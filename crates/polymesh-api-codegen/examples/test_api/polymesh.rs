#[allow(dead_code, unused_imports, non_camel_case_types)]
pub mod types {
  use super::WrappedCall;
  pub mod finality_grandpa {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Equivocation<Id, V, S> {
      pub round_number: u64,
      pub identity: Id,
      pub first: (V, S),
      pub second: (V, S),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Precommit<H, N> {
      pub target_hash: H,
      pub target_number: N,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Prevote<H, N> {
      pub target_hash: H,
      pub target_number: N,
    }
  }
  pub mod frame_support {
    use super::*;
    pub mod dispatch {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum DispatchClass {
        #[codec(index = 0u8)]
        Normal,
        #[codec(index = 1u8)]
        Operational,
        #[codec(index = 2u8)]
        Mandatory,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DispatchInfo {
        pub weight: ::polymesh_api_client::sp_weights::Weight,
        pub class: frame_support::dispatch::DispatchClass,
        pub pays_fee: frame_support::dispatch::Pays,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Pays {
        #[codec(index = 0u8)]
        Yes,
        #[codec(index = 1u8)]
        No,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PerDispatchClass<T> {
        pub normal: T,
        pub operational: T,
        pub mandatory: T,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum RawOrigin<AccountId> {
        #[codec(index = 0u8)]
        Root,
        #[codec(index = 1u8)]
        Signed(AccountId),
        #[codec(index = 2u8)]
        None,
      }
    }
    pub mod traits {
      use super::*;
      pub mod misc {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct WrapperOpaque<T>(#[codec(compact)] pub u32, pub T);
      }
      pub mod preimages {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Bounded<T> {
          #[codec(index = 0u8)]
          Legacy {
            hash: primitive_types::H256,
          },
          #[codec(index = 1u8)]
          Inline(::alloc::vec::Vec<u8>),
          #[codec(index = 2u8)]
          Lookup {
            hash: primitive_types::H256,
            len: u32,
          },
          PhantomDataVariant(core::marker::PhantomData<T>),
        }
      }
      pub mod tokens {
        use super::*;
        pub mod misc {
          use super::*;
          #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
          #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
          )]
          #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
          pub enum BalanceStatus {
            #[codec(index = 0u8)]
            Free,
            #[codec(index = 1u8)]
            Reserved,
          }
        }
      }
    }
  }
  pub mod frame_system {
    use super::*;
    pub mod extensions {
      use super::*;
      pub mod check_genesis {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckGenesis();
      }
      pub mod check_mortality {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckMortality(pub ::polymesh_api_client::Era);
      }
      pub mod check_nonce {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckNonce(#[codec(compact)] pub u32);
      }
      pub mod check_spec_version {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckSpecVersion();
      }
      pub mod check_tx_version {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckTxVersion();
      }
      pub mod check_weight {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckWeight();
      }
    }
    pub mod limits {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BlockLength {
        pub max: frame_support::dispatch::PerDispatchClass<u32>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BlockWeights {
        pub base_block: ::polymesh_api_client::sp_weights::Weight,
        pub max_block: ::polymesh_api_client::sp_weights::Weight,
        pub per_class:
          frame_support::dispatch::PerDispatchClass<frame_system::limits::WeightsPerClass>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct WeightsPerClass {
        pub base_extrinsic: ::polymesh_api_client::sp_weights::Weight,
        pub max_extrinsic: Option<::polymesh_api_client::sp_weights::Weight>,
        pub max_total: Option<::polymesh_api_client::sp_weights::Weight>,
        pub reserved: Option<::polymesh_api_client::sp_weights::Weight>,
      }
    }
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SystemCall {
        #[doc = "Make some on-chain remark."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`"]
        #[codec(index = 0u8)]
        remark { remark: ::alloc::vec::Vec<u8> },
        #[doc = "Set the number of pages in the WebAssembly environment's heap."]
        #[codec(index = 1u8)]
        set_heap_pages { pages: u64 },
        #[doc = "Set the new runtime code."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"]
        #[codec(index = 2u8)]
        set_code { code: ::alloc::vec::Vec<u8> },
        #[doc = "Set the new runtime code without doing any checks of the given `code`."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(C)` where `C` length of `code`"]
        #[codec(index = 3u8)]
        set_code_without_checks { code: ::alloc::vec::Vec<u8> },
        #[doc = "Set some items of storage."]
        #[codec(index = 4u8)]
        set_storage {
          items: ::alloc::vec::Vec<(::alloc::vec::Vec<u8>, ::alloc::vec::Vec<u8>)>,
        },
        #[doc = "Kill some items from storage."]
        #[codec(index = 5u8)]
        kill_storage {
          keys: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
        },
        #[doc = "Kill all storage items with a key that starts with the given prefix."]
        #[doc = ""]
        #[doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"]
        #[doc = "the prefix we are removing to accurately calculate the weight of this function."]
        #[codec(index = 6u8)]
        kill_prefix {
          prefix: ::alloc::vec::Vec<u8>,
          subkeys: u32,
        },
        #[doc = "Make some on-chain remark and emit event."]
        #[codec(index = 7u8)]
        remark_with_event { remark: ::alloc::vec::Vec<u8> },
      }
      impl SystemCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::remark { .. } => "System.remark",
            Self::set_heap_pages { .. } => "System.set_heap_pages",
            Self::set_code { .. } => "System.set_code",
            Self::set_code_without_checks { .. } => "System.set_code_without_checks",
            Self::set_storage { .. } => "System.set_storage",
            Self::kill_storage { .. } => "System.kill_storage",
            Self::kill_prefix { .. } => "System.kill_prefix",
            Self::remark_with_event { .. } => "System.remark_with_event",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SystemCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::remark { .. } => &[
              "Make some on-chain remark.",
              "",
              "## Complexity",
              "- `O(1)`",
            ],
            Self::set_heap_pages { .. } => {
              &["Set the number of pages in the WebAssembly environment's heap."]
            }
            Self::set_code { .. } => &[
              "Set the new runtime code.",
              "",
              "## Complexity",
              "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`",
            ],
            Self::set_code_without_checks { .. } => &[
              "Set the new runtime code without doing any checks of the given `code`.",
              "",
              "## Complexity",
              "- `O(C)` where `C` length of `code`",
            ],
            Self::set_storage { .. } => &["Set some items of storage."],
            Self::kill_storage { .. } => &["Kill some items from storage."],
            Self::kill_prefix { .. } => &[
              "Kill all storage items with a key that starts with the given prefix.",
              "",
              "**NOTE:** We rely on the Root origin to provide us the number of subkeys under",
              "the prefix we are removing to accurately calculate the weight of this function.",
            ],
            Self::remark_with_event { .. } => &["Make some on-chain remark and emit event."],
            _ => &[""],
          }
        }
      }
      impl From<SystemCall> for &'static str {
        fn from(v: SystemCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SystemCall> for &'static str {
        fn from(v: &SystemCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Error for the System pallet"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SystemError {
        #[doc = "The name of specification does not match between the current runtime"]
        #[doc = "and the new runtime."]
        #[codec(index = 0u8)]
        InvalidSpecName,
        #[doc = "The specification version is not allowed to decrease between the current runtime"]
        #[doc = "and the new runtime."]
        #[codec(index = 1u8)]
        SpecVersionNeedsToIncrease,
        #[doc = "Failed to extract the runtime version from the new runtime."]
        #[doc = ""]
        #[doc = "Either calling `Core_version` or decoding `RuntimeVersion` failed."]
        #[codec(index = 2u8)]
        FailedToExtractRuntimeVersion,
        #[doc = "Suicide called when the account has non-default composite data."]
        #[codec(index = 3u8)]
        NonDefaultComposite,
        #[doc = "There is a non-zero reference count preventing the account from being purged."]
        #[codec(index = 4u8)]
        NonZeroRefCount,
        #[doc = "The origin filter prevent the call to be dispatched."]
        #[codec(index = 5u8)]
        CallFiltered,
      }
      impl SystemError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidSpecName => "System.InvalidSpecName",
            Self::SpecVersionNeedsToIncrease => "System.SpecVersionNeedsToIncrease",
            Self::FailedToExtractRuntimeVersion => "System.FailedToExtractRuntimeVersion",
            Self::NonDefaultComposite => "System.NonDefaultComposite",
            Self::NonZeroRefCount => "System.NonZeroRefCount",
            Self::CallFiltered => "System.CallFiltered",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SystemError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidSpecName => &[
              "The name of specification does not match between the current runtime",
              "and the new runtime.",
            ],
            Self::SpecVersionNeedsToIncrease => &[
              "The specification version is not allowed to decrease between the current runtime",
              "and the new runtime.",
            ],
            Self::FailedToExtractRuntimeVersion => &[
              "Failed to extract the runtime version from the new runtime.",
              "",
              "Either calling `Core_version` or decoding `RuntimeVersion` failed.",
            ],
            Self::NonDefaultComposite => {
              &["Suicide called when the account has non-default composite data."]
            }
            Self::NonZeroRefCount => {
              &["There is a non-zero reference count preventing the account from being purged."]
            }
            Self::CallFiltered => &["The origin filter prevent the call to be dispatched."],
            _ => &[""],
          }
        }
      }
      impl From<SystemError> for &'static str {
        fn from(v: SystemError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SystemError> for &'static str {
        fn from(v: &SystemError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Event for the System pallet."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SystemEvent {
        #[doc = "An extrinsic completed successfully."]
        #[codec(index = 0u8)]
        ExtrinsicSuccess {
          dispatch_info: frame_support::dispatch::DispatchInfo,
        },
        #[doc = "An extrinsic failed."]
        #[codec(index = 1u8)]
        ExtrinsicFailed {
          dispatch_error: sp_runtime::DispatchError,
          dispatch_info: frame_support::dispatch::DispatchInfo,
        },
        #[doc = "`:code` was updated."]
        #[codec(index = 2u8)]
        CodeUpdated,
        #[doc = "A new account was created."]
        #[codec(index = 3u8)]
        NewAccount {
          account: ::polymesh_api_client::AccountId,
        },
        #[doc = "An account was reaped."]
        #[codec(index = 4u8)]
        KilledAccount {
          account: ::polymesh_api_client::AccountId,
        },
        #[doc = "On on-chain remark happened."]
        #[codec(index = 5u8)]
        Remarked {
          sender: ::polymesh_api_client::AccountId,
          hash: primitive_types::H256,
        },
      }
      impl SystemEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::ExtrinsicSuccess { .. } => "System.ExtrinsicSuccess",
            Self::ExtrinsicFailed { .. } => "System.ExtrinsicFailed",
            Self::CodeUpdated => "System.CodeUpdated",
            Self::NewAccount { .. } => "System.NewAccount",
            Self::KilledAccount { .. } => "System.KilledAccount",
            Self::Remarked { .. } => "System.Remarked",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SystemEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::ExtrinsicSuccess { .. } => &["An extrinsic completed successfully."],
            Self::ExtrinsicFailed { .. } => &["An extrinsic failed."],
            Self::CodeUpdated => &["`:code` was updated."],
            Self::NewAccount { .. } => &["A new account was created."],
            Self::KilledAccount { .. } => &["An account was reaped."],
            Self::Remarked { .. } => &["On on-chain remark happened."],
            _ => &[""],
          }
        }
      }
      impl From<SystemEvent> for &'static str {
        fn from(v: SystemEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SystemEvent> for &'static str {
        fn from(v: &SystemEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct AccountInfo<Index, AccountData> {
      pub nonce: Index,
      pub consumers: Index,
      pub providers: Index,
      pub sufficients: Index,
      pub data: AccountData,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct EventRecord<E, T> {
      pub phase: frame_system::Phase,
      pub event: E,
      pub topics: ::alloc::vec::Vec<T>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct LastRuntimeUpgradeInfo {
      #[codec(compact)]
      pub spec_version: u32,
      pub spec_name: ::alloc::string::String,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Phase {
      #[codec(index = 0u8)]
      ApplyExtrinsic(u32),
      #[codec(index = 1u8)]
      Finalization,
      #[codec(index = 2u8)]
      Initialization,
    }
  }
  pub mod pallet_asset {
    use super::*;
    pub mod checkpoint {
      use super::*;
      #[doc = "Dispatchable calls."]
      #[doc = ""]
      #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CheckpointCall {
        #[doc = "Creates a single checkpoint at the current time."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `asset_id`."]
        #[doc = "- `asset_id` to create the checkpoint for."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
        #[doc = "- `CounterOverflow` if the total checkpoint counter would overflow."]
        #[codec(index = 0u8)]
        create_checkpoint {
          asset_id: ::polymesh_api_client::AssetId,
        },
        #[doc = "Sets the max complexity of a schedule set for an arbitrary asset_id to `max_complexity`."]
        #[doc = "The new maximum is not enforced retroactively,"]
        #[doc = "and only applies once new schedules are made."]
        #[doc = ""]
        #[doc = "Must be called as a PIP (requires \"root\")."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "- `origin` is the root origin."]
        #[doc = "- `max_complexity` allowed for an arbitrary asset's schedule set."]
        #[codec(index = 1u8)]
        set_schedules_max_complexity { max_complexity: u64 },
        #[doc = "Creates a schedule generating checkpoints"]
        #[doc = "in the future at either a fixed time or at intervals."]
        #[doc = ""]
        #[doc = "The schedule starts out with `strong_ref_count(schedule_id) <- 0`."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
        #[doc = "- `asset_id` to create the schedule for."]
        #[doc = "- `schedule` that will generate checkpoints."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
        #[doc = "- `InsufficientAccountBalance` if the protocol fee could not be charged."]
        #[doc = "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow."]
        #[doc = ""]
        #[doc = "# Permissions"]
        #[doc = "* Asset"]
        #[codec(index = 2u8)]
        create_schedule {
          asset_id: ::polymesh_api_client::AssetId,
          schedule: polymesh_primitives::checkpoint::ScheduleCheckpoints,
        },
        #[doc = "Removes the checkpoint schedule of an asset identified by `id`."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
        #[doc = "- `asset_id` to remove the schedule from."]
        #[doc = "- `id` of the schedule, when it was created by `created_schedule`."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
        #[doc = "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `asset_id`."]
        #[doc = "- `ScheduleNotRemovable` if `id` exists but is not removable."]
        #[doc = ""]
        #[doc = "# Permissions"]
        #[doc = "* Asset"]
        #[codec(index = 3u8)]
        remove_schedule {
          asset_id: ::polymesh_api_client::AssetId,
          id: polymesh_primitives::checkpoint::ScheduleId,
        },
      }
      impl CheckpointCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::create_checkpoint { .. } => "Checkpoint.create_checkpoint",
            Self::set_schedules_max_complexity { .. } => "Checkpoint.set_schedules_max_complexity",
            Self::create_schedule { .. } => "Checkpoint.create_schedule",
            Self::remove_schedule { .. } => "Checkpoint.remove_schedule",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CheckpointCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: create_checkpoint { .. } => { & ["Creates a single checkpoint at the current time." , "" , "# Arguments" , "- `origin` is a signer that has permissions to act as an agent of `asset_id`." , "- `asset_id` to create the checkpoint for." , "" , "# Errors" , "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`." , "- `CounterOverflow` if the total checkpoint counter would overflow." ,] } , Self :: set_schedules_max_complexity { .. } => { & ["Sets the max complexity of a schedule set for an arbitrary asset_id to `max_complexity`." , "The new maximum is not enforced retroactively," , "and only applies once new schedules are made." , "" , "Must be called as a PIP (requires \"root\")." , "" , "# Arguments" , "- `origin` is the root origin." , "- `max_complexity` allowed for an arbitrary asset's schedule set." ,] } , Self :: create_schedule { .. } => { & ["Creates a schedule generating checkpoints" , "in the future at either a fixed time or at intervals." , "" , "The schedule starts out with `strong_ref_count(schedule_id) <- 0`." , "" , "# Arguments" , "- `origin` is a signer that has permissions to act as owner of `asset_id`." , "- `asset_id` to create the schedule for." , "- `schedule` that will generate checkpoints." , "" , "# Errors" , "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`." , "- `InsufficientAccountBalance` if the protocol fee could not be charged." , "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_schedule { .. } => { & ["Removes the checkpoint schedule of an asset identified by `id`." , "" , "# Arguments" , "- `origin` is a signer that has permissions to act as owner of `asset_id`." , "- `asset_id` to remove the schedule from." , "- `id` of the schedule, when it was created by `created_schedule`." , "" , "# Errors" , "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`." , "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `asset_id`." , "- `ScheduleNotRemovable` if `id` exists but is not removable." , "" , "# Permissions" , "* Asset" ,] } , _ => & [""] , }
        }
      }
      impl From<CheckpointCall> for &'static str {
        fn from(v: CheckpointCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CheckpointCall> for &'static str {
        fn from(v: &CheckpointCall) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CheckpointError {
        #[doc = "A checkpoint schedule does not exist for the asset."]
        #[codec(index = 0u8)]
        NoSuchSchedule,
        #[doc = "A checkpoint schedule is not removable as `ref_count(schedule_id) > 0`."]
        #[codec(index = 1u8)]
        ScheduleNotRemovable,
        #[doc = "The new schedule would put the asset over the maximum complexity allowed."]
        #[codec(index = 2u8)]
        SchedulesOverMaxComplexity,
        #[doc = "Can't create an empty schedule."]
        #[codec(index = 3u8)]
        ScheduleIsEmpty,
        #[doc = "The schedule has no more checkpoints."]
        #[codec(index = 4u8)]
        ScheduleFinished,
        #[doc = "The schedule has expired checkpoints."]
        #[codec(index = 5u8)]
        ScheduleHasExpiredCheckpoints,
      }
      impl CheckpointError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::NoSuchSchedule => "Checkpoint.NoSuchSchedule",
            Self::ScheduleNotRemovable => "Checkpoint.ScheduleNotRemovable",
            Self::SchedulesOverMaxComplexity => "Checkpoint.SchedulesOverMaxComplexity",
            Self::ScheduleIsEmpty => "Checkpoint.ScheduleIsEmpty",
            Self::ScheduleFinished => "Checkpoint.ScheduleFinished",
            Self::ScheduleHasExpiredCheckpoints => "Checkpoint.ScheduleHasExpiredCheckpoints",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CheckpointError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::NoSuchSchedule => &["A checkpoint schedule does not exist for the asset."],
            Self::ScheduleNotRemovable => {
              &["A checkpoint schedule is not removable as `ref_count(schedule_id) > 0`."]
            }
            Self::SchedulesOverMaxComplexity => {
              &["The new schedule would put the asset over the maximum complexity allowed."]
            }
            Self::ScheduleIsEmpty => &["Can't create an empty schedule."],
            Self::ScheduleFinished => &["The schedule has no more checkpoints."],
            Self::ScheduleHasExpiredCheckpoints => &["The schedule has expired checkpoints."],
            _ => &[""],
          }
        }
      }
      impl From<CheckpointError> for &'static str {
        fn from(v: CheckpointError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CheckpointError> for &'static str {
        fn from(v: &CheckpointError) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Version(pub u8);
    }
    pub mod error {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AssetError {
        #[doc = "The user is not authorized."]
        #[codec(index = 0u8)]
        Unauthorized,
        #[doc = "The token has already been created."]
        #[codec(index = 1u8)]
        AssetAlreadyCreated,
        #[doc = "The ticker length is over the limit."]
        #[codec(index = 2u8)]
        TickerTooLong,
        #[doc = "The ticker has non-alphanumeric parts."]
        #[codec(index = 3u8)]
        TickerNotAlphanumeric,
        #[doc = "The ticker is already registered to someone else."]
        #[codec(index = 4u8)]
        TickerAlreadyRegistered,
        #[doc = "The total supply is above the limit."]
        #[codec(index = 5u8)]
        TotalSupplyAboveLimit,
        #[doc = "No token associated to the given asset ID."]
        #[codec(index = 6u8)]
        NoSuchAsset,
        #[doc = "The token is already frozen."]
        #[codec(index = 7u8)]
        AlreadyFrozen,
        #[doc = "Not an owner of the token on Ethereum."]
        #[codec(index = 8u8)]
        NotAnOwner,
        #[doc = "An overflow while calculating the balance."]
        #[codec(index = 9u8)]
        BalanceOverflow,
        #[doc = "An overflow while calculating the total supply."]
        #[codec(index = 10u8)]
        TotalSupplyOverflow,
        #[doc = "An invalid granularity."]
        #[codec(index = 11u8)]
        InvalidGranularity,
        #[doc = "The asset must be frozen."]
        #[codec(index = 12u8)]
        NotFrozen,
        #[doc = "Transfer validation check failed."]
        #[codec(index = 13u8)]
        InvalidTransfer,
        #[doc = "The sender balance is not sufficient."]
        #[codec(index = 14u8)]
        InsufficientBalance,
        #[doc = "The token is already divisible."]
        #[codec(index = 15u8)]
        AssetAlreadyDivisible,
        #[doc = "An invalid Ethereum `EcdsaSignature`."]
        #[codec(index = 16u8)]
        InvalidEthereumSignature,
        #[doc = "Registration of ticker has expired."]
        #[codec(index = 17u8)]
        TickerRegistrationExpired,
        #[doc = "Transfers to self are not allowed"]
        #[codec(index = 18u8)]
        SenderSameAsReceiver,
        #[doc = "The given Document does not exist."]
        #[codec(index = 19u8)]
        NoSuchDoc,
        #[doc = "Maximum length of asset name has been exceeded."]
        #[codec(index = 20u8)]
        MaxLengthOfAssetNameExceeded,
        #[doc = "Maximum length of the funding round name has been exceeded."]
        #[codec(index = 21u8)]
        FundingRoundNameMaxLengthExceeded,
        #[doc = "Some `AssetIdentifier` was invalid."]
        #[codec(index = 22u8)]
        InvalidAssetIdentifier,
        #[doc = "Investor Uniqueness claims are not allowed for this asset."]
        #[codec(index = 23u8)]
        InvestorUniquenessClaimNotAllowed,
        #[doc = "Invalid `CustomAssetTypeId`."]
        #[codec(index = 24u8)]
        InvalidCustomAssetTypeId,
        #[doc = "Maximum length of the asset metadata type name has been exceeded."]
        #[codec(index = 25u8)]
        AssetMetadataNameMaxLengthExceeded,
        #[doc = "Maximum length of the asset metadata value has been exceeded."]
        #[codec(index = 26u8)]
        AssetMetadataValueMaxLengthExceeded,
        #[doc = "Maximum length of the asset metadata type definition has been exceeded."]
        #[codec(index = 27u8)]
        AssetMetadataTypeDefMaxLengthExceeded,
        #[doc = "Asset Metadata key is missing."]
        #[codec(index = 28u8)]
        AssetMetadataKeyIsMissing,
        #[doc = "Asset Metadata value is locked."]
        #[codec(index = 29u8)]
        AssetMetadataValueIsLocked,
        #[doc = "Asset Metadata Local type already exists for asset."]
        #[codec(index = 30u8)]
        AssetMetadataLocalKeyAlreadyExists,
        #[doc = "Asset Metadata Global type already exists."]
        #[codec(index = 31u8)]
        AssetMetadataGlobalKeyAlreadyExists,
        #[doc = "Tickers should start with at least one valid byte."]
        #[codec(index = 32u8)]
        TickerFirstByteNotValid,
        #[doc = "Attempt to call an extrinsic that is only permitted for fungible tokens."]
        #[codec(index = 33u8)]
        UnexpectedNonFungibleToken,
        #[doc = "Attempt to update the type of a non fungible token to a fungible token or the other way around."]
        #[codec(index = 34u8)]
        IncompatibleAssetTypeUpdate,
        #[doc = "Attempt to delete a key that is needed for an NFT collection."]
        #[codec(index = 35u8)]
        AssetMetadataKeyBelongsToNFTCollection,
        #[doc = "Attempt to lock a metadata value that is empty."]
        #[codec(index = 36u8)]
        AssetMetadataValueIsEmpty,
        #[doc = "Number of asset mediators would exceed the maximum allowed."]
        #[codec(index = 37u8)]
        NumberOfAssetMediatorsExceeded,
        #[doc = "Invalid ticker character - valid set: A`..`Z` `0`..`9` `_` `-` `.` `/`."]
        #[codec(index = 38u8)]
        InvalidTickerCharacter,
        #[doc = "Failed to transfer the asset - asset is frozen."]
        #[codec(index = 39u8)]
        InvalidTransferFrozenAsset,
        #[doc = "Failed to transfer an NFT - compliance failed."]
        #[codec(index = 40u8)]
        InvalidTransferComplianceFailure,
        #[doc = "Failed to transfer the asset - receiver cdd is not valid."]
        #[codec(index = 41u8)]
        InvalidTransferInvalidReceiverCDD,
        #[doc = "Failed to transfer the asset - sender cdd is not valid."]
        #[codec(index = 42u8)]
        InvalidTransferInvalidSenderCDD,
        #[doc = "The ticker registration associated to the ticker was not found."]
        #[codec(index = 43u8)]
        TickerRegistrationNotFound,
        #[doc = "The given ticker is already linked to an asset."]
        #[codec(index = 44u8)]
        TickerIsAlreadyLinkedToAnAsset,
        #[doc = "An unexpected error when generating a new asset ID."]
        #[codec(index = 45u8)]
        AssetIdGenerationError,
        #[doc = "The ticker doesn't belong to the caller."]
        #[codec(index = 46u8)]
        TickerNotRegisteredToCaller,
        #[doc = "The given asset is already linked to a ticker."]
        #[codec(index = 47u8)]
        AssetIsAlreadyLinkedToATicker,
        #[doc = "The given ticker is not linked to the given asset."]
        #[codec(index = 48u8)]
        TickerIsNotLinkedToTheAsset,
      }
      impl AssetError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Unauthorized => "Asset.Unauthorized",
            Self::AssetAlreadyCreated => "Asset.AssetAlreadyCreated",
            Self::TickerTooLong => "Asset.TickerTooLong",
            Self::TickerNotAlphanumeric => "Asset.TickerNotAlphanumeric",
            Self::TickerAlreadyRegistered => "Asset.TickerAlreadyRegistered",
            Self::TotalSupplyAboveLimit => "Asset.TotalSupplyAboveLimit",
            Self::NoSuchAsset => "Asset.NoSuchAsset",
            Self::AlreadyFrozen => "Asset.AlreadyFrozen",
            Self::NotAnOwner => "Asset.NotAnOwner",
            Self::BalanceOverflow => "Asset.BalanceOverflow",
            Self::TotalSupplyOverflow => "Asset.TotalSupplyOverflow",
            Self::InvalidGranularity => "Asset.InvalidGranularity",
            Self::NotFrozen => "Asset.NotFrozen",
            Self::InvalidTransfer => "Asset.InvalidTransfer",
            Self::InsufficientBalance => "Asset.InsufficientBalance",
            Self::AssetAlreadyDivisible => "Asset.AssetAlreadyDivisible",
            Self::InvalidEthereumSignature => "Asset.InvalidEthereumSignature",
            Self::TickerRegistrationExpired => "Asset.TickerRegistrationExpired",
            Self::SenderSameAsReceiver => "Asset.SenderSameAsReceiver",
            Self::NoSuchDoc => "Asset.NoSuchDoc",
            Self::MaxLengthOfAssetNameExceeded => "Asset.MaxLengthOfAssetNameExceeded",
            Self::FundingRoundNameMaxLengthExceeded => "Asset.FundingRoundNameMaxLengthExceeded",
            Self::InvalidAssetIdentifier => "Asset.InvalidAssetIdentifier",
            Self::InvestorUniquenessClaimNotAllowed => "Asset.InvestorUniquenessClaimNotAllowed",
            Self::InvalidCustomAssetTypeId => "Asset.InvalidCustomAssetTypeId",
            Self::AssetMetadataNameMaxLengthExceeded => "Asset.AssetMetadataNameMaxLengthExceeded",
            Self::AssetMetadataValueMaxLengthExceeded => {
              "Asset.AssetMetadataValueMaxLengthExceeded"
            }
            Self::AssetMetadataTypeDefMaxLengthExceeded => {
              "Asset.AssetMetadataTypeDefMaxLengthExceeded"
            }
            Self::AssetMetadataKeyIsMissing => "Asset.AssetMetadataKeyIsMissing",
            Self::AssetMetadataValueIsLocked => "Asset.AssetMetadataValueIsLocked",
            Self::AssetMetadataLocalKeyAlreadyExists => "Asset.AssetMetadataLocalKeyAlreadyExists",
            Self::AssetMetadataGlobalKeyAlreadyExists => {
              "Asset.AssetMetadataGlobalKeyAlreadyExists"
            }
            Self::TickerFirstByteNotValid => "Asset.TickerFirstByteNotValid",
            Self::UnexpectedNonFungibleToken => "Asset.UnexpectedNonFungibleToken",
            Self::IncompatibleAssetTypeUpdate => "Asset.IncompatibleAssetTypeUpdate",
            Self::AssetMetadataKeyBelongsToNFTCollection => {
              "Asset.AssetMetadataKeyBelongsToNFTCollection"
            }
            Self::AssetMetadataValueIsEmpty => "Asset.AssetMetadataValueIsEmpty",
            Self::NumberOfAssetMediatorsExceeded => "Asset.NumberOfAssetMediatorsExceeded",
            Self::InvalidTickerCharacter => "Asset.InvalidTickerCharacter",
            Self::InvalidTransferFrozenAsset => "Asset.InvalidTransferFrozenAsset",
            Self::InvalidTransferComplianceFailure => "Asset.InvalidTransferComplianceFailure",
            Self::InvalidTransferInvalidReceiverCDD => "Asset.InvalidTransferInvalidReceiverCDD",
            Self::InvalidTransferInvalidSenderCDD => "Asset.InvalidTransferInvalidSenderCDD",
            Self::TickerRegistrationNotFound => "Asset.TickerRegistrationNotFound",
            Self::TickerIsAlreadyLinkedToAnAsset => "Asset.TickerIsAlreadyLinkedToAnAsset",
            Self::AssetIdGenerationError => "Asset.AssetIdGenerationError",
            Self::TickerNotRegisteredToCaller => "Asset.TickerNotRegisteredToCaller",
            Self::AssetIsAlreadyLinkedToATicker => "Asset.AssetIsAlreadyLinkedToATicker",
            Self::TickerIsNotLinkedToTheAsset => "Asset.TickerIsNotLinkedToTheAsset",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for AssetError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: Unauthorized => { & ["The user is not authorized." ,] } , Self :: AssetAlreadyCreated => { & ["The token has already been created." ,] } , Self :: TickerTooLong => { & ["The ticker length is over the limit." ,] } , Self :: TickerNotAlphanumeric => { & ["The ticker has non-alphanumeric parts." ,] } , Self :: TickerAlreadyRegistered => { & ["The ticker is already registered to someone else." ,] } , Self :: TotalSupplyAboveLimit => { & ["The total supply is above the limit." ,] } , Self :: NoSuchAsset => { & ["No token associated to the given asset ID." ,] } , Self :: AlreadyFrozen => { & ["The token is already frozen." ,] } , Self :: NotAnOwner => { & ["Not an owner of the token on Ethereum." ,] } , Self :: BalanceOverflow => { & ["An overflow while calculating the balance." ,] } , Self :: TotalSupplyOverflow => { & ["An overflow while calculating the total supply." ,] } , Self :: InvalidGranularity => { & ["An invalid granularity." ,] } , Self :: NotFrozen => { & ["The asset must be frozen." ,] } , Self :: InvalidTransfer => { & ["Transfer validation check failed." ,] } , Self :: InsufficientBalance => { & ["The sender balance is not sufficient." ,] } , Self :: AssetAlreadyDivisible => { & ["The token is already divisible." ,] } , Self :: InvalidEthereumSignature => { & ["An invalid Ethereum `EcdsaSignature`." ,] } , Self :: TickerRegistrationExpired => { & ["Registration of ticker has expired." ,] } , Self :: SenderSameAsReceiver => { & ["Transfers to self are not allowed" ,] } , Self :: NoSuchDoc => { & ["The given Document does not exist." ,] } , Self :: MaxLengthOfAssetNameExceeded => { & ["Maximum length of asset name has been exceeded." ,] } , Self :: FundingRoundNameMaxLengthExceeded => { & ["Maximum length of the funding round name has been exceeded." ,] } , Self :: InvalidAssetIdentifier => { & ["Some `AssetIdentifier` was invalid." ,] } , Self :: InvestorUniquenessClaimNotAllowed => { & ["Investor Uniqueness claims are not allowed for this asset." ,] } , Self :: InvalidCustomAssetTypeId => { & ["Invalid `CustomAssetTypeId`." ,] } , Self :: AssetMetadataNameMaxLengthExceeded => { & ["Maximum length of the asset metadata type name has been exceeded." ,] } , Self :: AssetMetadataValueMaxLengthExceeded => { & ["Maximum length of the asset metadata value has been exceeded." ,] } , Self :: AssetMetadataTypeDefMaxLengthExceeded => { & ["Maximum length of the asset metadata type definition has been exceeded." ,] } , Self :: AssetMetadataKeyIsMissing => { & ["Asset Metadata key is missing." ,] } , Self :: AssetMetadataValueIsLocked => { & ["Asset Metadata value is locked." ,] } , Self :: AssetMetadataLocalKeyAlreadyExists => { & ["Asset Metadata Local type already exists for asset." ,] } , Self :: AssetMetadataGlobalKeyAlreadyExists => { & ["Asset Metadata Global type already exists." ,] } , Self :: TickerFirstByteNotValid => { & ["Tickers should start with at least one valid byte." ,] } , Self :: UnexpectedNonFungibleToken => { & ["Attempt to call an extrinsic that is only permitted for fungible tokens." ,] } , Self :: IncompatibleAssetTypeUpdate => { & ["Attempt to update the type of a non fungible token to a fungible token or the other way around." ,] } , Self :: AssetMetadataKeyBelongsToNFTCollection => { & ["Attempt to delete a key that is needed for an NFT collection." ,] } , Self :: AssetMetadataValueIsEmpty => { & ["Attempt to lock a metadata value that is empty." ,] } , Self :: NumberOfAssetMediatorsExceeded => { & ["Number of asset mediators would exceed the maximum allowed." ,] } , Self :: InvalidTickerCharacter => { & ["Invalid ticker character - valid set: A`..`Z` `0`..`9` `_` `-` `.` `/`." ,] } , Self :: InvalidTransferFrozenAsset => { & ["Failed to transfer the asset - asset is frozen." ,] } , Self :: InvalidTransferComplianceFailure => { & ["Failed to transfer an NFT - compliance failed." ,] } , Self :: InvalidTransferInvalidReceiverCDD => { & ["Failed to transfer the asset - receiver cdd is not valid." ,] } , Self :: InvalidTransferInvalidSenderCDD => { & ["Failed to transfer the asset - sender cdd is not valid." ,] } , Self :: TickerRegistrationNotFound => { & ["The ticker registration associated to the ticker was not found." ,] } , Self :: TickerIsAlreadyLinkedToAnAsset => { & ["The given ticker is already linked to an asset." ,] } , Self :: AssetIdGenerationError => { & ["An unexpected error when generating a new asset ID." ,] } , Self :: TickerNotRegisteredToCaller => { & ["The ticker doesn't belong to the caller." ,] } , Self :: AssetIsAlreadyLinkedToATicker => { & ["The given asset is already linked to a ticker." ,] } , Self :: TickerIsNotLinkedToTheAsset => { & ["The given ticker is not linked to the given asset." ,] } , _ => & [""] , }
        }
      }
      impl From<AssetError> for &'static str {
        fn from(v: AssetError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&AssetError> for &'static str {
        fn from(v: &AssetError) -> Self {
          v.as_static_str()
        }
      }
    }
    pub mod types {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetDetails {
        pub total_supply: u128,
        pub owner_did: ::polymesh_api_client::IdentityId,
        pub divisible: bool,
        pub asset_type: polymesh_primitives::asset::AssetType,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct TickerRegistration<T> {
        pub owner: ::polymesh_api_client::IdentityId,
        pub expiry: Option<T>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct TickerRegistrationConfig<T> {
        pub max_ticker_length: u8,
        pub registration_length: Option<T>,
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum AssetCall {
      #[doc = "Registers a unique ticker or extends the validity of an existing ticker."]
      #[doc = ""]
      #[doc = "This function allows the caller to register a new ticker or extend the registration"]
      #[doc = "of an existing ticker. The ticker validity does not carry forward when renewing."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ticker` - The ticker to register."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerRegistered` - When a ticker is successfully registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerAlreadyRegistered` - If the ticker is already registered."]
      #[doc = "* `TickerTooLong` - If the ticker length exceeds the maximum allowed length."]
      #[doc = "* `InvalidTickerCharacter` - If the ticker contains invalid characters."]
      #[codec(index = 0u8)]
      register_unique_ticker {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Accepts a ticker transfer."]
      #[doc = ""]
      #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `auth_id` - Authorization ID of ticker transfer authorization."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerTransferred` - When a ticker is successfully transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
      #[codec(index = 1u8)]
      accept_ticker_transfer { auth_id: u64 },
      #[doc = "Accepts an asset ownership transfer."]
      #[doc = ""]
      #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `auth_id` - Authorization ID of the asset ownership transfer authorization."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetOwnershipTransferred` - When a asset ownership is successfully transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
      #[codec(index = 2u8)]
      accept_asset_ownership_transfer { auth_id: u64 },
      #[doc = "Creates a new asset."]
      #[doc = ""]
      #[doc = "The total supply will initially be zero. To mint tokens, use [`Module::issue`]."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
      #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
      #[doc = "* `asset_type` - The [`AssetType`] of the new asset."]
      #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
      #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetCreated` - When a new asset is successfully created."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
      #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
      #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
      #[codec(index = 3u8)]
      create_asset {
        asset_name: polymesh_primitives::asset::AssetName,
        divisible: bool,
        asset_type: polymesh_primitives::asset::AssetType,
        asset_identifiers:
          ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
        funding_round_name: Option<polymesh_primitives::asset::FundingRoundName>,
      },
      #[doc = "Freezes transfers of a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to freeze transfers of a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The asset to freeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetFrozen` - When an asset is successfully frozen."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `AlreadyFrozen` - If the asset is already frozen."]
      #[codec(index = 4u8)]
      freeze {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Unfreezes transfers of a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to unfreeze transfers of a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The asset to unfreeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetUnfrozen` - When an asset is successfully unfrozen."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `NotFrozen` - If the asset is not frozen."]
      #[codec(index = 5u8)]
      unfreeze {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Updates the [`AssetName`] associated to an asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to update the name of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `asset_name` - The new [`AssetName`] that will be associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetRenamed` - When an asset is successfully renamed."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[codec(index = 6u8)]
      rename_asset {
        asset_id: ::polymesh_api_client::AssetId,
        asset_name: polymesh_primitives::asset::AssetName,
      },
      #[doc = "Issue (i.e mint) new tokens to the caller, which must be an authorized external agent."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to mint new tokens for a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: A signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
      #[doc = "* `amount`: The amount of tokens that will be issued."]
      #[doc = "* `portfolio_kind`: The [`PortfolioKind`] of the portfolio that will receive the minted tokens."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `InvalidGranularity` - If the amount to issue does not meet the granularity requirements."]
      #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
      #[codec(index = 7u8)]
      issue {
        asset_id: ::polymesh_api_client::AssetId,
        amount: u128,
        portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
      },
      #[doc = "Redeems (i.e burns) existing tokens by reducing the balance of the caller's portfolio and the total supply of the asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to redeem tokens from a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
      #[doc = "* `value`: amount of tokens to redeem."]
      #[doc = "* `portfolio_kind`: the [`PortfolioKind`] that will have its balance reduced."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `InvalidGranularity` - If the value to redeem does not meet the granularity requirements."]
      #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
      #[codec(index = 8u8)]
      redeem {
        asset_id: ::polymesh_api_client::AssetId,
        value: u128,
        portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
      },
      #[doc = "If the asset associated to `asset_id` is indivisible, sets [`AssetDetails::divisible`] to true."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to make an indivisible asset divisible."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `DivisibilityChanged` - When the divisibility of an asset is successfully changed."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `AssetAlreadyDivisible` - If the asset is already divisible."]
      #[codec(index = 9u8)]
      make_divisible {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Add documents for a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to add documents to an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `docs` - Documents to be attached to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `DocumentAdded` - When a document is successfully added to an asset."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `CounterOverflow` - If the document ID counter overflows."]
      #[codec(index = 10u8)]
      add_documents {
        docs: ::alloc::vec::Vec<polymesh_primitives::document::Document>,
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Remove documents for a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove documents from an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `docs_id` - A vector of all [`DocumentId`] that will be removed from the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `DocumentRemoved` - When a document is successfully removed from an asset."]
      #[codec(index = 11u8)]
      remove_documents {
        docs_id: ::alloc::vec::Vec<polymesh_primitives::document::DocumentId>,
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Sets the name of the current funding round."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to set the name of the current funding round for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `funding_round_name` - The [`FundingRoundName`] of the current funding round."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `FundingRoundSet` - When the funding round name is successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FundingRoundNameMaxLengthExceeded` - If the funding round name length exceeds the maximum allowed length."]
      #[codec(index = 12u8)]
      set_funding_round {
        asset_id: ::polymesh_api_client::AssetId,
        funding_round_name: polymesh_primitives::asset::FundingRoundName,
      },
      #[doc = "Updates the asset identifiers associated to the asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to update the asset identifiers for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`] that will be associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `IdentifiersUpdated` - When the asset identifiers are successfully updated."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
      #[codec(index = 13u8)]
      update_identifiers {
        asset_id: ::polymesh_api_client::AssetId,
        asset_identifiers:
          ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
      },
      #[doc = "Forces a transfer of tokens from `from_portfolio` to the caller's default portfolio."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to force a transfer of tokens from one portfolio to another."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `value` - The [`Balance`] of tokens that will be transferred."]
      #[doc = "* `from_portfolio` - The [`PortfolioId`] that will have its balance reduced."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `ControllerTransfer` - When tokens are successfully transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `InvalidGranularity` - If the amount to transfer does not meet the granularity requirements."]
      #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
      #[codec(index = 14u8)]
      controller_transfer {
        asset_id: ::polymesh_api_client::AssetId,
        value: u128,
        from_portfolio: polymesh_primitives::identity_id::PortfolioId,
      },
      #[doc = "Registers a custom asset type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ty` - Contains the string representation of the asset type."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
      #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
      #[codec(index = 15u8)]
      register_custom_asset_type { ty: ::alloc::vec::Vec<u8> },
      #[doc = "Creates a new asset with a new custom asset type."]
      #[doc = ""]
      #[doc = "The total supply will initially be zero. To mint tokens, use [`Module::issue`]."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
      #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
      #[doc = "* `custom_asset_type` - The custom asset type of the asset."]
      #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
      #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetCreated` - When a new asset is successfully created."]
      #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
      #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
      #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
      #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
      #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
      #[codec(index = 16u8)]
      create_asset_with_custom_type {
        asset_name: polymesh_primitives::asset::AssetName,
        divisible: bool,
        custom_asset_type: ::alloc::vec::Vec<u8>,
        asset_identifiers:
          ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
        funding_round_name: Option<polymesh_primitives::asset::FundingRoundName>,
      },
      #[doc = "Set asset metadata value."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to set metadata for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
      #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
      #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
      #[codec(index = 17u8)]
      set_asset_metadata {
        asset_id: ::polymesh_api_client::AssetId,
        key: polymesh_primitives::asset_metadata::AssetMetadataKey,
        value: polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      },
      #[doc = "Set asset metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to set metadata details for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
      #[doc = "* `details` - The [`AssetMetadataValueDetail`] (expire, lock status) that will be associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `SetAssetMetadataValueDetails` - When the asset metadata value details are successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataValueIsEmpty` - If the metadata value is empty."]
      #[codec(index = 18u8)]
      set_asset_metadata_details {
        asset_id: ::polymesh_api_client::AssetId,
        key: polymesh_primitives::asset_metadata::AssetMetadataKey,
        detail: polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
      },
      #[doc = "Registers and set local asset metadata."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to register and set local metadata for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `name` - The [`AssetMetadataName`]."]
      #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
      #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
      #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
      #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
      #[codec(index = 19u8)]
      register_and_set_local_asset_metadata {
        asset_id: ::polymesh_api_client::AssetId,
        name: polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: polymesh_primitives::asset_metadata::AssetMetadataSpec,
        value: polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      },
      #[doc = "Registers asset metadata local type."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to register a local metadata type for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `name` - The [`AssetMetadataName`]."]
      #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
      #[codec(index = 20u8)]
      register_asset_metadata_local_type {
        asset_id: ::polymesh_api_client::AssetId,
        name: polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: polymesh_primitives::asset_metadata::AssetMetadataSpec,
      },
      #[doc = "Registers asset metadata global type."]
      #[doc = ""]
      #[doc = "This function allows the root origin to register a global metadata type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The root origin."]
      #[doc = "* `name` - The [`AssetMetadataName`]."]
      #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RegisterAssetMetadataGlobalType` - When the global asset metadata type is successfully registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataGlobalKeyAlreadyExists` - If the global metadata key already exists."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
      #[codec(index = 21u8)]
      register_asset_metadata_global_type {
        name: polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: polymesh_primitives::asset_metadata::AssetMetadataSpec,
      },
      #[doc = "Updates the type of an asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to update the type of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `asset_type` - The new [`AssetType`] of the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetTypeChanged` - When the asset type is successfully changed."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
      #[doc = "* `IncompatibleAssetTypeUpdate` - If the new asset type is incompatible with the existing asset type."]
      #[codec(index = 22u8)]
      update_asset_type {
        asset_id: ::polymesh_api_client::AssetId,
        asset_type: polymesh_primitives::asset::AssetType,
      },
      #[doc = "Removes the asset metadata key and value of a local key."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove a local metadata key and its value for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the local metadata key."]
      #[doc = "* `local_key` - The [`AssetMetadataLocalKey`] that will be removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `LocalMetadataKeyDeleted` - When the local metadata key is successfully deleted."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the local metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataKeyBelongsToNFTCollection` - If the metadata key belongs to an NFT collection."]
      #[codec(index = 23u8)]
      remove_local_metadata_key {
        asset_id: ::polymesh_api_client::AssetId,
        local_key: polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      },
      #[doc = "Removes the asset metadata value of a metadata key."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove a metadata value for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the metadata key."]
      #[doc = "* `metadata_key` - The [`AssetMetadataKey`] that will have its value deleted."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `MetadataValueDeleted` - When the metadata value is successfully deleted."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[codec(index = 24u8)]
      remove_metadata_value {
        asset_id: ::polymesh_api_client::AssetId,
        metadata_key: polymesh_primitives::asset_metadata::AssetMetadataKey,
      },
      #[doc = "Pre-approves the receivement of the asset for all identities."]
      #[doc = ""]
      #[doc = "This function allows the root origin to pre-approve the receivement of an asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The root origin."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetAffirmationExemption` - When the asset is successfully exempted from affirmation."]
      #[codec(index = 25u8)]
      exempt_asset_affirmation {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Removes the pre-approval of the asset for all identities."]
      #[doc = ""]
      #[doc = "This function allows the root origin to remove the pre-approval of an asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The root origin."]
      #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RemoveAssetAffirmationExemption` - When the asset's affirmation exemption is successfully removed."]
      #[codec(index = 26u8)]
      remove_asset_affirmation_exemption {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Pre-approves the receivement of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `PreApprovedAsset` - When the asset is successfully pre-approved for receivement."]
      #[codec(index = 27u8)]
      pre_approve_asset {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Removes the pre-approval of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RemovePreApprovedAsset` - When the asset's pre-approval is successfully removed."]
      #[codec(index = 28u8)]
      remove_asset_pre_approval {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Sets all identities in the `mediators` set as mandatory mediators for any instruction transferring `asset_id`."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to add mandatory mediators for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] of the asset that will require the mediators."]
      #[doc = "* `mediators` - A set of [`IdentityId`] of all the mandatory mediators for the given ticker."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetMediatorsAdded` - When the mandatory mediators are successfully added."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NumberOfAssetMediatorsExceeded` - If the number of mandatory mediators exceeds the maximum allowed limit."]
      #[codec(index = 29u8)]
      add_mandatory_mediators {
        asset_id: ::polymesh_api_client::AssetId,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      },
      #[doc = "Removes all identities in the `mediators` set from the mandatory mediators list for the given `asset_id`."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove mandatory mediators for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] of the asset that will have mediators removed."]
      #[doc = "* `mediators` - A set of [`IdentityId`] of all the mediators that will be removed from the mandatory mediators list."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetMediatorsRemoved` - When the mandatory mediators are successfully removed."]
      #[codec(index = 30u8)]
      remove_mandatory_mediators {
        asset_id: ::polymesh_api_client::AssetId,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      },
      #[doc = "Establishes a connection between a ticker and an AssetId."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to link a ticker to an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ticker` - The [`Ticker`] that will be linked to the given `asset_id`."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be connected to `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerLinkedToAsset` - When the ticker is successfully linked to the asset."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
      #[doc = "* `TickerRegistrationExpired` - If the ticker registration has expired."]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
      #[doc = "* `AssetIsAlreadyLinkedToATicker` - If the asset is already linked to a ticker."]
      #[codec(index = 31u8)]
      link_ticker_to_asset_id {
        ticker: polymesh_primitives::ticker::Ticker,
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Removes the link between a ticker and an asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to unlink a ticker from an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ticker` - The [`Ticker`] that will be unlinked from the given `asset_id`."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be unlinked from `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerUnlinkedFromAsset` - When the ticker is successfully unlinked from the asset."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsNotLinkedToTheAsset` - If the ticker is not linked to the asset."]
      #[codec(index = 32u8)]
      unlink_ticker_from_asset_id {
        ticker: polymesh_primitives::ticker::Ticker,
        asset_id: ::polymesh_api_client::AssetId,
      },
    }
    impl AssetCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::register_unique_ticker { .. } => "Asset.register_unique_ticker",
          Self::accept_ticker_transfer { .. } => "Asset.accept_ticker_transfer",
          Self::accept_asset_ownership_transfer { .. } => "Asset.accept_asset_ownership_transfer",
          Self::create_asset { .. } => "Asset.create_asset",
          Self::freeze { .. } => "Asset.freeze",
          Self::unfreeze { .. } => "Asset.unfreeze",
          Self::rename_asset { .. } => "Asset.rename_asset",
          Self::issue { .. } => "Asset.issue",
          Self::redeem { .. } => "Asset.redeem",
          Self::make_divisible { .. } => "Asset.make_divisible",
          Self::add_documents { .. } => "Asset.add_documents",
          Self::remove_documents { .. } => "Asset.remove_documents",
          Self::set_funding_round { .. } => "Asset.set_funding_round",
          Self::update_identifiers { .. } => "Asset.update_identifiers",
          Self::controller_transfer { .. } => "Asset.controller_transfer",
          Self::register_custom_asset_type { .. } => "Asset.register_custom_asset_type",
          Self::create_asset_with_custom_type { .. } => "Asset.create_asset_with_custom_type",
          Self::set_asset_metadata { .. } => "Asset.set_asset_metadata",
          Self::set_asset_metadata_details { .. } => "Asset.set_asset_metadata_details",
          Self::register_and_set_local_asset_metadata { .. } => {
            "Asset.register_and_set_local_asset_metadata"
          }
          Self::register_asset_metadata_local_type { .. } => {
            "Asset.register_asset_metadata_local_type"
          }
          Self::register_asset_metadata_global_type { .. } => {
            "Asset.register_asset_metadata_global_type"
          }
          Self::update_asset_type { .. } => "Asset.update_asset_type",
          Self::remove_local_metadata_key { .. } => "Asset.remove_local_metadata_key",
          Self::remove_metadata_value { .. } => "Asset.remove_metadata_value",
          Self::exempt_asset_affirmation { .. } => "Asset.exempt_asset_affirmation",
          Self::remove_asset_affirmation_exemption { .. } => {
            "Asset.remove_asset_affirmation_exemption"
          }
          Self::pre_approve_asset { .. } => "Asset.pre_approve_asset",
          Self::remove_asset_pre_approval { .. } => "Asset.remove_asset_pre_approval",
          Self::add_mandatory_mediators { .. } => "Asset.add_mandatory_mediators",
          Self::remove_mandatory_mediators { .. } => "Asset.remove_mandatory_mediators",
          Self::link_ticker_to_asset_id { .. } => "Asset.link_ticker_to_asset_id",
          Self::unlink_ticker_from_asset_id { .. } => "Asset.unlink_ticker_from_asset_id",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for AssetCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: register_unique_ticker { .. } => { & ["Registers a unique ticker or extends the validity of an existing ticker." , "" , "This function allows the caller to register a new ticker or extend the registration" , "of an existing ticker. The ticker validity does not carry forward when renewing." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `ticker` - The ticker to register." , "" , "# Events" , "* `TickerRegistered` - When a ticker is successfully registered." , "" , "# Errors" , "* `TickerAlreadyRegistered` - If the ticker is already registered." , "* `TickerTooLong` - If the ticker length exceeds the maximum allowed length." , "* `InvalidTickerCharacter` - If the ticker contains invalid characters." ,] } , Self :: accept_ticker_transfer { .. } => { & ["Accepts a ticker transfer." , "" , "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)." , "NB: To reject the transfer, call remove auth function in identity module." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `auth_id` - Authorization ID of ticker transfer authorization." , "" , "# Events" , "* `TickerTransferred` - When a ticker is successfully transferred." , "" , "# Errors" , "* `TickerRegistrationNotFound` - If the ticker registration is not found." , "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset." ,] } , Self :: accept_asset_ownership_transfer { .. } => { & ["Accepts an asset ownership transfer." , "" , "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)." , "NB: To reject the transfer, call remove auth function in identity module." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `auth_id` - Authorization ID of the asset ownership transfer authorization." , "" , "# Events" , "* `AssetOwnershipTransferred` - When a asset ownership is successfully transferred." , "" , "# Errors" , "* `TickerRegistrationNotFound` - If the ticker registration is not found." , "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset." ,] } , Self :: create_asset { .. } => { & ["Creates a new asset." , "" , "The total supply will initially be zero. To mint tokens, use [`Module::issue`]." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_name` - The [`AssetName`] of the new asset." , "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible." , "* `asset_type` - The [`AssetType`] of the new asset." , "* `asset_identifiers` - A vector of [`AssetIdentifier`]." , "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])." , "" , "# Events" , "* `AssetCreated` - When a new asset is successfully created." , "" , "# Errors" , "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length." , "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid." , "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid." ,] } , Self :: freeze { .. } => { & ["Freezes transfers of a given asset." , "" , "This function allows the asset issuer or an external agent to freeze transfers of a given asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The asset to freeze." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetFrozen` - When an asset is successfully frozen." , "" , "# Errors" , "* `NoSuchAsset` - If the asset does not exist." , "* `AlreadyFrozen` - If the asset is already frozen." ,] } , Self :: unfreeze { .. } => { & ["Unfreezes transfers of a given asset." , "" , "This function allows the asset issuer or an external agent to unfreeze transfers of a given asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The asset to unfreeze." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetUnfrozen` - When an asset is successfully unfrozen." , "" , "# Errors" , "* `NoSuchAsset` - If the asset does not exist." , "* `NotFrozen` - If the asset is not frozen." ,] } , Self :: rename_asset { .. } => { & ["Updates the [`AssetName`] associated to an asset." , "" , "This function allows the asset issuer or an external agent to update the name of an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `asset_name` - The new [`AssetName`] that will be associated to the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetRenamed` - When an asset is successfully renamed." , "" , "# Errors" , "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length." , "* `NoSuchAsset` - If the asset does not exist." ,] } , Self :: issue { .. } => { & ["Issue (i.e mint) new tokens to the caller, which must be an authorized external agent." , "" , "This function allows the asset issuer or an external agent to mint new tokens for a given asset." , "" , "# Arguments" , "* `origin`: A signer that has permissions to act as an agent of `ticker`." , "* `asset_id`: the [`AssetId`] associated to the asset." , "* `amount`: The amount of tokens that will be issued." , "* `portfolio_kind`: The [`PortfolioKind`] of the portfolio that will receive the minted tokens." , "" , "# Permissions" , "* Asset" , "* Portfolio" , "" , "# Events" , "* `AssetBalanceUpdated` - When the asset balance is successfully updated." , "" , "# Errors" , "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token." , "* `InvalidGranularity` - If the amount to issue does not meet the granularity requirements." , "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit." ,] } , Self :: redeem { .. } => { & ["Redeems (i.e burns) existing tokens by reducing the balance of the caller's portfolio and the total supply of the asset." , "" , "This function allows the asset issuer or an external agent to redeem tokens from a given asset." , "" , "# Arguments" , "* `origin`: is a signer that has permissions to act as an agent of `asset_id`." , "* `asset_id`: the [`AssetId`] associated to the asset." , "* `value`: amount of tokens to redeem." , "* `portfolio_kind`: the [`PortfolioKind`] that will have its balance reduced." , "" , "# Permissions" , "* Asset" , "* Portfolio" , "" , "# Events" , "* `AssetBalanceUpdated` - When the asset balance is successfully updated." , "" , "# Errors" , "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token." , "* `InvalidGranularity` - If the value to redeem does not meet the granularity requirements." , "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit." ,] } , Self :: make_divisible { .. } => { & ["If the asset associated to `asset_id` is indivisible, sets [`AssetDetails::divisible`] to true." , "" , "This function allows the asset issuer or an external agent to make an indivisible asset divisible." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `DivisibilityChanged` - When the divisibility of an asset is successfully changed." , "" , "# Errors" , "* `NoSuchAsset` - If the asset does not exist." , "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token." , "* `AssetAlreadyDivisible` - If the asset is already divisible." ,] } , Self :: add_documents { .. } => { & ["Add documents for a given asset." , "" , "This function allows the asset issuer or an external agent to add documents to an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `docs` - Documents to be attached to the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `DocumentAdded` - When a document is successfully added to an asset." , "" , "# Errors" , "* `CounterOverflow` - If the document ID counter overflows." ,] } , Self :: remove_documents { .. } => { & ["Remove documents for a given asset." , "" , "This function allows the asset issuer or an external agent to remove documents from an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `docs_id` - A vector of all [`DocumentId`] that will be removed from the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `DocumentRemoved` - When a document is successfully removed from an asset." ,] } , Self :: set_funding_round { .. } => { & ["Sets the name of the current funding round." , "" , "This function allows the asset issuer or an external agent to set the name of the current funding round for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `funding_round_name` - The [`FundingRoundName`] of the current funding round." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `FundingRoundSet` - When the funding round name is successfully set." , "" , "# Errors" , "* `FundingRoundNameMaxLengthExceeded` - If the funding round name length exceeds the maximum allowed length." ,] } , Self :: update_identifiers { .. } => { & ["Updates the asset identifiers associated to the asset." , "" , "This function allows the asset issuer or an external agent to update the asset identifiers for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `asset_identifiers` - A vector of [`AssetIdentifier`] that will be associated to the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `IdentifiersUpdated` - When the asset identifiers are successfully updated." , "" , "# Errors" , "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid." ,] } , Self :: controller_transfer { .. } => { & ["Forces a transfer of tokens from `from_portfolio` to the caller's default portfolio." , "" , "This function allows the asset issuer or an external agent to force a transfer of tokens from one portfolio to another." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `value` - The [`Balance`] of tokens that will be transferred." , "* `from_portfolio` - The [`PortfolioId`] that will have its balance reduced." , "" , "# Permissions" , "* Asset" , "* Portfolio" , "" , "# Events" , "* `ControllerTransfer` - When tokens are successfully transferred." , "" , "# Errors" , "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token." , "* `InvalidGranularity` - If the amount to transfer does not meet the granularity requirements." , "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit." ,] } , Self :: register_custom_asset_type { .. } => { & ["Registers a custom asset type." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `ty` - Contains the string representation of the asset type." , "" , "# Events" , "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered." , "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered." , "" , "# Errors" , "* `TooLong` - If the custom asset type length exceeds the maximum allowed length." ,] } , Self :: create_asset_with_custom_type { .. } => { & ["Creates a new asset with a new custom asset type." , "" , "The total supply will initially be zero. To mint tokens, use [`Module::issue`]." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_name` - The [`AssetName`] of the new asset." , "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible." , "* `custom_asset_type` - The custom asset type of the asset." , "* `asset_identifiers` - A vector of [`AssetIdentifier`]." , "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])." , "" , "# Events" , "* `AssetCreated` - When a new asset is successfully created." , "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered." , "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered." , "" , "# Errors" , "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length." , "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid." , "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid." , "* `TooLong` - If the custom asset type length exceeds the maximum allowed length." ,] } , Self :: set_asset_metadata { .. } => { & ["Set asset metadata value." , "" , "This function allows the asset issuer or an external agent to set metadata for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `key` - The [`AssetMetadataKey`] associated to the asset." , "* `value` - The [`AssetMetadataValue`] of the given metadata key." , "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `SetAssetMetadataValue` - When the asset metadata value is successfully set." , "" , "# Errors" , "* `AssetMetadataKeyIsMissing` - If the metadata key is missing." , "* `AssetMetadataValueIsLocked` - If the metadata value is locked." , "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length." ,] } , Self :: set_asset_metadata_details { .. } => { & ["Set asset metadata value details (expire, lock status)." , "" , "This function allows the asset issuer or an external agent to set metadata details for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `key` - The [`AssetMetadataKey`] associated to the asset." , "* `details` - The [`AssetMetadataValueDetail`] (expire, lock status) that will be associated to the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `SetAssetMetadataValueDetails` - When the asset metadata value details are successfully set." , "" , "# Errors" , "* `AssetMetadataKeyIsMissing` - If the metadata key is missing." , "* `AssetMetadataValueIsLocked` - If the metadata value is locked." , "* `AssetMetadataValueIsEmpty` - If the metadata value is empty." ,] } , Self :: register_and_set_local_asset_metadata { .. } => { & ["Registers and set local asset metadata." , "" , "This function allows the asset issuer or an external agent to register and set local metadata for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `name` - The [`AssetMetadataName`]." , "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])." , "* `value` - The [`AssetMetadataValue`] of the given metadata key." , "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered." , "* `SetAssetMetadataValue` - When the asset metadata value is successfully set." , "" , "# Errors" , "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists." , "* `AssetMetadataValueIsLocked` - If the metadata value is locked." , "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length." ,] } , Self :: register_asset_metadata_local_type { .. } => { & ["Registers asset metadata local type." , "" , "This function allows the asset issuer or an external agent to register a local metadata type for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `name` - The [`AssetMetadataName`]." , "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered." , "" , "# Errors" , "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists." , "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length." , "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length." ,] } , Self :: register_asset_metadata_global_type { .. } => { & ["Registers asset metadata global type." , "" , "This function allows the root origin to register a global metadata type." , "" , "# Arguments" , "* `origin` - The root origin." , "* `name` - The [`AssetMetadataName`]." , "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])." , "" , "# Events" , "* `RegisterAssetMetadataGlobalType` - When the global asset metadata type is successfully registered." , "" , "# Errors" , "* `AssetMetadataGlobalKeyAlreadyExists` - If the global metadata key already exists." , "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length." , "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length." ,] } , Self :: update_asset_type { .. } => { & ["Updates the type of an asset." , "" , "This function allows the asset issuer or an external agent to update the type of an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `asset_type` - The new [`AssetType`] of the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetTypeChanged` - When the asset type is successfully changed." , "" , "# Errors" , "* `NoSuchAsset` - If the asset does not exist." , "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid." , "* `IncompatibleAssetTypeUpdate` - If the new asset type is incompatible with the existing asset type." ,] } , Self :: remove_local_metadata_key { .. } => { & ["Removes the asset metadata key and value of a local key." , "" , "This function allows the asset issuer or an external agent to remove a local metadata key and its value for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the local metadata key." , "* `local_key` - The [`AssetMetadataLocalKey`] that will be removed." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `LocalMetadataKeyDeleted` - When the local metadata key is successfully deleted." , "" , "# Errors" , "* `AssetMetadataKeyIsMissing` - If the local metadata key is missing." , "* `AssetMetadataValueIsLocked` - If the metadata value is locked." , "* `AssetMetadataKeyBelongsToNFTCollection` - If the metadata key belongs to an NFT collection." ,] } , Self :: remove_metadata_value { .. } => { & ["Removes the asset metadata value of a metadata key." , "" , "This function allows the asset issuer or an external agent to remove a metadata value for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the metadata key." , "* `metadata_key` - The [`AssetMetadataKey`] that will have its value deleted." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `MetadataValueDeleted` - When the metadata value is successfully deleted." , "" , "# Errors" , "* `AssetMetadataKeyIsMissing` - If the metadata key is missing." , "* `AssetMetadataValueIsLocked` - If the metadata value is locked." ,] } , Self :: exempt_asset_affirmation { .. } => { & ["Pre-approves the receivement of the asset for all identities." , "" , "This function allows the root origin to pre-approve the receivement of an asset for all identities." , "" , "# Arguments" , "* `origin` - The root origin." , "* `asset_id` - The [`AssetId`] that will be exempt from affirmation." , "" , "# Events" , "* `AssetAffirmationExemption` - When the asset is successfully exempted from affirmation." ,] } , Self :: remove_asset_affirmation_exemption { .. } => { & ["Removes the pre-approval of the asset for all identities." , "" , "This function allows the root origin to remove the pre-approval of an asset for all identities." , "" , "# Arguments" , "* `origin` - The root origin." , "* `asset_id` - The [`AssetId`] that will have its exemption removed." , "" , "# Events" , "* `RemoveAssetAffirmationExemption` - When the asset's affirmation exemption is successfully removed." ,] } , Self :: pre_approve_asset { .. } => { & ["Pre-approves the receivement of an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] that will be exempt from affirmation." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `PreApprovedAsset` - When the asset is successfully pre-approved for receivement." ,] } , Self :: remove_asset_pre_approval { .. } => { & ["Removes the pre-approval of an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] that will have its exemption removed." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `RemovePreApprovedAsset` - When the asset's pre-approval is successfully removed." ,] } , Self :: add_mandatory_mediators { .. } => { & ["Sets all identities in the `mediators` set as mandatory mediators for any instruction transferring `asset_id`." , "" , "This function allows the asset issuer or an external agent to add mandatory mediators for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] of the asset that will require the mediators." , "* `mediators` - A set of [`IdentityId`] of all the mandatory mediators for the given ticker." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetMediatorsAdded` - When the mandatory mediators are successfully added." , "" , "# Errors" , "* `NumberOfAssetMediatorsExceeded` - If the number of mandatory mediators exceeds the maximum allowed limit." ,] } , Self :: remove_mandatory_mediators { .. } => { & ["Removes all identities in the `mediators` set from the mandatory mediators list for the given `asset_id`." , "" , "This function allows the asset issuer or an external agent to remove mandatory mediators for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] of the asset that will have mediators removed." , "* `mediators` - A set of [`IdentityId`] of all the mediators that will be removed from the mandatory mediators list." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetMediatorsRemoved` - When the mandatory mediators are successfully removed." ,] } , Self :: link_ticker_to_asset_id { .. } => { & ["Establishes a connection between a ticker and an AssetId." , "" , "This function allows the asset issuer or an external agent to link a ticker to an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `ticker` - The [`Ticker`] that will be linked to the given `asset_id`." , "* `asset_id` - The [`AssetId`] that will be connected to `ticker`." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `TickerLinkedToAsset` - When the ticker is successfully linked to the asset." , "" , "# Errors" , "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller." , "* `TickerRegistrationExpired` - If the ticker registration has expired." , "* `TickerRegistrationNotFound` - If the ticker registration is not found." , "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset." , "* `AssetIsAlreadyLinkedToATicker` - If the asset is already linked to a ticker." ,] } , Self :: unlink_ticker_from_asset_id { .. } => { & ["Removes the link between a ticker and an asset." , "" , "This function allows the asset issuer or an external agent to unlink a ticker from an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `ticker` - The [`Ticker`] that will be unlinked from the given `asset_id`." , "* `asset_id` - The [`AssetId`] that will be unlinked from `ticker`." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `TickerUnlinkedFromAsset` - When the ticker is successfully unlinked from the asset." , "" , "# Errors" , "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller." , "* `TickerRegistrationNotFound` - If the ticker registration is not found." , "* `TickerIsNotLinkedToTheAsset` - If the ticker is not linked to the asset." ,] } , _ => & [""] , }
      }
    }
    impl From<AssetCall> for &'static str {
      fn from(v: AssetCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&AssetCall> for &'static str {
      fn from(v: &AssetCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_babe {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum BabeCall {
        #[doc = "Report authority equivocation/misbehavior. This method will verify"]
        #[doc = "the equivocation proof and validate the given key ownership proof"]
        #[doc = "against the extracted offender. If both are valid, the offence will"]
        #[doc = "be reported."]
        #[codec(index = 0u8)]
        report_equivocation {
          equivocation_proof: ::alloc::boxed::Box<
            sp_consensus_slots::EquivocationProof<
              sp_runtime::generic::header::Header<u32, sp_runtime::traits::BlakeTwo256>,
              sp_consensus_babe::app::Public,
            >,
          >,
          key_owner_proof: sp_session::MembershipProof,
        },
        #[doc = "Report authority equivocation/misbehavior. This method will verify"]
        #[doc = "the equivocation proof and validate the given key ownership proof"]
        #[doc = "against the extracted offender. If both are valid, the offence will"]
        #[doc = "be reported."]
        #[doc = "This extrinsic must be called unsigned and it is expected that only"]
        #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
        #[doc = "if the block author is defined it will be defined as the equivocation"]
        #[doc = "reporter."]
        #[codec(index = 1u8)]
        report_equivocation_unsigned {
          equivocation_proof: ::alloc::boxed::Box<
            sp_consensus_slots::EquivocationProof<
              sp_runtime::generic::header::Header<u32, sp_runtime::traits::BlakeTwo256>,
              sp_consensus_babe::app::Public,
            >,
          >,
          key_owner_proof: sp_session::MembershipProof,
        },
        #[doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"]
        #[doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."]
        #[doc = "Multiple calls to this method will replace any existing planned config change that had"]
        #[doc = "not been enacted yet."]
        #[codec(index = 2u8)]
        plan_config_change {
          config: sp_consensus_babe::digests::NextConfigDescriptor,
        },
      }
      impl BabeCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::report_equivocation { .. } => "Babe.report_equivocation",
            Self::report_equivocation_unsigned { .. } => "Babe.report_equivocation_unsigned",
            Self::plan_config_change { .. } => "Babe.plan_config_change",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for BabeCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: report_equivocation { .. } => { & ["Report authority equivocation/misbehavior. This method will verify" , "the equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence will" , "be reported." ,] } , Self :: report_equivocation_unsigned { .. } => { & ["Report authority equivocation/misbehavior. This method will verify" , "the equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence will" , "be reported." , "This extrinsic must be called unsigned and it is expected that only" , "block authors will call it (validated in `ValidateUnsigned`), as such" , "if the block author is defined it will be defined as the equivocation" , "reporter." ,] } , Self :: plan_config_change { .. } => { & ["Plan an epoch config change. The epoch config change is recorded and will be enacted on" , "the next call to `enact_epoch_change`. The config will be activated one epoch after." , "Multiple calls to this method will replace any existing planned config change that had" , "not been enacted yet." ,] } , _ => & [""] , }
        }
      }
      impl From<BabeCall> for &'static str {
        fn from(v: BabeCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&BabeCall> for &'static str {
        fn from(v: &BabeCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum BabeError {
        #[doc = "An equivocation proof provided as part of an equivocation report is invalid."]
        #[codec(index = 0u8)]
        InvalidEquivocationProof,
        #[doc = "A key ownership proof provided as part of an equivocation report is invalid."]
        #[codec(index = 1u8)]
        InvalidKeyOwnershipProof,
        #[doc = "A given equivocation report is valid but already previously reported."]
        #[codec(index = 2u8)]
        DuplicateOffenceReport,
        #[doc = "Submitted configuration is invalid."]
        #[codec(index = 3u8)]
        InvalidConfiguration,
      }
      impl BabeError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidEquivocationProof => "Babe.InvalidEquivocationProof",
            Self::InvalidKeyOwnershipProof => "Babe.InvalidKeyOwnershipProof",
            Self::DuplicateOffenceReport => "Babe.DuplicateOffenceReport",
            Self::InvalidConfiguration => "Babe.InvalidConfiguration",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for BabeError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidEquivocationProof => {
              &["An equivocation proof provided as part of an equivocation report is invalid."]
            }
            Self::InvalidKeyOwnershipProof => {
              &["A key ownership proof provided as part of an equivocation report is invalid."]
            }
            Self::DuplicateOffenceReport => {
              &["A given equivocation report is valid but already previously reported."]
            }
            Self::InvalidConfiguration => &["Submitted configuration is invalid."],
            _ => &[""],
          }
        }
      }
      impl From<BabeError> for &'static str {
        fn from(v: BabeError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&BabeError> for &'static str {
        fn from(v: &BabeError) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod pallet_balances {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct AccountData {
      pub free: u128,
      pub reserved: u128,
      pub misc_frozen: u128,
      pub fee_frozen: u128,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct BalanceLock<Balance> {
      pub id: [u8; 8usize],
      pub amount: Balance,
      pub reasons: pallet_balances::Reasons,
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BalancesCall {
      #[doc = "Transfer some liquid free balance to another account."]
      #[doc = ""]
      #[doc = "`transfer` will set the `FreeBalance` of the sender and receiver."]
      #[doc = "It will decrease the total issuance of the system by the `TransferFee`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Dependent on arguments but not critical, given proper implementations for"]
      #[doc = "  input config types. See related functions below."]
      #[doc = "- It contains a limited number of reads and writes internally and no complex computation."]
      #[doc = ""]
      #[doc = "Related functions:"]
      #[doc = ""]
      #[doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."]
      #[doc = "  - Transferring balances to accounts that did not exist before will cause"]
      #[doc = "     `T::OnNewAccount::on_new_account` to be called."]
      #[doc = "---------------------------------"]
      #[doc = "- Base Weight: 73.64 µs, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[codec(index = 0u8)]
      transfer {
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        #[codec(compact)]
        value: u128,
      },
      #[doc = "Transfer the native currency with the help of identifier string"]
      #[doc = "this functionality can help to differentiate the transfers."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Base Weight: 73.64 µs, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[codec(index = 1u8)]
      transfer_with_memo {
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        #[codec(compact)]
        value: u128,
        memo: Option<polymesh_primitives::Memo>,
      },
      #[doc = "Move some POLYX from balance of self to balance of BRR."]
      #[codec(index = 2u8)]
      deposit_block_reward_reserve_balance {
        #[codec(compact)]
        value: u128,
      },
      #[doc = "Set the balances of a given account."]
      #[doc = ""]
      #[doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"]
      #[doc = "also decrease the total issuance of the system (`TotalIssuance`)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call is `root`."]
      #[codec(index = 3u8)]
      set_balance {
        who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        #[codec(compact)]
        new_free: u128,
        #[codec(compact)]
        new_reserved: u128,
      },
      #[doc = "Exactly as `transfer`, except the origin must be root and the source account may be"]
      #[doc = "specified."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Same as transfer, but additional read and write because the source account is"]
      #[doc = "  not assumed to be in the overlay."]
      #[doc = "# </weight>"]
      #[codec(index = 4u8)]
      force_transfer {
        source: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        #[codec(compact)]
        value: u128,
      },
      #[doc = "Burns the given amount of tokens from the caller's free, unlocked balance."]
      #[codec(index = 5u8)]
      burn_account_balance { amount: u128 },
    }
    impl BalancesCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::transfer { .. } => "Balances.transfer",
          Self::transfer_with_memo { .. } => "Balances.transfer_with_memo",
          Self::deposit_block_reward_reserve_balance { .. } => {
            "Balances.deposit_block_reward_reserve_balance"
          }
          Self::set_balance { .. } => "Balances.set_balance",
          Self::force_transfer { .. } => "Balances.force_transfer",
          Self::burn_account_balance { .. } => "Balances.burn_account_balance",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for BalancesCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: transfer { .. } => { & ["Transfer some liquid free balance to another account." , "" , "`transfer` will set the `FreeBalance` of the sender and receiver." , "It will decrease the total issuance of the system by the `TransferFee`." , "" , "The dispatch origin for this call must be `Signed` by the transactor." , "" , "# <weight>" , "- Dependent on arguments but not critical, given proper implementations for" , "  input config types. See related functions below." , "- It contains a limited number of reads and writes internally and no complex computation." , "" , "Related functions:" , "" , "  - `ensure_can_withdraw` is always called internally but has a bounded complexity." , "  - Transferring balances to accounts that did not exist before will cause" , "     `T::OnNewAccount::on_new_account` to be called." , "---------------------------------" , "- Base Weight: 73.64 µs, worst case scenario (account created, account removed)" , "- DB Weight: 1 Read and 1 Write to destination account." , "- Origin account is already in memory, so no DB operations for them." , "# </weight>" ,] } , Self :: transfer_with_memo { .. } => { & ["Transfer the native currency with the help of identifier string" , "this functionality can help to differentiate the transfers." , "" , "# <weight>" , "- Base Weight: 73.64 µs, worst case scenario (account created, account removed)" , "- DB Weight: 1 Read and 1 Write to destination account." , "- Origin account is already in memory, so no DB operations for them." , "# </weight>" ,] } , Self :: deposit_block_reward_reserve_balance { .. } => { & ["Move some POLYX from balance of self to balance of BRR." ,] } , Self :: set_balance { .. } => { & ["Set the balances of a given account." , "" , "This will alter `FreeBalance` and `ReservedBalance` in storage. it will" , "also decrease the total issuance of the system (`TotalIssuance`)." , "" , "The dispatch origin for this call is `root`." ,] } , Self :: force_transfer { .. } => { & ["Exactly as `transfer`, except the origin must be root and the source account may be" , "specified." , "" , "# <weight>" , "- Same as transfer, but additional read and write because the source account is" , "  not assumed to be in the overlay." , "# </weight>" ,] } , Self :: burn_account_balance { .. } => { & ["Burns the given amount of tokens from the caller's free, unlocked balance." ,] } , _ => & [""] , }
      }
    }
    impl From<BalancesCall> for &'static str {
      fn from(v: BalancesCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&BalancesCall> for &'static str {
      fn from(v: &BalancesCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BalancesError {
      #[doc = "Account liquidity restrictions prevent withdrawal"]
      #[codec(index = 0u8)]
      LiquidityRestrictions,
      #[doc = "Got an overflow after adding"]
      #[codec(index = 1u8)]
      Overflow,
      #[doc = "Balance too low to send value"]
      #[codec(index = 2u8)]
      InsufficientBalance,
      #[doc = "Value too low to create account due to existential deposit"]
      #[codec(index = 3u8)]
      ExistentialDeposit,
      #[doc = "Receiver does not have a valid CDD"]
      #[codec(index = 4u8)]
      ReceiverCddMissing,
    }
    impl BalancesError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::LiquidityRestrictions => "Balances.LiquidityRestrictions",
          Self::Overflow => "Balances.Overflow",
          Self::InsufficientBalance => "Balances.InsufficientBalance",
          Self::ExistentialDeposit => "Balances.ExistentialDeposit",
          Self::ReceiverCddMissing => "Balances.ReceiverCddMissing",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for BalancesError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::LiquidityRestrictions => &["Account liquidity restrictions prevent withdrawal"],
          Self::Overflow => &["Got an overflow after adding"],
          Self::InsufficientBalance => &["Balance too low to send value"],
          Self::ExistentialDeposit => {
            &["Value too low to create account due to existential deposit"]
          }
          Self::ReceiverCddMissing => &["Receiver does not have a valid CDD"],
          _ => &[""],
        }
      }
    }
    impl From<BalancesError> for &'static str {
      fn from(v: BalancesError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&BalancesError> for &'static str {
      fn from(v: &BalancesError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BalancesEvent<AccountId> {
      #[doc = "An account was created with some free balance. \\[did, account, free_balance]"]
      #[codec(index = 0u8)]
      Endowed(Option<::polymesh_api_client::IdentityId>, AccountId, u128),
      #[doc = "Transfer succeeded (from_did, from, to_did, to, value, memo)."]
      #[codec(index = 1u8)]
      Transfer(
        Option<::polymesh_api_client::IdentityId>,
        AccountId,
        Option<::polymesh_api_client::IdentityId>,
        AccountId,
        u128,
        Option<polymesh_primitives::Memo>,
      ),
      #[doc = "A balance was set by root (did, who, free, reserved)."]
      #[codec(index = 2u8)]
      BalanceSet(::polymesh_api_client::IdentityId, AccountId, u128, u128),
      #[doc = "The account and the amount of unlocked balance of that account that was burned."]
      #[doc = "(caller Id, caller account, amount)"]
      #[codec(index = 3u8)]
      AccountBalanceBurned(::polymesh_api_client::IdentityId, AccountId, u128),
      #[doc = "Some balance was reserved (moved from free to reserved). \\[who, value]"]
      #[codec(index = 4u8)]
      Reserved(AccountId, u128),
      #[doc = "Some balance was unreserved (moved from reserved to free). \\[who, value]"]
      #[codec(index = 5u8)]
      Unreserved(AccountId, u128),
      #[doc = "Some balance was moved from the reserve of the first account to the second account."]
      #[doc = "Final argument indicates the destination balance type."]
      #[doc = "\\[from, to, balance, destination_status]"]
      #[codec(index = 6u8)]
      ReserveRepatriated(
        AccountId,
        AccountId,
        u128,
        frame_support::traits::tokens::misc::BalanceStatus,
      ),
    }
    impl<AccountId> BalancesEvent<AccountId> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::Endowed(_, _, _) => "Balances.Endowed",
          Self::Transfer(_, _, _, _, _, _) => "Balances.Transfer",
          Self::BalanceSet(_, _, _, _) => "Balances.BalanceSet",
          Self::AccountBalanceBurned(_, _, _) => "Balances.AccountBalanceBurned",
          Self::Reserved(_, _) => "Balances.Reserved",
          Self::Unreserved(_, _) => "Balances.Unreserved",
          Self::ReserveRepatriated(_, _, _, _) => "Balances.ReserveRepatriated",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<AccountId> ::polymesh_api_client::EnumInfo for BalancesEvent<AccountId> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::Endowed(_, _, _) => {
            &["An account was created with some free balance. \\[did, account, free_balance]"]
          }
          Self::Transfer(_, _, _, _, _, _) => {
            &["Transfer succeeded (from_did, from, to_did, to, value, memo)."]
          }
          Self::BalanceSet(_, _, _, _) => {
            &["A balance was set by root (did, who, free, reserved)."]
          }
          Self::AccountBalanceBurned(_, _, _) => &[
            "The account and the amount of unlocked balance of that account that was burned.",
            "(caller Id, caller account, amount)",
          ],
          Self::Reserved(_, _) => {
            &["Some balance was reserved (moved from free to reserved). \\[who, value]"]
          }
          Self::Unreserved(_, _) => {
            &["Some balance was unreserved (moved from reserved to free). \\[who, value]"]
          }
          Self::ReserveRepatriated(_, _, _, _) => &[
            "Some balance was moved from the reserve of the first account to the second account.",
            "Final argument indicates the destination balance type.",
            "\\[from, to, balance, destination_status]",
          ],
          _ => &[""],
        }
      }
    }
    impl<AccountId> From<BalancesEvent<AccountId>> for &'static str {
      fn from(v: BalancesEvent<AccountId>) -> Self {
        v.as_static_str()
      }
    }
    impl<AccountId> From<&BalancesEvent<AccountId>> for &'static str {
      fn from(v: &BalancesEvent<AccountId>) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Reasons {
      #[codec(index = 0u8)]
      Fee,
      #[codec(index = 1u8)]
      Misc,
      #[codec(index = 2u8)]
      All,
    }
  }
  pub mod pallet_base {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BaseCall {}
    impl BaseCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for BaseCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          _ => &[""],
        }
      }
    }
    impl From<BaseCall> for &'static str {
      fn from(v: BaseCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&BaseCall> for &'static str {
      fn from(v: &BaseCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BaseError {
      #[doc = "Exceeded a generic length limit."]
      #[doc = "The limit could be for any sort of lists of things, including a string."]
      #[codec(index = 0u8)]
      TooLong,
      #[doc = "The sequence counter for something overflowed."]
      #[doc = ""]
      #[doc = "When this happens depends on e.g., the capacity of the identifier type."]
      #[doc = "For example, we might have `pub struct PipId(u32);`, with `u32::MAX` capacity."]
      #[doc = "In practice, these errors will never happen but no code path should result in a panic,"]
      #[doc = "so these corner cases need to be covered with an error variant."]
      #[codec(index = 1u8)]
      CounterOverflow,
    }
    impl BaseError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::TooLong => "Base.TooLong",
          Self::CounterOverflow => "Base.CounterOverflow",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for BaseError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: TooLong => { & ["Exceeded a generic length limit." , "The limit could be for any sort of lists of things, including a string." ,] } , Self :: CounterOverflow => { & ["The sequence counter for something overflowed." , "" , "When this happens depends on e.g., the capacity of the identifier type." , "For example, we might have `pub struct PipId(u32);`, with `u32::MAX` capacity." , "In practice, these errors will never happen but no code path should result in a panic," , "so these corner cases need to be covered with an error variant." ,] } , _ => & [""] , }
      }
    }
    impl From<BaseError> for &'static str {
      fn from(v: BaseError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&BaseError> for &'static str {
      fn from(v: &BaseError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_bridge {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct BridgeTxDetail<BlockNumber> {
      pub amount: u128,
      pub status: pallet_bridge::BridgeTxStatus,
      pub execution_block: BlockNumber,
      pub tx_hash: primitive_types::H256,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BridgeTxStatus {
      #[codec(index = 0u8)]
      Absent,
      #[codec(index = 1u8)]
      Pending(u8),
      #[codec(index = 2u8)]
      Frozen,
      #[codec(index = 3u8)]
      Timelocked,
      #[codec(index = 4u8)]
      Handled,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_committee {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum UpgradeCommitteeCall {
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[codec(index = 0u8)]
      set_vote_threshold { n: u32, d: u32 },
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[codec(index = 1u8)]
      set_release_coordinator {
        id: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[codec(index = 2u8)]
      set_expires_after {
        expiry: polymesh_common_utilities::MaybeBlock<u32>,
      },
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[codec(index = 3u8)]
      vote_or_propose {
        approve: bool,
        call: ::alloc::boxed::Box<runtime::RuntimeCall>,
      },
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[codec(index = 4u8)]
      vote {
        proposal: primitive_types::H256,
        index: u32,
        approve: bool,
      },
    }
    impl UpgradeCommitteeCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_vote_threshold { .. } => "UpgradeCommittee.set_vote_threshold",
          Self::set_release_coordinator { .. } => "UpgradeCommittee.set_release_coordinator",
          Self::set_expires_after { .. } => "UpgradeCommittee.set_expires_after",
          Self::vote_or_propose { .. } => "UpgradeCommittee.vote_or_propose",
          Self::vote { .. } => "UpgradeCommittee.vote",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_vote_threshold { .. } => { & ["Change the vote threshold the determines the winning proposal." , "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"." , "" , "# Arguments" , "* `n` - Numerator of the fraction representing vote threshold." , "* `d` - Denominator of the fraction representing vote threshold." ,] } , Self :: set_release_coordinator { .. } => { & ["Changes the release coordinator." , "" , "# Arguments" , "* `id` - The DID of the new release coordinator." , "" , "# Errors" , "* `NotAMember`, If the new coordinator `id` is not part of the committee." ,] } , Self :: set_expires_after { .. } => { & ["Changes the time after which a proposal expires." , "" , "# Arguments" , "* `expiry` - The new expiry time." ,] } , Self :: vote_or_propose { .. } => { & ["Proposes to the committee that `call` should be executed in its name." , "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed," , "then this call counts as a vote, i.e., as if `vote_by_hash` was called." , "" , "# Weight" , "" , "The weight of this dispatchable is that of `call` as well as the complexity" , "for recording the vote itself." , "" , "# Arguments" , "* `approve` - is this an approving vote?" , "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`." , "* `call` - the call to propose for execution." , "" , "# Errors" , "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`." , "* `NotAMember`, if the `origin` is not a member of this committee." ,] } , Self :: vote { .. } => { & ["Votes `approve`ingly (or not, if `false`)" , "on an existing `proposal` given by its hash, `index`." , "" , "# Arguments" , "* `proposal` - A hash of the proposal to be voted on." , "* `index` - The proposal index." , "* `approve` - If `true` than this is a `for` vote, and `against` otherwise." , "" , "# Errors" , "* `NotAMember`, if the `origin` is not a member of this committee." ,] } , _ => & [""] , }
      }
    }
    impl From<UpgradeCommitteeCall> for &'static str {
      fn from(v: UpgradeCommitteeCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&UpgradeCommitteeCall> for &'static str {
      fn from(v: &UpgradeCommitteeCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum UpgradeCommitteeError {
      #[doc = "Duplicate votes are not allowed."]
      #[codec(index = 0u8)]
      DuplicateVote,
      #[doc = "A DID isn't part of the committee."]
      #[doc = "The DID may either be a caller or some other context."]
      #[codec(index = 1u8)]
      NotAMember,
      #[doc = "No such proposal."]
      #[codec(index = 2u8)]
      NoSuchProposal,
      #[doc = "Proposal exists, but it has expired."]
      #[codec(index = 3u8)]
      ProposalExpired,
      #[doc = "Duplicate proposal."]
      #[codec(index = 4u8)]
      DuplicateProposal,
      #[doc = "Mismatched voting index."]
      #[codec(index = 5u8)]
      MismatchedVotingIndex,
      #[doc = "Proportion must be a rational number."]
      #[codec(index = 6u8)]
      InvalidProportion,
      #[doc = "First vote on a proposal creates it, so it must be an approval."]
      #[doc = "All proposals are motions to execute something as \"GC majority\"."]
      #[doc = "To reject e.g., a PIP, a motion to reject should be *approved*."]
      #[codec(index = 7u8)]
      FirstVoteReject,
      #[doc = "Maximum number of proposals has been reached."]
      #[codec(index = 8u8)]
      ProposalsLimitReached,
    }
    impl UpgradeCommitteeError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::DuplicateVote => "UpgradeCommittee.DuplicateVote",
          Self::NotAMember => "UpgradeCommittee.NotAMember",
          Self::NoSuchProposal => "UpgradeCommittee.NoSuchProposal",
          Self::ProposalExpired => "UpgradeCommittee.ProposalExpired",
          Self::DuplicateProposal => "UpgradeCommittee.DuplicateProposal",
          Self::MismatchedVotingIndex => "UpgradeCommittee.MismatchedVotingIndex",
          Self::InvalidProportion => "UpgradeCommittee.InvalidProportion",
          Self::FirstVoteReject => "UpgradeCommittee.FirstVoteReject",
          Self::ProposalsLimitReached => "UpgradeCommittee.ProposalsLimitReached",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::DuplicateVote => &["Duplicate votes are not allowed."],
          Self::NotAMember => &[
            "A DID isn't part of the committee.",
            "The DID may either be a caller or some other context.",
          ],
          Self::NoSuchProposal => &["No such proposal."],
          Self::ProposalExpired => &["Proposal exists, but it has expired."],
          Self::DuplicateProposal => &["Duplicate proposal."],
          Self::MismatchedVotingIndex => &["Mismatched voting index."],
          Self::InvalidProportion => &["Proportion must be a rational number."],
          Self::FirstVoteReject => &[
            "First vote on a proposal creates it, so it must be an approval.",
            "All proposals are motions to execute something as \"GC majority\".",
            "To reject e.g., a PIP, a motion to reject should be *approved*.",
          ],
          Self::ProposalsLimitReached => &["Maximum number of proposals has been reached."],
          _ => &[""],
        }
      }
    }
    impl From<UpgradeCommitteeError> for &'static str {
      fn from(v: UpgradeCommitteeError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&UpgradeCommitteeError> for &'static str {
      fn from(v: &UpgradeCommitteeError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance1();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance3();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance4();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PolymeshVotes<BlockNumber> {
      pub index: BlockNumber,
      pub ayes: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      pub nays: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      pub expiry: polymesh_common_utilities::MaybeBlock<BlockNumber>,
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum UpgradeCommitteeEvent<Hash, BlockNumber, I> {
      #[doc = "A motion (given hash) has been proposed (by given account) with a threshold (given `MemberCount`)."]
      #[doc = "Parameters: caller DID, proposal index, proposal hash."]
      #[codec(index = 0u8)]
      Proposed(::polymesh_api_client::IdentityId, BlockNumber, Hash),
      #[doc = "A motion (given hash) has been voted on by given account, leaving"]
      #[doc = "a tally (yes votes, no votes and total seats given respectively as `MemberCount`)."]
      #[doc = "caller DID, Proposal index, Proposal hash, current vote, yay vote count, nay vote count, total seats."]
      #[codec(index = 1u8)]
      Voted(
        ::polymesh_api_client::IdentityId,
        BlockNumber,
        Hash,
        bool,
        BlockNumber,
        BlockNumber,
        BlockNumber,
      ),
      #[doc = "A vote on a motion (given hash) has been retracted."]
      #[doc = "caller DID, ProposalIndex, Proposal hash, vote that was retracted"]
      #[codec(index = 2u8)]
      VoteRetracted(::polymesh_api_client::IdentityId, BlockNumber, Hash, bool),
      #[doc = "Final votes on a motion (given hash)"]
      #[doc = "caller DID, ProposalIndex, Proposal hash, yes voters, no voter"]
      #[codec(index = 3u8)]
      FinalVotes(
        Option<::polymesh_api_client::IdentityId>,
        BlockNumber,
        Hash,
        ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
        ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ),
      #[doc = "A motion was approved by the required threshold with the following"]
      #[doc = "tally (yes votes, no votes and total seats given respectively as `MemberCount`)."]
      #[doc = "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats."]
      #[codec(index = 4u8)]
      Approved(
        Option<::polymesh_api_client::IdentityId>,
        Hash,
        BlockNumber,
        BlockNumber,
        BlockNumber,
      ),
      #[doc = "A motion was rejected by the required threshold with the following"]
      #[doc = "tally (yes votes, no votes and total seats given respectively as `MemberCount`)."]
      #[doc = "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats."]
      #[codec(index = 5u8)]
      Rejected(
        Option<::polymesh_api_client::IdentityId>,
        Hash,
        BlockNumber,
        BlockNumber,
        BlockNumber,
      ),
      #[doc = "A motion was executed; `DispatchResult` is `Ok(())` if returned without error."]
      #[doc = "Parameters: caller DID, proposal hash, result of proposal dispatch."]
      #[codec(index = 6u8)]
      Executed(
        Option<::polymesh_api_client::IdentityId>,
        Hash,
        Result<(), sp_runtime::DispatchError>,
      ),
      #[doc = "Release coordinator has been updated."]
      #[doc = "Parameters: DID of the release coordinator."]
      #[codec(index = 7u8)]
      ReleaseCoordinatorUpdated(Option<::polymesh_api_client::IdentityId>),
      #[doc = "Proposal expiry time has been updated."]
      #[doc = "Parameters: caller DID, new expiry time (if any)."]
      #[codec(index = 8u8)]
      ExpiresAfterUpdated(
        ::polymesh_api_client::IdentityId,
        polymesh_common_utilities::MaybeBlock<BlockNumber>,
      ),
      #[doc = "Voting threshold has been updated"]
      #[doc = "Parameters: caller DID, numerator, denominator"]
      #[codec(index = 9u8)]
      VoteThresholdUpdated(::polymesh_api_client::IdentityId, BlockNumber, BlockNumber),
      PhantomDataVariant(core::marker::PhantomData<I>),
    }
    impl<Hash, BlockNumber, I> UpgradeCommitteeEvent<Hash, BlockNumber, I> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::Proposed(_, _, _) => "UpgradeCommittee.Proposed",
          Self::Voted(_, _, _, _, _, _, _) => "UpgradeCommittee.Voted",
          Self::VoteRetracted(_, _, _, _) => "UpgradeCommittee.VoteRetracted",
          Self::FinalVotes(_, _, _, _, _) => "UpgradeCommittee.FinalVotes",
          Self::Approved(_, _, _, _, _) => "UpgradeCommittee.Approved",
          Self::Rejected(_, _, _, _, _) => "UpgradeCommittee.Rejected",
          Self::Executed(_, _, _) => "UpgradeCommittee.Executed",
          Self::ReleaseCoordinatorUpdated(_) => "UpgradeCommittee.ReleaseCoordinatorUpdated",
          Self::ExpiresAfterUpdated(_, _) => "UpgradeCommittee.ExpiresAfterUpdated",
          Self::VoteThresholdUpdated(_, _, _) => "UpgradeCommittee.VoteThresholdUpdated",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<Hash, BlockNumber, I> ::polymesh_api_client::EnumInfo
      for UpgradeCommitteeEvent<Hash, BlockNumber, I>
    {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: Proposed (_ , _ , _) => { & ["A motion (given hash) has been proposed (by given account) with a threshold (given `MemberCount`)." , "Parameters: caller DID, proposal index, proposal hash." ,] } , Self :: Voted (_ , _ , _ , _ , _ , _ , _) => { & ["A motion (given hash) has been voted on by given account, leaving" , "a tally (yes votes, no votes and total seats given respectively as `MemberCount`)." , "caller DID, Proposal index, Proposal hash, current vote, yay vote count, nay vote count, total seats." ,] } , Self :: VoteRetracted (_ , _ , _ , _) => { & ["A vote on a motion (given hash) has been retracted." , "caller DID, ProposalIndex, Proposal hash, vote that was retracted" ,] } , Self :: FinalVotes (_ , _ , _ , _ , _) => { & ["Final votes on a motion (given hash)" , "caller DID, ProposalIndex, Proposal hash, yes voters, no voter" ,] } , Self :: Approved (_ , _ , _ , _ , _) => { & ["A motion was approved by the required threshold with the following" , "tally (yes votes, no votes and total seats given respectively as `MemberCount`)." , "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats." ,] } , Self :: Rejected (_ , _ , _ , _ , _) => { & ["A motion was rejected by the required threshold with the following" , "tally (yes votes, no votes and total seats given respectively as `MemberCount`)." , "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats." ,] } , Self :: Executed (_ , _ , _) => { & ["A motion was executed; `DispatchResult` is `Ok(())` if returned without error." , "Parameters: caller DID, proposal hash, result of proposal dispatch." ,] } , Self :: ReleaseCoordinatorUpdated (_) => { & ["Release coordinator has been updated." , "Parameters: DID of the release coordinator." ,] } , Self :: ExpiresAfterUpdated (_ , _) => { & ["Proposal expiry time has been updated." , "Parameters: caller DID, new expiry time (if any)." ,] } , Self :: VoteThresholdUpdated (_ , _ , _) => { & ["Voting threshold has been updated" , "Parameters: caller DID, numerator, denominator" ,] } , _ => & [""] , }
      }
    }
    impl<Hash, BlockNumber, I> From<UpgradeCommitteeEvent<Hash, BlockNumber, I>> for &'static str {
      fn from(v: UpgradeCommitteeEvent<Hash, BlockNumber, I>) -> Self {
        v.as_static_str()
      }
    }
    impl<Hash, BlockNumber, I> From<&UpgradeCommitteeEvent<Hash, BlockNumber, I>> for &'static str {
      fn from(v: &UpgradeCommitteeEvent<Hash, BlockNumber, I>) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RawOrigin<AccountId, I> {
      #[codec(index = 0u8)]
      Endorsed,
      PhantomDataVariant(core::marker::PhantomData<(AccountId, I)>),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_compliance_manager {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ComplianceManagerCall {
      #[doc = "Adds a compliance requirement to an asset given by `asset_id`."]
      #[doc = "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = "* sender_conditions - Sender transfer conditions."]
      #[doc = "* receiver_conditions - Receiver transfer conditions."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 0u8)]
      add_compliance_requirement {
        asset_id: ::polymesh_api_client::AssetId,
        sender_conditions: ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
        receiver_conditions: ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
      },
      #[doc = "Removes a compliance requirement from an asset's compliance."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = "* id - Compliance requirement id which is need to be removed"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 1u8)]
      remove_compliance_requirement {
        asset_id: ::polymesh_api_client::AssetId,
        id: u32,
      },
      #[doc = "Replaces an asset's compliance with a new compliance."]
      #[doc = ""]
      #[doc = "Compliance requirements will be sorted (ascending by id) before"]
      #[doc = "replacing the current requirements."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `asset_id` - the asset asset_id,"]
      #[doc = "* `asset_compliance - the new asset compliance."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `Unauthorized` if `origin` is not the owner of the asset_id."]
      #[doc = "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 2u8)]
      replace_asset_compliance {
        asset_id: ::polymesh_api_client::AssetId,
        asset_compliance:
          ::alloc::vec::Vec<polymesh_primitives::compliance_manager::ComplianceRequirement>,
      },
      #[doc = "Removes an asset's compliance"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 3u8)]
      reset_asset_compliance {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Pauses the verification of conditions for `asset_id` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 4u8)]
      pause_asset_compliance {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Resumes the verification of conditions for `asset_id` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 5u8)]
      resume_asset_compliance {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Adds another default trusted claim issuer at the asset level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
      #[doc = "* asset_id - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 6u8)]
      add_default_trusted_claim_issuer {
        asset_id: ::polymesh_api_client::AssetId,
        issuer: polymesh_primitives::condition::TrustedIssuer,
      },
      #[doc = "Removes the given `issuer` from the set of default trusted claim issuers at the asset level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
      #[doc = "* asset_id - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 7u8)]
      remove_default_trusted_claim_issuer {
        asset_id: ::polymesh_api_client::AssetId,
        issuer: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Modify an existing compliance requirement of a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
      #[doc = "* asset_id - Symbol of the asset."]
      #[doc = "* new_req - Compliance requirement."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 8u8)]
      change_compliance_requirement {
        asset_id: ::polymesh_api_client::AssetId,
        new_req: polymesh_primitives::compliance_manager::ComplianceRequirement,
      },
    }
    impl ComplianceManagerCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::add_compliance_requirement { .. } => "ComplianceManager.add_compliance_requirement",
          Self::remove_compliance_requirement { .. } => {
            "ComplianceManager.remove_compliance_requirement"
          }
          Self::replace_asset_compliance { .. } => "ComplianceManager.replace_asset_compliance",
          Self::reset_asset_compliance { .. } => "ComplianceManager.reset_asset_compliance",
          Self::pause_asset_compliance { .. } => "ComplianceManager.pause_asset_compliance",
          Self::resume_asset_compliance { .. } => "ComplianceManager.resume_asset_compliance",
          Self::add_default_trusted_claim_issuer { .. } => {
            "ComplianceManager.add_default_trusted_claim_issuer"
          }
          Self::remove_default_trusted_claim_issuer { .. } => {
            "ComplianceManager.remove_default_trusted_claim_issuer"
          }
          Self::change_compliance_requirement { .. } => {
            "ComplianceManager.change_compliance_requirement"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ComplianceManagerCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: add_compliance_requirement { .. } => { & ["Adds a compliance requirement to an asset given by `asset_id`." , "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset" , "* asset_id - Symbol of the asset" , "* sender_conditions - Sender transfer conditions." , "* receiver_conditions - Receiver transfer conditions." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_compliance_requirement { .. } => { & ["Removes a compliance requirement from an asset's compliance." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset" , "* asset_id - Symbol of the asset" , "* id - Compliance requirement id which is need to be removed" , "" , "# Permissions" , "* Asset" ,] } , Self :: replace_asset_compliance { .. } => { & ["Replaces an asset's compliance with a new compliance." , "" , "Compliance requirements will be sorted (ascending by id) before" , "replacing the current requirements." , "" , "# Arguments" , "* `asset_id` - the asset asset_id," , "* `asset_compliance - the new asset compliance." , "" , "# Errors" , "* `Unauthorized` if `origin` is not the owner of the asset_id." , "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`." , "" , "# Permissions" , "* Asset" ,] } , Self :: reset_asset_compliance { .. } => { & ["Removes an asset's compliance" , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset" , "* asset_id - Symbol of the asset" , "" , "# Permissions" , "* Asset" ,] } , Self :: pause_asset_compliance { .. } => { & ["Pauses the verification of conditions for `asset_id` during transfers." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset" , "* asset_id - Symbol of the asset" , "" , "# Permissions" , "* Asset" ,] } , Self :: resume_asset_compliance { .. } => { & ["Resumes the verification of conditions for `asset_id` during transfers." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset" , "* asset_id - Symbol of the asset" , "" , "# Permissions" , "* Asset" ,] } , Self :: add_default_trusted_claim_issuer { .. } => { & ["Adds another default trusted claim issuer at the asset level." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset." , "* asset_id - Symbol of the asset." , "* issuer - IdentityId of the trusted claim issuer." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_default_trusted_claim_issuer { .. } => { & ["Removes the given `issuer` from the set of default trusted claim issuers at the asset level." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset." , "* asset_id - Symbol of the asset." , "* issuer - IdentityId of the trusted claim issuer." , "" , "# Permissions" , "* Asset" ,] } , Self :: change_compliance_requirement { .. } => { & ["Modify an existing compliance requirement of a given asset." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset." , "* asset_id - Symbol of the asset." , "* new_req - Compliance requirement." , "" , "# Permissions" , "* Asset" ,] } , _ => & [""] , }
      }
    }
    impl From<ComplianceManagerCall> for &'static str {
      fn from(v: ComplianceManagerCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ComplianceManagerCall> for &'static str {
      fn from(v: &ComplianceManagerCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ComplianceManagerError {
      #[doc = "User is not authorized."]
      #[codec(index = 0u8)]
      Unauthorized,
      #[doc = "Did not exist."]
      #[codec(index = 1u8)]
      DidNotExist,
      #[doc = "Compliance requirement id doesn't exist."]
      #[codec(index = 2u8)]
      InvalidComplianceRequirementId,
      #[doc = "Issuer exist but trying to add it again."]
      #[codec(index = 3u8)]
      IncorrectOperationOnTrustedIssuer,
      #[doc = "There are duplicate compliance requirements."]
      #[codec(index = 4u8)]
      DuplicateComplianceRequirements,
      #[doc = "The worst case scenario of the compliance requirement is too complex."]
      #[codec(index = 5u8)]
      ComplianceRequirementTooComplex,
      #[doc = "The maximum weight limit for executing the function was exceeded."]
      #[codec(index = 6u8)]
      WeightLimitExceeded,
    }
    impl ComplianceManagerError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::Unauthorized => "ComplianceManager.Unauthorized",
          Self::DidNotExist => "ComplianceManager.DidNotExist",
          Self::InvalidComplianceRequirementId => {
            "ComplianceManager.InvalidComplianceRequirementId"
          }
          Self::IncorrectOperationOnTrustedIssuer => {
            "ComplianceManager.IncorrectOperationOnTrustedIssuer"
          }
          Self::DuplicateComplianceRequirements => {
            "ComplianceManager.DuplicateComplianceRequirements"
          }
          Self::ComplianceRequirementTooComplex => {
            "ComplianceManager.ComplianceRequirementTooComplex"
          }
          Self::WeightLimitExceeded => "ComplianceManager.WeightLimitExceeded",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ComplianceManagerError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::Unauthorized => &["User is not authorized."],
          Self::DidNotExist => &["Did not exist."],
          Self::InvalidComplianceRequirementId => &["Compliance requirement id doesn't exist."],
          Self::IncorrectOperationOnTrustedIssuer => &["Issuer exist but trying to add it again."],
          Self::DuplicateComplianceRequirements => {
            &["There are duplicate compliance requirements."]
          }
          Self::ComplianceRequirementTooComplex => {
            &["The worst case scenario of the compliance requirement is too complex."]
          }
          Self::WeightLimitExceeded => {
            &["The maximum weight limit for executing the function was exceeded."]
          }
          _ => &[""],
        }
      }
    }
    impl From<ComplianceManagerError> for &'static str {
      fn from(v: ComplianceManagerError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ComplianceManagerError> for &'static str {
      fn from(v: &ComplianceManagerError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_contracts {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ContractsCall {
        #[doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."]
        #[codec(index = 0u8)]
        call_old_weight {
          dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          #[codec(compact)]
          value: u128,
          #[codec(compact)]
          gas_limit: ::polymesh_api_client::OldWeight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          data: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."]
        #[codec(index = 1u8)]
        instantiate_with_code_old_weight {
          #[codec(compact)]
          value: u128,
          #[codec(compact)]
          gas_limit: ::polymesh_api_client::OldWeight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          code: ::alloc::vec::Vec<u8>,
          data: ::alloc::vec::Vec<u8>,
          salt: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."]
        #[codec(index = 2u8)]
        instantiate_old_weight {
          #[codec(compact)]
          value: u128,
          #[codec(compact)]
          gas_limit: ::polymesh_api_client::OldWeight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          code_hash: primitive_types::H256,
          data: ::alloc::vec::Vec<u8>,
          salt: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Upload new `code` without instantiating a contract from it."]
        #[doc = ""]
        #[doc = "If the code does not already exist a deposit is reserved from the caller"]
        #[doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"]
        #[doc = "depends on the instrumented size of the the supplied `code`."]
        #[doc = ""]
        #[doc = "If the code already exists in storage it will still return `Ok` and upgrades"]
        #[doc = "the in storage version to the current"]
        #[doc = "[`InstructionWeights::version`](InstructionWeights)."]
        #[doc = ""]
        #[doc = "- `determinism`: If this is set to any other value but [`Determinism::Deterministic`]"]
        #[doc = "  then the only way to use this code is to delegate call into it from an offchain"]
        #[doc = "  execution. Set to [`Determinism::Deterministic`] if in doubt."]
        #[doc = ""]
        #[doc = "# Note"]
        #[doc = ""]
        #[doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."]
        #[doc = "To avoid this situation a constructor could employ access control so that it can"]
        #[doc = "only be instantiated by permissioned entities. The same is true when uploading"]
        #[doc = "through [`Self::instantiate_with_code`]."]
        #[codec(index = 3u8)]
        upload_code {
          code: ::alloc::vec::Vec<u8>,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          determinism: pallet_contracts::wasm::Determinism,
        },
        #[doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."]
        #[doc = ""]
        #[doc = "A code can only be removed by its original uploader (its owner) and only if it is"]
        #[doc = "not used by any contract."]
        #[codec(index = 4u8)]
        remove_code { code_hash: primitive_types::H256 },
        #[doc = "Privileged function that changes the code of an existing contract."]
        #[doc = ""]
        #[doc = "This takes care of updating refcounts and all other necessary operations. Returns"]
        #[doc = "an error if either the `code_hash` or `dest` do not exist."]
        #[doc = ""]
        #[doc = "# Note"]
        #[doc = ""]
        #[doc = "This does **not** change the address of the contract in question. This means"]
        #[doc = "that the contract address is no longer derived from its code hash after calling"]
        #[doc = "this dispatchable."]
        #[codec(index = 5u8)]
        set_code {
          dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          code_hash: primitive_types::H256,
        },
        #[doc = "Makes a call to an account, optionally transferring some balance."]
        #[doc = ""]
        #[doc = "# Parameters"]
        #[doc = ""]
        #[doc = "* `dest`: Address of the contract to call."]
        #[doc = "* `value`: The balance to transfer from the `origin` to `dest`."]
        #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
        #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"]
        #[doc = "  caller to pay for the storage consumed."]
        #[doc = "* `data`: The input data to pass to the contract."]
        #[doc = ""]
        #[doc = "* If the account is a smart-contract account, the associated code will be"]
        #[doc = "executed and any value will be transferred."]
        #[doc = "* If the account is a regular account, any value will be transferred."]
        #[doc = "* If no account exists and the call value is not less than `existential_deposit`,"]
        #[doc = "a regular account will be created and any value will be transferred."]
        #[codec(index = 6u8)]
        call {
          dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          #[codec(compact)]
          value: u128,
          gas_limit: ::polymesh_api_client::sp_weights::Weight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          data: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Instantiates a new contract from the supplied `code` optionally transferring"]
        #[doc = "some balance."]
        #[doc = ""]
        #[doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"]
        #[doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"]
        #[doc = "also check the documentation of [`Self::upload_code`]."]
        #[doc = ""]
        #[doc = "# Parameters"]
        #[doc = ""]
        #[doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."]
        #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
        #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"]
        #[doc = "  from the caller to pay for the storage consumed."]
        #[doc = "* `code`: The contract code to deploy in raw bytes."]
        #[doc = "* `data`: The input data to pass to the contract constructor."]
        #[doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."]
        #[doc = ""]
        #[doc = "Instantiation is executed as follows:"]
        #[doc = ""]
        #[doc = "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that"]
        #[doc = "  code."]
        #[doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."]
        #[doc = "- The destination address is computed based on the sender, code_hash and the salt."]
        #[doc = "- The smart-contract account is created at the computed address."]
        #[doc = "- The `value` is transferred to the new account."]
        #[doc = "- The `deploy` function is executed in the context of the newly-created account."]
        #[codec(index = 7u8)]
        instantiate_with_code {
          #[codec(compact)]
          value: u128,
          gas_limit: ::polymesh_api_client::sp_weights::Weight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          code: ::alloc::vec::Vec<u8>,
          data: ::alloc::vec::Vec<u8>,
          salt: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Instantiates a contract from a previously deployed wasm binary."]
        #[doc = ""]
        #[doc = "This function is identical to [`Self::instantiate_with_code`] but without the"]
        #[doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"]
        #[doc = "must be supplied."]
        #[codec(index = 8u8)]
        instantiate {
          #[codec(compact)]
          value: u128,
          gas_limit: ::polymesh_api_client::sp_weights::Weight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          code_hash: primitive_types::H256,
          data: ::alloc::vec::Vec<u8>,
          salt: ::alloc::vec::Vec<u8>,
        },
      }
      impl ContractsCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::call_old_weight { .. } => "Contracts.call_old_weight",
            Self::instantiate_with_code_old_weight { .. } => {
              "Contracts.instantiate_with_code_old_weight"
            }
            Self::instantiate_old_weight { .. } => "Contracts.instantiate_old_weight",
            Self::upload_code { .. } => "Contracts.upload_code",
            Self::remove_code { .. } => "Contracts.remove_code",
            Self::set_code { .. } => "Contracts.set_code",
            Self::call { .. } => "Contracts.call",
            Self::instantiate_with_code { .. } => "Contracts.instantiate_with_code",
            Self::instantiate { .. } => "Contracts.instantiate",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ContractsCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: call_old_weight { .. } => { & ["Deprecated version if [`Self::call`] for use in an in-storage `Call`." ,] } , Self :: instantiate_with_code_old_weight { .. } => { & ["Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`." ,] } , Self :: instantiate_old_weight { .. } => { & ["Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`." ,] } , Self :: upload_code { .. } => { & ["Upload new `code` without instantiating a contract from it." , "" , "If the code does not already exist a deposit is reserved from the caller" , "and unreserved only when [`Self::remove_code`] is called. The size of the reserve" , "depends on the instrumented size of the the supplied `code`." , "" , "If the code already exists in storage it will still return `Ok` and upgrades" , "the in storage version to the current" , "[`InstructionWeights::version`](InstructionWeights)." , "" , "- `determinism`: If this is set to any other value but [`Determinism::Deterministic`]" , "  then the only way to use this code is to delegate call into it from an offchain" , "  execution. Set to [`Determinism::Deterministic`] if in doubt." , "" , "# Note" , "" , "Anyone can instantiate a contract from any uploaded code and thus prevent its removal." , "To avoid this situation a constructor could employ access control so that it can" , "only be instantiated by permissioned entities. The same is true when uploading" , "through [`Self::instantiate_with_code`]." ,] } , Self :: remove_code { .. } => { & ["Remove the code stored under `code_hash` and refund the deposit to its owner." , "" , "A code can only be removed by its original uploader (its owner) and only if it is" , "not used by any contract." ,] } , Self :: set_code { .. } => { & ["Privileged function that changes the code of an existing contract." , "" , "This takes care of updating refcounts and all other necessary operations. Returns" , "an error if either the `code_hash` or `dest` do not exist." , "" , "# Note" , "" , "This does **not** change the address of the contract in question. This means" , "that the contract address is no longer derived from its code hash after calling" , "this dispatchable." ,] } , Self :: call { .. } => { & ["Makes a call to an account, optionally transferring some balance." , "" , "# Parameters" , "" , "* `dest`: Address of the contract to call." , "* `value`: The balance to transfer from the `origin` to `dest`." , "* `gas_limit`: The gas limit enforced when executing the constructor." , "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the" , "  caller to pay for the storage consumed." , "* `data`: The input data to pass to the contract." , "" , "* If the account is a smart-contract account, the associated code will be" , "executed and any value will be transferred." , "* If the account is a regular account, any value will be transferred." , "* If no account exists and the call value is not less than `existential_deposit`," , "a regular account will be created and any value will be transferred." ,] } , Self :: instantiate_with_code { .. } => { & ["Instantiates a new contract from the supplied `code` optionally transferring" , "some balance." , "" , "This dispatchable has the same effect as calling [`Self::upload_code`] +" , "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please" , "also check the documentation of [`Self::upload_code`]." , "" , "# Parameters" , "" , "* `value`: The balance to transfer from the `origin` to the newly created contract." , "* `gas_limit`: The gas limit enforced when executing the constructor." , "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved" , "  from the caller to pay for the storage consumed." , "* `code`: The contract code to deploy in raw bytes." , "* `data`: The input data to pass to the contract constructor." , "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]." , "" , "Instantiation is executed as follows:" , "" , "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that" , "  code." , "- If the `code_hash` already exists on the chain the underlying `code` will be shared." , "- The destination address is computed based on the sender, code_hash and the salt." , "- The smart-contract account is created at the computed address." , "- The `value` is transferred to the new account." , "- The `deploy` function is executed in the context of the newly-created account." ,] } , Self :: instantiate { .. } => { & ["Instantiates a contract from a previously deployed wasm binary." , "" , "This function is identical to [`Self::instantiate_with_code`] but without the" , "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary" , "must be supplied." ,] } , _ => & [""] , }
        }
      }
      impl From<ContractsCall> for &'static str {
        fn from(v: ContractsCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ContractsCall> for &'static str {
        fn from(v: &ContractsCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ContractsError {
        #[doc = "A new schedule must have a greater version than the current one."]
        #[codec(index = 0u8)]
        InvalidScheduleVersion,
        #[doc = "Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`."]
        #[codec(index = 1u8)]
        InvalidCallFlags,
        #[doc = "The executed contract exhausted its gas limit."]
        #[codec(index = 2u8)]
        OutOfGas,
        #[doc = "The output buffer supplied to a contract API call was too small."]
        #[codec(index = 3u8)]
        OutputBufferTooSmall,
        #[doc = "Performing the requested transfer failed. Probably because there isn't enough"]
        #[doc = "free balance in the sender's account."]
        #[codec(index = 4u8)]
        TransferFailed,
        #[doc = "Performing a call was denied because the calling depth reached the limit"]
        #[doc = "of what is specified in the schedule."]
        #[codec(index = 5u8)]
        MaxCallDepthReached,
        #[doc = "No contract was found at the specified address."]
        #[codec(index = 6u8)]
        ContractNotFound,
        #[doc = "The code supplied to `instantiate_with_code` exceeds the limit specified in the"]
        #[doc = "current schedule."]
        #[codec(index = 7u8)]
        CodeTooLarge,
        #[doc = "No code could be found at the supplied code hash."]
        #[codec(index = 8u8)]
        CodeNotFound,
        #[doc = "A buffer outside of sandbox memory was passed to a contract API function."]
        #[codec(index = 9u8)]
        OutOfBounds,
        #[doc = "Input passed to a contract API function failed to decode as expected type."]
        #[codec(index = 10u8)]
        DecodingFailed,
        #[doc = "Contract trapped during execution."]
        #[codec(index = 11u8)]
        ContractTrapped,
        #[doc = "The size defined in `T::MaxValueSize` was exceeded."]
        #[codec(index = 12u8)]
        ValueTooLarge,
        #[doc = "Termination of a contract is not allowed while the contract is already"]
        #[doc = "on the call stack. Can be triggered by `seal_terminate`."]
        #[codec(index = 13u8)]
        TerminatedWhileReentrant,
        #[doc = "`seal_call` forwarded this contracts input. It therefore is no longer available."]
        #[codec(index = 14u8)]
        InputForwarded,
        #[doc = "The subject passed to `seal_random` exceeds the limit."]
        #[codec(index = 15u8)]
        RandomSubjectTooLong,
        #[doc = "The amount of topics passed to `seal_deposit_events` exceeds the limit."]
        #[codec(index = 16u8)]
        TooManyTopics,
        #[doc = "The chain does not provide a chain extension. Calling the chain extension results"]
        #[doc = "in this error. Note that this usually  shouldn't happen as deploying such contracts"]
        #[doc = "is rejected."]
        #[codec(index = 17u8)]
        NoChainExtension,
        #[doc = "Removal of a contract failed because the deletion queue is full."]
        #[doc = ""]
        #[doc = "This can happen when calling `seal_terminate`."]
        #[doc = "The queue is filled by deleting contracts and emptied by a fixed amount each block."]
        #[doc = "Trying again during another block is the only way to resolve this issue."]
        #[codec(index = 18u8)]
        DeletionQueueFull,
        #[doc = "A contract with the same AccountId already exists."]
        #[codec(index = 19u8)]
        DuplicateContract,
        #[doc = "A contract self destructed in its constructor."]
        #[doc = ""]
        #[doc = "This can be triggered by a call to `seal_terminate`."]
        #[codec(index = 20u8)]
        TerminatedInConstructor,
        #[doc = "A call tried to invoke a contract that is flagged as non-reentrant."]
        #[codec(index = 21u8)]
        ReentranceDenied,
        #[doc = "Origin doesn't have enough balance to pay the required storage deposits."]
        #[codec(index = 22u8)]
        StorageDepositNotEnoughFunds,
        #[doc = "More storage was created than allowed by the storage deposit limit."]
        #[codec(index = 23u8)]
        StorageDepositLimitExhausted,
        #[doc = "Code removal was denied because the code is still in use by at least one contract."]
        #[codec(index = 24u8)]
        CodeInUse,
        #[doc = "The contract ran to completion but decided to revert its storage changes."]
        #[doc = "Please note that this error is only returned from extrinsics. When called directly"]
        #[doc = "or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags"]
        #[doc = "to determine whether a reversion has taken place."]
        #[codec(index = 25u8)]
        ContractReverted,
        #[doc = "The contract's code was found to be invalid during validation or instrumentation."]
        #[doc = ""]
        #[doc = "The most likely cause of this is that an API was used which is not supported by the"]
        #[doc = "node. This hapens if an older node is used with a new version of ink!. Try updating"]
        #[doc = "your node to the newest available version."]
        #[doc = ""]
        #[doc = "A more detailed error can be found on the node console if debug messages are enabled"]
        #[doc = "by supplying `-lruntime::contracts=debug`."]
        #[codec(index = 26u8)]
        CodeRejected,
        #[doc = "An indetermistic code was used in a context where this is not permitted."]
        #[codec(index = 27u8)]
        Indeterministic,
      }
      impl ContractsError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidScheduleVersion => "Contracts.InvalidScheduleVersion",
            Self::InvalidCallFlags => "Contracts.InvalidCallFlags",
            Self::OutOfGas => "Contracts.OutOfGas",
            Self::OutputBufferTooSmall => "Contracts.OutputBufferTooSmall",
            Self::TransferFailed => "Contracts.TransferFailed",
            Self::MaxCallDepthReached => "Contracts.MaxCallDepthReached",
            Self::ContractNotFound => "Contracts.ContractNotFound",
            Self::CodeTooLarge => "Contracts.CodeTooLarge",
            Self::CodeNotFound => "Contracts.CodeNotFound",
            Self::OutOfBounds => "Contracts.OutOfBounds",
            Self::DecodingFailed => "Contracts.DecodingFailed",
            Self::ContractTrapped => "Contracts.ContractTrapped",
            Self::ValueTooLarge => "Contracts.ValueTooLarge",
            Self::TerminatedWhileReentrant => "Contracts.TerminatedWhileReentrant",
            Self::InputForwarded => "Contracts.InputForwarded",
            Self::RandomSubjectTooLong => "Contracts.RandomSubjectTooLong",
            Self::TooManyTopics => "Contracts.TooManyTopics",
            Self::NoChainExtension => "Contracts.NoChainExtension",
            Self::DeletionQueueFull => "Contracts.DeletionQueueFull",
            Self::DuplicateContract => "Contracts.DuplicateContract",
            Self::TerminatedInConstructor => "Contracts.TerminatedInConstructor",
            Self::ReentranceDenied => "Contracts.ReentranceDenied",
            Self::StorageDepositNotEnoughFunds => "Contracts.StorageDepositNotEnoughFunds",
            Self::StorageDepositLimitExhausted => "Contracts.StorageDepositLimitExhausted",
            Self::CodeInUse => "Contracts.CodeInUse",
            Self::ContractReverted => "Contracts.ContractReverted",
            Self::CodeRejected => "Contracts.CodeRejected",
            Self::Indeterministic => "Contracts.Indeterministic",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ContractsError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: InvalidScheduleVersion => { & ["A new schedule must have a greater version than the current one." ,] } , Self :: InvalidCallFlags => { & ["Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`." ,] } , Self :: OutOfGas => { & ["The executed contract exhausted its gas limit." ,] } , Self :: OutputBufferTooSmall => { & ["The output buffer supplied to a contract API call was too small." ,] } , Self :: TransferFailed => { & ["Performing the requested transfer failed. Probably because there isn't enough" , "free balance in the sender's account." ,] } , Self :: MaxCallDepthReached => { & ["Performing a call was denied because the calling depth reached the limit" , "of what is specified in the schedule." ,] } , Self :: ContractNotFound => { & ["No contract was found at the specified address." ,] } , Self :: CodeTooLarge => { & ["The code supplied to `instantiate_with_code` exceeds the limit specified in the" , "current schedule." ,] } , Self :: CodeNotFound => { & ["No code could be found at the supplied code hash." ,] } , Self :: OutOfBounds => { & ["A buffer outside of sandbox memory was passed to a contract API function." ,] } , Self :: DecodingFailed => { & ["Input passed to a contract API function failed to decode as expected type." ,] } , Self :: ContractTrapped => { & ["Contract trapped during execution." ,] } , Self :: ValueTooLarge => { & ["The size defined in `T::MaxValueSize` was exceeded." ,] } , Self :: TerminatedWhileReentrant => { & ["Termination of a contract is not allowed while the contract is already" , "on the call stack. Can be triggered by `seal_terminate`." ,] } , Self :: InputForwarded => { & ["`seal_call` forwarded this contracts input. It therefore is no longer available." ,] } , Self :: RandomSubjectTooLong => { & ["The subject passed to `seal_random` exceeds the limit." ,] } , Self :: TooManyTopics => { & ["The amount of topics passed to `seal_deposit_events` exceeds the limit." ,] } , Self :: NoChainExtension => { & ["The chain does not provide a chain extension. Calling the chain extension results" , "in this error. Note that this usually  shouldn't happen as deploying such contracts" , "is rejected." ,] } , Self :: DeletionQueueFull => { & ["Removal of a contract failed because the deletion queue is full." , "" , "This can happen when calling `seal_terminate`." , "The queue is filled by deleting contracts and emptied by a fixed amount each block." , "Trying again during another block is the only way to resolve this issue." ,] } , Self :: DuplicateContract => { & ["A contract with the same AccountId already exists." ,] } , Self :: TerminatedInConstructor => { & ["A contract self destructed in its constructor." , "" , "This can be triggered by a call to `seal_terminate`." ,] } , Self :: ReentranceDenied => { & ["A call tried to invoke a contract that is flagged as non-reentrant." ,] } , Self :: StorageDepositNotEnoughFunds => { & ["Origin doesn't have enough balance to pay the required storage deposits." ,] } , Self :: StorageDepositLimitExhausted => { & ["More storage was created than allowed by the storage deposit limit." ,] } , Self :: CodeInUse => { & ["Code removal was denied because the code is still in use by at least one contract." ,] } , Self :: ContractReverted => { & ["The contract ran to completion but decided to revert its storage changes." , "Please note that this error is only returned from extrinsics. When called directly" , "or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags" , "to determine whether a reversion has taken place." ,] } , Self :: CodeRejected => { & ["The contract's code was found to be invalid during validation or instrumentation." , "" , "The most likely cause of this is that an API was used which is not supported by the" , "node. This hapens if an older node is used with a new version of ink!. Try updating" , "your node to the newest available version." , "" , "A more detailed error can be found on the node console if debug messages are enabled" , "by supplying `-lruntime::contracts=debug`." ,] } , Self :: Indeterministic => { & ["An indetermistic code was used in a context where this is not permitted." ,] } , _ => & [""] , }
        }
      }
      impl From<ContractsError> for &'static str {
        fn from(v: ContractsError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ContractsError> for &'static str {
        fn from(v: &ContractsError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ContractsEvent {
        #[doc = "Contract deployed by address at the specified address."]
        #[codec(index = 0u8)]
        Instantiated {
          deployer: ::polymesh_api_client::AccountId,
          contract: ::polymesh_api_client::AccountId,
        },
        #[doc = "Contract has been removed."]
        #[doc = ""]
        #[doc = "# Note"]
        #[doc = ""]
        #[doc = "The only way for a contract to be removed and emitting this event is by calling"]
        #[doc = "`seal_terminate`."]
        #[codec(index = 1u8)]
        Terminated {
          #[doc = "The contract that was terminated."]
          contract: ::polymesh_api_client::AccountId,
          #[doc = "The account that received the contracts remaining balance"]
          beneficiary: ::polymesh_api_client::AccountId,
        },
        #[doc = "Code with the specified hash has been stored."]
        #[codec(index = 2u8)]
        CodeStored { code_hash: primitive_types::H256 },
        #[doc = "A custom event emitted by the contract."]
        #[codec(index = 3u8)]
        ContractEmitted {
          #[doc = "The contract that emitted the event."]
          contract: ::polymesh_api_client::AccountId,
          #[doc = "Data supplied by the contract. Metadata generated during contract compilation"]
          #[doc = "is needed to decode it."]
          data: ::alloc::vec::Vec<u8>,
        },
        #[doc = "A code with the specified hash was removed."]
        #[codec(index = 4u8)]
        CodeRemoved { code_hash: primitive_types::H256 },
        #[doc = "A contract's code was updated."]
        #[codec(index = 5u8)]
        ContractCodeUpdated {
          #[doc = "The contract that has been updated."]
          contract: ::polymesh_api_client::AccountId,
          #[doc = "New code hash that was set for the contract."]
          new_code_hash: primitive_types::H256,
          #[doc = "Previous code hash of the contract."]
          old_code_hash: primitive_types::H256,
        },
        #[doc = "A contract was called either by a plain account or another contract."]
        #[doc = ""]
        #[doc = "# Note"]
        #[doc = ""]
        #[doc = "Please keep in mind that like all events this is only emitted for successful"]
        #[doc = "calls. This is because on failure all storage changes including events are"]
        #[doc = "rolled back."]
        #[codec(index = 6u8)]
        Called {
          #[doc = "The account that called the `contract`."]
          caller: ::polymesh_api_client::AccountId,
          #[doc = "The contract that was called."]
          contract: ::polymesh_api_client::AccountId,
        },
        #[doc = "A contract delegate called a code hash."]
        #[doc = ""]
        #[doc = "# Note"]
        #[doc = ""]
        #[doc = "Please keep in mind that like all events this is only emitted for successful"]
        #[doc = "calls. This is because on failure all storage changes including events are"]
        #[doc = "rolled back."]
        #[codec(index = 7u8)]
        DelegateCalled {
          #[doc = "The contract that performed the delegate call and hence in whose context"]
          #[doc = "the `code_hash` is executed."]
          contract: ::polymesh_api_client::AccountId,
          #[doc = "The code hash that was delegate called."]
          code_hash: primitive_types::H256,
        },
      }
      impl ContractsEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Instantiated { .. } => "Contracts.Instantiated",
            Self::Terminated { .. } => "Contracts.Terminated",
            Self::CodeStored { .. } => "Contracts.CodeStored",
            Self::ContractEmitted { .. } => "Contracts.ContractEmitted",
            Self::CodeRemoved { .. } => "Contracts.CodeRemoved",
            Self::ContractCodeUpdated { .. } => "Contracts.ContractCodeUpdated",
            Self::Called { .. } => "Contracts.Called",
            Self::DelegateCalled { .. } => "Contracts.DelegateCalled",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ContractsEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::Instantiated { .. } => {
              &["Contract deployed by address at the specified address."]
            }
            Self::Terminated { .. } => &[
              "Contract has been removed.",
              "",
              "# Note",
              "",
              "The only way for a contract to be removed and emitting this event is by calling",
              "`seal_terminate`.",
            ],
            Self::CodeStored { .. } => &["Code with the specified hash has been stored."],
            Self::ContractEmitted { .. } => &["A custom event emitted by the contract."],
            Self::CodeRemoved { .. } => &["A code with the specified hash was removed."],
            Self::ContractCodeUpdated { .. } => &["A contract's code was updated."],
            Self::Called { .. } => &[
              "A contract was called either by a plain account or another contract.",
              "",
              "# Note",
              "",
              "Please keep in mind that like all events this is only emitted for successful",
              "calls. This is because on failure all storage changes including events are",
              "rolled back.",
            ],
            Self::DelegateCalled { .. } => &[
              "A contract delegate called a code hash.",
              "",
              "# Note",
              "",
              "Please keep in mind that like all events this is only emitted for successful",
              "calls. This is because on failure all storage changes including events are",
              "rolled back.",
            ],
            _ => &[""],
          }
        }
      }
      impl From<ContractsEvent> for &'static str {
        fn from(v: ContractsEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ContractsEvent> for &'static str {
        fn from(v: &ContractsEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    pub mod schedule {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct HostFnWeights {
        pub caller: ::polymesh_api_client::sp_weights::Weight,
        pub is_contract: ::polymesh_api_client::sp_weights::Weight,
        pub code_hash: ::polymesh_api_client::sp_weights::Weight,
        pub own_code_hash: ::polymesh_api_client::sp_weights::Weight,
        pub caller_is_origin: ::polymesh_api_client::sp_weights::Weight,
        pub address: ::polymesh_api_client::sp_weights::Weight,
        pub gas_left: ::polymesh_api_client::sp_weights::Weight,
        pub balance: ::polymesh_api_client::sp_weights::Weight,
        pub value_transferred: ::polymesh_api_client::sp_weights::Weight,
        pub minimum_balance: ::polymesh_api_client::sp_weights::Weight,
        pub block_number: ::polymesh_api_client::sp_weights::Weight,
        pub now: ::polymesh_api_client::sp_weights::Weight,
        pub weight_to_fee: ::polymesh_api_client::sp_weights::Weight,
        pub gas: ::polymesh_api_client::sp_weights::Weight,
        pub input: ::polymesh_api_client::sp_weights::Weight,
        pub input_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub r#return: ::polymesh_api_client::sp_weights::Weight,
        pub return_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub terminate: ::polymesh_api_client::sp_weights::Weight,
        pub random: ::polymesh_api_client::sp_weights::Weight,
        pub deposit_event: ::polymesh_api_client::sp_weights::Weight,
        pub deposit_event_per_topic: ::polymesh_api_client::sp_weights::Weight,
        pub deposit_event_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub debug_message: ::polymesh_api_client::sp_weights::Weight,
        pub debug_message_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub set_storage: ::polymesh_api_client::sp_weights::Weight,
        pub set_storage_per_new_byte: ::polymesh_api_client::sp_weights::Weight,
        pub set_storage_per_old_byte: ::polymesh_api_client::sp_weights::Weight,
        pub set_code_hash: ::polymesh_api_client::sp_weights::Weight,
        pub clear_storage: ::polymesh_api_client::sp_weights::Weight,
        pub clear_storage_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub contains_storage: ::polymesh_api_client::sp_weights::Weight,
        pub contains_storage_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub get_storage: ::polymesh_api_client::sp_weights::Weight,
        pub get_storage_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub take_storage: ::polymesh_api_client::sp_weights::Weight,
        pub take_storage_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub transfer: ::polymesh_api_client::sp_weights::Weight,
        pub call: ::polymesh_api_client::sp_weights::Weight,
        pub delegate_call: ::polymesh_api_client::sp_weights::Weight,
        pub call_transfer_surcharge: ::polymesh_api_client::sp_weights::Weight,
        pub call_per_cloned_byte: ::polymesh_api_client::sp_weights::Weight,
        pub instantiate: ::polymesh_api_client::sp_weights::Weight,
        pub instantiate_transfer_surcharge: ::polymesh_api_client::sp_weights::Weight,
        pub instantiate_per_input_byte: ::polymesh_api_client::sp_weights::Weight,
        pub instantiate_per_salt_byte: ::polymesh_api_client::sp_weights::Weight,
        pub hash_sha2_256: ::polymesh_api_client::sp_weights::Weight,
        pub hash_sha2_256_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub hash_keccak_256: ::polymesh_api_client::sp_weights::Weight,
        pub hash_keccak_256_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub hash_blake2_256: ::polymesh_api_client::sp_weights::Weight,
        pub hash_blake2_256_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub hash_blake2_128: ::polymesh_api_client::sp_weights::Weight,
        pub hash_blake2_128_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub ecdsa_recover: ::polymesh_api_client::sp_weights::Weight,
        pub ecdsa_to_eth_address: ::polymesh_api_client::sp_weights::Weight,
        pub reentrance_count: ::polymesh_api_client::sp_weights::Weight,
        pub account_reentrance_count: ::polymesh_api_client::sp_weights::Weight,
        pub instantiation_nonce: ::polymesh_api_client::sp_weights::Weight,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct InstructionWeights {
        pub version: u32,
        pub fallback: u32,
        pub i64const: u32,
        pub i64load: u32,
        pub i64store: u32,
        pub select: u32,
        pub r#if: u32,
        pub br: u32,
        pub br_if: u32,
        pub br_table: u32,
        pub br_table_per_entry: u32,
        pub call: u32,
        pub call_indirect: u32,
        pub call_indirect_per_param: u32,
        pub call_per_local: u32,
        pub local_get: u32,
        pub local_set: u32,
        pub local_tee: u32,
        pub global_get: u32,
        pub global_set: u32,
        pub memory_current: u32,
        pub memory_grow: u32,
        pub i64clz: u32,
        pub i64ctz: u32,
        pub i64popcnt: u32,
        pub i64eqz: u32,
        pub i64extendsi32: u32,
        pub i64extendui32: u32,
        pub i32wrapi64: u32,
        pub i64eq: u32,
        pub i64ne: u32,
        pub i64lts: u32,
        pub i64ltu: u32,
        pub i64gts: u32,
        pub i64gtu: u32,
        pub i64les: u32,
        pub i64leu: u32,
        pub i64ges: u32,
        pub i64geu: u32,
        pub i64add: u32,
        pub i64sub: u32,
        pub i64mul: u32,
        pub i64divs: u32,
        pub i64divu: u32,
        pub i64rems: u32,
        pub i64remu: u32,
        pub i64and: u32,
        pub i64or: u32,
        pub i64xor: u32,
        pub i64shl: u32,
        pub i64shrs: u32,
        pub i64shru: u32,
        pub i64rotl: u32,
        pub i64rotr: u32,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Limits {
        pub event_topics: u32,
        pub globals: u32,
        pub locals: u32,
        pub parameters: u32,
        pub memory_pages: u32,
        pub table_size: u32,
        pub br_table_size: u32,
        pub subject_len: u32,
        pub payload_len: u32,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Schedule {
        pub limits: pallet_contracts::schedule::Limits,
        pub instruction_weights: pallet_contracts::schedule::InstructionWeights,
        pub host_fn_weights: pallet_contracts::schedule::HostFnWeights,
      }
    }
    pub mod storage {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ContractInfo {
        pub trie_id: ::alloc::vec::Vec<u8>,
        pub deposit_account: pallet_contracts::storage::DepositAccount,
        pub code_hash: primitive_types::H256,
        pub storage_bytes: u32,
        pub storage_items: u32,
        pub storage_byte_deposit: u128,
        pub storage_item_deposit: u128,
        pub storage_base_deposit: u128,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DeletedContract {
        pub trie_id: ::alloc::vec::Vec<u8>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DepositAccount(pub ::polymesh_api_client::AccountId);
    }
    pub mod wasm {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Determinism {
        #[codec(index = 0u8)]
        Deterministic,
        #[codec(index = 1u8)]
        AllowIndeterminism,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct OwnerInfo {
        pub owner: ::polymesh_api_client::AccountId,
        #[codec(compact)]
        pub deposit: u128,
        #[codec(compact)]
        pub refcount: u64,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PrefabWasmModule {
        #[codec(compact)]
        pub instruction_weights_version: u32,
        #[codec(compact)]
        pub initial: u32,
        #[codec(compact)]
        pub maximum: u32,
        pub code: ::alloc::vec::Vec<u8>,
        pub determinism: pallet_contracts::wasm::Determinism,
      }
    }
  }
  pub mod pallet_corporate_actions {
    use super::*;
    pub mod ballot {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BallotMeta {
        pub title: pallet_corporate_actions::ballot::BallotTitle,
        pub motions: ::alloc::vec::Vec<pallet_corporate_actions::ballot::Motion>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BallotTimeRange {
        pub start: u64,
        pub end: u64,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BallotTitle(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BallotVote {
        pub power: u128,
        pub fallback: Option<u16>,
      }
      #[doc = "Dispatchable calls."]
      #[doc = ""]
      #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CorporateBallotCall {
        #[doc = "Attach a corporate ballot to the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "The ballot will admit votes within `range`."]
        #[doc = "The ballot's metadata is provided by `meta`,"]
        #[doc = "which includes the ballot title, the motions, their choices, etc."]
        #[doc = "See the `BallotMeta` for more."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
        #[doc = "- `ca_id` identifies the CA to attach the ballot to."]
        #[doc = "- `range` specifies when voting starts and ends."]
        #[doc = "- `meta` specifies the ballot's metadata as aforementioned."]
        #[doc = "- `rcv` specifies whether RCV is enabled for this ballot."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
        #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
        #[doc = "- `CANotNotice` if the CA is not of the `IssuerNotice` kind."]
        #[doc = "- `StartAfterEnd` if `range.start > range.end`."]
        #[doc = "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp."]
        #[doc = "- `NoRecordDate` if CA has no record date."]
        #[doc = "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date."]
        #[doc = "- `AlreadyExists` if there's a ballot already."]
        #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
        #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
        #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
        #[codec(index = 0u8)]
        attach_ballot {
          ca_id: pallet_corporate_actions::CAId,
          range: pallet_corporate_actions::ballot::BallotTimeRange,
          meta: pallet_corporate_actions::ballot::BallotMeta,
          rcv: bool,
        },
        #[doc = "Cast `votes` in the ballot attached to the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` which must be a permissioned signer targeted by the CA."]
        #[doc = "- `ca_id` identifies the attached ballot's CA."]
        #[doc = "- `votes` specifies the balances to assign to each choice in the ballot."]
        #[doc = "   The full voting power of `origin`'s DID may be used for each motion in the ballot."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
        #[doc = "- `VotingNotStarted` if the voting period hasn't commenced yet."]
        #[doc = "- `VotingAlreadyEnded` if the voting period has ended."]
        #[doc = "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`."]
        #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
        #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
        #[doc = "- `InsufficientVotes` if the voting power used for any motion in `votes`"]
        #[doc = "   exceeds `origin`'s DID's voting power."]
        #[codec(index = 1u8)]
        vote {
          ca_id: pallet_corporate_actions::CAId,
          votes: ::alloc::vec::Vec<pallet_corporate_actions::ballot::BallotVote>,
        },
        #[doc = "Amend the end date of the ballot of the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
        #[doc = "- `ca_id` identifies the attached ballot's CA."]
        #[doc = "- `end` specifies the new end date of the ballot."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
        #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
        #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
        #[doc = "- `StartAfterEnd` if `start > end`."]
        #[codec(index = 2u8)]
        change_end {
          ca_id: pallet_corporate_actions::CAId,
          end: u64,
        },
        #[doc = "Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
        #[doc = "- `ca_id` identifies the attached ballot's CA."]
        #[doc = "- `meta` specifies the new metadata."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
        #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
        #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
        #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
        #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
        #[codec(index = 3u8)]
        change_meta {
          ca_id: pallet_corporate_actions::CAId,
          meta: pallet_corporate_actions::ballot::BallotMeta,
        },
        #[doc = "Amend RCV support for the ballot of the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
        #[doc = "- `ca_id` identifies the attached ballot's CA."]
        #[doc = "- `rcv` specifies if RCV is to be supported or not."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
        #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
        #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
        #[codec(index = 4u8)]
        change_rcv {
          ca_id: pallet_corporate_actions::CAId,
          rcv: bool,
        },
        #[doc = "Remove the ballot of the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
        #[doc = "- `ca_id` identifies the attached ballot's CA."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
        #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
        #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
        #[codec(index = 5u8)]
        remove_ballot {
          ca_id: pallet_corporate_actions::CAId,
        },
      }
      impl CorporateBallotCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::attach_ballot { .. } => "CorporateBallot.attach_ballot",
            Self::vote { .. } => "CorporateBallot.vote",
            Self::change_end { .. } => "CorporateBallot.change_end",
            Self::change_meta { .. } => "CorporateBallot.change_meta",
            Self::change_rcv { .. } => "CorporateBallot.change_rcv",
            Self::remove_ballot { .. } => "CorporateBallot.remove_ballot",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CorporateBallotCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: attach_ballot { .. } => { & ["Attach a corporate ballot to the CA identified by `ca_id`." , "" , "The ballot will admit votes within `range`." , "The ballot's metadata is provided by `meta`," , "which includes the ballot title, the motions, their choices, etc." , "See the `BallotMeta` for more." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the CA to attach the ballot to." , "- `range` specifies when voting starts and ends." , "- `meta` specifies the ballot's metadata as aforementioned." , "- `rcv` specifies whether RCV is enabled for this ballot." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `CANotNotice` if the CA is not of the `IssuerNotice` kind." , "- `StartAfterEnd` if `range.start > range.end`." , "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp." , "- `NoRecordDate` if CA has no record date." , "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date." , "- `AlreadyExists` if there's a ballot already." , "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`." , "- `TooLong` if any of the embedded strings in `meta` are too long." , "- `InsufficientBalance` if the protocol fee couldn't be charged." ,] } , Self :: vote { .. } => { & ["Cast `votes` in the ballot attached to the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` which must be a permissioned signer targeted by the CA." , "- `ca_id` identifies the attached ballot's CA." , "- `votes` specifies the balances to assign to each choice in the ballot." , "   The full voting power of `origin`'s DID may be used for each motion in the ballot." , "" , "# Errors" , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingNotStarted` if the voting period hasn't commenced yet." , "- `VotingAlreadyEnded` if the voting period has ended." , "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NotTargetedByCA` if the CA does not target `origin`'s DID." , "- `InsufficientVotes` if the voting power used for any motion in `votes`" , "   exceeds `origin`'s DID's voting power." ,] } , Self :: change_end { .. } => { & ["Amend the end date of the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the attached ballot's CA." , "- `end` specifies the new end date of the ballot." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." , "- `StartAfterEnd` if `start > end`." ,] } , Self :: change_meta { .. } => { & ["Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the attached ballot's CA." , "- `meta` specifies the new metadata." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." , "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`." , "- `TooLong` if any of the embedded strings in `meta` are too long." ,] } , Self :: change_rcv { .. } => { & ["Amend RCV support for the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the attached ballot's CA." , "- `rcv` specifies if RCV is to be supported or not." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." ,] } , Self :: remove_ballot { .. } => { & ["Remove the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the attached ballot's CA." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." ,] } , _ => & [""] , }
        }
      }
      impl From<CorporateBallotCall> for &'static str {
        fn from(v: CorporateBallotCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CorporateBallotCall> for &'static str {
        fn from(v: &CorporateBallotCall) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ChoiceTitle(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CorporateBallotError {
        #[doc = "A corporate ballot was made for a non `IssuerNotice` CA."]
        #[codec(index = 0u8)]
        CANotNotice,
        #[doc = "A corporate ballot already exists for this CA."]
        #[codec(index = 1u8)]
        AlreadyExists,
        #[doc = "A corporate ballot doesn't exist for this CA."]
        #[codec(index = 2u8)]
        NoSuchBallot,
        #[doc = "A corporate ballot's start time was strictly after the ballot's end."]
        #[codec(index = 3u8)]
        StartAfterEnd,
        #[doc = "A corporate ballot's end time was strictly before the current time."]
        #[codec(index = 4u8)]
        NowAfterEnd,
        #[doc = "If some motion in a corporate ballot has more choices than would fit in `u16`."]
        #[codec(index = 5u8)]
        NumberOfChoicesOverflow,
        #[doc = "Voting started already. Amending a ballot is no longer possible."]
        #[codec(index = 6u8)]
        VotingAlreadyStarted,
        #[doc = "Voting hasn't started yet."]
        #[codec(index = 7u8)]
        VotingNotStarted,
        #[doc = "Voting ended already."]
        #[codec(index = 8u8)]
        VotingAlreadyEnded,
        #[doc = "Provided list of balances does not match the total number of choices."]
        #[codec(index = 9u8)]
        WrongVoteCount,
        #[doc = "Voting power used by a DID on a motion exceeds that which is available to them."]
        #[codec(index = 10u8)]
        InsufficientVotes,
        #[doc = "The RCV fallback of some choice does not exist."]
        #[codec(index = 11u8)]
        NoSuchRCVFallback,
        #[doc = "The RCV fallback points to the origin choice."]
        #[codec(index = 12u8)]
        RCVSelfCycle,
        #[doc = "RCV is not allowed for this ballot."]
        #[codec(index = 13u8)]
        RCVNotAllowed,
      }
      impl CorporateBallotError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::CANotNotice => "CorporateBallot.CANotNotice",
            Self::AlreadyExists => "CorporateBallot.AlreadyExists",
            Self::NoSuchBallot => "CorporateBallot.NoSuchBallot",
            Self::StartAfterEnd => "CorporateBallot.StartAfterEnd",
            Self::NowAfterEnd => "CorporateBallot.NowAfterEnd",
            Self::NumberOfChoicesOverflow => "CorporateBallot.NumberOfChoicesOverflow",
            Self::VotingAlreadyStarted => "CorporateBallot.VotingAlreadyStarted",
            Self::VotingNotStarted => "CorporateBallot.VotingNotStarted",
            Self::VotingAlreadyEnded => "CorporateBallot.VotingAlreadyEnded",
            Self::WrongVoteCount => "CorporateBallot.WrongVoteCount",
            Self::InsufficientVotes => "CorporateBallot.InsufficientVotes",
            Self::NoSuchRCVFallback => "CorporateBallot.NoSuchRCVFallback",
            Self::RCVSelfCycle => "CorporateBallot.RCVSelfCycle",
            Self::RCVNotAllowed => "CorporateBallot.RCVNotAllowed",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CorporateBallotError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::CANotNotice => &["A corporate ballot was made for a non `IssuerNotice` CA."],
            Self::AlreadyExists => &["A corporate ballot already exists for this CA."],
            Self::NoSuchBallot => &["A corporate ballot doesn't exist for this CA."],
            Self::StartAfterEnd => {
              &["A corporate ballot's start time was strictly after the ballot's end."]
            }
            Self::NowAfterEnd => {
              &["A corporate ballot's end time was strictly before the current time."]
            }
            Self::NumberOfChoicesOverflow => {
              &["If some motion in a corporate ballot has more choices than would fit in `u16`."]
            }
            Self::VotingAlreadyStarted => {
              &["Voting started already. Amending a ballot is no longer possible."]
            }
            Self::VotingNotStarted => &["Voting hasn't started yet."],
            Self::VotingAlreadyEnded => &["Voting ended already."],
            Self::WrongVoteCount => {
              &["Provided list of balances does not match the total number of choices."]
            }
            Self::InsufficientVotes => {
              &["Voting power used by a DID on a motion exceeds that which is available to them."]
            }
            Self::NoSuchRCVFallback => &["The RCV fallback of some choice does not exist."],
            Self::RCVSelfCycle => &["The RCV fallback points to the origin choice."],
            Self::RCVNotAllowed => &["RCV is not allowed for this ballot."],
            _ => &[""],
          }
        }
      }
      impl From<CorporateBallotError> for &'static str {
        fn from(v: CorporateBallotError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CorporateBallotError> for &'static str {
        fn from(v: &CorporateBallotError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Events for this module."]
      #[doc = ""]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CorporateBallotEvent {
        #[doc = "A corporate ballot was created."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, Voting start/end, Ballot metadata, RCV enabled?)"]
        #[codec(index = 0u8)]
        Created(
          ::polymesh_api_client::IdentityId,
          pallet_corporate_actions::CAId,
          pallet_corporate_actions::ballot::BallotTimeRange,
          pallet_corporate_actions::ballot::BallotMeta,
          bool,
        ),
        #[doc = "A vote was cast in a corporate ballot."]
        #[doc = ""]
        #[doc = "(voter DID, CAId, Votes)"]
        #[codec(index = 1u8)]
        VoteCast(
          ::polymesh_api_client::IdentityId,
          pallet_corporate_actions::CAId,
          ::alloc::vec::Vec<pallet_corporate_actions::ballot::BallotVote>,
        ),
        #[doc = "A corporate ballot changed its start/end date range."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, Voting start/end)"]
        #[codec(index = 2u8)]
        RangeChanged(
          ::polymesh_api_client::IdentityId,
          pallet_corporate_actions::CAId,
          pallet_corporate_actions::ballot::BallotTimeRange,
        ),
        #[doc = "A corporate ballot changed its metadata."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, New metadata)"]
        #[codec(index = 3u8)]
        MetaChanged(
          ::polymesh_api_client::IdentityId,
          pallet_corporate_actions::CAId,
          pallet_corporate_actions::ballot::BallotMeta,
        ),
        #[doc = "A corporate ballot changed its RCV support."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, New support)"]
        #[codec(index = 4u8)]
        RCVChanged(
          ::polymesh_api_client::IdentityId,
          pallet_corporate_actions::CAId,
          bool,
        ),
        #[doc = "A corporate ballot was removed."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID)"]
        #[codec(index = 5u8)]
        Removed(
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          pallet_corporate_actions::CAId,
        ),
      }
      impl CorporateBallotEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Created(_, _, _, _, _) => "CorporateBallot.Created",
            Self::VoteCast(_, _, _) => "CorporateBallot.VoteCast",
            Self::RangeChanged(_, _, _) => "CorporateBallot.RangeChanged",
            Self::MetaChanged(_, _, _) => "CorporateBallot.MetaChanged",
            Self::RCVChanged(_, _, _) => "CorporateBallot.RCVChanged",
            Self::Removed(_, _) => "CorporateBallot.Removed",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CorporateBallotEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::Created(_, _, _, _, _) => &[
              "A corporate ballot was created.",
              "",
              "(Agent DID, CA's ID, Voting start/end, Ballot metadata, RCV enabled?)",
            ],
            Self::VoteCast(_, _, _) => &[
              "A vote was cast in a corporate ballot.",
              "",
              "(voter DID, CAId, Votes)",
            ],
            Self::RangeChanged(_, _, _) => &[
              "A corporate ballot changed its start/end date range.",
              "",
              "(Agent DID, CA's ID, Voting start/end)",
            ],
            Self::MetaChanged(_, _, _) => &[
              "A corporate ballot changed its metadata.",
              "",
              "(Agent DID, CA's ID, New metadata)",
            ],
            Self::RCVChanged(_, _, _) => &[
              "A corporate ballot changed its RCV support.",
              "",
              "(Agent DID, CA's ID, New support)",
            ],
            Self::Removed(_, _) => &[
              "A corporate ballot was removed.",
              "",
              "(Agent DID, CA's ID)",
            ],
            _ => &[""],
          }
        }
      }
      impl From<CorporateBallotEvent> for &'static str {
        fn from(v: CorporateBallotEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CorporateBallotEvent> for &'static str {
        fn from(v: &CorporateBallotEvent) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Motion {
        pub title: pallet_corporate_actions::ballot::MotionTitle,
        pub info_link: pallet_corporate_actions::ballot::MotionInfoLink,
        pub choices: ::alloc::vec::Vec<pallet_corporate_actions::ballot::ChoiceTitle>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct MotionInfoLink(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct MotionTitle(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Version(pub u8);
    }
    pub mod distribution {
      use super::*;
      #[doc = "Dispatchable calls."]
      #[doc = ""]
      #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CapitalDistributionCall {
        #[doc = "Start and attach a capital distribution, to the CA identified by `ca_id`,"]
        #[doc = "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID."]
        #[doc = ""]
        #[doc = "The distribution will commence at `payment_at` and expire at `expires_at`,"]
        #[doc = "if provided, or if `None`, then there's no expiry."]
        #[doc = ""]
        #[doc = "The funds will be locked in `portfolio` from when `distribute` is called."]
        #[doc = "When there's no expiry, some funds may be locked indefinitely in `portfolio`,"]
        #[doc = "due to claimants not withdrawing or no benefits being pushed to them."]
        #[doc = "For indivisible currencies, unlocked amounts, of less than one whole unit,"]
        #[doc = "will not be transferable from `portfolio`."]
        #[doc = "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units,"]
        #[doc = "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`,"]
        #[doc = "which is now transferrable."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
        #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
        #[doc = "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from."]
        #[doc = "- `currency` to withdraw and distribute from the `portfolio`."]
        #[doc = "- `per_share` amount of `currency` to withdraw and distribute."]
        #[doc = "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token."]
        #[doc = "- `amount` of `currency` to withdraw and distribute at most."]
        #[doc = "- `payment_at` specifies when benefits may first be pushed or claimed."]
        #[doc = "- `expires_at` specifies, if provided, when remaining benefits are forfeit"]
        #[doc = "   and may be reclaimed by `origin`."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
        #[doc = "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`."]
        #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
        #[doc = "- `NoRecordDate` if CA has no record date."]
        #[doc = "- `RecordDateAfterStart` if CA's record date > payment_at."]
        #[doc = "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`."]
        #[doc = "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`."]
        #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
        #[doc = "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit"]
        #[doc = "- `DistributionAmountIsZero` if the `amount` is zero."]
        #[doc = "- `DistributionPerShareIsZero` if the `per_share` is zero."]
        #[doc = ""]
        #[doc = "# Permissions"]
        #[doc = "* Asset"]
        #[doc = "* Portfolio"]
        #[codec(index = 0u8)]
        distribute {
          ca_id: pallet_corporate_actions::CAId,
          portfolio: Option<polymesh_primitives::identity_id::PortfolioNumber>,
          currency: ::polymesh_api_client::AssetId,
          per_share: u128,
          amount: u128,
          payment_at: u64,
          expires_at: Option<u64>,
        },
        #[doc = "Claim a benefit of the capital distribution attached to `ca_id`."]
        #[doc = ""]
        #[doc = "Taxes are withheld as specified by the CA."]
        #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
        #[doc = ""]
        #[doc = "All benefits are rounded by truncation, down to first integer below."]
        #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
        #[doc = "they are rounded down to a whole unit."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` which must be a holder of the asset and eligible for the distribution."]
        #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit."]
        #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
        #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
        #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
        #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
        #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
        #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
        #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
        #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
        #[codec(index = 1u8)]
        claim {
          ca_id: pallet_corporate_actions::CAId,
        },
        #[doc = "Push benefit of an ongoing distribution to the given `holder`."]
        #[doc = ""]
        #[doc = "Taxes are withheld as specified by the CA."]
        #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
        #[doc = ""]
        #[doc = "All benefits are rounded by truncation, down to first integer below."]
        #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
        #[doc = "they are rounded down to a whole unit."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
        #[doc = "- `ca_id` identifies the CA with a capital distributions to push benefits for."]
        #[doc = "- `holder` to push benefits to."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
        #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
        #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
        #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
        #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
        #[doc = "- `NotTargetedByCA` if the CA does not target `holder`."]
        #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
        #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
        #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
        #[codec(index = 2u8)]
        push_benefit {
          ca_id: pallet_corporate_actions::CAId,
          holder: ::polymesh_api_client::IdentityId,
        },
        #[doc = "Assuming a distribution has expired,"]
        #[doc = "unlock the remaining amount in the distributor portfolio."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` which must be the creator of the capital distribution tied to `ca_id`."]
        #[doc = "- `ca_id` identifies the CA with a capital distribution to reclaim for."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
        #[doc = "- `AlreadyReclaimed` if this function has already been called successfully."]
        #[doc = "- `NotExpired` if `now < expiry`."]
        #[codec(index = 3u8)]
        reclaim {
          ca_id: pallet_corporate_actions::CAId,
        },
        #[doc = "Removes a distribution that hasn't started yet,"]
        #[doc = "unlocking the full amount in the distributor portfolio."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
        #[doc = "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
        #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
        #[doc = "- `DistributionStarted` if `payment_at <= now`."]
        #[codec(index = 4u8)]
        remove_distribution {
          ca_id: pallet_corporate_actions::CAId,
        },
      }
      impl CapitalDistributionCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::distribute { .. } => "CapitalDistribution.distribute",
            Self::claim { .. } => "CapitalDistribution.claim",
            Self::push_benefit { .. } => "CapitalDistribution.push_benefit",
            Self::reclaim { .. } => "CapitalDistribution.reclaim",
            Self::remove_distribution { .. } => "CapitalDistribution.remove_distribution",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CapitalDistributionCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: distribute { .. } => { & ["Start and attach a capital distribution, to the CA identified by `ca_id`," , "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID." , "" , "The distribution will commence at `payment_at` and expire at `expires_at`," , "if provided, or if `None`, then there's no expiry." , "" , "The funds will be locked in `portfolio` from when `distribute` is called." , "When there's no expiry, some funds may be locked indefinitely in `portfolio`," , "due to claimants not withdrawing or no benefits being pushed to them." , "For indivisible currencies, unlocked amounts, of less than one whole unit," , "will not be transferable from `portfolio`." , "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units," , "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`," , "which is now transferrable." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the CA to start a capital distribution for." , "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from." , "- `currency` to withdraw and distribute from the `portfolio`." , "- `per_share` amount of `currency` to withdraw and distribute." , "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token." , "- `amount` of `currency` to withdraw and distribute at most." , "- `payment_at` specifies when benefits may first be pushed or claimed." , "- `expires_at` specifies, if provided, when remaining benefits are forfeit" , "   and may be reclaimed by `origin`." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NoRecordDate` if CA has no record date." , "- `RecordDateAfterStart` if CA's record date > payment_at." , "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`." , "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`." , "- `InsufficientBalance` if the protocol fee couldn't be charged." , "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit" , "- `DistributionAmountIsZero` if the `amount` is zero." , "- `DistributionPerShareIsZero` if the `per_share` is zero." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: claim { .. } => { & ["Claim a benefit of the capital distribution attached to `ca_id`." , "" , "Taxes are withheld as specified by the CA." , "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID." , "" , "All benefits are rounded by truncation, down to first integer below." , "Moreover, before post-tax earnings, in indivisible currencies are transferred," , "they are rounded down to a whole unit." , "" , "## Arguments" , "- `origin` which must be a holder of the asset and eligible for the distribution." , "- `ca_id` identifies the CA to start a capital distribution for." , "" , "# Errors" , "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit." , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `CannotClaimBeforeStart` if `now < payment_at`." , "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NotTargetedByCA` if the CA does not target `origin`'s DID." , "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow." , "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow." , "- Other errors can occur if the compliance manager rejects the transfer." ,] } , Self :: push_benefit { .. } => { & ["Push benefit of an ongoing distribution to the given `holder`." , "" , "Taxes are withheld as specified by the CA." , "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID." , "" , "All benefits are rounded by truncation, down to first integer below." , "Moreover, before post-tax earnings, in indivisible currencies are transferred," , "they are rounded down to a whole unit." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the CA with a capital distributions to push benefits for." , "- `holder` to push benefits to." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `CannotClaimBeforeStart` if `now < payment_at`." , "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NotTargetedByCA` if the CA does not target `holder`." , "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow." , "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow." , "- Other errors can occur if the compliance manager rejects the transfer." ,] } , Self :: reclaim { .. } => { & ["Assuming a distribution has expired," , "unlock the remaining amount in the distributor portfolio." , "" , "## Arguments" , "- `origin` which must be the creator of the capital distribution tied to `ca_id`." , "- `ca_id` identifies the CA with a capital distribution to reclaim for." , "" , "# Errors" , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `AlreadyReclaimed` if this function has already been called successfully." , "- `NotExpired` if `now < expiry`." ,] } , Self :: remove_distribution { .. } => { & ["Removes a distribution that hasn't started yet," , "unlocking the full amount in the distributor portfolio." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `DistributionStarted` if `payment_at <= now`." ,] } , _ => & [""] , }
        }
      }
      impl From<CapitalDistributionCall> for &'static str {
        fn from(v: CapitalDistributionCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CapitalDistributionCall> for &'static str {
        fn from(v: &CapitalDistributionCall) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Distribution {
        pub from: polymesh_primitives::identity_id::PortfolioId,
        pub currency: ::polymesh_api_client::AssetId,
        pub per_share: u128,
        pub amount: u128,
        pub remaining: u128,
        pub reclaimed: bool,
        pub payment_at: u64,
        pub expires_at: Option<u64>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CapitalDistributionError {
        #[doc = "A capital distribution was made for a non-benefit CA."]
        #[codec(index = 0u8)]
        CANotBenefit,
        #[doc = "A distribution already exists for this CA."]
        #[codec(index = 1u8)]
        AlreadyExists,
        #[doc = "A distributions provided expiry date was strictly before its payment date."]
        #[doc = "In other words, everything to distribute would immediately be forfeited."]
        #[codec(index = 2u8)]
        ExpiryBeforePayment,
        #[doc = "The token holder has already been paid their benefit."]
        #[codec(index = 3u8)]
        HolderAlreadyPaid,
        #[doc = "A capital distribution doesn't exist for this CA."]
        #[codec(index = 4u8)]
        NoSuchDistribution,
        #[doc = "Distribution allotment cannot be claimed as the current time is before start-of-payment."]
        #[codec(index = 5u8)]
        CannotClaimBeforeStart,
        #[doc = "Distribution's expiry has passed. DID cannot claim anymore and has forfeited the benefits."]
        #[codec(index = 6u8)]
        CannotClaimAfterExpiry,
        #[doc = "Multiplication of the balance with the per share payout amount overflowed."]
        #[codec(index = 7u8)]
        BalancePerShareProductOverflowed,
        #[doc = "DID is not the one who created the distribution."]
        #[codec(index = 8u8)]
        NotDistributionCreator,
        #[doc = "DID who created the distribution already did reclaim."]
        #[codec(index = 9u8)]
        AlreadyReclaimed,
        #[doc = "Distribution had not expired yet, or there's no expiry date."]
        #[codec(index = 10u8)]
        NotExpired,
        #[doc = "A distribution has been activated, as `payment_at <= now` holds."]
        #[codec(index = 11u8)]
        DistributionStarted,
        #[doc = "A distribution has insufficient remaining amount of currency to distribute."]
        #[codec(index = 12u8)]
        InsufficientRemainingAmount,
        #[doc = "Distribution `amount` cannot be zero."]
        #[codec(index = 13u8)]
        DistributionAmountIsZero,
        #[doc = "Distribution `per_share` cannot be zero."]
        #[codec(index = 14u8)]
        DistributionPerShareIsZero,
      }
      impl CapitalDistributionError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::CANotBenefit => "CapitalDistribution.CANotBenefit",
            Self::AlreadyExists => "CapitalDistribution.AlreadyExists",
            Self::ExpiryBeforePayment => "CapitalDistribution.ExpiryBeforePayment",
            Self::HolderAlreadyPaid => "CapitalDistribution.HolderAlreadyPaid",
            Self::NoSuchDistribution => "CapitalDistribution.NoSuchDistribution",
            Self::CannotClaimBeforeStart => "CapitalDistribution.CannotClaimBeforeStart",
            Self::CannotClaimAfterExpiry => "CapitalDistribution.CannotClaimAfterExpiry",
            Self::BalancePerShareProductOverflowed => {
              "CapitalDistribution.BalancePerShareProductOverflowed"
            }
            Self::NotDistributionCreator => "CapitalDistribution.NotDistributionCreator",
            Self::AlreadyReclaimed => "CapitalDistribution.AlreadyReclaimed",
            Self::NotExpired => "CapitalDistribution.NotExpired",
            Self::DistributionStarted => "CapitalDistribution.DistributionStarted",
            Self::InsufficientRemainingAmount => "CapitalDistribution.InsufficientRemainingAmount",
            Self::DistributionAmountIsZero => "CapitalDistribution.DistributionAmountIsZero",
            Self::DistributionPerShareIsZero => "CapitalDistribution.DistributionPerShareIsZero",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CapitalDistributionError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: CANotBenefit => { & ["A capital distribution was made for a non-benefit CA." ,] } , Self :: AlreadyExists => { & ["A distribution already exists for this CA." ,] } , Self :: ExpiryBeforePayment => { & ["A distributions provided expiry date was strictly before its payment date." , "In other words, everything to distribute would immediately be forfeited." ,] } , Self :: HolderAlreadyPaid => { & ["The token holder has already been paid their benefit." ,] } , Self :: NoSuchDistribution => { & ["A capital distribution doesn't exist for this CA." ,] } , Self :: CannotClaimBeforeStart => { & ["Distribution allotment cannot be claimed as the current time is before start-of-payment." ,] } , Self :: CannotClaimAfterExpiry => { & ["Distribution's expiry has passed. DID cannot claim anymore and has forfeited the benefits." ,] } , Self :: BalancePerShareProductOverflowed => { & ["Multiplication of the balance with the per share payout amount overflowed." ,] } , Self :: NotDistributionCreator => { & ["DID is not the one who created the distribution." ,] } , Self :: AlreadyReclaimed => { & ["DID who created the distribution already did reclaim." ,] } , Self :: NotExpired => { & ["Distribution had not expired yet, or there's no expiry date." ,] } , Self :: DistributionStarted => { & ["A distribution has been activated, as `payment_at <= now` holds." ,] } , Self :: InsufficientRemainingAmount => { & ["A distribution has insufficient remaining amount of currency to distribute." ,] } , Self :: DistributionAmountIsZero => { & ["Distribution `amount` cannot be zero." ,] } , Self :: DistributionPerShareIsZero => { & ["Distribution `per_share` cannot be zero." ,] } , _ => & [""] , }
        }
      }
      impl From<CapitalDistributionError> for &'static str {
        fn from(v: CapitalDistributionError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CapitalDistributionError> for &'static str {
        fn from(v: &CapitalDistributionError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Events for this module."]
      #[doc = ""]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CapitalDistributionEvent {
        #[doc = "A capital distribution, with details included,"]
        #[doc = "was created by the DID (permissioned agent) for the CA identified by `CAId`."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, distribution details)"]
        #[codec(index = 0u8)]
        Created(
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          pallet_corporate_actions::CAId,
          pallet_corporate_actions::distribution::Distribution,
        ),
        #[doc = "A token holder's benefit of a capital distribution for the given `CAId` was claimed."]
        #[doc = ""]
        #[doc = "(Caller DID, Holder/Claimant DID, CA's ID, updated distribution details, DID's benefit, DID's tax %)"]
        #[codec(index = 1u8)]
        BenefitClaimed(
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          pallet_corporate_actions::CAId,
          pallet_corporate_actions::distribution::Distribution,
          u128,
          ::polymesh_api_client::per_things::Permill,
        ),
        #[doc = "Stats from `push_benefit` was emitted."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, max requested DIDs, processed DIDs, failed DIDs)"]
        #[codec(index = 2u8)]
        Reclaimed(
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          pallet_corporate_actions::CAId,
          u128,
        ),
        #[doc = "A capital distribution was removed."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID)"]
        #[codec(index = 3u8)]
        Removed(
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          pallet_corporate_actions::CAId,
        ),
      }
      impl CapitalDistributionEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Created(_, _, _) => "CapitalDistribution.Created",
            Self::BenefitClaimed(_, _, _, _, _, _) => "CapitalDistribution.BenefitClaimed",
            Self::Reclaimed(_, _, _) => "CapitalDistribution.Reclaimed",
            Self::Removed(_, _) => "CapitalDistribution.Removed",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CapitalDistributionEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: Created (_ , _ , _) => { & ["A capital distribution, with details included," , "was created by the DID (permissioned agent) for the CA identified by `CAId`." , "" , "(Agent DID, CA's ID, distribution details)" ,] } , Self :: BenefitClaimed (_ , _ , _ , _ , _ , _) => { & ["A token holder's benefit of a capital distribution for the given `CAId` was claimed." , "" , "(Caller DID, Holder/Claimant DID, CA's ID, updated distribution details, DID's benefit, DID's tax %)" ,] } , Self :: Reclaimed (_ , _ , _) => { & ["Stats from `push_benefit` was emitted." , "" , "(Agent DID, CA's ID, max requested DIDs, processed DIDs, failed DIDs)" ,] } , Self :: Removed (_ , _) => { & ["A capital distribution was removed." , "" , "(Agent DID, CA's ID)" ,] } , _ => & [""] , }
        }
      }
      impl From<CapitalDistributionEvent> for &'static str {
        fn from(v: CapitalDistributionEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CapitalDistributionEvent> for &'static str {
        fn from(v: &CapitalDistributionEvent) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Version(pub u8);
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum CACheckpoint {
      #[codec(index = 0u8)]
      Scheduled(polymesh_primitives::checkpoint::ScheduleId, u64),
      #[codec(index = 1u8)]
      Existing(polymesh_primitives::asset::CheckpointId),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct CADetails(pub ::alloc::vec::Vec<u8>);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct CAId {
      pub asset_id: ::polymesh_api_client::AssetId,
      pub local_id: pallet_corporate_actions::LocalCAId,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum CAKind {
      #[codec(index = 0u8)]
      PredictableBenefit,
      #[codec(index = 1u8)]
      UnpredictableBenefit,
      #[codec(index = 2u8)]
      IssuerNotice,
      #[codec(index = 3u8)]
      Reorganization,
      #[codec(index = 4u8)]
      Other,
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum CorporateActionCall {
      #[doc = "Set the max `length` of `details` in terms of bytes."]
      #[doc = "May only be called via a PIP."]
      #[codec(index = 0u8)]
      set_max_details_length { length: u32 },
      #[doc = "Set the default CA `TargetIdentities` to `targets`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` for which the default identities are changing."]
      #[doc = "- `targets` the default target identities for a CA."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 1u8)]
      set_default_targets {
        asset_id: ::polymesh_api_client::AssetId,
        targets: pallet_corporate_actions::TargetIdentities,
      },
      #[doc = "Set the default withholding tax for all DIDs and CAs relevant to this `asset_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` that the withholding tax will apply to."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 2u8)]
      set_default_withholding_tax {
        asset_id: ::polymesh_api_client::AssetId,
        tax: ::polymesh_api_client::per_things::Permill,
      },
      #[doc = "Set the withholding tax of `asset_id` for `taxed_did` to `tax`."]
      #[doc = "If `Some(tax)`, this overrides the default withholding tax of `asset_id` to `tax` for `taxed_did`."]
      #[doc = "Otherwise, if `None`, the default withholding tax will be used."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` that the withholding tax will apply to."]
      #[doc = "- `taxed_did` that will have its withholding tax updated."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 3u8)]
      set_did_withholding_tax {
        asset_id: ::polymesh_api_client::AssetId,
        taxed_did: ::polymesh_api_client::IdentityId,
        tax: Option<::polymesh_api_client::per_things::Permill>,
      },
      #[doc = "Initiates a CA for `asset_id` of `kind` with `details` and other provided arguments."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` that the CA is made for."]
      #[doc = "- `kind` of CA being initiated."]
      #[doc = "- `decl_date` of CA bring initialized."]
      #[doc = "- `record_date`, if any, to calculate the impact of this CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = "- `details` of the CA in free-text form, up to a certain number of bytes in length."]
      #[doc = "- `targets`, if any, which this CA is relevant/irrelevant to."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_targets`)."]
      #[doc = "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)."]
      #[doc = "- `withholding_tax`, if any, provides per-DID withholding tax overrides."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `CounterOverflow` in the unlikely event that so many CAs were created for this `asset_id`,"]
      #[doc = "  that integer overflow would have occured if instead allowed."]
      #[doc = "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`."]
      #[doc = "- `DuplicateDidTax` if a DID is included more than once in `wt`."]
      #[doc = "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`."]
      #[doc = "- `DeclDateInFuture` if the declaration date is not in the past."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 4u8)]
      initiate_corporate_action {
        asset_id: ::polymesh_api_client::AssetId,
        kind: pallet_corporate_actions::CAKind,
        decl_date: u64,
        record_date: Option<pallet_corporate_actions::RecordDateSpec>,
        details: pallet_corporate_actions::CADetails,
        targets: Option<pallet_corporate_actions::TargetIdentities>,
        default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
        withholding_tax: Option<
          ::alloc::vec::Vec<(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::per_things::Permill,
          )>,
        >,
      },
      #[doc = "Link the given CA `id` to the given `docs`."]
      #[doc = "Any previous links for the CA are removed in favor of `docs`."]
      #[doc = ""]
      #[doc = "The workflow here is to add the documents and initiating the CA in any order desired."]
      #[doc = "Once both exist, they can now be linked together."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `id.asset_id` with relevant permissions."]
      #[doc = "- `id` of the CA to associate with `docs`."]
      #[doc = "- `docs` to associate with the CA with `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- `NoSuchDoc` if any of `docs` does not identify an existing document."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 5u8)]
      link_ca_doc {
        id: pallet_corporate_actions::CAId,
        docs: ::alloc::vec::Vec<polymesh_primitives::document::DocumentId>,
      },
      #[doc = "Removes the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "Associated data, such as document links, ballots,"]
      #[doc = "and capital distributions are also removed."]
      #[doc = ""]
      #[doc = "Any schedule associated with the record date will see"]
      #[doc = "`strong_ref_count(schedule_id)` decremented."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 6u8)]
      remove_ca {
        ca_id: pallet_corporate_actions::CAId,
      },
      #[doc = "Changes the record date of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to alter."]
      #[doc = "- `record_date`, if any, to calculate the impact of the CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 7u8)]
      change_record_date {
        ca_id: pallet_corporate_actions::CAId,
        record_date: Option<pallet_corporate_actions::RecordDateSpec>,
      },
      #[doc = "Utility extrinsic to batch `initiate_corporate_action` and `distribute`"]
      #[codec(index = 8u8)]
      initiate_corporate_action_and_distribute {
        ca_args: pallet_corporate_actions::InitiateCorporateActionArgs,
        portfolio: Option<polymesh_primitives::identity_id::PortfolioNumber>,
        currency: ::polymesh_api_client::AssetId,
        per_share: u128,
        amount: u128,
        payment_at: u64,
        expires_at: Option<u64>,
      },
    }
    impl CorporateActionCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_max_details_length { .. } => "CorporateAction.set_max_details_length",
          Self::set_default_targets { .. } => "CorporateAction.set_default_targets",
          Self::set_default_withholding_tax { .. } => "CorporateAction.set_default_withholding_tax",
          Self::set_did_withholding_tax { .. } => "CorporateAction.set_did_withholding_tax",
          Self::initiate_corporate_action { .. } => "CorporateAction.initiate_corporate_action",
          Self::link_ca_doc { .. } => "CorporateAction.link_ca_doc",
          Self::remove_ca { .. } => "CorporateAction.remove_ca",
          Self::change_record_date { .. } => "CorporateAction.change_record_date",
          Self::initiate_corporate_action_and_distribute { .. } => {
            "CorporateAction.initiate_corporate_action_and_distribute"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for CorporateActionCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_max_details_length { .. } => { & ["Set the max `length` of `details` in terms of bytes." , "May only be called via a PIP." ,] } , Self :: set_default_targets { .. } => { & ["Set the default CA `TargetIdentities` to `targets`." , "" , "## Arguments" , "- `origin` which must be an external agent of `asset_id` with relevant permissions." , "- `asset_id` for which the default identities are changing." , "- `targets` the default target identities for a CA." , "" , "## Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`." , "" , "# Permissions" , "* Asset" ,] } , Self :: set_default_withholding_tax { .. } => { & ["Set the default withholding tax for all DIDs and CAs relevant to this `asset_id`." , "" , "## Arguments" , "- `origin` which must be an external agent of `asset_id` with relevant permissions." , "- `asset_id` that the withholding tax will apply to." , "- `tax` that should be withheld when distributing dividends, etc." , "" , "## Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "" , "# Permissions" , "* Asset" ,] } , Self :: set_did_withholding_tax { .. } => { & ["Set the withholding tax of `asset_id` for `taxed_did` to `tax`." , "If `Some(tax)`, this overrides the default withholding tax of `asset_id` to `tax` for `taxed_did`." , "Otherwise, if `None`, the default withholding tax will be used." , "" , "## Arguments" , "- `origin` which must be an external agent of `asset_id` with relevant permissions." , "- `asset_id` that the withholding tax will apply to." , "- `taxed_did` that will have its withholding tax updated." , "- `tax` that should be withheld when distributing dividends, etc." , "" , "## Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`." , "" , "# Permissions" , "* Asset" ,] } , Self :: initiate_corporate_action { .. } => { & ["Initiates a CA for `asset_id` of `kind` with `details` and other provided arguments." , "" , "## Arguments" , "- `origin` which must be an external agent of `asset_id` with relevant permissions." , "- `asset_id` that the CA is made for." , "- `kind` of CA being initiated." , "- `decl_date` of CA bring initialized." , "- `record_date`, if any, to calculate the impact of this CA." , "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date." , "- `details` of the CA in free-text form, up to a certain number of bytes in length." , "- `targets`, if any, which this CA is relevant/irrelevant to." , "   Overrides, if provided, the default at the asset level (`set_default_targets`)." , "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA." , "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)." , "- `withholding_tax`, if any, provides per-DID withholding tax overrides." , "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)." , "" , "# Errors" , "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `CounterOverflow` in the unlikely event that so many CAs were created for this `asset_id`," , "  that integer overflow would have occured if instead allowed." , "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`." , "- `DuplicateDidTax` if a DID is included more than once in `wt`." , "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`." , "- `DeclDateInFuture` if the declaration date is not in the past." , "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur." , "" , "# Permissions" , "* Asset" ,] } , Self :: link_ca_doc { .. } => { & ["Link the given CA `id` to the given `docs`." , "Any previous links for the CA are removed in favor of `docs`." , "" , "The workflow here is to add the documents and initiating the CA in any order desired." , "Once both exist, they can now be linked together." , "" , "## Arguments" , "- `origin` which must be an external agent of `id.asset_id` with relevant permissions." , "- `id` of the CA to associate with `docs`." , "- `docs` to associate with the CA with `id`." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchCA` if `id` does not identify an existing CA." , "- `NoSuchDoc` if any of `docs` does not identify an existing document." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_ca { .. } => { & ["Removes the CA identified by `ca_id`." , "" , "Associated data, such as document links, ballots," , "and capital distributions are also removed." , "" , "Any schedule associated with the record date will see" , "`strong_ref_count(schedule_id)` decremented." , "" , "## Arguments" , "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions." , "- `ca_id` of the CA to remove." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchCA` if `id` does not identify an existing CA." , "" , "# Permissions" , "* Asset" ,] } , Self :: change_record_date { .. } => { & ["Changes the record date of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions." , "- `ca_id` of the CA to alter." , "- `record_date`, if any, to calculate the impact of the CA." , "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchCA` if `id` does not identify an existing CA." , "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur." , "" , "# Permissions" , "* Asset" ,] } , Self :: initiate_corporate_action_and_distribute { .. } => { & ["Utility extrinsic to batch `initiate_corporate_action` and `distribute`" ,] } , _ => & [""] , }
      }
    }
    impl From<CorporateActionCall> for &'static str {
      fn from(v: CorporateActionCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&CorporateActionCall> for &'static str {
      fn from(v: &CorporateActionCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct CorporateAction {
      pub kind: pallet_corporate_actions::CAKind,
      pub decl_date: u64,
      pub record_date: Option<pallet_corporate_actions::RecordDate>,
      pub targets: pallet_corporate_actions::TargetIdentities,
      pub default_withholding_tax: ::polymesh_api_client::per_things::Permill,
      pub withholding_tax: ::alloc::vec::Vec<(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::per_things::Permill,
      )>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum CorporateActionError {
      #[doc = "The `details` of a CA exceeded the max allowed length."]
      #[codec(index = 0u8)]
      DetailsTooLong,
      #[doc = "A withholding tax override for a given DID was specified more than once."]
      #[doc = "The chain refused to make a choice, and hence there was an error."]
      #[codec(index = 1u8)]
      DuplicateDidTax,
      #[doc = "Too many withholding tax overrides were specified."]
      #[codec(index = 2u8)]
      TooManyDidTaxes,
      #[doc = "Too many identities in `TargetIdentities` were specified."]
      #[codec(index = 3u8)]
      TooManyTargetIds,
      #[doc = "On CA creation, a checkpoint ID was provided which doesn't exist."]
      #[codec(index = 4u8)]
      NoSuchCheckpointId,
      #[doc = "A CA with the given `CAId` did not exist."]
      #[codec(index = 5u8)]
      NoSuchCA,
      #[doc = "The CA did not have a record date."]
      #[codec(index = 6u8)]
      NoRecordDate,
      #[doc = "A CA's record date was strictly after the \"start\" time,"]
      #[doc = "where \"start\" is context dependent."]
      #[doc = "For example, it could be the start of a ballot, or the start-of-payment in capital distribution."]
      #[codec(index = 7u8)]
      RecordDateAfterStart,
      #[doc = "A CA's declaration date was strictly after its record date."]
      #[codec(index = 8u8)]
      DeclDateAfterRecordDate,
      #[doc = "A CA's declaration date occurs in the future."]
      #[codec(index = 9u8)]
      DeclDateInFuture,
      #[doc = "CA does not target the DID."]
      #[codec(index = 10u8)]
      NotTargetedByCA,
    }
    impl CorporateActionError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::DetailsTooLong => "CorporateAction.DetailsTooLong",
          Self::DuplicateDidTax => "CorporateAction.DuplicateDidTax",
          Self::TooManyDidTaxes => "CorporateAction.TooManyDidTaxes",
          Self::TooManyTargetIds => "CorporateAction.TooManyTargetIds",
          Self::NoSuchCheckpointId => "CorporateAction.NoSuchCheckpointId",
          Self::NoSuchCA => "CorporateAction.NoSuchCA",
          Self::NoRecordDate => "CorporateAction.NoRecordDate",
          Self::RecordDateAfterStart => "CorporateAction.RecordDateAfterStart",
          Self::DeclDateAfterRecordDate => "CorporateAction.DeclDateAfterRecordDate",
          Self::DeclDateInFuture => "CorporateAction.DeclDateInFuture",
          Self::NotTargetedByCA => "CorporateAction.NotTargetedByCA",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for CorporateActionError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: DetailsTooLong => { & ["The `details` of a CA exceeded the max allowed length." ,] } , Self :: DuplicateDidTax => { & ["A withholding tax override for a given DID was specified more than once." , "The chain refused to make a choice, and hence there was an error." ,] } , Self :: TooManyDidTaxes => { & ["Too many withholding tax overrides were specified." ,] } , Self :: TooManyTargetIds => { & ["Too many identities in `TargetIdentities` were specified." ,] } , Self :: NoSuchCheckpointId => { & ["On CA creation, a checkpoint ID was provided which doesn't exist." ,] } , Self :: NoSuchCA => { & ["A CA with the given `CAId` did not exist." ,] } , Self :: NoRecordDate => { & ["The CA did not have a record date." ,] } , Self :: RecordDateAfterStart => { & ["A CA's record date was strictly after the \"start\" time," , "where \"start\" is context dependent." , "For example, it could be the start of a ballot, or the start-of-payment in capital distribution." ,] } , Self :: DeclDateAfterRecordDate => { & ["A CA's declaration date was strictly after its record date." ,] } , Self :: DeclDateInFuture => { & ["A CA's declaration date occurs in the future." ,] } , Self :: NotTargetedByCA => { & ["CA does not target the DID." ,] } , _ => & [""] , }
      }
    }
    impl From<CorporateActionError> for &'static str {
      fn from(v: CorporateActionError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&CorporateActionError> for &'static str {
      fn from(v: &CorporateActionError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum CorporateActionEvent {
      #[doc = "The maximum length of `details` in bytes was changed."]
      #[doc = "(GC DID, new length)"]
      #[codec(index = 0u8)]
      MaxDetailsLengthChanged(::polymesh_api_client::IdentityId, u32),
      #[doc = "The set of default `TargetIdentities` for the asset changed."]
      #[doc = "(Agent DID, AssetId, New TargetIdentities)"]
      #[codec(index = 1u8)]
      DefaultTargetIdentitiesChanged(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::AssetId,
        pallet_corporate_actions::TargetIdentities,
      ),
      #[doc = "The default withholding tax for the asset changed."]
      #[doc = "(Agent DID, AssetId, New Tax)."]
      #[codec(index = 2u8)]
      DefaultWithholdingTaxChanged(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::AssetId,
        ::polymesh_api_client::per_things::Permill,
      ),
      #[doc = "The withholding tax specific to a DID for the asset changed."]
      #[doc = "(Agent DID, AssetId, Taxed DID, New Tax)."]
      #[codec(index = 3u8)]
      DidWithholdingTaxChanged(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::AssetId,
        ::polymesh_api_client::IdentityId,
        Option<::polymesh_api_client::per_things::Permill>,
      ),
      #[doc = "A CA was initiated."]
      #[doc = "(Agent DID, CA id, the CA, the CA details)"]
      #[codec(index = 4u8)]
      CAInitiated(
        polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
        pallet_corporate_actions::CAId,
        pallet_corporate_actions::CorporateAction,
        pallet_corporate_actions::CADetails,
      ),
      #[doc = "A CA was linked to a set of docs."]
      #[doc = "(Agent DID, CA Id, List of doc identifiers)"]
      #[codec(index = 5u8)]
      CALinkedToDoc(
        ::polymesh_api_client::IdentityId,
        pallet_corporate_actions::CAId,
        ::alloc::vec::Vec<polymesh_primitives::document::DocumentId>,
      ),
      #[doc = "A CA was removed."]
      #[doc = "(Agent DID, CA Id)"]
      #[codec(index = 6u8)]
      CARemoved(
        polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
        pallet_corporate_actions::CAId,
      ),
      #[doc = "A CA's record date changed."]
      #[codec(index = 7u8)]
      RecordDateChanged(
        polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
        pallet_corporate_actions::CAId,
        pallet_corporate_actions::CorporateAction,
      ),
    }
    impl CorporateActionEvent {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::MaxDetailsLengthChanged(_, _) => "CorporateAction.MaxDetailsLengthChanged",
          Self::DefaultTargetIdentitiesChanged(_, _, _) => {
            "CorporateAction.DefaultTargetIdentitiesChanged"
          }
          Self::DefaultWithholdingTaxChanged(_, _, _) => {
            "CorporateAction.DefaultWithholdingTaxChanged"
          }
          Self::DidWithholdingTaxChanged(_, _, _, _) => "CorporateAction.DidWithholdingTaxChanged",
          Self::CAInitiated(_, _, _, _) => "CorporateAction.CAInitiated",
          Self::CALinkedToDoc(_, _, _) => "CorporateAction.CALinkedToDoc",
          Self::CARemoved(_, _) => "CorporateAction.CARemoved",
          Self::RecordDateChanged(_, _, _) => "CorporateAction.RecordDateChanged",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for CorporateActionEvent {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::MaxDetailsLengthChanged(_, _) => &[
            "The maximum length of `details` in bytes was changed.",
            "(GC DID, new length)",
          ],
          Self::DefaultTargetIdentitiesChanged(_, _, _) => &[
            "The set of default `TargetIdentities` for the asset changed.",
            "(Agent DID, AssetId, New TargetIdentities)",
          ],
          Self::DefaultWithholdingTaxChanged(_, _, _) => &[
            "The default withholding tax for the asset changed.",
            "(Agent DID, AssetId, New Tax).",
          ],
          Self::DidWithholdingTaxChanged(_, _, _, _) => &[
            "The withholding tax specific to a DID for the asset changed.",
            "(Agent DID, AssetId, Taxed DID, New Tax).",
          ],
          Self::CAInitiated(_, _, _, _) => &[
            "A CA was initiated.",
            "(Agent DID, CA id, the CA, the CA details)",
          ],
          Self::CALinkedToDoc(_, _, _) => &[
            "A CA was linked to a set of docs.",
            "(Agent DID, CA Id, List of doc identifiers)",
          ],
          Self::CARemoved(_, _) => &["A CA was removed.", "(Agent DID, CA Id)"],
          Self::RecordDateChanged(_, _, _) => &["A CA's record date changed."],
          _ => &[""],
        }
      }
    }
    impl From<CorporateActionEvent> for &'static str {
      fn from(v: CorporateActionEvent) -> Self {
        v.as_static_str()
      }
    }
    impl From<&CorporateActionEvent> for &'static str {
      fn from(v: &CorporateActionEvent) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct InitiateCorporateActionArgs {
      pub asset_id: ::polymesh_api_client::AssetId,
      pub kind: pallet_corporate_actions::CAKind,
      pub decl_date: u64,
      pub record_date: Option<pallet_corporate_actions::RecordDateSpec>,
      pub details: pallet_corporate_actions::CADetails,
      pub targets: Option<pallet_corporate_actions::TargetIdentities>,
      pub default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
      pub withholding_tax: Option<
        ::alloc::vec::Vec<(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::per_things::Permill,
        )>,
      >,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct LocalCAId(pub u32);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct RecordDate {
      pub date: u64,
      pub checkpoint: pallet_corporate_actions::CACheckpoint,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RecordDateSpec {
      #[codec(index = 0u8)]
      Scheduled(u64),
      #[codec(index = 1u8)]
      ExistingSchedule(polymesh_primitives::checkpoint::ScheduleId),
      #[codec(index = 2u8)]
      Existing(polymesh_primitives::asset::CheckpointId),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct TargetIdentities {
      pub identities: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      pub treatment: pallet_corporate_actions::TargetTreatment,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TargetTreatment {
      #[codec(index = 0u8)]
      Include,
      #[codec(index = 1u8)]
      Exclude,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_election_provider_multi_phase {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ElectionProviderMultiPhaseCall {
        #[doc = "Submit a solution for the unsigned phase."]
        #[doc = ""]
        #[doc = "The dispatch origin fo this call must be __none__."]
        #[doc = ""]
        #[doc = "This submission is checked on the fly. Moreover, this unsigned solution is only"]
        #[doc = "validated when submitted to the pool from the **local** node. Effectively, this means"]
        #[doc = "that only active validators can submit this transaction when authoring a block (similar"]
        #[doc = "to an inherent)."]
        #[doc = ""]
        #[doc = "To prevent any incorrect solution (and thus wasted time/weight), this transaction will"]
        #[doc = "panic if the solution submitted by the validator is invalid in any way, effectively"]
        #[doc = "putting their authoring reward at risk."]
        #[doc = ""]
        #[doc = "No deposit or reward is associated with this submission."]
        #[codec(index = 0u8)]
        submit_unsigned {
          raw_solution: ::alloc::boxed::Box<
            pallet_election_provider_multi_phase::RawSolution<
              polymesh_runtime_common::NposSolution16,
            >,
          >,
          witness: pallet_election_provider_multi_phase::SolutionOrSnapshotSize,
        },
        #[doc = "Set a new value for `MinimumUntrustedScore`."]
        #[doc = ""]
        #[doc = "Dispatch origin must be aligned with `T::ForceOrigin`."]
        #[doc = ""]
        #[doc = "This check can be turned off by setting the value to `None`."]
        #[codec(index = 1u8)]
        set_minimum_untrusted_score {
          maybe_next_score: Option<sp_npos_elections::ElectionScore>,
        },
        #[doc = "Set a solution in the queue, to be handed out to the client of this pallet in the next"]
        #[doc = "call to `ElectionProvider::elect`."]
        #[doc = ""]
        #[doc = "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`."]
        #[doc = ""]
        #[doc = "The solution is not checked for any feasibility and is assumed to be trustworthy, as any"]
        #[doc = "feasibility check itself can in principle cause the election process to fail (due to"]
        #[doc = "memory/weight constrains)."]
        #[codec(index = 2u8)]
        set_emergency_election_result {
          supports: ::alloc::vec::Vec<(
            ::polymesh_api_client::AccountId,
            sp_npos_elections::Support<::polymesh_api_client::AccountId>,
          )>,
        },
        #[doc = "Submit a solution for the signed phase."]
        #[doc = ""]
        #[doc = "The dispatch origin fo this call must be __signed__."]
        #[doc = ""]
        #[doc = "The solution is potentially queued, based on the claimed score and processed at the end"]
        #[doc = "of the signed phase."]
        #[doc = ""]
        #[doc = "A deposit is reserved and recorded for the solution. Based on the outcome, the solution"]
        #[doc = "might be rewarded, slashed, or get all or a part of the deposit back."]
        #[codec(index = 3u8)]
        submit {
          raw_solution: ::alloc::boxed::Box<
            pallet_election_provider_multi_phase::RawSolution<
              polymesh_runtime_common::NposSolution16,
            >,
          >,
        },
        #[doc = "Trigger the governance fallback."]
        #[doc = ""]
        #[doc = "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to"]
        #[doc = "calling [`Call::set_emergency_election_result`]."]
        #[codec(index = 4u8)]
        governance_fallback {
          maybe_max_voters: Option<u32>,
          maybe_max_targets: Option<u32>,
        },
      }
      impl ElectionProviderMultiPhaseCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::submit_unsigned { .. } => "ElectionProviderMultiPhase.submit_unsigned",
            Self::set_minimum_untrusted_score { .. } => {
              "ElectionProviderMultiPhase.set_minimum_untrusted_score"
            }
            Self::set_emergency_election_result { .. } => {
              "ElectionProviderMultiPhase.set_emergency_election_result"
            }
            Self::submit { .. } => "ElectionProviderMultiPhase.submit",
            Self::governance_fallback { .. } => "ElectionProviderMultiPhase.governance_fallback",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ElectionProviderMultiPhaseCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: submit_unsigned { .. } => { & ["Submit a solution for the unsigned phase." , "" , "The dispatch origin fo this call must be __none__." , "" , "This submission is checked on the fly. Moreover, this unsigned solution is only" , "validated when submitted to the pool from the **local** node. Effectively, this means" , "that only active validators can submit this transaction when authoring a block (similar" , "to an inherent)." , "" , "To prevent any incorrect solution (and thus wasted time/weight), this transaction will" , "panic if the solution submitted by the validator is invalid in any way, effectively" , "putting their authoring reward at risk." , "" , "No deposit or reward is associated with this submission." ,] } , Self :: set_minimum_untrusted_score { .. } => { & ["Set a new value for `MinimumUntrustedScore`." , "" , "Dispatch origin must be aligned with `T::ForceOrigin`." , "" , "This check can be turned off by setting the value to `None`." ,] } , Self :: set_emergency_election_result { .. } => { & ["Set a solution in the queue, to be handed out to the client of this pallet in the next" , "call to `ElectionProvider::elect`." , "" , "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`." , "" , "The solution is not checked for any feasibility and is assumed to be trustworthy, as any" , "feasibility check itself can in principle cause the election process to fail (due to" , "memory/weight constrains)." ,] } , Self :: submit { .. } => { & ["Submit a solution for the signed phase." , "" , "The dispatch origin fo this call must be __signed__." , "" , "The solution is potentially queued, based on the claimed score and processed at the end" , "of the signed phase." , "" , "A deposit is reserved and recorded for the solution. Based on the outcome, the solution" , "might be rewarded, slashed, or get all or a part of the deposit back." ,] } , Self :: governance_fallback { .. } => { & ["Trigger the governance fallback." , "" , "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to" , "calling [`Call::set_emergency_election_result`]." ,] } , _ => & [""] , }
        }
      }
      impl From<ElectionProviderMultiPhaseCall> for &'static str {
        fn from(v: ElectionProviderMultiPhaseCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ElectionProviderMultiPhaseCall> for &'static str {
        fn from(v: &ElectionProviderMultiPhaseCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Error of the pallet that can be returned in response to dispatches."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ElectionProviderMultiPhaseError {
        #[doc = "Submission was too early."]
        #[codec(index = 0u8)]
        PreDispatchEarlySubmission,
        #[doc = "Wrong number of winners presented."]
        #[codec(index = 1u8)]
        PreDispatchWrongWinnerCount,
        #[doc = "Submission was too weak, score-wise."]
        #[codec(index = 2u8)]
        PreDispatchWeakSubmission,
        #[doc = "The queue was full, and the solution was not better than any of the existing ones."]
        #[codec(index = 3u8)]
        SignedQueueFull,
        #[doc = "The origin failed to pay the deposit."]
        #[codec(index = 4u8)]
        SignedCannotPayDeposit,
        #[doc = "Witness data to dispatchable is invalid."]
        #[codec(index = 5u8)]
        SignedInvalidWitness,
        #[doc = "The signed submission consumes too much weight"]
        #[codec(index = 6u8)]
        SignedTooMuchWeight,
        #[doc = "OCW submitted solution for wrong round"]
        #[codec(index = 7u8)]
        OcwCallWrongEra,
        #[doc = "Snapshot metadata should exist but didn't."]
        #[codec(index = 8u8)]
        MissingSnapshotMetadata,
        #[doc = "`Self::insert_submission` returned an invalid index."]
        #[codec(index = 9u8)]
        InvalidSubmissionIndex,
        #[doc = "The call is not allowed at this point."]
        #[codec(index = 10u8)]
        CallNotAllowed,
        #[doc = "The fallback failed"]
        #[codec(index = 11u8)]
        FallbackFailed,
        #[doc = "Some bound not met"]
        #[codec(index = 12u8)]
        BoundNotMet,
        #[doc = "Submitted solution has too many winners"]
        #[codec(index = 13u8)]
        TooManyWinners,
      }
      impl ElectionProviderMultiPhaseError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::PreDispatchEarlySubmission => {
              "ElectionProviderMultiPhase.PreDispatchEarlySubmission"
            }
            Self::PreDispatchWrongWinnerCount => {
              "ElectionProviderMultiPhase.PreDispatchWrongWinnerCount"
            }
            Self::PreDispatchWeakSubmission => {
              "ElectionProviderMultiPhase.PreDispatchWeakSubmission"
            }
            Self::SignedQueueFull => "ElectionProviderMultiPhase.SignedQueueFull",
            Self::SignedCannotPayDeposit => "ElectionProviderMultiPhase.SignedCannotPayDeposit",
            Self::SignedInvalidWitness => "ElectionProviderMultiPhase.SignedInvalidWitness",
            Self::SignedTooMuchWeight => "ElectionProviderMultiPhase.SignedTooMuchWeight",
            Self::OcwCallWrongEra => "ElectionProviderMultiPhase.OcwCallWrongEra",
            Self::MissingSnapshotMetadata => "ElectionProviderMultiPhase.MissingSnapshotMetadata",
            Self::InvalidSubmissionIndex => "ElectionProviderMultiPhase.InvalidSubmissionIndex",
            Self::CallNotAllowed => "ElectionProviderMultiPhase.CallNotAllowed",
            Self::FallbackFailed => "ElectionProviderMultiPhase.FallbackFailed",
            Self::BoundNotMet => "ElectionProviderMultiPhase.BoundNotMet",
            Self::TooManyWinners => "ElectionProviderMultiPhase.TooManyWinners",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ElectionProviderMultiPhaseError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::PreDispatchEarlySubmission => &["Submission was too early."],
            Self::PreDispatchWrongWinnerCount => &["Wrong number of winners presented."],
            Self::PreDispatchWeakSubmission => &["Submission was too weak, score-wise."],
            Self::SignedQueueFull => &[
              "The queue was full, and the solution was not better than any of the existing ones.",
            ],
            Self::SignedCannotPayDeposit => &["The origin failed to pay the deposit."],
            Self::SignedInvalidWitness => &["Witness data to dispatchable is invalid."],
            Self::SignedTooMuchWeight => &["The signed submission consumes too much weight"],
            Self::OcwCallWrongEra => &["OCW submitted solution for wrong round"],
            Self::MissingSnapshotMetadata => &["Snapshot metadata should exist but didn't."],
            Self::InvalidSubmissionIndex => {
              &["`Self::insert_submission` returned an invalid index."]
            }
            Self::CallNotAllowed => &["The call is not allowed at this point."],
            Self::FallbackFailed => &["The fallback failed"],
            Self::BoundNotMet => &["Some bound not met"],
            Self::TooManyWinners => &["Submitted solution has too many winners"],
            _ => &[""],
          }
        }
      }
      impl From<ElectionProviderMultiPhaseError> for &'static str {
        fn from(v: ElectionProviderMultiPhaseError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ElectionProviderMultiPhaseError> for &'static str {
        fn from(v: &ElectionProviderMultiPhaseError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ElectionProviderMultiPhaseEvent {
        #[doc = "A solution was stored with the given compute."]
        #[doc = ""]
        #[doc = "The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`,"]
        #[doc = "the stored solution was submited in the signed phase by a miner with the `AccountId`."]
        #[doc = "Otherwise, the solution was stored either during the unsigned phase or by"]
        #[doc = "`T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make"]
        #[doc = "room for this one."]
        #[codec(index = 0u8)]
        SolutionStored {
          compute: pallet_election_provider_multi_phase::ElectionCompute,
          origin: Option<::polymesh_api_client::AccountId>,
          prev_ejected: bool,
        },
        #[doc = "The election has been finalized, with the given computation and score."]
        #[codec(index = 1u8)]
        ElectionFinalized {
          compute: pallet_election_provider_multi_phase::ElectionCompute,
          score: sp_npos_elections::ElectionScore,
        },
        #[doc = "An election failed."]
        #[doc = ""]
        #[doc = "Not much can be said about which computes failed in the process."]
        #[codec(index = 2u8)]
        ElectionFailed,
        #[doc = "An account has been rewarded for their signed submission being finalized."]
        #[codec(index = 3u8)]
        Rewarded {
          account: ::polymesh_api_client::AccountId,
          value: u128,
        },
        #[doc = "An account has been slashed for submitting an invalid signed submission."]
        #[codec(index = 4u8)]
        Slashed {
          account: ::polymesh_api_client::AccountId,
          value: u128,
        },
        #[doc = "There was a phase transition in a given round."]
        #[codec(index = 5u8)]
        PhaseTransitioned {
          from: pallet_election_provider_multi_phase::Phase<u32>,
          to: pallet_election_provider_multi_phase::Phase<u32>,
          round: u32,
        },
      }
      impl ElectionProviderMultiPhaseEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::SolutionStored { .. } => "ElectionProviderMultiPhase.SolutionStored",
            Self::ElectionFinalized { .. } => "ElectionProviderMultiPhase.ElectionFinalized",
            Self::ElectionFailed => "ElectionProviderMultiPhase.ElectionFailed",
            Self::Rewarded { .. } => "ElectionProviderMultiPhase.Rewarded",
            Self::Slashed { .. } => "ElectionProviderMultiPhase.Slashed",
            Self::PhaseTransitioned { .. } => "ElectionProviderMultiPhase.PhaseTransitioned",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ElectionProviderMultiPhaseEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: SolutionStored { .. } => { & ["A solution was stored with the given compute." , "" , "The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`," , "the stored solution was submited in the signed phase by a miner with the `AccountId`." , "Otherwise, the solution was stored either during the unsigned phase or by" , "`T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make" , "room for this one." ,] } , Self :: ElectionFinalized { .. } => { & ["The election has been finalized, with the given computation and score." ,] } , Self :: ElectionFailed => { & ["An election failed." , "" , "Not much can be said about which computes failed in the process." ,] } , Self :: Rewarded { .. } => { & ["An account has been rewarded for their signed submission being finalized." ,] } , Self :: Slashed { .. } => { & ["An account has been slashed for submitting an invalid signed submission." ,] } , Self :: PhaseTransitioned { .. } => { & ["There was a phase transition in a given round." ,] } , _ => & [""] , }
        }
      }
      impl From<ElectionProviderMultiPhaseEvent> for &'static str {
        fn from(v: ElectionProviderMultiPhaseEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ElectionProviderMultiPhaseEvent> for &'static str {
        fn from(v: &ElectionProviderMultiPhaseEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    pub mod signed {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SignedSubmission<AccountId, Balance, Solution> {
        pub who: AccountId,
        pub deposit: Balance,
        pub raw_solution: pallet_election_provider_multi_phase::RawSolution<Solution>,
        pub call_fee: Balance,
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ElectionCompute {
      #[codec(index = 0u8)]
      OnChain,
      #[codec(index = 1u8)]
      Signed,
      #[codec(index = 2u8)]
      Unsigned,
      #[codec(index = 3u8)]
      Fallback,
      #[codec(index = 4u8)]
      Emergency,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Phase<Bn> {
      #[codec(index = 0u8)]
      Off,
      #[codec(index = 1u8)]
      Signed,
      #[codec(index = 2u8)]
      Unsigned((bool, Bn)),
      #[codec(index = 3u8)]
      Emergency,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct RawSolution<S> {
      pub solution: S,
      pub score: sp_npos_elections::ElectionScore,
      pub round: u32,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ReadySolution {
      pub supports: ::alloc::vec::Vec<(
        ::polymesh_api_client::AccountId,
        sp_npos_elections::Support<::polymesh_api_client::AccountId>,
      )>,
      pub score: sp_npos_elections::ElectionScore,
      pub compute: pallet_election_provider_multi_phase::ElectionCompute,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct RoundSnapshot {
      pub voters: ::alloc::vec::Vec<(
        ::polymesh_api_client::AccountId,
        u64,
        ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      )>,
      pub targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct SolutionOrSnapshotSize {
      #[codec(compact)]
      pub voters: u32,
      #[codec(compact)]
      pub targets: u32,
    }
  }
  pub mod pallet_external_agents {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ExternalAgentsCall {
      #[doc = "Creates a custom agent group (AG) for the given `asset_id`."]
      #[doc = ""]
      #[doc = "The AG will have the permissions as given by `perms`."]
      #[doc = "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`,"]
      #[doc = "which you can use as `AgentGroup::Custom(id)` when adding agents for `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] to add the custom group for."]
      #[doc = "- `perms` that the new AG will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 0u8)]
      create_group {
        asset_id: ::polymesh_api_client::AssetId,
        perms: polymesh_primitives::secondary_key::ExtrinsicPermissions,
      },
      #[doc = "Updates the permissions of the custom AG identified by `id`, for the given `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] the custom AG belongs to."]
      #[doc = "- `id` for the custom AG within `asset_id`."]
      #[doc = "- `perms` to update the custom AG to."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 1u8)]
      set_group_permissions {
        asset_id: ::polymesh_api_client::AssetId,
        id: polymesh_primitives::agent::AGId,
        perms: polymesh_primitives::secondary_key::ExtrinsicPermissions,
      },
      #[doc = "Remove the given `agent` from `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] that has the `agent` to remove."]
      #[doc = "- `agent` of `asset_id` to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` is the last full one."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 2u8)]
      remove_agent {
        asset_id: ::polymesh_api_client::AssetId,
        agent: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Abdicate agentship for `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] of which the caller is an agent."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAnAgent` if the caller is not an agent of `asset_id`."]
      #[doc = "- `RemovingLastFullAgent` if the caller is the last full agent."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 3u8)]
      abdicate {
        asset_id: ::polymesh_api_client::AssetId,
      },
      #[doc = "Change the agent group that `agent` belongs to in `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] that has the `agent`."]
      #[doc = "- `agent` of `asset_id` to change the group for."]
      #[doc = "- `group` that `agent` will belong to in `asset_id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 4u8)]
      change_group {
        asset_id: ::polymesh_api_client::AssetId,
        agent: ::polymesh_api_client::IdentityId,
        group: polymesh_primitives::agent::AgentGroup,
      },
      #[doc = "Accept an authorization by an agent \"Alice\" who issued `auth_id`"]
      #[doc = "to also become an agent of the asset Alice specified."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` identifying the authorization to accept."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` is for an auth that has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not for a `BecomeAgent` auth type."]
      #[doc = "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth."]
      #[doc = "- `NoSuchAG` if the group referred to a custom that does not exist."]
      #[doc = "- `AlreadyAnAgent` if the caller is already an agent of the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[codec(index = 5u8)]
      accept_become_agent { auth_id: u64 },
      #[doc = "Utility extrinsic to batch `create_group` and  `add_auth`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 6u8)]
      create_group_and_add_auth {
        asset_id: ::polymesh_api_client::AssetId,
        perms: polymesh_primitives::secondary_key::ExtrinsicPermissions,
        target: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
      },
      #[doc = "Utility extrinsic to batch `create_group` and  `change_group` for custom groups only."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 7u8)]
      create_and_change_custom_group {
        asset_id: ::polymesh_api_client::AssetId,
        perms: polymesh_primitives::secondary_key::ExtrinsicPermissions,
        agent: ::polymesh_api_client::IdentityId,
      },
    }
    impl ExternalAgentsCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_group { .. } => "ExternalAgents.create_group",
          Self::set_group_permissions { .. } => "ExternalAgents.set_group_permissions",
          Self::remove_agent { .. } => "ExternalAgents.remove_agent",
          Self::abdicate { .. } => "ExternalAgents.abdicate",
          Self::change_group { .. } => "ExternalAgents.change_group",
          Self::accept_become_agent { .. } => "ExternalAgents.accept_become_agent",
          Self::create_group_and_add_auth { .. } => "ExternalAgents.create_group_and_add_auth",
          Self::create_and_change_custom_group { .. } => {
            "ExternalAgents.create_and_change_custom_group"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ExternalAgentsCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: create_group { .. } => { & ["Creates a custom agent group (AG) for the given `asset_id`." , "" , "The AG will have the permissions as given by `perms`." , "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`," , "which you can use as `AgentGroup::Custom(id)` when adding agents for `asset_id`." , "" , "# Arguments" , "- `assetID` the [`AssetId] to add the custom group for." , "- `perms` that the new AG will have." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this." , "- `TooLong` if `perms` had some string or list length that was too long." , "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , Self :: set_group_permissions { .. } => { & ["Updates the permissions of the custom AG identified by `id`, for the given `asset_id`." , "" , "# Arguments" , "- `assetID` the [`AssetId] the custom AG belongs to." , "- `id` for the custom AG within `asset_id`." , "- `perms` to update the custom AG to." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this." , "- `TooLong` if `perms` had some string or list length that was too long." , "- `NoSuchAG` if `id` does not identify a custom AG." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , Self :: remove_agent { .. } => { & ["Remove the given `agent` from `asset_id`." , "" , "# Arguments" , "- `assetID` the [`AssetId] that has the `agent` to remove." , "- `agent` of `asset_id` to remove." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this." , "- `NotAnAgent` if `agent` is not an agent of `asset_id`." , "- `RemovingLastFullAgent` if `agent` is the last full one." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , Self :: abdicate { .. } => { & ["Abdicate agentship for `asset_id`." , "" , "# Arguments" , "- `assetID` the [`AssetId] of which the caller is an agent." , "" , "# Errors" , "- `NotAnAgent` if the caller is not an agent of `asset_id`." , "- `RemovingLastFullAgent` if the caller is the last full agent." , "" , "# Permissions" , "* Asset" ,] } , Self :: change_group { .. } => { & ["Change the agent group that `agent` belongs to in `asset_id`." , "" , "# Arguments" , "- `assetID` the [`AssetId] that has the `agent`." , "- `agent` of `asset_id` to change the group for." , "- `group` that `agent` will belong to in `asset_id`." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this." , "- `NoSuchAG` if `id` does not identify a custom AG." , "- `NotAnAgent` if `agent` is not an agent of `asset_id`." , "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , Self :: accept_become_agent { .. } => { & ["Accept an authorization by an agent \"Alice\" who issued `auth_id`" , "to also become an agent of the asset Alice specified." , "" , "# Arguments" , "- `auth_id` identifying the authorization to accept." , "" , "# Errors" , "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller." , "- `AuthorizationError::Expired` if `auth_id` is for an auth that has expired." , "- `AuthorizationError::BadType` if `auth_id` was not for a `BecomeAgent` auth type." , "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth." , "- `NoSuchAG` if the group referred to a custom that does not exist." , "- `AlreadyAnAgent` if the caller is already an agent of the asset." , "" , "# Permissions" , "* Agent" ,] } , Self :: create_group_and_add_auth { .. } => { & ["Utility extrinsic to batch `create_group` and  `add_auth`." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , Self :: create_and_change_custom_group { .. } => { & ["Utility extrinsic to batch `create_group` and  `change_group` for custom groups only." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , _ => & [""] , }
      }
    }
    impl From<ExternalAgentsCall> for &'static str {
      fn from(v: ExternalAgentsCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ExternalAgentsCall> for &'static str {
      fn from(v: &ExternalAgentsCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ExternalAgentsError {
      #[doc = "An AG with the given `AGId` did not exist for the `AssetId`."]
      #[codec(index = 0u8)]
      NoSuchAG,
      #[doc = "The agent is not authorized to call the current extrinsic."]
      #[codec(index = 1u8)]
      UnauthorizedAgent,
      #[doc = "The provided `agent` is already an agent for the `AssetId`."]
      #[codec(index = 2u8)]
      AlreadyAnAgent,
      #[doc = "The provided `agent` is not an agent for the `AssetId`."]
      #[codec(index = 3u8)]
      NotAnAgent,
      #[doc = "This agent is the last full one, and it's being removed,"]
      #[doc = "making the asset orphaned."]
      #[codec(index = 4u8)]
      RemovingLastFullAgent,
      #[doc = "The caller's secondary key does not have the required asset permission."]
      #[codec(index = 5u8)]
      SecondaryKeyNotAuthorizedForAsset,
    }
    impl ExternalAgentsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::NoSuchAG => "ExternalAgents.NoSuchAG",
          Self::UnauthorizedAgent => "ExternalAgents.UnauthorizedAgent",
          Self::AlreadyAnAgent => "ExternalAgents.AlreadyAnAgent",
          Self::NotAnAgent => "ExternalAgents.NotAnAgent",
          Self::RemovingLastFullAgent => "ExternalAgents.RemovingLastFullAgent",
          Self::SecondaryKeyNotAuthorizedForAsset => {
            "ExternalAgents.SecondaryKeyNotAuthorizedForAsset"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ExternalAgentsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::NoSuchAG => &["An AG with the given `AGId` did not exist for the `AssetId`."],
          Self::UnauthorizedAgent => {
            &["The agent is not authorized to call the current extrinsic."]
          }
          Self::AlreadyAnAgent => &["The provided `agent` is already an agent for the `AssetId`."],
          Self::NotAnAgent => &["The provided `agent` is not an agent for the `AssetId`."],
          Self::RemovingLastFullAgent => &[
            "This agent is the last full one, and it's being removed,",
            "making the asset orphaned.",
          ],
          Self::SecondaryKeyNotAuthorizedForAsset => {
            &["The caller's secondary key does not have the required asset permission."]
          }
          _ => &[""],
        }
      }
    }
    impl From<ExternalAgentsError> for &'static str {
      fn from(v: ExternalAgentsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ExternalAgentsError> for &'static str {
      fn from(v: &ExternalAgentsError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_grandpa {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum GrandpaCall {
        #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
        #[doc = "equivocation proof and validate the given key ownership proof"]
        #[doc = "against the extracted offender. If both are valid, the offence"]
        #[doc = "will be reported."]
        #[codec(index = 0u8)]
        report_equivocation {
          equivocation_proof: ::alloc::boxed::Box<
            sp_consensus_grandpa::EquivocationProof<primitive_types::H256, u32>,
          >,
          key_owner_proof: sp_session::MembershipProof,
        },
        #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
        #[doc = "equivocation proof and validate the given key ownership proof"]
        #[doc = "against the extracted offender. If both are valid, the offence"]
        #[doc = "will be reported."]
        #[doc = ""]
        #[doc = "This extrinsic must be called unsigned and it is expected that only"]
        #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
        #[doc = "if the block author is defined it will be defined as the equivocation"]
        #[doc = "reporter."]
        #[codec(index = 1u8)]
        report_equivocation_unsigned {
          equivocation_proof: ::alloc::boxed::Box<
            sp_consensus_grandpa::EquivocationProof<primitive_types::H256, u32>,
          >,
          key_owner_proof: sp_session::MembershipProof,
        },
        #[doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."]
        #[doc = ""]
        #[doc = "This will trigger a forced authority set change at the beginning of the next session, to"]
        #[doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"]
        #[doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."]
        #[doc = "The block production rate (which may be slowed down because of finality lagging) should"]
        #[doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"]
        #[doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"]
        #[doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"]
        #[doc = "block of all validators of the new authority set."]
        #[doc = ""]
        #[doc = "Only callable by root."]
        #[codec(index = 2u8)]
        note_stalled {
          delay: u32,
          best_finalized_block_number: u32,
        },
      }
      impl GrandpaCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::report_equivocation { .. } => "Grandpa.report_equivocation",
            Self::report_equivocation_unsigned { .. } => "Grandpa.report_equivocation_unsigned",
            Self::note_stalled { .. } => "Grandpa.note_stalled",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for GrandpaCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: report_equivocation { .. } => { & ["Report voter equivocation/misbehavior. This method will verify the" , "equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence" , "will be reported." ,] } , Self :: report_equivocation_unsigned { .. } => { & ["Report voter equivocation/misbehavior. This method will verify the" , "equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence" , "will be reported." , "" , "This extrinsic must be called unsigned and it is expected that only" , "block authors will call it (validated in `ValidateUnsigned`), as such" , "if the block author is defined it will be defined as the equivocation" , "reporter." ,] } , Self :: note_stalled { .. } => { & ["Note that the current authority set of the GRANDPA finality gadget has stalled." , "" , "This will trigger a forced authority set change at the beginning of the next session, to" , "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume" , "that the block signalling the forced change will not be re-orged e.g. 1000 blocks." , "The block production rate (which may be slowed down because of finality lagging) should" , "be taken into account when choosing the `delay`. The GRANDPA voters based on the new" , "authority will start voting on top of `best_finalized_block_number` for new finalized" , "blocks. `best_finalized_block_number` should be the highest of the latest finalized" , "block of all validators of the new authority set." , "" , "Only callable by root." ,] } , _ => & [""] , }
        }
      }
      impl From<GrandpaCall> for &'static str {
        fn from(v: GrandpaCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&GrandpaCall> for &'static str {
        fn from(v: &GrandpaCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum GrandpaError {
        #[doc = "Attempt to signal GRANDPA pause when the authority set isn't live"]
        #[doc = "(either paused or already pending pause)."]
        #[codec(index = 0u8)]
        PauseFailed,
        #[doc = "Attempt to signal GRANDPA resume when the authority set isn't paused"]
        #[doc = "(either live or already pending resume)."]
        #[codec(index = 1u8)]
        ResumeFailed,
        #[doc = "Attempt to signal GRANDPA change with one already pending."]
        #[codec(index = 2u8)]
        ChangePending,
        #[doc = "Cannot signal forced change so soon after last."]
        #[codec(index = 3u8)]
        TooSoon,
        #[doc = "A key ownership proof provided as part of an equivocation report is invalid."]
        #[codec(index = 4u8)]
        InvalidKeyOwnershipProof,
        #[doc = "An equivocation proof provided as part of an equivocation report is invalid."]
        #[codec(index = 5u8)]
        InvalidEquivocationProof,
        #[doc = "A given equivocation report is valid but already previously reported."]
        #[codec(index = 6u8)]
        DuplicateOffenceReport,
      }
      impl GrandpaError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::PauseFailed => "Grandpa.PauseFailed",
            Self::ResumeFailed => "Grandpa.ResumeFailed",
            Self::ChangePending => "Grandpa.ChangePending",
            Self::TooSoon => "Grandpa.TooSoon",
            Self::InvalidKeyOwnershipProof => "Grandpa.InvalidKeyOwnershipProof",
            Self::InvalidEquivocationProof => "Grandpa.InvalidEquivocationProof",
            Self::DuplicateOffenceReport => "Grandpa.DuplicateOffenceReport",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for GrandpaError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::PauseFailed => &[
              "Attempt to signal GRANDPA pause when the authority set isn't live",
              "(either paused or already pending pause).",
            ],
            Self::ResumeFailed => &[
              "Attempt to signal GRANDPA resume when the authority set isn't paused",
              "(either live or already pending resume).",
            ],
            Self::ChangePending => &["Attempt to signal GRANDPA change with one already pending."],
            Self::TooSoon => &["Cannot signal forced change so soon after last."],
            Self::InvalidKeyOwnershipProof => {
              &["A key ownership proof provided as part of an equivocation report is invalid."]
            }
            Self::InvalidEquivocationProof => {
              &["An equivocation proof provided as part of an equivocation report is invalid."]
            }
            Self::DuplicateOffenceReport => {
              &["A given equivocation report is valid but already previously reported."]
            }
            _ => &[""],
          }
        }
      }
      impl From<GrandpaError> for &'static str {
        fn from(v: GrandpaError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&GrandpaError> for &'static str {
        fn from(v: &GrandpaError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum GrandpaEvent {
        #[doc = "New authority set has been applied."]
        #[codec(index = 0u8)]
        NewAuthorities {
          authority_set: ::alloc::vec::Vec<(sp_consensus_grandpa::app::Public, u64)>,
        },
        #[doc = "Current authority set has been paused."]
        #[codec(index = 1u8)]
        Paused,
        #[doc = "Current authority set has been resumed."]
        #[codec(index = 2u8)]
        Resumed,
      }
      impl GrandpaEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::NewAuthorities { .. } => "Grandpa.NewAuthorities",
            Self::Paused => "Grandpa.Paused",
            Self::Resumed => "Grandpa.Resumed",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for GrandpaEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::NewAuthorities { .. } => &["New authority set has been applied."],
            Self::Paused => &["Current authority set has been paused."],
            Self::Resumed => &["Current authority set has been resumed."],
            _ => &[""],
          }
        }
      }
      impl From<GrandpaEvent> for &'static str {
        fn from(v: GrandpaEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&GrandpaEvent> for &'static str {
        fn from(v: &GrandpaEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct StoredPendingChange<N> {
      pub scheduled_at: N,
      pub delay: N,
      pub next_authorities: ::alloc::vec::Vec<(sp_consensus_grandpa::app::Public, u64)>,
      pub forced: Option<N>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StoredState<N> {
      #[codec(index = 0u8)]
      Live,
      #[codec(index = 1u8)]
      PendingPause { scheduled_at: N, delay: N },
      #[codec(index = 2u8)]
      Paused,
      #[codec(index = 3u8)]
      PendingResume { scheduled_at: N, delay: N },
    }
  }
  pub mod pallet_group {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum UpgradeCommitteeMembershipCall {
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[codec(index = 0u8)]
      set_active_members_limit { limit: u32 },
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[codec(index = 1u8)]
      disable_member {
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      },
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[codec(index = 2u8)]
      add_member {
        who: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[codec(index = 3u8)]
      remove_member {
        who: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[codec(index = 4u8)]
      swap_member {
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[codec(index = 5u8)]
      reset_members {
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      },
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[codec(index = 6u8)]
      abdicate_membership,
    }
    impl UpgradeCommitteeMembershipCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_active_members_limit { .. } => {
            "UpgradeCommitteeMembership.set_active_members_limit"
          }
          Self::disable_member { .. } => "UpgradeCommitteeMembership.disable_member",
          Self::add_member { .. } => "UpgradeCommitteeMembership.add_member",
          Self::remove_member { .. } => "UpgradeCommitteeMembership.remove_member",
          Self::swap_member { .. } => "UpgradeCommitteeMembership.swap_member",
          Self::reset_members { .. } => "UpgradeCommitteeMembership.reset_members",
          Self::abdicate_membership => "UpgradeCommitteeMembership.abdicate_membership",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeMembershipCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_active_members_limit { .. } => { & ["Change this group's limit for how many concurrent active members they may be." , "" , "# Arguments" , "* `limit` - the number of active members there may be concurrently." ,] } , Self :: disable_member { .. } => { & ["Disables a member at specific moment." , "" , "Please note that if member is already revoked (a \"valid member\"), its revocation" , "time-stamp will be updated." , "" , "Any disabled member should NOT allow to act like an active member of the group. For" , "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any" , "generated claim issued before `at` would be considered as a valid one." , "" , "If you want to invalidate any generated claim, you should use `Self::remove_member`." , "" , "# Arguments" , "* `at` - Revocation time-stamp." , "* `who` - Target member of the group." , "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the" , "generated claims will be \"invalid\" as `who` is not considered a member of the group." ,] } , Self :: add_member { .. } => { & ["Adds a member `who` to the group. May only be called from `AddOrigin` or root." , "" , "# Arguments" , "* `origin` - Origin representing `AddOrigin` or root" , "* `who` - IdentityId to be added to the group." ,] } , Self :: remove_member { .. } => { & ["Removes a member `who` from the set. May only be called from `RemoveOrigin` or root." , "" , "Any claim previously generated by this member is not valid as a group claim. For" , "instance, if a CDD member group generated a claim for a target identity and then it is" , "removed, that claim will be invalid.  In case you want to keep the validity of generated" , "claims, you have to use `Self::disable_member` function" , "" , "# Arguments" , "* `origin` - Origin representing `RemoveOrigin` or root" , "* `who` - IdentityId to be removed from the group." ,] } , Self :: swap_member { .. } => { & ["Swaps out one member `remove` for another member `add`." , "" , "May only be called from `SwapOrigin` or root." , "" , "# Arguments" , "* `origin` - Origin representing `SwapOrigin` or root" , "* `remove` - IdentityId to be removed from the group." , "* `add` - IdentityId to be added in place of `remove`." ,] } , Self :: reset_members { .. } => { & ["Changes the membership to a new set, disregarding the existing membership." , "May only be called from `ResetOrigin` or root." , "" , "# Arguments" , "* `origin` - Origin representing `ResetOrigin` or root" , "* `members` - New set of identities" ,] } , Self :: abdicate_membership => { & ["Allows the calling member to *unilaterally quit* without this being subject to a GC" , "vote." , "" , "# Arguments" , "* `origin` - Member of committee who wants to quit." , "" , "# Error" , "" , "* Only primary key can abdicate." , "* Last member of a group cannot abdicate." ,] } , _ => & [""] , }
      }
    }
    impl From<UpgradeCommitteeMembershipCall> for &'static str {
      fn from(v: UpgradeCommitteeMembershipCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&UpgradeCommitteeMembershipCall> for &'static str {
      fn from(v: &UpgradeCommitteeMembershipCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum UpgradeCommitteeMembershipError {
      #[doc = "Only primary key of the identity is allowed."]
      #[codec(index = 0u8)]
      OnlyPrimaryKeyAllowed,
      #[doc = "Group member was added already."]
      #[codec(index = 1u8)]
      DuplicateMember,
      #[doc = "Can't remove a member that doesn't exist."]
      #[codec(index = 2u8)]
      NoSuchMember,
      #[doc = "Last member of the committee can not quit."]
      #[codec(index = 3u8)]
      LastMemberCannotQuit,
      #[doc = "The limit for the number of concurrent active members for this group has been exceeded."]
      #[codec(index = 4u8)]
      ActiveMembersLimitExceeded,
      #[doc = "Active member limit was greater than maximum committee members limit."]
      #[codec(index = 5u8)]
      ActiveMembersLimitOverflow,
    }
    impl UpgradeCommitteeMembershipError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::OnlyPrimaryKeyAllowed => "UpgradeCommitteeMembership.OnlyPrimaryKeyAllowed",
          Self::DuplicateMember => "UpgradeCommitteeMembership.DuplicateMember",
          Self::NoSuchMember => "UpgradeCommitteeMembership.NoSuchMember",
          Self::LastMemberCannotQuit => "UpgradeCommitteeMembership.LastMemberCannotQuit",
          Self::ActiveMembersLimitExceeded => {
            "UpgradeCommitteeMembership.ActiveMembersLimitExceeded"
          }
          Self::ActiveMembersLimitOverflow => {
            "UpgradeCommitteeMembership.ActiveMembersLimitOverflow"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeMembershipError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: OnlyPrimaryKeyAllowed => { & ["Only primary key of the identity is allowed." ,] } , Self :: DuplicateMember => { & ["Group member was added already." ,] } , Self :: NoSuchMember => { & ["Can't remove a member that doesn't exist." ,] } , Self :: LastMemberCannotQuit => { & ["Last member of the committee can not quit." ,] } , Self :: ActiveMembersLimitExceeded => { & ["The limit for the number of concurrent active members for this group has been exceeded." ,] } , Self :: ActiveMembersLimitOverflow => { & ["Active member limit was greater than maximum committee members limit." ,] } , _ => & [""] , }
      }
    }
    impl From<UpgradeCommitteeMembershipError> for &'static str {
      fn from(v: UpgradeCommitteeMembershipError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&UpgradeCommitteeMembershipError> for &'static str {
      fn from(v: &UpgradeCommitteeMembershipError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance1();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance2();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance3();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance4();
  }
  pub mod pallet_identity {
    use super::*;
    pub mod types {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Claim1stKey {
        pub target: ::polymesh_api_client::IdentityId,
        pub claim_type: polymesh_primitives::identity_claim::ClaimType,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Claim2ndKey {
        pub issuer: ::polymesh_api_client::IdentityId,
        pub scope: Option<polymesh_primitives::identity_claim::Scope>,
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum IdentityCall {
      #[doc = "Register `target_account` with a new Identity."]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[codec(index = 0u8)]
      cdd_register_did {
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
      },
      #[doc = "Invalidates any claim generated by `cdd` from `disable_from` timestamps."]
      #[doc = ""]
      #[doc = "You can also define an expiration time,"]
      #[doc = "which will invalidate all claims generated by that `cdd` and remove it as CDD member group."]
      #[codec(index = 1u8)]
      invalidate_cdd_claims {
        cdd: ::polymesh_api_client::IdentityId,
        disable_from: u64,
        expiry: Option<u64>,
      },
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key"]
      #[doc = "instead of leaving it as a secondary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[codec(index = 2u8)]
      accept_primary_key {
        rotation_auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      },
      #[doc = "Set if CDD authorization is required for updating primary key of an identity."]
      #[doc = "Callable via root (governance)"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_required` CDD Authorization required or not"]
      #[codec(index = 3u8)]
      change_cdd_requirement_for_mk_rotation { auth_required: bool },
      #[doc = "Join an identity as a secondary key."]
      #[codec(index = 4u8)]
      join_identity_as_key { auth_id: u64 },
      #[doc = "Leave the secondary key's identity."]
      #[codec(index = 5u8)]
      leave_identity_as_key,
      #[doc = "Adds a new claim record or edits an existing one."]
      #[doc = ""]
      #[doc = "Only called by did_issuer's secondary key."]
      #[codec(index = 6u8)]
      add_claim {
        target: ::polymesh_api_client::IdentityId,
        claim: polymesh_primitives::identity_claim::Claim,
        expiry: Option<u64>,
      },
      #[doc = "Marks the specified claim as revoked."]
      #[codec(index = 7u8)]
      revoke_claim {
        target: ::polymesh_api_client::IdentityId,
        claim: polymesh_primitives::identity_claim::Claim,
      },
      #[doc = "It disables all secondary keys at `did` identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[codec(index = 8u8)]
      freeze_secondary_keys,
      #[doc = "Re-enables all secondary keys of the caller's identity."]
      #[codec(index = 9u8)]
      unfreeze_secondary_keys,
      #[doc = "Adds an authorization."]
      #[codec(index = 10u8)]
      add_authorization {
        target: polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        data:
          polymesh_primitives::authorization::AuthorizationData<::polymesh_api_client::AccountId>,
        expiry: Option<u64>,
      },
      #[doc = "Removes an authorization."]
      #[doc = "_auth_issuer_pays determines whether the issuer of the authorisation pays the transaction fee"]
      #[codec(index = 11u8)]
      remove_authorization {
        target: polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        auth_id: u64,
        _auth_issuer_pays: bool,
      },
      #[doc = "Assuming this is executed by the GC voting majority, adds a new cdd claim record."]
      #[codec(index = 12u8)]
      gc_add_cdd_claim {
        target: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Assuming this is executed by the GC voting majority, removes an existing cdd claim record."]
      #[codec(index = 13u8)]
      gc_revoke_cdd_claim {
        target: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`,"]
      #[doc = "`claim_type`, and `scope`."]
      #[doc = ""]
      #[doc = "Please note that `origin` must be the issuer of the target claim."]
      #[codec(index = 14u8)]
      revoke_claim_by_index {
        target: ::polymesh_api_client::IdentityId,
        claim_type: polymesh_primitives::identity_claim::ClaimType,
        scope: Option<polymesh_primitives::identity_claim::Scope>,
      },
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change, (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from accept_primary_key in that it will leave the old primary key as a secondary"]
      #[doc = "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization"]
      #[doc = "instead of unlinking the old primary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[codec(index = 15u8)]
      rotate_primary_key_to_secondary {
        auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      },
      #[doc = "Adds secondary keys to target identity `id`."]
      #[doc = ""]
      #[doc = "Keys are directly added to identity because each of them has an authorization."]
      #[doc = ""]
      #[doc = "# Arguments:"]
      #[doc = "    - `origin` which must be the primary key of the identity `id`."]
      #[doc = "    - `id` to which new secondary keys will be added."]
      #[doc = "    - `additional_keys` which includes secondary keys,"]
      #[doc = "       coupled with authorization data, to add to target identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "    - Can only called by primary key owner."]
      #[doc = "    - Keys should be able to linked to any identity."]
      #[codec(index = 16u8)]
      add_secondary_keys_with_authorization {
        additional_keys: ::alloc::vec::Vec<
          polymesh_primitives::identity::SecondaryKeyWithAuth<::polymesh_api_client::AccountId>,
        >,
        expires_at: u64,
      },
      #[doc = "Sets permissions for an specific `target_key` key."]
      #[doc = ""]
      #[doc = "Only the primary key of an identity is able to set secondary key permissions."]
      #[codec(index = 17u8)]
      set_secondary_key_permissions {
        key: ::polymesh_api_client::AccountId,
        perms: polymesh_primitives::secondary_key::Permissions,
      },
      #[doc = "Removes specified secondary keys of a DID if present."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[doc = "The extrinsic can only called by primary key owner."]
      #[codec(index = 18u8)]
      remove_secondary_keys {
        keys_to_remove: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      },
      #[doc = "Register custom claim type."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists."]
      #[doc = "* `CounterOverflow` CustomClaimTypeId has overflowed."]
      #[doc = "* `TooLong` The type being registered is too lang."]
      #[codec(index = 19u8)]
      register_custom_claim_type { ty: ::alloc::vec::Vec<u8> },
      #[doc = "Register `target_account` with a new Identity and issue a CDD claim with a blank CddId"]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[codec(index = 20u8)]
      cdd_register_did_with_cdd {
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
        expiry: Option<u64>,
      },
      #[doc = "Create a child identity and make the `secondary_key` it's primary key."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `secondary_key` the secondary key that will become the primary key of the new identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity."]
      #[doc = "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[codec(index = 21u8)]
      create_child_identity {
        secondary_key: ::polymesh_api_client::AccountId,
      },
      #[doc = "Create a child identities."]
      #[doc = ""]
      #[doc = "The new primary key for each child identity will need to sign (off-chain)"]
      #[doc = "an authorization."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_keys` the keys that will become primary keys of their own child identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `AlreadyLinked` one of the keys is already linked to an identity."]
      #[doc = "- `DuplicateKey` one of the keys is included multiple times."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[codec(index = 22u8)]
      create_child_identities {
        child_keys: ::alloc::vec::Vec<
          polymesh_primitives::identity::CreateChildIdentityWithAuth<
            ::polymesh_api_client::AccountId,
          >,
        >,
        expires_at: u64,
      },
      #[doc = "Unlink a child identity from it's parent identity."]
      #[doc = ""]
      #[doc = "Only the primary key of the parent or child identities can unlink the identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_did` the child identity to unlink from its parent identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities."]
      #[doc = "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity."]
      #[doc = "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity."]
      #[codec(index = 23u8)]
      unlink_child_identity {
        child_did: ::polymesh_api_client::IdentityId,
      },
    }
    impl IdentityCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::cdd_register_did { .. } => "Identity.cdd_register_did",
          Self::invalidate_cdd_claims { .. } => "Identity.invalidate_cdd_claims",
          Self::accept_primary_key { .. } => "Identity.accept_primary_key",
          Self::change_cdd_requirement_for_mk_rotation { .. } => {
            "Identity.change_cdd_requirement_for_mk_rotation"
          }
          Self::join_identity_as_key { .. } => "Identity.join_identity_as_key",
          Self::leave_identity_as_key => "Identity.leave_identity_as_key",
          Self::add_claim { .. } => "Identity.add_claim",
          Self::revoke_claim { .. } => "Identity.revoke_claim",
          Self::freeze_secondary_keys => "Identity.freeze_secondary_keys",
          Self::unfreeze_secondary_keys => "Identity.unfreeze_secondary_keys",
          Self::add_authorization { .. } => "Identity.add_authorization",
          Self::remove_authorization { .. } => "Identity.remove_authorization",
          Self::gc_add_cdd_claim { .. } => "Identity.gc_add_cdd_claim",
          Self::gc_revoke_cdd_claim { .. } => "Identity.gc_revoke_cdd_claim",
          Self::revoke_claim_by_index { .. } => "Identity.revoke_claim_by_index",
          Self::rotate_primary_key_to_secondary { .. } => {
            "Identity.rotate_primary_key_to_secondary"
          }
          Self::add_secondary_keys_with_authorization { .. } => {
            "Identity.add_secondary_keys_with_authorization"
          }
          Self::set_secondary_key_permissions { .. } => "Identity.set_secondary_key_permissions",
          Self::remove_secondary_keys { .. } => "Identity.remove_secondary_keys",
          Self::register_custom_claim_type { .. } => "Identity.register_custom_claim_type",
          Self::cdd_register_did_with_cdd { .. } => "Identity.cdd_register_did_with_cdd",
          Self::create_child_identity { .. } => "Identity.create_child_identity",
          Self::create_child_identities { .. } => "Identity.create_child_identities",
          Self::unlink_child_identity { .. } => "Identity.unlink_child_identity",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for IdentityCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: cdd_register_did { .. } => { & ["Register `target_account` with a new Identity." , "" , "# Failure" , "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new" , "claims." , "- `target_account` (primary key of the new Identity) can be linked to just one and only" , "one identity." , "- External secondary keys can be linked to just one identity." ,] } , Self :: invalidate_cdd_claims { .. } => { & ["Invalidates any claim generated by `cdd` from `disable_from` timestamps." , "" , "You can also define an expiration time," , "which will invalidate all claims generated by that `cdd` and remove it as CDD member group." ,] } , Self :: accept_primary_key { .. } => { & ["Call this with the new primary key. By invoking this method, caller accepts authorization" , "to become the new primary key of the issuing identity. If a CDD service provider approved" , "this change (or this is not required), primary key of the DID is updated." , "" , "The caller (new primary key) must be either a secondary key of the issuing identity, or" , "unlinked to any identity." , "" , "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key" , "instead of leaving it as a secondary key." , "" , "# Arguments" , "* `owner_auth_id` Authorization from the owner who initiated the change" , "* `cdd_auth_id` Authorization from a CDD service provider" ,] } , Self :: change_cdd_requirement_for_mk_rotation { .. } => { & ["Set if CDD authorization is required for updating primary key of an identity." , "Callable via root (governance)" , "" , "# Arguments" , "* `auth_required` CDD Authorization required or not" ,] } , Self :: join_identity_as_key { .. } => { & ["Join an identity as a secondary key." ,] } , Self :: leave_identity_as_key => { & ["Leave the secondary key's identity." ,] } , Self :: add_claim { .. } => { & ["Adds a new claim record or edits an existing one." , "" , "Only called by did_issuer's secondary key." ,] } , Self :: revoke_claim { .. } => { & ["Marks the specified claim as revoked." ,] } , Self :: freeze_secondary_keys => { & ["It disables all secondary keys at `did` identity." , "" , "# Errors" , "" ,] } , Self :: unfreeze_secondary_keys => { & ["Re-enables all secondary keys of the caller's identity." ,] } , Self :: add_authorization { .. } => { & ["Adds an authorization." ,] } , Self :: remove_authorization { .. } => { & ["Removes an authorization." , "_auth_issuer_pays determines whether the issuer of the authorisation pays the transaction fee" ,] } , Self :: gc_add_cdd_claim { .. } => { & ["Assuming this is executed by the GC voting majority, adds a new cdd claim record." ,] } , Self :: gc_revoke_cdd_claim { .. } => { & ["Assuming this is executed by the GC voting majority, removes an existing cdd claim record." ,] } , Self :: revoke_claim_by_index { .. } => { & ["Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`," , "`claim_type`, and `scope`." , "" , "Please note that `origin` must be the issuer of the target claim." ,] } , Self :: rotate_primary_key_to_secondary { .. } => { & ["Call this with the new primary key. By invoking this method, caller accepts authorization" , "to become the new primary key of the issuing identity. If a CDD service provider approved" , "this change, (or this is not required), primary key of the DID is updated." , "" , "The caller (new primary key) must be either a secondary key of the issuing identity, or" , "unlinked to any identity." , "" , "Differs from accept_primary_key in that it will leave the old primary key as a secondary" , "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization" , "instead of unlinking the old primary key." , "" , "# Arguments" , "* `owner_auth_id` Authorization from the owner who initiated the change" , "* `cdd_auth_id` Authorization from a CDD service provider" ,] } , Self :: add_secondary_keys_with_authorization { .. } => { & ["Adds secondary keys to target identity `id`." , "" , "Keys are directly added to identity because each of them has an authorization." , "" , "# Arguments:" , "    - `origin` which must be the primary key of the identity `id`." , "    - `id` to which new secondary keys will be added." , "    - `additional_keys` which includes secondary keys," , "       coupled with authorization data, to add to target identity." , "" , "# Errors" , "    - Can only called by primary key owner." , "    - Keys should be able to linked to any identity." ,] } , Self :: set_secondary_key_permissions { .. } => { & ["Sets permissions for an specific `target_key` key." , "" , "Only the primary key of an identity is able to set secondary key permissions." ,] } , Self :: remove_secondary_keys { .. } => { & ["Removes specified secondary keys of a DID if present." , "" , "# Errors" , "" , "The extrinsic can only called by primary key owner." ,] } , Self :: register_custom_claim_type { .. } => { & ["Register custom claim type." , "" , "# Errors" , "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists." , "* `CounterOverflow` CustomClaimTypeId has overflowed." , "* `TooLong` The type being registered is too lang." ,] } , Self :: cdd_register_did_with_cdd { .. } => { & ["Register `target_account` with a new Identity and issue a CDD claim with a blank CddId" , "" , "# Failure" , "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new" , "claims." , "- `target_account` (primary key of the new Identity) can be linked to just one and only" , "one identity." , "- External secondary keys can be linked to just one identity." ,] } , Self :: create_child_identity { .. } => { & ["Create a child identity and make the `secondary_key` it's primary key." , "" , "Only the primary key can create child identities." , "" , "# Arguments" , "- `secondary_key` the secondary key that will become the primary key of the new identity." , "" , "# Errors" , "- `KeyNotAllowed` only the primary key can create a new identity." , "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity." , "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity." , "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities." ,] } , Self :: create_child_identities { .. } => { & ["Create a child identities." , "" , "The new primary key for each child identity will need to sign (off-chain)" , "an authorization." , "" , "Only the primary key can create child identities." , "" , "# Arguments" , "- `child_keys` the keys that will become primary keys of their own child identity." , "" , "# Errors" , "- `KeyNotAllowed` only the primary key can create a new identity." , "- `AlreadyLinked` one of the keys is already linked to an identity." , "- `DuplicateKey` one of the keys is included multiple times." , "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities." ,] } , Self :: unlink_child_identity { .. } => { & ["Unlink a child identity from it's parent identity." , "" , "Only the primary key of the parent or child identities can unlink the identities." , "" , "# Arguments" , "- `child_did` the child identity to unlink from its parent identity." , "" , "# Errors" , "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities." , "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity." , "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity." ,] } , _ => & [""] , }
      }
    }
    impl From<IdentityCall> for &'static str {
      fn from(v: IdentityCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&IdentityCall> for &'static str {
      fn from(v: &IdentityCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum IdentityError {
      #[doc = "One secondary or primary key can only belong to one DID"]
      #[codec(index = 0u8)]
      AlreadyLinked,
      #[doc = "Caller is missing an identity."]
      #[codec(index = 1u8)]
      MissingIdentity,
      #[doc = "Signatory is not pre authorized by the identity"]
      #[codec(index = 2u8)]
      Unauthorized,
      #[doc = "Account Id cannot be extracted from signer"]
      #[codec(index = 3u8)]
      InvalidAccountKey,
      #[doc = "Only CDD service providers are allowed."]
      #[codec(index = 4u8)]
      UnAuthorizedCddProvider,
      #[doc = "An invalid authorization from the owner."]
      #[codec(index = 5u8)]
      InvalidAuthorizationFromOwner,
      #[doc = "An invalid authorization from the CDD provider."]
      #[codec(index = 6u8)]
      InvalidAuthorizationFromCddProvider,
      #[doc = "Attestation was not by a CDD service provider."]
      #[codec(index = 7u8)]
      NotCddProviderAttestation,
      #[doc = "Authorizations are not for the same DID."]
      #[codec(index = 8u8)]
      AuthorizationsNotForSameDids,
      #[doc = "The DID must already exist."]
      #[codec(index = 9u8)]
      DidMustAlreadyExist,
      #[doc = "The offchain authorization has expired."]
      #[codec(index = 10u8)]
      AuthorizationExpired,
      #[doc = "The target DID has no valid CDD."]
      #[codec(index = 11u8)]
      TargetHasNoCdd,
      #[doc = "Authorization has been explicitly revoked."]
      #[codec(index = 12u8)]
      AuthorizationHasBeenRevoked,
      #[doc = "An invalid authorization signature."]
      #[codec(index = 13u8)]
      InvalidAuthorizationSignature,
      #[doc = "This key is not allowed to execute a given operation."]
      #[codec(index = 14u8)]
      KeyNotAllowed,
      #[doc = "Only the primary key is allowed to revoke an Identity Signatory off-chain authorization."]
      #[codec(index = 15u8)]
      NotPrimaryKey,
      #[doc = "The DID does not exist."]
      #[codec(index = 16u8)]
      DidDoesNotExist,
      #[doc = "The DID already exists."]
      #[codec(index = 17u8)]
      DidAlreadyExists,
      #[doc = "The secondary keys contain the primary key."]
      #[codec(index = 18u8)]
      SecondaryKeysContainPrimaryKey,
      #[doc = "Couldn't charge fee for the transaction."]
      #[codec(index = 19u8)]
      FailedToChargeFee,
      #[doc = "Signer is not a secondary key of the provided identity"]
      #[codec(index = 20u8)]
      NotASigner,
      #[doc = "Cannot convert a `T::AccountId` to `AnySignature::Signer::AccountId`."]
      #[codec(index = 21u8)]
      CannotDecodeSignerAccountId,
      #[doc = "The account key is being used, it can't be unlinked."]
      #[codec(index = 22u8)]
      AccountKeyIsBeingUsed,
      #[doc = "A custom scope is too long."]
      #[doc = "It can at most be `32` characters long."]
      #[codec(index = 23u8)]
      CustomScopeTooLong,
      #[doc = "The custom claim type trying to be registered already exists."]
      #[codec(index = 24u8)]
      CustomClaimTypeAlreadyExists,
      #[doc = "The custom claim type does not exist."]
      #[codec(index = 25u8)]
      CustomClaimTypeDoesNotExist,
      #[doc = "Claim does not exist."]
      #[codec(index = 26u8)]
      ClaimDoesNotExist,
      #[doc = "Identity is already a child of an other identity, can't create grand-child identity."]
      #[codec(index = 27u8)]
      IsChildIdentity,
      #[doc = "The Identity doesn't have a parent identity."]
      #[codec(index = 28u8)]
      NoParentIdentity,
      #[doc = "The caller is not the parent or child identity."]
      #[codec(index = 29u8)]
      NotParentOrChildIdentity,
      #[doc = "The same key was included multiple times."]
      #[codec(index = 30u8)]
      DuplicateKey,
      #[doc = "Cannot use Except when specifying extrinsic permissions."]
      #[codec(index = 31u8)]
      ExceptNotAllowedForExtrinsics,
      #[doc = "Maximum number of given authorizations was exceeded."]
      #[codec(index = 32u8)]
      ExceededNumberOfGivenAuths,
    }
    impl IdentityError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::AlreadyLinked => "Identity.AlreadyLinked",
          Self::MissingIdentity => "Identity.MissingIdentity",
          Self::Unauthorized => "Identity.Unauthorized",
          Self::InvalidAccountKey => "Identity.InvalidAccountKey",
          Self::UnAuthorizedCddProvider => "Identity.UnAuthorizedCddProvider",
          Self::InvalidAuthorizationFromOwner => "Identity.InvalidAuthorizationFromOwner",
          Self::InvalidAuthorizationFromCddProvider => {
            "Identity.InvalidAuthorizationFromCddProvider"
          }
          Self::NotCddProviderAttestation => "Identity.NotCddProviderAttestation",
          Self::AuthorizationsNotForSameDids => "Identity.AuthorizationsNotForSameDids",
          Self::DidMustAlreadyExist => "Identity.DidMustAlreadyExist",
          Self::AuthorizationExpired => "Identity.AuthorizationExpired",
          Self::TargetHasNoCdd => "Identity.TargetHasNoCdd",
          Self::AuthorizationHasBeenRevoked => "Identity.AuthorizationHasBeenRevoked",
          Self::InvalidAuthorizationSignature => "Identity.InvalidAuthorizationSignature",
          Self::KeyNotAllowed => "Identity.KeyNotAllowed",
          Self::NotPrimaryKey => "Identity.NotPrimaryKey",
          Self::DidDoesNotExist => "Identity.DidDoesNotExist",
          Self::DidAlreadyExists => "Identity.DidAlreadyExists",
          Self::SecondaryKeysContainPrimaryKey => "Identity.SecondaryKeysContainPrimaryKey",
          Self::FailedToChargeFee => "Identity.FailedToChargeFee",
          Self::NotASigner => "Identity.NotASigner",
          Self::CannotDecodeSignerAccountId => "Identity.CannotDecodeSignerAccountId",
          Self::AccountKeyIsBeingUsed => "Identity.AccountKeyIsBeingUsed",
          Self::CustomScopeTooLong => "Identity.CustomScopeTooLong",
          Self::CustomClaimTypeAlreadyExists => "Identity.CustomClaimTypeAlreadyExists",
          Self::CustomClaimTypeDoesNotExist => "Identity.CustomClaimTypeDoesNotExist",
          Self::ClaimDoesNotExist => "Identity.ClaimDoesNotExist",
          Self::IsChildIdentity => "Identity.IsChildIdentity",
          Self::NoParentIdentity => "Identity.NoParentIdentity",
          Self::NotParentOrChildIdentity => "Identity.NotParentOrChildIdentity",
          Self::DuplicateKey => "Identity.DuplicateKey",
          Self::ExceptNotAllowedForExtrinsics => "Identity.ExceptNotAllowedForExtrinsics",
          Self::ExceededNumberOfGivenAuths => "Identity.ExceededNumberOfGivenAuths",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for IdentityError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: AlreadyLinked => { & ["One secondary or primary key can only belong to one DID" ,] } , Self :: MissingIdentity => { & ["Caller is missing an identity." ,] } , Self :: Unauthorized => { & ["Signatory is not pre authorized by the identity" ,] } , Self :: InvalidAccountKey => { & ["Account Id cannot be extracted from signer" ,] } , Self :: UnAuthorizedCddProvider => { & ["Only CDD service providers are allowed." ,] } , Self :: InvalidAuthorizationFromOwner => { & ["An invalid authorization from the owner." ,] } , Self :: InvalidAuthorizationFromCddProvider => { & ["An invalid authorization from the CDD provider." ,] } , Self :: NotCddProviderAttestation => { & ["Attestation was not by a CDD service provider." ,] } , Self :: AuthorizationsNotForSameDids => { & ["Authorizations are not for the same DID." ,] } , Self :: DidMustAlreadyExist => { & ["The DID must already exist." ,] } , Self :: AuthorizationExpired => { & ["The offchain authorization has expired." ,] } , Self :: TargetHasNoCdd => { & ["The target DID has no valid CDD." ,] } , Self :: AuthorizationHasBeenRevoked => { & ["Authorization has been explicitly revoked." ,] } , Self :: InvalidAuthorizationSignature => { & ["An invalid authorization signature." ,] } , Self :: KeyNotAllowed => { & ["This key is not allowed to execute a given operation." ,] } , Self :: NotPrimaryKey => { & ["Only the primary key is allowed to revoke an Identity Signatory off-chain authorization." ,] } , Self :: DidDoesNotExist => { & ["The DID does not exist." ,] } , Self :: DidAlreadyExists => { & ["The DID already exists." ,] } , Self :: SecondaryKeysContainPrimaryKey => { & ["The secondary keys contain the primary key." ,] } , Self :: FailedToChargeFee => { & ["Couldn't charge fee for the transaction." ,] } , Self :: NotASigner => { & ["Signer is not a secondary key of the provided identity" ,] } , Self :: CannotDecodeSignerAccountId => { & ["Cannot convert a `T::AccountId` to `AnySignature::Signer::AccountId`." ,] } , Self :: AccountKeyIsBeingUsed => { & ["The account key is being used, it can't be unlinked." ,] } , Self :: CustomScopeTooLong => { & ["A custom scope is too long." , "It can at most be `32` characters long." ,] } , Self :: CustomClaimTypeAlreadyExists => { & ["The custom claim type trying to be registered already exists." ,] } , Self :: CustomClaimTypeDoesNotExist => { & ["The custom claim type does not exist." ,] } , Self :: ClaimDoesNotExist => { & ["Claim does not exist." ,] } , Self :: IsChildIdentity => { & ["Identity is already a child of an other identity, can't create grand-child identity." ,] } , Self :: NoParentIdentity => { & ["The Identity doesn't have a parent identity." ,] } , Self :: NotParentOrChildIdentity => { & ["The caller is not the parent or child identity." ,] } , Self :: DuplicateKey => { & ["The same key was included multiple times." ,] } , Self :: ExceptNotAllowedForExtrinsics => { & ["Cannot use Except when specifying extrinsic permissions." ,] } , Self :: ExceededNumberOfGivenAuths => { & ["Maximum number of given authorizations was exceeded." ,] } , _ => & [""] , }
      }
    }
    impl From<IdentityError> for &'static str {
      fn from(v: IdentityError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&IdentityError> for &'static str {
      fn from(v: &IdentityError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_im_online {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ImOnlineCall {
        #[doc = "## Complexity:"]
        #[doc = "- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of"]
        #[doc = "  `heartbeat.network_state.external_address`"]
        #[doc = "  - `O(K)`: decoding of length `K`"]
        #[doc = "  - `O(E)`: decoding/encoding of length `E`"]
        #[codec(index = 0u8)]
        heartbeat {
          heartbeat: pallet_im_online::Heartbeat<u32>,
          signature: pallet_im_online::sr25519::app_sr25519::Signature,
        },
      }
      impl ImOnlineCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::heartbeat { .. } => "ImOnline.heartbeat",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ImOnlineCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: heartbeat { .. } => { & ["## Complexity:" , "- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of" , "  `heartbeat.network_state.external_address`" , "  - `O(K)`: decoding of length `K`" , "  - `O(E)`: decoding/encoding of length `E`" ,] } , _ => & [""] , }
        }
      }
      impl From<ImOnlineCall> for &'static str {
        fn from(v: ImOnlineCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ImOnlineCall> for &'static str {
        fn from(v: &ImOnlineCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ImOnlineError {
        #[doc = "Non existent public key."]
        #[codec(index = 0u8)]
        InvalidKey,
        #[doc = "Duplicated heartbeat."]
        #[codec(index = 1u8)]
        DuplicatedHeartbeat,
      }
      impl ImOnlineError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidKey => "ImOnline.InvalidKey",
            Self::DuplicatedHeartbeat => "ImOnline.DuplicatedHeartbeat",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ImOnlineError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidKey => &["Non existent public key."],
            Self::DuplicatedHeartbeat => &["Duplicated heartbeat."],
            _ => &[""],
          }
        }
      }
      impl From<ImOnlineError> for &'static str {
        fn from(v: ImOnlineError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ImOnlineError> for &'static str {
        fn from(v: &ImOnlineError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ImOnlineEvent {
        #[doc = "A new heartbeat was received from `AuthorityId`."]
        #[codec(index = 0u8)]
        HeartbeatReceived {
          authority_id: pallet_im_online::sr25519::app_sr25519::Public,
        },
        #[doc = "At the end of the session, no offence was committed."]
        #[codec(index = 1u8)]
        AllGood,
        #[doc = "At the end of the session, at least one validator was found to be offline."]
        #[codec(index = 2u8)]
        SomeOffline {
          offline: ::alloc::vec::Vec<(
            ::polymesh_api_client::AccountId,
            pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
          )>,
        },
      }
      impl ImOnlineEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::HeartbeatReceived { .. } => "ImOnline.HeartbeatReceived",
            Self::AllGood => "ImOnline.AllGood",
            Self::SomeOffline { .. } => "ImOnline.SomeOffline",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ImOnlineEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::HeartbeatReceived { .. } => &["A new heartbeat was received from `AuthorityId`."],
            Self::AllGood => &["At the end of the session, no offence was committed."],
            Self::SomeOffline { .. } => {
              &["At the end of the session, at least one validator was found to be offline."]
            }
            _ => &[""],
          }
        }
      }
      impl From<ImOnlineEvent> for &'static str {
        fn from(v: ImOnlineEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ImOnlineEvent> for &'static str {
        fn from(v: &ImOnlineEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    pub mod sr25519 {
      use super::*;
      pub mod app_sr25519 {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Public(pub sp_core::sr25519::Public);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Signature(pub sp_core::sr25519::Signature);
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct BoundedOpaqueNetworkState {
      pub peer_id: ::alloc::vec::Vec<u8>,
      pub external_addresses: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Heartbeat<BlockNumber> {
      pub block_number: BlockNumber,
      pub network_state: sp_core::offchain::OpaqueNetworkState,
      pub session_index: BlockNumber,
      pub authority_index: BlockNumber,
      pub validators_len: BlockNumber,
    }
  }
  pub mod pallet_indices {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum IndicesCall {
        #[doc = "Assign an previously unassigned index."]
        #[doc = ""]
        #[doc = "Payment: `Deposit` is reserved from the sender account."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Signed_."]
        #[doc = ""]
        #[doc = "- `index`: the index to be claimed. This must not be in use."]
        #[doc = ""]
        #[doc = "Emits `IndexAssigned` if successful."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`."]
        #[codec(index = 0u8)]
        claim { index: u32 },
        #[doc = "Assign an index already owned by the sender to another account. The balance reservation"]
        #[doc = "is effectively transferred to the new account."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Signed_."]
        #[doc = ""]
        #[doc = "- `index`: the index to be re-assigned. This must be owned by the sender."]
        #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
        #[doc = ""]
        #[doc = "Emits `IndexAssigned` if successful."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`."]
        #[codec(index = 1u8)]
        transfer {
          new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          index: u32,
        },
        #[doc = "Free up an index owned by the sender."]
        #[doc = ""]
        #[doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."]
        #[doc = ""]
        #[doc = "- `index`: the index to be freed. This must be owned by the sender."]
        #[doc = ""]
        #[doc = "Emits `IndexFreed` if successful."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`."]
        #[codec(index = 2u8)]
        free { index: u32 },
        #[doc = "Force an index to an account. This doesn't require a deposit. If the index is already"]
        #[doc = "held, then any deposit is reimbursed to its current owner."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Root_."]
        #[doc = ""]
        #[doc = "- `index`: the index to be (re-)assigned."]
        #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
        #[doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."]
        #[doc = ""]
        #[doc = "Emits `IndexAssigned` if successful."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`."]
        #[codec(index = 3u8)]
        force_transfer {
          new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          index: u32,
          freeze: bool,
        },
        #[doc = "Freeze an index so it will always point to the sender account. This consumes the"]
        #[doc = "deposit."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
        #[doc = "non-frozen account `index`."]
        #[doc = ""]
        #[doc = "- `index`: the index to be frozen in place."]
        #[doc = ""]
        #[doc = "Emits `IndexFrozen` if successful."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`."]
        #[codec(index = 4u8)]
        freeze { index: u32 },
      }
      impl IndicesCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::claim { .. } => "Indices.claim",
            Self::transfer { .. } => "Indices.transfer",
            Self::free { .. } => "Indices.free",
            Self::force_transfer { .. } => "Indices.force_transfer",
            Self::freeze { .. } => "Indices.freeze",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for IndicesCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: claim { .. } => { & ["Assign an previously unassigned index." , "" , "Payment: `Deposit` is reserved from the sender account." , "" , "The dispatch origin for this call must be _Signed_." , "" , "- `index`: the index to be claimed. This must not be in use." , "" , "Emits `IndexAssigned` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: transfer { .. } => { & ["Assign an index already owned by the sender to another account. The balance reservation" , "is effectively transferred to the new account." , "" , "The dispatch origin for this call must be _Signed_." , "" , "- `index`: the index to be re-assigned. This must be owned by the sender." , "- `new`: the new owner of the index. This function is a no-op if it is equal to sender." , "" , "Emits `IndexAssigned` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: free { .. } => { & ["Free up an index owned by the sender." , "" , "Payment: Any previous deposit placed for the index is unreserved in the sender account." , "" , "The dispatch origin for this call must be _Signed_ and the sender must own the index." , "" , "- `index`: the index to be freed. This must be owned by the sender." , "" , "Emits `IndexFreed` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: force_transfer { .. } => { & ["Force an index to an account. This doesn't require a deposit. If the index is already" , "held, then any deposit is reimbursed to its current owner." , "" , "The dispatch origin for this call must be _Root_." , "" , "- `index`: the index to be (re-)assigned." , "- `new`: the new owner of the index. This function is a no-op if it is equal to sender." , "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred." , "" , "Emits `IndexAssigned` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: freeze { .. } => { & ["Freeze an index so it will always point to the sender account. This consumes the" , "deposit." , "" , "The dispatch origin for this call must be _Signed_ and the signing account must have a" , "non-frozen account `index`." , "" , "- `index`: the index to be frozen in place." , "" , "Emits `IndexFrozen` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , _ => & [""] , }
        }
      }
      impl From<IndicesCall> for &'static str {
        fn from(v: IndicesCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&IndicesCall> for &'static str {
        fn from(v: &IndicesCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum IndicesError {
        #[doc = "The index was not already assigned."]
        #[codec(index = 0u8)]
        NotAssigned,
        #[doc = "The index is assigned to another account."]
        #[codec(index = 1u8)]
        NotOwner,
        #[doc = "The index was not available."]
        #[codec(index = 2u8)]
        InUse,
        #[doc = "The source and destination accounts are identical."]
        #[codec(index = 3u8)]
        NotTransfer,
        #[doc = "The index is permanent and may not be freed/changed."]
        #[codec(index = 4u8)]
        Permanent,
      }
      impl IndicesError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::NotAssigned => "Indices.NotAssigned",
            Self::NotOwner => "Indices.NotOwner",
            Self::InUse => "Indices.InUse",
            Self::NotTransfer => "Indices.NotTransfer",
            Self::Permanent => "Indices.Permanent",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for IndicesError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::NotAssigned => &["The index was not already assigned."],
            Self::NotOwner => &["The index is assigned to another account."],
            Self::InUse => &["The index was not available."],
            Self::NotTransfer => &["The source and destination accounts are identical."],
            Self::Permanent => &["The index is permanent and may not be freed/changed."],
            _ => &[""],
          }
        }
      }
      impl From<IndicesError> for &'static str {
        fn from(v: IndicesError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&IndicesError> for &'static str {
        fn from(v: &IndicesError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum IndicesEvent {
        #[doc = "A account index was assigned."]
        #[codec(index = 0u8)]
        IndexAssigned {
          who: ::polymesh_api_client::AccountId,
          index: u32,
        },
        #[doc = "A account index has been freed up (unassigned)."]
        #[codec(index = 1u8)]
        IndexFreed { index: u32 },
        #[doc = "A account index has been frozen to its current account ID."]
        #[codec(index = 2u8)]
        IndexFrozen {
          index: u32,
          who: ::polymesh_api_client::AccountId,
        },
      }
      impl IndicesEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::IndexAssigned { .. } => "Indices.IndexAssigned",
            Self::IndexFreed { .. } => "Indices.IndexFreed",
            Self::IndexFrozen { .. } => "Indices.IndexFrozen",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for IndicesEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::IndexAssigned { .. } => &["A account index was assigned."],
            Self::IndexFreed { .. } => &["A account index has been freed up (unassigned)."],
            Self::IndexFrozen { .. } => {
              &["A account index has been frozen to its current account ID."]
            }
            _ => &[""],
          }
        }
      }
      impl From<IndicesEvent> for &'static str {
        fn from(v: IndicesEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&IndicesEvent> for &'static str {
        fn from(v: &IndicesEvent) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod pallet_multisig {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum MultiSigCall {
        #[doc = "Creates a multisig"]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)."]
        #[doc = "* `sigs_required` - Number of sigs required to process a multi-sig tx."]
        #[doc = "* `permissions` - optional custom permissions.  Only the primary key can provide custom permissions."]
        #[codec(index = 0u8)]
        create_multisig {
          signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
          sigs_required: u64,
          permissions: Option<polymesh_primitives::secondary_key::Permissions>,
        },
        #[doc = "Creates a multisig proposal"]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `multisig` - MultiSig address."]
        #[doc = "* `proposal` - Proposal to be voted on."]
        #[doc = "* `expiry` - Optional proposal expiry time."]
        #[doc = ""]
        #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
        #[codec(index = 1u8)]
        create_proposal {
          multisig: ::polymesh_api_client::AccountId,
          proposal: ::alloc::boxed::Box<runtime::RuntimeCall>,
          expiry: Option<u64>,
        },
        #[doc = "Approves a multisig proposal using the caller's secondary key (`AccountId`)."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `multisig` - MultiSig address."]
        #[doc = "* `proposal_id` - Proposal id to approve."]
        #[doc = "* `max_weight` - The maximum weight to execute the proposal."]
        #[doc = ""]
        #[doc = "If quorum is reached, the proposal will be immediately executed."]
        #[codec(index = 2u8)]
        approve {
          multisig: ::polymesh_api_client::AccountId,
          proposal_id: u64,
          max_weight: Option<::polymesh_api_client::sp_weights::Weight>,
        },
        #[doc = "Rejects a multisig proposal using the caller's secondary key (`AccountId`)."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `multisig` - MultiSig address."]
        #[doc = "* `proposal_id` - Proposal id to reject."]
        #[doc = "If quorum is reached, the proposal will be immediately executed."]
        #[codec(index = 3u8)]
        reject {
          multisig: ::polymesh_api_client::AccountId,
          proposal_id: u64,
        },
        #[doc = "Accepts a multisig signer authorization given to signer's key (AccountId)."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `auth_id` - Auth id of the authorization."]
        #[codec(index = 4u8)]
        accept_multisig_signer { auth_id: u64 },
        #[doc = "Adds signers to the multisig.  This must be called by the multisig itself."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `signers` - Signers to add."]
        #[codec(index = 5u8)]
        add_multisig_signers {
          signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        },
        #[doc = "Removes signers from the multisig.  This must be called by the multisig itself."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `signers` - Signers to remove."]
        #[codec(index = 6u8)]
        remove_multisig_signers {
          signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        },
        #[doc = "Adds a signer to the multisig.  This must be called by the admin identity of the"]
        #[doc = "multisig."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `multisig` - Address of the multi sig"]
        #[doc = "* `signers` - Signers to add."]
        #[doc = ""]
        #[codec(index = 7u8)]
        add_multisig_signers_via_admin {
          multisig: ::polymesh_api_client::AccountId,
          signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        },
        #[doc = "Removes a signer from the multisig."]
        #[doc = "This must be called by the admin identity of the multisig."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `multisig` - Address of the multisig."]
        #[doc = "* `signers` - Signers to remove."]
        #[doc = ""]
        #[codec(index = 8u8)]
        remove_multisig_signers_via_admin {
          multisig: ::polymesh_api_client::AccountId,
          signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        },
        #[doc = "Changes the number of signatures required by a multisig.  This must be called by the"]
        #[doc = "multisig itself."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `sigs_required` - New number of required signatures."]
        #[codec(index = 9u8)]
        change_sigs_required { sigs_required: u64 },
        #[doc = "Changes the number of signatures required by a multisig.  This must be called by the admin of the multisig."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `multisig` - The account identifier ([`AccountId`]) for the multi signature account."]
        #[doc = "* `signatures_required` - The number of required signatures."]
        #[codec(index = 10u8)]
        change_sigs_required_via_admin {
          multisig: ::polymesh_api_client::AccountId,
          signatures_required: u64,
        },
        #[doc = "Add an admin identity to the multisig.  This must be called by the multisig itself."]
        #[codec(index = 11u8)]
        add_admin {
          admin_did: ::polymesh_api_client::IdentityId,
        },
        #[doc = "Removes the admin identity from the `multisig`.  This must be called by the admin of the multisig."]
        #[codec(index = 12u8)]
        remove_admin_via_admin {
          multisig: ::polymesh_api_client::AccountId,
        },
        #[doc = "Removes the paying identity from the `multisig`.  This must be called by the multisig itself."]
        #[codec(index = 13u8)]
        remove_payer,
        #[doc = "Removes the paying identity from the `multisig`.  This must be called by the paying identity of the multisig."]
        #[codec(index = 14u8)]
        remove_payer_via_payer {
          multisig: ::polymesh_api_client::AccountId,
        },
        #[doc = "Approves a multisig join identity proposal."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "* `multisig` - MultiSig address."]
        #[doc = "* `auth_id` - The join identity authorization to approve."]
        #[doc = ""]
        #[doc = "If quorum is reached, the join identity proposal will be immediately executed."]
        #[codec(index = 15u8)]
        approve_join_identity {
          multisig: ::polymesh_api_client::AccountId,
          auth_id: u64,
        },
        #[doc = "Accept a JoinIdentity authorization for this multisig.  This must be called by the multisig itself."]
        #[codec(index = 16u8)]
        join_identity { auth_id: u64 },
        #[doc = "Removes the admin identity from the `multisig`.  This must be called by the multisig itself."]
        #[codec(index = 17u8)]
        remove_admin,
      }
      impl MultiSigCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::create_multisig { .. } => "MultiSig.create_multisig",
            Self::create_proposal { .. } => "MultiSig.create_proposal",
            Self::approve { .. } => "MultiSig.approve",
            Self::reject { .. } => "MultiSig.reject",
            Self::accept_multisig_signer { .. } => "MultiSig.accept_multisig_signer",
            Self::add_multisig_signers { .. } => "MultiSig.add_multisig_signers",
            Self::remove_multisig_signers { .. } => "MultiSig.remove_multisig_signers",
            Self::add_multisig_signers_via_admin { .. } => {
              "MultiSig.add_multisig_signers_via_admin"
            }
            Self::remove_multisig_signers_via_admin { .. } => {
              "MultiSig.remove_multisig_signers_via_admin"
            }
            Self::change_sigs_required { .. } => "MultiSig.change_sigs_required",
            Self::change_sigs_required_via_admin { .. } => {
              "MultiSig.change_sigs_required_via_admin"
            }
            Self::add_admin { .. } => "MultiSig.add_admin",
            Self::remove_admin_via_admin { .. } => "MultiSig.remove_admin_via_admin",
            Self::remove_payer => "MultiSig.remove_payer",
            Self::remove_payer_via_payer { .. } => "MultiSig.remove_payer_via_payer",
            Self::approve_join_identity { .. } => "MultiSig.approve_join_identity",
            Self::join_identity { .. } => "MultiSig.join_identity",
            Self::remove_admin => "MultiSig.remove_admin",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for MultiSigCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: create_multisig { .. } => { & ["Creates a multisig" , "" , "# Arguments" , "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)." , "* `sigs_required` - Number of sigs required to process a multi-sig tx." , "* `permissions` - optional custom permissions.  Only the primary key can provide custom permissions." ,] } , Self :: create_proposal { .. } => { & ["Creates a multisig proposal" , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal` - Proposal to be voted on." , "* `expiry` - Optional proposal expiry time." , "" , "If this is 1 out of `m` multisig, the proposal will be immediately executed." ,] } , Self :: approve { .. } => { & ["Approves a multisig proposal using the caller's secondary key (`AccountId`)." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal_id` - Proposal id to approve." , "* `max_weight` - The maximum weight to execute the proposal." , "" , "If quorum is reached, the proposal will be immediately executed." ,] } , Self :: reject { .. } => { & ["Rejects a multisig proposal using the caller's secondary key (`AccountId`)." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal_id` - Proposal id to reject." , "If quorum is reached, the proposal will be immediately executed." ,] } , Self :: accept_multisig_signer { .. } => { & ["Accepts a multisig signer authorization given to signer's key (AccountId)." , "" , "# Arguments" , "* `auth_id` - Auth id of the authorization." ,] } , Self :: add_multisig_signers { .. } => { & ["Adds signers to the multisig.  This must be called by the multisig itself." , "" , "# Arguments" , "* `signers` - Signers to add." ,] } , Self :: remove_multisig_signers { .. } => { & ["Removes signers from the multisig.  This must be called by the multisig itself." , "" , "# Arguments" , "* `signers` - Signers to remove." ,] } , Self :: add_multisig_signers_via_admin { .. } => { & ["Adds a signer to the multisig.  This must be called by the admin identity of the" , "multisig." , "" , "# Arguments" , "* `multisig` - Address of the multi sig" , "* `signers` - Signers to add." , "" ,] } , Self :: remove_multisig_signers_via_admin { .. } => { & ["Removes a signer from the multisig." , "This must be called by the admin identity of the multisig." , "" , "# Arguments" , "* `multisig` - Address of the multisig." , "* `signers` - Signers to remove." , "" ,] } , Self :: change_sigs_required { .. } => { & ["Changes the number of signatures required by a multisig.  This must be called by the" , "multisig itself." , "" , "# Arguments" , "* `sigs_required` - New number of required signatures." ,] } , Self :: change_sigs_required_via_admin { .. } => { & ["Changes the number of signatures required by a multisig.  This must be called by the admin of the multisig." , "" , "# Arguments" , "* `multisig` - The account identifier ([`AccountId`]) for the multi signature account." , "* `signatures_required` - The number of required signatures." ,] } , Self :: add_admin { .. } => { & ["Add an admin identity to the multisig.  This must be called by the multisig itself." ,] } , Self :: remove_admin_via_admin { .. } => { & ["Removes the admin identity from the `multisig`.  This must be called by the admin of the multisig." ,] } , Self :: remove_payer => { & ["Removes the paying identity from the `multisig`.  This must be called by the multisig itself." ,] } , Self :: remove_payer_via_payer { .. } => { & ["Removes the paying identity from the `multisig`.  This must be called by the paying identity of the multisig." ,] } , Self :: approve_join_identity { .. } => { & ["Approves a multisig join identity proposal." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `auth_id` - The join identity authorization to approve." , "" , "If quorum is reached, the join identity proposal will be immediately executed." ,] } , Self :: join_identity { .. } => { & ["Accept a JoinIdentity authorization for this multisig.  This must be called by the multisig itself." ,] } , Self :: remove_admin => { & ["Removes the admin identity from the `multisig`.  This must be called by the multisig itself." ,] } , _ => & [""] , }
        }
      }
      impl From<MultiSigCall> for &'static str {
        fn from(v: MultiSigCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&MultiSigCall> for &'static str {
        fn from(v: &MultiSigCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Multisig module errors."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum MultiSigError {
        #[doc = "The proposal does not exist."]
        #[codec(index = 0u8)]
        ProposalMissing,
        #[doc = "Multisig address."]
        #[codec(index = 1u8)]
        DecodingError,
        #[doc = "Required number of signers must be greater then zero."]
        #[codec(index = 2u8)]
        RequiredSignersIsZero,
        #[doc = "Not a signer."]
        #[codec(index = 3u8)]
        NotASigner,
        #[doc = "No such multisig."]
        #[codec(index = 4u8)]
        NoSuchMultisig,
        #[doc = "Not enough signers.  The number of signers has to be greater then or equal to"]
        #[doc = "the required number of signers to approve proposals."]
        #[codec(index = 5u8)]
        NotEnoughSigners,
        #[doc = "A nonce overflow."]
        #[codec(index = 6u8)]
        NonceOverflow,
        #[doc = "Already voted."]
        #[codec(index = 7u8)]
        AlreadyVoted,
        #[doc = "Already a signer."]
        #[codec(index = 8u8)]
        AlreadyASigner,
        #[doc = "Identity provided is not the multisig's admin."]
        #[codec(index = 9u8)]
        IdentityNotAdmin,
        #[doc = "Identity provided is not the multisig's payer."]
        #[codec(index = 10u8)]
        IdentityNotPayer,
        #[doc = "Changing multisig parameters not allowed since multisig is a primary key."]
        #[codec(index = 11u8)]
        ChangeNotAllowed,
        #[doc = "Signer is an account key that is already associated with a multisig."]
        #[codec(index = 12u8)]
        SignerAlreadyLinkedToMultisig,
        #[doc = "Signer is an account key that is already associated with an identity."]
        #[codec(index = 13u8)]
        SignerAlreadyLinkedToIdentity,
        #[doc = "A multisig can't be a signer of another multisig."]
        #[codec(index = 14u8)]
        NestingNotAllowed,
        #[doc = "Proposal was rejected earlier"]
        #[codec(index = 15u8)]
        ProposalAlreadyRejected,
        #[doc = "Proposal has expired"]
        #[codec(index = 16u8)]
        ProposalExpired,
        #[doc = "Proposal was executed earlier"]
        #[codec(index = 17u8)]
        ProposalAlreadyExecuted,
        #[doc = "Max weight not enough to execute proposal."]
        #[codec(index = 18u8)]
        MaxWeightTooLow,
        #[doc = "Multisig is not attached to an identity"]
        #[codec(index = 19u8)]
        MultisigMissingIdentity,
        #[doc = "Tried to add/remove too many signers."]
        #[codec(index = 20u8)]
        TooManySigners,
        #[doc = "Multisig doesn't have a paying DID."]
        #[codec(index = 21u8)]
        NoPayingDid,
        #[doc = "Expiry must be in the future."]
        #[codec(index = 22u8)]
        InvalidExpiryDate,
        #[doc = "The proposal has been invalidated after a multisg update."]
        #[codec(index = 23u8)]
        InvalidatedProposal,
        #[doc = "Multisig has no admin."]
        #[codec(index = 24u8)]
        AdminNotFound,
      }
      impl MultiSigError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::ProposalMissing => "MultiSig.ProposalMissing",
            Self::DecodingError => "MultiSig.DecodingError",
            Self::RequiredSignersIsZero => "MultiSig.RequiredSignersIsZero",
            Self::NotASigner => "MultiSig.NotASigner",
            Self::NoSuchMultisig => "MultiSig.NoSuchMultisig",
            Self::NotEnoughSigners => "MultiSig.NotEnoughSigners",
            Self::NonceOverflow => "MultiSig.NonceOverflow",
            Self::AlreadyVoted => "MultiSig.AlreadyVoted",
            Self::AlreadyASigner => "MultiSig.AlreadyASigner",
            Self::IdentityNotAdmin => "MultiSig.IdentityNotAdmin",
            Self::IdentityNotPayer => "MultiSig.IdentityNotPayer",
            Self::ChangeNotAllowed => "MultiSig.ChangeNotAllowed",
            Self::SignerAlreadyLinkedToMultisig => "MultiSig.SignerAlreadyLinkedToMultisig",
            Self::SignerAlreadyLinkedToIdentity => "MultiSig.SignerAlreadyLinkedToIdentity",
            Self::NestingNotAllowed => "MultiSig.NestingNotAllowed",
            Self::ProposalAlreadyRejected => "MultiSig.ProposalAlreadyRejected",
            Self::ProposalExpired => "MultiSig.ProposalExpired",
            Self::ProposalAlreadyExecuted => "MultiSig.ProposalAlreadyExecuted",
            Self::MaxWeightTooLow => "MultiSig.MaxWeightTooLow",
            Self::MultisigMissingIdentity => "MultiSig.MultisigMissingIdentity",
            Self::TooManySigners => "MultiSig.TooManySigners",
            Self::NoPayingDid => "MultiSig.NoPayingDid",
            Self::InvalidExpiryDate => "MultiSig.InvalidExpiryDate",
            Self::InvalidatedProposal => "MultiSig.InvalidatedProposal",
            Self::AdminNotFound => "MultiSig.AdminNotFound",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for MultiSigError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::ProposalMissing => &["The proposal does not exist."],
            Self::DecodingError => &["Multisig address."],
            Self::RequiredSignersIsZero => {
              &["Required number of signers must be greater then zero."]
            }
            Self::NotASigner => &["Not a signer."],
            Self::NoSuchMultisig => &["No such multisig."],
            Self::NotEnoughSigners => &[
              "Not enough signers.  The number of signers has to be greater then or equal to",
              "the required number of signers to approve proposals.",
            ],
            Self::NonceOverflow => &["A nonce overflow."],
            Self::AlreadyVoted => &["Already voted."],
            Self::AlreadyASigner => &["Already a signer."],
            Self::IdentityNotAdmin => &["Identity provided is not the multisig's admin."],
            Self::IdentityNotPayer => &["Identity provided is not the multisig's payer."],
            Self::ChangeNotAllowed => {
              &["Changing multisig parameters not allowed since multisig is a primary key."]
            }
            Self::SignerAlreadyLinkedToMultisig => {
              &["Signer is an account key that is already associated with a multisig."]
            }
            Self::SignerAlreadyLinkedToIdentity => {
              &["Signer is an account key that is already associated with an identity."]
            }
            Self::NestingNotAllowed => &["A multisig can't be a signer of another multisig."],
            Self::ProposalAlreadyRejected => &["Proposal was rejected earlier"],
            Self::ProposalExpired => &["Proposal has expired"],
            Self::ProposalAlreadyExecuted => &["Proposal was executed earlier"],
            Self::MaxWeightTooLow => &["Max weight not enough to execute proposal."],
            Self::MultisigMissingIdentity => &["Multisig is not attached to an identity"],
            Self::TooManySigners => &["Tried to add/remove too many signers."],
            Self::NoPayingDid => &["Multisig doesn't have a paying DID."],
            Self::InvalidExpiryDate => &["Expiry must be in the future."],
            Self::InvalidatedProposal => {
              &["The proposal has been invalidated after a multisg update."]
            }
            Self::AdminNotFound => &["Multisig has no admin."],
            _ => &[""],
          }
        }
      }
      impl From<MultiSigError> for &'static str {
        fn from(v: MultiSigError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&MultiSigError> for &'static str {
        fn from(v: &MultiSigError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum MultiSigEvent {
        #[doc = "A Multisig has been created."]
        #[codec(index = 0u8)]
        MultiSigCreated {
          caller_did: ::polymesh_api_client::IdentityId,
          multisig: ::polymesh_api_client::AccountId,
          caller: ::polymesh_api_client::AccountId,
          signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
          sigs_required: u64,
        },
        #[doc = "A Multisig proposal has been created."]
        #[codec(index = 1u8)]
        ProposalAdded {
          caller_did: Option<::polymesh_api_client::IdentityId>,
          multisig: ::polymesh_api_client::AccountId,
          proposal_id: u64,
        },
        #[doc = "A Multisig proposal has been executed."]
        #[codec(index = 2u8)]
        ProposalExecuted {
          caller_did: Option<::polymesh_api_client::IdentityId>,
          multisig: ::polymesh_api_client::AccountId,
          proposal_id: u64,
          result: Result<(), sp_runtime::DispatchError>,
        },
        #[doc = "A new signer has been added to a Multisig."]
        #[codec(index = 3u8)]
        MultiSigSignerAdded {
          caller_did: ::polymesh_api_client::IdentityId,
          multisig: ::polymesh_api_client::AccountId,
          signer: ::polymesh_api_client::AccountId,
        },
        #[doc = "New keys have been authorized to be signers on a Multisig."]
        #[codec(index = 4u8)]
        MultiSigSignersAuthorized {
          caller_did: ::polymesh_api_client::IdentityId,
          multisig: ::polymesh_api_client::AccountId,
          signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        },
        #[doc = "Signers have been removed from a Multisig."]
        #[codec(index = 5u8)]
        MultiSigSignersRemoved {
          caller_did: ::polymesh_api_client::IdentityId,
          multisig: ::polymesh_api_client::AccountId,
          signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        },
        #[doc = "A Multisig has changed its required number of approvals."]
        #[codec(index = 6u8)]
        MultiSigSignersRequiredChanged {
          caller_did: Option<::polymesh_api_client::IdentityId>,
          multisig: ::polymesh_api_client::AccountId,
          sigs_required: u64,
        },
        #[doc = "A signer has voted to approve a Multisig proposal."]
        #[codec(index = 7u8)]
        ProposalApprovalVote {
          caller_did: Option<::polymesh_api_client::IdentityId>,
          multisig: ::polymesh_api_client::AccountId,
          signer: ::polymesh_api_client::AccountId,
          proposal_id: u64,
        },
        #[doc = "A signer has voted to reject a Multisig proposal."]
        #[codec(index = 8u8)]
        ProposalRejectionVote {
          caller_did: Option<::polymesh_api_client::IdentityId>,
          multisig: ::polymesh_api_client::AccountId,
          signer: ::polymesh_api_client::AccountId,
          proposal_id: u64,
        },
        #[doc = "A Multisig proposal has been approved."]
        #[codec(index = 9u8)]
        ProposalApproved {
          caller_did: Option<::polymesh_api_client::IdentityId>,
          multisig: ::polymesh_api_client::AccountId,
          proposal_id: u64,
        },
        #[doc = "A Multisig proposal has been rejected."]
        #[codec(index = 10u8)]
        ProposalRejected {
          caller_did: Option<::polymesh_api_client::IdentityId>,
          multisig: ::polymesh_api_client::AccountId,
          proposal_id: u64,
        },
        #[doc = "A Multisig has added an admin DID."]
        #[codec(index = 11u8)]
        MultiSigAddedAdmin {
          caller_did: ::polymesh_api_client::IdentityId,
          multisig: ::polymesh_api_client::AccountId,
          admin_did: ::polymesh_api_client::IdentityId,
        },
        #[doc = "A Multisig has removed it's admin DID."]
        #[codec(index = 12u8)]
        MultiSigRemovedAdmin {
          caller_did: ::polymesh_api_client::IdentityId,
          multisig: ::polymesh_api_client::AccountId,
          admin_did: ::polymesh_api_client::IdentityId,
        },
        #[doc = "A Multisig has removed it's paying DID."]
        #[codec(index = 13u8)]
        MultiSigRemovedPayingDid {
          caller_did: ::polymesh_api_client::IdentityId,
          multisig: ::polymesh_api_client::AccountId,
          paying_did: ::polymesh_api_client::IdentityId,
        },
      }
      impl MultiSigEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::MultiSigCreated { .. } => "MultiSig.MultiSigCreated",
            Self::ProposalAdded { .. } => "MultiSig.ProposalAdded",
            Self::ProposalExecuted { .. } => "MultiSig.ProposalExecuted",
            Self::MultiSigSignerAdded { .. } => "MultiSig.MultiSigSignerAdded",
            Self::MultiSigSignersAuthorized { .. } => "MultiSig.MultiSigSignersAuthorized",
            Self::MultiSigSignersRemoved { .. } => "MultiSig.MultiSigSignersRemoved",
            Self::MultiSigSignersRequiredChanged { .. } => {
              "MultiSig.MultiSigSignersRequiredChanged"
            }
            Self::ProposalApprovalVote { .. } => "MultiSig.ProposalApprovalVote",
            Self::ProposalRejectionVote { .. } => "MultiSig.ProposalRejectionVote",
            Self::ProposalApproved { .. } => "MultiSig.ProposalApproved",
            Self::ProposalRejected { .. } => "MultiSig.ProposalRejected",
            Self::MultiSigAddedAdmin { .. } => "MultiSig.MultiSigAddedAdmin",
            Self::MultiSigRemovedAdmin { .. } => "MultiSig.MultiSigRemovedAdmin",
            Self::MultiSigRemovedPayingDid { .. } => "MultiSig.MultiSigRemovedPayingDid",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for MultiSigEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::MultiSigCreated { .. } => &["A Multisig has been created."],
            Self::ProposalAdded { .. } => &["A Multisig proposal has been created."],
            Self::ProposalExecuted { .. } => &["A Multisig proposal has been executed."],
            Self::MultiSigSignerAdded { .. } => &["A new signer has been added to a Multisig."],
            Self::MultiSigSignersAuthorized { .. } => {
              &["New keys have been authorized to be signers on a Multisig."]
            }
            Self::MultiSigSignersRemoved { .. } => &["Signers have been removed from a Multisig."],
            Self::MultiSigSignersRequiredChanged { .. } => {
              &["A Multisig has changed its required number of approvals."]
            }
            Self::ProposalApprovalVote { .. } => {
              &["A signer has voted to approve a Multisig proposal."]
            }
            Self::ProposalRejectionVote { .. } => {
              &["A signer has voted to reject a Multisig proposal."]
            }
            Self::ProposalApproved { .. } => &["A Multisig proposal has been approved."],
            Self::ProposalRejected { .. } => &["A Multisig proposal has been rejected."],
            Self::MultiSigAddedAdmin { .. } => &["A Multisig has added an admin DID."],
            Self::MultiSigRemovedAdmin { .. } => &["A Multisig has removed it's admin DID."],
            Self::MultiSigRemovedPayingDid { .. } => &["A Multisig has removed it's paying DID."],
            _ => &[""],
          }
        }
      }
      impl From<MultiSigEvent> for &'static str {
        fn from(v: MultiSigEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&MultiSigEvent> for &'static str {
        fn from(v: &MultiSigEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_nft {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum NftCall {
      #[doc = "Cretes a new `NFTCollection`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `asset_id` - optional [`AssetId`] associated to the new collection. `None` will create a new asset."]
      #[doc = "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type."]
      #[doc = "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionAlredyRegistered` - if the asset_id is already associated to an NFT collection."]
      #[doc = "- `InvalidAssetType` - if the associated asset is not of type NFT."]
      #[doc = "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed."]
      #[doc = "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 0u8)]
      create_nft_collection {
        asset_id: Option<::polymesh_api_client::AssetId>,
        nft_type: Option<polymesh_primitives::asset::NonFungibleType>,
        collection_keys: polymesh_primitives::nft::NFTCollectionKeys,
      },
      #[doc = "Issues an NFT to the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
      #[doc = "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT."]
      #[doc = "- `portfolio_kind` - the portfolio that will receive the minted nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
      #[doc = "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[codec(index = 1u8)]
      issue_nft {
        asset_id: ::polymesh_api_client::AssetId,
        nft_metadata_attributes: ::alloc::vec::Vec<polymesh_primitives::nft::NFTMetadataAttribute>,
        portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
      },
      #[doc = "Redeems the given NFT from the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
      #[doc = "* `nft_id` - the id of the NFT to be burned."]
      #[doc = "* `portfolio_kind` - the portfolio that contains the nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
      #[doc = "- `NFTNotFound` - if the given NFT does not exist in the portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[codec(index = 2u8)]
      redeem_nft {
        asset_id: ::polymesh_api_client::AssetId,
        nft_id: polymesh_primitives::nft::NFTId,
        portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
        number_of_keys: Option<u8>,
      },
      #[doc = "Forces the transfer of NFTs from a given portfolio to the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `nft_id` - the [`NFTId`] of the NFT to be transferred."]
      #[doc = "* `source_portfolio` - the [`PortfolioId`] that currently holds the NFT."]
      #[doc = "* `callers_portfolio_kind` - the [`PortfolioKind`] of the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[codec(index = 3u8)]
      controller_transfer {
        nfts: polymesh_primitives::nft::NFTs,
        source_portfolio: polymesh_primitives::identity_id::PortfolioId,
        callers_portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
      },
    }
    impl NftCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_nft_collection { .. } => "Nft.create_nft_collection",
          Self::issue_nft { .. } => "Nft.issue_nft",
          Self::redeem_nft { .. } => "Nft.redeem_nft",
          Self::controller_transfer { .. } => "Nft.controller_transfer",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for NftCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: create_nft_collection { .. } => { & ["Cretes a new `NFTCollection`." , "" , "# Arguments" , "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)." , "* `asset_id` - optional [`AssetId`] associated to the new collection. `None` will create a new asset." , "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type." , "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have." , "" , "## Errors" , "- `CollectionAlredyRegistered` - if the asset_id is already associated to an NFT collection." , "- `InvalidAssetType` - if the associated asset is not of type NFT." , "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed." , "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered." , "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input." , "" , "# Permissions" , "* Asset" ,] } , Self :: issue_nft { .. } => { & ["Issues an NFT to the caller." , "" , "# Arguments" , "* `origin` - is a signer that has permissions to act as an agent of `asset_id`." , "* `asset_id` - the [`AssetId`] of the NFT collection." , "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT." , "- `portfolio_kind` - the portfolio that will receive the minted nft." , "" , "## Errors" , "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created." , "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection." , "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input." , "" , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: redeem_nft { .. } => { & ["Redeems the given NFT from the caller's portfolio." , "" , "# Arguments" , "* `origin` - is a signer that has permissions to act as an agent of `asset_id`." , "* `asset_id` - the [`AssetId`] of the NFT collection." , "* `nft_id` - the id of the NFT to be burned." , "* `portfolio_kind` - the portfolio that contains the nft." , "" , "## Errors" , "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created." , "- `NFTNotFound` - if the given NFT does not exist in the portfolio." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: controller_transfer { .. } => { & ["Forces the transfer of NFTs from a given portfolio to the caller's portfolio." , "" , "# Arguments" , "* `origin` - is a signer that has permissions to act as an agent of `asset_id`." , "* `nft_id` - the [`NFTId`] of the NFT to be transferred." , "* `source_portfolio` - the [`PortfolioId`] that currently holds the NFT." , "* `callers_portfolio_kind` - the [`PortfolioKind`] of the caller's portfolio." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , _ => & [""] , }
      }
    }
    impl From<NftCall> for &'static str {
      fn from(v: NftCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&NftCall> for &'static str {
      fn from(v: &NftCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum NftError {
      #[doc = "An overflow while calculating the balance."]
      #[codec(index = 0u8)]
      BalanceOverflow,
      #[doc = "An underflow while calculating the balance."]
      #[codec(index = 1u8)]
      BalanceUnderflow,
      #[doc = "The asset_id is already associated to an NFT collection."]
      #[codec(index = 2u8)]
      CollectionAlredyRegistered,
      #[doc = "The NFT collection does not exist."]
      #[codec(index = 3u8)]
      CollectionNotFound,
      #[doc = "A duplicate metadata key has been passed as parameter."]
      #[codec(index = 4u8)]
      DuplicateMetadataKey,
      #[doc = "Duplicate ids are not allowed."]
      #[codec(index = 5u8)]
      DuplicatedNFTId,
      #[doc = "The asset must be of type non-fungible."]
      #[codec(index = 6u8)]
      InvalidAssetType,
      #[doc = "Either the number of keys or the key identifier does not match the keys defined for the collection."]
      #[codec(index = 7u8)]
      InvalidMetadataAttribute,
      #[doc = "Failed to transfer an NFT - NFT collection not found."]
      #[codec(index = 8u8)]
      InvalidNFTTransferCollectionNotFound,
      #[doc = "Failed to transfer an NFT - attempt to move to the same portfolio."]
      #[codec(index = 9u8)]
      InvalidNFTTransferSamePortfolio,
      #[doc = "Failed to transfer an NFT - NFT not found in portfolio."]
      #[codec(index = 10u8)]
      InvalidNFTTransferNFTNotOwned,
      #[doc = "Failed to transfer an NFT - identity count would overflow."]
      #[codec(index = 11u8)]
      InvalidNFTTransferCountOverflow,
      #[doc = "Failed to transfer an NFT - compliance failed."]
      #[codec(index = 12u8)]
      InvalidNFTTransferComplianceFailure,
      #[doc = "Failed to transfer an NFT - asset is frozen."]
      #[codec(index = 13u8)]
      InvalidNFTTransferFrozenAsset,
      #[doc = "Failed to transfer an NFT - the number of nfts in the identity is insufficient."]
      #[codec(index = 14u8)]
      InvalidNFTTransferInsufficientCount,
      #[doc = "The maximum number of metadata keys was exceeded."]
      #[codec(index = 15u8)]
      MaxNumberOfKeysExceeded,
      #[doc = "The maximum number of nfts being transferred in one leg was exceeded."]
      #[codec(index = 16u8)]
      MaxNumberOfNFTsPerLegExceeded,
      #[doc = "The NFT does not exist."]
      #[codec(index = 17u8)]
      NFTNotFound,
      #[doc = "At least one of the metadata keys has not been registered."]
      #[codec(index = 18u8)]
      UnregisteredMetadataKey,
      #[doc = "It is not possible to transferr zero nft."]
      #[codec(index = 19u8)]
      ZeroCount,
      #[doc = "An overflow while calculating the updated supply."]
      #[codec(index = 20u8)]
      SupplyOverflow,
      #[doc = "An underflow while calculating the updated supply."]
      #[codec(index = 21u8)]
      SupplyUnderflow,
      #[doc = "Failed to transfer an NFT - nft is locked."]
      #[codec(index = 22u8)]
      InvalidNFTTransferNFTIsLocked,
      #[doc = "The sender identity can't be the same as the receiver identity."]
      #[codec(index = 23u8)]
      InvalidNFTTransferSenderIdMatchesReceiverId,
      #[doc = "The receiver has an invalid CDD."]
      #[codec(index = 24u8)]
      InvalidNFTTransferInvalidReceiverCDD,
      #[doc = "The sender has an invalid CDD."]
      #[codec(index = 25u8)]
      InvalidNFTTransferInvalidSenderCDD,
      #[doc = "There's no asset associated to the given asset_id."]
      #[codec(index = 26u8)]
      InvalidAssetId,
      #[doc = "The NFT is locked."]
      #[codec(index = 27u8)]
      NFTIsLocked,
      #[doc = "The number of keys in the collection is greater than the input."]
      #[codec(index = 28u8)]
      NumberOfKeysIsLessThanExpected,
    }
    impl NftError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::BalanceOverflow => "Nft.BalanceOverflow",
          Self::BalanceUnderflow => "Nft.BalanceUnderflow",
          Self::CollectionAlredyRegistered => "Nft.CollectionAlredyRegistered",
          Self::CollectionNotFound => "Nft.CollectionNotFound",
          Self::DuplicateMetadataKey => "Nft.DuplicateMetadataKey",
          Self::DuplicatedNFTId => "Nft.DuplicatedNFTId",
          Self::InvalidAssetType => "Nft.InvalidAssetType",
          Self::InvalidMetadataAttribute => "Nft.InvalidMetadataAttribute",
          Self::InvalidNFTTransferCollectionNotFound => "Nft.InvalidNFTTransferCollectionNotFound",
          Self::InvalidNFTTransferSamePortfolio => "Nft.InvalidNFTTransferSamePortfolio",
          Self::InvalidNFTTransferNFTNotOwned => "Nft.InvalidNFTTransferNFTNotOwned",
          Self::InvalidNFTTransferCountOverflow => "Nft.InvalidNFTTransferCountOverflow",
          Self::InvalidNFTTransferComplianceFailure => "Nft.InvalidNFTTransferComplianceFailure",
          Self::InvalidNFTTransferFrozenAsset => "Nft.InvalidNFTTransferFrozenAsset",
          Self::InvalidNFTTransferInsufficientCount => "Nft.InvalidNFTTransferInsufficientCount",
          Self::MaxNumberOfKeysExceeded => "Nft.MaxNumberOfKeysExceeded",
          Self::MaxNumberOfNFTsPerLegExceeded => "Nft.MaxNumberOfNFTsPerLegExceeded",
          Self::NFTNotFound => "Nft.NFTNotFound",
          Self::UnregisteredMetadataKey => "Nft.UnregisteredMetadataKey",
          Self::ZeroCount => "Nft.ZeroCount",
          Self::SupplyOverflow => "Nft.SupplyOverflow",
          Self::SupplyUnderflow => "Nft.SupplyUnderflow",
          Self::InvalidNFTTransferNFTIsLocked => "Nft.InvalidNFTTransferNFTIsLocked",
          Self::InvalidNFTTransferSenderIdMatchesReceiverId => {
            "Nft.InvalidNFTTransferSenderIdMatchesReceiverId"
          }
          Self::InvalidNFTTransferInvalidReceiverCDD => "Nft.InvalidNFTTransferInvalidReceiverCDD",
          Self::InvalidNFTTransferInvalidSenderCDD => "Nft.InvalidNFTTransferInvalidSenderCDD",
          Self::InvalidAssetId => "Nft.InvalidAssetId",
          Self::NFTIsLocked => "Nft.NFTIsLocked",
          Self::NumberOfKeysIsLessThanExpected => "Nft.NumberOfKeysIsLessThanExpected",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for NftError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: BalanceOverflow => { & ["An overflow while calculating the balance." ,] } , Self :: BalanceUnderflow => { & ["An underflow while calculating the balance." ,] } , Self :: CollectionAlredyRegistered => { & ["The asset_id is already associated to an NFT collection." ,] } , Self :: CollectionNotFound => { & ["The NFT collection does not exist." ,] } , Self :: DuplicateMetadataKey => { & ["A duplicate metadata key has been passed as parameter." ,] } , Self :: DuplicatedNFTId => { & ["Duplicate ids are not allowed." ,] } , Self :: InvalidAssetType => { & ["The asset must be of type non-fungible." ,] } , Self :: InvalidMetadataAttribute => { & ["Either the number of keys or the key identifier does not match the keys defined for the collection." ,] } , Self :: InvalidNFTTransferCollectionNotFound => { & ["Failed to transfer an NFT - NFT collection not found." ,] } , Self :: InvalidNFTTransferSamePortfolio => { & ["Failed to transfer an NFT - attempt to move to the same portfolio." ,] } , Self :: InvalidNFTTransferNFTNotOwned => { & ["Failed to transfer an NFT - NFT not found in portfolio." ,] } , Self :: InvalidNFTTransferCountOverflow => { & ["Failed to transfer an NFT - identity count would overflow." ,] } , Self :: InvalidNFTTransferComplianceFailure => { & ["Failed to transfer an NFT - compliance failed." ,] } , Self :: InvalidNFTTransferFrozenAsset => { & ["Failed to transfer an NFT - asset is frozen." ,] } , Self :: InvalidNFTTransferInsufficientCount => { & ["Failed to transfer an NFT - the number of nfts in the identity is insufficient." ,] } , Self :: MaxNumberOfKeysExceeded => { & ["The maximum number of metadata keys was exceeded." ,] } , Self :: MaxNumberOfNFTsPerLegExceeded => { & ["The maximum number of nfts being transferred in one leg was exceeded." ,] } , Self :: NFTNotFound => { & ["The NFT does not exist." ,] } , Self :: UnregisteredMetadataKey => { & ["At least one of the metadata keys has not been registered." ,] } , Self :: ZeroCount => { & ["It is not possible to transferr zero nft." ,] } , Self :: SupplyOverflow => { & ["An overflow while calculating the updated supply." ,] } , Self :: SupplyUnderflow => { & ["An underflow while calculating the updated supply." ,] } , Self :: InvalidNFTTransferNFTIsLocked => { & ["Failed to transfer an NFT - nft is locked." ,] } , Self :: InvalidNFTTransferSenderIdMatchesReceiverId => { & ["The sender identity can't be the same as the receiver identity." ,] } , Self :: InvalidNFTTransferInvalidReceiverCDD => { & ["The receiver has an invalid CDD." ,] } , Self :: InvalidNFTTransferInvalidSenderCDD => { & ["The sender has an invalid CDD." ,] } , Self :: InvalidAssetId => { & ["There's no asset associated to the given asset_id." ,] } , Self :: NFTIsLocked => { & ["The NFT is locked." ,] } , Self :: NumberOfKeysIsLessThanExpected => { & ["The number of keys in the collection is greater than the input." ,] } , _ => & [""] , }
      }
    }
    impl From<NftError> for &'static str {
      fn from(v: NftError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&NftError> for &'static str {
      fn from(v: &NftError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_offences {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Events type."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum OffencesEvent {
        #[doc = "There is an offence reported of the given `kind` happened at the `session_index` and"]
        #[doc = "(kind-specific) time slot. This event is not deposited for duplicate slashes."]
        #[doc = "\\[kind, timeslot\\]."]
        #[codec(index = 0u8)]
        Offence {
          kind: [u8; 16usize],
          timeslot: ::alloc::vec::Vec<u8>,
        },
      }
      impl OffencesEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Offence { .. } => "Offences.Offence",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for OffencesEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: Offence { .. } => { & ["There is an offence reported of the given `kind` happened at the `session_index` and" , "(kind-specific) time slot. This event is not deposited for duplicate slashes." , "\\[kind, timeslot\\]." ,] } , _ => & [""] , }
        }
      }
      impl From<OffencesEvent> for &'static str {
        fn from(v: OffencesEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&OffencesEvent> for &'static str {
        fn from(v: &OffencesEvent) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod pallet_permissions {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PermissionsError {
      #[doc = "The caller is not authorized to call the current extrinsic."]
      #[codec(index = 0u8)]
      UnauthorizedCaller,
    }
    impl PermissionsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::UnauthorizedCaller => "Permissions.UnauthorizedCaller",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PermissionsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::UnauthorizedCaller => {
            &["The caller is not authorized to call the current extrinsic."]
          }
          _ => &[""],
        }
      }
    }
    impl From<PermissionsError> for &'static str {
      fn from(v: PermissionsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PermissionsError> for &'static str {
      fn from(v: &PermissionsError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct StoreCallMetadata();
  }
  pub mod pallet_pips {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PipsCall {
      #[doc = "Change whether completed PIPs are pruned."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `prune` specifies whether completed PIPs should be pruned."]
      #[codec(index = 0u8)]
      set_prune_historical_pips { prune: bool },
      #[doc = "Change the minimum proposal deposit amount required to start a proposal."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `deposit` the new min deposit required to start a proposal"]
      #[codec(index = 1u8)]
      set_min_proposal_deposit { deposit: u128 },
      #[doc = "Change the default enactment period."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `duration` the new default enactment period it takes for a scheduled PIP to be executed."]
      #[codec(index = 2u8)]
      set_default_enactment_period { duration: u32 },
      #[doc = "Change the amount of blocks after which a pending PIP is expired."]
      #[doc = "If `expiry` is `None` then PIPs never expire."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` the block-time it takes for a still-`Pending` PIP to expire."]
      #[codec(index = 3u8)]
      set_pending_pip_expiry {
        expiry: polymesh_common_utilities::MaybeBlock<u32>,
      },
      #[doc = "Change the maximum skip count (`max_pip_skip_count`)."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `max` skips before a PIP cannot be skipped by GC anymore."]
      #[codec(index = 4u8)]
      set_max_pip_skip_count { max: u8 },
      #[doc = "Change the maximum number of active PIPs before community members cannot propose anything."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` of concurrent active PIPs."]
      #[codec(index = 5u8)]
      set_active_pip_limit { limit: u32 },
      #[doc = "A network member creates a PIP by submitting a dispatchable which"]
      #[doc = "changes the network in someway. A minimum deposit is required to open a new proposal."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposer` is either a signing key or committee."]
      #[doc = "   Used to understand whether this is a committee proposal and verified against `origin`."]
      #[doc = "* `proposal` a dispatchable call"]
      #[doc = "* `deposit` minimum deposit value, which is ignored if `proposer` is a committee."]
      #[doc = "* `url` a link to a website for proposal discussion"]
      #[codec(index = 6u8)]
      propose {
        proposal: ::alloc::boxed::Box<runtime::RuntimeCall>,
        deposit: u128,
        url: Option<polymesh_primitives::Url>,
        description: Option<pallet_pips::PipDescription>,
      },
      #[doc = "Vote either in favor (`aye_or_nay` == true) or against a PIP with `id`."]
      #[doc = "The \"convinction\" or strength of the vote is given by `deposit`, which is reserved."]
      #[doc = ""]
      #[doc = "Note that `vote` is *not* additive."]
      #[doc = "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`"]
      #[doc = "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit."]
      #[doc = "To add atop of existing votes, you'll need `existing_deposit + addition`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`, proposal id"]
      #[doc = "* `aye_or_nay`, a bool representing for or against vote"]
      #[doc = "* `deposit`, the \"conviction\" with which the vote is made."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchProposal` if `id` doesn't reference a valid PIP."]
      #[doc = "* `NotFromCommunity` if proposal was made by a committee."]
      #[doc = "* `IncorrectProposalState` if PIP isn't pending."]
      #[doc = "* `InsufficientDeposit` if `origin` cannot reserve `deposit - old_deposit`."]
      #[codec(index = 7u8)]
      vote {
        id: pallet_pips::PipId,
        aye_or_nay: bool,
        deposit: u128,
      },
      #[doc = "Approves the pending committee PIP given by the `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal isn't pending."]
      #[doc = "* `NotByCommittee` if the proposal isn't by a committee."]
      #[codec(index = 8u8)]
      approve_committee_proposal { id: pallet_pips::PipId },
      #[doc = "Rejects the PIP given by the `id`, refunding any bonded funds,"]
      #[doc = "assuming it hasn't been cancelled or executed."]
      #[doc = "Note that proposals scheduled-for-execution can also be rejected."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal was cancelled or executed."]
      #[codec(index = 9u8)]
      reject_proposal { id: pallet_pips::PipId },
      #[doc = "Prune the PIP given by the `id`, refunding any funds not already refunded."]
      #[doc = "The PIP may not be active"]
      #[doc = ""]
      #[doc = "This function is intended for storage garbage collection purposes."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal is active."]
      #[codec(index = 10u8)]
      prune_proposal { id: pallet_pips::PipId },
      #[doc = "Updates the execution schedule of the PIP given by `id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `until` defines the future block where the enactment period will finished."]
      #[doc = "   `None` value means that enactment period is going to finish in the next block."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `RescheduleNotByReleaseCoordinator` unless triggered by release coordinator."]
      #[doc = "* `IncorrectProposalState` unless the proposal was in a scheduled state."]
      #[codec(index = 11u8)]
      reschedule_execution {
        id: pallet_pips::PipId,
        until: Option<u32>,
      },
      #[doc = "Clears the snapshot and emits the event `SnapshotCleared`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[codec(index = 12u8)]
      clear_snapshot,
      #[doc = "Takes a new snapshot of the current list of active && pending PIPs."]
      #[doc = "The PIPs are then sorted into a priority queue based on each PIP's weight."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[codec(index = 13u8)]
      snapshot,
      #[doc = "Enacts `results` for the PIPs in the snapshot queue."]
      #[doc = "The snapshot will be available for further enactments until it is cleared."]
      #[doc = ""]
      #[doc = "The `results` are encoded a list of `(id, result)` where `result` is applied to `id`."]
      #[doc = "Note that the snapshot priority queue is encoded with the *lowest priority first*."]
      #[doc = "so `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - unless a GC voting majority executes this function."]
      #[doc = "* `CannotSkipPip` - a given PIP has already been skipped too many times."]
      #[doc = "* `SnapshotResultTooLarge` - on len(results) > len(snapshot_queue)."]
      #[doc = "* `SnapshotIdMismatch` - if:"]
      #[doc = "  ```text"]
      #[doc = "   ∃ (i ∈ 0..SnapshotQueue.len())."]
      #[doc = "     results[i].0 ≠ SnapshotQueue[SnapshotQueue.len() - i].id"]
      #[doc = "  ```"]
      #[doc = "   This is protects against clearing queue while GC is voting."]
      #[codec(index = 14u8)]
      enact_snapshot_results {
        results: ::alloc::vec::Vec<(pallet_pips::PipId, pallet_pips::SnapshotResult)>,
      },
      #[doc = "Internal dispatchable that handles execution of a PIP."]
      #[codec(index = 15u8)]
      execute_scheduled_pip { id: pallet_pips::PipId },
      #[doc = "Internal dispatchable that handles expiration of a PIP."]
      #[codec(index = 16u8)]
      expire_scheduled_pip {
        did: ::polymesh_api_client::IdentityId,
        id: pallet_pips::PipId,
      },
    }
    impl PipsCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_prune_historical_pips { .. } => "Pips.set_prune_historical_pips",
          Self::set_min_proposal_deposit { .. } => "Pips.set_min_proposal_deposit",
          Self::set_default_enactment_period { .. } => "Pips.set_default_enactment_period",
          Self::set_pending_pip_expiry { .. } => "Pips.set_pending_pip_expiry",
          Self::set_max_pip_skip_count { .. } => "Pips.set_max_pip_skip_count",
          Self::set_active_pip_limit { .. } => "Pips.set_active_pip_limit",
          Self::propose { .. } => "Pips.propose",
          Self::vote { .. } => "Pips.vote",
          Self::approve_committee_proposal { .. } => "Pips.approve_committee_proposal",
          Self::reject_proposal { .. } => "Pips.reject_proposal",
          Self::prune_proposal { .. } => "Pips.prune_proposal",
          Self::reschedule_execution { .. } => "Pips.reschedule_execution",
          Self::clear_snapshot => "Pips.clear_snapshot",
          Self::snapshot => "Pips.snapshot",
          Self::enact_snapshot_results { .. } => "Pips.enact_snapshot_results",
          Self::execute_scheduled_pip { .. } => "Pips.execute_scheduled_pip",
          Self::expire_scheduled_pip { .. } => "Pips.expire_scheduled_pip",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PipsCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_prune_historical_pips { .. } => { & ["Change whether completed PIPs are pruned." , "Can only be called by root." , "" , "# Arguments" , "* `prune` specifies whether completed PIPs should be pruned." ,] } , Self :: set_min_proposal_deposit { .. } => { & ["Change the minimum proposal deposit amount required to start a proposal." , "Can only be called by root." , "" , "# Arguments" , "* `deposit` the new min deposit required to start a proposal" ,] } , Self :: set_default_enactment_period { .. } => { & ["Change the default enactment period." , "Can only be called by root." , "" , "# Arguments" , "* `duration` the new default enactment period it takes for a scheduled PIP to be executed." ,] } , Self :: set_pending_pip_expiry { .. } => { & ["Change the amount of blocks after which a pending PIP is expired." , "If `expiry` is `None` then PIPs never expire." , "Can only be called by root." , "" , "# Arguments" , "* `expiry` the block-time it takes for a still-`Pending` PIP to expire." ,] } , Self :: set_max_pip_skip_count { .. } => { & ["Change the maximum skip count (`max_pip_skip_count`)." , "Can only be called by root." , "" , "# Arguments" , "* `max` skips before a PIP cannot be skipped by GC anymore." ,] } , Self :: set_active_pip_limit { .. } => { & ["Change the maximum number of active PIPs before community members cannot propose anything." , "Can only be called by root." , "" , "# Arguments" , "* `limit` of concurrent active PIPs." ,] } , Self :: propose { .. } => { & ["A network member creates a PIP by submitting a dispatchable which" , "changes the network in someway. A minimum deposit is required to open a new proposal." , "" , "# Arguments" , "* `proposer` is either a signing key or committee." , "   Used to understand whether this is a committee proposal and verified against `origin`." , "* `proposal` a dispatchable call" , "* `deposit` minimum deposit value, which is ignored if `proposer` is a committee." , "* `url` a link to a website for proposal discussion" ,] } , Self :: vote { .. } => { & ["Vote either in favor (`aye_or_nay` == true) or against a PIP with `id`." , "The \"convinction\" or strength of the vote is given by `deposit`, which is reserved." , "" , "Note that `vote` is *not* additive." , "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`" , "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit." , "To add atop of existing votes, you'll need `existing_deposit + addition`." , "" , "# Arguments" , "* `id`, proposal id" , "* `aye_or_nay`, a bool representing for or against vote" , "* `deposit`, the \"conviction\" with which the vote is made." , "" , "# Errors" , "* `NoSuchProposal` if `id` doesn't reference a valid PIP." , "* `NotFromCommunity` if proposal was made by a committee." , "* `IncorrectProposalState` if PIP isn't pending." , "* `InsufficientDeposit` if `origin` cannot reserve `deposit - old_deposit`." ,] } , Self :: approve_committee_proposal { .. } => { & ["Approves the pending committee PIP given by the `id`." , "" , "# Errors" , "* `BadOrigin` unless a GC voting majority executes this function." , "* `NoSuchProposal` if the PIP with `id` doesn't exist." , "* `IncorrectProposalState` if the proposal isn't pending." , "* `NotByCommittee` if the proposal isn't by a committee." ,] } , Self :: reject_proposal { .. } => { & ["Rejects the PIP given by the `id`, refunding any bonded funds," , "assuming it hasn't been cancelled or executed." , "Note that proposals scheduled-for-execution can also be rejected." , "" , "# Errors" , "* `BadOrigin` unless a GC voting majority executes this function." , "* `NoSuchProposal` if the PIP with `id` doesn't exist." , "* `IncorrectProposalState` if the proposal was cancelled or executed." ,] } , Self :: prune_proposal { .. } => { & ["Prune the PIP given by the `id`, refunding any funds not already refunded." , "The PIP may not be active" , "" , "This function is intended for storage garbage collection purposes." , "" , "# Errors" , "* `BadOrigin` unless a GC voting majority executes this function." , "* `NoSuchProposal` if the PIP with `id` doesn't exist." , "* `IncorrectProposalState` if the proposal is active." ,] } , Self :: reschedule_execution { .. } => { & ["Updates the execution schedule of the PIP given by `id`." , "" , "# Arguments" , "* `until` defines the future block where the enactment period will finished." , "   `None` value means that enactment period is going to finish in the next block." , "" , "# Errors" , "* `RescheduleNotByReleaseCoordinator` unless triggered by release coordinator." , "* `IncorrectProposalState` unless the proposal was in a scheduled state." ,] } , Self :: clear_snapshot => { & ["Clears the snapshot and emits the event `SnapshotCleared`." , "" , "# Errors" , "* `NotACommitteeMember` - triggered when a non-GC-member executes the function." ,] } , Self :: snapshot => { & ["Takes a new snapshot of the current list of active && pending PIPs." , "The PIPs are then sorted into a priority queue based on each PIP's weight." , "" , "# Errors" , "* `NotACommitteeMember` - triggered when a non-GC-member executes the function." ,] } , Self :: enact_snapshot_results { .. } => { & ["Enacts `results` for the PIPs in the snapshot queue." , "The snapshot will be available for further enactments until it is cleared." , "" , "The `results` are encoded a list of `(id, result)` where `result` is applied to `id`." , "Note that the snapshot priority queue is encoded with the *lowest priority first*." , "so `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`." , "" , "# Errors" , "* `BadOrigin` - unless a GC voting majority executes this function." , "* `CannotSkipPip` - a given PIP has already been skipped too many times." , "* `SnapshotResultTooLarge` - on len(results) > len(snapshot_queue)." , "* `SnapshotIdMismatch` - if:" , "  ```text" , "   ∃ (i ∈ 0..SnapshotQueue.len())." , "     results[i].0 ≠ SnapshotQueue[SnapshotQueue.len() - i].id" , "  ```" , "   This is protects against clearing queue while GC is voting." ,] } , Self :: execute_scheduled_pip { .. } => { & ["Internal dispatchable that handles execution of a PIP." ,] } , Self :: expire_scheduled_pip { .. } => { & ["Internal dispatchable that handles expiration of a PIP." ,] } , _ => & [""] , }
      }
    }
    impl From<PipsCall> for &'static str {
      fn from(v: PipsCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PipsCall> for &'static str {
      fn from(v: &PipsCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Committee {
      #[codec(index = 0u8)]
      Technical,
      #[codec(index = 1u8)]
      Upgrade,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct DepositInfo<AccountId> {
      pub owner: AccountId,
      pub amount: u128,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PipsError {
      #[doc = "Only the GC release coordinator is allowed to reschedule proposal execution."]
      #[codec(index = 0u8)]
      RescheduleNotByReleaseCoordinator,
      #[doc = "The given dispatchable call is not valid for this proposal."]
      #[doc = "The proposal must be from the community, but isn't."]
      #[codec(index = 1u8)]
      NotFromCommunity,
      #[doc = "The given dispatchable call is not valid for this proposal."]
      #[doc = "The proposal must be by community, but isn't."]
      #[codec(index = 2u8)]
      NotByCommittee,
      #[doc = "The current number of active (pending | scheduled) PIPs exceed the maximum"]
      #[doc = "and the proposal is not by a committee."]
      #[codec(index = 3u8)]
      TooManyActivePips,
      #[doc = "Proposer specifies an incorrect deposit"]
      #[codec(index = 4u8)]
      IncorrectDeposit,
      #[doc = "Proposer can't afford to lock minimum deposit"]
      #[codec(index = 5u8)]
      InsufficientDeposit,
      #[doc = "The proposal does not exist."]
      #[codec(index = 6u8)]
      NoSuchProposal,
      #[doc = "Not part of governance committee."]
      #[codec(index = 7u8)]
      NotACommitteeMember,
      #[doc = "When a block number is less than current block number."]
      #[codec(index = 8u8)]
      InvalidFutureBlockNumber,
      #[doc = "When number of votes overflows."]
      #[codec(index = 9u8)]
      NumberOfVotesExceeded,
      #[doc = "When stake amount of a vote overflows."]
      #[codec(index = 10u8)]
      StakeAmountOfVotesExceeded,
      #[doc = "Missing current DID"]
      #[codec(index = 11u8)]
      MissingCurrentIdentity,
      #[doc = "Proposal is not in the correct state"]
      #[codec(index = 12u8)]
      IncorrectProposalState,
      #[doc = "When enacting snapshot results, an unskippable PIP was skipped."]
      #[codec(index = 13u8)]
      CannotSkipPip,
      #[doc = "Tried to enact results for the snapshot queue overflowing its length."]
      #[codec(index = 14u8)]
      SnapshotResultTooLarge,
      #[doc = "Tried to enact result for PIP with id different from that at the position in the queue."]
      #[codec(index = 15u8)]
      SnapshotIdMismatch,
      #[doc = "Execution of a scheduled proposal failed because it is missing."]
      #[codec(index = 16u8)]
      ScheduledProposalDoesntExist,
      #[doc = "A proposal that is not in a scheduled state cannot be executed."]
      #[codec(index = 17u8)]
      ProposalNotInScheduledState,
    }
    impl PipsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::RescheduleNotByReleaseCoordinator => "Pips.RescheduleNotByReleaseCoordinator",
          Self::NotFromCommunity => "Pips.NotFromCommunity",
          Self::NotByCommittee => "Pips.NotByCommittee",
          Self::TooManyActivePips => "Pips.TooManyActivePips",
          Self::IncorrectDeposit => "Pips.IncorrectDeposit",
          Self::InsufficientDeposit => "Pips.InsufficientDeposit",
          Self::NoSuchProposal => "Pips.NoSuchProposal",
          Self::NotACommitteeMember => "Pips.NotACommitteeMember",
          Self::InvalidFutureBlockNumber => "Pips.InvalidFutureBlockNumber",
          Self::NumberOfVotesExceeded => "Pips.NumberOfVotesExceeded",
          Self::StakeAmountOfVotesExceeded => "Pips.StakeAmountOfVotesExceeded",
          Self::MissingCurrentIdentity => "Pips.MissingCurrentIdentity",
          Self::IncorrectProposalState => "Pips.IncorrectProposalState",
          Self::CannotSkipPip => "Pips.CannotSkipPip",
          Self::SnapshotResultTooLarge => "Pips.SnapshotResultTooLarge",
          Self::SnapshotIdMismatch => "Pips.SnapshotIdMismatch",
          Self::ScheduledProposalDoesntExist => "Pips.ScheduledProposalDoesntExist",
          Self::ProposalNotInScheduledState => "Pips.ProposalNotInScheduledState",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PipsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: RescheduleNotByReleaseCoordinator => { & ["Only the GC release coordinator is allowed to reschedule proposal execution." ,] } , Self :: NotFromCommunity => { & ["The given dispatchable call is not valid for this proposal." , "The proposal must be from the community, but isn't." ,] } , Self :: NotByCommittee => { & ["The given dispatchable call is not valid for this proposal." , "The proposal must be by community, but isn't." ,] } , Self :: TooManyActivePips => { & ["The current number of active (pending | scheduled) PIPs exceed the maximum" , "and the proposal is not by a committee." ,] } , Self :: IncorrectDeposit => { & ["Proposer specifies an incorrect deposit" ,] } , Self :: InsufficientDeposit => { & ["Proposer can't afford to lock minimum deposit" ,] } , Self :: NoSuchProposal => { & ["The proposal does not exist." ,] } , Self :: NotACommitteeMember => { & ["Not part of governance committee." ,] } , Self :: InvalidFutureBlockNumber => { & ["When a block number is less than current block number." ,] } , Self :: NumberOfVotesExceeded => { & ["When number of votes overflows." ,] } , Self :: StakeAmountOfVotesExceeded => { & ["When stake amount of a vote overflows." ,] } , Self :: MissingCurrentIdentity => { & ["Missing current DID" ,] } , Self :: IncorrectProposalState => { & ["Proposal is not in the correct state" ,] } , Self :: CannotSkipPip => { & ["When enacting snapshot results, an unskippable PIP was skipped." ,] } , Self :: SnapshotResultTooLarge => { & ["Tried to enact results for the snapshot queue overflowing its length." ,] } , Self :: SnapshotIdMismatch => { & ["Tried to enact result for PIP with id different from that at the position in the queue." ,] } , Self :: ScheduledProposalDoesntExist => { & ["Execution of a scheduled proposal failed because it is missing." ,] } , Self :: ProposalNotInScheduledState => { & ["A proposal that is not in a scheduled state cannot be executed." ,] } , _ => & [""] , }
      }
    }
    impl From<PipsError> for &'static str {
      fn from(v: PipsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PipsError> for &'static str {
      fn from(v: &PipsError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Pip<Proposal, AccountId> {
      pub id: pallet_pips::PipId,
      pub proposal: Proposal,
      pub proposer: pallet_pips::Proposer<AccountId>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PipDescription(pub ::alloc::vec::Vec<u8>);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PipId(pub u32);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PipsMetadata<BlockNumber> {
      pub id: pallet_pips::PipId,
      pub url: Option<polymesh_primitives::Url>,
      pub description: Option<pallet_pips::PipDescription>,
      pub created_at: BlockNumber,
      pub transaction_version: BlockNumber,
      pub expiry: polymesh_common_utilities::MaybeBlock<BlockNumber>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ProposalData {
      #[codec(index = 0u8)]
      Hash(primitive_types::H256),
      #[codec(index = 1u8)]
      Proposal(::alloc::vec::Vec<u8>),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ProposalState {
      #[codec(index = 0u8)]
      Pending,
      #[codec(index = 1u8)]
      Rejected,
      #[codec(index = 2u8)]
      Scheduled,
      #[codec(index = 3u8)]
      Failed,
      #[codec(index = 4u8)]
      Executed,
      #[codec(index = 5u8)]
      Expired,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Proposer<AccountId> {
      #[codec(index = 0u8)]
      Community(AccountId),
      #[codec(index = 1u8)]
      Committee(pallet_pips::Committee),
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PipsEvent<AccountId, BlockNumber> {
      #[doc = "Pruning Historical PIPs is enabled or disabled (caller DID, old value, new value)"]
      #[codec(index = 0u8)]
      HistoricalPipsPruned(::polymesh_api_client::IdentityId, bool, bool),
      #[doc = "A PIP was made with a `Balance` stake."]
      #[doc = ""]
      #[doc = "# Parameters:"]
      #[doc = ""]
      #[doc = "Caller DID, Proposer, PIP ID, deposit, URL, description, expiry time, proposal data."]
      #[codec(index = 1u8)]
      ProposalCreated(
        ::polymesh_api_client::IdentityId,
        pallet_pips::Proposer<AccountId>,
        pallet_pips::PipId,
        u128,
        Option<polymesh_primitives::Url>,
        Option<pallet_pips::PipDescription>,
        polymesh_common_utilities::MaybeBlock<BlockNumber>,
        pallet_pips::ProposalData,
      ),
      #[doc = "Triggered each time the state of a proposal is amended"]
      #[codec(index = 2u8)]
      ProposalStateUpdated(
        ::polymesh_api_client::IdentityId,
        pallet_pips::PipId,
        pallet_pips::ProposalState,
      ),
      #[doc = "`AccountId` voted `bool` on the proposal referenced by `PipId`"]
      #[codec(index = 3u8)]
      Voted(
        ::polymesh_api_client::IdentityId,
        AccountId,
        pallet_pips::PipId,
        bool,
        u128,
      ),
      #[doc = "Pip has been closed, bool indicates whether data is pruned"]
      #[codec(index = 4u8)]
      PipClosed(::polymesh_api_client::IdentityId, pallet_pips::PipId, bool),
      #[doc = "Execution of a PIP has been scheduled at specific block."]
      #[codec(index = 5u8)]
      ExecutionScheduled(
        ::polymesh_api_client::IdentityId,
        pallet_pips::PipId,
        BlockNumber,
      ),
      #[doc = "Default enactment period (in blocks) has been changed."]
      #[doc = "(caller DID, old period, new period)"]
      #[codec(index = 6u8)]
      DefaultEnactmentPeriodChanged(::polymesh_api_client::IdentityId, BlockNumber, BlockNumber),
      #[doc = "Minimum deposit amount modified"]
      #[doc = "(caller DID, old amount, new amount)"]
      #[codec(index = 7u8)]
      MinimumProposalDepositChanged(::polymesh_api_client::IdentityId, u128, u128),
      #[doc = "Amount of blocks after which a pending PIP expires."]
      #[doc = "(caller DID, old expiry, new expiry)"]
      #[codec(index = 8u8)]
      PendingPipExpiryChanged(
        ::polymesh_api_client::IdentityId,
        polymesh_common_utilities::MaybeBlock<BlockNumber>,
        polymesh_common_utilities::MaybeBlock<BlockNumber>,
      ),
      #[doc = "The maximum times a PIP can be skipped was changed."]
      #[doc = "(caller DID, old value, new value)"]
      #[codec(index = 9u8)]
      MaxPipSkipCountChanged(::polymesh_api_client::IdentityId, u8, u8),
      #[doc = "The maximum number of active PIPs was changed."]
      #[doc = "(caller DID, old value, new value)"]
      #[codec(index = 10u8)]
      ActivePipLimitChanged(::polymesh_api_client::IdentityId, BlockNumber, BlockNumber),
      #[doc = "Refund proposal"]
      #[doc = "(id, total amount)"]
      #[codec(index = 11u8)]
      ProposalRefund(::polymesh_api_client::IdentityId, pallet_pips::PipId, u128),
      #[doc = "The snapshot was cleared."]
      #[codec(index = 12u8)]
      SnapshotCleared(::polymesh_api_client::IdentityId, pallet_pips::SnapshotId),
      #[doc = "A new snapshot was taken."]
      #[codec(index = 13u8)]
      SnapshotTaken(
        ::polymesh_api_client::IdentityId,
        pallet_pips::SnapshotId,
        ::alloc::vec::Vec<pallet_pips::SnapshottedPip>,
      ),
      #[doc = "A PIP in the snapshot queue was skipped."]
      #[doc = "(gc_did, pip_id, new_skip_count)"]
      #[codec(index = 14u8)]
      PipSkipped(::polymesh_api_client::IdentityId, pallet_pips::PipId, u8),
      #[doc = "Results (e.g., approved, rejected, and skipped), were enacted for some PIPs."]
      #[doc = "(gc_did, snapshot_id_opt, skipped_pips_with_new_count, rejected_pips, approved_pips)"]
      #[codec(index = 15u8)]
      SnapshotResultsEnacted(
        ::polymesh_api_client::IdentityId,
        Option<pallet_pips::SnapshotId>,
        ::alloc::vec::Vec<(pallet_pips::PipId, u8)>,
        ::alloc::vec::Vec<pallet_pips::PipId>,
        ::alloc::vec::Vec<pallet_pips::PipId>,
      ),
      #[doc = "Scheduling of the PIP for execution failed in the scheduler pallet."]
      #[codec(index = 16u8)]
      ExecutionSchedulingFailed(
        ::polymesh_api_client::IdentityId,
        pallet_pips::PipId,
        BlockNumber,
      ),
      #[doc = "The PIP has been scheduled for expiry."]
      #[codec(index = 17u8)]
      ExpiryScheduled(
        ::polymesh_api_client::IdentityId,
        pallet_pips::PipId,
        BlockNumber,
      ),
      #[doc = "Scheduling of the PIP for expiry failed in the scheduler pallet."]
      #[codec(index = 18u8)]
      ExpirySchedulingFailed(
        ::polymesh_api_client::IdentityId,
        pallet_pips::PipId,
        BlockNumber,
      ),
      #[doc = "Cancelling the PIP execution failed in the scheduler pallet."]
      #[codec(index = 19u8)]
      ExecutionCancellingFailed(pallet_pips::PipId),
    }
    impl<AccountId, BlockNumber> PipsEvent<AccountId, BlockNumber> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::HistoricalPipsPruned(_, _, _) => "Pips.HistoricalPipsPruned",
          Self::ProposalCreated(_, _, _, _, _, _, _, _) => "Pips.ProposalCreated",
          Self::ProposalStateUpdated(_, _, _) => "Pips.ProposalStateUpdated",
          Self::Voted(_, _, _, _, _) => "Pips.Voted",
          Self::PipClosed(_, _, _) => "Pips.PipClosed",
          Self::ExecutionScheduled(_, _, _) => "Pips.ExecutionScheduled",
          Self::DefaultEnactmentPeriodChanged(_, _, _) => "Pips.DefaultEnactmentPeriodChanged",
          Self::MinimumProposalDepositChanged(_, _, _) => "Pips.MinimumProposalDepositChanged",
          Self::PendingPipExpiryChanged(_, _, _) => "Pips.PendingPipExpiryChanged",
          Self::MaxPipSkipCountChanged(_, _, _) => "Pips.MaxPipSkipCountChanged",
          Self::ActivePipLimitChanged(_, _, _) => "Pips.ActivePipLimitChanged",
          Self::ProposalRefund(_, _, _) => "Pips.ProposalRefund",
          Self::SnapshotCleared(_, _) => "Pips.SnapshotCleared",
          Self::SnapshotTaken(_, _, _) => "Pips.SnapshotTaken",
          Self::PipSkipped(_, _, _) => "Pips.PipSkipped",
          Self::SnapshotResultsEnacted(_, _, _, _, _) => "Pips.SnapshotResultsEnacted",
          Self::ExecutionSchedulingFailed(_, _, _) => "Pips.ExecutionSchedulingFailed",
          Self::ExpiryScheduled(_, _, _) => "Pips.ExpiryScheduled",
          Self::ExpirySchedulingFailed(_, _, _) => "Pips.ExpirySchedulingFailed",
          Self::ExecutionCancellingFailed(_) => "Pips.ExecutionCancellingFailed",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<AccountId, BlockNumber> ::polymesh_api_client::EnumInfo for PipsEvent<AccountId, BlockNumber> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::HistoricalPipsPruned(_, _, _) => {
            &["Pruning Historical PIPs is enabled or disabled (caller DID, old value, new value)"]
          }
          Self::ProposalCreated(_, _, _, _, _, _, _, _) => &[
            "A PIP was made with a `Balance` stake.",
            "",
            "# Parameters:",
            "",
            "Caller DID, Proposer, PIP ID, deposit, URL, description, expiry time, proposal data.",
          ],
          Self::ProposalStateUpdated(_, _, _) => {
            &["Triggered each time the state of a proposal is amended"]
          }
          Self::Voted(_, _, _, _, _) => {
            &["`AccountId` voted `bool` on the proposal referenced by `PipId`"]
          }
          Self::PipClosed(_, _, _) => {
            &["Pip has been closed, bool indicates whether data is pruned"]
          }
          Self::ExecutionScheduled(_, _, _) => {
            &["Execution of a PIP has been scheduled at specific block."]
          }
          Self::DefaultEnactmentPeriodChanged(_, _, _) => &[
            "Default enactment period (in blocks) has been changed.",
            "(caller DID, old period, new period)",
          ],
          Self::MinimumProposalDepositChanged(_, _, _) => &[
            "Minimum deposit amount modified",
            "(caller DID, old amount, new amount)",
          ],
          Self::PendingPipExpiryChanged(_, _, _) => &[
            "Amount of blocks after which a pending PIP expires.",
            "(caller DID, old expiry, new expiry)",
          ],
          Self::MaxPipSkipCountChanged(_, _, _) => &[
            "The maximum times a PIP can be skipped was changed.",
            "(caller DID, old value, new value)",
          ],
          Self::ActivePipLimitChanged(_, _, _) => &[
            "The maximum number of active PIPs was changed.",
            "(caller DID, old value, new value)",
          ],
          Self::ProposalRefund(_, _, _) => &["Refund proposal", "(id, total amount)"],
          Self::SnapshotCleared(_, _) => &["The snapshot was cleared."],
          Self::SnapshotTaken(_, _, _) => &["A new snapshot was taken."],
          Self::PipSkipped(_, _, _) => &[
            "A PIP in the snapshot queue was skipped.",
            "(gc_did, pip_id, new_skip_count)",
          ],
          Self::SnapshotResultsEnacted(_, _, _, _, _) => &[
            "Results (e.g., approved, rejected, and skipped), were enacted for some PIPs.",
            "(gc_did, snapshot_id_opt, skipped_pips_with_new_count, rejected_pips, approved_pips)",
          ],
          Self::ExecutionSchedulingFailed(_, _, _) => {
            &["Scheduling of the PIP for execution failed in the scheduler pallet."]
          }
          Self::ExpiryScheduled(_, _, _) => &["The PIP has been scheduled for expiry."],
          Self::ExpirySchedulingFailed(_, _, _) => {
            &["Scheduling of the PIP for expiry failed in the scheduler pallet."]
          }
          Self::ExecutionCancellingFailed(_) => {
            &["Cancelling the PIP execution failed in the scheduler pallet."]
          }
          _ => &[""],
        }
      }
    }
    impl<AccountId, BlockNumber> From<PipsEvent<AccountId, BlockNumber>> for &'static str {
      fn from(v: PipsEvent<AccountId, BlockNumber>) -> Self {
        v.as_static_str()
      }
    }
    impl<AccountId, BlockNumber> From<&PipsEvent<AccountId, BlockNumber>> for &'static str {
      fn from(v: &PipsEvent<AccountId, BlockNumber>) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct SnapshotId(pub u32);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct SnapshotMetadata<BlockNumber, AccountId> {
      pub created_at: BlockNumber,
      pub made_by: AccountId,
      pub id: pallet_pips::SnapshotId,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum SnapshotResult {
      #[codec(index = 0u8)]
      Approve,
      #[codec(index = 1u8)]
      Reject,
      #[codec(index = 2u8)]
      Skip,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct SnapshottedPip {
      pub id: pallet_pips::PipId,
      pub weight: (bool, u128),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Vote(pub bool, pub u128);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct VotingResult {
      pub ayes_count: u32,
      pub ayes_stake: u128,
      pub nays_count: u32,
      pub nays_stake: u128,
    }
  }
  pub mod pallet_portfolio {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PortfolioCall {
      #[doc = "Creates a portfolio with the given `name`."]
      #[codec(index = 0u8)]
      create_portfolio {
        name: polymesh_primitives::identity_id::PortfolioName,
      },
      #[doc = "Deletes a user portfolio. A portfolio can be deleted only if it has no funds."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = "* `PortfolioNotEmpty` if the portfolio still holds any asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 1u8)]
      delete_portfolio {
        num: polymesh_primitives::identity_id::PortfolioNumber,
      },
      #[doc = "Renames a non-default portfolio."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 2u8)]
      rename_portfolio {
        num: polymesh_primitives::identity_id::PortfolioNumber,
        to_name: polymesh_primitives::identity_id::PortfolioName,
      },
      #[doc = "When called by the custodian of `portfolio_id`,"]
      #[doc = "allows returning the custody of the portfolio to the portfolio owner unilaterally."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 3u8)]
      quit_portfolio_custody {
        pid: polymesh_primitives::identity_id::PortfolioId,
      },
      #[codec(index = 4u8)]
      accept_portfolio_custody { auth_id: u64 },
      #[doc = "Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same"]
      #[doc = "identity. Must be called by the custodian of the sender."]
      #[doc = "Funds from deleted portfolios can also be recovered via this method."]
      #[doc = ""]
      #[doc = "A short memo can be added to to each token amount moved."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio."]
      #[doc = "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same"]
      #[doc = "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio"]
      #[doc = "* `InsufficientPortfolioBalance` if the sender does not have enough free balance"]
      #[doc = "* `NoDuplicateAssetsAllowed` the same asset can't be repeated in the items vector."]
      #[doc = "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own."]
      #[doc = "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 5u8)]
      move_portfolio_funds {
        from: polymesh_primitives::identity_id::PortfolioId,
        to: polymesh_primitives::identity_id::PortfolioId,
        funds: ::alloc::vec::Vec<polymesh_primitives::portfolio::Fund>,
      },
      #[doc = "Pre-approves the receivement of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 6u8)]
      pre_approve_portfolio {
        asset_id: ::polymesh_api_client::AssetId,
        portfolio_id: polymesh_primitives::identity_id::PortfolioId,
      },
      #[doc = "Removes the pre approval of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 7u8)]
      remove_portfolio_pre_approval {
        asset_id: ::polymesh_api_client::AssetId,
        portfolio_id: polymesh_primitives::identity_id::PortfolioId,
      },
      #[doc = "Adds an identity that will be allowed to create and take custody of a portfolio under the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `trusted_identity` - the [`IdentityId`] that will be allowed to call `create_custody_portfolio`."]
      #[doc = ""]
      #[codec(index = 8u8)]
      allow_identity_to_create_portfolios {
        trusted_identity: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Removes permission of an identity to create and take custody of a portfolio under the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `identity` - the [`IdentityId`] that will have the permissions to call `create_custody_portfolio` revoked."]
      #[doc = ""]
      #[codec(index = 9u8)]
      revoke_create_portfolios_permission {
        identity: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Creates a portfolio under the `portfolio_owner_id` identity and transfers its custody to the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `portfolio_owner_id` - the [`IdentityId`] that will own the new portfolio."]
      #[doc = "* `portfolio_name` - the [`PortfolioName`] of the new portfolio."]
      #[doc = ""]
      #[codec(index = 10u8)]
      create_custody_portfolio {
        portfolio_owner_id: ::polymesh_api_client::IdentityId,
        portfolio_name: polymesh_primitives::identity_id::PortfolioName,
      },
    }
    impl PortfolioCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_portfolio { .. } => "Portfolio.create_portfolio",
          Self::delete_portfolio { .. } => "Portfolio.delete_portfolio",
          Self::rename_portfolio { .. } => "Portfolio.rename_portfolio",
          Self::quit_portfolio_custody { .. } => "Portfolio.quit_portfolio_custody",
          Self::accept_portfolio_custody { .. } => "Portfolio.accept_portfolio_custody",
          Self::move_portfolio_funds { .. } => "Portfolio.move_portfolio_funds",
          Self::pre_approve_portfolio { .. } => "Portfolio.pre_approve_portfolio",
          Self::remove_portfolio_pre_approval { .. } => "Portfolio.remove_portfolio_pre_approval",
          Self::allow_identity_to_create_portfolios { .. } => {
            "Portfolio.allow_identity_to_create_portfolios"
          }
          Self::revoke_create_portfolios_permission { .. } => {
            "Portfolio.revoke_create_portfolios_permission"
          }
          Self::create_custody_portfolio { .. } => "Portfolio.create_custody_portfolio",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PortfolioCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: create_portfolio { .. } => { & ["Creates a portfolio with the given `name`." ,] } , Self :: delete_portfolio { .. } => { & ["Deletes a user portfolio. A portfolio can be deleted only if it has no funds." , "" , "# Errors" , "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio." , "* `PortfolioNotEmpty` if the portfolio still holds any asset" , "" , "# Permissions" , "* Portfolio" ,] } , Self :: rename_portfolio { .. } => { & ["Renames a non-default portfolio." , "" , "# Errors" , "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: quit_portfolio_custody { .. } => { & ["When called by the custodian of `portfolio_id`," , "allows returning the custody of the portfolio to the portfolio owner unilaterally." , "" , "# Errors" , "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: accept_portfolio_custody { .. } => { & ["" ,] } , Self :: move_portfolio_funds { .. } => { & ["Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same" , "identity. Must be called by the custodian of the sender." , "Funds from deleted portfolios can also be recovered via this method." , "" , "A short memo can be added to to each token amount moved." , "" , "# Errors" , "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio." , "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same" , "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities" , "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio" , "* `InsufficientPortfolioBalance` if the sender does not have enough free balance" , "* `NoDuplicateAssetsAllowed` the same asset can't be repeated in the items vector." , "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own." , "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: pre_approve_portfolio { .. } => { & ["Pre-approves the receivement of an asset to a portfolio." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `asset_id` - the [`AssetId`] that will be exempt from affirmation." , "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: remove_portfolio_pre_approval { .. } => { & ["Removes the pre approval of an asset to a portfolio." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `asset_id` - the [`AssetId`] that will be exempt from affirmation." , "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: allow_identity_to_create_portfolios { .. } => { & ["Adds an identity that will be allowed to create and take custody of a portfolio under the caller's identity." , "" , "# Arguments" , "* `trusted_identity` - the [`IdentityId`] that will be allowed to call `create_custody_portfolio`." , "" ,] } , Self :: revoke_create_portfolios_permission { .. } => { & ["Removes permission of an identity to create and take custody of a portfolio under the caller's identity." , "" , "# Arguments" , "* `identity` - the [`IdentityId`] that will have the permissions to call `create_custody_portfolio` revoked." , "" ,] } , Self :: create_custody_portfolio { .. } => { & ["Creates a portfolio under the `portfolio_owner_id` identity and transfers its custody to the caller's identity." , "" , "# Arguments" , "* `portfolio_owner_id` - the [`IdentityId`] that will own the new portfolio." , "* `portfolio_name` - the [`PortfolioName`] of the new portfolio." , "" ,] } , _ => & [""] , }
      }
    }
    impl From<PortfolioCall> for &'static str {
      fn from(v: PortfolioCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PortfolioCall> for &'static str {
      fn from(v: &PortfolioCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PortfolioError {
      #[doc = "The portfolio doesn't exist."]
      #[codec(index = 0u8)]
      PortfolioDoesNotExist,
      #[doc = "Insufficient balance for a transaction."]
      #[codec(index = 1u8)]
      InsufficientPortfolioBalance,
      #[doc = "The source and destination portfolios should be different."]
      #[codec(index = 2u8)]
      DestinationIsSamePortfolio,
      #[doc = "The portfolio couldn't be renamed because the chosen name is already in use."]
      #[codec(index = 3u8)]
      PortfolioNameAlreadyInUse,
      #[doc = "The secondary key is not authorized to access the portfolio(s)."]
      #[codec(index = 4u8)]
      SecondaryKeyNotAuthorizedForPortfolio,
      #[doc = "The porfolio's custody is with someone other than the caller."]
      #[codec(index = 5u8)]
      UnauthorizedCustodian,
      #[doc = "Can not unlock more tokens than what are locked"]
      #[codec(index = 6u8)]
      InsufficientTokensLocked,
      #[doc = "The portfolio still has some asset balance left"]
      #[codec(index = 7u8)]
      PortfolioNotEmpty,
      #[doc = "The portfolios belong to different identities"]
      #[codec(index = 8u8)]
      DifferentIdentityPortfolios,
      #[doc = "Duplicate asset among the items."]
      #[codec(index = 9u8)]
      NoDuplicateAssetsAllowed,
      #[doc = "The NFT does not exist in the portfolio."]
      #[codec(index = 10u8)]
      NFTNotFoundInPortfolio,
      #[doc = "The NFT is already locked."]
      #[codec(index = 11u8)]
      NFTAlreadyLocked,
      #[doc = "The NFT has never been locked."]
      #[codec(index = 12u8)]
      NFTNotLocked,
      #[doc = "Only owned NFTs can be moved between portfolios."]
      #[codec(index = 13u8)]
      InvalidTransferNFTNotOwned,
      #[doc = "Locked NFTs can not be moved between portfolios."]
      #[codec(index = 14u8)]
      InvalidTransferNFTIsLocked,
      #[doc = "Trying to move an amount of zero assets."]
      #[codec(index = 15u8)]
      EmptyTransfer,
      #[doc = "The caller doesn't have permission to create portfolios on the owner's behalf."]
      #[codec(index = 16u8)]
      MissingOwnersPermission,
      #[doc = "The sender identity can't be the same as the receiver identity."]
      #[codec(index = 17u8)]
      InvalidTransferSenderIdMatchesReceiverId,
      #[doc = "Adding itself as an AllowedCustodian is not permitted."]
      #[codec(index = 18u8)]
      SelfAdditionNotAllowed,
    }
    impl PortfolioError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::PortfolioDoesNotExist => "Portfolio.PortfolioDoesNotExist",
          Self::InsufficientPortfolioBalance => "Portfolio.InsufficientPortfolioBalance",
          Self::DestinationIsSamePortfolio => "Portfolio.DestinationIsSamePortfolio",
          Self::PortfolioNameAlreadyInUse => "Portfolio.PortfolioNameAlreadyInUse",
          Self::SecondaryKeyNotAuthorizedForPortfolio => {
            "Portfolio.SecondaryKeyNotAuthorizedForPortfolio"
          }
          Self::UnauthorizedCustodian => "Portfolio.UnauthorizedCustodian",
          Self::InsufficientTokensLocked => "Portfolio.InsufficientTokensLocked",
          Self::PortfolioNotEmpty => "Portfolio.PortfolioNotEmpty",
          Self::DifferentIdentityPortfolios => "Portfolio.DifferentIdentityPortfolios",
          Self::NoDuplicateAssetsAllowed => "Portfolio.NoDuplicateAssetsAllowed",
          Self::NFTNotFoundInPortfolio => "Portfolio.NFTNotFoundInPortfolio",
          Self::NFTAlreadyLocked => "Portfolio.NFTAlreadyLocked",
          Self::NFTNotLocked => "Portfolio.NFTNotLocked",
          Self::InvalidTransferNFTNotOwned => "Portfolio.InvalidTransferNFTNotOwned",
          Self::InvalidTransferNFTIsLocked => "Portfolio.InvalidTransferNFTIsLocked",
          Self::EmptyTransfer => "Portfolio.EmptyTransfer",
          Self::MissingOwnersPermission => "Portfolio.MissingOwnersPermission",
          Self::InvalidTransferSenderIdMatchesReceiverId => {
            "Portfolio.InvalidTransferSenderIdMatchesReceiverId"
          }
          Self::SelfAdditionNotAllowed => "Portfolio.SelfAdditionNotAllowed",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PortfolioError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::PortfolioDoesNotExist => &["The portfolio doesn't exist."],
          Self::InsufficientPortfolioBalance => &["Insufficient balance for a transaction."],
          Self::DestinationIsSamePortfolio => {
            &["The source and destination portfolios should be different."]
          }
          Self::PortfolioNameAlreadyInUse => {
            &["The portfolio couldn't be renamed because the chosen name is already in use."]
          }
          Self::SecondaryKeyNotAuthorizedForPortfolio => {
            &["The secondary key is not authorized to access the portfolio(s)."]
          }
          Self::UnauthorizedCustodian => {
            &["The porfolio's custody is with someone other than the caller."]
          }
          Self::InsufficientTokensLocked => &["Can not unlock more tokens than what are locked"],
          Self::PortfolioNotEmpty => &["The portfolio still has some asset balance left"],
          Self::DifferentIdentityPortfolios => &["The portfolios belong to different identities"],
          Self::NoDuplicateAssetsAllowed => &["Duplicate asset among the items."],
          Self::NFTNotFoundInPortfolio => &["The NFT does not exist in the portfolio."],
          Self::NFTAlreadyLocked => &["The NFT is already locked."],
          Self::NFTNotLocked => &["The NFT has never been locked."],
          Self::InvalidTransferNFTNotOwned => &["Only owned NFTs can be moved between portfolios."],
          Self::InvalidTransferNFTIsLocked => &["Locked NFTs can not be moved between portfolios."],
          Self::EmptyTransfer => &["Trying to move an amount of zero assets."],
          Self::MissingOwnersPermission => {
            &["The caller doesn't have permission to create portfolios on the owner's behalf."]
          }
          Self::InvalidTransferSenderIdMatchesReceiverId => {
            &["The sender identity can't be the same as the receiver identity."]
          }
          Self::SelfAdditionNotAllowed => {
            &["Adding itself as an AllowedCustodian is not permitted."]
          }
          _ => &[""],
        }
      }
    }
    impl From<PortfolioError> for &'static str {
      fn from(v: PortfolioError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PortfolioError> for &'static str {
      fn from(v: &PortfolioError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_preimage {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PreimageCall {
        #[doc = "Register a preimage on-chain."]
        #[doc = ""]
        #[doc = "If the preimage was previously requested, no fees or deposits are taken for providing"]
        #[doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."]
        #[codec(index = 0u8)]
        note_preimage { bytes: ::alloc::vec::Vec<u8> },
        #[doc = "Clear an unrequested preimage from the runtime storage."]
        #[doc = ""]
        #[doc = "If `len` is provided, then it will be a much cheaper operation."]
        #[doc = ""]
        #[doc = "- `hash`: The hash of the preimage to be removed from the store."]
        #[doc = "- `len`: The length of the preimage of `hash`."]
        #[codec(index = 1u8)]
        unnote_preimage { hash: primitive_types::H256 },
        #[doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."]
        #[doc = ""]
        #[doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"]
        #[doc = "a user may have paid, and take the control of the preimage out of their hands."]
        #[codec(index = 2u8)]
        request_preimage { hash: primitive_types::H256 },
        #[doc = "Clear a previously made request for a preimage."]
        #[doc = ""]
        #[doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."]
        #[codec(index = 3u8)]
        unrequest_preimage { hash: primitive_types::H256 },
      }
      impl PreimageCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::note_preimage { .. } => "Preimage.note_preimage",
            Self::unnote_preimage { .. } => "Preimage.unnote_preimage",
            Self::request_preimage { .. } => "Preimage.request_preimage",
            Self::unrequest_preimage { .. } => "Preimage.unrequest_preimage",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for PreimageCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: note_preimage { .. } => { & ["Register a preimage on-chain." , "" , "If the preimage was previously requested, no fees or deposits are taken for providing" , "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage." ,] } , Self :: unnote_preimage { .. } => { & ["Clear an unrequested preimage from the runtime storage." , "" , "If `len` is provided, then it will be a much cheaper operation." , "" , "- `hash`: The hash of the preimage to be removed from the store." , "- `len`: The length of the preimage of `hash`." ,] } , Self :: request_preimage { .. } => { & ["Request a preimage be uploaded to the chain without paying any fees or deposits." , "" , "If the preimage requests has already been provided on-chain, we unreserve any deposit" , "a user may have paid, and take the control of the preimage out of their hands." ,] } , Self :: unrequest_preimage { .. } => { & ["Clear a previously made request for a preimage." , "" , "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`." ,] } , _ => & [""] , }
        }
      }
      impl From<PreimageCall> for &'static str {
        fn from(v: PreimageCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&PreimageCall> for &'static str {
        fn from(v: &PreimageCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PreimageError {
        #[doc = "Preimage is too large to store on-chain."]
        #[codec(index = 0u8)]
        TooBig,
        #[doc = "Preimage has already been noted on-chain."]
        #[codec(index = 1u8)]
        AlreadyNoted,
        #[doc = "The user is not authorized to perform this action."]
        #[codec(index = 2u8)]
        NotAuthorized,
        #[doc = "The preimage cannot be removed since it has not yet been noted."]
        #[codec(index = 3u8)]
        NotNoted,
        #[doc = "A preimage may not be removed when there are outstanding requests."]
        #[codec(index = 4u8)]
        Requested,
        #[doc = "The preimage request cannot be removed since no outstanding requests exist."]
        #[codec(index = 5u8)]
        NotRequested,
      }
      impl PreimageError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::TooBig => "Preimage.TooBig",
            Self::AlreadyNoted => "Preimage.AlreadyNoted",
            Self::NotAuthorized => "Preimage.NotAuthorized",
            Self::NotNoted => "Preimage.NotNoted",
            Self::Requested => "Preimage.Requested",
            Self::NotRequested => "Preimage.NotRequested",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for PreimageError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::TooBig => &["Preimage is too large to store on-chain."],
            Self::AlreadyNoted => &["Preimage has already been noted on-chain."],
            Self::NotAuthorized => &["The user is not authorized to perform this action."],
            Self::NotNoted => &["The preimage cannot be removed since it has not yet been noted."],
            Self::Requested => {
              &["A preimage may not be removed when there are outstanding requests."]
            }
            Self::NotRequested => {
              &["The preimage request cannot be removed since no outstanding requests exist."]
            }
            _ => &[""],
          }
        }
      }
      impl From<PreimageError> for &'static str {
        fn from(v: PreimageError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&PreimageError> for &'static str {
        fn from(v: &PreimageError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PreimageEvent {
        #[doc = "A preimage has been noted."]
        #[codec(index = 0u8)]
        Noted { hash: primitive_types::H256 },
        #[doc = "A preimage has been requested."]
        #[codec(index = 1u8)]
        Requested { hash: primitive_types::H256 },
        #[doc = "A preimage has ben cleared."]
        #[codec(index = 2u8)]
        Cleared { hash: primitive_types::H256 },
      }
      impl PreimageEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Noted { .. } => "Preimage.Noted",
            Self::Requested { .. } => "Preimage.Requested",
            Self::Cleared { .. } => "Preimage.Cleared",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for PreimageEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::Noted { .. } => &["A preimage has been noted."],
            Self::Requested { .. } => &["A preimage has been requested."],
            Self::Cleared { .. } => &["A preimage has ben cleared."],
            _ => &[""],
          }
        }
      }
      impl From<PreimageEvent> for &'static str {
        fn from(v: PreimageEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&PreimageEvent> for &'static str {
        fn from(v: &PreimageEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RequestStatus<AccountId, Balance> {
      #[codec(index = 0u8)]
      Unrequested {
        deposit: (AccountId, Balance),
        len: u32,
      },
      #[codec(index = 1u8)]
      Requested {
        deposit: Option<(AccountId, Balance)>,
        count: u32,
        len: Option<u32>,
      },
    }
  }
  pub mod pallet_protocol_fee {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ProtocolFeeCall {
      #[doc = "Changes the fee coefficient for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[codec(index = 0u8)]
      change_coefficient {
        coefficient: polymesh_primitives::PosRatio,
      },
      #[doc = "Changes the a base fee for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[codec(index = 1u8)]
      change_base_fee {
        op: polymesh_common_utilities::protocol_fee::ProtocolOp,
        base_fee: u128,
      },
    }
    impl ProtocolFeeCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::change_coefficient { .. } => "ProtocolFee.change_coefficient",
          Self::change_base_fee { .. } => "ProtocolFee.change_base_fee",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ProtocolFeeCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::change_coefficient { .. } => &[
            "Changes the fee coefficient for the root origin.",
            "",
            "# Errors",
            "* `BadOrigin` - Only root allowed.",
          ],
          Self::change_base_fee { .. } => &[
            "Changes the a base fee for the root origin.",
            "",
            "# Errors",
            "* `BadOrigin` - Only root allowed.",
          ],
          _ => &[""],
        }
      }
    }
    impl From<ProtocolFeeCall> for &'static str {
      fn from(v: ProtocolFeeCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ProtocolFeeCall> for &'static str {
      fn from(v: &ProtocolFeeCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ProtocolFeeError {
      #[doc = "Insufficient account balance to pay the fee."]
      #[codec(index = 0u8)]
      InsufficientAccountBalance,
      #[doc = "Not able to handled the imbalances"]
      #[codec(index = 1u8)]
      UnHandledImbalances,
      #[doc = "Insufficient subsidy balance to pay the fee."]
      #[codec(index = 2u8)]
      InsufficientSubsidyBalance,
    }
    impl ProtocolFeeError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::InsufficientAccountBalance => "ProtocolFee.InsufficientAccountBalance",
          Self::UnHandledImbalances => "ProtocolFee.UnHandledImbalances",
          Self::InsufficientSubsidyBalance => "ProtocolFee.InsufficientSubsidyBalance",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ProtocolFeeError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::InsufficientAccountBalance => &["Insufficient account balance to pay the fee."],
          Self::UnHandledImbalances => &["Not able to handled the imbalances"],
          Self::InsufficientSubsidyBalance => &["Insufficient subsidy balance to pay the fee."],
          _ => &[""],
        }
      }
    }
    impl From<ProtocolFeeError> for &'static str {
      fn from(v: ProtocolFeeError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ProtocolFeeError> for &'static str {
      fn from(v: &ProtocolFeeError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ProtocolFeeEvent<AccountId> {
      #[doc = "The protocol fee of an operation."]
      #[codec(index = 0u8)]
      FeeSet(::polymesh_api_client::IdentityId, u128),
      #[doc = "The fee coefficient."]
      #[codec(index = 1u8)]
      CoefficientSet(
        ::polymesh_api_client::IdentityId,
        polymesh_primitives::PosRatio,
      ),
      #[doc = "Fee charged."]
      #[codec(index = 2u8)]
      FeeCharged(AccountId, u128),
    }
    impl<AccountId> ProtocolFeeEvent<AccountId> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::FeeSet(_, _) => "ProtocolFee.FeeSet",
          Self::CoefficientSet(_, _) => "ProtocolFee.CoefficientSet",
          Self::FeeCharged(_, _) => "ProtocolFee.FeeCharged",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<AccountId> ::polymesh_api_client::EnumInfo for ProtocolFeeEvent<AccountId> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::FeeSet(_, _) => &["The protocol fee of an operation."],
          Self::CoefficientSet(_, _) => &["The fee coefficient."],
          Self::FeeCharged(_, _) => &["Fee charged."],
          _ => &[""],
        }
      }
    }
    impl<AccountId> From<ProtocolFeeEvent<AccountId>> for &'static str {
      fn from(v: ProtocolFeeEvent<AccountId>) -> Self {
        v.as_static_str()
      }
    }
    impl<AccountId> From<&ProtocolFeeEvent<AccountId>> for &'static str {
      fn from(v: &ProtocolFeeEvent<AccountId>) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_relayer {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RelayerCall {
      #[doc = "Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to subsidise."]
      #[doc = "- `polyx_limit` the initial POLYX limit for this subsidy."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[codec(index = 0u8)]
      set_paying_key {
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      },
      #[doc = "Accepts a `paying_key` authorization."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` the authorization id to accept a `paying_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` the authorization has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not a `AddRelayerPayingKey` authorization."]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`."]
      #[doc = "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity."]
      #[doc = "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity."]
      #[doc = "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[codec(index = 1u8)]
      accept_paying_key { auth_id: u64 },
      #[doc = "Removes the `paying_key` from a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to remove the subsidy from."]
      #[doc = "- `paying_key` the paying key that was subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`."]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[codec(index = 2u8)]
      remove_paying_key {
        user_key: ::polymesh_api_client::AccountId,
        paying_key: ::polymesh_api_client::AccountId,
      },
      #[doc = "Updates the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[codec(index = 3u8)]
      update_polyx_limit {
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      },
      #[doc = "Increase the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to add to the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`."]
      #[codec(index = 4u8)]
      increase_polyx_limit {
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      },
      #[doc = "Decrease the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to remove from the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy has less then `amount` POLYX remaining."]
      #[codec(index = 5u8)]
      decrease_polyx_limit {
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      },
    }
    impl RelayerCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_paying_key { .. } => "Relayer.set_paying_key",
          Self::accept_paying_key { .. } => "Relayer.accept_paying_key",
          Self::remove_paying_key { .. } => "Relayer.remove_paying_key",
          Self::update_polyx_limit { .. } => "Relayer.update_polyx_limit",
          Self::increase_polyx_limit { .. } => "Relayer.increase_polyx_limit",
          Self::decrease_polyx_limit { .. } => "Relayer.decrease_polyx_limit",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for RelayerCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_paying_key { .. } => { & ["Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser." , "" , "# Arguments" , "- `user_key` the user key to subsidise." , "- `polyx_limit` the initial POLYX limit for this subsidy." , "" , "# Errors" , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: accept_paying_key { .. } => { & ["Accepts a `paying_key` authorization." , "" , "# Arguments" , "- `auth_id` the authorization id to accept a `paying_key`." , "" , "# Errors" , "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller." , "- `AuthorizationError::Expired` if `auth_id` the authorization has expired." , "- `AuthorizationError::BadType` if `auth_id` was not a `AddRelayerPayingKey` authorization." , "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`." , "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity." , "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity." , "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: remove_paying_key { .. } => { & ["Removes the `paying_key` from a `user_key`." , "" , "# Arguments" , "- `user_key` the user key to remove the subsidy from." , "- `paying_key` the paying key that was subsidising the `user_key`." , "" , "# Errors" , "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`." , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: update_polyx_limit { .. } => { & ["Updates the available POLYX for a `user_key`." , "" , "# Arguments" , "- `user_key` the user key of the subsidy to update the available POLYX." , "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`." , "" , "# Errors" , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if `origin` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: increase_polyx_limit { .. } => { & ["Increase the available POLYX for a `user_key`." , "" , "# Arguments" , "- `user_key` the user key of the subsidy to update the available POLYX." , "- `amount` the amount of POLYX to add to the subsidy of `user_key`." , "" , "# Errors" , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if `origin` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." , "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`." ,] } , Self :: decrease_polyx_limit { .. } => { & ["Decrease the available POLYX for a `user_key`." , "" , "# Arguments" , "- `user_key` the user key of the subsidy to update the available POLYX." , "- `amount` the amount of POLYX to remove from the subsidy of `user_key`." , "" , "# Errors" , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if `origin` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." , "- `Overlow` if the subsidy has less then `amount` POLYX remaining." ,] } , _ => & [""] , }
      }
    }
    impl From<RelayerCall> for &'static str {
      fn from(v: RelayerCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&RelayerCall> for &'static str {
      fn from(v: &RelayerCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RelayerError {
      #[doc = "The `user_key` is not attached to a CDD'd identity."]
      #[codec(index = 0u8)]
      UserKeyCddMissing,
      #[doc = "The `user_key` is not attached to a CDD'd identity."]
      #[codec(index = 1u8)]
      PayingKeyCddMissing,
      #[doc = "The `user_key` doesn't have a `paying_key`."]
      #[codec(index = 2u8)]
      NoPayingKey,
      #[doc = "The `user_key` has a different `paying_key`."]
      #[codec(index = 3u8)]
      NotPayingKey,
      #[doc = "The signer is not authorized for `paying_key`."]
      #[codec(index = 4u8)]
      NotAuthorizedForPayingKey,
      #[doc = "The signer is not authorized for `user_key`."]
      #[codec(index = 5u8)]
      NotAuthorizedForUserKey,
      #[doc = "The remaining POLYX for `user_key` overflowed."]
      #[codec(index = 6u8)]
      Overflow,
    }
    impl RelayerError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::UserKeyCddMissing => "Relayer.UserKeyCddMissing",
          Self::PayingKeyCddMissing => "Relayer.PayingKeyCddMissing",
          Self::NoPayingKey => "Relayer.NoPayingKey",
          Self::NotPayingKey => "Relayer.NotPayingKey",
          Self::NotAuthorizedForPayingKey => "Relayer.NotAuthorizedForPayingKey",
          Self::NotAuthorizedForUserKey => "Relayer.NotAuthorizedForUserKey",
          Self::Overflow => "Relayer.Overflow",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for RelayerError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::UserKeyCddMissing => &["The `user_key` is not attached to a CDD'd identity."],
          Self::PayingKeyCddMissing => &["The `user_key` is not attached to a CDD'd identity."],
          Self::NoPayingKey => &["The `user_key` doesn't have a `paying_key`."],
          Self::NotPayingKey => &["The `user_key` has a different `paying_key`."],
          Self::NotAuthorizedForPayingKey => &["The signer is not authorized for `paying_key`."],
          Self::NotAuthorizedForUserKey => &["The signer is not authorized for `user_key`."],
          Self::Overflow => &["The remaining POLYX for `user_key` overflowed."],
          _ => &[""],
        }
      }
    }
    impl From<RelayerError> for &'static str {
      fn from(v: RelayerError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&RelayerError> for &'static str {
      fn from(v: &RelayerError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Subsidy<Acc> {
      pub paying_key: Acc,
      pub remaining: u128,
    }
  }
  pub mod pallet_scheduler {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SchedulerCall {
        #[doc = "Anonymously schedule a task."]
        #[codec(index = 0u8)]
        schedule {
          when: u32,
          maybe_periodic: Option<(u32, u32)>,
          priority: u8,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
        #[doc = "Cancel an anonymously scheduled task."]
        #[codec(index = 1u8)]
        cancel { when: u32, index: u32 },
        #[doc = "Schedule a named task."]
        #[codec(index = 2u8)]
        schedule_named {
          id: [u8; 32usize],
          when: u32,
          maybe_periodic: Option<(u32, u32)>,
          priority: u8,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
        #[doc = "Cancel a named scheduled task."]
        #[codec(index = 3u8)]
        cancel_named { id: [u8; 32usize] },
        #[doc = "Anonymously schedule a task after a delay."]
        #[codec(index = 4u8)]
        schedule_after {
          after: u32,
          maybe_periodic: Option<(u32, u32)>,
          priority: u8,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
        #[doc = "Schedule a named task after a delay."]
        #[codec(index = 5u8)]
        schedule_named_after {
          id: [u8; 32usize],
          after: u32,
          maybe_periodic: Option<(u32, u32)>,
          priority: u8,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
      }
      impl SchedulerCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::schedule { .. } => "Scheduler.schedule",
            Self::cancel { .. } => "Scheduler.cancel",
            Self::schedule_named { .. } => "Scheduler.schedule_named",
            Self::cancel_named { .. } => "Scheduler.cancel_named",
            Self::schedule_after { .. } => "Scheduler.schedule_after",
            Self::schedule_named_after { .. } => "Scheduler.schedule_named_after",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SchedulerCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::schedule { .. } => &["Anonymously schedule a task."],
            Self::cancel { .. } => &["Cancel an anonymously scheduled task."],
            Self::schedule_named { .. } => &["Schedule a named task."],
            Self::cancel_named { .. } => &["Cancel a named scheduled task."],
            Self::schedule_after { .. } => &["Anonymously schedule a task after a delay."],
            Self::schedule_named_after { .. } => &["Schedule a named task after a delay."],
            _ => &[""],
          }
        }
      }
      impl From<SchedulerCall> for &'static str {
        fn from(v: SchedulerCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SchedulerCall> for &'static str {
        fn from(v: &SchedulerCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SchedulerError {
        #[doc = "Failed to schedule a call"]
        #[codec(index = 0u8)]
        FailedToSchedule,
        #[doc = "Cannot find the scheduled call."]
        #[codec(index = 1u8)]
        NotFound,
        #[doc = "Given target block number is in the past."]
        #[codec(index = 2u8)]
        TargetBlockNumberInPast,
        #[doc = "Reschedule failed because it does not change scheduled time."]
        #[codec(index = 3u8)]
        RescheduleNoChange,
        #[doc = "Attempt to use a non-named function on a named task."]
        #[codec(index = 4u8)]
        Named,
      }
      impl SchedulerError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::FailedToSchedule => "Scheduler.FailedToSchedule",
            Self::NotFound => "Scheduler.NotFound",
            Self::TargetBlockNumberInPast => "Scheduler.TargetBlockNumberInPast",
            Self::RescheduleNoChange => "Scheduler.RescheduleNoChange",
            Self::Named => "Scheduler.Named",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SchedulerError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::FailedToSchedule => &["Failed to schedule a call"],
            Self::NotFound => &["Cannot find the scheduled call."],
            Self::TargetBlockNumberInPast => &["Given target block number is in the past."],
            Self::RescheduleNoChange => {
              &["Reschedule failed because it does not change scheduled time."]
            }
            Self::Named => &["Attempt to use a non-named function on a named task."],
            _ => &[""],
          }
        }
      }
      impl From<SchedulerError> for &'static str {
        fn from(v: SchedulerError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SchedulerError> for &'static str {
        fn from(v: &SchedulerError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Events type."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SchedulerEvent {
        #[doc = "Scheduled some task."]
        #[codec(index = 0u8)]
        Scheduled { when: u32, index: u32 },
        #[doc = "Canceled some task."]
        #[codec(index = 1u8)]
        Canceled { when: u32, index: u32 },
        #[doc = "Dispatched some task."]
        #[codec(index = 2u8)]
        Dispatched {
          task: (u32, u32),
          id: Option<[u8; 32usize]>,
          result: Result<(), sp_runtime::DispatchError>,
        },
        #[doc = "The call for the provided hash was not found so the task has been aborted."]
        #[codec(index = 3u8)]
        CallUnavailable {
          task: (u32, u32),
          id: Option<[u8; 32usize]>,
        },
        #[doc = "The given task was unable to be renewed since the agenda is full at that block."]
        #[codec(index = 4u8)]
        PeriodicFailed {
          task: (u32, u32),
          id: Option<[u8; 32usize]>,
        },
        #[doc = "The given task can never be executed since it is overweight."]
        #[codec(index = 5u8)]
        PermanentlyOverweight {
          task: (u32, u32),
          id: Option<[u8; 32usize]>,
        },
      }
      impl SchedulerEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Scheduled { .. } => "Scheduler.Scheduled",
            Self::Canceled { .. } => "Scheduler.Canceled",
            Self::Dispatched { .. } => "Scheduler.Dispatched",
            Self::CallUnavailable { .. } => "Scheduler.CallUnavailable",
            Self::PeriodicFailed { .. } => "Scheduler.PeriodicFailed",
            Self::PermanentlyOverweight { .. } => "Scheduler.PermanentlyOverweight",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SchedulerEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::Scheduled { .. } => &["Scheduled some task."],
            Self::Canceled { .. } => &["Canceled some task."],
            Self::Dispatched { .. } => &["Dispatched some task."],
            Self::CallUnavailable { .. } => {
              &["The call for the provided hash was not found so the task has been aborted."]
            }
            Self::PeriodicFailed { .. } => {
              &["The given task was unable to be renewed since the agenda is full at that block."]
            }
            Self::PermanentlyOverweight { .. } => {
              &["The given task can never be executed since it is overweight."]
            }
            _ => &[""],
          }
        }
      }
      impl From<SchedulerEvent> for &'static str {
        fn from(v: SchedulerEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SchedulerEvent> for &'static str {
        fn from(v: &SchedulerEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Scheduled<Name, Call, BlockNumber, PalletsOrigin, AccountId> {
      pub maybe_id: Option<Name>,
      pub priority: u8,
      pub call: Call,
      pub maybe_periodic: Option<(BlockNumber, BlockNumber)>,
      pub origin: PalletsOrigin,
      _phantom_data: core::marker::PhantomData<AccountId>,
    }
  }
  pub mod pallet_session {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SessionCall {
        #[doc = "Sets the session key(s) of the function caller to `keys`."]
        #[doc = "Allows an account to set its session key prior to becoming a validator."]
        #[doc = "This doesn't take effect until the next session."]
        #[doc = ""]
        #[doc = "The dispatch origin of this function must be signed."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"]
        #[doc = "  fixed."]
        #[codec(index = 0u8)]
        set_keys {
          keys: runtime::SessionKeys,
          proof: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Removes any session key(s) of the function caller."]
        #[doc = ""]
        #[doc = "This doesn't take effect until the next session."]
        #[doc = ""]
        #[doc = "The dispatch origin of this function must be Signed and the account must be either be"]
        #[doc = "convertible to a validator ID using the chain's typical addressing system (this usually"]
        #[doc = "means being a controller account) or directly convertible into a validator ID (which"]
        #[doc = "usually means being a stash account)."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"]
        #[doc = "  `T::Keys::key_ids()` which is fixed."]
        #[codec(index = 1u8)]
        purge_keys,
      }
      impl SessionCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::set_keys { .. } => "Session.set_keys",
            Self::purge_keys => "Session.purge_keys",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SessionCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: set_keys { .. } => { & ["Sets the session key(s) of the function caller to `keys`." , "Allows an account to set its session key prior to becoming a validator." , "This doesn't take effect until the next session." , "" , "The dispatch origin of this function must be signed." , "" , "## Complexity" , "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is" , "  fixed." ,] } , Self :: purge_keys => { & ["Removes any session key(s) of the function caller." , "" , "This doesn't take effect until the next session." , "" , "The dispatch origin of this function must be Signed and the account must be either be" , "convertible to a validator ID using the chain's typical addressing system (this usually" , "means being a controller account) or directly convertible into a validator ID (which" , "usually means being a stash account)." , "" , "## Complexity" , "- `O(1)` in number of key types. Actual cost depends on the number of length of" , "  `T::Keys::key_ids()` which is fixed." ,] } , _ => & [""] , }
        }
      }
      impl From<SessionCall> for &'static str {
        fn from(v: SessionCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SessionCall> for &'static str {
        fn from(v: &SessionCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Error for the session pallet."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SessionError {
        #[doc = "Invalid ownership proof."]
        #[codec(index = 0u8)]
        InvalidProof,
        #[doc = "No associated validator ID for account."]
        #[codec(index = 1u8)]
        NoAssociatedValidatorId,
        #[doc = "Registered duplicate key."]
        #[codec(index = 2u8)]
        DuplicatedKey,
        #[doc = "No keys are associated with this account."]
        #[codec(index = 3u8)]
        NoKeys,
        #[doc = "Key setting account is not live, so it's impossible to associate keys."]
        #[codec(index = 4u8)]
        NoAccount,
      }
      impl SessionError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidProof => "Session.InvalidProof",
            Self::NoAssociatedValidatorId => "Session.NoAssociatedValidatorId",
            Self::DuplicatedKey => "Session.DuplicatedKey",
            Self::NoKeys => "Session.NoKeys",
            Self::NoAccount => "Session.NoAccount",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SessionError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidProof => &["Invalid ownership proof."],
            Self::NoAssociatedValidatorId => &["No associated validator ID for account."],
            Self::DuplicatedKey => &["Registered duplicate key."],
            Self::NoKeys => &["No keys are associated with this account."],
            Self::NoAccount => {
              &["Key setting account is not live, so it's impossible to associate keys."]
            }
            _ => &[""],
          }
        }
      }
      impl From<SessionError> for &'static str {
        fn from(v: SessionError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SessionError> for &'static str {
        fn from(v: &SessionError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SessionEvent {
        #[doc = "New session has happened. Note that the argument is the session index, not the"]
        #[doc = "block number as the type might suggest."]
        #[codec(index = 0u8)]
        NewSession { session_index: u32 },
      }
      impl SessionEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::NewSession { .. } => "Session.NewSession",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SessionEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::NewSession { .. } => &[
              "New session has happened. Note that the argument is the session index, not the",
              "block number as the type might suggest.",
            ],
            _ => &[""],
          }
        }
      }
      impl From<SessionEvent> for &'static str {
        fn from(v: SessionEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SessionEvent> for &'static str {
        fn from(v: &SessionEvent) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod pallet_settlement {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum SettlementCall {
      #[doc = "Registers a new venue."]
      #[doc = ""]
      #[doc = "* `details` - Extra details about a venue"]
      #[doc = "* `signers` - Array of signers that are allowed to sign receipts for this venue"]
      #[doc = "* `typ` - Type of venue being created"]
      #[codec(index = 0u8)]
      create_venue {
        details: polymesh_primitives::settlement::VenueDetails,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        typ: polymesh_primitives::settlement::VenueType,
      },
      #[doc = "Edit a venue's details."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `details` specifies the updated venue details."]
      #[codec(index = 1u8)]
      update_venue_details {
        id: polymesh_primitives::settlement::VenueId,
        details: polymesh_primitives::settlement::VenueDetails,
      },
      #[doc = "Edit a venue's type."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `type` specifies the new type of the venue."]
      #[codec(index = 2u8)]
      update_venue_type {
        id: polymesh_primitives::settlement::VenueId,
        typ: polymesh_primitives::settlement::VenueType,
      },
      #[doc = "Affirms an instruction using receipts for offchain transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 3u8)]
      affirm_with_receipts {
        id: polymesh_primitives::settlement::InstructionId,
        receipt_details: ::alloc::vec::Vec<
          polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            sp_runtime::MultiSignature,
          >,
        >,
        portfolios: ::alloc::collections::BTreeSet<polymesh_primitives::identity_id::PortfolioId>,
      },
      #[doc = "Enables or disabled venue filtering for a token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `asset_id` - AssetId of the token in question."]
      #[doc = "* `enabled` - Boolean that decides if the filtering should be enabled."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 4u8)]
      set_venue_filtering {
        asset_id: ::polymesh_api_client::AssetId,
        enabled: bool,
      },
      #[doc = "Allows additional venues to create instructions involving an asset."]
      #[doc = ""]
      #[doc = "* `asset_id` - AssetId of the token in question."]
      #[doc = "* `venues` - Array of venues that are allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 5u8)]
      allow_venues {
        asset_id: ::polymesh_api_client::AssetId,
        venues: ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
      },
      #[doc = "Revokes permission given to venues for creating instructions involving a particular asset."]
      #[doc = ""]
      #[doc = "* `asset_id` - AssetId of the token in question."]
      #[doc = "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 6u8)]
      disallow_venues {
        asset_id: ::polymesh_api_client::AssetId,
        venues: ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
      },
      #[doc = "Edit a venue's signers."]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `signers` specifies the signers to add/remove."]
      #[doc = "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false."]
      #[codec(index = 7u8)]
      update_venue_signers {
        id: polymesh_primitives::settlement::VenueId,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        add_signers: bool,
      },
      #[doc = "Manually executes an instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`: The [`InstructionId`] of the instruction to be executed."]
      #[doc = "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction."]
      #[doc = "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]."]
      #[doc = "* `fungible_transfers`: The number of fungible legs in the instruction."]
      #[doc = "* `nfts_transfers`: The number of nfts being transferred in the instruction."]
      #[doc = "* `offchain_transfers`: The number of offchain legs in the instruction."]
      #[doc = "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction."]
      #[doc = "If the `weight_limit` is less than the required amount, the instruction will fail execution."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters."]
      #[codec(index = 8u8)]
      execute_manual_instruction {
        id: polymesh_primitives::settlement::InstructionId,
        portfolio: Option<polymesh_primitives::identity_id::PortfolioId>,
        fungible_transfers: u32,
        nfts_transfers: u32,
        offchain_transfers: u32,
        weight_limit: Option<::polymesh_api_client::sp_weights::Weight>,
      },
      #[doc = "Adds a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The optional [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
      #[codec(index = 9u8)]
      add_instruction {
        venue_id: Option<polymesh_primitives::settlement::VenueId>,
        settlement_type: polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
        instruction_memo: Option<polymesh_primitives::Memo>,
      },
      #[doc = "Adds and affirms a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 10u8)]
      add_and_affirm_instruction {
        venue_id: Option<polymesh_primitives::settlement::VenueId>,
        settlement_type: polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
        portfolios: ::alloc::collections::BTreeSet<polymesh_primitives::identity_id::PortfolioId>,
        instruction_memo: Option<polymesh_primitives::Memo>,
      },
      #[doc = "Provide affirmation to an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 11u8)]
      affirm_instruction {
        id: polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<polymesh_primitives::identity_id::PortfolioId>,
      },
      #[doc = "Withdraw an affirmation for a given instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 12u8)]
      withdraw_affirmation {
        id: polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<polymesh_primitives::identity_id::PortfolioId>,
      },
      #[doc = "Rejects an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
      #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 13u8)]
      reject_instruction {
        id: polymesh_primitives::settlement::InstructionId,
        portfolio: polymesh_primitives::identity_id::PortfolioId,
      },
      #[doc = "Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction."]
      #[codec(index = 14u8)]
      execute_scheduled_instruction {
        id: polymesh_primitives::settlement::InstructionId,
        weight_limit: ::polymesh_api_client::sp_weights::Weight,
      },
      #[doc = "Affirms an instruction using receipts for offchain transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 15u8)]
      affirm_with_receipts_with_count {
        id: polymesh_primitives::settlement::InstructionId,
        receipt_details: ::alloc::vec::Vec<
          polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            sp_runtime::MultiSignature,
          >,
        >,
        portfolios: ::alloc::collections::BTreeSet<polymesh_primitives::identity_id::PortfolioId>,
        number_of_assets: Option<polymesh_primitives::settlement::AffirmationCount>,
      },
      #[doc = "Provide affirmation to an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 16u8)]
      affirm_instruction_with_count {
        id: polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<polymesh_primitives::identity_id::PortfolioId>,
        number_of_assets: Option<polymesh_primitives::settlement::AffirmationCount>,
      },
      #[doc = "Rejects an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
      #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
      #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 17u8)]
      reject_instruction_with_count {
        id: polymesh_primitives::settlement::InstructionId,
        portfolio: polymesh_primitives::identity_id::PortfolioId,
        number_of_assets: Option<polymesh_primitives::settlement::AssetCount>,
      },
      #[doc = "Withdraw an affirmation for a given instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
      #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 18u8)]
      withdraw_affirmation_with_count {
        id: polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<polymesh_primitives::identity_id::PortfolioId>,
        number_of_assets: Option<polymesh_primitives::settlement::AffirmationCount>,
      },
      #[doc = "Adds a new instruction with mediators."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
      #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
      #[codec(index = 19u8)]
      add_instruction_with_mediators {
        venue_id: Option<polymesh_primitives::settlement::VenueId>,
        settlement_type: polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
        instruction_memo: Option<polymesh_primitives::Memo>,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      },
      #[doc = "Adds and affirms a new instruction with mediators."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
      #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 20u8)]
      add_and_affirm_with_mediators {
        venue_id: Option<polymesh_primitives::settlement::VenueId>,
        settlement_type: polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
        portfolios: ::alloc::collections::BTreeSet<polymesh_primitives::identity_id::PortfolioId>,
        instruction_memo: Option<polymesh_primitives::Memo>,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      },
      #[doc = "Affirms the instruction as a mediator - should only be called by mediators, otherwise it will fail."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: The secondary key of the sender."]
      #[doc = "* `instruction_id`: The [`InstructionId`] that will be affirmed by the mediator."]
      #[doc = "* `expiry`: An Optional value for defining when the affirmation will expire (None means it will always be valid)."]
      #[codec(index = 21u8)]
      affirm_instruction_as_mediator {
        instruction_id: polymesh_primitives::settlement::InstructionId,
        expiry: Option<u64>,
      },
      #[doc = "Removes the mediator's affirmation for the instruction - should only be called by mediators, otherwise it will fail."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: The secondary key of the sender."]
      #[doc = "* `instruction_id`: The [`InstructionId`] that will have the affirmation removed."]
      #[codec(index = 22u8)]
      withdraw_affirmation_as_mediator {
        instruction_id: polymesh_primitives::settlement::InstructionId,
      },
      #[doc = "Rejects an existing instruction - should only be called by mediators, otherwise it will fail."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `instruction_id` - the [`InstructionId`] of the instruction being rejected."]
      #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
      #[codec(index = 23u8)]
      reject_instruction_as_mediator {
        instruction_id: polymesh_primitives::settlement::InstructionId,
        number_of_assets: Option<polymesh_primitives::settlement::AssetCount>,
      },
    }
    impl SettlementCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_venue { .. } => "Settlement.create_venue",
          Self::update_venue_details { .. } => "Settlement.update_venue_details",
          Self::update_venue_type { .. } => "Settlement.update_venue_type",
          Self::affirm_with_receipts { .. } => "Settlement.affirm_with_receipts",
          Self::set_venue_filtering { .. } => "Settlement.set_venue_filtering",
          Self::allow_venues { .. } => "Settlement.allow_venues",
          Self::disallow_venues { .. } => "Settlement.disallow_venues",
          Self::update_venue_signers { .. } => "Settlement.update_venue_signers",
          Self::execute_manual_instruction { .. } => "Settlement.execute_manual_instruction",
          Self::add_instruction { .. } => "Settlement.add_instruction",
          Self::add_and_affirm_instruction { .. } => "Settlement.add_and_affirm_instruction",
          Self::affirm_instruction { .. } => "Settlement.affirm_instruction",
          Self::withdraw_affirmation { .. } => "Settlement.withdraw_affirmation",
          Self::reject_instruction { .. } => "Settlement.reject_instruction",
          Self::execute_scheduled_instruction { .. } => "Settlement.execute_scheduled_instruction",
          Self::affirm_with_receipts_with_count { .. } => {
            "Settlement.affirm_with_receipts_with_count"
          }
          Self::affirm_instruction_with_count { .. } => "Settlement.affirm_instruction_with_count",
          Self::reject_instruction_with_count { .. } => "Settlement.reject_instruction_with_count",
          Self::withdraw_affirmation_with_count { .. } => {
            "Settlement.withdraw_affirmation_with_count"
          }
          Self::add_instruction_with_mediators { .. } => {
            "Settlement.add_instruction_with_mediators"
          }
          Self::add_and_affirm_with_mediators { .. } => "Settlement.add_and_affirm_with_mediators",
          Self::affirm_instruction_as_mediator { .. } => {
            "Settlement.affirm_instruction_as_mediator"
          }
          Self::withdraw_affirmation_as_mediator { .. } => {
            "Settlement.withdraw_affirmation_as_mediator"
          }
          Self::reject_instruction_as_mediator { .. } => {
            "Settlement.reject_instruction_as_mediator"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for SettlementCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: create_venue { .. } => { & ["Registers a new venue." , "" , "* `details` - Extra details about a venue" , "* `signers` - Array of signers that are allowed to sign receipts for this venue" , "* `typ` - Type of venue being created" ,] } , Self :: update_venue_details { .. } => { & ["Edit a venue's details." , "" , "* `id` specifies the ID of the venue to edit." , "* `details` specifies the updated venue details." ,] } , Self :: update_venue_type { .. } => { & ["Edit a venue's type." , "" , "* `id` specifies the ID of the venue to edit." , "* `type` specifies the new type of the venue." ,] } , Self :: affirm_with_receipts { .. } => { & ["Affirms an instruction using receipts for offchain transfers." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being affirmed." , "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: set_venue_filtering { .. } => { & ["Enables or disabled venue filtering for a token." , "" , "# Arguments" , "* `asset_id` - AssetId of the token in question." , "* `enabled` - Boolean that decides if the filtering should be enabled." , "" , "# Permissions" , "* Asset" ,] } , Self :: allow_venues { .. } => { & ["Allows additional venues to create instructions involving an asset." , "" , "* `asset_id` - AssetId of the token in question." , "* `venues` - Array of venues that are allowed to create instructions for the token in question." , "" , "# Permissions" , "* Asset" ,] } , Self :: disallow_venues { .. } => { & ["Revokes permission given to venues for creating instructions involving a particular asset." , "" , "* `asset_id` - AssetId of the token in question." , "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question." , "" , "# Permissions" , "* Asset" ,] } , Self :: update_venue_signers { .. } => { & ["Edit a venue's signers." , "* `id` specifies the ID of the venue to edit." , "* `signers` specifies the signers to add/remove." , "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false." ,] } , Self :: execute_manual_instruction { .. } => { & ["Manually executes an instruction." , "" , "# Arguments" , "* `id`: The [`InstructionId`] of the instruction to be executed." , "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction." , "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]." , "* `fungible_transfers`: The number of fungible legs in the instruction." , "* `nfts_transfers`: The number of nfts being transferred in the instruction." , "* `offchain_transfers`: The number of offchain legs in the instruction." , "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction." , "If the `weight_limit` is less than the required amount, the instruction will fail execution." , "" , "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters." ,] } , Self :: add_instruction { .. } => { & ["Adds a new instruction." , "" , "# Arguments" , "* `venue_id`: The optional [`VenueId`] of the venue this instruction belongs to." , "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled." , "* `trade_date`: Optional date from which people can interact with this instruction." , "* `value_date`: Optional date after which the instruction should be settled (not enforced)." , "* `legs`: A vector of all [`Leg`] included in this instruction." , "* `memo`: An optional [`Memo`] field for this instruction." ,] } , Self :: add_and_affirm_instruction { .. } => { & ["Adds and affirms a new instruction." , "" , "# Arguments" , "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to." , "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled." , "* `trade_date`: Optional date from which people can interact with this instruction." , "* `value_date`: Optional date after which the instruction should be settled (not enforced)." , "* `legs`: A vector of all [`Leg`] included in this instruction." , "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "* `memo`: An optional [`Memo`] field for this instruction." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: affirm_instruction { .. } => { & ["Provide affirmation to an existing instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being affirmed." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: withdraw_affirmation { .. } => { & ["Withdraw an affirmation for a given instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: reject_instruction { .. } => { & ["Rejects an existing instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being rejected." , "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: execute_scheduled_instruction { .. } => { & ["Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction." ,] } , Self :: affirm_with_receipts_with_count { .. } => { & ["Affirms an instruction using receipts for offchain transfers." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being affirmed." , "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic." , "" , "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: affirm_instruction_with_count { .. } => { & ["Provide affirmation to an existing instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being affirmed." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic." , "" , "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: reject_instruction_with_count { .. } => { & ["Rejects an existing instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being rejected." , "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it." , "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic." , "" , "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: withdraw_affirmation_with_count { .. } => { & ["Withdraw an affirmation for a given instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal." , "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic." , "" , "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: add_instruction_with_mediators { .. } => { & ["Adds a new instruction with mediators." , "" , "# Arguments" , "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to." , "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled." , "* `trade_date`: Optional date from which people can interact with this instruction." , "* `value_date`: Optional date after which the instruction should be settled (not enforced)." , "* `legs`: A vector of all [`Leg`] included in this instruction." , "* `instruction_memo`: An optional [`Memo`] field for this instruction." , "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction." ,] } , Self :: add_and_affirm_with_mediators { .. } => { & ["Adds and affirms a new instruction with mediators." , "" , "# Arguments" , "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to." , "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled." , "* `trade_date`: Optional date from which people can interact with this instruction." , "* `value_date`: Optional date after which the instruction should be settled (not enforced)." , "* `legs`: A vector of all [`Leg`] included in this instruction." , "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "* `instruction_memo`: An optional [`Memo`] field for this instruction." , "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: affirm_instruction_as_mediator { .. } => { & ["Affirms the instruction as a mediator - should only be called by mediators, otherwise it will fail." , "" , "# Arguments" , "* `origin`: The secondary key of the sender." , "* `instruction_id`: The [`InstructionId`] that will be affirmed by the mediator." , "* `expiry`: An Optional value for defining when the affirmation will expire (None means it will always be valid)." ,] } , Self :: withdraw_affirmation_as_mediator { .. } => { & ["Removes the mediator's affirmation for the instruction - should only be called by mediators, otherwise it will fail." , "" , "# Arguments" , "* `origin`: The secondary key of the sender." , "* `instruction_id`: The [`InstructionId`] that will have the affirmation removed." ,] } , Self :: reject_instruction_as_mediator { .. } => { & ["Rejects an existing instruction - should only be called by mediators, otherwise it will fail." , "" , "# Arguments" , "* `instruction_id` - the [`InstructionId`] of the instruction being rejected." , "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic." , "" , "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count." ,] } , _ => & [""] , }
      }
    }
    impl From<SettlementCall> for &'static str {
      fn from(v: SettlementCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&SettlementCall> for &'static str {
      fn from(v: &SettlementCall) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Errors for the Settlement module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum SettlementError {
      #[doc = "Venue does not exist."]
      #[codec(index = 0u8)]
      InvalidVenue,
      #[doc = "Sender does not have required permissions."]
      #[codec(index = 1u8)]
      Unauthorized,
      #[doc = "Instruction has not been affirmed."]
      #[codec(index = 2u8)]
      InstructionNotAffirmed,
      #[doc = "Signer is not authorized by the venue."]
      #[codec(index = 3u8)]
      UnauthorizedSigner,
      #[doc = "Receipt already used."]
      #[codec(index = 4u8)]
      ReceiptAlreadyClaimed,
      #[doc = "Venue does not have required permissions."]
      #[codec(index = 5u8)]
      UnauthorizedVenue,
      #[doc = "Instruction has invalid dates"]
      #[codec(index = 6u8)]
      InstructionDatesInvalid,
      #[doc = "Instruction's target settle block reached."]
      #[codec(index = 7u8)]
      InstructionSettleBlockPassed,
      #[doc = "Offchain signature is invalid."]
      #[codec(index = 8u8)]
      InvalidSignature,
      #[doc = "Sender and receiver are the same."]
      #[codec(index = 9u8)]
      SameSenderReceiver,
      #[doc = "The provided settlement block number is in the past and cannot be used by the scheduler."]
      #[codec(index = 10u8)]
      SettleOnPastBlock,
      #[doc = "The current instruction affirmation status does not support the requested action."]
      #[codec(index = 11u8)]
      UnexpectedAffirmationStatus,
      #[doc = "Scheduling of an instruction fails."]
      #[codec(index = 12u8)]
      FailedToSchedule,
      #[doc = "Instruction status is unknown"]
      #[codec(index = 13u8)]
      UnknownInstruction,
      #[doc = "Signer is already added to venue."]
      #[codec(index = 14u8)]
      SignerAlreadyExists,
      #[doc = "Signer is not added to venue."]
      #[codec(index = 15u8)]
      SignerDoesNotExist,
      #[doc = "Instruction leg amount can't be zero."]
      #[codec(index = 16u8)]
      ZeroAmount,
      #[doc = "Instruction settlement block has not yet been reached."]
      #[codec(index = 17u8)]
      InstructionSettleBlockNotReached,
      #[doc = "The caller is not a party of this instruction."]
      #[codec(index = 18u8)]
      CallerIsNotAParty,
      #[doc = "The number of nfts being transferred in the instruction was exceeded."]
      #[codec(index = 19u8)]
      MaxNumberOfNFTsExceeded,
      #[doc = "The given number of nfts being transferred was underestimated."]
      #[codec(index = 20u8)]
      NumberOfTransferredNFTsUnderestimated,
      #[doc = "Off-chain receipts can only be used for off-chain leg type."]
      #[codec(index = 21u8)]
      ReceiptForInvalidLegType,
      #[doc = "The maximum weight limit for executing the function was exceeded."]
      #[codec(index = 22u8)]
      WeightLimitExceeded,
      #[doc = "The maximum number of fungible assets was exceeded."]
      #[codec(index = 23u8)]
      MaxNumberOfFungibleAssetsExceeded,
      #[doc = "The maximum number of off-chain assets was exceeded."]
      #[codec(index = 24u8)]
      MaxNumberOfOffChainAssetsExceeded,
      #[doc = "The given number of fungible transfers was underestimated."]
      #[codec(index = 25u8)]
      NumberOfFungibleTransfersUnderestimated,
      #[doc = "AssetId could not be found on chain."]
      #[codec(index = 26u8)]
      UnexpectedOFFChainAsset,
      #[doc = "Off-Chain assets cannot be locked."]
      #[codec(index = 27u8)]
      OffChainAssetCantBeLocked,
      #[doc = "The given number of off-chain transfers was underestimated."]
      #[codec(index = 28u8)]
      NumberOfOffChainTransfersUnderestimated,
      #[doc = "No leg with the given id was found"]
      #[codec(index = 29u8)]
      LegNotFound,
      #[doc = "The input weight is less than the minimum required."]
      #[codec(index = 30u8)]
      InputWeightIsLessThanMinimum,
      #[doc = "The maximum number of receipts was exceeded."]
      #[codec(index = 31u8)]
      MaxNumberOfReceiptsExceeded,
      #[doc = "There are parties who have not affirmed the instruction."]
      #[codec(index = 32u8)]
      NotAllAffirmationsHaveBeenReceived,
      #[doc = "Only [`InstructionStatus::Pending`] or [`InstructionStatus::Failed`] instructions can be executed."]
      #[codec(index = 33u8)]
      InvalidInstructionStatusForExecution,
      #[doc = "The instruction failed to release asset locks or transfer the assets."]
      #[codec(index = 34u8)]
      FailedToReleaseLockOrTransferAssets,
      #[doc = "No duplicate uid are allowed for different receipts."]
      #[codec(index = 35u8)]
      DuplicateReceiptUid,
      #[doc = "The instruction id in all receipts must match the extrinsic parameter."]
      #[codec(index = 36u8)]
      ReceiptInstructionIdMissmatch,
      #[doc = "Multiple receipts for the same leg are not allowed."]
      #[codec(index = 37u8)]
      MultipleReceiptsForOneLeg,
      #[doc = "An invalid has been reached."]
      #[codec(index = 38u8)]
      UnexpectedLegStatus,
      #[doc = "The maximum number of venue signers was exceeded."]
      #[codec(index = 39u8)]
      NumberOfVenueSignersExceeded,
      #[doc = "The caller is not a mediator in the instruction."]
      #[codec(index = 40u8)]
      CallerIsNotAMediator,
      #[doc = "The mediator's expiry date must be in the future."]
      #[codec(index = 41u8)]
      InvalidExpiryDate,
      #[doc = "The expiry date for the mediator's affirmation has passed."]
      #[codec(index = 42u8)]
      MediatorAffirmationExpired,
      #[doc = "Offchain assets must have a venue."]
      #[codec(index = 43u8)]
      OffChainAssetsMustHaveAVenue,
    }
    impl SettlementError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::InvalidVenue => "Settlement.InvalidVenue",
          Self::Unauthorized => "Settlement.Unauthorized",
          Self::InstructionNotAffirmed => "Settlement.InstructionNotAffirmed",
          Self::UnauthorizedSigner => "Settlement.UnauthorizedSigner",
          Self::ReceiptAlreadyClaimed => "Settlement.ReceiptAlreadyClaimed",
          Self::UnauthorizedVenue => "Settlement.UnauthorizedVenue",
          Self::InstructionDatesInvalid => "Settlement.InstructionDatesInvalid",
          Self::InstructionSettleBlockPassed => "Settlement.InstructionSettleBlockPassed",
          Self::InvalidSignature => "Settlement.InvalidSignature",
          Self::SameSenderReceiver => "Settlement.SameSenderReceiver",
          Self::SettleOnPastBlock => "Settlement.SettleOnPastBlock",
          Self::UnexpectedAffirmationStatus => "Settlement.UnexpectedAffirmationStatus",
          Self::FailedToSchedule => "Settlement.FailedToSchedule",
          Self::UnknownInstruction => "Settlement.UnknownInstruction",
          Self::SignerAlreadyExists => "Settlement.SignerAlreadyExists",
          Self::SignerDoesNotExist => "Settlement.SignerDoesNotExist",
          Self::ZeroAmount => "Settlement.ZeroAmount",
          Self::InstructionSettleBlockNotReached => "Settlement.InstructionSettleBlockNotReached",
          Self::CallerIsNotAParty => "Settlement.CallerIsNotAParty",
          Self::MaxNumberOfNFTsExceeded => "Settlement.MaxNumberOfNFTsExceeded",
          Self::NumberOfTransferredNFTsUnderestimated => {
            "Settlement.NumberOfTransferredNFTsUnderestimated"
          }
          Self::ReceiptForInvalidLegType => "Settlement.ReceiptForInvalidLegType",
          Self::WeightLimitExceeded => "Settlement.WeightLimitExceeded",
          Self::MaxNumberOfFungibleAssetsExceeded => "Settlement.MaxNumberOfFungibleAssetsExceeded",
          Self::MaxNumberOfOffChainAssetsExceeded => "Settlement.MaxNumberOfOffChainAssetsExceeded",
          Self::NumberOfFungibleTransfersUnderestimated => {
            "Settlement.NumberOfFungibleTransfersUnderestimated"
          }
          Self::UnexpectedOFFChainAsset => "Settlement.UnexpectedOFFChainAsset",
          Self::OffChainAssetCantBeLocked => "Settlement.OffChainAssetCantBeLocked",
          Self::NumberOfOffChainTransfersUnderestimated => {
            "Settlement.NumberOfOffChainTransfersUnderestimated"
          }
          Self::LegNotFound => "Settlement.LegNotFound",
          Self::InputWeightIsLessThanMinimum => "Settlement.InputWeightIsLessThanMinimum",
          Self::MaxNumberOfReceiptsExceeded => "Settlement.MaxNumberOfReceiptsExceeded",
          Self::NotAllAffirmationsHaveBeenReceived => {
            "Settlement.NotAllAffirmationsHaveBeenReceived"
          }
          Self::InvalidInstructionStatusForExecution => {
            "Settlement.InvalidInstructionStatusForExecution"
          }
          Self::FailedToReleaseLockOrTransferAssets => {
            "Settlement.FailedToReleaseLockOrTransferAssets"
          }
          Self::DuplicateReceiptUid => "Settlement.DuplicateReceiptUid",
          Self::ReceiptInstructionIdMissmatch => "Settlement.ReceiptInstructionIdMissmatch",
          Self::MultipleReceiptsForOneLeg => "Settlement.MultipleReceiptsForOneLeg",
          Self::UnexpectedLegStatus => "Settlement.UnexpectedLegStatus",
          Self::NumberOfVenueSignersExceeded => "Settlement.NumberOfVenueSignersExceeded",
          Self::CallerIsNotAMediator => "Settlement.CallerIsNotAMediator",
          Self::InvalidExpiryDate => "Settlement.InvalidExpiryDate",
          Self::MediatorAffirmationExpired => "Settlement.MediatorAffirmationExpired",
          Self::OffChainAssetsMustHaveAVenue => "Settlement.OffChainAssetsMustHaveAVenue",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for SettlementError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: InvalidVenue => { & ["Venue does not exist." ,] } , Self :: Unauthorized => { & ["Sender does not have required permissions." ,] } , Self :: InstructionNotAffirmed => { & ["Instruction has not been affirmed." ,] } , Self :: UnauthorizedSigner => { & ["Signer is not authorized by the venue." ,] } , Self :: ReceiptAlreadyClaimed => { & ["Receipt already used." ,] } , Self :: UnauthorizedVenue => { & ["Venue does not have required permissions." ,] } , Self :: InstructionDatesInvalid => { & ["Instruction has invalid dates" ,] } , Self :: InstructionSettleBlockPassed => { & ["Instruction's target settle block reached." ,] } , Self :: InvalidSignature => { & ["Offchain signature is invalid." ,] } , Self :: SameSenderReceiver => { & ["Sender and receiver are the same." ,] } , Self :: SettleOnPastBlock => { & ["The provided settlement block number is in the past and cannot be used by the scheduler." ,] } , Self :: UnexpectedAffirmationStatus => { & ["The current instruction affirmation status does not support the requested action." ,] } , Self :: FailedToSchedule => { & ["Scheduling of an instruction fails." ,] } , Self :: UnknownInstruction => { & ["Instruction status is unknown" ,] } , Self :: SignerAlreadyExists => { & ["Signer is already added to venue." ,] } , Self :: SignerDoesNotExist => { & ["Signer is not added to venue." ,] } , Self :: ZeroAmount => { & ["Instruction leg amount can't be zero." ,] } , Self :: InstructionSettleBlockNotReached => { & ["Instruction settlement block has not yet been reached." ,] } , Self :: CallerIsNotAParty => { & ["The caller is not a party of this instruction." ,] } , Self :: MaxNumberOfNFTsExceeded => { & ["The number of nfts being transferred in the instruction was exceeded." ,] } , Self :: NumberOfTransferredNFTsUnderestimated => { & ["The given number of nfts being transferred was underestimated." ,] } , Self :: ReceiptForInvalidLegType => { & ["Off-chain receipts can only be used for off-chain leg type." ,] } , Self :: WeightLimitExceeded => { & ["The maximum weight limit for executing the function was exceeded." ,] } , Self :: MaxNumberOfFungibleAssetsExceeded => { & ["The maximum number of fungible assets was exceeded." ,] } , Self :: MaxNumberOfOffChainAssetsExceeded => { & ["The maximum number of off-chain assets was exceeded." ,] } , Self :: NumberOfFungibleTransfersUnderestimated => { & ["The given number of fungible transfers was underestimated." ,] } , Self :: UnexpectedOFFChainAsset => { & ["AssetId could not be found on chain." ,] } , Self :: OffChainAssetCantBeLocked => { & ["Off-Chain assets cannot be locked." ,] } , Self :: NumberOfOffChainTransfersUnderestimated => { & ["The given number of off-chain transfers was underestimated." ,] } , Self :: LegNotFound => { & ["No leg with the given id was found" ,] } , Self :: InputWeightIsLessThanMinimum => { & ["The input weight is less than the minimum required." ,] } , Self :: MaxNumberOfReceiptsExceeded => { & ["The maximum number of receipts was exceeded." ,] } , Self :: NotAllAffirmationsHaveBeenReceived => { & ["There are parties who have not affirmed the instruction." ,] } , Self :: InvalidInstructionStatusForExecution => { & ["Only [`InstructionStatus::Pending`] or [`InstructionStatus::Failed`] instructions can be executed." ,] } , Self :: FailedToReleaseLockOrTransferAssets => { & ["The instruction failed to release asset locks or transfer the assets." ,] } , Self :: DuplicateReceiptUid => { & ["No duplicate uid are allowed for different receipts." ,] } , Self :: ReceiptInstructionIdMissmatch => { & ["The instruction id in all receipts must match the extrinsic parameter." ,] } , Self :: MultipleReceiptsForOneLeg => { & ["Multiple receipts for the same leg are not allowed." ,] } , Self :: UnexpectedLegStatus => { & ["An invalid has been reached." ,] } , Self :: NumberOfVenueSignersExceeded => { & ["The maximum number of venue signers was exceeded." ,] } , Self :: CallerIsNotAMediator => { & ["The caller is not a mediator in the instruction." ,] } , Self :: InvalidExpiryDate => { & ["The mediator's expiry date must be in the future." ,] } , Self :: MediatorAffirmationExpired => { & ["The expiry date for the mediator's affirmation has passed." ,] } , Self :: OffChainAssetsMustHaveAVenue => { & ["Offchain assets must have a venue." ,] } , _ => & [""] , }
      }
    }
    impl From<SettlementError> for &'static str {
      fn from(v: SettlementError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&SettlementError> for &'static str {
      fn from(v: &SettlementError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_staking {
    use super::*;
    pub mod pallet {
      use super::*;
      pub mod pallet {
        use super::*;
        #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum StakingCall {
          #[doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"]
          #[doc = "be the account that controls it."]
          #[doc = ""]
          #[doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_ by the stash account."]
          #[doc = ""]
          #[doc = "Emits `Bonded`."]
          #[doc = "## Complexity"]
          #[doc = "- Independent of the arguments. Moderate complexity."]
          #[doc = "- O(1)."]
          #[doc = "- Three extra DB entries."]
          #[doc = ""]
          #[doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"]
          #[doc = "unless the `origin` falls below _existential deposit_ and gets removed as dust."]
          #[codec(index = 0u8)]
          bond {
            controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
            #[codec(compact)]
            value: u128,
            payee: pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
          },
          #[doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"]
          #[doc = "for staking."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
          #[doc = ""]
          #[doc = "Use this if there are additional funds in your stash account that you wish to bond."]
          #[doc = "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose"]
          #[doc = "any limitation on the amount that can be added."]
          #[doc = ""]
          #[doc = "Emits `Bonded`."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "- Independent of the arguments. Insignificant complexity."]
          #[doc = "- O(1)."]
          #[codec(index = 1u8)]
          bond_extra {
            #[codec(compact)]
            max_additional: u128,
          },
          #[doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"]
          #[doc = "period ends. If this leaves an amount actively bonded less than"]
          #[doc = "T::Currency::minimum_balance(), then it is increased to the full amount."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
          #[doc = ""]
          #[doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"]
          #[doc = "the funds out of management ready for transfer."]
          #[doc = ""]
          #[doc = "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)"]
          #[doc = "can co-exists at the same time. If there are no unlocking chunks slots available"]
          #[doc = "[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible)."]
          #[doc = ""]
          #[doc = "If a user encounters the `InsufficientBond` error when calling this extrinsic,"]
          #[doc = "they should call `chill` first in order to free up their bonded funds."]
          #[doc = ""]
          #[doc = "Emits `Unbonded`."]
          #[doc = ""]
          #[doc = "See also [`Call::withdraw_unbonded`]."]
          #[codec(index = 2u8)]
          unbond {
            #[codec(compact)]
            value: u128,
          },
          #[doc = "Remove any unlocked chunks from the `unlocking` queue from our management."]
          #[doc = ""]
          #[doc = "This essentially frees up that balance to be used by the stash account to do"]
          #[doc = "whatever it wants."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_ by the controller."]
          #[doc = ""]
          #[doc = "Emits `Withdrawn`."]
          #[doc = ""]
          #[doc = "See also [`Call::unbond`]."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "O(S) where S is the number of slashing spans to remove"]
          #[doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."]
          #[codec(index = 3u8)]
          withdraw_unbonded { num_slashing_spans: u32 },
          #[doc = "Declare the desire to validate for the origin controller."]
          #[doc = ""]
          #[doc = "Effects will be felt at the beginning of the next era."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
          #[codec(index = 4u8)]
          validate {
            prefs: pallet_staking::ValidatorPrefs,
          },
          #[doc = "Declare the desire to nominate `targets` for the origin controller."]
          #[doc = ""]
          #[doc = "Effects will be felt at the beginning of the next era."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "- The transaction's complexity is proportional to the size of `targets` (N)"]
          #[doc = "which is capped at CompactAssignments::LIMIT (T::MaxNominations)."]
          #[doc = "- Both the reads and writes follow a similar pattern."]
          #[codec(index = 5u8)]
          nominate {
            targets: ::alloc::vec::Vec<
              ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
            >,
          },
          #[doc = "Declare no desire to either validate or nominate."]
          #[doc = ""]
          #[doc = "Effects will be felt at the beginning of the next era."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "- Independent of the arguments. Insignificant complexity."]
          #[doc = "- Contains one read."]
          #[doc = "- Writes are limited to the `origin` account key."]
          #[codec(index = 6u8)]
          chill,
          #[doc = "(Re-)set the payment target for a controller."]
          #[doc = ""]
          #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "- O(1)"]
          #[doc = "- Independent of the arguments. Insignificant complexity."]
          #[doc = "- Contains a limited number of reads."]
          #[doc = "- Writes are limited to the `origin` account key."]
          #[doc = "---------"]
          #[codec(index = 7u8)]
          set_payee {
            payee: pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
          },
          #[doc = "(Re-)set the controller of a stash."]
          #[doc = ""]
          #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "O(1)"]
          #[doc = "- Independent of the arguments. Insignificant complexity."]
          #[doc = "- Contains a limited number of reads."]
          #[doc = "- Writes are limited to the `origin` account key."]
          #[codec(index = 8u8)]
          set_controller {
            controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          },
          #[doc = "Sets the ideal number of validators."]
          #[doc = ""]
          #[doc = "The dispatch origin must be Root."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "O(1)"]
          #[codec(index = 9u8)]
          set_validator_count {
            #[codec(compact)]
            new: u32,
          },
          #[doc = "Increments the ideal number of validators upto maximum of"]
          #[doc = "`ElectionProviderBase::MaxWinners`."]
          #[doc = ""]
          #[doc = "The dispatch origin must be Root."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "Same as [`Self::set_validator_count`]."]
          #[codec(index = 10u8)]
          increase_validator_count {
            #[codec(compact)]
            additional: u32,
          },
          #[doc = "Scale up the ideal number of validators by a factor upto maximum of"]
          #[doc = "`ElectionProviderBase::MaxWinners`."]
          #[doc = ""]
          #[doc = "The dispatch origin must be Root."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "Same as [`Self::set_validator_count`]."]
          #[codec(index = 11u8)]
          scale_validator_count {
            factor: ::polymesh_api_client::per_things::Percent,
          },
          #[doc = "Force there to be no new eras indefinitely."]
          #[doc = ""]
          #[doc = "The dispatch origin must be Root."]
          #[doc = ""]
          #[doc = "# Warning"]
          #[doc = ""]
          #[doc = "The election process starts multiple blocks before the end of the era."]
          #[doc = "Thus the election process may be ongoing when this is called. In this case the"]
          #[doc = "election will continue until the next era is triggered."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "- No arguments."]
          #[doc = "- Weight: O(1)"]
          #[codec(index = 12u8)]
          force_no_eras,
          #[doc = "Force there to be a new era at the end of the next session. After this, it will be"]
          #[doc = "reset to normal (non-forced) behaviour."]
          #[doc = ""]
          #[doc = "The dispatch origin must be Root."]
          #[doc = ""]
          #[doc = "# Warning"]
          #[doc = ""]
          #[doc = "The election process starts multiple blocks before the end of the era."]
          #[doc = "If this is called just before a new era is triggered, the election process may not"]
          #[doc = "have enough blocks to get a result."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "- No arguments."]
          #[doc = "- Weight: O(1)"]
          #[codec(index = 13u8)]
          force_new_era,
          #[doc = "Set the validators who cannot be slashed (if any)."]
          #[doc = ""]
          #[doc = "The dispatch origin must be Root."]
          #[codec(index = 14u8)]
          set_invulnerables {
            invulnerables: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
          },
          #[doc = "Force a current staker to become completely unstaked, immediately."]
          #[doc = ""]
          #[doc = "The dispatch origin must be Root."]
          #[codec(index = 15u8)]
          force_unstake {
            stash: ::polymesh_api_client::AccountId,
            num_slashing_spans: u32,
          },
          #[doc = "Force there to be a new era at the end of sessions indefinitely."]
          #[doc = ""]
          #[doc = "The dispatch origin must be Root."]
          #[doc = ""]
          #[doc = "# Warning"]
          #[doc = ""]
          #[doc = "The election process starts multiple blocks before the end of the era."]
          #[doc = "If this is called just before a new era is triggered, the election process may not"]
          #[doc = "have enough blocks to get a result."]
          #[codec(index = 16u8)]
          force_new_era_always,
          #[doc = "Cancel enactment of a deferred slash."]
          #[doc = ""]
          #[doc = "Can be called by the `T::AdminOrigin`."]
          #[doc = ""]
          #[doc = "Parameters: era and indices of the slashes for that era to kill."]
          #[codec(index = 17u8)]
          cancel_deferred_slash {
            era: u32,
            slash_indices: ::alloc::vec::Vec<u32>,
          },
          #[doc = "Pay out all the stakers behind a single validator for a single era."]
          #[doc = ""]
          #[doc = "- `validator_stash` is the stash account of the validator. Their nominators, up to"]
          #[doc = "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards."]
          #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
          #[doc = ""]
          #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
          #[doc = "it is not one of the stakers."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "- At most O(MaxNominatorRewardedPerValidator)."]
          #[codec(index = 18u8)]
          payout_stakers {
            validator_stash: ::polymesh_api_client::AccountId,
            era: u32,
          },
          #[doc = "Rebond a portion of the stash scheduled to be unlocked."]
          #[doc = ""]
          #[doc = "The dispatch origin must be signed by the controller."]
          #[doc = ""]
          #[doc = "## Complexity"]
          #[doc = "- Time complexity: O(L), where L is unlocking chunks"]
          #[doc = "- Bounded by `MaxUnlockingChunks`."]
          #[codec(index = 19u8)]
          rebond {
            #[codec(compact)]
            value: u128,
          },
          #[doc = "Remove all data structures concerning a staker/stash once it is at a state where it can"]
          #[doc = "be considered `dust` in the staking system. The requirements are:"]
          #[doc = ""]
          #[doc = "1. the `total_balance` of the stash is below existential deposit."]
          #[doc = "2. or, the `ledger.total` of the stash is below existential deposit."]
          #[doc = ""]
          #[doc = "The former can happen in cases like a slash; the latter when a fully unbonded account"]
          #[doc = "is still receiving staking rewards in `RewardDestination::Staked`."]
          #[doc = ""]
          #[doc = "It can be called by anyone, as long as `stash` meets the above requirements."]
          #[doc = ""]
          #[doc = "Refunds the transaction fees upon successful execution."]
          #[codec(index = 20u8)]
          reap_stash {
            stash: ::polymesh_api_client::AccountId,
            num_slashing_spans: u32,
          },
          #[doc = "Remove the given nominations from the calling validator."]
          #[doc = ""]
          #[doc = "Effects will be felt at the beginning of the next era."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
          #[doc = ""]
          #[doc = "- `who`: A list of nominator stash accounts who are nominating this validator which"]
          #[doc = "  should no longer be nominating this validator."]
          #[doc = ""]
          #[doc = "Note: Making this call only makes sense if you first set the validator preferences to"]
          #[doc = "block any further nominations."]
          #[codec(index = 21u8)]
          kick {
            who: ::alloc::vec::Vec<
              ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
            >,
          },
          #[doc = "Update the various staking configurations ."]
          #[doc = ""]
          #[doc = "* `min_nominator_bond`: The minimum active bond needed to be a nominator."]
          #[doc = "* `min_validator_bond`: The minimum active bond needed to be a validator."]
          #[doc = "* `max_nominator_count`: The max number of users who can be a nominator at once. When"]
          #[doc = "  set to `None`, no limit is enforced."]
          #[doc = "* `max_validator_count`: The max number of users who can be a validator at once. When"]
          #[doc = "  set to `None`, no limit is enforced."]
          #[doc = "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which"]
          #[doc = "  should be filled in order for the `chill_other` transaction to work."]
          #[doc = "* `min_commission`: The minimum amount of commission that each validators must maintain."]
          #[doc = "  This is checked only upon calling `validate`. Existing validators are not affected."]
          #[doc = ""]
          #[doc = "RuntimeOrigin must be Root to call this function."]
          #[doc = ""]
          #[doc = "NOTE: Existing nominators and validators will not be affected by this update."]
          #[doc = "to kick people under the new limits, `chill_other` should be called."]
          #[codec(index = 22u8)]
          set_staking_configs {
            min_nominator_bond: pallet_staking::pallet::pallet::ConfigOp<u128>,
            min_validator_bond: pallet_staking::pallet::pallet::ConfigOp<u128>,
            max_nominator_count: pallet_staking::pallet::pallet::ConfigOp<u32>,
            max_validator_count: pallet_staking::pallet::pallet::ConfigOp<u32>,
            chill_threshold:
              pallet_staking::pallet::pallet::ConfigOp<::polymesh_api_client::per_things::Percent>,
            min_commission:
              pallet_staking::pallet::pallet::ConfigOp<::polymesh_api_client::per_things::Perbill>,
          },
          #[doc = "Declare a `controller` to stop participating as either a validator or nominator."]
          #[doc = ""]
          #[doc = "Effects will be felt at the beginning of the next era."]
          #[doc = ""]
          #[doc = "The dispatch origin for this call must be _Signed_, but can be called by anyone."]
          #[doc = ""]
          #[doc = "If the caller is the same as the controller being targeted, then no further checks are"]
          #[doc = "enforced, and this function behaves just like `chill`."]
          #[doc = ""]
          #[doc = "If the caller is different than the controller being targeted, the following conditions"]
          #[doc = "must be met:"]
          #[doc = ""]
          #[doc = "* `controller` must belong to a nominator who has become non-decodable,"]
          #[doc = ""]
          #[doc = "Or:"]
          #[doc = ""]
          #[doc = "* A `ChillThreshold` must be set and checked which defines how close to the max"]
          #[doc = "  nominators or validators we must reach before users can start chilling one-another."]
          #[doc = "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine"]
          #[doc = "  how close we are to the threshold."]
          #[doc = "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines"]
          #[doc = "  if this is a person that should be chilled because they have not met the threshold"]
          #[doc = "  bond required."]
          #[doc = ""]
          #[doc = "This can be helpful if bond requirements are updated, and we need to remove old users"]
          #[doc = "who do not satisfy these requirements."]
          #[codec(index = 23u8)]
          chill_other {
            controller: ::polymesh_api_client::AccountId,
          },
          #[doc = "Force a validator to have at least the minimum commission. This will not affect a"]
          #[doc = "validator who already has a commission greater than or equal to the minimum. Any account"]
          #[doc = "can call this."]
          #[codec(index = 24u8)]
          force_apply_min_commission {
            validator_stash: ::polymesh_api_client::AccountId,
          },
          #[doc = "Sets the minimum amount of commission that each validators must maintain."]
          #[doc = ""]
          #[doc = "This call has lower privilege requirements than `set_staking_config` and can be called"]
          #[doc = "by the `T::AdminOrigin`. Root can always call this."]
          #[codec(index = 25u8)]
          set_min_commission {
            new: ::polymesh_api_client::per_things::Perbill,
          },
          #[doc = "Adds a permissioned identity and sets its preferences."]
          #[doc = ""]
          #[doc = "The dispatch origin must be Root."]
          #[codec(index = 26u8)]
          add_permissioned_validator {
            identity: ::polymesh_api_client::IdentityId,
            intended_count: Option<u32>,
          },
          #[doc = "Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session."]
          #[doc = ""]
          #[doc = "The dispatch origin must be Root."]
          #[doc = ""]
          #[doc = "# Arguments"]
          #[doc = "* origin Required origin for removing a potential validator."]
          #[doc = "* identity Validator's IdentityId."]
          #[codec(index = 27u8)]
          remove_permissioned_validator {
            identity: ::polymesh_api_client::IdentityId,
          },
          #[doc = "Validate the nominators CDD expiry time."]
          #[doc = ""]
          #[doc = "If an account from a given set of address is nominating then check the CDD expiry time"]
          #[doc = "of it and if it is expired then the account should be unbonded and removed from the"]
          #[doc = "nominating process."]
          #[codec(index = 28u8)]
          validate_cdd_expiry_nominators {
            targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
          },
          #[codec(index = 29u8)]
          payout_stakers_by_system {
            validator_stash: ::polymesh_api_client::AccountId,
            era: u32,
          },
          #[doc = "Switch slashing status on the basis of given `slashing_switch`. Can only be called by root."]
          #[codec(index = 30u8)]
          change_slashing_allowed_for {
            slashing_switch: pallet_staking::types::SlashingSwitch,
          },
          #[doc = "Sets the intended count to `new_intended_count` for the given `identity`."]
          #[codec(index = 31u8)]
          update_permissioned_validator_intended_count {
            identity: ::polymesh_api_client::IdentityId,
            new_intended_count: u32,
          },
          #[doc = "Governance council forcefully chills a validator. Effects will be felt at the beginning of the next era."]
          #[codec(index = 32u8)]
          chill_from_governance {
            identity: ::polymesh_api_client::IdentityId,
            stash_keys: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
          },
          #[doc = "Changes commission rate which applies to all validators. Only Governance"]
          #[doc = "committee is allowed to change this value."]
          #[doc = ""]
          #[doc = "# Arguments"]
          #[doc = "* `new_cap` the new commission cap."]
          #[codec(index = 33u8)]
          set_commission_cap {
            new_cap: ::polymesh_api_client::per_things::Perbill,
          },
        }
        impl StakingCall {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::bond { .. } => "Staking.bond",
              Self::bond_extra { .. } => "Staking.bond_extra",
              Self::unbond { .. } => "Staking.unbond",
              Self::withdraw_unbonded { .. } => "Staking.withdraw_unbonded",
              Self::validate { .. } => "Staking.validate",
              Self::nominate { .. } => "Staking.nominate",
              Self::chill => "Staking.chill",
              Self::set_payee { .. } => "Staking.set_payee",
              Self::set_controller { .. } => "Staking.set_controller",
              Self::set_validator_count { .. } => "Staking.set_validator_count",
              Self::increase_validator_count { .. } => "Staking.increase_validator_count",
              Self::scale_validator_count { .. } => "Staking.scale_validator_count",
              Self::force_no_eras => "Staking.force_no_eras",
              Self::force_new_era => "Staking.force_new_era",
              Self::set_invulnerables { .. } => "Staking.set_invulnerables",
              Self::force_unstake { .. } => "Staking.force_unstake",
              Self::force_new_era_always => "Staking.force_new_era_always",
              Self::cancel_deferred_slash { .. } => "Staking.cancel_deferred_slash",
              Self::payout_stakers { .. } => "Staking.payout_stakers",
              Self::rebond { .. } => "Staking.rebond",
              Self::reap_stash { .. } => "Staking.reap_stash",
              Self::kick { .. } => "Staking.kick",
              Self::set_staking_configs { .. } => "Staking.set_staking_configs",
              Self::chill_other { .. } => "Staking.chill_other",
              Self::force_apply_min_commission { .. } => "Staking.force_apply_min_commission",
              Self::set_min_commission { .. } => "Staking.set_min_commission",
              Self::add_permissioned_validator { .. } => "Staking.add_permissioned_validator",
              Self::remove_permissioned_validator { .. } => "Staking.remove_permissioned_validator",
              Self::validate_cdd_expiry_nominators { .. } => {
                "Staking.validate_cdd_expiry_nominators"
              }
              Self::payout_stakers_by_system { .. } => "Staking.payout_stakers_by_system",
              Self::change_slashing_allowed_for { .. } => "Staking.change_slashing_allowed_for",
              Self::update_permissioned_validator_intended_count { .. } => {
                "Staking.update_permissioned_validator_intended_count"
              }
              Self::chill_from_governance { .. } => "Staking.chill_from_governance",
              Self::set_commission_cap { .. } => "Staking.set_commission_cap",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for StakingCall {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: bond { .. } => { & ["Take the origin account as a stash and lock up `value` of its balance. `controller` will" , "be the account that controls it." , "" , "`value` must be more than the `minimum_balance` specified by `T::Currency`." , "" , "The dispatch origin for this call must be _Signed_ by the stash account." , "" , "Emits `Bonded`." , "## Complexity" , "- Independent of the arguments. Moderate complexity." , "- O(1)." , "- Three extra DB entries." , "" , "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned" , "unless the `origin` falls below _existential deposit_ and gets removed as dust." ,] } , Self :: bond_extra { .. } => { & ["Add some extra amount that have appeared in the stash `free_balance` into the balance up" , "for staking." , "" , "The dispatch origin for this call must be _Signed_ by the stash, not the controller." , "" , "Use this if there are additional funds in your stash account that you wish to bond." , "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose" , "any limitation on the amount that can be added." , "" , "Emits `Bonded`." , "" , "## Complexity" , "- Independent of the arguments. Insignificant complexity." , "- O(1)." ,] } , Self :: unbond { .. } => { & ["Schedule a portion of the stash to be unlocked ready for transfer out after the bond" , "period ends. If this leaves an amount actively bonded less than" , "T::Currency::minimum_balance(), then it is increased to the full amount." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "Once the unlock period is done, you can call `withdraw_unbonded` to actually move" , "the funds out of management ready for transfer." , "" , "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)" , "can co-exists at the same time. If there are no unlocking chunks slots available" , "[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible)." , "" , "If a user encounters the `InsufficientBond` error when calling this extrinsic," , "they should call `chill` first in order to free up their bonded funds." , "" , "Emits `Unbonded`." , "" , "See also [`Call::withdraw_unbonded`]." ,] } , Self :: withdraw_unbonded { .. } => { & ["Remove any unlocked chunks from the `unlocking` queue from our management." , "" , "This essentially frees up that balance to be used by the stash account to do" , "whatever it wants." , "" , "The dispatch origin for this call must be _Signed_ by the controller." , "" , "Emits `Withdrawn`." , "" , "See also [`Call::unbond`]." , "" , "## Complexity" , "O(S) where S is the number of slashing spans to remove" , "NOTE: Weight annotation is the kill scenario, we refund otherwise." ,] } , Self :: validate { .. } => { & ["Declare the desire to validate for the origin controller." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." ,] } , Self :: nominate { .. } => { & ["Declare the desire to nominate `targets` for the origin controller." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "## Complexity" , "- The transaction's complexity is proportional to the size of `targets` (N)" , "which is capped at CompactAssignments::LIMIT (T::MaxNominations)." , "- Both the reads and writes follow a similar pattern." ,] } , Self :: chill => { & ["Declare no desire to either validate or nominate." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "## Complexity" , "- Independent of the arguments. Insignificant complexity." , "- Contains one read." , "- Writes are limited to the `origin` account key." ,] } , Self :: set_payee { .. } => { & ["(Re-)set the payment target for a controller." , "" , "Effects will be felt instantly (as soon as this function is completed successfully)." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "## Complexity" , "- O(1)" , "- Independent of the arguments. Insignificant complexity." , "- Contains a limited number of reads." , "- Writes are limited to the `origin` account key." , "---------" ,] } , Self :: set_controller { .. } => { & ["(Re-)set the controller of a stash." , "" , "Effects will be felt instantly (as soon as this function is completed successfully)." , "" , "The dispatch origin for this call must be _Signed_ by the stash, not the controller." , "" , "## Complexity" , "O(1)" , "- Independent of the arguments. Insignificant complexity." , "- Contains a limited number of reads." , "- Writes are limited to the `origin` account key." ,] } , Self :: set_validator_count { .. } => { & ["Sets the ideal number of validators." , "" , "The dispatch origin must be Root." , "" , "## Complexity" , "O(1)" ,] } , Self :: increase_validator_count { .. } => { & ["Increments the ideal number of validators upto maximum of" , "`ElectionProviderBase::MaxWinners`." , "" , "The dispatch origin must be Root." , "" , "## Complexity" , "Same as [`Self::set_validator_count`]." ,] } , Self :: scale_validator_count { .. } => { & ["Scale up the ideal number of validators by a factor upto maximum of" , "`ElectionProviderBase::MaxWinners`." , "" , "The dispatch origin must be Root." , "" , "## Complexity" , "Same as [`Self::set_validator_count`]." ,] } , Self :: force_no_eras => { & ["Force there to be no new eras indefinitely." , "" , "The dispatch origin must be Root." , "" , "# Warning" , "" , "The election process starts multiple blocks before the end of the era." , "Thus the election process may be ongoing when this is called. In this case the" , "election will continue until the next era is triggered." , "" , "## Complexity" , "- No arguments." , "- Weight: O(1)" ,] } , Self :: force_new_era => { & ["Force there to be a new era at the end of the next session. After this, it will be" , "reset to normal (non-forced) behaviour." , "" , "The dispatch origin must be Root." , "" , "# Warning" , "" , "The election process starts multiple blocks before the end of the era." , "If this is called just before a new era is triggered, the election process may not" , "have enough blocks to get a result." , "" , "## Complexity" , "- No arguments." , "- Weight: O(1)" ,] } , Self :: set_invulnerables { .. } => { & ["Set the validators who cannot be slashed (if any)." , "" , "The dispatch origin must be Root." ,] } , Self :: force_unstake { .. } => { & ["Force a current staker to become completely unstaked, immediately." , "" , "The dispatch origin must be Root." ,] } , Self :: force_new_era_always => { & ["Force there to be a new era at the end of sessions indefinitely." , "" , "The dispatch origin must be Root." , "" , "# Warning" , "" , "The election process starts multiple blocks before the end of the era." , "If this is called just before a new era is triggered, the election process may not" , "have enough blocks to get a result." ,] } , Self :: cancel_deferred_slash { .. } => { & ["Cancel enactment of a deferred slash." , "" , "Can be called by the `T::AdminOrigin`." , "" , "Parameters: era and indices of the slashes for that era to kill." ,] } , Self :: payout_stakers { .. } => { & ["Pay out all the stakers behind a single validator for a single era." , "" , "- `validator_stash` is the stash account of the validator. Their nominators, up to" , "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards." , "- `era` may be any era between `[current_era - history_depth; current_era]`." , "" , "The origin of this call must be _Signed_. Any account can call this function, even if" , "it is not one of the stakers." , "" , "## Complexity" , "- At most O(MaxNominatorRewardedPerValidator)." ,] } , Self :: rebond { .. } => { & ["Rebond a portion of the stash scheduled to be unlocked." , "" , "The dispatch origin must be signed by the controller." , "" , "## Complexity" , "- Time complexity: O(L), where L is unlocking chunks" , "- Bounded by `MaxUnlockingChunks`." ,] } , Self :: reap_stash { .. } => { & ["Remove all data structures concerning a staker/stash once it is at a state where it can" , "be considered `dust` in the staking system. The requirements are:" , "" , "1. the `total_balance` of the stash is below existential deposit." , "2. or, the `ledger.total` of the stash is below existential deposit." , "" , "The former can happen in cases like a slash; the latter when a fully unbonded account" , "is still receiving staking rewards in `RewardDestination::Staked`." , "" , "It can be called by anyone, as long as `stash` meets the above requirements." , "" , "Refunds the transaction fees upon successful execution." ,] } , Self :: kick { .. } => { & ["Remove the given nominations from the calling validator." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "- `who`: A list of nominator stash accounts who are nominating this validator which" , "  should no longer be nominating this validator." , "" , "Note: Making this call only makes sense if you first set the validator preferences to" , "block any further nominations." ,] } , Self :: set_staking_configs { .. } => { & ["Update the various staking configurations ." , "" , "* `min_nominator_bond`: The minimum active bond needed to be a nominator." , "* `min_validator_bond`: The minimum active bond needed to be a validator." , "* `max_nominator_count`: The max number of users who can be a nominator at once. When" , "  set to `None`, no limit is enforced." , "* `max_validator_count`: The max number of users who can be a validator at once. When" , "  set to `None`, no limit is enforced." , "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which" , "  should be filled in order for the `chill_other` transaction to work." , "* `min_commission`: The minimum amount of commission that each validators must maintain." , "  This is checked only upon calling `validate`. Existing validators are not affected." , "" , "RuntimeOrigin must be Root to call this function." , "" , "NOTE: Existing nominators and validators will not be affected by this update." , "to kick people under the new limits, `chill_other` should be called." ,] } , Self :: chill_other { .. } => { & ["Declare a `controller` to stop participating as either a validator or nominator." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_, but can be called by anyone." , "" , "If the caller is the same as the controller being targeted, then no further checks are" , "enforced, and this function behaves just like `chill`." , "" , "If the caller is different than the controller being targeted, the following conditions" , "must be met:" , "" , "* `controller` must belong to a nominator who has become non-decodable," , "" , "Or:" , "" , "* A `ChillThreshold` must be set and checked which defines how close to the max" , "  nominators or validators we must reach before users can start chilling one-another." , "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine" , "  how close we are to the threshold." , "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines" , "  if this is a person that should be chilled because they have not met the threshold" , "  bond required." , "" , "This can be helpful if bond requirements are updated, and we need to remove old users" , "who do not satisfy these requirements." ,] } , Self :: force_apply_min_commission { .. } => { & ["Force a validator to have at least the minimum commission. This will not affect a" , "validator who already has a commission greater than or equal to the minimum. Any account" , "can call this." ,] } , Self :: set_min_commission { .. } => { & ["Sets the minimum amount of commission that each validators must maintain." , "" , "This call has lower privilege requirements than `set_staking_config` and can be called" , "by the `T::AdminOrigin`. Root can always call this." ,] } , Self :: add_permissioned_validator { .. } => { & ["Adds a permissioned identity and sets its preferences." , "" , "The dispatch origin must be Root." ,] } , Self :: remove_permissioned_validator { .. } => { & ["Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session." , "" , "The dispatch origin must be Root." , "" , "# Arguments" , "* origin Required origin for removing a potential validator." , "* identity Validator's IdentityId." ,] } , Self :: validate_cdd_expiry_nominators { .. } => { & ["Validate the nominators CDD expiry time." , "" , "If an account from a given set of address is nominating then check the CDD expiry time" , "of it and if it is expired then the account should be unbonded and removed from the" , "nominating process." ,] } , Self :: payout_stakers_by_system { .. } => { & ["" ,] } , Self :: change_slashing_allowed_for { .. } => { & ["Switch slashing status on the basis of given `slashing_switch`. Can only be called by root." ,] } , Self :: update_permissioned_validator_intended_count { .. } => { & ["Sets the intended count to `new_intended_count` for the given `identity`." ,] } , Self :: chill_from_governance { .. } => { & ["Governance council forcefully chills a validator. Effects will be felt at the beginning of the next era." ,] } , Self :: set_commission_cap { .. } => { & ["Changes commission rate which applies to all validators. Only Governance" , "committee is allowed to change this value." , "" , "# Arguments" , "* `new_cap` the new commission cap." ,] } , _ => & [""] , }
          }
        }
        impl From<StakingCall> for &'static str {
          fn from(v: StakingCall) -> Self {
            v.as_static_str()
          }
        }
        impl From<&StakingCall> for &'static str {
          fn from(v: &StakingCall) -> Self {
            v.as_static_str()
          }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum ConfigOp<T> {
          #[codec(index = 0u8)]
          Noop,
          #[codec(index = 1u8)]
          Set(T),
          #[codec(index = 2u8)]
          Remove,
        }
        #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum StakingError {
          #[doc = "Not a controller account."]
          #[codec(index = 0u8)]
          NotController,
          #[doc = "Not a stash account."]
          #[codec(index = 1u8)]
          NotStash,
          #[doc = "Stash is already bonded."]
          #[codec(index = 2u8)]
          AlreadyBonded,
          #[doc = "Controller is already paired."]
          #[codec(index = 3u8)]
          AlreadyPaired,
          #[doc = "Targets cannot be empty."]
          #[codec(index = 4u8)]
          EmptyTargets,
          #[doc = "Duplicate index."]
          #[codec(index = 5u8)]
          DuplicateIndex,
          #[doc = "Slash record index out of bounds."]
          #[codec(index = 6u8)]
          InvalidSlashIndex,
          #[doc = "Cannot have a validator or nominator role, with value less than the minimum defined by"]
          #[doc = "governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the"]
          #[doc = "intention, `chill` first to remove one's role as validator/nominator."]
          #[codec(index = 7u8)]
          InsufficientBond,
          #[doc = "Can not schedule more unlock chunks."]
          #[codec(index = 8u8)]
          NoMoreChunks,
          #[doc = "Can not rebond without unlocking chunks."]
          #[codec(index = 9u8)]
          NoUnlockChunk,
          #[doc = "Attempting to target a stash that still has funds."]
          #[codec(index = 10u8)]
          FundedTarget,
          #[doc = "Invalid era to reward."]
          #[codec(index = 11u8)]
          InvalidEraToReward,
          #[doc = "Invalid number of nominations."]
          #[codec(index = 12u8)]
          InvalidNumberOfNominations,
          #[doc = "Items are not sorted and unique."]
          #[codec(index = 13u8)]
          NotSortedAndUnique,
          #[doc = "Rewards for this era have already been claimed for this validator."]
          #[codec(index = 14u8)]
          AlreadyClaimed,
          #[doc = "Incorrect previous history depth input provided."]
          #[codec(index = 15u8)]
          IncorrectHistoryDepth,
          #[doc = "Incorrect number of slashing spans provided."]
          #[codec(index = 16u8)]
          IncorrectSlashingSpans,
          #[doc = "Internal state has become somehow corrupted and the operation cannot continue."]
          #[codec(index = 17u8)]
          BadState,
          #[doc = "Too many nomination targets supplied."]
          #[codec(index = 18u8)]
          TooManyTargets,
          #[doc = "A nomination target was supplied that was blocked or otherwise not a validator."]
          #[codec(index = 19u8)]
          BadTarget,
          #[doc = "The user has enough bond and thus cannot be chilled forcefully by an external person."]
          #[codec(index = 20u8)]
          CannotChillOther,
          #[doc = "There are too many nominators in the system. Governance needs to adjust the staking"]
          #[doc = "settings to keep things safe for the runtime."]
          #[codec(index = 21u8)]
          TooManyNominators,
          #[doc = "There are too many validator candidates in the system."]
          #[codec(index = 22u8)]
          TooManyValidators,
          #[doc = "Commission is too low. Must be at least `MinCommission`."]
          #[codec(index = 23u8)]
          CommissionTooLow,
          #[doc = "Some bound is not met."]
          #[codec(index = 24u8)]
          BoundNotMet,
          #[doc = "Validator or nominator stash identity does not exist."]
          #[codec(index = 25u8)]
          StashIdentityDoesNotExist,
          #[doc = "Validator's stash identity is not permissioned."]
          #[codec(index = 26u8)]
          StashIdentityNotPermissioned,
          #[doc = "Nominator stash has not gone through CDD."]
          #[codec(index = 27u8)]
          StashIdentityNotCDDed,
          #[doc = "Permissioned validator already exists."]
          #[codec(index = 28u8)]
          IdentityIsAlreadyPermissioned,
          #[doc = "Identity has not gone throught CDD."]
          #[codec(index = 29u8)]
          IdentityIsMissingCDD,
          #[doc = "When the intended number of validators to run is >= 2/3 of `validator_count`."]
          #[codec(index = 30u8)]
          IntendedCountIsExceedingConsensusLimit,
          #[doc = "Identity was not found in the permissioned identity pool."]
          #[codec(index = 31u8)]
          IdentityNotFound,
          #[doc = "No validator was found for the given key."]
          #[codec(index = 32u8)]
          ValidatorNotFound,
          #[doc = "Validator commiission is above maximum."]
          #[codec(index = 33u8)]
          CommissionTooHigh,
          #[doc = "New commission must be different from previous commission."]
          #[codec(index = 34u8)]
          CommissionUnchanged,
        }
        impl StakingError {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::NotController => "Staking.NotController",
              Self::NotStash => "Staking.NotStash",
              Self::AlreadyBonded => "Staking.AlreadyBonded",
              Self::AlreadyPaired => "Staking.AlreadyPaired",
              Self::EmptyTargets => "Staking.EmptyTargets",
              Self::DuplicateIndex => "Staking.DuplicateIndex",
              Self::InvalidSlashIndex => "Staking.InvalidSlashIndex",
              Self::InsufficientBond => "Staking.InsufficientBond",
              Self::NoMoreChunks => "Staking.NoMoreChunks",
              Self::NoUnlockChunk => "Staking.NoUnlockChunk",
              Self::FundedTarget => "Staking.FundedTarget",
              Self::InvalidEraToReward => "Staking.InvalidEraToReward",
              Self::InvalidNumberOfNominations => "Staking.InvalidNumberOfNominations",
              Self::NotSortedAndUnique => "Staking.NotSortedAndUnique",
              Self::AlreadyClaimed => "Staking.AlreadyClaimed",
              Self::IncorrectHistoryDepth => "Staking.IncorrectHistoryDepth",
              Self::IncorrectSlashingSpans => "Staking.IncorrectSlashingSpans",
              Self::BadState => "Staking.BadState",
              Self::TooManyTargets => "Staking.TooManyTargets",
              Self::BadTarget => "Staking.BadTarget",
              Self::CannotChillOther => "Staking.CannotChillOther",
              Self::TooManyNominators => "Staking.TooManyNominators",
              Self::TooManyValidators => "Staking.TooManyValidators",
              Self::CommissionTooLow => "Staking.CommissionTooLow",
              Self::BoundNotMet => "Staking.BoundNotMet",
              Self::StashIdentityDoesNotExist => "Staking.StashIdentityDoesNotExist",
              Self::StashIdentityNotPermissioned => "Staking.StashIdentityNotPermissioned",
              Self::StashIdentityNotCDDed => "Staking.StashIdentityNotCDDed",
              Self::IdentityIsAlreadyPermissioned => "Staking.IdentityIsAlreadyPermissioned",
              Self::IdentityIsMissingCDD => "Staking.IdentityIsMissingCDD",
              Self::IntendedCountIsExceedingConsensusLimit => {
                "Staking.IntendedCountIsExceedingConsensusLimit"
              }
              Self::IdentityNotFound => "Staking.IdentityNotFound",
              Self::ValidatorNotFound => "Staking.ValidatorNotFound",
              Self::CommissionTooHigh => "Staking.CommissionTooHigh",
              Self::CommissionUnchanged => "Staking.CommissionUnchanged",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for StakingError {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: NotController => { & ["Not a controller account." ,] } , Self :: NotStash => { & ["Not a stash account." ,] } , Self :: AlreadyBonded => { & ["Stash is already bonded." ,] } , Self :: AlreadyPaired => { & ["Controller is already paired." ,] } , Self :: EmptyTargets => { & ["Targets cannot be empty." ,] } , Self :: DuplicateIndex => { & ["Duplicate index." ,] } , Self :: InvalidSlashIndex => { & ["Slash record index out of bounds." ,] } , Self :: InsufficientBond => { & ["Cannot have a validator or nominator role, with value less than the minimum defined by" , "governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the" , "intention, `chill` first to remove one's role as validator/nominator." ,] } , Self :: NoMoreChunks => { & ["Can not schedule more unlock chunks." ,] } , Self :: NoUnlockChunk => { & ["Can not rebond without unlocking chunks." ,] } , Self :: FundedTarget => { & ["Attempting to target a stash that still has funds." ,] } , Self :: InvalidEraToReward => { & ["Invalid era to reward." ,] } , Self :: InvalidNumberOfNominations => { & ["Invalid number of nominations." ,] } , Self :: NotSortedAndUnique => { & ["Items are not sorted and unique." ,] } , Self :: AlreadyClaimed => { & ["Rewards for this era have already been claimed for this validator." ,] } , Self :: IncorrectHistoryDepth => { & ["Incorrect previous history depth input provided." ,] } , Self :: IncorrectSlashingSpans => { & ["Incorrect number of slashing spans provided." ,] } , Self :: BadState => { & ["Internal state has become somehow corrupted and the operation cannot continue." ,] } , Self :: TooManyTargets => { & ["Too many nomination targets supplied." ,] } , Self :: BadTarget => { & ["A nomination target was supplied that was blocked or otherwise not a validator." ,] } , Self :: CannotChillOther => { & ["The user has enough bond and thus cannot be chilled forcefully by an external person." ,] } , Self :: TooManyNominators => { & ["There are too many nominators in the system. Governance needs to adjust the staking" , "settings to keep things safe for the runtime." ,] } , Self :: TooManyValidators => { & ["There are too many validator candidates in the system." ,] } , Self :: CommissionTooLow => { & ["Commission is too low. Must be at least `MinCommission`." ,] } , Self :: BoundNotMet => { & ["Some bound is not met." ,] } , Self :: StashIdentityDoesNotExist => { & ["Validator or nominator stash identity does not exist." ,] } , Self :: StashIdentityNotPermissioned => { & ["Validator's stash identity is not permissioned." ,] } , Self :: StashIdentityNotCDDed => { & ["Nominator stash has not gone through CDD." ,] } , Self :: IdentityIsAlreadyPermissioned => { & ["Permissioned validator already exists." ,] } , Self :: IdentityIsMissingCDD => { & ["Identity has not gone throught CDD." ,] } , Self :: IntendedCountIsExceedingConsensusLimit => { & ["When the intended number of validators to run is >= 2/3 of `validator_count`." ,] } , Self :: IdentityNotFound => { & ["Identity was not found in the permissioned identity pool." ,] } , Self :: ValidatorNotFound => { & ["No validator was found for the given key." ,] } , Self :: CommissionTooHigh => { & ["Validator commiission is above maximum." ,] } , Self :: CommissionUnchanged => { & ["New commission must be different from previous commission." ,] } , _ => & [""] , }
          }
        }
        impl From<StakingError> for &'static str {
          fn from(v: StakingError) -> Self {
            v.as_static_str()
          }
        }
        impl From<&StakingError> for &'static str {
          fn from(v: &StakingError) -> Self {
            v.as_static_str()
          }
        }
        #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum StakingEvent {
          #[doc = "The era payout has been set; the first balance is the validator-payout; the second is"]
          #[doc = "the remainder from the maximum amount of reward."]
          #[codec(index = 0u8)]
          EraPaid {
            era_index: u32,
            validator_payout: u128,
            remainder: u128,
          },
          #[doc = "The nominator has been rewarded by this amount."]
          #[codec(index = 1u8)]
          Rewarded {
            identity: ::polymesh_api_client::IdentityId,
            stash: ::polymesh_api_client::AccountId,
            amount: u128,
          },
          #[doc = "A staker (validator or nominator) has been slashed by the given amount."]
          #[codec(index = 2u8)]
          Slashed {
            staker: ::polymesh_api_client::AccountId,
            amount: u128,
          },
          #[doc = "A slash for the given validator, for the given percentage of their stake, at the given"]
          #[doc = "era as been reported."]
          #[codec(index = 3u8)]
          SlashReported {
            validator: ::polymesh_api_client::AccountId,
            fraction: ::polymesh_api_client::per_things::Perbill,
            slash_era: u32,
          },
          #[doc = "An old slashing report from a prior era was discarded because it could"]
          #[doc = "not be processed."]
          #[codec(index = 4u8)]
          OldSlashingReportDiscarded { session_index: u32 },
          #[doc = "A new set of stakers was elected."]
          #[codec(index = 5u8)]
          StakersElected,
          #[doc = "An account has bonded this amount. \\[stash, amount\\]"]
          #[doc = ""]
          #[doc = "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,"]
          #[doc = "it will not be emitted for staking rewards when they are added to stake."]
          #[codec(index = 6u8)]
          Bonded {
            identity: ::polymesh_api_client::IdentityId,
            stash: ::polymesh_api_client::AccountId,
            amount: u128,
          },
          #[doc = "An account has unbonded this amount."]
          #[codec(index = 7u8)]
          Unbonded {
            identity: ::polymesh_api_client::IdentityId,
            stash: ::polymesh_api_client::AccountId,
            amount: u128,
          },
          #[doc = "An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`"]
          #[doc = "from the unlocking queue."]
          #[codec(index = 8u8)]
          Withdrawn {
            stash: ::polymesh_api_client::AccountId,
            amount: u128,
          },
          #[doc = "A nominator has been kicked from a validator."]
          #[codec(index = 9u8)]
          Kicked {
            nominator: ::polymesh_api_client::AccountId,
            stash: ::polymesh_api_client::AccountId,
          },
          #[doc = "The election failed. No new era is planned."]
          #[codec(index = 10u8)]
          StakingElectionFailed,
          #[doc = "An account has stopped participating as either a validator or nominator."]
          #[codec(index = 11u8)]
          Chilled {
            stash: ::polymesh_api_client::AccountId,
          },
          #[doc = "The stakers' rewards are getting paid."]
          #[codec(index = 12u8)]
          PayoutStarted {
            era_index: u32,
            validator_stash: ::polymesh_api_client::AccountId,
          },
          #[doc = "A validator has set their preferences."]
          #[codec(index = 13u8)]
          ValidatorPrefsSet {
            stash: ::polymesh_api_client::AccountId,
            prefs: pallet_staking::ValidatorPrefs,
          },
          #[doc = "A new force era mode was set."]
          #[codec(index = 14u8)]
          ForceEra { mode: pallet_staking::Forcing },
          #[doc = "User has updated their nominations."]
          #[codec(index = 15u8)]
          Nominated {
            nominator_identity: ::polymesh_api_client::IdentityId,
            stash: ::polymesh_api_client::AccountId,
            targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
          },
          #[doc = "An identity has issued a candidacy for becoming a validator."]
          #[codec(index = 16u8)]
          PermissionedIdentityAdded {
            governance_councill_did: ::polymesh_api_client::IdentityId,
            validators_identity: ::polymesh_api_client::IdentityId,
          },
          #[doc = "An identity has been removed from the permissioned identities pool."]
          #[codec(index = 17u8)]
          PermissionedIdentityRemoved {
            governance_councill_did: ::polymesh_api_client::IdentityId,
            validators_identity: ::polymesh_api_client::IdentityId,
          },
          #[doc = "Remove the nominators from the valid nominators when there CDD expired."]
          #[codec(index = 18u8)]
          InvalidatedNominators {
            governance_councill_did: ::polymesh_api_client::IdentityId,
            governance_councill_account: ::polymesh_api_client::IdentityId,
            expired_nominators: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
          },
          #[doc = "Slashing allowed has been updated."]
          #[codec(index = 19u8)]
          SlashingAllowedForChanged {
            slashing_switch: pallet_staking::types::SlashingSwitch,
          },
          #[doc = "Reward scheduling interrupted."]
          #[codec(index = 20u8)]
          RewardPaymentSchedulingInterrupted {
            account_id: ::polymesh_api_client::AccountId,
            era: u32,
            error: sp_runtime::DispatchError,
          },
          #[doc = "Commission cap has been updated."]
          #[codec(index = 21u8)]
          CommissionCapUpdated {
            governance_councill_did: ::polymesh_api_client::IdentityId,
            old_commission_cap: ::polymesh_api_client::per_things::Perbill,
            new_commission_cap: ::polymesh_api_client::per_things::Perbill,
          },
        }
        impl StakingEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::EraPaid { .. } => "Staking.EraPaid",
              Self::Rewarded { .. } => "Staking.Rewarded",
              Self::Slashed { .. } => "Staking.Slashed",
              Self::SlashReported { .. } => "Staking.SlashReported",
              Self::OldSlashingReportDiscarded { .. } => "Staking.OldSlashingReportDiscarded",
              Self::StakersElected => "Staking.StakersElected",
              Self::Bonded { .. } => "Staking.Bonded",
              Self::Unbonded { .. } => "Staking.Unbonded",
              Self::Withdrawn { .. } => "Staking.Withdrawn",
              Self::Kicked { .. } => "Staking.Kicked",
              Self::StakingElectionFailed => "Staking.StakingElectionFailed",
              Self::Chilled { .. } => "Staking.Chilled",
              Self::PayoutStarted { .. } => "Staking.PayoutStarted",
              Self::ValidatorPrefsSet { .. } => "Staking.ValidatorPrefsSet",
              Self::ForceEra { .. } => "Staking.ForceEra",
              Self::Nominated { .. } => "Staking.Nominated",
              Self::PermissionedIdentityAdded { .. } => "Staking.PermissionedIdentityAdded",
              Self::PermissionedIdentityRemoved { .. } => "Staking.PermissionedIdentityRemoved",
              Self::InvalidatedNominators { .. } => "Staking.InvalidatedNominators",
              Self::SlashingAllowedForChanged { .. } => "Staking.SlashingAllowedForChanged",
              Self::RewardPaymentSchedulingInterrupted { .. } => {
                "Staking.RewardPaymentSchedulingInterrupted"
              }
              Self::CommissionCapUpdated { .. } => "Staking.CommissionCapUpdated",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for StakingEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: EraPaid { .. } => { & ["The era payout has been set; the first balance is the validator-payout; the second is" , "the remainder from the maximum amount of reward." ,] } , Self :: Rewarded { .. } => { & ["The nominator has been rewarded by this amount." ,] } , Self :: Slashed { .. } => { & ["A staker (validator or nominator) has been slashed by the given amount." ,] } , Self :: SlashReported { .. } => { & ["A slash for the given validator, for the given percentage of their stake, at the given" , "era as been reported." ,] } , Self :: OldSlashingReportDiscarded { .. } => { & ["An old slashing report from a prior era was discarded because it could" , "not be processed." ,] } , Self :: StakersElected => { & ["A new set of stakers was elected." ,] } , Self :: Bonded { .. } => { & ["An account has bonded this amount. \\[stash, amount\\]" , "" , "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably," , "it will not be emitted for staking rewards when they are added to stake." ,] } , Self :: Unbonded { .. } => { & ["An account has unbonded this amount." ,] } , Self :: Withdrawn { .. } => { & ["An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`" , "from the unlocking queue." ,] } , Self :: Kicked { .. } => { & ["A nominator has been kicked from a validator." ,] } , Self :: StakingElectionFailed => { & ["The election failed. No new era is planned." ,] } , Self :: Chilled { .. } => { & ["An account has stopped participating as either a validator or nominator." ,] } , Self :: PayoutStarted { .. } => { & ["The stakers' rewards are getting paid." ,] } , Self :: ValidatorPrefsSet { .. } => { & ["A validator has set their preferences." ,] } , Self :: ForceEra { .. } => { & ["A new force era mode was set." ,] } , Self :: Nominated { .. } => { & ["User has updated their nominations." ,] } , Self :: PermissionedIdentityAdded { .. } => { & ["An identity has issued a candidacy for becoming a validator." ,] } , Self :: PermissionedIdentityRemoved { .. } => { & ["An identity has been removed from the permissioned identities pool." ,] } , Self :: InvalidatedNominators { .. } => { & ["Remove the nominators from the valid nominators when there CDD expired." ,] } , Self :: SlashingAllowedForChanged { .. } => { & ["Slashing allowed has been updated." ,] } , Self :: RewardPaymentSchedulingInterrupted { .. } => { & ["Reward scheduling interrupted." ,] } , Self :: CommissionCapUpdated { .. } => { & ["Commission cap has been updated." ,] } , _ => & [""] , }
          }
        }
        impl From<StakingEvent> for &'static str {
          fn from(v: StakingEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&StakingEvent> for &'static str {
          fn from(v: &StakingEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Version(pub u8);
    }
    pub mod slashing {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SlashingSpans {
        pub span_index: u32,
        pub last_start: u32,
        pub last_nonzero_slash: u32,
        pub prior: ::alloc::vec::Vec<u32>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SpanRecord<Balance> {
        pub slashed: Balance,
        pub paid_out: Balance,
      }
    }
    pub mod types {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PermissionedIdentityPrefs {
        pub intended_count: u32,
        pub running_count: u32,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SlashingSwitch {
        #[codec(index = 0u8)]
        Validator,
        #[codec(index = 1u8)]
        ValidatorAndNominator,
        #[codec(index = 2u8)]
        None,
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ActiveEraInfo {
      pub index: u32,
      pub start: Option<u64>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct EraRewardPoints<AccountId: Ord> {
      pub total: u32,
      pub individual: ::alloc::collections::BTreeMap<AccountId, u32>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Exposure<AccountId, Balance> {
      #[codec(compact)]
      pub total: Balance,
      #[codec(compact)]
      pub own: Balance,
      pub others: ::alloc::vec::Vec<pallet_staking::IndividualExposure<AccountId, Balance>>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Forcing {
      #[codec(index = 0u8)]
      NotForcing,
      #[codec(index = 1u8)]
      ForceNew,
      #[codec(index = 2u8)]
      ForceNone,
      #[codec(index = 3u8)]
      ForceAlways,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct IndividualExposure<AccountId, Balance> {
      pub who: AccountId,
      #[codec(compact)]
      pub value: Balance,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Nominations {
      pub targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      pub submitted_in: u32,
      pub suppressed: bool,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RewardDestination<AccountId> {
      #[codec(index = 0u8)]
      Staked,
      #[codec(index = 1u8)]
      Stash,
      #[codec(index = 2u8)]
      Controller,
      #[codec(index = 3u8)]
      Account(AccountId),
      #[codec(index = 4u8)]
      None,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct StakingLedger {
      pub stash: ::polymesh_api_client::AccountId,
      #[codec(compact)]
      pub total: u128,
      #[codec(compact)]
      pub active: u128,
      pub unlocking: ::alloc::vec::Vec<pallet_staking::UnlockChunk<u128>>,
      pub claimed_rewards: ::alloc::vec::Vec<u32>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct UnappliedSlash<AccountId, Balance> {
      pub validator: AccountId,
      pub own: Balance,
      pub others: ::alloc::vec::Vec<(AccountId, Balance)>,
      pub reporters: ::alloc::vec::Vec<AccountId>,
      pub payout: Balance,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct UnlockChunk<Balance> {
      #[codec(compact)]
      pub value: Balance,
      #[codec(compact)]
      pub era: u32,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ValidatorPrefs {
      #[codec(compact)]
      pub commission: ::polymesh_api_client::per_things::Perbill,
      pub blocked: bool,
    }
  }
  pub mod pallet_statistics {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StatisticsCall {
      #[doc = "Set the active asset stat_types."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
      #[doc = "- `stat_types` - the new stat types to replace any existing types."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeLimitReached` - too many stat types enabled for the `asset_id`."]
      #[doc = "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[codec(index = 0u8)]
      set_active_asset_stats {
        asset_id: ::polymesh_api_client::AssetId,
        stat_types: ::alloc::collections::BTreeSet<polymesh_primitives::statistics::StatType>,
      },
      #[doc = "Allow a trusted issuer to init/resync asset/company stats."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
      #[doc = "- `stat_type` - stat type to update."]
      #[doc = "- `values` - Updated values for `stat_type`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeMissing` - `stat_type` is not enabled for the `asset_id`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[codec(index = 1u8)]
      batch_update_asset_stats {
        asset_id: ::polymesh_api_client::AssetId,
        stat_type: polymesh_primitives::statistics::StatType,
        values: ::alloc::collections::BTreeSet<polymesh_primitives::statistics::StatUpdate>,
      },
      #[doc = "Set asset transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
      #[doc = "- `transfer_conditions` - the new transfer condition to replace any existing conditions."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset_id`."]
      #[doc = "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset_id`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[codec(index = 2u8)]
      set_asset_transfer_compliance {
        asset_id: ::polymesh_api_client::AssetId,
        transfer_conditions: ::alloc::collections::BTreeSet<
          polymesh_primitives::transfer_compliance::TransferCondition,
        >,
      },
      #[doc = "Set/unset entities exempt from an asset's transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`."]
      #[doc = "- `is_exempt` - enable/disable exemption for `entities`."]
      #[doc = "- `exempt_key` - the asset and stat type to exempt the `entities` from."]
      #[doc = "- `entities` - the entities to set/unset the exemption for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[codec(index = 3u8)]
      set_entities_exempt {
        is_exempt: bool,
        exempt_key: polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
        entities: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      },
    }
    impl StatisticsCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_active_asset_stats { .. } => "Statistics.set_active_asset_stats",
          Self::batch_update_asset_stats { .. } => "Statistics.batch_update_asset_stats",
          Self::set_asset_transfer_compliance { .. } => "Statistics.set_asset_transfer_compliance",
          Self::set_entities_exempt { .. } => "Statistics.set_entities_exempt",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for StatisticsCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_active_asset_stats { .. } => { & ["Set the active asset stat_types." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `asset_id`." , "- `asset_id` - the [`AssetId`] to change the active stats on." , "- `stat_types` - the new stat types to replace any existing types." , "" , "# Errors" , "- `StatTypeLimitReached` - too many stat types enabled for the `asset_id`." , "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , Self :: batch_update_asset_stats { .. } => { & ["Allow a trusted issuer to init/resync asset/company stats." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `asset_id`." , "- `asset_id` - the [`AssetId`] to change the active stats on." , "- `stat_type` - stat type to update." , "- `values` - Updated values for `stat_type`." , "" , "# Errors" , "- `StatTypeMissing` - `stat_type` is not enabled for the `asset_id`." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , Self :: set_asset_transfer_compliance { .. } => { & ["Set asset transfer compliance rules." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `asset_id`." , "- `asset_id` - the [`AssetId`] to change the active stats on." , "- `transfer_conditions` - the new transfer condition to replace any existing conditions." , "" , "# Errors" , "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset_id`." , "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset_id`." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , Self :: set_entities_exempt { .. } => { & ["Set/unset entities exempt from an asset's transfer compliance rules." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`." , "- `is_exempt` - enable/disable exemption for `entities`." , "- `exempt_key` - the asset and stat type to exempt the `entities` from." , "- `entities` - the entities to set/unset the exemption for." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , _ => & [""] , }
      }
    }
    impl From<StatisticsCall> for &'static str {
      fn from(v: StatisticsCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&StatisticsCall> for &'static str {
      fn from(v: &StatisticsCall) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Statistics module errors."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StatisticsError {
      #[doc = "Invalid transfer [`TransferCondition`] not respected."]
      #[codec(index = 0u8)]
      InvalidTransferStatisticsFailure,
      #[doc = "StatType is not enabled."]
      #[codec(index = 1u8)]
      StatTypeMissing,
      #[doc = "StatType is needed by TransferCondition."]
      #[codec(index = 2u8)]
      StatTypeNeededByTransferCondition,
      #[doc = "A Stattype is in use and can't be removed."]
      #[codec(index = 3u8)]
      CannotRemoveStatTypeInUse,
      #[doc = "The limit of StatTypes allowed for an asset has been reached."]
      #[codec(index = 4u8)]
      StatTypeLimitReached,
      #[doc = "The limit of TransferConditions allowed for an asset has been reached."]
      #[codec(index = 5u8)]
      TransferConditionLimitReached,
      #[doc = "The maximum weight limit for executing the function was exceeded."]
      #[codec(index = 6u8)]
      WeightLimitExceeded,
    }
    impl StatisticsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::InvalidTransferStatisticsFailure => "Statistics.InvalidTransferStatisticsFailure",
          Self::StatTypeMissing => "Statistics.StatTypeMissing",
          Self::StatTypeNeededByTransferCondition => "Statistics.StatTypeNeededByTransferCondition",
          Self::CannotRemoveStatTypeInUse => "Statistics.CannotRemoveStatTypeInUse",
          Self::StatTypeLimitReached => "Statistics.StatTypeLimitReached",
          Self::TransferConditionLimitReached => "Statistics.TransferConditionLimitReached",
          Self::WeightLimitExceeded => "Statistics.WeightLimitExceeded",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for StatisticsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::InvalidTransferStatisticsFailure => {
            &["Invalid transfer [`TransferCondition`] not respected."]
          }
          Self::StatTypeMissing => &["StatType is not enabled."],
          Self::StatTypeNeededByTransferCondition => &["StatType is needed by TransferCondition."],
          Self::CannotRemoveStatTypeInUse => &["A Stattype is in use and can't be removed."],
          Self::StatTypeLimitReached => {
            &["The limit of StatTypes allowed for an asset has been reached."]
          }
          Self::TransferConditionLimitReached => {
            &["The limit of TransferConditions allowed for an asset has been reached."]
          }
          Self::WeightLimitExceeded => {
            &["The maximum weight limit for executing the function was exceeded."]
          }
          _ => &[""],
        }
      }
    }
    impl From<StatisticsError> for &'static str {
      fn from(v: StatisticsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&StatisticsError> for &'static str {
      fn from(v: &StatisticsError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_sto {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StoCall {
      #[doc = "Create a new fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_portfolio` - Portfolio containing the `offering_asset`."]
      #[doc = "* `offering_asset` - Asset being offered."]
      #[doc = "* `raising_portfolio` - Portfolio containing the `raising_asset`."]
      #[doc = "* `raising_asset` - Asset being exchanged for `offering_asset` on investment."]
      #[doc = "* `tiers` - Price tiers to charge investors on investment."]
      #[doc = "* `venue_id` - Venue to handle settlement."]
      #[doc = "* `start` - Fundraiser start time, if `None` the fundraiser will start immediately."]
      #[doc = "* `end` - Fundraiser end time, if `None` the fundraiser will never expire."]
      #[doc = "* `minimum_investment` - Minimum amount of `raising_asset` that an investor needs to spend to invest in this raise."]
      #[doc = "* `fundraiser_name` - Fundraiser name, only used in the UIs."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[codec(index = 0u8)]
      create_fundraiser {
        offering_portfolio: polymesh_primitives::identity_id::PortfolioId,
        offering_asset: ::polymesh_api_client::AssetId,
        raising_portfolio: polymesh_primitives::identity_id::PortfolioId,
        raising_asset: ::polymesh_api_client::AssetId,
        tiers: ::alloc::vec::Vec<pallet_sto::PriceTier>,
        venue_id: polymesh_primitives::settlement::VenueId,
        start: Option<u64>,
        end: Option<u64>,
        minimum_investment: u128,
        fundraiser_name: pallet_sto::FundraiserName,
      },
      #[doc = "Invest in a fundraiser."]
      #[doc = ""]
      #[doc = "* `investment_portfolio` - Portfolio that `offering_asset` will be deposited in."]
      #[doc = "* `funding_portfolio` - Portfolio that will fund the investment."]
      #[doc = "* `offering_asset` - Asset to invest in."]
      #[doc = "* `id` - ID of the fundraiser to invest in."]
      #[doc = "* `purchase_amount` - Amount of `offering_asset` to purchase."]
      #[doc = "* `max_price` - Maximum price to pay per unit of `offering_asset`, If `None`there are no constraints on price."]
      #[doc = "* `receipt` - Off-chain receipt to use instead of on-chain balance in `funding_portfolio`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 1u8)]
      invest {
        investment_portfolio: polymesh_primitives::identity_id::PortfolioId,
        funding_portfolio: polymesh_primitives::identity_id::PortfolioId,
        offering_asset: ::polymesh_api_client::AssetId,
        id: pallet_sto::FundraiserId,
        purchase_amount: u128,
        max_price: Option<u128>,
        receipt: Option<
          polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            sp_runtime::MultiSignature,
          >,
        >,
      },
      #[doc = "Freeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to freeze."]
      #[doc = "* `id` - ID of the fundraiser to freeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 2u8)]
      freeze_fundraiser {
        offering_asset: ::polymesh_api_client::AssetId,
        id: pallet_sto::FundraiserId,
      },
      #[doc = "Unfreeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to unfreeze."]
      #[doc = "* `id` - ID of the fundraiser to unfreeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 3u8)]
      unfreeze_fundraiser {
        offering_asset: ::polymesh_api_client::AssetId,
        id: pallet_sto::FundraiserId,
      },
      #[doc = "Modify the time window a fundraiser is active"]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to modify."]
      #[doc = "* `id` - ID of the fundraiser to modify."]
      #[doc = "* `start` - New start of the fundraiser."]
      #[doc = "* `end` - New end of the fundraiser to modify."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 4u8)]
      modify_fundraiser_window {
        offering_asset: ::polymesh_api_client::AssetId,
        id: pallet_sto::FundraiserId,
        start: u64,
        end: Option<u64>,
      },
      #[doc = "Stop a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to stop."]
      #[doc = "* `id` - ID of the fundraiser to stop."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 5u8)]
      stop {
        offering_asset: ::polymesh_api_client::AssetId,
        id: pallet_sto::FundraiserId,
      },
    }
    impl StoCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_fundraiser { .. } => "Sto.create_fundraiser",
          Self::invest { .. } => "Sto.invest",
          Self::freeze_fundraiser { .. } => "Sto.freeze_fundraiser",
          Self::unfreeze_fundraiser { .. } => "Sto.unfreeze_fundraiser",
          Self::modify_fundraiser_window { .. } => "Sto.modify_fundraiser_window",
          Self::stop { .. } => "Sto.stop",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for StoCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: create_fundraiser { .. } => { & ["Create a new fundraiser." , "" , "* `offering_portfolio` - Portfolio containing the `offering_asset`." , "* `offering_asset` - Asset being offered." , "* `raising_portfolio` - Portfolio containing the `raising_asset`." , "* `raising_asset` - Asset being exchanged for `offering_asset` on investment." , "* `tiers` - Price tiers to charge investors on investment." , "* `venue_id` - Venue to handle settlement." , "* `start` - Fundraiser start time, if `None` the fundraiser will start immediately." , "* `end` - Fundraiser end time, if `None` the fundraiser will never expire." , "* `minimum_investment` - Minimum amount of `raising_asset` that an investor needs to spend to invest in this raise." , "* `fundraiser_name` - Fundraiser name, only used in the UIs." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: invest { .. } => { & ["Invest in a fundraiser." , "" , "* `investment_portfolio` - Portfolio that `offering_asset` will be deposited in." , "* `funding_portfolio` - Portfolio that will fund the investment." , "* `offering_asset` - Asset to invest in." , "* `id` - ID of the fundraiser to invest in." , "* `purchase_amount` - Amount of `offering_asset` to purchase." , "* `max_price` - Maximum price to pay per unit of `offering_asset`, If `None`there are no constraints on price." , "* `receipt` - Off-chain receipt to use instead of on-chain balance in `funding_portfolio`." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: freeze_fundraiser { .. } => { & ["Freeze a fundraiser." , "" , "* `offering_asset` - Asset to freeze." , "* `id` - ID of the fundraiser to freeze." , "" , "# Permissions" , "* Asset" ,] } , Self :: unfreeze_fundraiser { .. } => { & ["Unfreeze a fundraiser." , "" , "* `offering_asset` - Asset to unfreeze." , "* `id` - ID of the fundraiser to unfreeze." , "" , "# Permissions" , "* Asset" ,] } , Self :: modify_fundraiser_window { .. } => { & ["Modify the time window a fundraiser is active" , "" , "* `offering_asset` - Asset to modify." , "* `id` - ID of the fundraiser to modify." , "* `start` - New start of the fundraiser." , "* `end` - New end of the fundraiser to modify." , "" , "# Permissions" , "* Asset" ,] } , Self :: stop { .. } => { & ["Stop a fundraiser." , "" , "* `offering_asset` - Asset to stop." , "* `id` - ID of the fundraiser to stop." , "" , "# Permissions" , "* Asset" ,] } , _ => & [""] , }
      }
    }
    impl From<StoCall> for &'static str {
      fn from(v: StoCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&StoCall> for &'static str {
      fn from(v: &StoCall) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Errors for the Settlement module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StoError {
      #[doc = "Sender does not have required permissions."]
      #[codec(index = 0u8)]
      Unauthorized,
      #[doc = "An arithmetic operation overflowed."]
      #[codec(index = 1u8)]
      Overflow,
      #[doc = "Not enough tokens left for sale."]
      #[codec(index = 2u8)]
      InsufficientTokensRemaining,
      #[doc = "Fundraiser not found."]
      #[codec(index = 3u8)]
      FundraiserNotFound,
      #[doc = "Fundraiser is either frozen or stopped."]
      #[codec(index = 4u8)]
      FundraiserNotLive,
      #[doc = "Fundraiser has been closed/stopped already."]
      #[codec(index = 5u8)]
      FundraiserClosed,
      #[doc = "Interacting with a fundraiser past the end `Moment`."]
      #[codec(index = 6u8)]
      FundraiserExpired,
      #[doc = "An invalid venue provided."]
      #[codec(index = 7u8)]
      InvalidVenue,
      #[doc = "An individual price tier was invalid or a set of price tiers was invalid."]
      #[codec(index = 8u8)]
      InvalidPriceTiers,
      #[doc = "Window (start time, end time) has invalid parameters, e.g start time is after end time."]
      #[codec(index = 9u8)]
      InvalidOfferingWindow,
      #[doc = "Price of the investment exceeded the max price."]
      #[codec(index = 10u8)]
      MaxPriceExceeded,
      #[doc = "Investment amount is lower than minimum investment amount."]
      #[codec(index = 11u8)]
      InvestmentAmountTooLow,
    }
    impl StoError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::Unauthorized => "Sto.Unauthorized",
          Self::Overflow => "Sto.Overflow",
          Self::InsufficientTokensRemaining => "Sto.InsufficientTokensRemaining",
          Self::FundraiserNotFound => "Sto.FundraiserNotFound",
          Self::FundraiserNotLive => "Sto.FundraiserNotLive",
          Self::FundraiserClosed => "Sto.FundraiserClosed",
          Self::FundraiserExpired => "Sto.FundraiserExpired",
          Self::InvalidVenue => "Sto.InvalidVenue",
          Self::InvalidPriceTiers => "Sto.InvalidPriceTiers",
          Self::InvalidOfferingWindow => "Sto.InvalidOfferingWindow",
          Self::MaxPriceExceeded => "Sto.MaxPriceExceeded",
          Self::InvestmentAmountTooLow => "Sto.InvestmentAmountTooLow",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for StoError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: Unauthorized => { & ["Sender does not have required permissions." ,] } , Self :: Overflow => { & ["An arithmetic operation overflowed." ,] } , Self :: InsufficientTokensRemaining => { & ["Not enough tokens left for sale." ,] } , Self :: FundraiserNotFound => { & ["Fundraiser not found." ,] } , Self :: FundraiserNotLive => { & ["Fundraiser is either frozen or stopped." ,] } , Self :: FundraiserClosed => { & ["Fundraiser has been closed/stopped already." ,] } , Self :: FundraiserExpired => { & ["Interacting with a fundraiser past the end `Moment`." ,] } , Self :: InvalidVenue => { & ["An invalid venue provided." ,] } , Self :: InvalidPriceTiers => { & ["An individual price tier was invalid or a set of price tiers was invalid." ,] } , Self :: InvalidOfferingWindow => { & ["Window (start time, end time) has invalid parameters, e.g start time is after end time." ,] } , Self :: MaxPriceExceeded => { & ["Price of the investment exceeded the max price." ,] } , Self :: InvestmentAmountTooLow => { & ["Investment amount is lower than minimum investment amount." ,] } , _ => & [""] , }
      }
    }
    impl From<StoError> for &'static str {
      fn from(v: StoError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&StoError> for &'static str {
      fn from(v: &StoError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Fundraiser<Moment> {
      pub creator: ::polymesh_api_client::IdentityId,
      pub offering_portfolio: polymesh_primitives::identity_id::PortfolioId,
      pub offering_asset: ::polymesh_api_client::AssetId,
      pub raising_portfolio: polymesh_primitives::identity_id::PortfolioId,
      pub raising_asset: ::polymesh_api_client::AssetId,
      pub tiers: ::alloc::vec::Vec<pallet_sto::FundraiserTier>,
      pub venue_id: polymesh_primitives::settlement::VenueId,
      pub start: Moment,
      pub end: Option<Moment>,
      pub status: pallet_sto::FundraiserStatus,
      pub minimum_investment: u128,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct FundraiserId(pub u64);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct FundraiserName(pub ::alloc::vec::Vec<u8>);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum FundraiserStatus {
      #[codec(index = 0u8)]
      Live,
      #[codec(index = 1u8)]
      Frozen,
      #[codec(index = 2u8)]
      Closed,
      #[codec(index = 3u8)]
      ClosedEarly,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct FundraiserTier {
      pub total: u128,
      pub price: u128,
      pub remaining: u128,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PriceTier {
      pub total: u128,
      pub price: u128,
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StoEvent<Moment> {
      #[doc = "A new fundraiser has been created."]
      #[doc = "(Agent DID, fundraiser id, fundraiser name, fundraiser details)"]
      #[codec(index = 0u8)]
      FundraiserCreated(
        ::polymesh_api_client::IdentityId,
        pallet_sto::FundraiserId,
        pallet_sto::FundraiserName,
        pallet_sto::Fundraiser<Moment>,
      ),
      #[doc = "An investor invested in the fundraiser."]
      #[doc = "(Investor, fundraiser_id, offering token, raise token, offering_token_amount, raise_token_amount)"]
      #[codec(index = 1u8)]
      Invested(
        ::polymesh_api_client::IdentityId,
        pallet_sto::FundraiserId,
        ::polymesh_api_client::AssetId,
        ::polymesh_api_client::AssetId,
        u128,
        u128,
      ),
      #[doc = "A fundraiser has been frozen."]
      #[doc = "(Agent DID, fundraiser id)"]
      #[codec(index = 2u8)]
      FundraiserFrozen(::polymesh_api_client::IdentityId, pallet_sto::FundraiserId),
      #[doc = "A fundraiser has been unfrozen."]
      #[doc = "(Agent DID, fundraiser id)"]
      #[codec(index = 3u8)]
      FundraiserUnfrozen(::polymesh_api_client::IdentityId, pallet_sto::FundraiserId),
      #[doc = "A fundraiser window has been modified."]
      #[doc = "(Agent DID, fundraiser id, old_start, old_end, new_start, new_end)"]
      #[codec(index = 4u8)]
      FundraiserWindowModified(
        polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
        pallet_sto::FundraiserId,
        Moment,
        Option<Moment>,
        Moment,
        Option<Moment>,
      ),
      #[doc = "A fundraiser has been stopped."]
      #[doc = "(Agent DID, fundraiser id)"]
      #[codec(index = 5u8)]
      FundraiserClosed(::polymesh_api_client::IdentityId, pallet_sto::FundraiserId),
    }
    impl<Moment> StoEvent<Moment> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::FundraiserCreated(_, _, _, _) => "Sto.FundraiserCreated",
          Self::Invested(_, _, _, _, _, _) => "Sto.Invested",
          Self::FundraiserFrozen(_, _) => "Sto.FundraiserFrozen",
          Self::FundraiserUnfrozen(_, _) => "Sto.FundraiserUnfrozen",
          Self::FundraiserWindowModified(_, _, _, _, _, _) => "Sto.FundraiserWindowModified",
          Self::FundraiserClosed(_, _) => "Sto.FundraiserClosed",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<Moment> ::polymesh_api_client::EnumInfo for StoEvent<Moment> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: FundraiserCreated (_ , _ , _ , _) => { & ["A new fundraiser has been created." , "(Agent DID, fundraiser id, fundraiser name, fundraiser details)" ,] } , Self :: Invested (_ , _ , _ , _ , _ , _) => { & ["An investor invested in the fundraiser." , "(Investor, fundraiser_id, offering token, raise token, offering_token_amount, raise_token_amount)" ,] } , Self :: FundraiserFrozen (_ , _) => { & ["A fundraiser has been frozen." , "(Agent DID, fundraiser id)" ,] } , Self :: FundraiserUnfrozen (_ , _) => { & ["A fundraiser has been unfrozen." , "(Agent DID, fundraiser id)" ,] } , Self :: FundraiserWindowModified (_ , _ , _ , _ , _ , _) => { & ["A fundraiser window has been modified." , "(Agent DID, fundraiser id, old_start, old_end, new_start, new_end)" ,] } , Self :: FundraiserClosed (_ , _) => { & ["A fundraiser has been stopped." , "(Agent DID, fundraiser id)" ,] } , _ => & [""] , }
      }
    }
    impl<Moment> From<StoEvent<Moment>> for &'static str {
      fn from(v: StoEvent<Moment>) -> Self {
        v.as_static_str()
      }
    }
    impl<Moment> From<&StoEvent<Moment>> for &'static str {
      fn from(v: &StoEvent<Moment>) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod pallet_timestamp {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum TimestampCall {
        #[doc = "Set the current time."]
        #[doc = ""]
        #[doc = "This call should be invoked exactly once per block. It will panic at the finalization"]
        #[doc = "phase, if this call hasn't been invoked by that time."]
        #[doc = ""]
        #[doc = "The timestamp should be greater than the previous one by the amount specified by"]
        #[doc = "`MinimumPeriod`."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be `Inherent`."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"]
        #[doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"]
        #[doc = "  `on_finalize`)"]
        #[doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."]
        #[codec(index = 0u8)]
        set {
          #[codec(compact)]
          now: u64,
        },
      }
      impl TimestampCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::set { .. } => "Timestamp.set",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for TimestampCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: set { .. } => { & ["Set the current time." , "" , "This call should be invoked exactly once per block. It will panic at the finalization" , "phase, if this call hasn't been invoked by that time." , "" , "The timestamp should be greater than the previous one by the amount specified by" , "`MinimumPeriod`." , "" , "The dispatch origin for this call must be `Inherent`." , "" , "## Complexity" , "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)" , "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in" , "  `on_finalize`)" , "- 1 event handler `on_timestamp_set`. Must be `O(1)`." ,] } , _ => & [""] , }
        }
      }
      impl From<TimestampCall> for &'static str {
        fn from(v: TimestampCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&TimestampCall> for &'static str {
        fn from(v: &TimestampCall) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod pallet_transaction_payment {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum TransactionPaymentCall {
        #[codec(index = 0u8)]
        set_disable_fees { value: bool },
      }
      impl TransactionPaymentCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::set_disable_fees { .. } => "TransactionPayment.set_disable_fees",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for TransactionPaymentCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::set_disable_fees { .. } => &[""],
            _ => &[""],
          }
        }
      }
      impl From<TransactionPaymentCall> for &'static str {
        fn from(v: TransactionPaymentCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&TransactionPaymentCall> for &'static str {
        fn from(v: &TransactionPaymentCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum TransactionPaymentEvent {
        #[doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"]
        #[doc = "has been paid by `who`."]
        #[codec(index = 0u8)]
        TransactionFeePaid {
          who: ::polymesh_api_client::AccountId,
          actual_fee: u128,
          tip: u128,
        },
      }
      impl TransactionPaymentEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::TransactionFeePaid { .. } => "TransactionPayment.TransactionFeePaid",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for TransactionPaymentEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: TransactionFeePaid { .. } => { & ["A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee," , "has been paid by `who`." ,] } , _ => & [""] , }
        }
      }
      impl From<TransactionPaymentEvent> for &'static str {
        fn from(v: TransactionPaymentEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&TransactionPaymentEvent> for &'static str {
        fn from(v: &TransactionPaymentEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ChargeTransactionPayment(#[codec(compact)] pub u128);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Releases {
      #[codec(index = 0u8)]
      V1Ancient,
      #[codec(index = 1u8)]
      V2,
    }
  }
  pub mod pallet_treasury {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TreasuryCall {
      #[doc = "It transfers balances from treasury to each of beneficiaries and the specific amount"]
      #[doc = "for each of them."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = "* `BadOrigin`: Only root can execute transaction."]
      #[doc = "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries."]
      #[doc = "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity."]
      #[codec(index = 0u8)]
      disbursement {
        beneficiaries: ::alloc::vec::Vec<polymesh_primitives::Beneficiary<u128>>,
      },
      #[doc = "It transfers the specific `amount` from `origin` account into treasury."]
      #[doc = ""]
      #[doc = "Only accounts which are associated to an identity can make a donation to treasury."]
      #[codec(index = 1u8)]
      reimbursement { amount: u128 },
    }
    impl TreasuryCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::disbursement { .. } => "Treasury.disbursement",
          Self::reimbursement { .. } => "Treasury.reimbursement",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for TreasuryCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: disbursement { .. } => { & ["It transfers balances from treasury to each of beneficiaries and the specific amount" , "for each of them." , "" , "# Error" , "* `BadOrigin`: Only root can execute transaction." , "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries." , "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity." ,] } , Self :: reimbursement { .. } => { & ["It transfers the specific `amount` from `origin` account into treasury." , "" , "Only accounts which are associated to an identity can make a donation to treasury." ,] } , _ => & [""] , }
      }
    }
    impl From<TreasuryCall> for &'static str {
      fn from(v: TreasuryCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&TreasuryCall> for &'static str {
      fn from(v: &TreasuryCall) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Error for the treasury module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TreasuryError {
      #[doc = "Proposer's balance is too low."]
      #[codec(index = 0u8)]
      InsufficientBalance,
      #[doc = "Invalid identity for disbursement."]
      #[codec(index = 1u8)]
      InvalidIdentity,
    }
    impl TreasuryError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::InsufficientBalance => "Treasury.InsufficientBalance",
          Self::InvalidIdentity => "Treasury.InvalidIdentity",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for TreasuryError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::InsufficientBalance => &["Proposer's balance is too low."],
          Self::InvalidIdentity => &["Invalid identity for disbursement."],
          _ => &[""],
        }
      }
    }
    impl From<TreasuryError> for &'static str {
      fn from(v: TreasuryError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&TreasuryError> for &'static str {
      fn from(v: &TreasuryError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TreasuryEvent<Balance, AccountId> {
      #[doc = "Disbursement to a target Identity."]
      #[doc = ""]
      #[doc = "(treasury identity, target identity, target primary key, amount)"]
      #[codec(index = 0u8)]
      TreasuryDisbursement(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::IdentityId,
        AccountId,
        Balance,
      ),
      #[doc = "Disbursement to a target Identity failed."]
      #[doc = ""]
      #[doc = "(treasury identity, target identity, target primary key, amount)"]
      #[codec(index = 1u8)]
      TreasuryDisbursementFailed(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::IdentityId,
        AccountId,
        Balance,
      ),
      #[doc = "Treasury reimbursement."]
      #[doc = ""]
      #[doc = "(source identity, amount)"]
      #[codec(index = 2u8)]
      TreasuryReimbursement(::polymesh_api_client::IdentityId, Balance),
    }
    impl<Balance, AccountId> TreasuryEvent<Balance, AccountId> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::TreasuryDisbursement(_, _, _, _) => "Treasury.TreasuryDisbursement",
          Self::TreasuryDisbursementFailed(_, _, _, _) => "Treasury.TreasuryDisbursementFailed",
          Self::TreasuryReimbursement(_, _) => "Treasury.TreasuryReimbursement",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<Balance, AccountId> ::polymesh_api_client::EnumInfo for TreasuryEvent<Balance, AccountId> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::TreasuryDisbursement(_, _, _, _) => &[
            "Disbursement to a target Identity.",
            "",
            "(treasury identity, target identity, target primary key, amount)",
          ],
          Self::TreasuryDisbursementFailed(_, _, _, _) => &[
            "Disbursement to a target Identity failed.",
            "",
            "(treasury identity, target identity, target primary key, amount)",
          ],
          Self::TreasuryReimbursement(_, _) => {
            &["Treasury reimbursement.", "", "(source identity, amount)"]
          }
          _ => &[""],
        }
      }
    }
    impl<Balance, AccountId> From<TreasuryEvent<Balance, AccountId>> for &'static str {
      fn from(v: TreasuryEvent<Balance, AccountId>) -> Self {
        v.as_static_str()
      }
    }
    impl<Balance, AccountId> From<&TreasuryEvent<Balance, AccountId>> for &'static str {
      fn from(v: &TreasuryEvent<Balance, AccountId>) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_utility {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum UtilityCall {
        #[doc = "Send a batch of dispatch calls."]
        #[doc = ""]
        #[doc = "May be called from any origin except `None`."]
        #[doc = ""]
        #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
        #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
        #[doc = ""]
        #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
        #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- O(C) where C is the number of calls to be batched."]
        #[doc = ""]
        #[doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"]
        #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
        #[doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"]
        #[doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"]
        #[doc = "event is deposited."]
        #[codec(index = 0u8)]
        batch {
          calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
        },
        #[doc = "Relay a call for a target from an origin"]
        #[doc = ""]
        #[doc = "Relaying in this context refers to the ability of origin to make a call on behalf of"]
        #[doc = "target."]
        #[doc = ""]
        #[doc = "Fees are charged to origin"]
        #[doc = ""]
        #[doc = "# Parameters"]
        #[doc = "- `target`: Account to be relayed"]
        #[doc = "- `signature`: Signature from target authorizing the relay"]
        #[doc = "- `call`: Call to be relayed on behalf of target"]
        #[doc = ""]
        #[doc = "POLYMESH: added."]
        #[codec(index = 1u8)]
        relay_tx {
          target: ::polymesh_api_client::AccountId,
          signature: sp_runtime::MultiSignature,
          call: pallet_utility::UniqueCall<runtime::RuntimeCall>,
        },
        #[doc = "Send a batch of dispatch calls and atomically execute them."]
        #[doc = "The whole transaction will rollback and fail if any of the calls failed."]
        #[doc = ""]
        #[doc = "May be called from any origin except `None`."]
        #[doc = ""]
        #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
        #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
        #[doc = ""]
        #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
        #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- O(C) where C is the number of calls to be batched."]
        #[codec(index = 2u8)]
        batch_all {
          calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
        },
        #[doc = "Dispatches a function call with a provided origin."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Root_."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- O(1)."]
        #[codec(index = 3u8)]
        dispatch_as {
          as_origin: ::alloc::boxed::Box<runtime::OriginCaller>,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
        #[doc = "Send a batch of dispatch calls."]
        #[doc = "Unlike `batch`, it allows errors and won't interrupt."]
        #[doc = ""]
        #[doc = "May be called from any origin except `None`."]
        #[doc = ""]
        #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
        #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
        #[doc = ""]
        #[doc = "If origin is root then the calls are dispatch without checking origin filter. (This"]
        #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- O(C) where C is the number of calls to be batched."]
        #[codec(index = 4u8)]
        force_batch {
          calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
        },
        #[doc = "Dispatch a function call with a specified weight."]
        #[doc = ""]
        #[doc = "This function does not check the weight of the call, and instead allows the"]
        #[doc = "Root origin to specify the weight of the call."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Root_."]
        #[codec(index = 5u8)]
        with_weight {
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
          weight: ::polymesh_api_client::sp_weights::Weight,
        },
        #[doc = "Send a call through an indexed pseudonym of the sender."]
        #[doc = ""]
        #[doc = "Filter from origin are passed along. The call will be dispatched with an origin which"]
        #[doc = "use the same filter as the origin of this call."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Signed_."]
        #[codec(index = 9u8)]
        as_derivative {
          index: u16,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
      }
      impl UtilityCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::batch { .. } => "Utility.batch",
            Self::relay_tx { .. } => "Utility.relay_tx",
            Self::batch_all { .. } => "Utility.batch_all",
            Self::dispatch_as { .. } => "Utility.dispatch_as",
            Self::force_batch { .. } => "Utility.force_batch",
            Self::with_weight { .. } => "Utility.with_weight",
            Self::as_derivative { .. } => "Utility.as_derivative",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for UtilityCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: batch { .. } => { & ["Send a batch of dispatch calls." , "" , "May be called from any origin except `None`." , "" , "- `calls`: The calls to be dispatched from the same origin. The number of call must not" , "  exceed the constant: `batched_calls_limit` (available in constant metadata)." , "" , "If origin is root then the calls are dispatched without checking origin filter. (This" , "includes bypassing `frame_system::Config::BaseCallFilter`)." , "" , "## Complexity" , "- O(C) where C is the number of calls to be batched." , "" , "This will return `Ok` in all circumstances. To determine the success of the batch, an" , "event is deposited. If a call failed and the batch was interrupted, then the" , "`BatchInterrupted` event is deposited, along with the number of successful calls made" , "and the error of the failed call. If all were successful, then the `BatchCompleted`" , "event is deposited." ,] } , Self :: relay_tx { .. } => { & ["Relay a call for a target from an origin" , "" , "Relaying in this context refers to the ability of origin to make a call on behalf of" , "target." , "" , "Fees are charged to origin" , "" , "# Parameters" , "- `target`: Account to be relayed" , "- `signature`: Signature from target authorizing the relay" , "- `call`: Call to be relayed on behalf of target" , "" , "POLYMESH: added." ,] } , Self :: batch_all { .. } => { & ["Send a batch of dispatch calls and atomically execute them." , "The whole transaction will rollback and fail if any of the calls failed." , "" , "May be called from any origin except `None`." , "" , "- `calls`: The calls to be dispatched from the same origin. The number of call must not" , "  exceed the constant: `batched_calls_limit` (available in constant metadata)." , "" , "If origin is root then the calls are dispatched without checking origin filter. (This" , "includes bypassing `frame_system::Config::BaseCallFilter`)." , "" , "## Complexity" , "- O(C) where C is the number of calls to be batched." ,] } , Self :: dispatch_as { .. } => { & ["Dispatches a function call with a provided origin." , "" , "The dispatch origin for this call must be _Root_." , "" , "## Complexity" , "- O(1)." ,] } , Self :: force_batch { .. } => { & ["Send a batch of dispatch calls." , "Unlike `batch`, it allows errors and won't interrupt." , "" , "May be called from any origin except `None`." , "" , "- `calls`: The calls to be dispatched from the same origin. The number of call must not" , "  exceed the constant: `batched_calls_limit` (available in constant metadata)." , "" , "If origin is root then the calls are dispatch without checking origin filter. (This" , "includes bypassing `frame_system::Config::BaseCallFilter`)." , "" , "## Complexity" , "- O(C) where C is the number of calls to be batched." ,] } , Self :: with_weight { .. } => { & ["Dispatch a function call with a specified weight." , "" , "This function does not check the weight of the call, and instead allows the" , "Root origin to specify the weight of the call." , "" , "The dispatch origin for this call must be _Root_." ,] } , Self :: as_derivative { .. } => { & ["Send a call through an indexed pseudonym of the sender." , "" , "Filter from origin are passed along. The call will be dispatched with an origin which" , "use the same filter as the origin of this call." , "" , "The dispatch origin for this call must be _Signed_." ,] } , _ => & [""] , }
        }
      }
      impl From<UtilityCall> for &'static str {
        fn from(v: UtilityCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&UtilityCall> for &'static str {
        fn from(v: &UtilityCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum UtilityError {
        #[doc = "Too many calls batched."]
        #[codec(index = 0u8)]
        TooManyCalls,
        #[doc = "Offchain signature is invalid"]
        #[doc = "POLYMESH error"]
        #[codec(index = 1u8)]
        InvalidSignature,
        #[doc = "Target does not have a valid CDD"]
        #[doc = "POLYMESH error"]
        #[codec(index = 2u8)]
        TargetCddMissing,
        #[doc = "Provided nonce was invalid"]
        #[doc = "If the provided nonce < current nonce, the call was already executed"]
        #[doc = "If the provided nonce > current nonce, the call(s) before the current failed to execute"]
        #[doc = "POLYMESH error"]
        #[codec(index = 3u8)]
        InvalidNonce,
        #[doc = "Decoding derivative account Id failed."]
        #[codec(index = 4u8)]
        UnableToDeriveAccountId,
      }
      impl UtilityError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::TooManyCalls => "Utility.TooManyCalls",
            Self::InvalidSignature => "Utility.InvalidSignature",
            Self::TargetCddMissing => "Utility.TargetCddMissing",
            Self::InvalidNonce => "Utility.InvalidNonce",
            Self::UnableToDeriveAccountId => "Utility.UnableToDeriveAccountId",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for UtilityError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: TooManyCalls => { & ["Too many calls batched." ,] } , Self :: InvalidSignature => { & ["Offchain signature is invalid" , "POLYMESH error" ,] } , Self :: TargetCddMissing => { & ["Target does not have a valid CDD" , "POLYMESH error" ,] } , Self :: InvalidNonce => { & ["Provided nonce was invalid" , "If the provided nonce < current nonce, the call was already executed" , "If the provided nonce > current nonce, the call(s) before the current failed to execute" , "POLYMESH error" ,] } , Self :: UnableToDeriveAccountId => { & ["Decoding derivative account Id failed." ,] } , _ => & [""] , }
        }
      }
      impl From<UtilityError> for &'static str {
        fn from(v: UtilityError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&UtilityError> for &'static str {
        fn from(v: &UtilityError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum UtilityEvent {
        #[doc = "Batch of dispatches did not complete fully. Index of first failing dispatch given, as"]
        #[doc = "well as the error."]
        #[codec(index = 0u8)]
        BatchInterrupted {
          index: u32,
          error: sp_runtime::DispatchError,
        },
        #[doc = "Batch of dispatches completed fully with no error."]
        #[codec(index = 1u8)]
        BatchCompleted,
        #[doc = "Batch of dispatches completed but has errors."]
        #[codec(index = 2u8)]
        BatchCompletedWithErrors,
        #[doc = "A single item within a Batch of dispatches has completed with no error."]
        #[codec(index = 3u8)]
        ItemCompleted,
        #[doc = "A single item within a Batch of dispatches has completed with error."]
        #[codec(index = 4u8)]
        ItemFailed { error: sp_runtime::DispatchError },
        #[doc = "A call was dispatched."]
        #[codec(index = 5u8)]
        DispatchedAs {
          result: Result<(), sp_runtime::DispatchError>,
        },
        #[doc = "Relayed transaction."]
        #[doc = "POLYMESH: event."]
        #[codec(index = 6u8)]
        RelayedTx {
          caller_did: ::polymesh_api_client::IdentityId,
          target: ::polymesh_api_client::AccountId,
          result: Result<(), sp_runtime::DispatchError>,
        },
      }
      impl UtilityEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::BatchInterrupted { .. } => "Utility.BatchInterrupted",
            Self::BatchCompleted => "Utility.BatchCompleted",
            Self::BatchCompletedWithErrors => "Utility.BatchCompletedWithErrors",
            Self::ItemCompleted => "Utility.ItemCompleted",
            Self::ItemFailed { .. } => "Utility.ItemFailed",
            Self::DispatchedAs { .. } => "Utility.DispatchedAs",
            Self::RelayedTx { .. } => "Utility.RelayedTx",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for UtilityEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: BatchInterrupted { .. } => { & ["Batch of dispatches did not complete fully. Index of first failing dispatch given, as" , "well as the error." ,] } , Self :: BatchCompleted => { & ["Batch of dispatches completed fully with no error." ,] } , Self :: BatchCompletedWithErrors => { & ["Batch of dispatches completed but has errors." ,] } , Self :: ItemCompleted => { & ["A single item within a Batch of dispatches has completed with no error." ,] } , Self :: ItemFailed { .. } => { & ["A single item within a Batch of dispatches has completed with error." ,] } , Self :: DispatchedAs { .. } => { & ["A call was dispatched." ,] } , Self :: RelayedTx { .. } => { & ["Relayed transaction." , "POLYMESH: event." ,] } , _ => & [""] , }
        }
      }
      impl From<UtilityEvent> for &'static str {
        fn from(v: UtilityEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&UtilityEvent> for &'static str {
        fn from(v: &UtilityEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct UniqueCall<C> {
      pub nonce: u64,
      pub call: ::alloc::boxed::Box<C>,
    }
  }
  pub mod polymesh_common_utilities {
    use super::*;
    pub mod protocol_fee {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ProtocolOp {
        #[codec(index = 0u8)]
        AssetRegisterTicker,
        #[codec(index = 1u8)]
        AssetIssue,
        #[codec(index = 2u8)]
        AssetAddDocuments,
        #[codec(index = 3u8)]
        AssetCreateAsset,
        #[codec(index = 4u8)]
        CheckpointCreateSchedule,
        #[codec(index = 5u8)]
        ComplianceManagerAddComplianceRequirement,
        #[codec(index = 6u8)]
        IdentityCddRegisterDid,
        #[codec(index = 7u8)]
        IdentityAddClaim,
        #[codec(index = 8u8)]
        IdentityAddSecondaryKeysWithAuthorization,
        #[codec(index = 9u8)]
        PipsPropose,
        #[codec(index = 10u8)]
        ContractsPutCode,
        #[codec(index = 11u8)]
        CorporateBallotAttachBallot,
        #[codec(index = 12u8)]
        CapitalDistributionDistribute,
        #[codec(index = 13u8)]
        NFTCreateCollection,
        #[codec(index = 14u8)]
        NFTMint,
        #[codec(index = 15u8)]
        IdentityCreateChildIdentity,
      }
    }
    pub mod traits {
      use super::*;
      pub mod asset {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum AssetEvent<Moment> {
          #[doc = "Event for creation of the asset."]
          #[doc = "caller DID/ owner DID, AssetId, divisibility, asset type, beneficiary DID, asset name, identifiers, funding round"]
          #[codec(index = 0u8)]
          AssetCreated(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            bool,
            polymesh_primitives::asset::AssetType,
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::asset::AssetName,
            ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
            Option<polymesh_primitives::asset::FundingRoundName>,
          ),
          #[doc = "Event emitted when any token identifiers are updated."]
          #[doc = "caller DID, AssetId, a vector of (identifier type, identifier value)"]
          #[codec(index = 1u8)]
          IdentifiersUpdated(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
          ),
          #[doc = "Event for change in divisibility."]
          #[doc = "caller DID, AssetId, divisibility"]
          #[codec(index = 2u8)]
          DivisibilityChanged(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            bool,
          ),
          #[doc = "Emit when ticker is registered."]
          #[doc = "caller DID / ticker owner did, ticker, ticker owner, expiry"]
          #[codec(index = 3u8)]
          TickerRegistered(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            Option<Moment>,
          ),
          #[doc = "Emit when ticker is transferred."]
          #[doc = "caller DID / ticker transferred to DID, ticker, from"]
          #[codec(index = 4u8)]
          TickerTransferred(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "Emit when token ownership is transferred."]
          #[doc = "caller DID / token ownership transferred to DID, AssetId, from"]
          #[codec(index = 5u8)]
          AssetOwnershipTransferred(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "An event emitted when an asset is frozen."]
          #[doc = "Parameter: caller DID, AssetId."]
          #[codec(index = 6u8)]
          AssetFrozen(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
          ),
          #[doc = "An event emitted when an asset is unfrozen."]
          #[doc = "Parameter: caller DID, AssetId."]
          #[codec(index = 7u8)]
          AssetUnfrozen(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
          ),
          #[doc = "An event emitted when a token is renamed."]
          #[doc = "Parameters: caller DID, AssetId, new token name."]
          #[codec(index = 8u8)]
          AssetRenamed(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::asset::AssetName,
          ),
          #[doc = "An event carrying the name of the current funding round of an asset."]
          #[doc = "Parameters: caller DID, AssetId, funding round name."]
          #[codec(index = 9u8)]
          FundingRoundSet(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::asset::FundingRoundName,
          ),
          #[doc = "A new document attached to an asset"]
          #[codec(index = 10u8)]
          DocumentAdded(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::document::DocumentId,
            polymesh_primitives::document::Document,
          ),
          #[doc = "A document removed from an asset"]
          #[codec(index = 11u8)]
          DocumentRemoved(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::document::DocumentId,
          ),
          #[doc = "Event for when a forced transfer takes place."]
          #[doc = "caller DID/ controller DID, ExtensionRemoved, Portfolio of token holder, value."]
          #[codec(index = 12u8)]
          ControllerTransfer(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::identity_id::PortfolioId,
            u128,
          ),
          #[doc = "A custom asset type already exists on-chain."]
          #[doc = "caller DID, the ID of the custom asset type, the string contents registered."]
          #[codec(index = 13u8)]
          CustomAssetTypeExists(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::asset::CustomAssetTypeId,
            ::alloc::vec::Vec<u8>,
          ),
          #[doc = "A custom asset type was registered on-chain."]
          #[doc = "caller DID, the ID of the custom asset type, the string contents registered."]
          #[codec(index = 14u8)]
          CustomAssetTypeRegistered(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::asset::CustomAssetTypeId,
            ::alloc::vec::Vec<u8>,
          ),
          #[doc = "Set asset metadata value."]
          #[doc = "(Caller DID, AssetId, metadata value, optional value details)"]
          #[codec(index = 15u8)]
          SetAssetMetadataValue(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::asset_metadata::AssetMetadataValue,
            Option<polymesh_primitives::asset_metadata::AssetMetadataValueDetail<Moment>>,
          ),
          #[doc = "Set asset metadata value details (expire, lock status)."]
          #[doc = "(Caller DID, AssetId, value details)"]
          #[codec(index = 16u8)]
          SetAssetMetadataValueDetails(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::asset_metadata::AssetMetadataValueDetail<Moment>,
          ),
          #[doc = "Register asset metadata local type."]
          #[doc = "(Caller DID, AssetId, Local type name, Local type key, type specs)"]
          #[codec(index = 17u8)]
          RegisterAssetMetadataLocalType(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::asset_metadata::AssetMetadataName,
            polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
            polymesh_primitives::asset_metadata::AssetMetadataSpec,
          ),
          #[doc = "Register asset metadata global type."]
          #[doc = "(Global type name, Global type key, type specs)"]
          #[codec(index = 18u8)]
          RegisterAssetMetadataGlobalType(
            polymesh_primitives::asset_metadata::AssetMetadataName,
            polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
            polymesh_primitives::asset_metadata::AssetMetadataSpec,
          ),
          #[doc = "An event emitted when the type of an asset changed."]
          #[doc = "Parameters: caller DID, AssetId, new token type."]
          #[codec(index = 19u8)]
          AssetTypeChanged(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::asset::AssetType,
          ),
          #[doc = "An event emitted when a local metadata key has been removed."]
          #[doc = "Parameters: caller AssetId, Local type name"]
          #[codec(index = 20u8)]
          LocalMetadataKeyDeleted(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
          ),
          #[doc = "An event emitted when a local metadata value has been removed."]
          #[doc = "Parameters: caller AssetId, Local type name"]
          #[codec(index = 21u8)]
          MetadataValueDeleted(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::asset_metadata::AssetMetadataKey,
          ),
          #[doc = "Emitted when Tokens were issued, redeemed or transferred."]
          #[doc = "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`AssetId`] for the token, the balance that was issued/transferred/redeemed,"]
          #[doc = "the [`PortfolioId`] of the source, the [`PortfolioId`] of the destination and the [`PortfolioUpdateReason`]."]
          #[codec(index = 22u8)]
          AssetBalanceUpdated(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            u128,
            Option<polymesh_primitives::identity_id::PortfolioId>,
            Option<polymesh_primitives::identity_id::PortfolioId>,
            polymesh_primitives::portfolio::PortfolioUpdateReason,
          ),
          #[doc = "An asset has been added to the list of pre aprroved receivement (valid for all identities)."]
          #[doc = "Parameters: [`AssetId`] of the pre approved asset."]
          #[codec(index = 23u8)]
          AssetAffirmationExemption(::polymesh_api_client::AssetId),
          #[doc = "An asset has been removed from the list of pre aprroved receivement (valid for all identities)."]
          #[doc = "Parameters: [`AssetId`] of the asset."]
          #[codec(index = 24u8)]
          RemoveAssetAffirmationExemption(::polymesh_api_client::AssetId),
          #[doc = "An identity has added an asset to the list of pre aprroved receivement."]
          #[doc = "Parameters: [`IdentityId`] of caller, [`AssetId`] of the pre approved asset."]
          #[codec(index = 25u8)]
          PreApprovedAsset(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
          ),
          #[doc = "An identity has removed an asset to the list of pre aprroved receivement."]
          #[doc = "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset."]
          #[codec(index = 26u8)]
          RemovePreApprovedAsset(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
          ),
          #[doc = "An identity has added mandatory mediators to an asset."]
          #[doc = "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset, the identity of all mediators added."]
          #[codec(index = 27u8)]
          AssetMediatorsAdded(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
          ),
          #[doc = "An identity has removed mediators from an asset."]
          #[doc = "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset, the identity of all mediators removed."]
          #[codec(index = 28u8)]
          AssetMediatorsRemoved(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
          ),
          #[doc = "An identity has linked a ticker to an asset."]
          #[doc = "Parameters: [`IdentityId`] of caller, [`Ticker`] of the asset, the asset identifier [`AssetId`]."]
          #[codec(index = 29u8)]
          TickerLinkedToAsset(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::polymesh_api_client::AssetId,
          ),
          #[doc = "An identity has unlinked a ticker from an asset."]
          #[doc = "Parameters: [`IdentityId`] of caller, unlinked [`Ticker`], the asset identifier [`AssetId`]."]
          #[codec(index = 30u8)]
          TickerUnlinkedFromAsset(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::polymesh_api_client::AssetId,
          ),
        }
        impl<Moment> AssetEvent<Moment> {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::AssetCreated(_, _, _, _, _, _, _, _) => "Asset.AssetCreated",
              Self::IdentifiersUpdated(_, _, _) => "Asset.IdentifiersUpdated",
              Self::DivisibilityChanged(_, _, _) => "Asset.DivisibilityChanged",
              Self::TickerRegistered(_, _, _) => "Asset.TickerRegistered",
              Self::TickerTransferred(_, _, _) => "Asset.TickerTransferred",
              Self::AssetOwnershipTransferred(_, _, _) => "Asset.AssetOwnershipTransferred",
              Self::AssetFrozen(_, _) => "Asset.AssetFrozen",
              Self::AssetUnfrozen(_, _) => "Asset.AssetUnfrozen",
              Self::AssetRenamed(_, _, _) => "Asset.AssetRenamed",
              Self::FundingRoundSet(_, _, _) => "Asset.FundingRoundSet",
              Self::DocumentAdded(_, _, _, _) => "Asset.DocumentAdded",
              Self::DocumentRemoved(_, _, _) => "Asset.DocumentRemoved",
              Self::ControllerTransfer(_, _, _, _) => "Asset.ControllerTransfer",
              Self::CustomAssetTypeExists(_, _, _) => "Asset.CustomAssetTypeExists",
              Self::CustomAssetTypeRegistered(_, _, _) => "Asset.CustomAssetTypeRegistered",
              Self::SetAssetMetadataValue(_, _, _, _) => "Asset.SetAssetMetadataValue",
              Self::SetAssetMetadataValueDetails(_, _, _) => "Asset.SetAssetMetadataValueDetails",
              Self::RegisterAssetMetadataLocalType(_, _, _, _, _) => {
                "Asset.RegisterAssetMetadataLocalType"
              }
              Self::RegisterAssetMetadataGlobalType(_, _, _) => {
                "Asset.RegisterAssetMetadataGlobalType"
              }
              Self::AssetTypeChanged(_, _, _) => "Asset.AssetTypeChanged",
              Self::LocalMetadataKeyDeleted(_, _, _) => "Asset.LocalMetadataKeyDeleted",
              Self::MetadataValueDeleted(_, _, _) => "Asset.MetadataValueDeleted",
              Self::AssetBalanceUpdated(_, _, _, _, _, _) => "Asset.AssetBalanceUpdated",
              Self::AssetAffirmationExemption(_) => "Asset.AssetAffirmationExemption",
              Self::RemoveAssetAffirmationExemption(_) => "Asset.RemoveAssetAffirmationExemption",
              Self::PreApprovedAsset(_, _) => "Asset.PreApprovedAsset",
              Self::RemovePreApprovedAsset(_, _) => "Asset.RemovePreApprovedAsset",
              Self::AssetMediatorsAdded(_, _, _) => "Asset.AssetMediatorsAdded",
              Self::AssetMediatorsRemoved(_, _, _) => "Asset.AssetMediatorsRemoved",
              Self::TickerLinkedToAsset(_, _, _) => "Asset.TickerLinkedToAsset",
              Self::TickerUnlinkedFromAsset(_, _, _) => "Asset.TickerUnlinkedFromAsset",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl<Moment> ::polymesh_api_client::EnumInfo for AssetEvent<Moment> {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: AssetCreated (_ , _ , _ , _ , _ , _ , _ , _) => { & ["Event for creation of the asset." , "caller DID/ owner DID, AssetId, divisibility, asset type, beneficiary DID, asset name, identifiers, funding round" ,] } , Self :: IdentifiersUpdated (_ , _ , _) => { & ["Event emitted when any token identifiers are updated." , "caller DID, AssetId, a vector of (identifier type, identifier value)" ,] } , Self :: DivisibilityChanged (_ , _ , _) => { & ["Event for change in divisibility." , "caller DID, AssetId, divisibility" ,] } , Self :: TickerRegistered (_ , _ , _) => { & ["Emit when ticker is registered." , "caller DID / ticker owner did, ticker, ticker owner, expiry" ,] } , Self :: TickerTransferred (_ , _ , _) => { & ["Emit when ticker is transferred." , "caller DID / ticker transferred to DID, ticker, from" ,] } , Self :: AssetOwnershipTransferred (_ , _ , _) => { & ["Emit when token ownership is transferred." , "caller DID / token ownership transferred to DID, AssetId, from" ,] } , Self :: AssetFrozen (_ , _) => { & ["An event emitted when an asset is frozen." , "Parameter: caller DID, AssetId." ,] } , Self :: AssetUnfrozen (_ , _) => { & ["An event emitted when an asset is unfrozen." , "Parameter: caller DID, AssetId." ,] } , Self :: AssetRenamed (_ , _ , _) => { & ["An event emitted when a token is renamed." , "Parameters: caller DID, AssetId, new token name." ,] } , Self :: FundingRoundSet (_ , _ , _) => { & ["An event carrying the name of the current funding round of an asset." , "Parameters: caller DID, AssetId, funding round name." ,] } , Self :: DocumentAdded (_ , _ , _ , _) => { & ["A new document attached to an asset" ,] } , Self :: DocumentRemoved (_ , _ , _) => { & ["A document removed from an asset" ,] } , Self :: ControllerTransfer (_ , _ , _ , _) => { & ["Event for when a forced transfer takes place." , "caller DID/ controller DID, ExtensionRemoved, Portfolio of token holder, value." ,] } , Self :: CustomAssetTypeExists (_ , _ , _) => { & ["A custom asset type already exists on-chain." , "caller DID, the ID of the custom asset type, the string contents registered." ,] } , Self :: CustomAssetTypeRegistered (_ , _ , _) => { & ["A custom asset type was registered on-chain." , "caller DID, the ID of the custom asset type, the string contents registered." ,] } , Self :: SetAssetMetadataValue (_ , _ , _ , _) => { & ["Set asset metadata value." , "(Caller DID, AssetId, metadata value, optional value details)" ,] } , Self :: SetAssetMetadataValueDetails (_ , _ , _) => { & ["Set asset metadata value details (expire, lock status)." , "(Caller DID, AssetId, value details)" ,] } , Self :: RegisterAssetMetadataLocalType (_ , _ , _ , _ , _) => { & ["Register asset metadata local type." , "(Caller DID, AssetId, Local type name, Local type key, type specs)" ,] } , Self :: RegisterAssetMetadataGlobalType (_ , _ , _) => { & ["Register asset metadata global type." , "(Global type name, Global type key, type specs)" ,] } , Self :: AssetTypeChanged (_ , _ , _) => { & ["An event emitted when the type of an asset changed." , "Parameters: caller DID, AssetId, new token type." ,] } , Self :: LocalMetadataKeyDeleted (_ , _ , _) => { & ["An event emitted when a local metadata key has been removed." , "Parameters: caller AssetId, Local type name" ,] } , Self :: MetadataValueDeleted (_ , _ , _) => { & ["An event emitted when a local metadata value has been removed." , "Parameters: caller AssetId, Local type name" ,] } , Self :: AssetBalanceUpdated (_ , _ , _ , _ , _ , _) => { & ["Emitted when Tokens were issued, redeemed or transferred." , "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`AssetId`] for the token, the balance that was issued/transferred/redeemed," , "the [`PortfolioId`] of the source, the [`PortfolioId`] of the destination and the [`PortfolioUpdateReason`]." ,] } , Self :: AssetAffirmationExemption (_) => { & ["An asset has been added to the list of pre aprroved receivement (valid for all identities)." , "Parameters: [`AssetId`] of the pre approved asset." ,] } , Self :: RemoveAssetAffirmationExemption (_) => { & ["An asset has been removed from the list of pre aprroved receivement (valid for all identities)." , "Parameters: [`AssetId`] of the asset." ,] } , Self :: PreApprovedAsset (_ , _) => { & ["An identity has added an asset to the list of pre aprroved receivement." , "Parameters: [`IdentityId`] of caller, [`AssetId`] of the pre approved asset." ,] } , Self :: RemovePreApprovedAsset (_ , _) => { & ["An identity has removed an asset to the list of pre aprroved receivement." , "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset." ,] } , Self :: AssetMediatorsAdded (_ , _ , _) => { & ["An identity has added mandatory mediators to an asset." , "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset, the identity of all mediators added." ,] } , Self :: AssetMediatorsRemoved (_ , _ , _) => { & ["An identity has removed mediators from an asset." , "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset, the identity of all mediators removed." ,] } , Self :: TickerLinkedToAsset (_ , _ , _) => { & ["An identity has linked a ticker to an asset." , "Parameters: [`IdentityId`] of caller, [`Ticker`] of the asset, the asset identifier [`AssetId`]." ,] } , Self :: TickerUnlinkedFromAsset (_ , _ , _) => { & ["An identity has unlinked a ticker from an asset." , "Parameters: [`IdentityId`] of caller, unlinked [`Ticker`], the asset identifier [`AssetId`]." ,] } , _ => & [""] , }
          }
        }
        impl<Moment> From<AssetEvent<Moment>> for &'static str {
          fn from(v: AssetEvent<Moment>) -> Self {
            v.as_static_str()
          }
        }
        impl<Moment> From<&AssetEvent<Moment>> for &'static str {
          fn from(v: &AssetEvent<Moment>) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod base {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum BaseEvent {
          #[doc = "An unexpected error happened that should be investigated."]
          #[codec(index = 0u8)]
          UnexpectedError(Option<sp_runtime::DispatchError>),
        }
        impl BaseEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::UnexpectedError(_) => "Base.UnexpectedError",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for BaseEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::UnexpectedError(_) => {
                &["An unexpected error happened that should be investigated."]
              }
              _ => &[""],
            }
          }
        }
        impl From<BaseEvent> for &'static str {
          fn from(v: BaseEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&BaseEvent> for &'static str {
          fn from(v: &BaseEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod compliance_manager {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum ComplianceManagerEvent {
          #[doc = "Emitted when new compliance requirement is created."]
          #[doc = "(caller DID, AssetId, ComplianceRequirement)."]
          #[codec(index = 0u8)]
          ComplianceRequirementCreated(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::compliance_manager::ComplianceRequirement,
          ),
          #[doc = "Emitted when a compliance requirement is removed."]
          #[doc = "(caller DID, AssetId, requirement_id)."]
          #[codec(index = 1u8)]
          ComplianceRequirementRemoved(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            u32,
          ),
          #[doc = "Emitted when an asset compliance is replaced."]
          #[doc = "Parameters: caller DID, AssetId, new asset compliance."]
          #[codec(index = 2u8)]
          AssetComplianceReplaced(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::alloc::vec::Vec<polymesh_primitives::compliance_manager::ComplianceRequirement>,
          ),
          #[doc = "Emitted when an asset compliance of a asset_id is reset."]
          #[doc = "(caller DID, AssetId)."]
          #[codec(index = 3u8)]
          AssetComplianceReset(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
          ),
          #[doc = "Emitted when an asset compliance for a given asset_id gets resume."]
          #[doc = "(caller DID, AssetId)."]
          #[codec(index = 4u8)]
          AssetComplianceResumed(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
          ),
          #[doc = "Emitted when an asset compliance for a given asset_id gets paused."]
          #[doc = "(caller DID, AssetId)."]
          #[codec(index = 5u8)]
          AssetCompliancePaused(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
          ),
          #[doc = "Emitted when compliance requirement get modified/change."]
          #[doc = "(caller DID, AssetId, ComplianceRequirement)."]
          #[codec(index = 6u8)]
          ComplianceRequirementChanged(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::compliance_manager::ComplianceRequirement,
          ),
          #[doc = "Emitted when default claim issuer list for a given asset_id gets added."]
          #[doc = "(caller DID, AssetId, Added TrustedIssuer)."]
          #[codec(index = 7u8)]
          TrustedDefaultClaimIssuerAdded(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::condition::TrustedIssuer,
          ),
          #[doc = "Emitted when default claim issuer list for a given asset_id get removed."]
          #[doc = "(caller DID, AssetId, Removed TrustedIssuer)."]
          #[codec(index = 8u8)]
          TrustedDefaultClaimIssuerRemoved(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::polymesh_api_client::IdentityId,
          ),
        }
        impl ComplianceManagerEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::ComplianceRequirementCreated(_, _, _) => {
                "ComplianceManager.ComplianceRequirementCreated"
              }
              Self::ComplianceRequirementRemoved(_, _, _) => {
                "ComplianceManager.ComplianceRequirementRemoved"
              }
              Self::AssetComplianceReplaced(_, _, _) => "ComplianceManager.AssetComplianceReplaced",
              Self::AssetComplianceReset(_, _) => "ComplianceManager.AssetComplianceReset",
              Self::AssetComplianceResumed(_, _) => "ComplianceManager.AssetComplianceResumed",
              Self::AssetCompliancePaused(_, _) => "ComplianceManager.AssetCompliancePaused",
              Self::ComplianceRequirementChanged(_, _, _) => {
                "ComplianceManager.ComplianceRequirementChanged"
              }
              Self::TrustedDefaultClaimIssuerAdded(_, _, _) => {
                "ComplianceManager.TrustedDefaultClaimIssuerAdded"
              }
              Self::TrustedDefaultClaimIssuerRemoved(_, _, _) => {
                "ComplianceManager.TrustedDefaultClaimIssuerRemoved"
              }
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for ComplianceManagerEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::ComplianceRequirementCreated(_, _, _) => &[
                "Emitted when new compliance requirement is created.",
                "(caller DID, AssetId, ComplianceRequirement).",
              ],
              Self::ComplianceRequirementRemoved(_, _, _) => &[
                "Emitted when a compliance requirement is removed.",
                "(caller DID, AssetId, requirement_id).",
              ],
              Self::AssetComplianceReplaced(_, _, _) => &[
                "Emitted when an asset compliance is replaced.",
                "Parameters: caller DID, AssetId, new asset compliance.",
              ],
              Self::AssetComplianceReset(_, _) => &[
                "Emitted when an asset compliance of a asset_id is reset.",
                "(caller DID, AssetId).",
              ],
              Self::AssetComplianceResumed(_, _) => &[
                "Emitted when an asset compliance for a given asset_id gets resume.",
                "(caller DID, AssetId).",
              ],
              Self::AssetCompliancePaused(_, _) => &[
                "Emitted when an asset compliance for a given asset_id gets paused.",
                "(caller DID, AssetId).",
              ],
              Self::ComplianceRequirementChanged(_, _, _) => &[
                "Emitted when compliance requirement get modified/change.",
                "(caller DID, AssetId, ComplianceRequirement).",
              ],
              Self::TrustedDefaultClaimIssuerAdded(_, _, _) => &[
                "Emitted when default claim issuer list for a given asset_id gets added.",
                "(caller DID, AssetId, Added TrustedIssuer).",
              ],
              Self::TrustedDefaultClaimIssuerRemoved(_, _, _) => &[
                "Emitted when default claim issuer list for a given asset_id get removed.",
                "(caller DID, AssetId, Removed TrustedIssuer).",
              ],
              _ => &[""],
            }
          }
        }
        impl From<ComplianceManagerEvent> for &'static str {
          fn from(v: ComplianceManagerEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&ComplianceManagerEvent> for &'static str {
          fn from(v: &ComplianceManagerEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod external_agents {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum ExternalAgentsEvent {
          #[doc = "An Agent Group was created."]
          #[doc = ""]
          #[doc = "(Caller DID, AG's AssetId, AG's ID, AG's permissions)"]
          #[codec(index = 0u8)]
          GroupCreated(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::agent::AGId,
            polymesh_primitives::secondary_key::ExtrinsicPermissions,
          ),
          #[doc = "An Agent Group's permissions was updated."]
          #[doc = ""]
          #[doc = "(Caller DID, AG's AssetId, AG's ID, AG's new permissions)"]
          #[codec(index = 1u8)]
          GroupPermissionsUpdated(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::agent::AGId,
            polymesh_primitives::secondary_key::ExtrinsicPermissions,
          ),
          #[doc = "An agent was added."]
          #[doc = ""]
          #[doc = "(Caller/Agent DID, Agent's AssetId, Agent's group)"]
          #[codec(index = 2u8)]
          AgentAdded(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::agent::AgentGroup,
          ),
          #[doc = "An agent was removed."]
          #[doc = ""]
          #[doc = "(Caller DID, Agent's AssetId, Agent's DID)"]
          #[codec(index = 3u8)]
          AgentRemoved(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            ::polymesh_api_client::AssetId,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "An agent's group was changed."]
          #[doc = ""]
          #[doc = "(Caller DID, Agent's AssetId, Agent's DID, The new group of the agent)"]
          #[codec(index = 4u8)]
          GroupChanged(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            ::polymesh_api_client::AssetId,
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::agent::AgentGroup,
          ),
        }
        impl ExternalAgentsEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::GroupCreated(_, _, _, _) => "ExternalAgents.GroupCreated",
              Self::GroupPermissionsUpdated(_, _, _, _) => "ExternalAgents.GroupPermissionsUpdated",
              Self::AgentAdded(_, _, _) => "ExternalAgents.AgentAdded",
              Self::AgentRemoved(_, _, _) => "ExternalAgents.AgentRemoved",
              Self::GroupChanged(_, _, _, _) => "ExternalAgents.GroupChanged",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for ExternalAgentsEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::GroupCreated(_, _, _, _) => &[
                "An Agent Group was created.",
                "",
                "(Caller DID, AG's AssetId, AG's ID, AG's permissions)",
              ],
              Self::GroupPermissionsUpdated(_, _, _, _) => &[
                "An Agent Group's permissions was updated.",
                "",
                "(Caller DID, AG's AssetId, AG's ID, AG's new permissions)",
              ],
              Self::AgentAdded(_, _, _) => &[
                "An agent was added.",
                "",
                "(Caller/Agent DID, Agent's AssetId, Agent's group)",
              ],
              Self::AgentRemoved(_, _, _) => &[
                "An agent was removed.",
                "",
                "(Caller DID, Agent's AssetId, Agent's DID)",
              ],
              Self::GroupChanged(_, _, _, _) => &[
                "An agent's group was changed.",
                "",
                "(Caller DID, Agent's AssetId, Agent's DID, The new group of the agent)",
              ],
              _ => &[""],
            }
          }
        }
        impl From<ExternalAgentsEvent> for &'static str {
          fn from(v: ExternalAgentsEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&ExternalAgentsEvent> for &'static str {
          fn from(v: &ExternalAgentsEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod nft {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum NftEvent {
          #[doc = "Emitted when a new nft collection is created."]
          #[codec(index = 0u8)]
          NftCollectionCreated(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::nft::NFTCollectionId,
          ),
          #[doc = "Emitted when NFTs were issued, redeemed or transferred."]
          #[doc = "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`NFTs`], the [`PortfolioId`] of the source, the [`PortfolioId`]"]
          #[doc = "of the destination and the [`PortfolioUpdateReason`]."]
          #[codec(index = 1u8)]
          NFTPortfolioUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::nft::NFTs,
            Option<polymesh_primitives::identity_id::PortfolioId>,
            Option<polymesh_primitives::identity_id::PortfolioId>,
            polymesh_primitives::portfolio::PortfolioUpdateReason,
          ),
        }
        impl NftEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::NftCollectionCreated(_, _, _) => "Nft.NftCollectionCreated",
              Self::NFTPortfolioUpdated(_, _, _, _, _) => "Nft.NFTPortfolioUpdated",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for NftEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: NftCollectionCreated (_ , _ , _) => { & ["Emitted when a new nft collection is created." ,] } , Self :: NFTPortfolioUpdated (_ , _ , _ , _ , _) => { & ["Emitted when NFTs were issued, redeemed or transferred." , "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`NFTs`], the [`PortfolioId`] of the source, the [`PortfolioId`]" , "of the destination and the [`PortfolioUpdateReason`]." ,] } , _ => & [""] , }
          }
        }
        impl From<NftEvent> for &'static str {
          fn from(v: NftEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&NftEvent> for &'static str {
          fn from(v: &NftEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod portfolio {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum PortfolioEvent {
          #[doc = "The portfolio has been successfully created."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* origin DID"]
          #[doc = "* portfolio number"]
          #[doc = "* portfolio name"]
          #[codec(index = 0u8)]
          PortfolioCreated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioNumber,
            polymesh_primitives::identity_id::PortfolioName,
          ),
          #[doc = "The portfolio has been successfully removed."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* origin DID"]
          #[doc = "* portfolio number"]
          #[codec(index = 1u8)]
          PortfolioDeleted(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioNumber,
          ),
          #[doc = "The portfolio identified with `num` has been renamed to `name`."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* origin DID"]
          #[doc = "* portfolio number"]
          #[doc = "* portfolio name"]
          #[codec(index = 2u8)]
          PortfolioRenamed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioNumber,
            polymesh_primitives::identity_id::PortfolioName,
          ),
          #[doc = "All non-default portfolio numbers and names of a DID."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* origin DID"]
          #[doc = "* vector of number-name pairs"]
          #[codec(index = 3u8)]
          UserPortfolios(
            ::polymesh_api_client::IdentityId,
            ::alloc::vec::Vec<(
              polymesh_primitives::identity_id::PortfolioNumber,
              polymesh_primitives::identity_id::PortfolioName,
            )>,
          ),
          #[doc = "Custody of a portfolio has been given to a different identity"]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* origin DID"]
          #[doc = "* portfolio id"]
          #[doc = "* portfolio custodian did"]
          #[codec(index = 4u8)]
          PortfolioCustodianChanged(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "Funds have moved between portfolios"]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* Origin DID."]
          #[doc = "* Source portfolio."]
          #[doc = "* Destination portfolio."]
          #[doc = "* The type of fund that was moved."]
          #[doc = "* Optional memo for the move."]
          #[codec(index = 5u8)]
          FundsMovedBetweenPortfolios(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            polymesh_primitives::identity_id::PortfolioId,
            polymesh_primitives::portfolio::FundDescription,
            Option<polymesh_primitives::Memo>,
          ),
          #[doc = "A portfolio has pre approved the receivement of an asset."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* [`IdentityId`] of the caller."]
          #[doc = "* [`PortfolioId`] that will receive assets without explicit affirmation."]
          #[doc = "* [`AssetId`] of the asset that has been exempt from explicit affirmation."]
          #[codec(index = 6u8)]
          PreApprovedPortfolio(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            ::polymesh_api_client::AssetId,
          ),
          #[doc = "A portfolio has removed the approval of an asset."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* [`IdentityId`] of the caller."]
          #[doc = "* [`PortfolioId`] that had its pre approval revoked."]
          #[doc = "* [`AssetId`] of the asset that had its pre approval revoked."]
          #[codec(index = 7u8)]
          RevokePreApprovedPortfolio(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            ::polymesh_api_client::AssetId,
          ),
          #[doc = "Allow another identity to create portfolios."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* [`IdentityId`] of the caller."]
          #[doc = "* [`IdentityId`] allowed to create portfolios."]
          #[codec(index = 8u8)]
          AllowIdentityToCreatePortfolios(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "Revoke another identities permission to create portfolios."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* [`IdentityId`] of the caller."]
          #[doc = "* [`IdentityId`] permissions to create portfolios is revoked."]
          #[codec(index = 9u8)]
          RevokeCreatePortfoliosPermission(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
          ),
        }
        impl PortfolioEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::PortfolioCreated(_, _, _) => "Portfolio.PortfolioCreated",
              Self::PortfolioDeleted(_, _) => "Portfolio.PortfolioDeleted",
              Self::PortfolioRenamed(_, _, _) => "Portfolio.PortfolioRenamed",
              Self::UserPortfolios(_, _) => "Portfolio.UserPortfolios",
              Self::PortfolioCustodianChanged(_, _, _) => "Portfolio.PortfolioCustodianChanged",
              Self::FundsMovedBetweenPortfolios(_, _, _, _, _) => {
                "Portfolio.FundsMovedBetweenPortfolios"
              }
              Self::PreApprovedPortfolio(_, _, _) => "Portfolio.PreApprovedPortfolio",
              Self::RevokePreApprovedPortfolio(_, _, _) => "Portfolio.RevokePreApprovedPortfolio",
              Self::AllowIdentityToCreatePortfolios(_, _) => {
                "Portfolio.AllowIdentityToCreatePortfolios"
              }
              Self::RevokeCreatePortfoliosPermission(_, _) => {
                "Portfolio.RevokeCreatePortfoliosPermission"
              }
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for PortfolioEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::PortfolioCreated(_, _, _) => &[
                "The portfolio has been successfully created.",
                "",
                "# Parameters",
                "* origin DID",
                "* portfolio number",
                "* portfolio name",
              ],
              Self::PortfolioDeleted(_, _) => &[
                "The portfolio has been successfully removed.",
                "",
                "# Parameters",
                "* origin DID",
                "* portfolio number",
              ],
              Self::PortfolioRenamed(_, _, _) => &[
                "The portfolio identified with `num` has been renamed to `name`.",
                "",
                "# Parameters",
                "* origin DID",
                "* portfolio number",
                "* portfolio name",
              ],
              Self::UserPortfolios(_, _) => &[
                "All non-default portfolio numbers and names of a DID.",
                "",
                "# Parameters",
                "* origin DID",
                "* vector of number-name pairs",
              ],
              Self::PortfolioCustodianChanged(_, _, _) => &[
                "Custody of a portfolio has been given to a different identity",
                "",
                "# Parameters",
                "* origin DID",
                "* portfolio id",
                "* portfolio custodian did",
              ],
              Self::FundsMovedBetweenPortfolios(_, _, _, _, _) => &[
                "Funds have moved between portfolios",
                "",
                "# Parameters",
                "* Origin DID.",
                "* Source portfolio.",
                "* Destination portfolio.",
                "* The type of fund that was moved.",
                "* Optional memo for the move.",
              ],
              Self::PreApprovedPortfolio(_, _, _) => &[
                "A portfolio has pre approved the receivement of an asset.",
                "",
                "# Parameters",
                "* [`IdentityId`] of the caller.",
                "* [`PortfolioId`] that will receive assets without explicit affirmation.",
                "* [`AssetId`] of the asset that has been exempt from explicit affirmation.",
              ],
              Self::RevokePreApprovedPortfolio(_, _, _) => &[
                "A portfolio has removed the approval of an asset.",
                "",
                "# Parameters",
                "* [`IdentityId`] of the caller.",
                "* [`PortfolioId`] that had its pre approval revoked.",
                "* [`AssetId`] of the asset that had its pre approval revoked.",
              ],
              Self::AllowIdentityToCreatePortfolios(_, _) => &[
                "Allow another identity to create portfolios.",
                "",
                "# Parameters",
                "* [`IdentityId`] of the caller.",
                "* [`IdentityId`] allowed to create portfolios.",
              ],
              Self::RevokeCreatePortfoliosPermission(_, _) => &[
                "Revoke another identities permission to create portfolios.",
                "",
                "# Parameters",
                "* [`IdentityId`] of the caller.",
                "* [`IdentityId`] permissions to create portfolios is revoked.",
              ],
              _ => &[""],
            }
          }
        }
        impl From<PortfolioEvent> for &'static str {
          fn from(v: PortfolioEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&PortfolioEvent> for &'static str {
          fn from(v: &PortfolioEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod relayer {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum RelayerEvent<AccountId> {
          #[doc = "Authorization given for `paying_key` to `user_key`."]
          #[doc = ""]
          #[doc = "(Caller DID, User Key, Paying Key, Initial POLYX limit, Auth ID)"]
          #[codec(index = 0u8)]
          AuthorizedPayingKey(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            AccountId,
            AccountId,
            u128,
            u64,
          ),
          #[doc = "Accepted paying key."]
          #[doc = ""]
          #[doc = "(Caller DID, User Key, Paying Key)"]
          #[codec(index = 1u8)]
          AcceptedPayingKey(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            AccountId,
            AccountId,
          ),
          #[doc = "Removed paying key."]
          #[doc = ""]
          #[doc = "(Caller DID, User Key, Paying Key)"]
          #[codec(index = 2u8)]
          RemovedPayingKey(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            AccountId,
            AccountId,
          ),
          #[doc = "Updated polyx limit."]
          #[doc = ""]
          #[doc = "(Caller DID, User Key, Paying Key, POLYX limit, old remaining POLYX)"]
          #[codec(index = 3u8)]
          UpdatedPolyxLimit(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            AccountId,
            AccountId,
            u128,
            u128,
          ),
        }
        impl<AccountId> RelayerEvent<AccountId> {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::AuthorizedPayingKey(_, _, _, _, _) => "Relayer.AuthorizedPayingKey",
              Self::AcceptedPayingKey(_, _, _) => "Relayer.AcceptedPayingKey",
              Self::RemovedPayingKey(_, _, _) => "Relayer.RemovedPayingKey",
              Self::UpdatedPolyxLimit(_, _, _, _, _) => "Relayer.UpdatedPolyxLimit",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl<AccountId> ::polymesh_api_client::EnumInfo for RelayerEvent<AccountId> {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::AuthorizedPayingKey(_, _, _, _, _) => &[
                "Authorization given for `paying_key` to `user_key`.",
                "",
                "(Caller DID, User Key, Paying Key, Initial POLYX limit, Auth ID)",
              ],
              Self::AcceptedPayingKey(_, _, _) => &[
                "Accepted paying key.",
                "",
                "(Caller DID, User Key, Paying Key)",
              ],
              Self::RemovedPayingKey(_, _, _) => &[
                "Removed paying key.",
                "",
                "(Caller DID, User Key, Paying Key)",
              ],
              Self::UpdatedPolyxLimit(_, _, _, _, _) => &[
                "Updated polyx limit.",
                "",
                "(Caller DID, User Key, Paying Key, POLYX limit, old remaining POLYX)",
              ],
              _ => &[""],
            }
          }
        }
        impl<AccountId> From<RelayerEvent<AccountId>> for &'static str {
          fn from(v: RelayerEvent<AccountId>) -> Self {
            v.as_static_str()
          }
        }
        impl<AccountId> From<&RelayerEvent<AccountId>> for &'static str {
          fn from(v: &RelayerEvent<AccountId>) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod settlement {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum SettlementEvent<Moment, BlockNumber, AccountId> {
          #[doc = "A new venue has been created (did, venue_id, details, type)"]
          #[codec(index = 0u8)]
          VenueCreated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::VenueId,
            polymesh_primitives::settlement::VenueDetails,
            polymesh_primitives::settlement::VenueType,
          ),
          #[doc = "An existing venue's details has been updated (did, venue_id, details)"]
          #[codec(index = 1u8)]
          VenueDetailsUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::VenueId,
            polymesh_primitives::settlement::VenueDetails,
          ),
          #[doc = "An existing venue's type has been updated (did, venue_id, type)"]
          #[codec(index = 2u8)]
          VenueTypeUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::VenueId,
            polymesh_primitives::settlement::VenueType,
          ),
          #[doc = "An instruction has been affirmed (did, portfolio, instruction_id)"]
          #[codec(index = 3u8)]
          InstructionAffirmed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "An affirmation has been withdrawn (did, portfolio, instruction_id)"]
          #[codec(index = 4u8)]
          AffirmationWithdrawn(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "An instruction has been rejected (did, instruction_id)"]
          #[codec(index = 5u8)]
          InstructionRejected(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "A receipt has been claimed (did, instruction_id, leg_id, receipt_uid, signer, receipt metadata)"]
          #[codec(index = 6u8)]
          ReceiptClaimed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
            polymesh_primitives::settlement::LegId,
            Moment,
            AccountId,
            Option<polymesh_primitives::settlement::ReceiptMetadata>,
          ),
          #[doc = "Venue filtering has been enabled or disabled for an asset (did, AssetId, filtering_enabled)"]
          #[codec(index = 7u8)]
          VenueFiltering(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            bool,
          ),
          #[doc = "Venues added to allow list (did, AssetId, vec<venue_id>)"]
          #[codec(index = 8u8)]
          VenuesAllowed(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
          ),
          #[doc = "Venues added to block list (did, AssetId, vec<venue_id>)"]
          #[codec(index = 9u8)]
          VenuesBlocked(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
          ),
          #[doc = "Execution of a leg failed (did, instruction_id, leg_id)"]
          #[codec(index = 10u8)]
          LegFailedExecution(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
            polymesh_primitives::settlement::LegId,
          ),
          #[doc = "Instruction executed successfully(did, instruction_id)"]
          #[codec(index = 11u8)]
          InstructionExecuted(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "Venue not part of the token's allow list (did, AssetId, venue_id)"]
          #[codec(index = 12u8)]
          VenueUnauthorized(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::settlement::VenueId,
          ),
          #[doc = "Scheduling of instruction fails."]
          #[codec(index = 13u8)]
          SchedulingFailed(
            polymesh_primitives::settlement::InstructionId,
            sp_runtime::DispatchError,
          ),
          #[doc = "Instruction is rescheduled."]
          #[doc = "(caller DID, instruction_id)"]
          #[codec(index = 14u8)]
          InstructionRescheduled(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "An existing venue's signers has been updated (did, venue_id, signers, update_type)"]
          #[codec(index = 15u8)]
          VenueSignersUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::VenueId,
            ::alloc::vec::Vec<AccountId>,
            bool,
          ),
          #[doc = "Settlement manually executed (did, id)"]
          #[codec(index = 16u8)]
          SettlementManuallyExecuted(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "A new instruction has been created"]
          #[doc = "(did, venue_id, instruction_id, settlement_type, trade_date, value_date, legs, memo)"]
          #[codec(index = 17u8)]
          InstructionCreated(
            ::polymesh_api_client::IdentityId,
            Option<polymesh_primitives::settlement::VenueId>,
            polymesh_primitives::settlement::InstructionId,
            polymesh_primitives::settlement::SettlementType<BlockNumber>,
            Option<Moment>,
            Option<Moment>,
            ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
            Option<polymesh_primitives::Memo>,
          ),
          #[doc = "Failed to execute instruction."]
          #[codec(index = 18u8)]
          FailedToExecuteInstruction(
            polymesh_primitives::settlement::InstructionId,
            sp_runtime::DispatchError,
          ),
          #[doc = "An instruction has been automatically affirmed."]
          #[doc = "Parameters: [`IdentityId`] of the caller, [`PortfolioId`] of the receiver, and [`InstructionId`] of the instruction."]
          #[codec(index = 19u8)]
          InstructionAutomaticallyAffirmed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "An instruction has affirmed by a mediator."]
          #[doc = "Parameters: [`IdentityId`] of the mediator and [`InstructionId`] of the instruction."]
          #[codec(index = 20u8)]
          MediatorAffirmationReceived(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
            Option<Moment>,
          ),
          #[doc = "An instruction affirmation has been withdrawn by a mediator."]
          #[doc = "Parameters: [`IdentityId`] of the mediator and [`InstructionId`] of the instruction."]
          #[codec(index = 21u8)]
          MediatorAffirmationWithdrawn(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "An instruction with mediators has been created."]
          #[doc = "Parameters: [`InstructionId`] of the instruction and the [`IdentityId`] of all mediators."]
          #[codec(index = 22u8)]
          InstructionMediators(
            polymesh_primitives::settlement::InstructionId,
            ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
          ),
        }
        impl<Moment, BlockNumber, AccountId> SettlementEvent<Moment, BlockNumber, AccountId> {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::VenueCreated(_, _, _, _) => "Settlement.VenueCreated",
              Self::VenueDetailsUpdated(_, _, _) => "Settlement.VenueDetailsUpdated",
              Self::VenueTypeUpdated(_, _, _) => "Settlement.VenueTypeUpdated",
              Self::InstructionAffirmed(_, _, _) => "Settlement.InstructionAffirmed",
              Self::AffirmationWithdrawn(_, _, _) => "Settlement.AffirmationWithdrawn",
              Self::InstructionRejected(_, _) => "Settlement.InstructionRejected",
              Self::ReceiptClaimed(_, _, _, _, _, _) => "Settlement.ReceiptClaimed",
              Self::VenueFiltering(_, _, _) => "Settlement.VenueFiltering",
              Self::VenuesAllowed(_, _, _) => "Settlement.VenuesAllowed",
              Self::VenuesBlocked(_, _, _) => "Settlement.VenuesBlocked",
              Self::LegFailedExecution(_, _, _) => "Settlement.LegFailedExecution",
              Self::InstructionExecuted(_, _) => "Settlement.InstructionExecuted",
              Self::VenueUnauthorized(_, _, _) => "Settlement.VenueUnauthorized",
              Self::SchedulingFailed(_, _) => "Settlement.SchedulingFailed",
              Self::InstructionRescheduled(_, _) => "Settlement.InstructionRescheduled",
              Self::VenueSignersUpdated(_, _, _, _) => "Settlement.VenueSignersUpdated",
              Self::SettlementManuallyExecuted(_, _) => "Settlement.SettlementManuallyExecuted",
              Self::InstructionCreated(_, _, _, _, _, _, _, _) => "Settlement.InstructionCreated",
              Self::FailedToExecuteInstruction(_, _) => "Settlement.FailedToExecuteInstruction",
              Self::InstructionAutomaticallyAffirmed(_, _, _) => {
                "Settlement.InstructionAutomaticallyAffirmed"
              }
              Self::MediatorAffirmationReceived(_, _, _) => {
                "Settlement.MediatorAffirmationReceived"
              }
              Self::MediatorAffirmationWithdrawn(_, _) => "Settlement.MediatorAffirmationWithdrawn",
              Self::InstructionMediators(_, _) => "Settlement.InstructionMediators",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl<Moment, BlockNumber, AccountId> ::polymesh_api_client::EnumInfo
          for SettlementEvent<Moment, BlockNumber, AccountId>
        {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: VenueCreated (_ , _ , _ , _) => { & ["A new venue has been created (did, venue_id, details, type)" ,] } , Self :: VenueDetailsUpdated (_ , _ , _) => { & ["An existing venue's details has been updated (did, venue_id, details)" ,] } , Self :: VenueTypeUpdated (_ , _ , _) => { & ["An existing venue's type has been updated (did, venue_id, type)" ,] } , Self :: InstructionAffirmed (_ , _ , _) => { & ["An instruction has been affirmed (did, portfolio, instruction_id)" ,] } , Self :: AffirmationWithdrawn (_ , _ , _) => { & ["An affirmation has been withdrawn (did, portfolio, instruction_id)" ,] } , Self :: InstructionRejected (_ , _) => { & ["An instruction has been rejected (did, instruction_id)" ,] } , Self :: ReceiptClaimed (_ , _ , _ , _ , _ , _) => { & ["A receipt has been claimed (did, instruction_id, leg_id, receipt_uid, signer, receipt metadata)" ,] } , Self :: VenueFiltering (_ , _ , _) => { & ["Venue filtering has been enabled or disabled for an asset (did, AssetId, filtering_enabled)" ,] } , Self :: VenuesAllowed (_ , _ , _) => { & ["Venues added to allow list (did, AssetId, vec<venue_id>)" ,] } , Self :: VenuesBlocked (_ , _ , _) => { & ["Venues added to block list (did, AssetId, vec<venue_id>)" ,] } , Self :: LegFailedExecution (_ , _ , _) => { & ["Execution of a leg failed (did, instruction_id, leg_id)" ,] } , Self :: InstructionExecuted (_ , _) => { & ["Instruction executed successfully(did, instruction_id)" ,] } , Self :: VenueUnauthorized (_ , _ , _) => { & ["Venue not part of the token's allow list (did, AssetId, venue_id)" ,] } , Self :: SchedulingFailed (_ , _) => { & ["Scheduling of instruction fails." ,] } , Self :: InstructionRescheduled (_ , _) => { & ["Instruction is rescheduled." , "(caller DID, instruction_id)" ,] } , Self :: VenueSignersUpdated (_ , _ , _ , _) => { & ["An existing venue's signers has been updated (did, venue_id, signers, update_type)" ,] } , Self :: SettlementManuallyExecuted (_ , _) => { & ["Settlement manually executed (did, id)" ,] } , Self :: InstructionCreated (_ , _ , _ , _ , _ , _ , _ , _) => { & ["A new instruction has been created" , "(did, venue_id, instruction_id, settlement_type, trade_date, value_date, legs, memo)" ,] } , Self :: FailedToExecuteInstruction (_ , _) => { & ["Failed to execute instruction." ,] } , Self :: InstructionAutomaticallyAffirmed (_ , _ , _) => { & ["An instruction has been automatically affirmed." , "Parameters: [`IdentityId`] of the caller, [`PortfolioId`] of the receiver, and [`InstructionId`] of the instruction." ,] } , Self :: MediatorAffirmationReceived (_ , _ , _) => { & ["An instruction has affirmed by a mediator." , "Parameters: [`IdentityId`] of the mediator and [`InstructionId`] of the instruction." ,] } , Self :: MediatorAffirmationWithdrawn (_ , _) => { & ["An instruction affirmation has been withdrawn by a mediator." , "Parameters: [`IdentityId`] of the mediator and [`InstructionId`] of the instruction." ,] } , Self :: InstructionMediators (_ , _) => { & ["An instruction with mediators has been created." , "Parameters: [`InstructionId`] of the instruction and the [`IdentityId`] of all mediators." ,] } , _ => & [""] , }
          }
        }
        impl<Moment, BlockNumber, AccountId> From<SettlementEvent<Moment, BlockNumber, AccountId>>
          for &'static str
        {
          fn from(v: SettlementEvent<Moment, BlockNumber, AccountId>) -> Self {
            v.as_static_str()
          }
        }
        impl<Moment, BlockNumber, AccountId> From<&SettlementEvent<Moment, BlockNumber, AccountId>>
          for &'static str
        {
          fn from(v: &SettlementEvent<Moment, BlockNumber, AccountId>) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod statistics {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum StatisticsEvent {
          #[doc = "Stat types added to asset."]
          #[doc = ""]
          #[doc = "(Caller DID, AssetId, Stat types)"]
          #[codec(index = 0u8)]
          StatTypesAdded(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::alloc::vec::Vec<polymesh_primitives::statistics::StatType>,
          ),
          #[doc = "Stat types removed from asset."]
          #[doc = ""]
          #[doc = "(Caller DID, AssetId, Stat types)"]
          #[codec(index = 1u8)]
          StatTypesRemoved(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::alloc::vec::Vec<polymesh_primitives::statistics::StatType>,
          ),
          #[doc = "Asset stats updated."]
          #[doc = ""]
          #[doc = "(Caller DID, AssetId, Stat type, Updates)"]
          #[codec(index = 2u8)]
          AssetStatsUpdated(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            polymesh_primitives::statistics::StatType,
            ::alloc::vec::Vec<polymesh_primitives::statistics::StatUpdate>,
          ),
          #[doc = "Set Transfer compliance rules for asset."]
          #[doc = ""]
          #[doc = "(Caller DID, AssetId, Transfer conditions)"]
          #[codec(index = 3u8)]
          SetAssetTransferCompliance(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::AssetId,
            ::alloc::vec::Vec<polymesh_primitives::transfer_compliance::TransferCondition>,
          ),
          #[doc = "Add `IdentityId`s exempt for transfer conditions matching exempt key."]
          #[doc = ""]
          #[doc = "(Caller DID, Exempt key, Entities)"]
          #[codec(index = 4u8)]
          TransferConditionExemptionsAdded(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
            ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
          ),
          #[doc = "Remove `IdentityId`s exempt for transfer conditions matching exempt key."]
          #[doc = ""]
          #[doc = "(Caller DID, Exempt key, Entities)"]
          #[codec(index = 5u8)]
          TransferConditionExemptionsRemoved(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
            ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
          ),
        }
        impl StatisticsEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::StatTypesAdded(_, _, _) => "Statistics.StatTypesAdded",
              Self::StatTypesRemoved(_, _, _) => "Statistics.StatTypesRemoved",
              Self::AssetStatsUpdated(_, _, _, _) => "Statistics.AssetStatsUpdated",
              Self::SetAssetTransferCompliance(_, _, _) => "Statistics.SetAssetTransferCompliance",
              Self::TransferConditionExemptionsAdded(_, _, _) => {
                "Statistics.TransferConditionExemptionsAdded"
              }
              Self::TransferConditionExemptionsRemoved(_, _, _) => {
                "Statistics.TransferConditionExemptionsRemoved"
              }
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for StatisticsEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::StatTypesAdded(_, _, _) => &[
                "Stat types added to asset.",
                "",
                "(Caller DID, AssetId, Stat types)",
              ],
              Self::StatTypesRemoved(_, _, _) => &[
                "Stat types removed from asset.",
                "",
                "(Caller DID, AssetId, Stat types)",
              ],
              Self::AssetStatsUpdated(_, _, _, _) => &[
                "Asset stats updated.",
                "",
                "(Caller DID, AssetId, Stat type, Updates)",
              ],
              Self::SetAssetTransferCompliance(_, _, _) => &[
                "Set Transfer compliance rules for asset.",
                "",
                "(Caller DID, AssetId, Transfer conditions)",
              ],
              Self::TransferConditionExemptionsAdded(_, _, _) => &[
                "Add `IdentityId`s exempt for transfer conditions matching exempt key.",
                "",
                "(Caller DID, Exempt key, Entities)",
              ],
              Self::TransferConditionExemptionsRemoved(_, _, _) => &[
                "Remove `IdentityId`s exempt for transfer conditions matching exempt key.",
                "",
                "(Caller DID, Exempt key, Entities)",
              ],
              _ => &[""],
            }
          }
        }
        impl From<StatisticsEvent> for &'static str {
          fn from(v: StatisticsEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&StatisticsEvent> for &'static str {
          fn from(v: &StatisticsEvent) -> Self {
            v.as_static_str()
          }
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum MaybeBlock<BlockNumber> {
      #[codec(index = 0u8)]
      Some(BlockNumber),
      #[codec(index = 1u8)]
      None,
    }
  }
  pub mod polymesh_contracts {
    use super::*;
    pub mod chain_extension {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ExtrinsicId(pub u8, pub u8);
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Api {
      pub desc: [u8; 4usize],
      pub major: u32,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ApiCodeHash {
      pub hash: primitive_types::H256,
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PolymeshContractsCall {
      #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code` with the WASM binary defining the smart contract."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[codec(index = 0u8)]
      instantiate_with_code_perms {
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: polymesh_primitives::secondary_key::Permissions,
      },
      #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
      #[doc = ""]
      #[doc = "Unlike `instantiate_with_code`,"]
      #[doc = "this assumes that at least one contract with the same WASM code has already been uploaded."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code_hash` of an already uploaded WASM binary."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[codec(index = 1u8)]
      instantiate_with_hash_perms {
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code_hash: primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: polymesh_primitives::secondary_key::Permissions,
      },
      #[doc = "Update CallRuntime whitelist."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = ""]
      #[doc = "# Errors"]
      #[codec(index = 2u8)]
      update_call_runtime_whitelist {
        updates: ::alloc::vec::Vec<(polymesh_contracts::chain_extension::ExtrinsicId, bool)>,
      },
      #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
      #[doc = ""]
      #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment`: Amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit`: For how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
      #[doc = "- `code`: The WASM binary defining the smart contract."]
      #[doc = "- `data`: The input data to pass to the contract constructor."]
      #[doc = "- `salt`: Used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
      #[doc = ""]
      #[codec(index = 3u8)]
      instantiate_with_code_as_primary_key {
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      },
      #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
      #[doc = ""]
      #[doc = "Unlike `instantiate_with_code`, this assumes that at least one contract with the same WASM code has already been uploaded."]
      #[doc = ""]
      #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment`: amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit`: for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
      #[doc = "- `code_hash`: of an already uploaded WASM binary."]
      #[doc = "- `data`: The input data to pass to the contract constructor."]
      #[doc = "- `salt`: used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
      #[doc = ""]
      #[codec(index = 4u8)]
      instantiate_with_hash_as_primary_key {
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code_hash: primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      },
      #[codec(index = 5u8)]
      upgrade_api {
        api: polymesh_contracts::Api,
        next_upgrade: polymesh_contracts::NextUpgrade,
      },
    }
    impl PolymeshContractsCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::instantiate_with_code_perms { .. } => {
            "PolymeshContracts.instantiate_with_code_perms"
          }
          Self::instantiate_with_hash_perms { .. } => {
            "PolymeshContracts.instantiate_with_hash_perms"
          }
          Self::update_call_runtime_whitelist { .. } => {
            "PolymeshContracts.update_call_runtime_whitelist"
          }
          Self::instantiate_with_code_as_primary_key { .. } => {
            "PolymeshContracts.instantiate_with_code_as_primary_key"
          }
          Self::instantiate_with_hash_as_primary_key { .. } => {
            "PolymeshContracts.instantiate_with_hash_as_primary_key"
          }
          Self::upgrade_api { .. } => "PolymeshContracts.upgrade_api",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PolymeshContractsCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: instantiate_with_code_perms { .. } => { & ["Instantiates a smart contract defining it with the given `code` and `salt`." , "" , "The contract will be attached as a secondary key," , "with `perms` as its permissions, to `origin`'s identity." , "" , "The contract is transferred `endowment` amount of POLYX." , "This is distinct from the `gas_limit`," , "which controls how much gas the deployment code may at most consume." , "" , "# Arguments" , "- `endowment` amount of POLYX to transfer to the contract." , "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume." , "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved" , "  from the caller to pay for the storage consumed." , "- `code` with the WASM binary defining the smart contract." , "- `data` The input data to pass to the contract constructor." , "- `salt` used for contract address derivation." , "   By varying this, the same `code` can be used under the same identity." , "- `perms` that the new secondary key will have." , "" , "# Errors" , "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here." , "- CDD/Permissions are checked, unlike in `pallet_contracts`." , "- Errors that arise when adding a new secondary key can also occur here." ,] } , Self :: instantiate_with_hash_perms { .. } => { & ["Instantiates a smart contract defining using the given `code_hash` and `salt`." , "" , "Unlike `instantiate_with_code`," , "this assumes that at least one contract with the same WASM code has already been uploaded." , "" , "The contract will be attached as a secondary key," , "with `perms` as its permissions, to `origin`'s identity." , "" , "The contract is transferred `endowment` amount of POLYX." , "This is distinct from the `gas_limit`," , "which controls how much gas the deployment code may at most consume." , "" , "# Arguments" , "- `endowment` amount of POLYX to transfer to the contract." , "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume." , "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved" , "  from the caller to pay for the storage consumed." , "- `code_hash` of an already uploaded WASM binary." , "- `data` The input data to pass to the contract constructor." , "- `salt` used for contract address derivation." , "   By varying this, the same `code` can be used under the same identity." , "- `perms` that the new secondary key will have." , "" , "# Errors" , "- All the errors in `pallet_contracts::Call::instantiate` can also happen here." , "- CDD/Permissions are checked, unlike in `pallet_contracts`." , "- Errors that arise when adding a new secondary key can also occur here." ,] } , Self :: update_call_runtime_whitelist { .. } => { & ["Update CallRuntime whitelist." , "" , "# Arguments" , "" , "# Errors" ,] } , Self :: instantiate_with_code_as_primary_key { .. } => { & ["Instantiates a smart contract defining it with the given `code` and `salt`." , "" , "The contract will be attached as a primary key of a newly created child identity of the caller." , "" , "# Arguments" , "- `endowment`: Amount of POLYX to transfer to the contract." , "- `gas_limit`: For how much gas the `deploy` code in the contract may at most consume." , "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed." , "- `code`: The WASM binary defining the smart contract." , "- `data`: The input data to pass to the contract constructor." , "- `salt`: Used for contract address derivation. By varying this, the same `code` can be used under the same identity." , "" ,] } , Self :: instantiate_with_hash_as_primary_key { .. } => { & ["Instantiates a smart contract defining using the given `code_hash` and `salt`." , "" , "Unlike `instantiate_with_code`, this assumes that at least one contract with the same WASM code has already been uploaded." , "" , "The contract will be attached as a primary key of a newly created child identity of the caller." , "" , "# Arguments" , "- `endowment`: amount of POLYX to transfer to the contract." , "- `gas_limit`: for how much gas the `deploy` code in the contract may at most consume." , "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed." , "- `code_hash`: of an already uploaded WASM binary." , "- `data`: The input data to pass to the contract constructor." , "- `salt`: used for contract address derivation. By varying this, the same `code` can be used under the same identity." , "" ,] } , Self :: upgrade_api { .. } => { & ["" ,] } , _ => & [""] , }
      }
    }
    impl From<PolymeshContractsCall> for &'static str {
      fn from(v: PolymeshContractsCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PolymeshContractsCall> for &'static str {
      fn from(v: &PolymeshContractsCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ChainVersion {
      pub spec_version: u32,
      pub tx_version: u32,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PolymeshContractsError {
      #[doc = "Invalid `func_id` provided from contract."]
      #[codec(index = 0u8)]
      InvalidFuncId,
      #[doc = "Failed to decode a valid `RuntimeCall`."]
      #[codec(index = 1u8)]
      InvalidRuntimeCall,
      #[doc = "`ReadStorage` failed to write value into the contract's buffer."]
      #[codec(index = 2u8)]
      ReadStorageFailed,
      #[doc = "Data left in input when decoding arguments of a call."]
      #[codec(index = 3u8)]
      DataLeftAfterDecoding,
      #[doc = "Input data that a contract passed when using the ChainExtension was too large."]
      #[codec(index = 4u8)]
      InLenTooLarge,
      #[doc = "Output data returned from the ChainExtension was too large."]
      #[codec(index = 5u8)]
      OutLenTooLarge,
      #[doc = "A contract was attempted to be instantiated,"]
      #[doc = "but no identity was given to associate the new contract's key with."]
      #[codec(index = 6u8)]
      InstantiatorWithNoIdentity,
      #[doc = "Extrinsic is not allowed to be called by contracts."]
      #[codec(index = 7u8)]
      RuntimeCallDenied,
      #[doc = "The caller is not a primary key."]
      #[codec(index = 8u8)]
      CallerNotAPrimaryKey,
      #[doc = "Secondary key permissions are missing."]
      #[codec(index = 9u8)]
      MissingKeyPermissions,
      #[doc = "Only future chain versions are allowed."]
      #[codec(index = 10u8)]
      InvalidChainVersion,
      #[doc = "There are no api upgrades supported for the contract."]
      #[codec(index = 11u8)]
      NoUpgradesSupported,
    }
    impl PolymeshContractsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::InvalidFuncId => "PolymeshContracts.InvalidFuncId",
          Self::InvalidRuntimeCall => "PolymeshContracts.InvalidRuntimeCall",
          Self::ReadStorageFailed => "PolymeshContracts.ReadStorageFailed",
          Self::DataLeftAfterDecoding => "PolymeshContracts.DataLeftAfterDecoding",
          Self::InLenTooLarge => "PolymeshContracts.InLenTooLarge",
          Self::OutLenTooLarge => "PolymeshContracts.OutLenTooLarge",
          Self::InstantiatorWithNoIdentity => "PolymeshContracts.InstantiatorWithNoIdentity",
          Self::RuntimeCallDenied => "PolymeshContracts.RuntimeCallDenied",
          Self::CallerNotAPrimaryKey => "PolymeshContracts.CallerNotAPrimaryKey",
          Self::MissingKeyPermissions => "PolymeshContracts.MissingKeyPermissions",
          Self::InvalidChainVersion => "PolymeshContracts.InvalidChainVersion",
          Self::NoUpgradesSupported => "PolymeshContracts.NoUpgradesSupported",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PolymeshContractsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::InvalidFuncId => &["Invalid `func_id` provided from contract."],
          Self::InvalidRuntimeCall => &["Failed to decode a valid `RuntimeCall`."],
          Self::ReadStorageFailed => {
            &["`ReadStorage` failed to write value into the contract's buffer."]
          }
          Self::DataLeftAfterDecoding => &["Data left in input when decoding arguments of a call."],
          Self::InLenTooLarge => {
            &["Input data that a contract passed when using the ChainExtension was too large."]
          }
          Self::OutLenTooLarge => &["Output data returned from the ChainExtension was too large."],
          Self::InstantiatorWithNoIdentity => &[
            "A contract was attempted to be instantiated,",
            "but no identity was given to associate the new contract's key with.",
          ],
          Self::RuntimeCallDenied => &["Extrinsic is not allowed to be called by contracts."],
          Self::CallerNotAPrimaryKey => &["The caller is not a primary key."],
          Self::MissingKeyPermissions => &["Secondary key permissions are missing."],
          Self::InvalidChainVersion => &["Only future chain versions are allowed."],
          Self::NoUpgradesSupported => &["There are no api upgrades supported for the contract."],
          _ => &[""],
        }
      }
    }
    impl From<PolymeshContractsError> for &'static str {
      fn from(v: PolymeshContractsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PolymeshContractsError> for &'static str {
      fn from(v: &PolymeshContractsError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct NextUpgrade {
      pub chain_version: polymesh_contracts::ChainVersion,
      pub api_hash: polymesh_contracts::ApiCodeHash,
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PolymeshContractsEvent<Hash, AccountId> {
      #[doc = "Emitted when a contract starts supporting a new API upgrade."]
      #[doc = "Contains the [`Api`], [`ChainVersion`], and the bytes for the code hash."]
      #[codec(index = 0u8)]
      ApiHashUpdated(
        polymesh_contracts::Api,
        polymesh_contracts::ChainVersion,
        Hash,
      ),
      #[doc = "Emitted when a contract calls into the runtime."]
      #[doc = "Contains the account id set by the contract owner and the [`ExtrinsicId`]."]
      #[codec(index = 1u8)]
      SCRuntimeCall(AccountId, polymesh_contracts::chain_extension::ExtrinsicId),
    }
    impl<Hash, AccountId> PolymeshContractsEvent<Hash, AccountId> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::ApiHashUpdated(_, _, _) => "PolymeshContracts.ApiHashUpdated",
          Self::SCRuntimeCall(_, _) => "PolymeshContracts.SCRuntimeCall",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<Hash, AccountId> ::polymesh_api_client::EnumInfo for PolymeshContractsEvent<Hash, AccountId> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::ApiHashUpdated(_, _, _) => &[
            "Emitted when a contract starts supporting a new API upgrade.",
            "Contains the [`Api`], [`ChainVersion`], and the bytes for the code hash.",
          ],
          Self::SCRuntimeCall(_, _) => &[
            "Emitted when a contract calls into the runtime.",
            "Contains the account id set by the contract owner and the [`ExtrinsicId`].",
          ],
          _ => &[""],
        }
      }
    }
    impl<Hash, AccountId> From<PolymeshContractsEvent<Hash, AccountId>> for &'static str {
      fn from(v: PolymeshContractsEvent<Hash, AccountId>) -> Self {
        v.as_static_str()
      }
    }
    impl<Hash, AccountId> From<&PolymeshContractsEvent<Hash, AccountId>> for &'static str {
      fn from(v: &PolymeshContractsEvent<Hash, AccountId>) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod polymesh_primitives {
    use super::*;
    pub mod agent {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AGId(pub u32);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AgentGroup {
        #[codec(index = 0u8)]
        Full,
        #[codec(index = 1u8)]
        Custom(polymesh_primitives::agent::AGId),
        #[codec(index = 2u8)]
        ExceptMeta,
        #[codec(index = 3u8)]
        PolymeshV1CAA,
        #[codec(index = 4u8)]
        PolymeshV1PIA,
      }
    }
    pub mod asset {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetId(pub [u8; 16usize]);
      #[derive(Clone, Debug, PartialEq, Eq, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetName(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AssetType {
        #[codec(index = 0u8)]
        EquityCommon,
        #[codec(index = 1u8)]
        EquityPreferred,
        #[codec(index = 2u8)]
        Commodity,
        #[codec(index = 3u8)]
        FixedIncome,
        #[codec(index = 4u8)]
        REIT,
        #[codec(index = 5u8)]
        Fund,
        #[codec(index = 6u8)]
        RevenueShareAgreement,
        #[codec(index = 7u8)]
        StructuredProduct,
        #[codec(index = 8u8)]
        Derivative,
        #[codec(index = 9u8)]
        Custom(polymesh_primitives::asset::CustomAssetTypeId),
        #[codec(index = 10u8)]
        StableCoin,
        #[codec(index = 11u8)]
        NonFungible(polymesh_primitives::asset::NonFungibleType),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct CheckpointId(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct CustomAssetTypeId(pub u32);
      #[derive(Clone, Debug, PartialEq, Eq, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct FundingRoundName(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum NonFungibleType {
        #[codec(index = 0u8)]
        Derivative,
        #[codec(index = 1u8)]
        FixedIncome,
        #[codec(index = 2u8)]
        Invoice,
        #[codec(index = 3u8)]
        Custom(polymesh_primitives::asset::CustomAssetTypeId),
      }
    }
    pub mod asset_identifier {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AssetIdentifier {
        #[codec(index = 0u8)]
        CUSIP([u8; 9usize]),
        #[codec(index = 1u8)]
        CINS([u8; 9usize]),
        #[codec(index = 2u8)]
        ISIN([u8; 12usize]),
        #[codec(index = 3u8)]
        LEI([u8; 20usize]),
        #[codec(index = 4u8)]
        FIGI([u8; 12usize]),
      }
    }
    pub mod asset_metadata {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataDescription(pub ::alloc::vec::Vec<u8>);
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataGlobalKey(pub u64);
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AssetMetadataKey {
        #[codec(index = 0u8)]
        Global(polymesh_primitives::asset_metadata::AssetMetadataGlobalKey),
        #[codec(index = 1u8)]
        Local(polymesh_primitives::asset_metadata::AssetMetadataLocalKey),
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataLocalKey(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AssetMetadataLockStatus<Moment> {
        #[codec(index = 0u8)]
        Unlocked,
        #[codec(index = 1u8)]
        Locked,
        #[codec(index = 2u8)]
        LockedUntil(Moment),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataName(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataSpec {
        pub url: Option<polymesh_primitives::Url>,
        pub description: Option<polymesh_primitives::asset_metadata::AssetMetadataDescription>,
        pub type_def: Option<::alloc::vec::Vec<u8>>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataValue(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataValueDetail<Moment> {
        pub expire: Option<Moment>,
        pub lock_status: polymesh_primitives::asset_metadata::AssetMetadataLockStatus<Moment>,
      }
    }
    pub mod authorization {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Authorization<AccountId, Moment> {
        pub authorization_data: polymesh_primitives::authorization::AuthorizationData<AccountId>,
        pub authorized_by: ::polymesh_api_client::IdentityId,
        pub expiry: Option<Moment>,
        pub auth_id: Moment,
        pub count: u32,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AuthorizationData<AccountId> {
        #[codec(index = 0u8)]
        AttestPrimaryKeyRotation(::polymesh_api_client::IdentityId),
        #[codec(index = 1u8)]
        RotatePrimaryKey,
        #[codec(index = 2u8)]
        TransferTicker(polymesh_primitives::ticker::Ticker),
        #[codec(index = 3u8)]
        AddMultiSigSigner(AccountId),
        #[codec(index = 4u8)]
        TransferAssetOwnership(::polymesh_api_client::AssetId),
        #[codec(index = 5u8)]
        JoinIdentity(polymesh_primitives::secondary_key::Permissions),
        #[codec(index = 6u8)]
        PortfolioCustody(polymesh_primitives::identity_id::PortfolioId),
        #[codec(index = 7u8)]
        BecomeAgent(
          ::polymesh_api_client::AssetId,
          polymesh_primitives::agent::AgentGroup,
        ),
        #[codec(index = 8u8)]
        AddRelayerPayingKey(AccountId, AccountId, u128),
        #[codec(index = 9u8)]
        RotatePrimaryKeyToSecondary(polymesh_primitives::secondary_key::Permissions),
      }
    }
    pub mod cdd_id {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct CddId(pub [u8; 32usize]);
    }
    pub mod checkpoint {
      use super::*;
      #[doc = "Events for this module."]
      #[doc = ""]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CheckpointEvent {
        #[doc = "A checkpoint was created."]
        #[doc = ""]
        #[doc = "(caller DID, AssetId, checkpoint ID, total supply, checkpoint timestamp)"]
        #[codec(index = 0u8)]
        CheckpointCreated(
          Option<::polymesh_api_client::IdentityId>,
          ::polymesh_api_client::AssetId,
          polymesh_primitives::asset::CheckpointId,
          u128,
          u64,
        ),
        #[doc = "The maximum complexity for an arbitrary asset's schedule set was changed."]
        #[doc = ""]
        #[doc = "(GC DID, the new maximum)"]
        #[codec(index = 1u8)]
        MaximumSchedulesComplexityChanged(::polymesh_api_client::IdentityId, u64),
        #[doc = "A checkpoint schedule was created."]
        #[doc = ""]
        #[doc = "(caller DID, AssetId, schedule id, schedule)"]
        #[codec(index = 2u8)]
        ScheduleCreated(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::AssetId,
          polymesh_primitives::checkpoint::ScheduleId,
          polymesh_primitives::checkpoint::ScheduleCheckpoints,
        ),
        #[doc = "A checkpoint schedule was removed."]
        #[doc = ""]
        #[doc = "(caller DID, AssetId, schedule id, schedule)"]
        #[codec(index = 3u8)]
        ScheduleRemoved(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::AssetId,
          polymesh_primitives::checkpoint::ScheduleId,
          polymesh_primitives::checkpoint::ScheduleCheckpoints,
        ),
      }
      impl CheckpointEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::CheckpointCreated(_, _, _, _, _) => "Checkpoint.CheckpointCreated",
            Self::MaximumSchedulesComplexityChanged(_, _) => {
              "Checkpoint.MaximumSchedulesComplexityChanged"
            }
            Self::ScheduleCreated(_, _, _, _) => "Checkpoint.ScheduleCreated",
            Self::ScheduleRemoved(_, _, _, _) => "Checkpoint.ScheduleRemoved",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CheckpointEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::CheckpointCreated(_, _, _, _, _) => &[
              "A checkpoint was created.",
              "",
              "(caller DID, AssetId, checkpoint ID, total supply, checkpoint timestamp)",
            ],
            Self::MaximumSchedulesComplexityChanged(_, _) => &[
              "The maximum complexity for an arbitrary asset's schedule set was changed.",
              "",
              "(GC DID, the new maximum)",
            ],
            Self::ScheduleCreated(_, _, _, _) => &[
              "A checkpoint schedule was created.",
              "",
              "(caller DID, AssetId, schedule id, schedule)",
            ],
            Self::ScheduleRemoved(_, _, _, _) => &[
              "A checkpoint schedule was removed.",
              "",
              "(caller DID, AssetId, schedule id, schedule)",
            ],
            _ => &[""],
          }
        }
      }
      impl From<CheckpointEvent> for &'static str {
        fn from(v: CheckpointEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CheckpointEvent> for &'static str {
        fn from(v: &CheckpointEvent) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NextCheckpoints {
        pub next_at: u64,
        pub total_pending: u64,
        pub schedules:
          ::alloc::collections::BTreeMap<polymesh_primitives::checkpoint::ScheduleId, u64>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ScheduleCheckpoints {
        pub pending: ::alloc::collections::BTreeSet<u64>,
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ScheduleId(pub u64);
    }
    pub mod compliance_manager {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetCompliance {
        pub paused: bool,
        pub requirements:
          ::alloc::vec::Vec<polymesh_primitives::compliance_manager::ComplianceRequirement>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ComplianceRequirement {
        pub sender_conditions: ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
        pub receiver_conditions: ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
        pub id: u32,
      }
    }
    pub mod condition {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Condition {
        pub condition_type: polymesh_primitives::condition::ConditionType,
        pub issuers: ::alloc::vec::Vec<polymesh_primitives::condition::TrustedIssuer>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ConditionType {
        #[codec(index = 0u8)]
        IsPresent(polymesh_primitives::identity_claim::Claim),
        #[codec(index = 1u8)]
        IsAbsent(polymesh_primitives::identity_claim::Claim),
        #[codec(index = 2u8)]
        IsAnyOf(::alloc::vec::Vec<polymesh_primitives::identity_claim::Claim>),
        #[codec(index = 3u8)]
        IsNoneOf(::alloc::vec::Vec<polymesh_primitives::identity_claim::Claim>),
        #[codec(index = 4u8)]
        IsIdentity(polymesh_primitives::condition::TargetIdentity),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum TargetIdentity {
        #[codec(index = 0u8)]
        ExternalAgent,
        #[codec(index = 1u8)]
        Specific(::polymesh_api_client::IdentityId),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum TrustedFor {
        #[codec(index = 0u8)]
        Any,
        #[codec(index = 1u8)]
        Specific(::alloc::vec::Vec<polymesh_primitives::identity_claim::ClaimType>),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct TrustedIssuer {
        pub issuer: ::polymesh_api_client::IdentityId,
        pub trusted_for: polymesh_primitives::condition::TrustedFor,
      }
    }
    pub mod document {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Document {
        pub uri: polymesh_primitives::document::DocumentUri,
        pub content_hash: polymesh_primitives::document_hash::DocumentHash,
        pub name: polymesh_primitives::document::DocumentName,
        pub doc_type: Option<polymesh_primitives::document::DocumentType>,
        pub filing_date: Option<u64>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DocumentId(pub u32);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DocumentName(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DocumentType(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DocumentUri(pub ::alloc::vec::Vec<u8>);
    }
    pub mod document_hash {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum DocumentHash {
        #[codec(index = 0u8)]
        None,
        #[codec(index = 1u8)]
        H512(
          #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))] [u8; 64usize],
        ),
        #[codec(index = 2u8)]
        H384(
          #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))] [u8; 48usize],
        ),
        #[codec(index = 3u8)]
        H320(
          #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))] [u8; 40usize],
        ),
        #[codec(index = 4u8)]
        H256([u8; 32usize]),
        #[codec(index = 5u8)]
        H224([u8; 28usize]),
        #[codec(index = 6u8)]
        H192([u8; 24usize]),
        #[codec(index = 7u8)]
        H160([u8; 20usize]),
        #[codec(index = 8u8)]
        H128([u8; 16usize]),
      }
    }
    pub mod event_only {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct EventOnly<T>(pub T);
    }
    pub mod group {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct InactiveMember<Moment> {
        pub id: ::polymesh_api_client::IdentityId,
        pub deactivated_at: Moment,
        pub expiry: Option<Moment>,
      }
      #[doc = "Events for this module."]
      #[doc = ""]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I> {
        #[doc = "The given member was added; see the transaction for who."]
        #[doc = "caller DID, New member DID."]
        #[codec(index = 0u8)]
        MemberAdded(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::IdentityId,
        ),
        #[doc = "The given member was removed; see the transaction for who."]
        #[doc = "caller DID, member DID that get removed."]
        #[codec(index = 1u8)]
        MemberRemoved(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::IdentityId,
        ),
        #[doc = "The given member has been revoked at specific time-stamp."]
        #[doc = "caller DID, member DID that get revoked."]
        #[codec(index = 2u8)]
        MemberRevoked(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::IdentityId,
        ),
        #[doc = "Two members were swapped; see the transaction for who."]
        #[doc = "caller DID, Removed DID, New add DID."]
        #[codec(index = 3u8)]
        MembersSwapped(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::IdentityId,
        ),
        #[doc = "The membership was reset; see the transaction for who the new set is."]
        #[doc = "caller DID, List of new members."]
        #[codec(index = 4u8)]
        MembersReset(
          ::polymesh_api_client::IdentityId,
          ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
        ),
        #[doc = "The limit of how many active members there can be concurrently was changed."]
        #[codec(index = 5u8)]
        ActiveLimitChanged(::polymesh_api_client::IdentityId, u32, u32),
        #[doc = "Phantom member, never used."]
        #[codec(index = 6u8)]
        Dummy,
        PhantomDataVariant(core::marker::PhantomData<(AccountId, RuntimeEvent, I)>),
      }
      impl<AccountId, RuntimeEvent, I> UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I> {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::MemberAdded(_, _) => "UpgradeCommitteeMembership.MemberAdded",
            Self::MemberRemoved(_, _) => "UpgradeCommitteeMembership.MemberRemoved",
            Self::MemberRevoked(_, _) => "UpgradeCommitteeMembership.MemberRevoked",
            Self::MembersSwapped(_, _, _) => "UpgradeCommitteeMembership.MembersSwapped",
            Self::MembersReset(_, _) => "UpgradeCommitteeMembership.MembersReset",
            Self::ActiveLimitChanged(_, _, _) => "UpgradeCommitteeMembership.ActiveLimitChanged",
            Self::Dummy => "UpgradeCommitteeMembership.Dummy",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl<AccountId, RuntimeEvent, I> ::polymesh_api_client::EnumInfo
        for UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I>
      {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::MemberAdded(_, _) => &[
              "The given member was added; see the transaction for who.",
              "caller DID, New member DID.",
            ],
            Self::MemberRemoved(_, _) => &[
              "The given member was removed; see the transaction for who.",
              "caller DID, member DID that get removed.",
            ],
            Self::MemberRevoked(_, _) => &[
              "The given member has been revoked at specific time-stamp.",
              "caller DID, member DID that get revoked.",
            ],
            Self::MembersSwapped(_, _, _) => &[
              "Two members were swapped; see the transaction for who.",
              "caller DID, Removed DID, New add DID.",
            ],
            Self::MembersReset(_, _) => &[
              "The membership was reset; see the transaction for who the new set is.",
              "caller DID, List of new members.",
            ],
            Self::ActiveLimitChanged(_, _, _) => {
              &["The limit of how many active members there can be concurrently was changed."]
            }
            Self::Dummy => &["Phantom member, never used."],
            _ => &[""],
          }
        }
      }
      impl<AccountId, RuntimeEvent, I>
        From<UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I>> for &'static str
      {
        fn from(v: UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I>) -> Self {
          v.as_static_str()
        }
      }
      impl<AccountId, RuntimeEvent, I>
        From<&UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I>> for &'static str
      {
        fn from(v: &UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I>) -> Self {
          v.as_static_str()
        }
      }
    }
    pub mod identity {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct CreateChildIdentityWithAuth<AccountId> {
        pub key: AccountId,
        pub auth_signature: primitive_types::H512,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DidRecord<AccountId> {
        pub primary_key: Option<AccountId>,
      }
      #[doc = "Events for this module."]
      #[doc = ""]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum IdentityEvent<AccountId, Moment> {
        #[doc = "Identity created."]
        #[doc = ""]
        #[doc = "(DID, primary key, secondary keys)"]
        #[codec(index = 0u8)]
        DidCreated(
          ::polymesh_api_client::IdentityId,
          AccountId,
          ::alloc::vec::Vec<polymesh_primitives::secondary_key::SecondaryKey<AccountId>>,
        ),
        #[doc = "Secondary keys added to identity."]
        #[doc = ""]
        #[doc = "(DID, new keys)"]
        #[codec(index = 1u8)]
        SecondaryKeysAdded(
          ::polymesh_api_client::IdentityId,
          ::alloc::vec::Vec<polymesh_primitives::secondary_key::SecondaryKey<AccountId>>,
        ),
        #[doc = "Secondary keys removed from identity."]
        #[doc = ""]
        #[doc = "(DID, the keys that got removed)"]
        #[codec(index = 2u8)]
        SecondaryKeysRemoved(
          ::polymesh_api_client::IdentityId,
          ::alloc::vec::Vec<AccountId>,
        ),
        #[doc = "A secondary key left their identity."]
        #[doc = ""]
        #[doc = "(DID, secondary key)"]
        #[codec(index = 3u8)]
        SecondaryKeyLeftIdentity(::polymesh_api_client::IdentityId, AccountId),
        #[doc = "Secondary key permissions updated."]
        #[doc = ""]
        #[doc = "(DID, updated secondary key, previous permissions, new permissions)"]
        #[codec(index = 4u8)]
        SecondaryKeyPermissionsUpdated(
          ::polymesh_api_client::IdentityId,
          AccountId,
          polymesh_primitives::secondary_key::Permissions,
          polymesh_primitives::secondary_key::Permissions,
        ),
        #[doc = "Primary key of identity changed."]
        #[doc = ""]
        #[doc = "(DID, old primary key account ID, new ID)"]
        #[codec(index = 5u8)]
        PrimaryKeyUpdated(::polymesh_api_client::IdentityId, AccountId, AccountId),
        #[doc = "Claim added to identity."]
        #[doc = ""]
        #[doc = "(DID, claim)"]
        #[codec(index = 6u8)]
        ClaimAdded(
          ::polymesh_api_client::IdentityId,
          polymesh_primitives::identity_claim::IdentityClaim,
        ),
        #[doc = "Claim revoked from identity."]
        #[doc = ""]
        #[doc = "(DID, claim)"]
        #[codec(index = 7u8)]
        ClaimRevoked(
          ::polymesh_api_client::IdentityId,
          polymesh_primitives::identity_claim::IdentityClaim,
        ),
        #[doc = "Asset's identity registered."]
        #[doc = ""]
        #[doc = "(Asset DID, ticker)"]
        #[codec(index = 8u8)]
        AssetDidRegistered(
          ::polymesh_api_client::IdentityId,
          polymesh_primitives::ticker::Ticker,
        ),
        #[doc = "New authorization added."]
        #[doc = ""]
        #[doc = "(authorised_by, target_did, target_key, auth_id, authorization_data, expiry)"]
        #[codec(index = 9u8)]
        AuthorizationAdded(
          ::polymesh_api_client::IdentityId,
          Option<::polymesh_api_client::IdentityId>,
          Option<AccountId>,
          Moment,
          polymesh_primitives::authorization::AuthorizationData<AccountId>,
          Option<Moment>,
        ),
        #[doc = "Authorization revoked by the authorizer."]
        #[doc = ""]
        #[doc = "(authorized_identity, authorized_key, auth_id)"]
        #[codec(index = 10u8)]
        AuthorizationRevoked(
          Option<::polymesh_api_client::IdentityId>,
          Option<AccountId>,
          Moment,
        ),
        #[doc = "Authorization rejected by the user who was authorized."]
        #[doc = ""]
        #[doc = "(authorized_identity, authorized_key, auth_id)"]
        #[codec(index = 11u8)]
        AuthorizationRejected(
          Option<::polymesh_api_client::IdentityId>,
          Option<AccountId>,
          Moment,
        ),
        #[doc = "Authorization consumed."]
        #[doc = ""]
        #[doc = "(authorized_identity, authorized_key, auth_id)"]
        #[codec(index = 12u8)]
        AuthorizationConsumed(
          Option<::polymesh_api_client::IdentityId>,
          Option<AccountId>,
          Moment,
        ),
        #[doc = "Accepting Authorization retry limit reached."]
        #[doc = ""]
        #[doc = "(authorized_identity, authorized_key, auth_id)"]
        #[codec(index = 13u8)]
        AuthorizationRetryLimitReached(
          Option<::polymesh_api_client::IdentityId>,
          Option<AccountId>,
          Moment,
        ),
        #[doc = "CDD requirement for updating primary key changed."]
        #[doc = ""]
        #[doc = "(new_requirement)"]
        #[codec(index = 14u8)]
        CddRequirementForPrimaryKeyUpdated(bool),
        #[doc = "CDD claims generated by `IdentityId` (a CDD Provider) have been invalidated from"]
        #[doc = "`Moment`."]
        #[doc = ""]
        #[doc = "(CDD provider DID, disable from date)"]
        #[codec(index = 15u8)]
        CddClaimsInvalidated(::polymesh_api_client::IdentityId, Moment),
        #[doc = "All Secondary keys of the identity ID are frozen."]
        #[doc = ""]
        #[doc = "(DID)"]
        #[codec(index = 16u8)]
        SecondaryKeysFrozen(::polymesh_api_client::IdentityId),
        #[doc = "All Secondary keys of the identity ID are unfrozen."]
        #[doc = ""]
        #[doc = "(DID)"]
        #[codec(index = 17u8)]
        SecondaryKeysUnfrozen(::polymesh_api_client::IdentityId),
        #[doc = "A new CustomClaimType was added."]
        #[doc = ""]
        #[doc = "(DID, id, Type)"]
        #[codec(index = 18u8)]
        CustomClaimTypeAdded(
          ::polymesh_api_client::IdentityId,
          polymesh_primitives::identity_claim::CustomClaimTypeId,
          ::alloc::vec::Vec<u8>,
        ),
        #[doc = "Child identity created."]
        #[doc = ""]
        #[doc = "(Parent DID, Child DID, primary key)"]
        #[codec(index = 19u8)]
        ChildDidCreated(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::IdentityId,
          AccountId,
        ),
        #[doc = "Child identity unlinked from parent identity."]
        #[doc = ""]
        #[doc = "(Caller DID, Parent DID, Child DID)"]
        #[codec(index = 20u8)]
        ChildDidUnlinked(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::IdentityId,
        ),
      }
      impl<AccountId, Moment> IdentityEvent<AccountId, Moment> {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::DidCreated(_, _, _) => "Identity.DidCreated",
            Self::SecondaryKeysAdded(_, _) => "Identity.SecondaryKeysAdded",
            Self::SecondaryKeysRemoved(_, _) => "Identity.SecondaryKeysRemoved",
            Self::SecondaryKeyLeftIdentity(_, _) => "Identity.SecondaryKeyLeftIdentity",
            Self::SecondaryKeyPermissionsUpdated(_, _, _, _) => {
              "Identity.SecondaryKeyPermissionsUpdated"
            }
            Self::PrimaryKeyUpdated(_, _, _) => "Identity.PrimaryKeyUpdated",
            Self::ClaimAdded(_, _) => "Identity.ClaimAdded",
            Self::ClaimRevoked(_, _) => "Identity.ClaimRevoked",
            Self::AssetDidRegistered(_, _) => "Identity.AssetDidRegistered",
            Self::AuthorizationAdded(_, _, _, _, _, _) => "Identity.AuthorizationAdded",
            Self::AuthorizationRevoked(_, _, _) => "Identity.AuthorizationRevoked",
            Self::AuthorizationRejected(_, _, _) => "Identity.AuthorizationRejected",
            Self::AuthorizationConsumed(_, _, _) => "Identity.AuthorizationConsumed",
            Self::AuthorizationRetryLimitReached(_, _, _) => {
              "Identity.AuthorizationRetryLimitReached"
            }
            Self::CddRequirementForPrimaryKeyUpdated(_) => {
              "Identity.CddRequirementForPrimaryKeyUpdated"
            }
            Self::CddClaimsInvalidated(_, _) => "Identity.CddClaimsInvalidated",
            Self::SecondaryKeysFrozen(_) => "Identity.SecondaryKeysFrozen",
            Self::SecondaryKeysUnfrozen(_) => "Identity.SecondaryKeysUnfrozen",
            Self::CustomClaimTypeAdded(_, _, _) => "Identity.CustomClaimTypeAdded",
            Self::ChildDidCreated(_, _, _) => "Identity.ChildDidCreated",
            Self::ChildDidUnlinked(_, _, _) => "Identity.ChildDidUnlinked",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl<AccountId, Moment> ::polymesh_api_client::EnumInfo for IdentityEvent<AccountId, Moment> {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::DidCreated(_, _, _) => &[
              "Identity created.",
              "",
              "(DID, primary key, secondary keys)",
            ],
            Self::SecondaryKeysAdded(_, _) => {
              &["Secondary keys added to identity.", "", "(DID, new keys)"]
            }
            Self::SecondaryKeysRemoved(_, _) => &[
              "Secondary keys removed from identity.",
              "",
              "(DID, the keys that got removed)",
            ],
            Self::SecondaryKeyLeftIdentity(_, _) => &[
              "A secondary key left their identity.",
              "",
              "(DID, secondary key)",
            ],
            Self::SecondaryKeyPermissionsUpdated(_, _, _, _) => &[
              "Secondary key permissions updated.",
              "",
              "(DID, updated secondary key, previous permissions, new permissions)",
            ],
            Self::PrimaryKeyUpdated(_, _, _) => &[
              "Primary key of identity changed.",
              "",
              "(DID, old primary key account ID, new ID)",
            ],
            Self::ClaimAdded(_, _) => &["Claim added to identity.", "", "(DID, claim)"],
            Self::ClaimRevoked(_, _) => &["Claim revoked from identity.", "", "(DID, claim)"],
            Self::AssetDidRegistered(_, _) => {
              &["Asset's identity registered.", "", "(Asset DID, ticker)"]
            }
            Self::AuthorizationAdded(_, _, _, _, _, _) => &[
              "New authorization added.",
              "",
              "(authorised_by, target_did, target_key, auth_id, authorization_data, expiry)",
            ],
            Self::AuthorizationRevoked(_, _, _) => &[
              "Authorization revoked by the authorizer.",
              "",
              "(authorized_identity, authorized_key, auth_id)",
            ],
            Self::AuthorizationRejected(_, _, _) => &[
              "Authorization rejected by the user who was authorized.",
              "",
              "(authorized_identity, authorized_key, auth_id)",
            ],
            Self::AuthorizationConsumed(_, _, _) => &[
              "Authorization consumed.",
              "",
              "(authorized_identity, authorized_key, auth_id)",
            ],
            Self::AuthorizationRetryLimitReached(_, _, _) => &[
              "Accepting Authorization retry limit reached.",
              "",
              "(authorized_identity, authorized_key, auth_id)",
            ],
            Self::CddRequirementForPrimaryKeyUpdated(_) => &[
              "CDD requirement for updating primary key changed.",
              "",
              "(new_requirement)",
            ],
            Self::CddClaimsInvalidated(_, _) => &[
              "CDD claims generated by `IdentityId` (a CDD Provider) have been invalidated from",
              "`Moment`.",
              "",
              "(CDD provider DID, disable from date)",
            ],
            Self::SecondaryKeysFrozen(_) => &[
              "All Secondary keys of the identity ID are frozen.",
              "",
              "(DID)",
            ],
            Self::SecondaryKeysUnfrozen(_) => &[
              "All Secondary keys of the identity ID are unfrozen.",
              "",
              "(DID)",
            ],
            Self::CustomClaimTypeAdded(_, _, _) => {
              &["A new CustomClaimType was added.", "", "(DID, id, Type)"]
            }
            Self::ChildDidCreated(_, _, _) => &[
              "Child identity created.",
              "",
              "(Parent DID, Child DID, primary key)",
            ],
            Self::ChildDidUnlinked(_, _, _) => &[
              "Child identity unlinked from parent identity.",
              "",
              "(Caller DID, Parent DID, Child DID)",
            ],
            _ => &[""],
          }
        }
      }
      impl<AccountId, Moment> From<IdentityEvent<AccountId, Moment>> for &'static str {
        fn from(v: IdentityEvent<AccountId, Moment>) -> Self {
          v.as_static_str()
        }
      }
      impl<AccountId, Moment> From<&IdentityEvent<AccountId, Moment>> for &'static str {
        fn from(v: &IdentityEvent<AccountId, Moment>) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SecondaryKeyWithAuth<AccountId> {
        pub secondary_key: polymesh_primitives::secondary_key::SecondaryKey<AccountId>,
        pub auth_signature: primitive_types::H512,
      }
    }
    pub mod identity_claim {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Claim {
        #[codec(index = 0u8)]
        Accredited(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 1u8)]
        Affiliate(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 2u8)]
        BuyLockup(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 3u8)]
        SellLockup(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 4u8)]
        CustomerDueDiligence(polymesh_primitives::cdd_id::CddId),
        #[codec(index = 5u8)]
        KnowYourCustomer(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 6u8)]
        Jurisdiction(
          polymesh_primitives::jurisdiction::CountryCode,
          polymesh_primitives::identity_claim::Scope,
        ),
        #[codec(index = 7u8)]
        Exempted(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 8u8)]
        Blocked(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 9u8)]
        Custom(
          polymesh_primitives::identity_claim::CustomClaimTypeId,
          Option<polymesh_primitives::identity_claim::Scope>,
        ),
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ClaimType {
        #[codec(index = 0u8)]
        Accredited,
        #[codec(index = 1u8)]
        Affiliate,
        #[codec(index = 2u8)]
        BuyLockup,
        #[codec(index = 3u8)]
        SellLockup,
        #[codec(index = 4u8)]
        CustomerDueDiligence,
        #[codec(index = 5u8)]
        KnowYourCustomer,
        #[codec(index = 6u8)]
        Jurisdiction,
        #[codec(index = 7u8)]
        Exempted,
        #[codec(index = 8u8)]
        Blocked,
        #[codec(index = 9u8)]
        Custom(polymesh_primitives::identity_claim::CustomClaimTypeId),
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct CustomClaimTypeId(pub u32);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct IdentityClaim {
        pub claim_issuer: ::polymesh_api_client::IdentityId,
        pub issuance_date: u64,
        pub last_update_date: u64,
        pub expiry: Option<u64>,
        pub claim: polymesh_primitives::identity_claim::Claim,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Scope {
        #[codec(index = 0u8)]
        Identity(::polymesh_api_client::IdentityId),
        #[codec(index = 1u8)]
        Asset(::polymesh_api_client::AssetId),
        #[codec(index = 2u8)]
        Custom(::alloc::vec::Vec<u8>),
      }
    }
    pub mod identity_id {
      use super::*;
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct IdentityId(pub [u8; 32usize]);
      #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PortfolioId {
        pub did: ::polymesh_api_client::IdentityId,
        pub kind: polymesh_primitives::identity_id::PortfolioKind,
      }
      #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PortfolioKind {
        #[codec(index = 0u8)]
        Default,
        #[codec(index = 1u8)]
        User(polymesh_primitives::identity_id::PortfolioNumber),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PortfolioName(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PortfolioNumber(pub u64);
    }
    pub mod jurisdiction {
      use super::*;
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CountryCode {
        #[codec(index = 0u8)]
        AF,
        #[codec(index = 1u8)]
        AX,
        #[codec(index = 2u8)]
        AL,
        #[codec(index = 3u8)]
        DZ,
        #[codec(index = 4u8)]
        AS,
        #[codec(index = 5u8)]
        AD,
        #[codec(index = 6u8)]
        AO,
        #[codec(index = 7u8)]
        AI,
        #[codec(index = 8u8)]
        AQ,
        #[codec(index = 9u8)]
        AG,
        #[codec(index = 10u8)]
        AR,
        #[codec(index = 11u8)]
        AM,
        #[codec(index = 12u8)]
        AW,
        #[codec(index = 13u8)]
        AU,
        #[codec(index = 14u8)]
        AT,
        #[codec(index = 15u8)]
        AZ,
        #[codec(index = 16u8)]
        BS,
        #[codec(index = 17u8)]
        BH,
        #[codec(index = 18u8)]
        BD,
        #[codec(index = 19u8)]
        BB,
        #[codec(index = 20u8)]
        BY,
        #[codec(index = 21u8)]
        BE,
        #[codec(index = 22u8)]
        BZ,
        #[codec(index = 23u8)]
        BJ,
        #[codec(index = 24u8)]
        BM,
        #[codec(index = 25u8)]
        BT,
        #[codec(index = 26u8)]
        BO,
        #[codec(index = 27u8)]
        BA,
        #[codec(index = 28u8)]
        BW,
        #[codec(index = 29u8)]
        BV,
        #[codec(index = 30u8)]
        BR,
        #[codec(index = 31u8)]
        VG,
        #[codec(index = 32u8)]
        IO,
        #[codec(index = 33u8)]
        BN,
        #[codec(index = 34u8)]
        BG,
        #[codec(index = 35u8)]
        BF,
        #[codec(index = 36u8)]
        BI,
        #[codec(index = 37u8)]
        KH,
        #[codec(index = 38u8)]
        CM,
        #[codec(index = 39u8)]
        CA,
        #[codec(index = 40u8)]
        CV,
        #[codec(index = 41u8)]
        KY,
        #[codec(index = 42u8)]
        CF,
        #[codec(index = 43u8)]
        TD,
        #[codec(index = 44u8)]
        CL,
        #[codec(index = 45u8)]
        CN,
        #[codec(index = 46u8)]
        HK,
        #[codec(index = 47u8)]
        MO,
        #[codec(index = 48u8)]
        CX,
        #[codec(index = 49u8)]
        CC,
        #[codec(index = 50u8)]
        CO,
        #[codec(index = 51u8)]
        KM,
        #[codec(index = 52u8)]
        CG,
        #[codec(index = 53u8)]
        CD,
        #[codec(index = 54u8)]
        CK,
        #[codec(index = 55u8)]
        CR,
        #[codec(index = 56u8)]
        CI,
        #[codec(index = 57u8)]
        HR,
        #[codec(index = 58u8)]
        CU,
        #[codec(index = 59u8)]
        CY,
        #[codec(index = 60u8)]
        CZ,
        #[codec(index = 61u8)]
        DK,
        #[codec(index = 62u8)]
        DJ,
        #[codec(index = 63u8)]
        DM,
        #[codec(index = 64u8)]
        DO,
        #[codec(index = 65u8)]
        EC,
        #[codec(index = 66u8)]
        EG,
        #[codec(index = 67u8)]
        SV,
        #[codec(index = 68u8)]
        GQ,
        #[codec(index = 69u8)]
        ER,
        #[codec(index = 70u8)]
        EE,
        #[codec(index = 71u8)]
        ET,
        #[codec(index = 72u8)]
        FK,
        #[codec(index = 73u8)]
        FO,
        #[codec(index = 74u8)]
        FJ,
        #[codec(index = 75u8)]
        FI,
        #[codec(index = 76u8)]
        FR,
        #[codec(index = 77u8)]
        GF,
        #[codec(index = 78u8)]
        PF,
        #[codec(index = 79u8)]
        TF,
        #[codec(index = 80u8)]
        GA,
        #[codec(index = 81u8)]
        GM,
        #[codec(index = 82u8)]
        GE,
        #[codec(index = 83u8)]
        DE,
        #[codec(index = 84u8)]
        GH,
        #[codec(index = 85u8)]
        GI,
        #[codec(index = 86u8)]
        GR,
        #[codec(index = 87u8)]
        GL,
        #[codec(index = 88u8)]
        GD,
        #[codec(index = 89u8)]
        GP,
        #[codec(index = 90u8)]
        GU,
        #[codec(index = 91u8)]
        GT,
        #[codec(index = 92u8)]
        GG,
        #[codec(index = 93u8)]
        GN,
        #[codec(index = 94u8)]
        GW,
        #[codec(index = 95u8)]
        GY,
        #[codec(index = 96u8)]
        HT,
        #[codec(index = 97u8)]
        HM,
        #[codec(index = 98u8)]
        VA,
        #[codec(index = 99u8)]
        HN,
        #[codec(index = 100u8)]
        HU,
        #[codec(index = 101u8)]
        IS,
        #[codec(index = 102u8)]
        IN,
        #[codec(index = 103u8)]
        ID,
        #[codec(index = 104u8)]
        IR,
        #[codec(index = 105u8)]
        IQ,
        #[codec(index = 106u8)]
        IE,
        #[codec(index = 107u8)]
        IM,
        #[codec(index = 108u8)]
        IL,
        #[codec(index = 109u8)]
        IT,
        #[codec(index = 110u8)]
        JM,
        #[codec(index = 111u8)]
        JP,
        #[codec(index = 112u8)]
        JE,
        #[codec(index = 113u8)]
        JO,
        #[codec(index = 114u8)]
        KZ,
        #[codec(index = 115u8)]
        KE,
        #[codec(index = 116u8)]
        KI,
        #[codec(index = 117u8)]
        KP,
        #[codec(index = 118u8)]
        KR,
        #[codec(index = 119u8)]
        KW,
        #[codec(index = 120u8)]
        KG,
        #[codec(index = 121u8)]
        LA,
        #[codec(index = 122u8)]
        LV,
        #[codec(index = 123u8)]
        LB,
        #[codec(index = 124u8)]
        LS,
        #[codec(index = 125u8)]
        LR,
        #[codec(index = 126u8)]
        LY,
        #[codec(index = 127u8)]
        LI,
        #[codec(index = 128u8)]
        LT,
        #[codec(index = 129u8)]
        LU,
        #[codec(index = 130u8)]
        MK,
        #[codec(index = 131u8)]
        MG,
        #[codec(index = 132u8)]
        MW,
        #[codec(index = 133u8)]
        MY,
        #[codec(index = 134u8)]
        MV,
        #[codec(index = 135u8)]
        ML,
        #[codec(index = 136u8)]
        MT,
        #[codec(index = 137u8)]
        MH,
        #[codec(index = 138u8)]
        MQ,
        #[codec(index = 139u8)]
        MR,
        #[codec(index = 140u8)]
        MU,
        #[codec(index = 141u8)]
        YT,
        #[codec(index = 142u8)]
        MX,
        #[codec(index = 143u8)]
        FM,
        #[codec(index = 144u8)]
        MD,
        #[codec(index = 145u8)]
        MC,
        #[codec(index = 146u8)]
        MN,
        #[codec(index = 147u8)]
        ME,
        #[codec(index = 148u8)]
        MS,
        #[codec(index = 149u8)]
        MA,
        #[codec(index = 150u8)]
        MZ,
        #[codec(index = 151u8)]
        MM,
        #[codec(index = 152u8)]
        NA,
        #[codec(index = 153u8)]
        NR,
        #[codec(index = 154u8)]
        NP,
        #[codec(index = 155u8)]
        NL,
        #[codec(index = 156u8)]
        AN,
        #[codec(index = 157u8)]
        NC,
        #[codec(index = 158u8)]
        NZ,
        #[codec(index = 159u8)]
        NI,
        #[codec(index = 160u8)]
        NE,
        #[codec(index = 161u8)]
        NG,
        #[codec(index = 162u8)]
        NU,
        #[codec(index = 163u8)]
        NF,
        #[codec(index = 164u8)]
        MP,
        #[codec(index = 165u8)]
        NO,
        #[codec(index = 166u8)]
        OM,
        #[codec(index = 167u8)]
        PK,
        #[codec(index = 168u8)]
        PW,
        #[codec(index = 169u8)]
        PS,
        #[codec(index = 170u8)]
        PA,
        #[codec(index = 171u8)]
        PG,
        #[codec(index = 172u8)]
        PY,
        #[codec(index = 173u8)]
        PE,
        #[codec(index = 174u8)]
        PH,
        #[codec(index = 175u8)]
        PN,
        #[codec(index = 176u8)]
        PL,
        #[codec(index = 177u8)]
        PT,
        #[codec(index = 178u8)]
        PR,
        #[codec(index = 179u8)]
        QA,
        #[codec(index = 180u8)]
        RE,
        #[codec(index = 181u8)]
        RO,
        #[codec(index = 182u8)]
        RU,
        #[codec(index = 183u8)]
        RW,
        #[codec(index = 184u8)]
        BL,
        #[codec(index = 185u8)]
        SH,
        #[codec(index = 186u8)]
        KN,
        #[codec(index = 187u8)]
        LC,
        #[codec(index = 188u8)]
        MF,
        #[codec(index = 189u8)]
        PM,
        #[codec(index = 190u8)]
        VC,
        #[codec(index = 191u8)]
        WS,
        #[codec(index = 192u8)]
        SM,
        #[codec(index = 193u8)]
        ST,
        #[codec(index = 194u8)]
        SA,
        #[codec(index = 195u8)]
        SN,
        #[codec(index = 196u8)]
        RS,
        #[codec(index = 197u8)]
        SC,
        #[codec(index = 198u8)]
        SL,
        #[codec(index = 199u8)]
        SG,
        #[codec(index = 200u8)]
        SK,
        #[codec(index = 201u8)]
        SI,
        #[codec(index = 202u8)]
        SB,
        #[codec(index = 203u8)]
        SO,
        #[codec(index = 204u8)]
        ZA,
        #[codec(index = 205u8)]
        GS,
        #[codec(index = 206u8)]
        SS,
        #[codec(index = 207u8)]
        ES,
        #[codec(index = 208u8)]
        LK,
        #[codec(index = 209u8)]
        SD,
        #[codec(index = 210u8)]
        SR,
        #[codec(index = 211u8)]
        SJ,
        #[codec(index = 212u8)]
        SZ,
        #[codec(index = 213u8)]
        SE,
        #[codec(index = 214u8)]
        CH,
        #[codec(index = 215u8)]
        SY,
        #[codec(index = 216u8)]
        TW,
        #[codec(index = 217u8)]
        TJ,
        #[codec(index = 218u8)]
        TZ,
        #[codec(index = 219u8)]
        TH,
        #[codec(index = 220u8)]
        TL,
        #[codec(index = 221u8)]
        TG,
        #[codec(index = 222u8)]
        TK,
        #[codec(index = 223u8)]
        TO,
        #[codec(index = 224u8)]
        TT,
        #[codec(index = 225u8)]
        TN,
        #[codec(index = 226u8)]
        TR,
        #[codec(index = 227u8)]
        TM,
        #[codec(index = 228u8)]
        TC,
        #[codec(index = 229u8)]
        TV,
        #[codec(index = 230u8)]
        UG,
        #[codec(index = 231u8)]
        UA,
        #[codec(index = 232u8)]
        AE,
        #[codec(index = 233u8)]
        GB,
        #[codec(index = 234u8)]
        US,
        #[codec(index = 235u8)]
        UM,
        #[codec(index = 236u8)]
        UY,
        #[codec(index = 237u8)]
        UZ,
        #[codec(index = 238u8)]
        VU,
        #[codec(index = 239u8)]
        VE,
        #[codec(index = 240u8)]
        VN,
        #[codec(index = 241u8)]
        VI,
        #[codec(index = 242u8)]
        WF,
        #[codec(index = 243u8)]
        EH,
        #[codec(index = 244u8)]
        YE,
        #[codec(index = 245u8)]
        ZM,
        #[codec(index = 246u8)]
        ZW,
        #[codec(index = 247u8)]
        BQ,
        #[codec(index = 248u8)]
        CW,
        #[codec(index = 249u8)]
        SX,
      }
    }
    pub mod multisig {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ProposalState<Moment> {
        #[codec(index = 0u8)]
        Active { until: Option<Moment> },
        #[codec(index = 1u8)]
        ExecutionSuccessful,
        #[codec(index = 2u8)]
        ExecutionFailed,
        #[codec(index = 3u8)]
        Rejected,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ProposalVoteCount {
        pub approvals: u64,
        pub rejections: u64,
      }
    }
    pub mod nft {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTCollection {
        pub id: polymesh_primitives::nft::NFTCollectionId,
        pub asset_id: ::polymesh_api_client::AssetId,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTCollectionId(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTCollectionKeys(
        pub ::alloc::vec::Vec<polymesh_primitives::asset_metadata::AssetMetadataKey>,
      );
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTId(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTMetadataAttribute {
        pub key: polymesh_primitives::asset_metadata::AssetMetadataKey,
        pub value: polymesh_primitives::asset_metadata::AssetMetadataValue,
      }
      #[derive(Clone, Debug, PartialEq, Eq)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTs {
        pub asset_id: ::polymesh_api_client::AssetId,
        pub ids: ::alloc::vec::Vec<polymesh_primitives::nft::NFTId>,
      }
    }
    pub mod portfolio {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Fund {
        pub description: polymesh_primitives::portfolio::FundDescription,
        pub memo: Option<polymesh_primitives::Memo>,
      }
      #[derive(Clone, Debug, PartialEq, Eq)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum FundDescription {
        #[codec(index = 0u8)]
        Fungible {
          asset_id: ::polymesh_api_client::AssetId,
          amount: u128,
        },
        #[codec(index = 1u8)]
        NonFungible(polymesh_primitives::nft::NFTs),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PortfolioUpdateReason {
        #[codec(index = 0u8)]
        Issued {
          funding_round_name: Option<polymesh_primitives::asset::FundingRoundName>,
        },
        #[codec(index = 1u8)]
        Redeemed,
        #[codec(index = 2u8)]
        Transferred {
          instruction_id: Option<polymesh_primitives::settlement::InstructionId>,
          instruction_memo: Option<polymesh_primitives::Memo>,
        },
        #[codec(index = 3u8)]
        ControllerTransfer,
      }
    }
    pub mod secondary_key {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ExtrinsicPermissions {
        #[codec(index = 0u8)]
        Whole,
        #[codec(index = 1u8)]
        These(
          ::alloc::collections::BTreeMap<
            polymesh_primitives::PalletName,
            polymesh_primitives::secondary_key::PalletPermissions,
          >,
        ),
        #[codec(index = 2u8)]
        Except(
          ::alloc::collections::BTreeMap<
            polymesh_primitives::PalletName,
            polymesh_primitives::secondary_key::PalletPermissions,
          >,
        ),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum KeyRecord<AccountId> {
        #[codec(index = 0u8)]
        PrimaryKey(::polymesh_api_client::IdentityId),
        #[codec(index = 1u8)]
        SecondaryKey(::polymesh_api_client::IdentityId),
        #[codec(index = 2u8)]
        MultiSigSignerKey(AccountId),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PalletPermissions {
        pub extrinsics:
          polymesh_primitives::subset::SubsetRestriction<polymesh_primitives::ExtrinsicName>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Permissions {
        pub asset: polymesh_primitives::subset::SubsetRestriction<::polymesh_api_client::AssetId>,
        pub extrinsic: polymesh_primitives::secondary_key::ExtrinsicPermissions,
        pub portfolio: polymesh_primitives::subset::SubsetRestriction<
          polymesh_primitives::identity_id::PortfolioId,
        >,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SecondaryKey<AccountId> {
        pub key: AccountId,
        pub permissions: polymesh_primitives::secondary_key::Permissions,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Signatory<AccountId> {
        #[codec(index = 0u8)]
        Identity(::polymesh_api_client::IdentityId),
        #[codec(index = 1u8)]
        Account(AccountId),
      }
    }
    pub mod settlement {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AffirmationCount {
        pub sender_asset_count: polymesh_primitives::settlement::AssetCount,
        pub receiver_asset_count: polymesh_primitives::settlement::AssetCount,
        pub offchain_count: u32,
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AffirmationStatus {
        #[codec(index = 0u8)]
        Unknown,
        #[codec(index = 1u8)]
        Pending,
        #[codec(index = 2u8)]
        Affirmed,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetCount {
        pub fungible: u32,
        pub non_fungible: u32,
        pub off_chain: u32,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Instruction<Moment, BlockNumber> {
        pub instruction_id: polymesh_primitives::settlement::InstructionId,
        pub venue_id: Option<polymesh_primitives::settlement::VenueId>,
        pub settlement_type: polymesh_primitives::settlement::SettlementType<BlockNumber>,
        pub created_at: Option<Moment>,
        pub trade_date: Option<Moment>,
        pub value_date: Option<Moment>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct InstructionId(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum InstructionStatus<BlockNumber> {
        #[codec(index = 0u8)]
        Unknown,
        #[codec(index = 1u8)]
        Pending,
        #[codec(index = 2u8)]
        Failed,
        #[codec(index = 3u8)]
        Success(BlockNumber),
        #[codec(index = 4u8)]
        Rejected(BlockNumber),
      }
      #[derive(Clone, Debug, PartialEq, Eq)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Leg {
        #[codec(index = 0u8)]
        Fungible {
          sender: polymesh_primitives::identity_id::PortfolioId,
          receiver: polymesh_primitives::identity_id::PortfolioId,
          asset_id: ::polymesh_api_client::AssetId,
          amount: u128,
        },
        #[codec(index = 1u8)]
        NonFungible {
          sender: polymesh_primitives::identity_id::PortfolioId,
          receiver: polymesh_primitives::identity_id::PortfolioId,
          nfts: polymesh_primitives::nft::NFTs,
        },
        #[codec(index = 2u8)]
        OffChain {
          sender_identity: ::polymesh_api_client::IdentityId,
          receiver_identity: ::polymesh_api_client::IdentityId,
          ticker: polymesh_primitives::ticker::Ticker,
          amount: u128,
        },
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct LegId(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum LegStatus<AccountId> {
        #[codec(index = 0u8)]
        PendingTokenLock,
        #[codec(index = 1u8)]
        ExecutionPending,
        #[codec(index = 2u8)]
        ExecutionToBeSkipped(AccountId, u64),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum MediatorAffirmationStatus<T> {
        #[codec(index = 0u8)]
        Unknown,
        #[codec(index = 1u8)]
        Pending,
        #[codec(index = 2u8)]
        Affirmed { expiry: Option<T> },
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ReceiptDetails<AccountId, OffChainSignature> {
        pub uid: u64,
        pub instruction_id: polymesh_primitives::settlement::InstructionId,
        pub leg_id: polymesh_primitives::settlement::LegId,
        pub signer: AccountId,
        pub signature: OffChainSignature,
        pub metadata: Option<polymesh_primitives::settlement::ReceiptMetadata>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ReceiptMetadata(pub [u8; 32usize]);
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SettlementType<BlockNumber> {
        #[codec(index = 0u8)]
        SettleOnAffirmation,
        #[codec(index = 1u8)]
        SettleOnBlock(BlockNumber),
        #[codec(index = 2u8)]
        SettleManual(BlockNumber),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Venue {
        pub creator: ::polymesh_api_client::IdentityId,
        pub venue_type: polymesh_primitives::settlement::VenueType,
      }
      #[derive(Clone, Debug, PartialEq, Eq, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct VenueDetails(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct VenueId(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum VenueType {
        #[codec(index = 0u8)]
        Other,
        #[codec(index = 1u8)]
        Distribution,
        #[codec(index = 2u8)]
        Sto,
        #[codec(index = 3u8)]
        Exchange,
      }
    }
    pub mod statistics {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Stat1stKey {
        pub asset_id: ::polymesh_api_client::AssetId,
        pub stat_type: polymesh_primitives::statistics::StatType,
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Stat2ndKey {
        #[codec(index = 0u8)]
        NoClaimStat,
        #[codec(index = 1u8)]
        Claim(polymesh_primitives::statistics::StatClaim),
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum StatClaim {
        #[codec(index = 0u8)]
        Accredited(bool),
        #[codec(index = 1u8)]
        Affiliate(bool),
        #[codec(index = 2u8)]
        Jurisdiction(Option<polymesh_primitives::jurisdiction::CountryCode>),
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum StatOpType {
        #[codec(index = 0u8)]
        Count,
        #[codec(index = 1u8)]
        Balance,
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct StatType {
        pub operation_type: polymesh_primitives::statistics::StatOpType,
        pub claim_issuer: Option<(
          polymesh_primitives::identity_claim::ClaimType,
          ::polymesh_api_client::IdentityId,
        )>,
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct StatUpdate {
        pub key2: polymesh_primitives::statistics::Stat2ndKey,
        pub value: Option<u128>,
      }
    }
    pub mod subset {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SubsetRestriction<A: Ord> {
        #[codec(index = 0u8)]
        Whole,
        #[codec(index = 1u8)]
        These(::alloc::collections::BTreeSet<A>),
        #[codec(index = 2u8)]
        Except(::alloc::collections::BTreeSet<A>),
      }
    }
    pub mod ticker {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink::storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Ticker(pub [u8; 12usize]);
    }
    pub mod transfer_compliance {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetTransferCompliance {
        pub paused: bool,
        pub requirements: ::alloc::collections::BTreeSet<
          polymesh_primitives::transfer_compliance::TransferCondition,
        >,
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum TransferCondition {
        #[codec(index = 0u8)]
        MaxInvestorCount(u64),
        #[codec(index = 1u8)]
        MaxInvestorOwnership(::polymesh_api_client::per_things::Permill),
        #[codec(index = 2u8)]
        ClaimCount(
          polymesh_primitives::statistics::StatClaim,
          ::polymesh_api_client::IdentityId,
          u64,
          Option<u64>,
        ),
        #[codec(index = 3u8)]
        ClaimOwnership(
          polymesh_primitives::statistics::StatClaim,
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::per_things::Permill,
          ::polymesh_api_client::per_things::Permill,
        ),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct TransferConditionExemptKey {
        pub asset_id: ::polymesh_api_client::AssetId,
        pub op: polymesh_primitives::statistics::StatOpType,
        pub claim_type: Option<polymesh_primitives::identity_claim::ClaimType>,
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Beneficiary<Balance> {
      pub id: ::polymesh_api_client::IdentityId,
      pub amount: Balance,
    }
    #[derive(
      Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
    )]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ExtrinsicName(pub ::alloc::string::String);
    #[derive(Clone, Debug, PartialEq, Eq)]
    #[cfg_attr(
      all(feature = "ink", feature = "std"),
      derive(::ink::storage::traits::StorageLayout)
    )]
    #[derive(:: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Memo(pub [u8; 32usize]);
    #[derive(
      Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
    )]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PalletName(pub ::alloc::string::String);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PosRatio(pub u32, pub u32);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Url(pub ::alloc::vec::Vec<u8>);
  }
  pub mod polymesh_runtime_common {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct NposSolution16 {
      pub votes1: ::alloc::vec::Vec<(::codec::Compact<u32>, ::codec::Compact<u16>)>,
      pub votes2: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        (
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ),
        ::codec::Compact<u16>,
      )>,
      pub votes3: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 2usize],
        ::codec::Compact<u16>,
      )>,
      pub votes4: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 3usize],
        ::codec::Compact<u16>,
      )>,
      pub votes5: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 4usize],
        ::codec::Compact<u16>,
      )>,
      pub votes6: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 5usize],
        ::codec::Compact<u16>,
      )>,
      pub votes7: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 6usize],
        ::codec::Compact<u16>,
      )>,
      pub votes8: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 7usize],
        ::codec::Compact<u16>,
      )>,
      pub votes9: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 8usize],
        ::codec::Compact<u16>,
      )>,
      pub votes10: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 9usize],
        ::codec::Compact<u16>,
      )>,
      pub votes11: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 10usize],
        ::codec::Compact<u16>,
      )>,
      pub votes12: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 11usize],
        ::codec::Compact<u16>,
      )>,
      pub votes13: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 12usize],
        ::codec::Compact<u16>,
      )>,
      pub votes14: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 13usize],
        ::codec::Compact<u16>,
      )>,
      pub votes15: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 14usize],
        ::codec::Compact<u16>,
      )>,
      pub votes16: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 15usize],
        ::codec::Compact<u16>,
      )>,
    }
  }
  pub mod primitive_types {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct H256(pub [u8; 32usize]);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct H512(
      #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))] pub [u8; 64usize],
    );
  }
  pub mod runtime {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum OriginCaller {
      #[codec(index = 0u8)]
      system(frame_support::dispatch::RawOrigin<::polymesh_api_client::AccountId>),
      #[codec(index = 9u8)]
      PolymeshCommittee(
        pallet_committee::RawOrigin<::polymesh_api_client::AccountId, pallet_committee::Instance1>,
      ),
      #[codec(index = 11u8)]
      TechnicalCommittee(
        pallet_committee::RawOrigin<::polymesh_api_client::AccountId, pallet_committee::Instance3>,
      ),
      #[codec(index = 13u8)]
      UpgradeCommittee(
        pallet_committee::RawOrigin<::polymesh_api_client::AccountId, pallet_committee::Instance4>,
      ),
      #[codec(index = 4u8)]
      Void(sp_core::Void),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Runtime();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RuntimeCall {
      #[codec(index = 0u8)]
      System(frame_system::pallet::SystemCall),
      #[codec(index = 1u8)]
      Babe(pallet_babe::pallet::BabeCall),
      #[codec(index = 2u8)]
      Timestamp(pallet_timestamp::pallet::TimestampCall),
      #[codec(index = 3u8)]
      Indices(pallet_indices::pallet::IndicesCall),
      #[codec(index = 5u8)]
      Balances(pallet_balances::BalancesCall),
      #[codec(index = 6u8)]
      TransactionPayment(pallet_transaction_payment::pallet::TransactionPaymentCall),
      #[codec(index = 7u8)]
      Identity(pallet_identity::IdentityCall),
      #[codec(index = 8u8)]
      CddServiceProviders(pallet_group::UpgradeCommitteeMembershipCall),
      #[codec(index = 9u8)]
      PolymeshCommittee(pallet_committee::UpgradeCommitteeCall),
      #[codec(index = 10u8)]
      CommitteeMembership(pallet_group::UpgradeCommitteeMembershipCall),
      #[codec(index = 11u8)]
      TechnicalCommittee(pallet_committee::UpgradeCommitteeCall),
      #[codec(index = 12u8)]
      TechnicalCommitteeMembership(pallet_group::UpgradeCommitteeMembershipCall),
      #[codec(index = 13u8)]
      UpgradeCommittee(pallet_committee::UpgradeCommitteeCall),
      #[codec(index = 14u8)]
      UpgradeCommitteeMembership(pallet_group::UpgradeCommitteeMembershipCall),
      #[codec(index = 15u8)]
      MultiSig(pallet_multisig::pallet::MultiSigCall),
      #[codec(index = 17u8)]
      Staking(pallet_staking::pallet::pallet::StakingCall),
      #[codec(index = 19u8)]
      Session(pallet_session::pallet::SessionCall),
      #[codec(index = 21u8)]
      Grandpa(pallet_grandpa::pallet::GrandpaCall),
      #[codec(index = 23u8)]
      ImOnline(pallet_im_online::pallet::ImOnlineCall),
      #[codec(index = 26u8)]
      Asset(pallet_asset::AssetCall),
      #[codec(index = 27u8)]
      CapitalDistribution(pallet_corporate_actions::distribution::CapitalDistributionCall),
      #[codec(index = 28u8)]
      Checkpoint(pallet_asset::checkpoint::CheckpointCall),
      #[codec(index = 29u8)]
      ComplianceManager(pallet_compliance_manager::ComplianceManagerCall),
      #[codec(index = 30u8)]
      CorporateAction(pallet_corporate_actions::CorporateActionCall),
      #[codec(index = 31u8)]
      CorporateBallot(pallet_corporate_actions::ballot::CorporateBallotCall),
      #[codec(index = 33u8)]
      Pips(pallet_pips::PipsCall),
      #[codec(index = 34u8)]
      Portfolio(pallet_portfolio::PortfolioCall),
      #[codec(index = 35u8)]
      ProtocolFee(pallet_protocol_fee::ProtocolFeeCall),
      #[codec(index = 36u8)]
      Scheduler(pallet_scheduler::pallet::SchedulerCall),
      #[codec(index = 37u8)]
      Settlement(pallet_settlement::SettlementCall),
      #[codec(index = 38u8)]
      Statistics(pallet_statistics::StatisticsCall),
      #[codec(index = 39u8)]
      Sto(pallet_sto::StoCall),
      #[codec(index = 40u8)]
      Treasury(pallet_treasury::TreasuryCall),
      #[codec(index = 41u8)]
      Utility(pallet_utility::pallet::UtilityCall),
      #[codec(index = 42u8)]
      Base(pallet_base::BaseCall),
      #[codec(index = 43u8)]
      ExternalAgents(pallet_external_agents::ExternalAgentsCall),
      #[codec(index = 44u8)]
      Relayer(pallet_relayer::RelayerCall),
      #[codec(index = 46u8)]
      Contracts(pallet_contracts::pallet::ContractsCall),
      #[codec(index = 47u8)]
      PolymeshContracts(polymesh_contracts::PolymeshContractsCall),
      #[codec(index = 48u8)]
      Preimage(pallet_preimage::pallet::PreimageCall),
      #[codec(index = 49u8)]
      Nft(pallet_nft::NftCall),
      #[codec(index = 50u8)]
      ElectionProviderMultiPhase(
        pallet_election_provider_multi_phase::pallet::ElectionProviderMultiPhaseCall,
      ),
    }
    impl RuntimeCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::System(val) => val.as_static_str(),
          Self::Babe(val) => val.as_static_str(),
          Self::Timestamp(val) => val.as_static_str(),
          Self::Indices(val) => val.as_static_str(),
          Self::Balances(val) => val.as_static_str(),
          Self::TransactionPayment(val) => val.as_static_str(),
          Self::Identity(val) => val.as_static_str(),
          Self::CddServiceProviders(val) => val.as_static_str(),
          Self::PolymeshCommittee(val) => val.as_static_str(),
          Self::CommitteeMembership(val) => val.as_static_str(),
          Self::TechnicalCommittee(val) => val.as_static_str(),
          Self::TechnicalCommitteeMembership(val) => val.as_static_str(),
          Self::UpgradeCommittee(val) => val.as_static_str(),
          Self::UpgradeCommitteeMembership(val) => val.as_static_str(),
          Self::MultiSig(val) => val.as_static_str(),
          Self::Staking(val) => val.as_static_str(),
          Self::Session(val) => val.as_static_str(),
          Self::Grandpa(val) => val.as_static_str(),
          Self::ImOnline(val) => val.as_static_str(),
          Self::Asset(val) => val.as_static_str(),
          Self::CapitalDistribution(val) => val.as_static_str(),
          Self::Checkpoint(val) => val.as_static_str(),
          Self::ComplianceManager(val) => val.as_static_str(),
          Self::CorporateAction(val) => val.as_static_str(),
          Self::CorporateBallot(val) => val.as_static_str(),
          Self::Pips(val) => val.as_static_str(),
          Self::Portfolio(val) => val.as_static_str(),
          Self::ProtocolFee(val) => val.as_static_str(),
          Self::Scheduler(val) => val.as_static_str(),
          Self::Settlement(val) => val.as_static_str(),
          Self::Statistics(val) => val.as_static_str(),
          Self::Sto(val) => val.as_static_str(),
          Self::Treasury(val) => val.as_static_str(),
          Self::Utility(val) => val.as_static_str(),
          Self::Base(val) => val.as_static_str(),
          Self::ExternalAgents(val) => val.as_static_str(),
          Self::Relayer(val) => val.as_static_str(),
          Self::Contracts(val) => val.as_static_str(),
          Self::PolymeshContracts(val) => val.as_static_str(),
          Self::Preimage(val) => val.as_static_str(),
          Self::Nft(val) => val.as_static_str(),
          Self::ElectionProviderMultiPhase(val) => val.as_static_str(),
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for RuntimeCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::System(val) => val.as_docs(),
          Self::Babe(val) => val.as_docs(),
          Self::Timestamp(val) => val.as_docs(),
          Self::Indices(val) => val.as_docs(),
          Self::Balances(val) => val.as_docs(),
          Self::TransactionPayment(val) => val.as_docs(),
          Self::Identity(val) => val.as_docs(),
          Self::CddServiceProviders(val) => val.as_docs(),
          Self::PolymeshCommittee(val) => val.as_docs(),
          Self::CommitteeMembership(val) => val.as_docs(),
          Self::TechnicalCommittee(val) => val.as_docs(),
          Self::TechnicalCommitteeMembership(val) => val.as_docs(),
          Self::UpgradeCommittee(val) => val.as_docs(),
          Self::UpgradeCommitteeMembership(val) => val.as_docs(),
          Self::MultiSig(val) => val.as_docs(),
          Self::Staking(val) => val.as_docs(),
          Self::Session(val) => val.as_docs(),
          Self::Grandpa(val) => val.as_docs(),
          Self::ImOnline(val) => val.as_docs(),
          Self::Asset(val) => val.as_docs(),
          Self::CapitalDistribution(val) => val.as_docs(),
          Self::Checkpoint(val) => val.as_docs(),
          Self::ComplianceManager(val) => val.as_docs(),
          Self::CorporateAction(val) => val.as_docs(),
          Self::CorporateBallot(val) => val.as_docs(),
          Self::Pips(val) => val.as_docs(),
          Self::Portfolio(val) => val.as_docs(),
          Self::ProtocolFee(val) => val.as_docs(),
          Self::Scheduler(val) => val.as_docs(),
          Self::Settlement(val) => val.as_docs(),
          Self::Statistics(val) => val.as_docs(),
          Self::Sto(val) => val.as_docs(),
          Self::Treasury(val) => val.as_docs(),
          Self::Utility(val) => val.as_docs(),
          Self::Base(val) => val.as_docs(),
          Self::ExternalAgents(val) => val.as_docs(),
          Self::Relayer(val) => val.as_docs(),
          Self::Contracts(val) => val.as_docs(),
          Self::PolymeshContracts(val) => val.as_docs(),
          Self::Preimage(val) => val.as_docs(),
          Self::Nft(val) => val.as_docs(),
          Self::ElectionProviderMultiPhase(val) => val.as_docs(),
          _ => &[""],
        }
      }
    }
    impl From<RuntimeCall> for &'static str {
      fn from(v: RuntimeCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&RuntimeCall> for &'static str {
      fn from(v: &RuntimeCall) -> Self {
        v.as_static_str()
      }
    }
    pub mod events {
      use super::*;
      pub type SystemEvent = frame_system::pallet::SystemEvent;
      pub type IndicesEvent = pallet_indices::pallet::IndicesEvent;
      pub type BalancesEvent = pallet_balances::BalancesEvent<::polymesh_api_client::AccountId>;
      pub type TransactionPaymentEvent =
        pallet_transaction_payment::pallet::TransactionPaymentEvent;
      pub type IdentityEvent =
        polymesh_primitives::identity::IdentityEvent<::polymesh_api_client::AccountId, u64>;
      pub type CddServiceProvidersEvent =
        polymesh_primitives::group::UpgradeCommitteeMembershipEvent<
          ::polymesh_api_client::AccountId,
          runtime::RuntimeEvent,
          pallet_group::Instance2,
        >;
      pub type PolymeshCommitteeEvent = pallet_committee::UpgradeCommitteeEvent<
        primitive_types::H256,
        u32,
        pallet_committee::Instance1,
      >;
      pub type CommitteeMembershipEvent =
        polymesh_primitives::group::UpgradeCommitteeMembershipEvent<
          ::polymesh_api_client::AccountId,
          runtime::RuntimeEvent,
          pallet_group::Instance1,
        >;
      pub type TechnicalCommitteeEvent = pallet_committee::UpgradeCommitteeEvent<
        primitive_types::H256,
        u32,
        pallet_committee::Instance3,
      >;
      pub type TechnicalCommitteeMembershipEvent =
        polymesh_primitives::group::UpgradeCommitteeMembershipEvent<
          ::polymesh_api_client::AccountId,
          runtime::RuntimeEvent,
          pallet_group::Instance3,
        >;
      pub type UpgradeCommitteeEvent = pallet_committee::UpgradeCommitteeEvent<
        primitive_types::H256,
        u32,
        pallet_committee::Instance4,
      >;
      pub type UpgradeCommitteeMembershipEvent =
        polymesh_primitives::group::UpgradeCommitteeMembershipEvent<
          ::polymesh_api_client::AccountId,
          runtime::RuntimeEvent,
          pallet_group::Instance4,
        >;
      pub type MultiSigEvent = pallet_multisig::pallet::MultiSigEvent;
      pub type StakingEvent = pallet_staking::pallet::pallet::StakingEvent;
      pub type OffencesEvent = pallet_offences::pallet::OffencesEvent;
      pub type SessionEvent = pallet_session::pallet::SessionEvent;
      pub type GrandpaEvent = pallet_grandpa::pallet::GrandpaEvent;
      pub type ImOnlineEvent = pallet_im_online::pallet::ImOnlineEvent;
      pub type AssetEvent = polymesh_common_utilities::traits::asset::AssetEvent<u64>;
      pub type CapitalDistributionEvent =
        pallet_corporate_actions::distribution::CapitalDistributionEvent;
      pub type CheckpointEvent = polymesh_primitives::checkpoint::CheckpointEvent;
      pub type ComplianceManagerEvent =
        polymesh_common_utilities::traits::compliance_manager::ComplianceManagerEvent;
      pub type CorporateActionEvent = pallet_corporate_actions::CorporateActionEvent;
      pub type CorporateBallotEvent = pallet_corporate_actions::ballot::CorporateBallotEvent;
      pub type PipsEvent = pallet_pips::PipsEvent<::polymesh_api_client::AccountId, u32>;
      pub type PortfolioEvent = polymesh_common_utilities::traits::portfolio::PortfolioEvent;
      pub type ProtocolFeeEvent =
        pallet_protocol_fee::ProtocolFeeEvent<::polymesh_api_client::AccountId>;
      pub type SchedulerEvent = pallet_scheduler::pallet::SchedulerEvent;
      pub type SettlementEvent = polymesh_common_utilities::traits::settlement::SettlementEvent<
        u64,
        u32,
        ::polymesh_api_client::AccountId,
      >;
      pub type StatisticsEvent = polymesh_common_utilities::traits::statistics::StatisticsEvent;
      pub type StoEvent = pallet_sto::StoEvent<u64>;
      pub type TreasuryEvent =
        pallet_treasury::TreasuryEvent<u128, ::polymesh_api_client::AccountId>;
      pub type UtilityEvent = pallet_utility::pallet::UtilityEvent;
      pub type BaseEvent = polymesh_common_utilities::traits::base::BaseEvent;
      pub type ExternalAgentsEvent =
        polymesh_common_utilities::traits::external_agents::ExternalAgentsEvent;
      pub type RelayerEvent =
        polymesh_common_utilities::traits::relayer::RelayerEvent<::polymesh_api_client::AccountId>;
      pub type ContractsEvent = pallet_contracts::pallet::ContractsEvent;
      pub type PolymeshContractsEvent = polymesh_contracts::PolymeshContractsEvent<
        primitive_types::H256,
        ::polymesh_api_client::AccountId,
      >;
      pub type PreimageEvent = pallet_preimage::pallet::PreimageEvent;
      pub type NftEvent = polymesh_common_utilities::traits::nft::NftEvent;
      pub type ElectionProviderMultiPhaseEvent =
        pallet_election_provider_multi_phase::pallet::ElectionProviderMultiPhaseEvent;
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RuntimeEvent {
      #[codec(index = 0u8)]
      System(events::SystemEvent),
      #[codec(index = 3u8)]
      Indices(events::IndicesEvent),
      #[codec(index = 5u8)]
      Balances(events::BalancesEvent),
      #[codec(index = 6u8)]
      TransactionPayment(events::TransactionPaymentEvent),
      #[codec(index = 7u8)]
      Identity(events::IdentityEvent),
      #[codec(index = 8u8)]
      CddServiceProviders(events::CddServiceProvidersEvent),
      #[codec(index = 9u8)]
      PolymeshCommittee(events::PolymeshCommitteeEvent),
      #[codec(index = 10u8)]
      CommitteeMembership(events::CommitteeMembershipEvent),
      #[codec(index = 11u8)]
      TechnicalCommittee(events::TechnicalCommitteeEvent),
      #[codec(index = 12u8)]
      TechnicalCommitteeMembership(events::TechnicalCommitteeMembershipEvent),
      #[codec(index = 13u8)]
      UpgradeCommittee(events::UpgradeCommitteeEvent),
      #[codec(index = 14u8)]
      UpgradeCommitteeMembership(events::UpgradeCommitteeMembershipEvent),
      #[codec(index = 15u8)]
      MultiSig(events::MultiSigEvent),
      #[codec(index = 17u8)]
      Staking(events::StakingEvent),
      #[codec(index = 18u8)]
      Offences(events::OffencesEvent),
      #[codec(index = 19u8)]
      Session(events::SessionEvent),
      #[codec(index = 21u8)]
      Grandpa(events::GrandpaEvent),
      #[codec(index = 23u8)]
      ImOnline(events::ImOnlineEvent),
      #[codec(index = 26u8)]
      Asset(events::AssetEvent),
      #[codec(index = 27u8)]
      CapitalDistribution(events::CapitalDistributionEvent),
      #[codec(index = 28u8)]
      Checkpoint(events::CheckpointEvent),
      #[codec(index = 29u8)]
      ComplianceManager(events::ComplianceManagerEvent),
      #[codec(index = 30u8)]
      CorporateAction(events::CorporateActionEvent),
      #[codec(index = 31u8)]
      CorporateBallot(events::CorporateBallotEvent),
      #[codec(index = 33u8)]
      Pips(events::PipsEvent),
      #[codec(index = 34u8)]
      Portfolio(events::PortfolioEvent),
      #[codec(index = 35u8)]
      ProtocolFee(events::ProtocolFeeEvent),
      #[codec(index = 36u8)]
      Scheduler(events::SchedulerEvent),
      #[codec(index = 37u8)]
      Settlement(events::SettlementEvent),
      #[codec(index = 38u8)]
      Statistics(events::StatisticsEvent),
      #[codec(index = 39u8)]
      Sto(events::StoEvent),
      #[codec(index = 40u8)]
      Treasury(events::TreasuryEvent),
      #[codec(index = 41u8)]
      Utility(events::UtilityEvent),
      #[codec(index = 42u8)]
      Base(events::BaseEvent),
      #[codec(index = 43u8)]
      ExternalAgents(events::ExternalAgentsEvent),
      #[codec(index = 44u8)]
      Relayer(events::RelayerEvent),
      #[codec(index = 46u8)]
      Contracts(events::ContractsEvent),
      #[codec(index = 47u8)]
      PolymeshContracts(events::PolymeshContractsEvent),
      #[codec(index = 48u8)]
      Preimage(events::PreimageEvent),
      #[codec(index = 49u8)]
      Nft(events::NftEvent),
      #[codec(index = 50u8)]
      ElectionProviderMultiPhase(events::ElectionProviderMultiPhaseEvent),
    }
    impl RuntimeEvent {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::System(val) => val.as_static_str(),
          Self::Indices(val) => val.as_static_str(),
          Self::Balances(val) => val.as_static_str(),
          Self::TransactionPayment(val) => val.as_static_str(),
          Self::Identity(val) => val.as_static_str(),
          Self::CddServiceProviders(val) => val.as_static_str(),
          Self::PolymeshCommittee(val) => val.as_static_str(),
          Self::CommitteeMembership(val) => val.as_static_str(),
          Self::TechnicalCommittee(val) => val.as_static_str(),
          Self::TechnicalCommitteeMembership(val) => val.as_static_str(),
          Self::UpgradeCommittee(val) => val.as_static_str(),
          Self::UpgradeCommitteeMembership(val) => val.as_static_str(),
          Self::MultiSig(val) => val.as_static_str(),
          Self::Staking(val) => val.as_static_str(),
          Self::Offences(val) => val.as_static_str(),
          Self::Session(val) => val.as_static_str(),
          Self::Grandpa(val) => val.as_static_str(),
          Self::ImOnline(val) => val.as_static_str(),
          Self::Asset(val) => val.as_static_str(),
          Self::CapitalDistribution(val) => val.as_static_str(),
          Self::Checkpoint(val) => val.as_static_str(),
          Self::ComplianceManager(val) => val.as_static_str(),
          Self::CorporateAction(val) => val.as_static_str(),
          Self::CorporateBallot(val) => val.as_static_str(),
          Self::Pips(val) => val.as_static_str(),
          Self::Portfolio(val) => val.as_static_str(),
          Self::ProtocolFee(val) => val.as_static_str(),
          Self::Scheduler(val) => val.as_static_str(),
          Self::Settlement(val) => val.as_static_str(),
          Self::Statistics(val) => val.as_static_str(),
          Self::Sto(val) => val.as_static_str(),
          Self::Treasury(val) => val.as_static_str(),
          Self::Utility(val) => val.as_static_str(),
          Self::Base(val) => val.as_static_str(),
          Self::ExternalAgents(val) => val.as_static_str(),
          Self::Relayer(val) => val.as_static_str(),
          Self::Contracts(val) => val.as_static_str(),
          Self::PolymeshContracts(val) => val.as_static_str(),
          Self::Preimage(val) => val.as_static_str(),
          Self::Nft(val) => val.as_static_str(),
          Self::ElectionProviderMultiPhase(val) => val.as_static_str(),
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for RuntimeEvent {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::System(val) => val.as_docs(),
          Self::Indices(val) => val.as_docs(),
          Self::Balances(val) => val.as_docs(),
          Self::TransactionPayment(val) => val.as_docs(),
          Self::Identity(val) => val.as_docs(),
          Self::CddServiceProviders(val) => val.as_docs(),
          Self::PolymeshCommittee(val) => val.as_docs(),
          Self::CommitteeMembership(val) => val.as_docs(),
          Self::TechnicalCommittee(val) => val.as_docs(),
          Self::TechnicalCommitteeMembership(val) => val.as_docs(),
          Self::UpgradeCommittee(val) => val.as_docs(),
          Self::UpgradeCommitteeMembership(val) => val.as_docs(),
          Self::MultiSig(val) => val.as_docs(),
          Self::Staking(val) => val.as_docs(),
          Self::Offences(val) => val.as_docs(),
          Self::Session(val) => val.as_docs(),
          Self::Grandpa(val) => val.as_docs(),
          Self::ImOnline(val) => val.as_docs(),
          Self::Asset(val) => val.as_docs(),
          Self::CapitalDistribution(val) => val.as_docs(),
          Self::Checkpoint(val) => val.as_docs(),
          Self::ComplianceManager(val) => val.as_docs(),
          Self::CorporateAction(val) => val.as_docs(),
          Self::CorporateBallot(val) => val.as_docs(),
          Self::Pips(val) => val.as_docs(),
          Self::Portfolio(val) => val.as_docs(),
          Self::ProtocolFee(val) => val.as_docs(),
          Self::Scheduler(val) => val.as_docs(),
          Self::Settlement(val) => val.as_docs(),
          Self::Statistics(val) => val.as_docs(),
          Self::Sto(val) => val.as_docs(),
          Self::Treasury(val) => val.as_docs(),
          Self::Utility(val) => val.as_docs(),
          Self::Base(val) => val.as_docs(),
          Self::ExternalAgents(val) => val.as_docs(),
          Self::Relayer(val) => val.as_docs(),
          Self::Contracts(val) => val.as_docs(),
          Self::PolymeshContracts(val) => val.as_docs(),
          Self::Preimage(val) => val.as_docs(),
          Self::Nft(val) => val.as_docs(),
          Self::ElectionProviderMultiPhase(val) => val.as_docs(),
          _ => &[""],
        }
      }
    }
    impl From<RuntimeEvent> for &'static str {
      fn from(v: RuntimeEvent) -> Self {
        v.as_static_str()
      }
    }
    impl From<&RuntimeEvent> for &'static str {
      fn from(v: &RuntimeEvent) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct SessionKeys {
      pub grandpa: sp_consensus_grandpa::app::Public,
      pub babe: sp_consensus_babe::app::Public,
      pub im_online: pallet_im_online::sr25519::app_sr25519::Public,
      pub authority_discovery: sp_authority_discovery::app::Public,
    }
  }
  pub mod sp_arithmetic {
    use super::*;
    pub mod fixed_point {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct FixedU128(pub u128);
    }
    pub mod per_things {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PerU16(pub u16);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Perbill(pub u32);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Percent(pub u8);
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Permill(pub u32);
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ArithmeticError {
      #[codec(index = 0u8)]
      Underflow,
      #[codec(index = 1u8)]
      Overflow,
      #[codec(index = 2u8)]
      DivisionByZero,
    }
    impl ArithmeticError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::Underflow => "Underflow",
          Self::Overflow => "Overflow",
          Self::DivisionByZero => "DivisionByZero",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ArithmeticError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::Underflow => &[""],
          Self::Overflow => &[""],
          Self::DivisionByZero => &[""],
          _ => &[""],
        }
      }
    }
    impl From<ArithmeticError> for &'static str {
      fn from(v: ArithmeticError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ArithmeticError> for &'static str {
      fn from(v: &ArithmeticError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod sp_authority_discovery {
    use super::*;
    pub mod app {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Public(pub sp_core::sr25519::Public);
    }
  }
  pub mod sp_consensus_babe {
    use super::*;
    pub mod app {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Public(pub sp_core::sr25519::Public);
    }
    pub mod digests {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum NextConfigDescriptor {
        #[codec(index = 1u8)]
        V1 {
          c: (u64, u64),
          allowed_slots: sp_consensus_babe::AllowedSlots,
        },
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PreDigest {
        #[codec(index = 1u8)]
        Primary(sp_consensus_babe::digests::PrimaryPreDigest),
        #[codec(index = 2u8)]
        SecondaryPlain(sp_consensus_babe::digests::SecondaryPlainPreDigest),
        #[codec(index = 3u8)]
        SecondaryVRF(sp_consensus_babe::digests::SecondaryVRFPreDigest),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PrimaryPreDigest {
        pub authority_index: u32,
        pub slot: sp_consensus_slots::Slot,
        pub vrf_output: [u8; 32usize],
        #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
        pub vrf_proof: [u8; 64usize],
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SecondaryPlainPreDigest {
        pub authority_index: u32,
        pub slot: sp_consensus_slots::Slot,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SecondaryVRFPreDigest {
        pub authority_index: u32,
        pub slot: sp_consensus_slots::Slot,
        pub vrf_output: [u8; 32usize],
        #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
        pub vrf_proof: [u8; 64usize],
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum AllowedSlots {
      #[codec(index = 0u8)]
      PrimarySlots,
      #[codec(index = 1u8)]
      PrimaryAndSecondaryPlainSlots,
      #[codec(index = 2u8)]
      PrimaryAndSecondaryVRFSlots,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct BabeEpochConfiguration {
      pub c: (u64, u64),
      pub allowed_slots: sp_consensus_babe::AllowedSlots,
    }
  }
  pub mod sp_consensus_grandpa {
    use super::*;
    pub mod app {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Public(pub sp_core::ed25519::Public);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Signature(pub sp_core::ed25519::Signature);
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Equivocation<H, N> {
      #[codec(index = 0u8)]
      Prevote(
        finality_grandpa::Equivocation<
          sp_consensus_grandpa::app::Public,
          finality_grandpa::Prevote<H, N>,
          sp_consensus_grandpa::app::Signature,
        >,
      ),
      #[codec(index = 1u8)]
      Precommit(
        finality_grandpa::Equivocation<
          sp_consensus_grandpa::app::Public,
          finality_grandpa::Precommit<H, N>,
          sp_consensus_grandpa::app::Signature,
        >,
      ),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct EquivocationProof<H, N> {
      pub set_id: u64,
      pub equivocation: sp_consensus_grandpa::Equivocation<H, N>,
    }
  }
  pub mod sp_consensus_slots {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct EquivocationProof<Header, Id> {
      pub offender: Id,
      pub slot: sp_consensus_slots::Slot,
      pub first_header: Header,
      pub second_header: Header,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Slot(pub u64);
  }
  pub mod sp_core {
    use super::*;
    pub mod crypto {
      use super::*;
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AccountId32(pub [u8; 32usize]);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct KeyTypeId(pub [u8; 4usize]);
    }
    pub mod ecdsa {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Signature(
        #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
        pub  [u8; 65usize],
      );
    }
    pub mod ed25519 {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Public(pub [u8; 32usize]);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Signature(
        #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
        pub  [u8; 64usize],
      );
    }
    pub mod offchain {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct OpaqueMultiaddr(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct OpaqueNetworkState {
        pub peer_id: sp_core::OpaquePeerId,
        pub external_addresses: ::alloc::vec::Vec<sp_core::offchain::OpaqueMultiaddr>,
      }
    }
    pub mod sr25519 {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Public(pub [u8; 32usize]);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Signature(
        #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
        pub  [u8; 64usize],
      );
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct OpaquePeerId(pub ::alloc::vec::Vec<u8>);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Void {}
  }
  pub mod sp_npos_elections {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ElectionScore {
      pub minimal_stake: u128,
      pub sum_stake: u128,
      pub sum_stake_squared: u128,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Support<AccountId> {
      pub total: u128,
      pub voters: ::alloc::vec::Vec<(AccountId, u128)>,
    }
  }
  pub mod sp_runtime {
    use super::*;
    pub mod generic {
      use super::*;
      pub mod digest {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Digest {
          pub logs: ::alloc::vec::Vec<sp_runtime::generic::digest::DigestItem>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum DigestItem {
          #[codec(index = 6u8)]
          PreRuntime([u8; 4usize], ::alloc::vec::Vec<u8>),
          #[codec(index = 4u8)]
          Consensus([u8; 4usize], ::alloc::vec::Vec<u8>),
          #[codec(index = 5u8)]
          Seal([u8; 4usize], ::alloc::vec::Vec<u8>),
          #[codec(index = 0u8)]
          Other(::alloc::vec::Vec<u8>),
          #[codec(index = 8u8)]
          RuntimeEnvironmentUpdated,
        }
      }
      pub mod era {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Era {
          #[codec(index = 0u8)]
          Immortal,
          #[codec(index = 1u8)]
          Mortal1(u8),
          #[codec(index = 2u8)]
          Mortal2(u8),
          #[codec(index = 3u8)]
          Mortal3(u8),
          #[codec(index = 4u8)]
          Mortal4(u8),
          #[codec(index = 5u8)]
          Mortal5(u8),
          #[codec(index = 6u8)]
          Mortal6(u8),
          #[codec(index = 7u8)]
          Mortal7(u8),
          #[codec(index = 8u8)]
          Mortal8(u8),
          #[codec(index = 9u8)]
          Mortal9(u8),
          #[codec(index = 10u8)]
          Mortal10(u8),
          #[codec(index = 11u8)]
          Mortal11(u8),
          #[codec(index = 12u8)]
          Mortal12(u8),
          #[codec(index = 13u8)]
          Mortal13(u8),
          #[codec(index = 14u8)]
          Mortal14(u8),
          #[codec(index = 15u8)]
          Mortal15(u8),
          #[codec(index = 16u8)]
          Mortal16(u8),
          #[codec(index = 17u8)]
          Mortal17(u8),
          #[codec(index = 18u8)]
          Mortal18(u8),
          #[codec(index = 19u8)]
          Mortal19(u8),
          #[codec(index = 20u8)]
          Mortal20(u8),
          #[codec(index = 21u8)]
          Mortal21(u8),
          #[codec(index = 22u8)]
          Mortal22(u8),
          #[codec(index = 23u8)]
          Mortal23(u8),
          #[codec(index = 24u8)]
          Mortal24(u8),
          #[codec(index = 25u8)]
          Mortal25(u8),
          #[codec(index = 26u8)]
          Mortal26(u8),
          #[codec(index = 27u8)]
          Mortal27(u8),
          #[codec(index = 28u8)]
          Mortal28(u8),
          #[codec(index = 29u8)]
          Mortal29(u8),
          #[codec(index = 30u8)]
          Mortal30(u8),
          #[codec(index = 31u8)]
          Mortal31(u8),
          #[codec(index = 32u8)]
          Mortal32(u8),
          #[codec(index = 33u8)]
          Mortal33(u8),
          #[codec(index = 34u8)]
          Mortal34(u8),
          #[codec(index = 35u8)]
          Mortal35(u8),
          #[codec(index = 36u8)]
          Mortal36(u8),
          #[codec(index = 37u8)]
          Mortal37(u8),
          #[codec(index = 38u8)]
          Mortal38(u8),
          #[codec(index = 39u8)]
          Mortal39(u8),
          #[codec(index = 40u8)]
          Mortal40(u8),
          #[codec(index = 41u8)]
          Mortal41(u8),
          #[codec(index = 42u8)]
          Mortal42(u8),
          #[codec(index = 43u8)]
          Mortal43(u8),
          #[codec(index = 44u8)]
          Mortal44(u8),
          #[codec(index = 45u8)]
          Mortal45(u8),
          #[codec(index = 46u8)]
          Mortal46(u8),
          #[codec(index = 47u8)]
          Mortal47(u8),
          #[codec(index = 48u8)]
          Mortal48(u8),
          #[codec(index = 49u8)]
          Mortal49(u8),
          #[codec(index = 50u8)]
          Mortal50(u8),
          #[codec(index = 51u8)]
          Mortal51(u8),
          #[codec(index = 52u8)]
          Mortal52(u8),
          #[codec(index = 53u8)]
          Mortal53(u8),
          #[codec(index = 54u8)]
          Mortal54(u8),
          #[codec(index = 55u8)]
          Mortal55(u8),
          #[codec(index = 56u8)]
          Mortal56(u8),
          #[codec(index = 57u8)]
          Mortal57(u8),
          #[codec(index = 58u8)]
          Mortal58(u8),
          #[codec(index = 59u8)]
          Mortal59(u8),
          #[codec(index = 60u8)]
          Mortal60(u8),
          #[codec(index = 61u8)]
          Mortal61(u8),
          #[codec(index = 62u8)]
          Mortal62(u8),
          #[codec(index = 63u8)]
          Mortal63(u8),
          #[codec(index = 64u8)]
          Mortal64(u8),
          #[codec(index = 65u8)]
          Mortal65(u8),
          #[codec(index = 66u8)]
          Mortal66(u8),
          #[codec(index = 67u8)]
          Mortal67(u8),
          #[codec(index = 68u8)]
          Mortal68(u8),
          #[codec(index = 69u8)]
          Mortal69(u8),
          #[codec(index = 70u8)]
          Mortal70(u8),
          #[codec(index = 71u8)]
          Mortal71(u8),
          #[codec(index = 72u8)]
          Mortal72(u8),
          #[codec(index = 73u8)]
          Mortal73(u8),
          #[codec(index = 74u8)]
          Mortal74(u8),
          #[codec(index = 75u8)]
          Mortal75(u8),
          #[codec(index = 76u8)]
          Mortal76(u8),
          #[codec(index = 77u8)]
          Mortal77(u8),
          #[codec(index = 78u8)]
          Mortal78(u8),
          #[codec(index = 79u8)]
          Mortal79(u8),
          #[codec(index = 80u8)]
          Mortal80(u8),
          #[codec(index = 81u8)]
          Mortal81(u8),
          #[codec(index = 82u8)]
          Mortal82(u8),
          #[codec(index = 83u8)]
          Mortal83(u8),
          #[codec(index = 84u8)]
          Mortal84(u8),
          #[codec(index = 85u8)]
          Mortal85(u8),
          #[codec(index = 86u8)]
          Mortal86(u8),
          #[codec(index = 87u8)]
          Mortal87(u8),
          #[codec(index = 88u8)]
          Mortal88(u8),
          #[codec(index = 89u8)]
          Mortal89(u8),
          #[codec(index = 90u8)]
          Mortal90(u8),
          #[codec(index = 91u8)]
          Mortal91(u8),
          #[codec(index = 92u8)]
          Mortal92(u8),
          #[codec(index = 93u8)]
          Mortal93(u8),
          #[codec(index = 94u8)]
          Mortal94(u8),
          #[codec(index = 95u8)]
          Mortal95(u8),
          #[codec(index = 96u8)]
          Mortal96(u8),
          #[codec(index = 97u8)]
          Mortal97(u8),
          #[codec(index = 98u8)]
          Mortal98(u8),
          #[codec(index = 99u8)]
          Mortal99(u8),
          #[codec(index = 100u8)]
          Mortal100(u8),
          #[codec(index = 101u8)]
          Mortal101(u8),
          #[codec(index = 102u8)]
          Mortal102(u8),
          #[codec(index = 103u8)]
          Mortal103(u8),
          #[codec(index = 104u8)]
          Mortal104(u8),
          #[codec(index = 105u8)]
          Mortal105(u8),
          #[codec(index = 106u8)]
          Mortal106(u8),
          #[codec(index = 107u8)]
          Mortal107(u8),
          #[codec(index = 108u8)]
          Mortal108(u8),
          #[codec(index = 109u8)]
          Mortal109(u8),
          #[codec(index = 110u8)]
          Mortal110(u8),
          #[codec(index = 111u8)]
          Mortal111(u8),
          #[codec(index = 112u8)]
          Mortal112(u8),
          #[codec(index = 113u8)]
          Mortal113(u8),
          #[codec(index = 114u8)]
          Mortal114(u8),
          #[codec(index = 115u8)]
          Mortal115(u8),
          #[codec(index = 116u8)]
          Mortal116(u8),
          #[codec(index = 117u8)]
          Mortal117(u8),
          #[codec(index = 118u8)]
          Mortal118(u8),
          #[codec(index = 119u8)]
          Mortal119(u8),
          #[codec(index = 120u8)]
          Mortal120(u8),
          #[codec(index = 121u8)]
          Mortal121(u8),
          #[codec(index = 122u8)]
          Mortal122(u8),
          #[codec(index = 123u8)]
          Mortal123(u8),
          #[codec(index = 124u8)]
          Mortal124(u8),
          #[codec(index = 125u8)]
          Mortal125(u8),
          #[codec(index = 126u8)]
          Mortal126(u8),
          #[codec(index = 127u8)]
          Mortal127(u8),
          #[codec(index = 128u8)]
          Mortal128(u8),
          #[codec(index = 129u8)]
          Mortal129(u8),
          #[codec(index = 130u8)]
          Mortal130(u8),
          #[codec(index = 131u8)]
          Mortal131(u8),
          #[codec(index = 132u8)]
          Mortal132(u8),
          #[codec(index = 133u8)]
          Mortal133(u8),
          #[codec(index = 134u8)]
          Mortal134(u8),
          #[codec(index = 135u8)]
          Mortal135(u8),
          #[codec(index = 136u8)]
          Mortal136(u8),
          #[codec(index = 137u8)]
          Mortal137(u8),
          #[codec(index = 138u8)]
          Mortal138(u8),
          #[codec(index = 139u8)]
          Mortal139(u8),
          #[codec(index = 140u8)]
          Mortal140(u8),
          #[codec(index = 141u8)]
          Mortal141(u8),
          #[codec(index = 142u8)]
          Mortal142(u8),
          #[codec(index = 143u8)]
          Mortal143(u8),
          #[codec(index = 144u8)]
          Mortal144(u8),
          #[codec(index = 145u8)]
          Mortal145(u8),
          #[codec(index = 146u8)]
          Mortal146(u8),
          #[codec(index = 147u8)]
          Mortal147(u8),
          #[codec(index = 148u8)]
          Mortal148(u8),
          #[codec(index = 149u8)]
          Mortal149(u8),
          #[codec(index = 150u8)]
          Mortal150(u8),
          #[codec(index = 151u8)]
          Mortal151(u8),
          #[codec(index = 152u8)]
          Mortal152(u8),
          #[codec(index = 153u8)]
          Mortal153(u8),
          #[codec(index = 154u8)]
          Mortal154(u8),
          #[codec(index = 155u8)]
          Mortal155(u8),
          #[codec(index = 156u8)]
          Mortal156(u8),
          #[codec(index = 157u8)]
          Mortal157(u8),
          #[codec(index = 158u8)]
          Mortal158(u8),
          #[codec(index = 159u8)]
          Mortal159(u8),
          #[codec(index = 160u8)]
          Mortal160(u8),
          #[codec(index = 161u8)]
          Mortal161(u8),
          #[codec(index = 162u8)]
          Mortal162(u8),
          #[codec(index = 163u8)]
          Mortal163(u8),
          #[codec(index = 164u8)]
          Mortal164(u8),
          #[codec(index = 165u8)]
          Mortal165(u8),
          #[codec(index = 166u8)]
          Mortal166(u8),
          #[codec(index = 167u8)]
          Mortal167(u8),
          #[codec(index = 168u8)]
          Mortal168(u8),
          #[codec(index = 169u8)]
          Mortal169(u8),
          #[codec(index = 170u8)]
          Mortal170(u8),
          #[codec(index = 171u8)]
          Mortal171(u8),
          #[codec(index = 172u8)]
          Mortal172(u8),
          #[codec(index = 173u8)]
          Mortal173(u8),
          #[codec(index = 174u8)]
          Mortal174(u8),
          #[codec(index = 175u8)]
          Mortal175(u8),
          #[codec(index = 176u8)]
          Mortal176(u8),
          #[codec(index = 177u8)]
          Mortal177(u8),
          #[codec(index = 178u8)]
          Mortal178(u8),
          #[codec(index = 179u8)]
          Mortal179(u8),
          #[codec(index = 180u8)]
          Mortal180(u8),
          #[codec(index = 181u8)]
          Mortal181(u8),
          #[codec(index = 182u8)]
          Mortal182(u8),
          #[codec(index = 183u8)]
          Mortal183(u8),
          #[codec(index = 184u8)]
          Mortal184(u8),
          #[codec(index = 185u8)]
          Mortal185(u8),
          #[codec(index = 186u8)]
          Mortal186(u8),
          #[codec(index = 187u8)]
          Mortal187(u8),
          #[codec(index = 188u8)]
          Mortal188(u8),
          #[codec(index = 189u8)]
          Mortal189(u8),
          #[codec(index = 190u8)]
          Mortal190(u8),
          #[codec(index = 191u8)]
          Mortal191(u8),
          #[codec(index = 192u8)]
          Mortal192(u8),
          #[codec(index = 193u8)]
          Mortal193(u8),
          #[codec(index = 194u8)]
          Mortal194(u8),
          #[codec(index = 195u8)]
          Mortal195(u8),
          #[codec(index = 196u8)]
          Mortal196(u8),
          #[codec(index = 197u8)]
          Mortal197(u8),
          #[codec(index = 198u8)]
          Mortal198(u8),
          #[codec(index = 199u8)]
          Mortal199(u8),
          #[codec(index = 200u8)]
          Mortal200(u8),
          #[codec(index = 201u8)]
          Mortal201(u8),
          #[codec(index = 202u8)]
          Mortal202(u8),
          #[codec(index = 203u8)]
          Mortal203(u8),
          #[codec(index = 204u8)]
          Mortal204(u8),
          #[codec(index = 205u8)]
          Mortal205(u8),
          #[codec(index = 206u8)]
          Mortal206(u8),
          #[codec(index = 207u8)]
          Mortal207(u8),
          #[codec(index = 208u8)]
          Mortal208(u8),
          #[codec(index = 209u8)]
          Mortal209(u8),
          #[codec(index = 210u8)]
          Mortal210(u8),
          #[codec(index = 211u8)]
          Mortal211(u8),
          #[codec(index = 212u8)]
          Mortal212(u8),
          #[codec(index = 213u8)]
          Mortal213(u8),
          #[codec(index = 214u8)]
          Mortal214(u8),
          #[codec(index = 215u8)]
          Mortal215(u8),
          #[codec(index = 216u8)]
          Mortal216(u8),
          #[codec(index = 217u8)]
          Mortal217(u8),
          #[codec(index = 218u8)]
          Mortal218(u8),
          #[codec(index = 219u8)]
          Mortal219(u8),
          #[codec(index = 220u8)]
          Mortal220(u8),
          #[codec(index = 221u8)]
          Mortal221(u8),
          #[codec(index = 222u8)]
          Mortal222(u8),
          #[codec(index = 223u8)]
          Mortal223(u8),
          #[codec(index = 224u8)]
          Mortal224(u8),
          #[codec(index = 225u8)]
          Mortal225(u8),
          #[codec(index = 226u8)]
          Mortal226(u8),
          #[codec(index = 227u8)]
          Mortal227(u8),
          #[codec(index = 228u8)]
          Mortal228(u8),
          #[codec(index = 229u8)]
          Mortal229(u8),
          #[codec(index = 230u8)]
          Mortal230(u8),
          #[codec(index = 231u8)]
          Mortal231(u8),
          #[codec(index = 232u8)]
          Mortal232(u8),
          #[codec(index = 233u8)]
          Mortal233(u8),
          #[codec(index = 234u8)]
          Mortal234(u8),
          #[codec(index = 235u8)]
          Mortal235(u8),
          #[codec(index = 236u8)]
          Mortal236(u8),
          #[codec(index = 237u8)]
          Mortal237(u8),
          #[codec(index = 238u8)]
          Mortal238(u8),
          #[codec(index = 239u8)]
          Mortal239(u8),
          #[codec(index = 240u8)]
          Mortal240(u8),
          #[codec(index = 241u8)]
          Mortal241(u8),
          #[codec(index = 242u8)]
          Mortal242(u8),
          #[codec(index = 243u8)]
          Mortal243(u8),
          #[codec(index = 244u8)]
          Mortal244(u8),
          #[codec(index = 245u8)]
          Mortal245(u8),
          #[codec(index = 246u8)]
          Mortal246(u8),
          #[codec(index = 247u8)]
          Mortal247(u8),
          #[codec(index = 248u8)]
          Mortal248(u8),
          #[codec(index = 249u8)]
          Mortal249(u8),
          #[codec(index = 250u8)]
          Mortal250(u8),
          #[codec(index = 251u8)]
          Mortal251(u8),
          #[codec(index = 252u8)]
          Mortal252(u8),
          #[codec(index = 253u8)]
          Mortal253(u8),
          #[codec(index = 254u8)]
          Mortal254(u8),
          #[codec(index = 255u8)]
          Mortal255(u8),
        }
      }
      pub mod header {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Header<Number, Hash> {
          pub parent_hash: primitive_types::H256,
          #[codec(compact)]
          pub number: Number,
          pub state_root: primitive_types::H256,
          pub extrinsics_root: primitive_types::H256,
          pub digest: sp_runtime::generic::digest::Digest,
          _phantom_data: core::marker::PhantomData<Hash>,
        }
      }
      pub mod unchecked_extrinsic {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct UncheckedExtrinsic<Address, Call, Signature, Extra>(
          pub ::alloc::vec::Vec<u8>,
          core::marker::PhantomData<(Address, Call, Signature, Extra)>,
        );
      }
    }
    pub mod multiaddress {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum MultiAddress<AccountId, AccountIndex> {
        #[codec(index = 0u8)]
        Id(AccountId),
        #[codec(index = 1u8)]
        Index(#[codec(compact)] AccountIndex),
        #[codec(index = 2u8)]
        Raw(::alloc::vec::Vec<u8>),
        #[codec(index = 3u8)]
        Address32([u8; 32usize]),
        #[codec(index = 4u8)]
        Address20([u8; 20usize]),
      }
    }
    pub mod traits {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BlakeTwo256();
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum DispatchError {
      Other,
      CannotLookup,
      BadOrigin,
      Module(ModuleError),
      ConsumerRemaining,
      NoProviders,
      TooManyConsumers,
      Token(sp_runtime::TokenError),
      Arithmetic(sp_arithmetic::ArithmeticError),
      Transactional(sp_runtime::TransactionalError),
      Exhausted,
      Corruption,
      Unavailable,
      RootNotAllowed,
    }
    impl DispatchError {
      pub fn as_static_str(&self) -> &'static str {
        match self {
          Self::Other => "Other",
          Self::CannotLookup => "CannotLookup",
          Self::BadOrigin => "BadOrigin",
          Self::Module(err) => err.as_static_str(),
          Self::ConsumerRemaining => "ConsumerRemaining",
          Self::NoProviders => "NoProviders",
          Self::TooManyConsumers => "TooManyConsumers",
          Self::Token(err) => err.as_static_str(),
          Self::Arithmetic(err) => err.as_static_str(),
          Self::Transactional(err) => err.as_static_str(),
          Self::Exhausted => "Exhausted",
          Self::Corruption => "Corruption",
          Self::Unavailable => "Unavailable",
          Self::RootNotAllowed => "RootNotAllowed",
        }
      }
    }
    impl From<DispatchError> for &'static str {
      fn from(v: DispatchError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&DispatchError> for &'static str {
      fn from(v: &DispatchError) -> Self {
        v.as_static_str()
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for DispatchError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        match self { Self :: Other => & ["Some error occurred."] , Self :: CannotLookup => & ["Failed to lookup some data."] , Self :: BadOrigin => & ["A bad origin."] , Self :: Module (err) => err . as_docs () , Self :: ConsumerRemaining => & ["At least one consumer is remaining so the account cannot be destroyed."] , Self :: NoProviders => & ["There are no providers so the account cannot be created."] , Self :: TooManyConsumers => & ["There are too many consumers so the account cannot be created."] , Self :: Token (err) => err . as_docs () , Self :: Arithmetic (err) => err . as_docs () , Self :: Transactional (err) => err . as_docs () , Self :: Exhausted => & ["Resources exhausted, e.g. attempt to read/write data which is too large to manipulate."] , Self :: Corruption => & ["The state is corrupt; this is generally not going to fix itself."] , Self :: Unavailable => & ["Some resource (e.g. a preimage) is unavailable right now. This might fix itself later."] , Self :: RootNotAllowed => & ["Root origin is not allowed."] , }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RuntimeError {
      #[codec(index = 0u8)]
      System(frame_system::pallet::SystemError),
      #[codec(index = 1u8)]
      Babe(pallet_babe::pallet::BabeError),
      #[codec(index = 3u8)]
      Indices(pallet_indices::pallet::IndicesError),
      #[codec(index = 5u8)]
      Balances(pallet_balances::BalancesError),
      #[codec(index = 7u8)]
      Identity(pallet_identity::IdentityError),
      #[codec(index = 8u8)]
      CddServiceProviders(pallet_group::UpgradeCommitteeMembershipError),
      #[codec(index = 9u8)]
      PolymeshCommittee(pallet_committee::UpgradeCommitteeError),
      #[codec(index = 10u8)]
      CommitteeMembership(pallet_group::UpgradeCommitteeMembershipError),
      #[codec(index = 11u8)]
      TechnicalCommittee(pallet_committee::UpgradeCommitteeError),
      #[codec(index = 12u8)]
      TechnicalCommitteeMembership(pallet_group::UpgradeCommitteeMembershipError),
      #[codec(index = 13u8)]
      UpgradeCommittee(pallet_committee::UpgradeCommitteeError),
      #[codec(index = 14u8)]
      UpgradeCommitteeMembership(pallet_group::UpgradeCommitteeMembershipError),
      #[codec(index = 15u8)]
      MultiSig(pallet_multisig::pallet::MultiSigError),
      #[codec(index = 17u8)]
      Staking(pallet_staking::pallet::pallet::StakingError),
      #[codec(index = 19u8)]
      Session(pallet_session::pallet::SessionError),
      #[codec(index = 21u8)]
      Grandpa(pallet_grandpa::pallet::GrandpaError),
      #[codec(index = 23u8)]
      ImOnline(pallet_im_online::pallet::ImOnlineError),
      #[codec(index = 26u8)]
      Asset(pallet_asset::error::AssetError),
      #[codec(index = 27u8)]
      CapitalDistribution(pallet_corporate_actions::distribution::CapitalDistributionError),
      #[codec(index = 28u8)]
      Checkpoint(pallet_asset::checkpoint::CheckpointError),
      #[codec(index = 29u8)]
      ComplianceManager(pallet_compliance_manager::ComplianceManagerError),
      #[codec(index = 30u8)]
      CorporateAction(pallet_corporate_actions::CorporateActionError),
      #[codec(index = 31u8)]
      CorporateBallot(pallet_corporate_actions::ballot::CorporateBallotError),
      #[codec(index = 32u8)]
      Permissions(pallet_permissions::PermissionsError),
      #[codec(index = 33u8)]
      Pips(pallet_pips::PipsError),
      #[codec(index = 34u8)]
      Portfolio(pallet_portfolio::PortfolioError),
      #[codec(index = 35u8)]
      ProtocolFee(pallet_protocol_fee::ProtocolFeeError),
      #[codec(index = 36u8)]
      Scheduler(pallet_scheduler::pallet::SchedulerError),
      #[codec(index = 37u8)]
      Settlement(pallet_settlement::SettlementError),
      #[codec(index = 38u8)]
      Statistics(pallet_statistics::StatisticsError),
      #[codec(index = 39u8)]
      Sto(pallet_sto::StoError),
      #[codec(index = 40u8)]
      Treasury(pallet_treasury::TreasuryError),
      #[codec(index = 41u8)]
      Utility(pallet_utility::pallet::UtilityError),
      #[codec(index = 42u8)]
      Base(pallet_base::BaseError),
      #[codec(index = 43u8)]
      ExternalAgents(pallet_external_agents::ExternalAgentsError),
      #[codec(index = 44u8)]
      Relayer(pallet_relayer::RelayerError),
      #[codec(index = 46u8)]
      Contracts(pallet_contracts::pallet::ContractsError),
      #[codec(index = 47u8)]
      PolymeshContracts(polymesh_contracts::PolymeshContractsError),
      #[codec(index = 48u8)]
      Preimage(pallet_preimage::pallet::PreimageError),
      #[codec(index = 49u8)]
      Nft(pallet_nft::NftError),
      #[codec(index = 50u8)]
      ElectionProviderMultiPhase(
        pallet_election_provider_multi_phase::pallet::ElectionProviderMultiPhaseError,
      ),
    }
    impl RuntimeError {
      pub fn as_static_str(&self) -> &'static str {
        match self {
          RuntimeError::System(err) => err.as_static_str(),
          RuntimeError::Babe(err) => err.as_static_str(),
          RuntimeError::Indices(err) => err.as_static_str(),
          RuntimeError::Balances(err) => err.as_static_str(),
          RuntimeError::Identity(err) => err.as_static_str(),
          RuntimeError::CddServiceProviders(err) => err.as_static_str(),
          RuntimeError::PolymeshCommittee(err) => err.as_static_str(),
          RuntimeError::CommitteeMembership(err) => err.as_static_str(),
          RuntimeError::TechnicalCommittee(err) => err.as_static_str(),
          RuntimeError::TechnicalCommitteeMembership(err) => err.as_static_str(),
          RuntimeError::UpgradeCommittee(err) => err.as_static_str(),
          RuntimeError::UpgradeCommitteeMembership(err) => err.as_static_str(),
          RuntimeError::MultiSig(err) => err.as_static_str(),
          RuntimeError::Staking(err) => err.as_static_str(),
          RuntimeError::Session(err) => err.as_static_str(),
          RuntimeError::Grandpa(err) => err.as_static_str(),
          RuntimeError::ImOnline(err) => err.as_static_str(),
          RuntimeError::Asset(err) => err.as_static_str(),
          RuntimeError::CapitalDistribution(err) => err.as_static_str(),
          RuntimeError::Checkpoint(err) => err.as_static_str(),
          RuntimeError::ComplianceManager(err) => err.as_static_str(),
          RuntimeError::CorporateAction(err) => err.as_static_str(),
          RuntimeError::CorporateBallot(err) => err.as_static_str(),
          RuntimeError::Permissions(err) => err.as_static_str(),
          RuntimeError::Pips(err) => err.as_static_str(),
          RuntimeError::Portfolio(err) => err.as_static_str(),
          RuntimeError::ProtocolFee(err) => err.as_static_str(),
          RuntimeError::Scheduler(err) => err.as_static_str(),
          RuntimeError::Settlement(err) => err.as_static_str(),
          RuntimeError::Statistics(err) => err.as_static_str(),
          RuntimeError::Sto(err) => err.as_static_str(),
          RuntimeError::Treasury(err) => err.as_static_str(),
          RuntimeError::Utility(err) => err.as_static_str(),
          RuntimeError::Base(err) => err.as_static_str(),
          RuntimeError::ExternalAgents(err) => err.as_static_str(),
          RuntimeError::Relayer(err) => err.as_static_str(),
          RuntimeError::Contracts(err) => err.as_static_str(),
          RuntimeError::PolymeshContracts(err) => err.as_static_str(),
          RuntimeError::Preimage(err) => err.as_static_str(),
          RuntimeError::Nft(err) => err.as_static_str(),
          RuntimeError::ElectionProviderMultiPhase(err) => err.as_static_str(),
        }
      }
    }
    impl From<RuntimeError> for &'static str {
      fn from(v: RuntimeError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&RuntimeError> for &'static str {
      fn from(v: &RuntimeError) -> Self {
        v.as_static_str()
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for RuntimeError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        match self {
          RuntimeError::System(err) => err.as_docs(),
          RuntimeError::Babe(err) => err.as_docs(),
          RuntimeError::Indices(err) => err.as_docs(),
          RuntimeError::Balances(err) => err.as_docs(),
          RuntimeError::Identity(err) => err.as_docs(),
          RuntimeError::CddServiceProviders(err) => err.as_docs(),
          RuntimeError::PolymeshCommittee(err) => err.as_docs(),
          RuntimeError::CommitteeMembership(err) => err.as_docs(),
          RuntimeError::TechnicalCommittee(err) => err.as_docs(),
          RuntimeError::TechnicalCommitteeMembership(err) => err.as_docs(),
          RuntimeError::UpgradeCommittee(err) => err.as_docs(),
          RuntimeError::UpgradeCommitteeMembership(err) => err.as_docs(),
          RuntimeError::MultiSig(err) => err.as_docs(),
          RuntimeError::Staking(err) => err.as_docs(),
          RuntimeError::Session(err) => err.as_docs(),
          RuntimeError::Grandpa(err) => err.as_docs(),
          RuntimeError::ImOnline(err) => err.as_docs(),
          RuntimeError::Asset(err) => err.as_docs(),
          RuntimeError::CapitalDistribution(err) => err.as_docs(),
          RuntimeError::Checkpoint(err) => err.as_docs(),
          RuntimeError::ComplianceManager(err) => err.as_docs(),
          RuntimeError::CorporateAction(err) => err.as_docs(),
          RuntimeError::CorporateBallot(err) => err.as_docs(),
          RuntimeError::Permissions(err) => err.as_docs(),
          RuntimeError::Pips(err) => err.as_docs(),
          RuntimeError::Portfolio(err) => err.as_docs(),
          RuntimeError::ProtocolFee(err) => err.as_docs(),
          RuntimeError::Scheduler(err) => err.as_docs(),
          RuntimeError::Settlement(err) => err.as_docs(),
          RuntimeError::Statistics(err) => err.as_docs(),
          RuntimeError::Sto(err) => err.as_docs(),
          RuntimeError::Treasury(err) => err.as_docs(),
          RuntimeError::Utility(err) => err.as_docs(),
          RuntimeError::Base(err) => err.as_docs(),
          RuntimeError::ExternalAgents(err) => err.as_docs(),
          RuntimeError::Relayer(err) => err.as_docs(),
          RuntimeError::Contracts(err) => err.as_docs(),
          RuntimeError::PolymeshContracts(err) => err.as_docs(),
          RuntimeError::Preimage(err) => err.as_docs(),
          RuntimeError::Nft(err) => err.as_docs(),
          RuntimeError::ElectionProviderMultiPhase(err) => err.as_docs(),
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ModuleError(pub RuntimeError);
    impl ::codec::Encode for ModuleError {
      fn encode_to<T: ::codec::Output + ?Sized>(&self, output: &mut T) {
        let mut raw = self.0.encode();
        raw.resize(5usize, 0);
        output.write(raw.as_slice());
      }
    }
    impl ::codec::Decode for ModuleError {
      fn decode<I: ::codec::Input>(input: &mut I) -> Result<Self, ::codec::Error> {
        let raw: [u8; 5usize] = ::codec::Decode::decode(input)?;
        Ok(Self(RuntimeError::decode(&mut &raw[..])?))
      }
    }
    impl ModuleError {
      pub fn as_static_str(&self) -> &'static str {
        self.0.as_static_str()
      }
    }
    impl From<ModuleError> for &'static str {
      fn from(v: ModuleError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ModuleError> for &'static str {
      fn from(v: &ModuleError) -> Self {
        v.as_static_str()
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ModuleError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        self.0.as_docs()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum MultiSignature {
      #[codec(index = 0u8)]
      Ed25519(sp_core::ed25519::Signature),
      #[codec(index = 1u8)]
      Sr25519(sp_core::sr25519::Signature),
      #[codec(index = 2u8)]
      Ecdsa(sp_core::ecdsa::Signature),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TokenError {
      #[codec(index = 0u8)]
      NoFunds,
      #[codec(index = 1u8)]
      WouldDie,
      #[codec(index = 2u8)]
      BelowMinimum,
      #[codec(index = 3u8)]
      CannotCreate,
      #[codec(index = 4u8)]
      UnknownAsset,
      #[codec(index = 5u8)]
      Frozen,
      #[codec(index = 6u8)]
      Unsupported,
    }
    impl TokenError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::NoFunds => "NoFunds",
          Self::WouldDie => "WouldDie",
          Self::BelowMinimum => "BelowMinimum",
          Self::CannotCreate => "CannotCreate",
          Self::UnknownAsset => "UnknownAsset",
          Self::Frozen => "Frozen",
          Self::Unsupported => "Unsupported",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for TokenError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::NoFunds => &[""],
          Self::WouldDie => &[""],
          Self::BelowMinimum => &[""],
          Self::CannotCreate => &[""],
          Self::UnknownAsset => &[""],
          Self::Frozen => &[""],
          Self::Unsupported => &[""],
          _ => &[""],
        }
      }
    }
    impl From<TokenError> for &'static str {
      fn from(v: TokenError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&TokenError> for &'static str {
      fn from(v: &TokenError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TransactionalError {
      #[codec(index = 0u8)]
      LimitReached,
      #[codec(index = 1u8)]
      NoLayer,
    }
    impl TransactionalError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::LimitReached => "LimitReached",
          Self::NoLayer => "NoLayer",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for TransactionalError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::LimitReached => &[""],
          Self::NoLayer => &[""],
          _ => &[""],
        }
      }
    }
    impl From<TransactionalError> for &'static str {
      fn from(v: TransactionalError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&TransactionalError> for &'static str {
      fn from(v: &TransactionalError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod sp_session {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct MembershipProof {
      pub session: u32,
      pub trie_nodes: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
      pub validator_count: u32,
    }
  }
  pub mod sp_staking {
    use super::*;
    pub mod offence {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct OffenceDetails<Reporter, Offender> {
        pub offender: Offender,
        pub reporters: ::alloc::vec::Vec<Reporter>,
      }
    }
  }
}
#[allow(dead_code, unused_imports, non_camel_case_types)]
pub mod api {
  use super::types;
  use super::types::*;
  use super::WrappedCall;
  pub mod system {
    use super::*;
    #[derive(Clone)]
    pub struct SystemCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> SystemCallApi<'api> {
      #[doc = "Make some on-chain remark."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`"]
      #[cfg(not(feature = "ink"))]
      pub fn remark(
        &self,
        remark: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::remark { remark },
        ))
      }
      #[doc = "Make some on-chain remark."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`"]
      #[cfg(feature = "ink")]
      pub fn remark(&self, remark: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 0u8];
        remark.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the number of pages in the WebAssembly environment's heap."]
      #[cfg(not(feature = "ink"))]
      pub fn set_heap_pages(
        &self,
        pages: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::set_heap_pages { pages },
        ))
      }
      #[doc = "Set the number of pages in the WebAssembly environment's heap."]
      #[cfg(feature = "ink")]
      pub fn set_heap_pages(&self, pages: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 1u8];
        pages.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the new runtime code."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"]
      #[cfg(not(feature = "ink"))]
      pub fn set_code(
        &self,
        code: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::set_code { code },
        ))
      }
      #[doc = "Set the new runtime code."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"]
      #[cfg(feature = "ink")]
      pub fn set_code(&self, code: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 2u8];
        code.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the new runtime code without doing any checks of the given `code`."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(C)` where `C` length of `code`"]
      #[cfg(not(feature = "ink"))]
      pub fn set_code_without_checks(
        &self,
        code: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::set_code_without_checks { code },
        ))
      }
      #[doc = "Set the new runtime code without doing any checks of the given `code`."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(C)` where `C` length of `code`"]
      #[cfg(feature = "ink")]
      pub fn set_code_without_checks(
        &self,
        code: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 3u8];
        code.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set some items of storage."]
      #[cfg(not(feature = "ink"))]
      pub fn set_storage(
        &self,
        items: ::alloc::vec::Vec<(::alloc::vec::Vec<u8>, ::alloc::vec::Vec<u8>)>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::set_storage { items },
        ))
      }
      #[doc = "Set some items of storage."]
      #[cfg(feature = "ink")]
      pub fn set_storage(
        &self,
        items: ::alloc::vec::Vec<(::alloc::vec::Vec<u8>, ::alloc::vec::Vec<u8>)>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 4u8];
        items.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Kill some items from storage."]
      #[cfg(not(feature = "ink"))]
      pub fn kill_storage(
        &self,
        keys: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::kill_storage { keys },
        ))
      }
      #[doc = "Kill some items from storage."]
      #[cfg(feature = "ink")]
      pub fn kill_storage(
        &self,
        keys: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 5u8];
        keys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Kill all storage items with a key that starts with the given prefix."]
      #[doc = ""]
      #[doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"]
      #[doc = "the prefix we are removing to accurately calculate the weight of this function."]
      #[cfg(not(feature = "ink"))]
      pub fn kill_prefix(
        &self,
        prefix: ::alloc::vec::Vec<u8>,
        subkeys: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::kill_prefix { prefix, subkeys },
        ))
      }
      #[doc = "Kill all storage items with a key that starts with the given prefix."]
      #[doc = ""]
      #[doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"]
      #[doc = "the prefix we are removing to accurately calculate the weight of this function."]
      #[cfg(feature = "ink")]
      pub fn kill_prefix(
        &self,
        prefix: ::alloc::vec::Vec<u8>,
        subkeys: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 6u8];
        prefix.encode_to(&mut buf);
        subkeys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Make some on-chain remark and emit event."]
      #[cfg(not(feature = "ink"))]
      pub fn remark_with_event(
        &self,
        remark: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::remark_with_event { remark },
        ))
      }
      #[doc = "Make some on-chain remark and emit event."]
      #[cfg(feature = "ink")]
      pub fn remark_with_event(&self, remark: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 7u8];
        remark.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for SystemCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct SystemQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> SystemQueryApi<'api> {
      #[doc = " The full account information for a particular account ID."]
      #[cfg(not(feature = "ink"))]
      pub async fn account(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        types::frame_system::AccountInfo<u32, pallet_balances::AccountData>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8, 156u8, 12u8, 243u8, 14u8,
          136u8, 134u8, 55u8, 29u8, 169u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::frame_system::AccountInfo<u32, pallet_balances::AccountData>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The full account information for a particular account ID."]
      #[cfg(feature = "ink")]
      pub fn account(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        types::frame_system::AccountInfo<u32, pallet_balances::AccountData>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8, 156u8, 12u8, 243u8, 14u8,
          136u8, 134u8, 55u8, 29u8, 169u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::frame_system::AccountInfo<u32, pallet_balances::AccountData>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Total extrinsics count for the current block."]
      #[cfg(not(feature = "ink"))]
      pub async fn extrinsic_count(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 189u8, 192u8, 189u8, 48u8, 62u8, 152u8, 85u8, 129u8, 58u8, 168u8, 163u8,
          13u8, 78u8, 252u8, 81u8, 18u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Total extrinsics count for the current block."]
      #[cfg(feature = "ink")]
      pub fn extrinsic_count(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 189u8, 192u8, 189u8, 48u8, 62u8, 152u8, 85u8, 129u8, 58u8, 168u8, 163u8,
          13u8, 78u8, 252u8, 81u8, 18u8,
        ])?;
        Ok(value)
      }
      #[doc = " The current weight for the block."]
      #[cfg(not(feature = "ink"))]
      pub async fn block_weight(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::frame_support::dispatch::PerDispatchClass<::polymesh_api_client::sp_weights::Weight>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 52u8, 171u8, 245u8, 203u8, 52u8, 214u8, 36u8, 67u8, 120u8, 205u8, 219u8,
          241u8, 142u8, 132u8, 157u8, 150u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::frame_support::dispatch::PerDispatchClass<
            ::polymesh_api_client::sp_weights::Weight,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The current weight for the block."]
      #[cfg(feature = "ink")]
      pub fn block_weight(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::frame_support::dispatch::PerDispatchClass<::polymesh_api_client::sp_weights::Weight>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 52u8, 171u8, 245u8, 203u8, 52u8, 214u8, 36u8, 67u8, 120u8, 205u8, 219u8,
          241u8, 142u8, 132u8, 157u8, 150u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::frame_support::dispatch::PerDispatchClass<
            ::polymesh_api_client::sp_weights::Weight,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Total length (in bytes) for all extrinsics put together, for the current block."]
      #[cfg(not(feature = "ink"))]
      pub async fn all_extrinsics_len(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 168u8, 109u8, 165u8, 169u8, 50u8, 104u8, 79u8, 25u8, 149u8, 57u8, 131u8,
          111u8, 203u8, 140u8, 136u8, 111u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Total length (in bytes) for all extrinsics put together, for the current block."]
      #[cfg(feature = "ink")]
      pub fn all_extrinsics_len(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 168u8, 109u8, 165u8, 169u8, 50u8, 104u8, 79u8, 25u8, 149u8, 57u8, 131u8,
          111u8, 203u8, 140u8, 136u8, 111u8,
        ])?;
        Ok(value)
      }
      #[doc = " Map of block numbers to block hashes."]
      #[cfg(not(feature = "ink"))]
      pub async fn block_hash(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<types::primitive_types::H256> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 164u8, 71u8, 4u8, 181u8, 104u8, 210u8, 22u8, 103u8, 53u8, 106u8, 90u8, 5u8,
          12u8, 17u8, 135u8, 70u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Map of block numbers to block hashes."]
      #[cfg(feature = "ink")]
      pub fn block_hash(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<types::primitive_types::H256> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 164u8, 71u8, 4u8, 181u8, 104u8, 210u8, 22u8, 103u8, 53u8, 106u8, 90u8, 5u8,
          12u8, 17u8, 135u8, 70u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."]
      #[cfg(not(feature = "ink"))]
      pub async fn extrinsic_data(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 223u8, 29u8, 174u8, 184u8, 152u8, 104u8, 55u8, 242u8, 28u8, 197u8, 209u8,
          117u8, 150u8, 187u8, 120u8, 209u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."]
      #[cfg(feature = "ink")]
      pub fn extrinsic_data(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 223u8, 29u8, 174u8, 184u8, 152u8, 104u8, 55u8, 242u8, 28u8, 197u8, 209u8,
          117u8, 150u8, 187u8, 120u8, 209u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current block number being processed. Set by `execute_block`."]
      #[cfg(not(feature = "ink"))]
      pub async fn number(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 2u8, 165u8, 193u8, 177u8, 154u8, 183u8, 160u8, 79u8, 83u8, 108u8, 81u8,
          154u8, 202u8, 73u8, 131u8, 172u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current block number being processed. Set by `execute_block`."]
      #[cfg(feature = "ink")]
      pub fn number(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 2u8, 165u8, 193u8, 177u8, 154u8, 183u8, 160u8, 79u8, 83u8, 108u8, 81u8,
          154u8, 202u8, 73u8, 131u8, 172u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Hash of the previous block."]
      #[cfg(not(feature = "ink"))]
      pub async fn parent_hash(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::primitive_types::H256> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 138u8, 66u8, 243u8, 51u8, 35u8, 203u8, 92u8, 237u8, 59u8, 68u8, 221u8,
          130u8, 95u8, 218u8, 159u8, 204u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Hash of the previous block."]
      #[cfg(feature = "ink")]
      pub fn parent_hash(&self) -> ::polymesh_api_ink::error::Result<types::primitive_types::H256> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 138u8, 66u8, 243u8, 51u8, 35u8, 203u8, 92u8, 237u8, 59u8, 68u8, 221u8,
          130u8, 95u8, 218u8, 159u8, 204u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Digest of the current block, also part of the block header."]
      #[cfg(not(feature = "ink"))]
      pub async fn digest(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::sp_runtime::generic::digest::Digest> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 153u8, 231u8, 249u8, 63u8, 198u8, 169u8, 143u8, 8u8, 116u8, 253u8, 5u8,
          127u8, 17u8, 28u8, 77u8, 45u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::sp_runtime::generic::digest::Digest>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Digest of the current block, also part of the block header."]
      #[cfg(feature = "ink")]
      pub fn digest(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::sp_runtime::generic::digest::Digest> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 153u8, 231u8, 249u8, 63u8, 198u8, 169u8, 143u8, 8u8, 116u8, 253u8, 5u8,
          127u8, 17u8, 28u8, 77u8, 45u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::sp_runtime::generic::digest::Digest>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Events deposited for the current block."]
      #[doc = ""]
      #[doc = " NOTE: The item is unbound and should therefore never be read on chain."]
      #[doc = " It could otherwise inflate the PoV size of a block."]
      #[doc = ""]
      #[doc = " Events have a large in-memory size. Box the events to not go out-of-memory"]
      #[doc = " just in case someone still reads them from within the runtime."]
      #[cfg(not(feature = "ink"))]
      pub async fn events(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 128u8, 212u8, 30u8, 94u8, 22u8, 5u8, 103u8, 101u8, 188u8, 132u8, 97u8,
          133u8, 16u8, 114u8, 201u8, 215u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        ::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Events deposited for the current block."]
      #[doc = ""]
      #[doc = " NOTE: The item is unbound and should therefore never be read on chain."]
      #[doc = " It could otherwise inflate the PoV size of a block."]
      #[doc = ""]
      #[doc = " Events have a large in-memory size. Box the events to not go out-of-memory"]
      #[doc = " just in case someone still reads them from within the runtime."]
      #[cfg(feature = "ink")]
      pub fn events(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 128u8, 212u8, 30u8, 94u8, 22u8, 5u8, 103u8, 101u8, 188u8, 132u8, 97u8,
          133u8, 16u8, 114u8, 201u8, 215u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        ::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " The number of events in the `Events<T>` list."]
      #[cfg(not(feature = "ink"))]
      pub async fn event_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 10u8, 152u8, 253u8, 190u8, 156u8, 230u8, 197u8, 88u8, 55u8, 87u8, 108u8,
          96u8, 199u8, 175u8, 56u8, 80u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The number of events in the `Events<T>` list."]
      #[cfg(feature = "ink")]
      pub fn event_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 10u8, 152u8, 253u8, 190u8, 156u8, 230u8, 197u8, 88u8, 55u8, 87u8, 108u8,
          96u8, 199u8, 175u8, 56u8, 80u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"]
      #[doc = " of events in the `<Events<T>>` list."]
      #[doc = ""]
      #[doc = " All topic vectors have deterministic storage locations depending on the topic. This"]
      #[doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"]
      #[doc = " in case of changes fetch the list of events of interest."]
      #[doc = ""]
      #[doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"]
      #[doc = " the `EventIndex` then in case if the topic has the same contents on the next block"]
      #[doc = " no notification will be triggered thus the event might be lost."]
      #[cfg(not(feature = "ink"))]
      pub async fn event_topics(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<(u32, u32)>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 187u8, 148u8, 225u8, 194u8, 26u8, 218u8, 183u8, 20u8, 152u8, 60u8, 240u8,
          102u8, 34u8, 225u8, 222u8, 118u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"]
      #[doc = " of events in the `<Events<T>>` list."]
      #[doc = ""]
      #[doc = " All topic vectors have deterministic storage locations depending on the topic. This"]
      #[doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"]
      #[doc = " in case of changes fetch the list of events of interest."]
      #[doc = ""]
      #[doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"]
      #[doc = " the `EventIndex` then in case if the topic has the same contents on the next block"]
      #[doc = " no notification will be triggered thus the event might be lost."]
      #[cfg(feature = "ink")]
      pub fn event_topics(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<(u32, u32)>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 187u8, 148u8, 225u8, 194u8, 26u8, 218u8, 183u8, 20u8, 152u8, 60u8, 240u8,
          102u8, 34u8, 225u8, 222u8, 118u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."]
      #[cfg(not(feature = "ink"))]
      pub async fn last_runtime_upgrade(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<types::frame_system::LastRuntimeUpgradeInfo>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 249u8, 204u8, 233u8, 200u8, 136u8, 70u8, 155u8, 177u8, 160u8, 220u8, 234u8,
          161u8, 41u8, 103u8, 46u8, 248u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."]
      #[cfg(feature = "ink")]
      pub fn last_runtime_upgrade(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::frame_system::LastRuntimeUpgradeInfo>>
      {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 249u8, 204u8, 233u8, 200u8, 136u8, 70u8, 155u8, 177u8, 160u8, 220u8, 234u8,
          161u8, 41u8, 103u8, 46u8, 248u8,
        ])?;
        Ok(value)
      }
      #[doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."]
      #[cfg(not(feature = "ink"))]
      pub async fn upgraded_to_u32_ref_count(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 86u8, 132u8, 160u8, 34u8, 163u8, 77u8, 216u8, 191u8, 162u8, 186u8, 175u8,
          68u8, 241u8, 114u8, 183u8, 16u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."]
      #[cfg(feature = "ink")]
      pub fn upgraded_to_u32_ref_count(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 86u8, 132u8, 160u8, 34u8, 163u8, 77u8, 216u8, 191u8, 162u8, 186u8, 175u8,
          68u8, 241u8, 114u8, 183u8, 16u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"]
      #[doc = " (default) if not."]
      #[cfg(not(feature = "ink"))]
      pub async fn upgraded_to_triple_ref_count(
        &self,
      ) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 167u8, 253u8, 108u8, 40u8, 131u8, 107u8, 154u8, 40u8, 82u8, 45u8, 201u8,
          36u8, 17u8, 12u8, 244u8, 57u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"]
      #[doc = " (default) if not."]
      #[cfg(feature = "ink")]
      pub fn upgraded_to_triple_ref_count(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 167u8, 253u8, 108u8, 40u8, 131u8, 107u8, 154u8, 40u8, 82u8, 45u8, 201u8,
          36u8, 17u8, 12u8, 244u8, 57u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The execution phase of the block."]
      #[cfg(not(feature = "ink"))]
      pub async fn execution_phase(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<types::frame_system::Phase>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 255u8, 85u8, 59u8, 90u8, 152u8, 98u8, 165u8, 22u8, 147u8, 157u8, 130u8,
          179u8, 211u8, 216u8, 102u8, 26u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The execution phase of the block."]
      #[cfg(feature = "ink")]
      pub fn execution_phase(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::frame_system::Phase>> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 255u8, 85u8, 59u8, 90u8, 152u8, 98u8, 165u8, 22u8, 147u8, 157u8, 130u8,
          179u8, 211u8, 216u8, 102u8, 26u8,
        ])?;
        Ok(value)
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct SystemPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> SystemPagedQueryApi<'api> {
      #[doc = " The full account information for a particular account ID."]
      pub fn account(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::frame_system::AccountInfo<u32, pallet_balances::AccountData>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8, 156u8, 12u8, 243u8, 14u8,
          136u8, 134u8, 55u8, 29u8, 169u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Map of block numbers to block hashes."]
      pub fn block_hash(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<u32, types::primitive_types::H256> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 164u8, 71u8, 4u8, 181u8, 104u8, 210u8, 22u8, 103u8, 53u8, 106u8, 90u8, 5u8,
          12u8, 17u8, 135u8, 70u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."]
      pub fn extrinsic_data(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<u32, ::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 223u8, 29u8, 174u8, 184u8, 152u8, 104u8, 55u8, 242u8, 28u8, 197u8, 209u8,
          117u8, 150u8, 187u8, 120u8, 209u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"]
      #[doc = " of events in the `<Events<T>>` list."]
      #[doc = ""]
      #[doc = " All topic vectors have deterministic storage locations depending on the topic. This"]
      #[doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"]
      #[doc = " in case of changes fetch the list of events of interest."]
      #[doc = ""]
      #[doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"]
      #[doc = " the `EventIndex` then in case if the topic has the same contents on the next block"]
      #[doc = " no notification will be triggered thus the event might be lost."]
      pub fn event_topics(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::primitive_types::H256,
        ::alloc::vec::Vec<(u32, u32)>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 187u8, 148u8, 225u8, 194u8, 26u8, 218u8, 183u8, 20u8, 152u8, 60u8, 240u8,
          102u8, 34u8, 225u8, 222u8, 118u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
    }
  }
  pub mod babe {
    use super::*;
    #[derive(Clone)]
    pub struct BabeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> BabeCallApi<'api> {
      #[doc = "Report authority equivocation/misbehavior. This method will verify"]
      #[doc = "the equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence will"]
      #[doc = "be reported."]
      #[cfg(not(feature = "ink"))]
      pub fn report_equivocation(
        &self,
        equivocation_proof: types::sp_consensus_slots::EquivocationProof<
          types::sp_runtime::generic::header::Header<u32, types::sp_runtime::traits::BlakeTwo256>,
          types::sp_consensus_babe::app::Public,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Babe(
          types::pallet_babe::pallet::BabeCall::report_equivocation {
            equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
            key_owner_proof,
          },
        ))
      }
      #[doc = "Report authority equivocation/misbehavior. This method will verify"]
      #[doc = "the equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence will"]
      #[doc = "be reported."]
      #[cfg(feature = "ink")]
      pub fn report_equivocation(
        &self,
        equivocation_proof: types::sp_consensus_slots::EquivocationProof<
          types::sp_runtime::generic::header::Header<u32, types::sp_runtime::traits::BlakeTwo256>,
          types::sp_consensus_babe::app::Public,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![1u8, 0u8];
        equivocation_proof.encode_to(&mut buf);
        key_owner_proof.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Report authority equivocation/misbehavior. This method will verify"]
      #[doc = "the equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence will"]
      #[doc = "be reported."]
      #[doc = "This extrinsic must be called unsigned and it is expected that only"]
      #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
      #[doc = "if the block author is defined it will be defined as the equivocation"]
      #[doc = "reporter."]
      #[cfg(not(feature = "ink"))]
      pub fn report_equivocation_unsigned(
        &self,
        equivocation_proof: types::sp_consensus_slots::EquivocationProof<
          types::sp_runtime::generic::header::Header<u32, types::sp_runtime::traits::BlakeTwo256>,
          types::sp_consensus_babe::app::Public,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Babe(
          types::pallet_babe::pallet::BabeCall::report_equivocation_unsigned {
            equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
            key_owner_proof,
          },
        ))
      }
      #[doc = "Report authority equivocation/misbehavior. This method will verify"]
      #[doc = "the equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence will"]
      #[doc = "be reported."]
      #[doc = "This extrinsic must be called unsigned and it is expected that only"]
      #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
      #[doc = "if the block author is defined it will be defined as the equivocation"]
      #[doc = "reporter."]
      #[cfg(feature = "ink")]
      pub fn report_equivocation_unsigned(
        &self,
        equivocation_proof: types::sp_consensus_slots::EquivocationProof<
          types::sp_runtime::generic::header::Header<u32, types::sp_runtime::traits::BlakeTwo256>,
          types::sp_consensus_babe::app::Public,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![1u8, 1u8];
        equivocation_proof.encode_to(&mut buf);
        key_owner_proof.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"]
      #[doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."]
      #[doc = "Multiple calls to this method will replace any existing planned config change that had"]
      #[doc = "not been enacted yet."]
      #[cfg(not(feature = "ink"))]
      pub fn plan_config_change(
        &self,
        config: types::sp_consensus_babe::digests::NextConfigDescriptor,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Babe(
          types::pallet_babe::pallet::BabeCall::plan_config_change { config },
        ))
      }
      #[doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"]
      #[doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."]
      #[doc = "Multiple calls to this method will replace any existing planned config change that had"]
      #[doc = "not been enacted yet."]
      #[cfg(feature = "ink")]
      pub fn plan_config_change(
        &self,
        config: types::sp_consensus_babe::digests::NextConfigDescriptor,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![1u8, 2u8];
        config.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for BabeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct BabeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> BabeQueryApi<'api> {
      #[doc = " Current epoch index."]
      #[cfg(not(feature = "ink"))]
      pub async fn epoch_index(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 56u8, 49u8, 108u8, 191u8, 143u8, 160u8, 218u8, 130u8, 42u8, 32u8,
          172u8, 28u8, 85u8, 191u8, 27u8, 227u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current epoch index."]
      #[cfg(feature = "ink")]
      pub fn epoch_index(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 56u8, 49u8, 108u8, 191u8, 143u8, 160u8, 218u8, 130u8, 42u8, 32u8,
          172u8, 28u8, 85u8, 191u8, 27u8, 227u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current epoch authorities."]
      #[cfg(not(feature = "ink"))]
      pub async fn authorities(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 94u8, 6u8, 33u8, 196u8, 134u8, 154u8, 166u8, 12u8, 2u8, 190u8, 154u8,
          220u8, 201u8, 138u8, 13u8, 29u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Current epoch authorities."]
      #[cfg(feature = "ink")]
      pub fn authorities(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 94u8, 6u8, 33u8, 196u8, 134u8, 154u8, 166u8, 12u8, 2u8, 190u8, 154u8,
          220u8, 201u8, 138u8, 13u8, 29u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The slot at which the first epoch actually started. This is 0"]
      #[doc = " until the first block of the chain."]
      #[cfg(not(feature = "ink"))]
      pub async fn genesis_slot(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::sp_consensus_slots::Slot> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 103u8, 135u8, 17u8, 209u8, 94u8, 187u8, 206u8, 186u8, 92u8, 208u8,
          206u8, 161u8, 88u8, 230u8, 103u8, 90u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The slot at which the first epoch actually started. This is 0"]
      #[doc = " until the first block of the chain."]
      #[cfg(feature = "ink")]
      pub fn genesis_slot(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::sp_consensus_slots::Slot> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 103u8, 135u8, 17u8, 209u8, 94u8, 187u8, 206u8, 186u8, 92u8, 208u8,
          206u8, 161u8, 88u8, 230u8, 103u8, 90u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current slot number."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_slot(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::sp_consensus_slots::Slot> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 6u8, 21u8, 91u8, 60u8, 217u8, 168u8, 201u8, 229u8, 233u8, 162u8, 63u8,
          213u8, 220u8, 19u8, 165u8, 237u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current slot number."]
      #[cfg(feature = "ink")]
      pub fn current_slot(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::sp_consensus_slots::Slot> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 6u8, 21u8, 91u8, 60u8, 217u8, 168u8, 201u8, 229u8, 233u8, 162u8, 63u8,
          213u8, 220u8, 19u8, 165u8, 237u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The epoch randomness for the *current* epoch."]
      #[doc = ""]
      #[doc = " # Security"]
      #[doc = ""]
      #[doc = " This MUST NOT be used for gambling, as it can be influenced by a"]
      #[doc = " malicious validator in the short term. It MAY be used in many"]
      #[doc = " cryptographic protocols, however, so long as one remembers that this"]
      #[doc = " (like everything else on-chain) it is public. For example, it can be"]
      #[doc = " used where a number is needed that cannot have been chosen by an"]
      #[doc = " adversary, for purposes such as public-coin zero-knowledge proofs."]
      #[cfg(not(feature = "ink"))]
      pub async fn randomness(&self) -> ::polymesh_api_client::error::Result<[u8; 32usize]> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 122u8, 65u8, 76u8, 176u8, 8u8, 224u8, 230u8, 30u8, 70u8, 114u8, 42u8,
          166u8, 10u8, 189u8, 214u8, 114u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The epoch randomness for the *current* epoch."]
      #[doc = ""]
      #[doc = " # Security"]
      #[doc = ""]
      #[doc = " This MUST NOT be used for gambling, as it can be influenced by a"]
      #[doc = " malicious validator in the short term. It MAY be used in many"]
      #[doc = " cryptographic protocols, however, so long as one remembers that this"]
      #[doc = " (like everything else on-chain) it is public. For example, it can be"]
      #[doc = " used where a number is needed that cannot have been chosen by an"]
      #[doc = " adversary, for purposes such as public-coin zero-knowledge proofs."]
      #[cfg(feature = "ink")]
      pub fn randomness(&self) -> ::polymesh_api_ink::error::Result<[u8; 32usize]> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 122u8, 65u8, 76u8, 176u8, 8u8, 224u8, 230u8, 30u8, 70u8, 114u8, 42u8,
          166u8, 10u8, 189u8, 214u8, 114u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Pending epoch configuration change that will be applied when the next epoch is enacted."]
      #[cfg(not(feature = "ink"))]
      pub async fn pending_epoch_config_change(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::sp_consensus_babe::digests::NextConfigDescriptor>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 139u8, 67u8, 40u8, 227u8, 67u8, 195u8, 224u8, 172u8, 144u8, 248u8,
          61u8, 164u8, 134u8, 12u8, 190u8, 54u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Pending epoch configuration change that will be applied when the next epoch is enacted."]
      #[cfg(feature = "ink")]
      pub fn pending_epoch_config_change(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::sp_consensus_babe::digests::NextConfigDescriptor>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 139u8, 67u8, 40u8, 227u8, 67u8, 195u8, 224u8, 172u8, 144u8, 248u8,
          61u8, 164u8, 134u8, 12u8, 190u8, 54u8,
        ])?;
        Ok(value)
      }
      #[doc = " Next epoch randomness."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_randomness(&self) -> ::polymesh_api_client::error::Result<[u8; 32usize]> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 124u8, 230u8, 120u8, 121u8, 157u8, 62u8, 255u8, 2u8, 66u8, 83u8,
          185u8, 14u8, 132u8, 146u8, 124u8, 198u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Next epoch randomness."]
      #[cfg(feature = "ink")]
      pub fn next_randomness(&self) -> ::polymesh_api_ink::error::Result<[u8; 32usize]> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 124u8, 230u8, 120u8, 121u8, 157u8, 62u8, 255u8, 2u8, 66u8, 83u8,
          185u8, 14u8, 132u8, 146u8, 124u8, 198u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Next epoch authorities."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_authorities(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 170u8, 207u8, 0u8, 185u8, 180u8, 31u8, 218u8, 122u8, 146u8, 104u8,
          130u8, 28u8, 42u8, 43u8, 62u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Next epoch authorities."]
      #[cfg(feature = "ink")]
      pub fn next_authorities(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 170u8, 207u8, 0u8, 185u8, 180u8, 31u8, 218u8, 122u8, 146u8, 104u8,
          130u8, 28u8, 42u8, 43u8, 62u8, 76u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Randomness under construction."]
      #[doc = ""]
      #[doc = " We make a trade-off between storage accesses and list length."]
      #[doc = " We store the under-construction randomness in segments of up to"]
      #[doc = " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`."]
      #[doc = ""]
      #[doc = " Once a segment reaches this length, we begin the next one."]
      #[doc = " We reset all segments and return to `0` at the beginning of every"]
      #[doc = " epoch."]
      #[cfg(not(feature = "ink"))]
      pub async fn segment_index(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 102u8, 232u8, 240u8, 53u8, 200u8, 173u8, 190u8, 127u8, 21u8, 71u8,
          180u8, 60u8, 81u8, 230u8, 248u8, 164u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Randomness under construction."]
      #[doc = ""]
      #[doc = " We make a trade-off between storage accesses and list length."]
      #[doc = " We store the under-construction randomness in segments of up to"]
      #[doc = " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`."]
      #[doc = ""]
      #[doc = " Once a segment reaches this length, we begin the next one."]
      #[doc = " We reset all segments and return to `0` at the beginning of every"]
      #[doc = " epoch."]
      #[cfg(feature = "ink")]
      pub fn segment_index(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 102u8, 232u8, 240u8, 53u8, 200u8, 173u8, 190u8, 127u8, 21u8, 71u8,
          180u8, 60u8, 81u8, 230u8, 248u8, 164u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."]
      #[cfg(not(feature = "ink"))]
      pub async fn under_construction(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<[u8; 32usize]>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 185u8, 9u8, 54u8, 89u8, 215u8, 168u8, 86u8, 128u8, 151u8, 87u8, 19u8,
          77u8, 43u8, 200u8, 110u8, 98u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<[u8; 32usize]>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."]
      #[cfg(feature = "ink")]
      pub fn under_construction(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<[u8; 32usize]>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 185u8, 9u8, 54u8, 89u8, 215u8, 168u8, 86u8, 128u8, 151u8, 87u8, 19u8,
          77u8, 43u8, 200u8, 110u8, 98u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<[u8; 32usize]>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Temporary value (cleared at block finalization) which is `Some`"]
      #[doc = " if per-block initialization has already been called for current block."]
      #[cfg(not(feature = "ink"))]
      pub async fn initialized(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<Option<types::sp_consensus_babe::digests::PreDigest>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 250u8, 146u8, 222u8, 145u8, 10u8, 124u8, 226u8, 189u8, 88u8, 233u8,
          151u8, 41u8, 198u8, 151u8, 39u8, 193u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Temporary value (cleared at block finalization) which is `Some`"]
      #[doc = " if per-block initialization has already been called for current block."]
      #[cfg(feature = "ink")]
      pub fn initialized(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<Option<types::sp_consensus_babe::digests::PreDigest>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 250u8, 146u8, 222u8, 145u8, 10u8, 124u8, 226u8, 189u8, 88u8, 233u8,
          151u8, 41u8, 198u8, 151u8, 39u8, 193u8,
        ])?;
        Ok(value)
      }
      #[doc = " This field should always be populated during block processing unless"]
      #[doc = " secondary plain slots are enabled (which don't contain a VRF output)."]
      #[doc = ""]
      #[doc = " It is set in `on_finalize`, before it will contain the value from the last block."]
      #[cfg(not(feature = "ink"))]
      pub async fn author_vrf_randomness(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<[u8; 32usize]>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 208u8, 119u8, 223u8, 219u8, 138u8, 219u8, 16u8, 247u8, 143u8, 16u8,
          165u8, 223u8, 135u8, 66u8, 197u8, 69u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <Option<[u8; 32usize]>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " This field should always be populated during block processing unless"]
      #[doc = " secondary plain slots are enabled (which don't contain a VRF output)."]
      #[doc = ""]
      #[doc = " It is set in `on_finalize`, before it will contain the value from the last block."]
      #[cfg(feature = "ink")]
      pub fn author_vrf_randomness(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<[u8; 32usize]>> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 208u8, 119u8, 223u8, 219u8, 138u8, 219u8, 16u8, 247u8, 143u8, 16u8,
          165u8, 223u8, 135u8, 66u8, 197u8, 69u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <Option<[u8; 32usize]>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The block numbers when the last and current epoch have started, respectively `N-1` and"]
      #[doc = " `N`."]
      #[doc = " NOTE: We track this is in order to annotate the block number when a given pool of"]
      #[doc = " entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in"]
      #[doc = " slots, which may be skipped, the block numbers may not line up with the slot numbers."]
      #[cfg(not(feature = "ink"))]
      pub async fn epoch_start(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 233u8, 14u8, 47u8, 191u8, 45u8, 121u8, 44u8, 179u8, 36u8, 191u8,
          250u8, 148u8, 39u8, 254u8, 31u8, 14u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The block numbers when the last and current epoch have started, respectively `N-1` and"]
      #[doc = " `N`."]
      #[doc = " NOTE: We track this is in order to annotate the block number when a given pool of"]
      #[doc = " entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in"]
      #[doc = " slots, which may be skipped, the block numbers may not line up with the slot numbers."]
      #[cfg(feature = "ink")]
      pub fn epoch_start(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 233u8, 14u8, 47u8, 191u8, 45u8, 121u8, 44u8, 179u8, 36u8, 191u8,
          250u8, 148u8, 39u8, 254u8, 31u8, 14u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How late the current block is compared to its parent."]
      #[doc = ""]
      #[doc = " This entry is populated as part of block execution and is cleaned up"]
      #[doc = " on block finalization. Querying this storage entry outside of block"]
      #[doc = " execution context should always yield zero."]
      #[cfg(not(feature = "ink"))]
      pub async fn lateness(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 3u8, 35u8, 71u8, 86u8, 87u8, 224u8, 137u8, 15u8, 189u8, 191u8, 102u8,
          251u8, 36u8, 180u8, 100u8, 158u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How late the current block is compared to its parent."]
      #[doc = ""]
      #[doc = " This entry is populated as part of block execution and is cleaned up"]
      #[doc = " on block finalization. Querying this storage entry outside of block"]
      #[doc = " execution context should always yield zero."]
      #[cfg(feature = "ink")]
      pub fn lateness(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 3u8, 35u8, 71u8, 86u8, 87u8, 224u8, 137u8, 15u8, 189u8, 191u8, 102u8,
          251u8, 36u8, 180u8, 100u8, 158u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The configuration for the current epoch. Should never be `None` as it is initialized in"]
      #[doc = " genesis."]
      #[cfg(not(feature = "ink"))]
      pub async fn epoch_config(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::sp_consensus_babe::BabeEpochConfiguration>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 220u8, 107u8, 23u8, 27u8, 119u8, 48u8, 66u8, 99u8, 194u8, 146u8,
          204u8, 62u8, 165u8, 237u8, 49u8, 239u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The configuration for the current epoch. Should never be `None` as it is initialized in"]
      #[doc = " genesis."]
      #[cfg(feature = "ink")]
      pub fn epoch_config(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::sp_consensus_babe::BabeEpochConfiguration>>
      {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 220u8, 107u8, 23u8, 27u8, 119u8, 48u8, 66u8, 99u8, 194u8, 146u8,
          204u8, 62u8, 165u8, 237u8, 49u8, 239u8,
        ])?;
        Ok(value)
      }
      #[doc = " The configuration for the next epoch, `None` if the config will not change"]
      #[doc = " (you can fallback to `EpochConfig` instead in that case)."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_epoch_config(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::sp_consensus_babe::BabeEpochConfiguration>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 154u8, 171u8, 10u8, 91u8, 99u8, 179u8, 89u8, 81u8, 45u8, 238u8, 229u8,
          87u8, 201u8, 244u8, 207u8, 99u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The configuration for the next epoch, `None` if the config will not change"]
      #[doc = " (you can fallback to `EpochConfig` instead in that case)."]
      #[cfg(feature = "ink")]
      pub fn next_epoch_config(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::sp_consensus_babe::BabeEpochConfiguration>>
      {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 154u8, 171u8, 10u8, 91u8, 99u8, 179u8, 89u8, 81u8, 45u8, 238u8, 229u8,
          87u8, 201u8, 244u8, 207u8, 99u8,
        ])?;
        Ok(value)
      }
      #[doc = " A list of the last 100 skipped epochs and the corresponding session index"]
      #[doc = " when the epoch was skipped."]
      #[doc = ""]
      #[doc = " This is only used for validating equivocation proofs. An equivocation proof"]
      #[doc = " must contains a key-ownership proof for a given session, therefore we need a"]
      #[doc = " way to tie together sessions and epoch indices, i.e. we need to validate that"]
      #[doc = " a validator was the owner of a given key on a given session, and what the"]
      #[doc = " active epoch index was during that session."]
      #[cfg(not(feature = "ink"))]
      pub async fn skipped_epochs(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<(u64, u32)>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 55u8, 184u8, 132u8, 47u8, 84u8, 199u8, 237u8, 223u8, 2u8, 181u8,
          229u8, 132u8, 170u8, 42u8, 230u8, 204u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u64, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A list of the last 100 skipped epochs and the corresponding session index"]
      #[doc = " when the epoch was skipped."]
      #[doc = ""]
      #[doc = " This is only used for validating equivocation proofs. An equivocation proof"]
      #[doc = " must contains a key-ownership proof for a given session, therefore we need a"]
      #[doc = " way to tie together sessions and epoch indices, i.e. we need to validate that"]
      #[doc = " a validator was the owner of a given key on a given session, and what the"]
      #[doc = " active epoch index was during that session."]
      #[cfg(feature = "ink")]
      pub fn skipped_epochs(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<(u64, u32)>> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 55u8, 184u8, 132u8, 47u8, 84u8, 199u8, 237u8, 223u8, 2u8, 181u8,
          229u8, 132u8, 170u8, 42u8, 230u8, 204u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u64, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct BabePagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> BabePagedQueryApi<'api> {
      #[doc = " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."]
      pub fn under_construction(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<u32, ::alloc::vec::Vec<[u8; 32usize]>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 185u8, 9u8, 54u8, 89u8, 215u8, 168u8, 86u8, 128u8, 151u8, 87u8, 19u8,
          77u8, 43u8, 200u8, 110u8, 98u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod timestamp {
    use super::*;
    #[derive(Clone)]
    pub struct TimestampCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TimestampCallApi<'api> {
      #[doc = "Set the current time."]
      #[doc = ""]
      #[doc = "This call should be invoked exactly once per block. It will panic at the finalization"]
      #[doc = "phase, if this call hasn't been invoked by that time."]
      #[doc = ""]
      #[doc = "The timestamp should be greater than the previous one by the amount specified by"]
      #[doc = "`MinimumPeriod`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be `Inherent`."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"]
      #[doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"]
      #[doc = "  `on_finalize`)"]
      #[doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn set(
        &self,
        now: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Timestamp(
          types::pallet_timestamp::pallet::TimestampCall::set { now },
        ))
      }
      #[doc = "Set the current time."]
      #[doc = ""]
      #[doc = "This call should be invoked exactly once per block. It will panic at the finalization"]
      #[doc = "phase, if this call hasn't been invoked by that time."]
      #[doc = ""]
      #[doc = "The timestamp should be greater than the previous one by the amount specified by"]
      #[doc = "`MinimumPeriod`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be `Inherent`."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"]
      #[doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"]
      #[doc = "  `on_finalize`)"]
      #[doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn set(&self, now: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![2u8, 0u8];
        now.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for TimestampCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TimestampQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TimestampQueryApi<'api> {
      #[doc = " Current time for the current block."]
      #[cfg(not(feature = "ink"))]
      pub async fn now(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8, 14u8, 122u8,
          65u8, 19u8, 196u8, 159u8, 31u8, 5u8, 21u8, 244u8, 98u8, 205u8, 207u8, 132u8, 224u8,
          241u8, 214u8, 4u8, 93u8, 252u8, 187u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current time for the current block."]
      #[cfg(feature = "ink")]
      pub fn now(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8, 14u8, 122u8,
          65u8, 19u8, 196u8, 159u8, 31u8, 5u8, 21u8, 244u8, 98u8, 205u8, 207u8, 132u8, 224u8,
          241u8, 214u8, 4u8, 93u8, 252u8, 187u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Did the timestamp get updated in this block?"]
      #[cfg(not(feature = "ink"))]
      pub async fn did_update(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8, 14u8, 122u8,
          65u8, 19u8, 196u8, 187u8, 209u8, 8u8, 196u8, 137u8, 153u8, 100u8, 247u8, 7u8, 253u8,
          175u8, 251u8, 130u8, 99u8, 96u8, 101u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Did the timestamp get updated in this block?"]
      #[cfg(feature = "ink")]
      pub fn did_update(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8, 14u8, 122u8,
          65u8, 19u8, 196u8, 187u8, 209u8, 8u8, 196u8, 137u8, 153u8, 100u8, 247u8, 7u8, 253u8,
          175u8, 251u8, 130u8, 99u8, 96u8, 101u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct TimestampPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> TimestampPagedQueryApi<'api> {}
  }
  pub mod indices {
    use super::*;
    #[derive(Clone)]
    pub struct IndicesCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> IndicesCallApi<'api> {
      #[doc = "Assign an previously unassigned index."]
      #[doc = ""]
      #[doc = "Payment: `Deposit` is reserved from the sender account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be claimed. This must not be in use."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn claim(
        &self,
        index: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Indices(
          types::pallet_indices::pallet::IndicesCall::claim { index },
        ))
      }
      #[doc = "Assign an previously unassigned index."]
      #[doc = ""]
      #[doc = "Payment: `Deposit` is reserved from the sender account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be claimed. This must not be in use."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn claim(&self, index: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![3u8, 0u8];
        index.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Assign an index already owned by the sender to another account. The balance reservation"]
      #[doc = "is effectively transferred to the new account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be re-assigned. This must be owned by the sender."]
      #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn transfer(
        &self,
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        index: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Indices(
          types::pallet_indices::pallet::IndicesCall::transfer { new, index },
        ))
      }
      #[doc = "Assign an index already owned by the sender to another account. The balance reservation"]
      #[doc = "is effectively transferred to the new account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be re-assigned. This must be owned by the sender."]
      #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn transfer(
        &self,
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        index: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![3u8, 1u8];
        new.encode_to(&mut buf);
        index.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Free up an index owned by the sender."]
      #[doc = ""]
      #[doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."]
      #[doc = ""]
      #[doc = "- `index`: the index to be freed. This must be owned by the sender."]
      #[doc = ""]
      #[doc = "Emits `IndexFreed` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn free(
        &self,
        index: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Indices(
          types::pallet_indices::pallet::IndicesCall::free { index },
        ))
      }
      #[doc = "Free up an index owned by the sender."]
      #[doc = ""]
      #[doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."]
      #[doc = ""]
      #[doc = "- `index`: the index to be freed. This must be owned by the sender."]
      #[doc = ""]
      #[doc = "Emits `IndexFreed` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn free(&self, index: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![3u8, 2u8];
        index.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Force an index to an account. This doesn't require a deposit. If the index is already"]
      #[doc = "held, then any deposit is reimbursed to its current owner."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be (re-)assigned."]
      #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
      #[doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn force_transfer(
        &self,
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        index: u32,
        freeze: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Indices(
          types::pallet_indices::pallet::IndicesCall::force_transfer { new, index, freeze },
        ))
      }
      #[doc = "Force an index to an account. This doesn't require a deposit. If the index is already"]
      #[doc = "held, then any deposit is reimbursed to its current owner."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be (re-)assigned."]
      #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
      #[doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn force_transfer(
        &self,
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        index: u32,
        freeze: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![3u8, 3u8];
        new.encode_to(&mut buf);
        index.encode_to(&mut buf);
        freeze.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Freeze an index so it will always point to the sender account. This consumes the"]
      #[doc = "deposit."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
      #[doc = "non-frozen account `index`."]
      #[doc = ""]
      #[doc = "- `index`: the index to be frozen in place."]
      #[doc = ""]
      #[doc = "Emits `IndexFrozen` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn freeze(
        &self,
        index: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Indices(
          types::pallet_indices::pallet::IndicesCall::freeze { index },
        ))
      }
      #[doc = "Freeze an index so it will always point to the sender account. This consumes the"]
      #[doc = "deposit."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
      #[doc = "non-frozen account `index`."]
      #[doc = ""]
      #[doc = "- `index`: the index to be frozen in place."]
      #[doc = ""]
      #[doc = "Emits `IndexFrozen` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn freeze(&self, index: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![3u8, 4u8];
        index.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for IndicesCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct IndicesQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> IndicesQueryApi<'api> {
      #[doc = " The lookup from index to account."]
      #[cfg(not(feature = "ink"))]
      pub async fn accounts(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<
        Option<(::polymesh_api_client::AccountId, u128, bool)>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          26u8, 115u8, 109u8, 55u8, 80u8, 76u8, 46u8, 63u8, 183u8, 61u8, 173u8, 22u8, 12u8, 85u8,
          178u8, 145u8, 142u8, 231u8, 65u8, 138u8, 101u8, 49u8, 23u8, 61u8, 96u8, 209u8, 246u8,
          168u8, 45u8, 143u8, 77u8, 81u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The lookup from index to account."]
      #[cfg(feature = "ink")]
      pub fn accounts(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<Option<(::polymesh_api_client::AccountId, u128, bool)>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          26u8, 115u8, 109u8, 55u8, 80u8, 76u8, 46u8, 63u8, 183u8, 61u8, 173u8, 22u8, 12u8, 85u8,
          178u8, 145u8, 142u8, 231u8, 65u8, 138u8, 101u8, 49u8, 23u8, 61u8, 96u8, 209u8, 246u8,
          168u8, 45u8, 143u8, 77u8, 81u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct IndicesPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> IndicesPagedQueryApi<'api> {
      #[doc = " The lookup from index to account."]
      pub fn accounts(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<u32, (::polymesh_api_client::AccountId, u128, bool)>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          26u8, 115u8, 109u8, 55u8, 80u8, 76u8, 46u8, 63u8, 183u8, 61u8, 173u8, 22u8, 12u8, 85u8,
          178u8, 145u8, 142u8, 231u8, 65u8, 138u8, 101u8, 49u8, 23u8, 61u8, 96u8, 209u8, 246u8,
          168u8, 45u8, 143u8, 77u8, 81u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
    }
  }
  pub mod authorship {
    use super::*;
    #[derive(Clone)]
    pub struct AuthorshipCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> AuthorshipCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for AuthorshipCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct AuthorshipQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> AuthorshipQueryApi<'api> {
      #[doc = " Author of current block."]
      #[cfg(not(feature = "ink"))]
      pub async fn author(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          213u8, 123u8, 206u8, 84u8, 95u8, 179u8, 130u8, 195u8, 69u8, 112u8, 229u8, 223u8, 191u8,
          51u8, 143u8, 94u8, 50u8, 109u8, 33u8, 188u8, 103u8, 164u8, 179u8, 64u8, 35u8, 213u8,
          119u8, 88u8, 93u8, 114u8, 191u8, 215u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Author of current block."]
      #[cfg(feature = "ink")]
      pub fn author(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        let value = self.api.read_storage(::alloc::vec![
          213u8, 123u8, 206u8, 84u8, 95u8, 179u8, 130u8, 195u8, 69u8, 112u8, 229u8, 223u8, 191u8,
          51u8, 143u8, 94u8, 50u8, 109u8, 33u8, 188u8, 103u8, 164u8, 179u8, 64u8, 35u8, 213u8,
          119u8, 88u8, 93u8, 114u8, 191u8, 215u8,
        ])?;
        Ok(value)
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct AuthorshipPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> AuthorshipPagedQueryApi<'api> {}
  }
  pub mod balances {
    use super::*;
    #[derive(Clone)]
    pub struct BalancesCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> BalancesCallApi<'api> {
      #[doc = "Transfer some liquid free balance to another account."]
      #[doc = ""]
      #[doc = "`transfer` will set the `FreeBalance` of the sender and receiver."]
      #[doc = "It will decrease the total issuance of the system by the `TransferFee`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Dependent on arguments but not critical, given proper implementations for"]
      #[doc = "  input config types. See related functions below."]
      #[doc = "- It contains a limited number of reads and writes internally and no complex computation."]
      #[doc = ""]
      #[doc = "Related functions:"]
      #[doc = ""]
      #[doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."]
      #[doc = "  - Transferring balances to accounts that did not exist before will cause"]
      #[doc = "     `T::OnNewAccount::on_new_account` to be called."]
      #[doc = "---------------------------------"]
      #[doc = "- Base Weight: 73.64 µs, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn transfer(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::transfer { dest, value },
        ))
      }
      #[doc = "Transfer some liquid free balance to another account."]
      #[doc = ""]
      #[doc = "`transfer` will set the `FreeBalance` of the sender and receiver."]
      #[doc = "It will decrease the total issuance of the system by the `TransferFee`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Dependent on arguments but not critical, given proper implementations for"]
      #[doc = "  input config types. See related functions below."]
      #[doc = "- It contains a limited number of reads and writes internally and no complex computation."]
      #[doc = ""]
      #[doc = "Related functions:"]
      #[doc = ""]
      #[doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."]
      #[doc = "  - Transferring balances to accounts that did not exist before will cause"]
      #[doc = "     `T::OnNewAccount::on_new_account` to be called."]
      #[doc = "---------------------------------"]
      #[doc = "- Base Weight: 73.64 µs, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn transfer(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 0u8];
        dest.encode_to(&mut buf);
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Transfer the native currency with the help of identifier string"]
      #[doc = "this functionality can help to differentiate the transfers."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Base Weight: 73.64 µs, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn transfer_with_memo(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        memo: Option<types::polymesh_primitives::Memo>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::transfer_with_memo { dest, value, memo },
        ))
      }
      #[doc = "Transfer the native currency with the help of identifier string"]
      #[doc = "this functionality can help to differentiate the transfers."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Base Weight: 73.64 µs, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn transfer_with_memo(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        memo: Option<types::polymesh_primitives::Memo>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 1u8];
        dest.encode_to(&mut buf);
        value.encode_to(&mut buf);
        memo.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Move some POLYX from balance of self to balance of BRR."]
      #[cfg(not(feature = "ink"))]
      pub fn deposit_block_reward_reserve_balance(
        &self,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::deposit_block_reward_reserve_balance { value },
        ))
      }
      #[doc = "Move some POLYX from balance of self to balance of BRR."]
      #[cfg(feature = "ink")]
      pub fn deposit_block_reward_reserve_balance(&self, value: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 2u8];
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the balances of a given account."]
      #[doc = ""]
      #[doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"]
      #[doc = "also decrease the total issuance of the system (`TotalIssuance`)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call is `root`."]
      #[cfg(not(feature = "ink"))]
      pub fn set_balance(
        &self,
        who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        new_free: u128,
        new_reserved: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::set_balance {
            who,
            new_free,
            new_reserved,
          },
        ))
      }
      #[doc = "Set the balances of a given account."]
      #[doc = ""]
      #[doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"]
      #[doc = "also decrease the total issuance of the system (`TotalIssuance`)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call is `root`."]
      #[cfg(feature = "ink")]
      pub fn set_balance(
        &self,
        who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        new_free: u128,
        new_reserved: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 3u8];
        who.encode_to(&mut buf);
        new_free.encode_to(&mut buf);
        new_reserved.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Exactly as `transfer`, except the origin must be root and the source account may be"]
      #[doc = "specified."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Same as transfer, but additional read and write because the source account is"]
      #[doc = "  not assumed to be in the overlay."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn force_transfer(
        &self,
        source: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::force_transfer {
            source,
            dest,
            value,
          },
        ))
      }
      #[doc = "Exactly as `transfer`, except the origin must be root and the source account may be"]
      #[doc = "specified."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Same as transfer, but additional read and write because the source account is"]
      #[doc = "  not assumed to be in the overlay."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn force_transfer(
        &self,
        source: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 4u8];
        source.encode_to(&mut buf);
        dest.encode_to(&mut buf);
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Burns the given amount of tokens from the caller's free, unlocked balance."]
      #[cfg(not(feature = "ink"))]
      pub fn burn_account_balance(
        &self,
        amount: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::burn_account_balance { amount },
        ))
      }
      #[doc = "Burns the given amount of tokens from the caller's free, unlocked balance."]
      #[cfg(feature = "ink")]
      pub fn burn_account_balance(&self, amount: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 5u8];
        amount.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for BalancesCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct BalancesQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> BalancesQueryApi<'api> {
      #[doc = " The total units issued in the system."]
      #[cfg(not(feature = "ink"))]
      pub async fn total_issuance(&self) -> ::polymesh_api_client::error::Result<u128> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8, 116u8,
          177u8, 92u8, 47u8, 87u8, 200u8, 117u8, 228u8, 207u8, 247u8, 65u8, 72u8, 228u8, 98u8,
          143u8, 38u8, 75u8, 151u8, 76u8, 128u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total units issued in the system."]
      #[cfg(feature = "ink")]
      pub fn total_issuance(&self) -> ::polymesh_api_ink::error::Result<u128> {
        let value = self.api.read_storage(::alloc::vec![
          194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8, 116u8,
          177u8, 92u8, 47u8, 87u8, 200u8, 117u8, 228u8, 207u8, 247u8, 65u8, 72u8, 228u8, 98u8,
          143u8, 38u8, 75u8, 151u8, 76u8, 128u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Any liquidity locks on some account balances."]
      #[doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."]
      #[cfg(not(feature = "ink"))]
      pub async fn locks(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::pallet_balances::BalanceLock<u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8, 116u8,
          177u8, 92u8, 47u8, 33u8, 143u8, 38u8, 199u8, 58u8, 221u8, 99u8, 72u8, 151u8, 85u8, 11u8,
          64u8, 3u8, 178u8, 107u8, 198u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_balances::BalanceLock<u128>>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Any liquidity locks on some account balances."]
      #[doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."]
      #[cfg(feature = "ink")]
      pub fn locks(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::pallet_balances::BalanceLock<u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8, 116u8,
          177u8, 92u8, 47u8, 33u8, 143u8, 38u8, 199u8, 58u8, 221u8, 99u8, 72u8, 151u8, 85u8, 11u8,
          64u8, 3u8, 178u8, 107u8, 198u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_balances::BalanceLock<u128>>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct BalancesPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> BalancesPagedQueryApi<'api> {
      #[doc = " Any liquidity locks on some account balances."]
      #[doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."]
      pub fn locks(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        ::alloc::vec::Vec<types::pallet_balances::BalanceLock<u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8, 116u8,
          177u8, 92u8, 47u8, 33u8, 143u8, 38u8, 199u8, 58u8, 221u8, 99u8, 72u8, 151u8, 85u8, 11u8,
          64u8, 3u8, 178u8, 107u8, 198u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
    }
  }
  pub mod transaction_payment {
    use super::*;
    #[derive(Clone)]
    pub struct TransactionPaymentCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TransactionPaymentCallApi<'api> {
      #[cfg(not(feature = "ink"))]
      pub fn set_disable_fees(
        &self,
        value: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TransactionPayment(
          types::pallet_transaction_payment::pallet::TransactionPaymentCall::set_disable_fees {
            value,
          },
        ))
      }
      #[cfg(feature = "ink")]
      pub fn set_disable_fees(&self, value: bool) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![6u8, 0u8];
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for TransactionPaymentCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TransactionPaymentQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TransactionPaymentQueryApi<'api> {
      #[cfg(not(feature = "ink"))]
      pub async fn next_fee_multiplier(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::sp_arithmetic::fixed_point::FixedU128>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8, 85u8,
          226u8, 8u8, 16u8, 63u8, 46u8, 223u8, 59u8, 223u8, 56u8, 29u8, 235u8, 227u8, 49u8, 171u8,
          116u8, 70u8, 173u8, 223u8, 220u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 100u8, 167u8, 179u8, 182u8, 224u8, 13u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8,
          ];
          <types::sp_arithmetic::fixed_point::FixedU128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(feature = "ink")]
      pub fn next_fee_multiplier(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::sp_arithmetic::fixed_point::FixedU128> {
        let value = self.api.read_storage(::alloc::vec![
          63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8, 85u8,
          226u8, 8u8, 16u8, 63u8, 46u8, 223u8, 59u8, 223u8, 56u8, 29u8, 235u8, 227u8, 49u8, 171u8,
          116u8, 70u8, 173u8, 223u8, 220u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 100u8, 167u8, 179u8, 182u8, 224u8, 13u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8,
          ];
          <types::sp_arithmetic::fixed_point::FixedU128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_transaction_payment::Releases> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8, 85u8,
          226u8, 8u8, 16u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_transaction_payment::Releases>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_transaction_payment::Releases> {
        let value = self.api.read_storage(::alloc::vec![
          63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8, 85u8,
          226u8, 8u8, 16u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_transaction_payment::Releases>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct TransactionPaymentPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> TransactionPaymentPagedQueryApi<'api> {}
  }
  pub mod identity {
    use super::*;
    #[derive(Clone)]
    pub struct IdentityCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> IdentityCallApi<'api> {
      #[doc = "Register `target_account` with a new Identity."]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[cfg(not(feature = "ink"))]
      pub fn cdd_register_did(
        &self,
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::cdd_register_did {
            target_account,
            secondary_keys,
          },
        ))
      }
      #[doc = "Register `target_account` with a new Identity."]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[cfg(feature = "ink")]
      pub fn cdd_register_did(
        &self,
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 0u8];
        target_account.encode_to(&mut buf);
        secondary_keys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Invalidates any claim generated by `cdd` from `disable_from` timestamps."]
      #[doc = ""]
      #[doc = "You can also define an expiration time,"]
      #[doc = "which will invalidate all claims generated by that `cdd` and remove it as CDD member group."]
      #[cfg(not(feature = "ink"))]
      pub fn invalidate_cdd_claims(
        &self,
        cdd: ::polymesh_api_client::IdentityId,
        disable_from: u64,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::invalidate_cdd_claims {
            cdd,
            disable_from,
            expiry,
          },
        ))
      }
      #[doc = "Invalidates any claim generated by `cdd` from `disable_from` timestamps."]
      #[doc = ""]
      #[doc = "You can also define an expiration time,"]
      #[doc = "which will invalidate all claims generated by that `cdd` and remove it as CDD member group."]
      #[cfg(feature = "ink")]
      pub fn invalidate_cdd_claims(
        &self,
        cdd: ::polymesh_api_client::IdentityId,
        disable_from: u64,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 1u8];
        cdd.encode_to(&mut buf);
        disable_from.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key"]
      #[doc = "instead of leaving it as a secondary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[cfg(not(feature = "ink"))]
      pub fn accept_primary_key(
        &self,
        rotation_auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::accept_primary_key {
            rotation_auth_id,
            optional_cdd_auth_id,
          },
        ))
      }
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key"]
      #[doc = "instead of leaving it as a secondary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[cfg(feature = "ink")]
      pub fn accept_primary_key(
        &self,
        rotation_auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 2u8];
        rotation_auth_id.encode_to(&mut buf);
        optional_cdd_auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set if CDD authorization is required for updating primary key of an identity."]
      #[doc = "Callable via root (governance)"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_required` CDD Authorization required or not"]
      #[cfg(not(feature = "ink"))]
      pub fn change_cdd_requirement_for_mk_rotation(
        &self,
        auth_required: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::change_cdd_requirement_for_mk_rotation {
            auth_required,
          },
        ))
      }
      #[doc = "Set if CDD authorization is required for updating primary key of an identity."]
      #[doc = "Callable via root (governance)"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_required` CDD Authorization required or not"]
      #[cfg(feature = "ink")]
      pub fn change_cdd_requirement_for_mk_rotation(
        &self,
        auth_required: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 3u8];
        auth_required.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Join an identity as a secondary key."]
      #[cfg(not(feature = "ink"))]
      pub fn join_identity_as_key(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::join_identity_as_key { auth_id },
        ))
      }
      #[doc = "Join an identity as a secondary key."]
      #[cfg(feature = "ink")]
      pub fn join_identity_as_key(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 4u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Leave the secondary key's identity."]
      #[cfg(not(feature = "ink"))]
      pub fn leave_identity_as_key(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::leave_identity_as_key,
        ))
      }
      #[doc = "Leave the secondary key's identity."]
      #[cfg(feature = "ink")]
      pub fn leave_identity_as_key(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![7u8, 5u8])
      }
      #[doc = "Adds a new claim record or edits an existing one."]
      #[doc = ""]
      #[doc = "Only called by did_issuer's secondary key."]
      #[cfg(not(feature = "ink"))]
      pub fn add_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim: types::polymesh_primitives::identity_claim::Claim,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::add_claim {
            target,
            claim,
            expiry,
          },
        ))
      }
      #[doc = "Adds a new claim record or edits an existing one."]
      #[doc = ""]
      #[doc = "Only called by did_issuer's secondary key."]
      #[cfg(feature = "ink")]
      pub fn add_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim: types::polymesh_primitives::identity_claim::Claim,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 6u8];
        target.encode_to(&mut buf);
        claim.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Marks the specified claim as revoked."]
      #[cfg(not(feature = "ink"))]
      pub fn revoke_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim: types::polymesh_primitives::identity_claim::Claim,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::revoke_claim { target, claim },
        ))
      }
      #[doc = "Marks the specified claim as revoked."]
      #[cfg(feature = "ink")]
      pub fn revoke_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim: types::polymesh_primitives::identity_claim::Claim,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 7u8];
        target.encode_to(&mut buf);
        claim.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "It disables all secondary keys at `did` identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub fn freeze_secondary_keys(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::freeze_secondary_keys,
        ))
      }
      #[doc = "It disables all secondary keys at `did` identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn freeze_secondary_keys(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![7u8, 8u8])
      }
      #[doc = "Re-enables all secondary keys of the caller's identity."]
      #[cfg(not(feature = "ink"))]
      pub fn unfreeze_secondary_keys(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::unfreeze_secondary_keys,
        ))
      }
      #[doc = "Re-enables all secondary keys of the caller's identity."]
      #[cfg(feature = "ink")]
      pub fn unfreeze_secondary_keys(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![7u8, 9u8])
      }
      #[doc = "Adds an authorization."]
      #[cfg(not(feature = "ink"))]
      pub fn add_authorization(
        &self,
        target: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        data: types::polymesh_primitives::authorization::AuthorizationData<
          ::polymesh_api_client::AccountId,
        >,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::add_authorization {
            target,
            data,
            expiry,
          },
        ))
      }
      #[doc = "Adds an authorization."]
      #[cfg(feature = "ink")]
      pub fn add_authorization(
        &self,
        target: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        data: types::polymesh_primitives::authorization::AuthorizationData<
          ::polymesh_api_client::AccountId,
        >,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 10u8];
        target.encode_to(&mut buf);
        data.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes an authorization."]
      #[doc = "_auth_issuer_pays determines whether the issuer of the authorisation pays the transaction fee"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_authorization(
        &self,
        target: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        auth_id: u64,
        _auth_issuer_pays: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::remove_authorization {
            target,
            auth_id,
            _auth_issuer_pays,
          },
        ))
      }
      #[doc = "Removes an authorization."]
      #[doc = "_auth_issuer_pays determines whether the issuer of the authorisation pays the transaction fee"]
      #[cfg(feature = "ink")]
      pub fn remove_authorization(
        &self,
        target: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        auth_id: u64,
        _auth_issuer_pays: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 11u8];
        target.encode_to(&mut buf);
        auth_id.encode_to(&mut buf);
        _auth_issuer_pays.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Assuming this is executed by the GC voting majority, adds a new cdd claim record."]
      #[cfg(not(feature = "ink"))]
      pub fn gc_add_cdd_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::gc_add_cdd_claim { target },
        ))
      }
      #[doc = "Assuming this is executed by the GC voting majority, adds a new cdd claim record."]
      #[cfg(feature = "ink")]
      pub fn gc_add_cdd_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 12u8];
        target.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Assuming this is executed by the GC voting majority, removes an existing cdd claim record."]
      #[cfg(not(feature = "ink"))]
      pub fn gc_revoke_cdd_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::gc_revoke_cdd_claim { target },
        ))
      }
      #[doc = "Assuming this is executed by the GC voting majority, removes an existing cdd claim record."]
      #[cfg(feature = "ink")]
      pub fn gc_revoke_cdd_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 13u8];
        target.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`,"]
      #[doc = "`claim_type`, and `scope`."]
      #[doc = ""]
      #[doc = "Please note that `origin` must be the issuer of the target claim."]
      #[cfg(not(feature = "ink"))]
      pub fn revoke_claim_by_index(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim_type: types::polymesh_primitives::identity_claim::ClaimType,
        scope: Option<types::polymesh_primitives::identity_claim::Scope>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::revoke_claim_by_index {
            target,
            claim_type,
            scope,
          },
        ))
      }
      #[doc = "Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`,"]
      #[doc = "`claim_type`, and `scope`."]
      #[doc = ""]
      #[doc = "Please note that `origin` must be the issuer of the target claim."]
      #[cfg(feature = "ink")]
      pub fn revoke_claim_by_index(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim_type: types::polymesh_primitives::identity_claim::ClaimType,
        scope: Option<types::polymesh_primitives::identity_claim::Scope>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 14u8];
        target.encode_to(&mut buf);
        claim_type.encode_to(&mut buf);
        scope.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change, (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from accept_primary_key in that it will leave the old primary key as a secondary"]
      #[doc = "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization"]
      #[doc = "instead of unlinking the old primary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[cfg(not(feature = "ink"))]
      pub fn rotate_primary_key_to_secondary(
        &self,
        auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::rotate_primary_key_to_secondary {
            auth_id,
            optional_cdd_auth_id,
          },
        ))
      }
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change, (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from accept_primary_key in that it will leave the old primary key as a secondary"]
      #[doc = "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization"]
      #[doc = "instead of unlinking the old primary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[cfg(feature = "ink")]
      pub fn rotate_primary_key_to_secondary(
        &self,
        auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 15u8];
        auth_id.encode_to(&mut buf);
        optional_cdd_auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds secondary keys to target identity `id`."]
      #[doc = ""]
      #[doc = "Keys are directly added to identity because each of them has an authorization."]
      #[doc = ""]
      #[doc = "# Arguments:"]
      #[doc = "    - `origin` which must be the primary key of the identity `id`."]
      #[doc = "    - `id` to which new secondary keys will be added."]
      #[doc = "    - `additional_keys` which includes secondary keys,"]
      #[doc = "       coupled with authorization data, to add to target identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "    - Can only called by primary key owner."]
      #[doc = "    - Keys should be able to linked to any identity."]
      #[cfg(not(feature = "ink"))]
      pub fn add_secondary_keys_with_authorization(
        &self,
        additional_keys: ::alloc::vec::Vec<
          polymesh_primitives::identity::SecondaryKeyWithAuth<::polymesh_api_client::AccountId>,
        >,
        expires_at: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::add_secondary_keys_with_authorization {
            additional_keys,
            expires_at,
          },
        ))
      }
      #[doc = "Adds secondary keys to target identity `id`."]
      #[doc = ""]
      #[doc = "Keys are directly added to identity because each of them has an authorization."]
      #[doc = ""]
      #[doc = "# Arguments:"]
      #[doc = "    - `origin` which must be the primary key of the identity `id`."]
      #[doc = "    - `id` to which new secondary keys will be added."]
      #[doc = "    - `additional_keys` which includes secondary keys,"]
      #[doc = "       coupled with authorization data, to add to target identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "    - Can only called by primary key owner."]
      #[doc = "    - Keys should be able to linked to any identity."]
      #[cfg(feature = "ink")]
      pub fn add_secondary_keys_with_authorization(
        &self,
        additional_keys: ::alloc::vec::Vec<
          polymesh_primitives::identity::SecondaryKeyWithAuth<::polymesh_api_client::AccountId>,
        >,
        expires_at: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 16u8];
        additional_keys.encode_to(&mut buf);
        expires_at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets permissions for an specific `target_key` key."]
      #[doc = ""]
      #[doc = "Only the primary key of an identity is able to set secondary key permissions."]
      #[cfg(not(feature = "ink"))]
      pub fn set_secondary_key_permissions(
        &self,
        key: ::polymesh_api_client::AccountId,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::set_secondary_key_permissions { key, perms },
        ))
      }
      #[doc = "Sets permissions for an specific `target_key` key."]
      #[doc = ""]
      #[doc = "Only the primary key of an identity is able to set secondary key permissions."]
      #[cfg(feature = "ink")]
      pub fn set_secondary_key_permissions(
        &self,
        key: ::polymesh_api_client::AccountId,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 17u8];
        key.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes specified secondary keys of a DID if present."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[doc = "The extrinsic can only called by primary key owner."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_secondary_keys(
        &self,
        keys_to_remove: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::remove_secondary_keys { keys_to_remove },
        ))
      }
      #[doc = "Removes specified secondary keys of a DID if present."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[doc = "The extrinsic can only called by primary key owner."]
      #[cfg(feature = "ink")]
      pub fn remove_secondary_keys(
        &self,
        keys_to_remove: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 18u8];
        keys_to_remove.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Register custom claim type."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists."]
      #[doc = "* `CounterOverflow` CustomClaimTypeId has overflowed."]
      #[doc = "* `TooLong` The type being registered is too lang."]
      #[cfg(not(feature = "ink"))]
      pub fn register_custom_claim_type(
        &self,
        ty: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::register_custom_claim_type { ty },
        ))
      }
      #[doc = "Register custom claim type."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists."]
      #[doc = "* `CounterOverflow` CustomClaimTypeId has overflowed."]
      #[doc = "* `TooLong` The type being registered is too lang."]
      #[cfg(feature = "ink")]
      pub fn register_custom_claim_type(
        &self,
        ty: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 19u8];
        ty.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Register `target_account` with a new Identity and issue a CDD claim with a blank CddId"]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[cfg(not(feature = "ink"))]
      pub fn cdd_register_did_with_cdd(
        &self,
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::cdd_register_did_with_cdd {
            target_account,
            secondary_keys,
            expiry,
          },
        ))
      }
      #[doc = "Register `target_account` with a new Identity and issue a CDD claim with a blank CddId"]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[cfg(feature = "ink")]
      pub fn cdd_register_did_with_cdd(
        &self,
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 20u8];
        target_account.encode_to(&mut buf);
        secondary_keys.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Create a child identity and make the `secondary_key` it's primary key."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `secondary_key` the secondary key that will become the primary key of the new identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity."]
      #[doc = "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[cfg(not(feature = "ink"))]
      pub fn create_child_identity(
        &self,
        secondary_key: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::create_child_identity { secondary_key },
        ))
      }
      #[doc = "Create a child identity and make the `secondary_key` it's primary key."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `secondary_key` the secondary key that will become the primary key of the new identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity."]
      #[doc = "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[cfg(feature = "ink")]
      pub fn create_child_identity(
        &self,
        secondary_key: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 21u8];
        secondary_key.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Create a child identities."]
      #[doc = ""]
      #[doc = "The new primary key for each child identity will need to sign (off-chain)"]
      #[doc = "an authorization."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_keys` the keys that will become primary keys of their own child identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `AlreadyLinked` one of the keys is already linked to an identity."]
      #[doc = "- `DuplicateKey` one of the keys is included multiple times."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[cfg(not(feature = "ink"))]
      pub fn create_child_identities(
        &self,
        child_keys: ::alloc::vec::Vec<
          polymesh_primitives::identity::CreateChildIdentityWithAuth<
            ::polymesh_api_client::AccountId,
          >,
        >,
        expires_at: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::create_child_identities {
            child_keys,
            expires_at,
          },
        ))
      }
      #[doc = "Create a child identities."]
      #[doc = ""]
      #[doc = "The new primary key for each child identity will need to sign (off-chain)"]
      #[doc = "an authorization."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_keys` the keys that will become primary keys of their own child identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `AlreadyLinked` one of the keys is already linked to an identity."]
      #[doc = "- `DuplicateKey` one of the keys is included multiple times."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[cfg(feature = "ink")]
      pub fn create_child_identities(
        &self,
        child_keys: ::alloc::vec::Vec<
          polymesh_primitives::identity::CreateChildIdentityWithAuth<
            ::polymesh_api_client::AccountId,
          >,
        >,
        expires_at: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 22u8];
        child_keys.encode_to(&mut buf);
        expires_at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Unlink a child identity from it's parent identity."]
      #[doc = ""]
      #[doc = "Only the primary key of the parent or child identities can unlink the identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_did` the child identity to unlink from its parent identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities."]
      #[doc = "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity."]
      #[doc = "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity."]
      #[cfg(not(feature = "ink"))]
      pub fn unlink_child_identity(
        &self,
        child_did: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::unlink_child_identity { child_did },
        ))
      }
      #[doc = "Unlink a child identity from it's parent identity."]
      #[doc = ""]
      #[doc = "Only the primary key of the parent or child identities can unlink the identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_did` the child identity to unlink from its parent identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities."]
      #[doc = "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity."]
      #[doc = "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity."]
      #[cfg(feature = "ink")]
      pub fn unlink_child_identity(
        &self,
        child_did: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 23u8];
        child_did.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for IdentityCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct IdentityQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> IdentityQueryApi<'api> {
      #[doc = " DID -> identity info"]
      #[cfg(not(feature = "ink"))]
      pub async fn did_records(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity::DidRecord<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 116u8, 80u8, 50u8, 71u8, 155u8, 166u8, 193u8, 20u8, 243u8, 13u8, 15u8,
          187u8, 81u8, 210u8, 17u8, 101u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " DID -> identity info"]
      #[cfg(feature = "ink")]
      pub fn did_records(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity::DidRecord<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 116u8, 80u8, 50u8, 71u8, 155u8, 166u8, 193u8, 20u8, 243u8, 13u8, 15u8,
          187u8, 81u8, 210u8, 17u8, 101u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " DID -> bool that indicates if secondary keys are frozen."]
      #[cfg(not(feature = "ink"))]
      pub async fn is_did_frozen(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 88u8, 25u8, 37u8, 70u8, 145u8, 206u8, 174u8, 76u8, 55u8, 194u8, 155u8,
          126u8, 165u8, 90u8, 158u8, 251u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " DID -> bool that indicates if secondary keys are frozen."]
      #[cfg(feature = "ink")]
      pub fn is_did_frozen(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 88u8, 25u8, 37u8, 70u8, 145u8, 206u8, 174u8, 76u8, 55u8, 194u8, 155u8,
          126u8, 165u8, 90u8, 158u8, 251u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " It stores the current gas fee payer for the current transaction"]
      #[cfg(not(feature = "ink"))]
      pub async fn current_payer(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 223u8, 12u8, 177u8, 135u8, 158u8, 14u8, 195u8, 122u8, 19u8, 92u8,
          166u8, 91u8, 51u8, 74u8, 253u8, 115u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " It stores the current gas fee payer for the current transaction"]
      #[cfg(feature = "ink")]
      pub fn current_payer(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 223u8, 12u8, 177u8, 135u8, 158u8, 14u8, 195u8, 122u8, 19u8, 92u8,
          166u8, 91u8, 51u8, 74u8, 253u8, 115u8,
        ])?;
        Ok(value)
      }
      #[doc = " (Target ID, claim type) (issuer,scope) -> Associated claims"]
      #[cfg(not(feature = "ink"))]
      pub async fn claims(
        &self,
        key_0: types::pallet_identity::types::Claim1stKey,
        key_1: types::pallet_identity::types::Claim2ndKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity_claim::IdentityClaim>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 156u8, 93u8, 121u8, 93u8, 2u8, 151u8, 190u8, 86u8, 2u8, 122u8, 75u8,
          36u8, 100u8, 227u8, 51u8, 151u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " (Target ID, claim type) (issuer,scope) -> Associated claims"]
      #[cfg(feature = "ink")]
      pub fn claims(
        &self,
        key_0: types::pallet_identity::types::Claim1stKey,
        key_1: types::pallet_identity::types::Claim2ndKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity_claim::IdentityClaim>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 156u8, 93u8, 121u8, 93u8, 2u8, 151u8, 190u8, 86u8, 2u8, 122u8, 75u8,
          36u8, 100u8, 227u8, 51u8, 151u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " CustomClaimTypeId -> String constant"]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_claims(
        &self,
        key_0: types::polymesh_primitives::identity_claim::CustomClaimTypeId,
      ) -> ::polymesh_api_client::error::Result<Option<::alloc::vec::Vec<u8>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 191u8, 149u8, 69u8, 57u8, 187u8, 49u8, 56u8, 118u8, 117u8, 181u8,
          215u8, 96u8, 18u8, 206u8, 94u8, 232u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " CustomClaimTypeId -> String constant"]
      #[cfg(feature = "ink")]
      pub fn custom_claims(
        &self,
        key_0: types::polymesh_primitives::identity_claim::CustomClaimTypeId,
      ) -> ::polymesh_api_ink::error::Result<Option<::alloc::vec::Vec<u8>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 191u8, 149u8, 69u8, 57u8, 187u8, 49u8, 56u8, 118u8, 117u8, 181u8,
          215u8, 96u8, 18u8, 206u8, 94u8, 232u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " String constant -> CustomClaimTypeId"]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_claims_inverse(
        &self,
        key_0: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity_claim::CustomClaimTypeId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 238u8, 140u8, 175u8, 222u8, 16u8, 43u8, 89u8, 2u8, 60u8, 101u8, 161u8,
          89u8, 63u8, 155u8, 89u8, 216u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " String constant -> CustomClaimTypeId"]
      #[cfg(feature = "ink")]
      pub fn custom_claims_inverse(
        &self,
        key_0: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity_claim::CustomClaimTypeId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 238u8, 140u8, 175u8, 222u8, 16u8, 43u8, 89u8, 2u8, 60u8, 101u8, 161u8,
          89u8, 63u8, 155u8, 89u8, 216u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The next `CustomClaimTypeId`."]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_claim_id_sequence(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::identity_claim::CustomClaimTypeId,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 216u8, 67u8, 38u8, 124u8, 109u8, 145u8, 9u8, 206u8, 14u8, 87u8, 168u8,
          35u8, 237u8, 61u8, 102u8, 0u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::identity_claim::CustomClaimTypeId>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The next `CustomClaimTypeId`."]
      #[cfg(feature = "ink")]
      pub fn custom_claim_id_sequence(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::identity_claim::CustomClaimTypeId,
      > {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 216u8, 67u8, 38u8, 124u8, 109u8, 145u8, 9u8, 206u8, 14u8, 87u8, 168u8,
          35u8, 237u8, 61u8, 102u8, 0u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::identity_claim::CustomClaimTypeId>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Map from AccountId to `KeyRecord` that holds the key's type and identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn key_records(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::polymesh_primitives::secondary_key::KeyRecord<::polymesh_api_client::AccountId>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 140u8, 4u8, 71u8, 134u8, 27u8, 11u8, 130u8, 15u8, 11u8, 176u8, 222u8,
          164u8, 7u8, 164u8, 75u8, 52u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Map from AccountId to `KeyRecord` that holds the key's type and identity."]
      #[cfg(feature = "ink")]
      pub fn key_records(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::polymesh_primitives::secondary_key::KeyRecord<::polymesh_api_client::AccountId>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 140u8, 4u8, 71u8, 134u8, 27u8, 11u8, 130u8, 15u8, 11u8, 176u8, 222u8,
          164u8, 7u8, 164u8, 75u8, 52u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A secondary key's extrinsic permissions."]
      #[cfg(not(feature = "ink"))]
      pub async fn key_extrinsic_permissions(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::secondary_key::ExtrinsicPermissions>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 66u8, 215u8, 106u8, 150u8, 225u8, 217u8, 210u8, 44u8, 255u8, 38u8,
          187u8, 4u8, 9u8, 185u8, 157u8, 131u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A secondary key's extrinsic permissions."]
      #[cfg(feature = "ink")]
      pub fn key_extrinsic_permissions(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::secondary_key::ExtrinsicPermissions>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 66u8, 215u8, 106u8, 150u8, 225u8, 217u8, 210u8, 44u8, 255u8, 38u8,
          187u8, 4u8, 9u8, 185u8, 157u8, 131u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A secondary key's asset permissions."]
      #[cfg(not(feature = "ink"))]
      pub async fn key_asset_permissions(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::polymesh_primitives::subset::SubsetRestriction<::polymesh_api_client::AssetId>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 185u8, 144u8, 42u8, 124u8, 79u8, 75u8, 50u8, 231u8, 22u8, 182u8, 5u8,
          71u8, 190u8, 2u8, 122u8, 31u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A secondary key's asset permissions."]
      #[cfg(feature = "ink")]
      pub fn key_asset_permissions(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::polymesh_primitives::subset::SubsetRestriction<::polymesh_api_client::AssetId>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 185u8, 144u8, 42u8, 124u8, 79u8, 75u8, 50u8, 231u8, 22u8, 182u8, 5u8,
          71u8, 190u8, 2u8, 122u8, 31u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A secondary key's portfolio permissions."]
      #[cfg(not(feature = "ink"))]
      pub async fn key_portfolio_permissions(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::polymesh_primitives::subset::SubsetRestriction<
            types::polymesh_primitives::identity_id::PortfolioId,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 51u8, 17u8, 209u8, 116u8, 254u8, 60u8, 114u8, 180u8, 75u8, 236u8,
          206u8, 226u8, 14u8, 117u8, 212u8, 41u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A secondary key's portfolio permissions."]
      #[cfg(feature = "ink")]
      pub fn key_portfolio_permissions(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::polymesh_primitives::subset::SubsetRestriction<
            types::polymesh_primitives::identity_id::PortfolioId,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 51u8, 17u8, 209u8, 116u8, 254u8, 60u8, 114u8, 180u8, 75u8, 236u8,
          206u8, 226u8, 14u8, 117u8, 212u8, 41u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A reverse double map to allow finding all keys for an identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn did_keys(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 48u8, 201u8, 137u8, 112u8, 80u8, 239u8, 164u8, 12u8, 73u8, 173u8,
          249u8, 240u8, 185u8, 87u8, 20u8, 244u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A reverse double map to allow finding all keys for an identity."]
      #[cfg(feature = "ink")]
      pub fn did_keys(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 48u8, 201u8, 137u8, 112u8, 80u8, 239u8, 164u8, 12u8, 73u8, 173u8,
          249u8, 240u8, 185u8, 87u8, 20u8, 244u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Nonce to ensure unique actions. starts from 1."]
      #[cfg(not(feature = "ink"))]
      pub async fn multi_purpose_nonce(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 136u8, 63u8, 194u8, 107u8, 192u8, 198u8, 19u8, 83u8, 149u8, 2u8, 100u8,
          173u8, 112u8, 208u8, 112u8, 17u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Nonce to ensure unique actions. starts from 1."]
      #[cfg(feature = "ink")]
      pub fn multi_purpose_nonce(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 136u8, 63u8, 194u8, 107u8, 192u8, 198u8, 19u8, 83u8, 149u8, 2u8, 100u8,
          173u8, 112u8, 208u8, 112u8, 17u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Authorization nonce per Identity. Initially is 0."]
      #[cfg(not(feature = "ink"))]
      pub async fn off_chain_authorization_nonce(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 180u8, 43u8, 244u8, 108u8, 4u8, 166u8, 74u8, 143u8, 8u8, 226u8, 206u8,
          196u8, 229u8, 245u8, 62u8, 152u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Authorization nonce per Identity. Initially is 0."]
      #[cfg(feature = "ink")]
      pub fn off_chain_authorization_nonce(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 180u8, 43u8, 244u8, 108u8, 4u8, 166u8, 74u8, 143u8, 8u8, 226u8, 206u8,
          196u8, 229u8, 245u8, 62u8, 152u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All authorizations that an identity/key has"]
      #[cfg(not(feature = "ink"))]
      pub async fn authorizations(
        &self,
        key_0: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        key_1: u64,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::polymesh_primitives::authorization::Authorization<
            ::polymesh_api_client::AccountId,
            u64,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 104u8, 58u8, 80u8, 244u8, 170u8, 112u8, 186u8, 34u8, 193u8, 127u8,
          221u8, 184u8, 141u8, 38u8, 73u8, 43u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All authorizations that an identity/key has"]
      #[cfg(feature = "ink")]
      pub fn authorizations(
        &self,
        key_0: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        key_1: u64,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::polymesh_primitives::authorization::Authorization<
            ::polymesh_api_client::AccountId,
            u64,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 104u8, 58u8, 80u8, 244u8, 170u8, 112u8, 186u8, 34u8, 193u8, 127u8,
          221u8, 184u8, 141u8, 38u8, 73u8, 43u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " All authorizations that an identity has given. (Authorizer, auth_id -> authorized)"]
      #[cfg(not(feature = "ink"))]
      pub async fn authorizations_given(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: u64,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 31u8, 154u8, 92u8, 218u8, 166u8, 154u8, 225u8, 139u8, 48u8, 60u8,
          199u8, 128u8, 85u8, 224u8, 137u8, 110u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::secondary_key::Signatory<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " All authorizations that an identity has given. (Authorizer, auth_id -> authorized)"]
      #[cfg(feature = "ink")]
      pub fn authorizations_given(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: u64,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 31u8, 154u8, 92u8, 218u8, 166u8, 154u8, 225u8, 139u8, 48u8, 60u8,
          199u8, 128u8, 85u8, 224u8, 137u8, 110u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::secondary_key::Signatory<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " A config flag that, if set, instructs an authorization from a CDD provider in order to"]
      #[doc = " change the primary key of an identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn cdd_auth_for_primary_key_rotation(
        &self,
      ) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 114u8, 149u8, 136u8, 2u8, 121u8, 4u8, 72u8, 56u8, 19u8, 118u8, 139u8,
          92u8, 202u8, 32u8, 42u8, 41u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A config flag that, if set, instructs an authorization from a CDD provider in order to"]
      #[doc = " change the primary key of an identity."]
      #[cfg(feature = "ink")]
      pub fn cdd_auth_for_primary_key_rotation(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 114u8, 149u8, 136u8, 2u8, 121u8, 4u8, 72u8, 56u8, 19u8, 118u8, 139u8,
          92u8, 202u8, 32u8, 42u8, 41u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_identity::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_identity::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_identity::Version> {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_identity::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many \"strong\" references to the account key."]
      #[doc = ""]
      #[doc = " Strong references will block a key from leaving it's identity."]
      #[doc = ""]
      #[doc = " Pallets using \"strong\" references to account keys:"]
      #[doc = " * Relayer: For `user_key` and `paying_key`"]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub async fn account_key_ref_count(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 231u8, 18u8, 4u8, 202u8, 201u8, 201u8, 123u8, 37u8, 198u8, 89u8, 13u8,
          191u8, 196u8, 34u8, 200u8, 154u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many \"strong\" references to the account key."]
      #[doc = ""]
      #[doc = " Strong references will block a key from leaving it's identity."]
      #[doc = ""]
      #[doc = " Pallets using \"strong\" references to account keys:"]
      #[doc = " * Relayer: For `user_key` and `paying_key`"]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn account_key_ref_count(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 231u8, 18u8, 4u8, 202u8, 201u8, 201u8, 123u8, 37u8, 198u8, 89u8, 13u8,
          191u8, 196u8, 34u8, 200u8, 154u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Parent identity if the DID is a child Identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn parent_did(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 187u8, 179u8, 70u8, 131u8, 158u8, 200u8, 210u8, 30u8, 255u8, 150u8,
          252u8, 84u8, 192u8, 67u8, 126u8, 27u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Parent identity if the DID is a child Identity."]
      #[cfg(feature = "ink")]
      pub fn parent_did(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 187u8, 179u8, 70u8, 131u8, 158u8, 200u8, 210u8, 30u8, 255u8, 150u8,
          252u8, 84u8, 192u8, 67u8, 126u8, 27u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " All child identities of a parent (i.e ParentDID, ChildDID, true)"]
      #[cfg(not(feature = "ink"))]
      pub async fn child_did(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 220u8, 79u8, 118u8, 156u8, 85u8, 150u8, 146u8, 163u8, 144u8, 61u8,
          210u8, 112u8, 12u8, 48u8, 194u8, 208u8,
        ]);
        buf.extend(key_0.encode());
        buf.extend(key_1.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All child identities of a parent (i.e ParentDID, ChildDID, true)"]
      #[cfg(feature = "ink")]
      pub fn child_did(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 220u8, 79u8, 118u8, 156u8, 85u8, 150u8, 146u8, 163u8, 144u8, 61u8,
          210u8, 112u8, 12u8, 48u8, 194u8, 208u8,
        ]);
        buf.extend(key_0.encode());
        buf.extend(key_1.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Track the number of authorizations given by each identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn number_of_given_auths(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 101u8, 202u8, 103u8, 188u8, 53u8, 68u8, 42u8, 200u8, 90u8, 253u8,
          255u8, 123u8, 93u8, 99u8, 239u8, 174u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Track the number of authorizations given by each identity."]
      #[cfg(feature = "ink")]
      pub fn number_of_given_auths(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 101u8, 202u8, 103u8, 188u8, 53u8, 68u8, 42u8, 200u8, 90u8, 253u8,
          255u8, 123u8, 93u8, 99u8, 239u8, 174u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks all authorizations that must be deleted"]
      #[cfg(not(feature = "ink"))]
      pub async fn outdated_authorizations(
        &self,
        key_0: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
      ) -> ::polymesh_api_client::error::Result<Option<u64>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 254u8, 249u8, 229u8, 86u8, 138u8, 153u8, 19u8, 161u8, 120u8, 28u8,
          28u8, 44u8, 9u8, 135u8, 124u8, 227u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Tracks all authorizations that must be deleted"]
      #[cfg(feature = "ink")]
      pub fn outdated_authorizations(
        &self,
        key_0: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
      ) -> ::polymesh_api_ink::error::Result<Option<u64>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 254u8, 249u8, 229u8, 86u8, 138u8, 153u8, 19u8, 161u8, 120u8, 28u8,
          28u8, 44u8, 9u8, 135u8, 124u8, 227u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Controls the authorization id."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_auth_id(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 44u8, 229u8, 229u8, 139u8, 191u8, 99u8, 68u8, 254u8, 197u8, 173u8,
          240u8, 151u8, 160u8, 101u8, 208u8, 238u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Controls the authorization id."]
      #[cfg(feature = "ink")]
      pub fn current_auth_id(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 44u8, 229u8, 229u8, 139u8, 191u8, 99u8, 68u8, 254u8, 197u8, 173u8,
          240u8, 151u8, 160u8, 101u8, 208u8, 238u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct IdentityPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> IdentityPagedQueryApi<'api> {
      #[doc = " DID -> identity info"]
      pub fn did_records(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::IdentityId,
        types::polymesh_primitives::identity::DidRecord<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 116u8, 80u8, 50u8, 71u8, 155u8, 166u8, 193u8, 20u8, 243u8, 13u8, 15u8,
          187u8, 81u8, 210u8, 17u8, 101u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " DID -> bool that indicates if secondary keys are frozen."]
      pub fn is_did_frozen(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 88u8, 25u8, 37u8, 70u8, 145u8, 206u8, 174u8, 76u8, 55u8, 194u8, 155u8,
          126u8, 165u8, 90u8, 158u8, 251u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " (Target ID, claim type) (issuer,scope) -> Associated claims"]
      pub fn claims(
        &self,
        key_0: types::pallet_identity::types::Claim1stKey,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_identity::types::Claim2ndKey,
        types::polymesh_primitives::identity_claim::IdentityClaim,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 156u8, 93u8, 121u8, 93u8, 2u8, 151u8, 190u8, 86u8, 2u8, 122u8, 75u8,
          36u8, 100u8, 227u8, 51u8, 151u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " CustomClaimTypeId -> String constant"]
      pub fn custom_claims(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::identity_claim::CustomClaimTypeId,
        ::alloc::vec::Vec<u8>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 191u8, 149u8, 69u8, 57u8, 187u8, 49u8, 56u8, 118u8, 117u8, 181u8,
          215u8, 96u8, 18u8, 206u8, 94u8, 232u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " String constant -> CustomClaimTypeId"]
      pub fn custom_claims_inverse(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::alloc::vec::Vec<u8>,
        types::polymesh_primitives::identity_claim::CustomClaimTypeId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 238u8, 140u8, 175u8, 222u8, 16u8, 43u8, 89u8, 2u8, 60u8, 101u8, 161u8,
          89u8, 63u8, 155u8, 89u8, 216u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Map from AccountId to `KeyRecord` that holds the key's type and identity."]
      pub fn key_records(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::polymesh_primitives::secondary_key::KeyRecord<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 140u8, 4u8, 71u8, 134u8, 27u8, 11u8, 130u8, 15u8, 11u8, 176u8, 222u8,
          164u8, 7u8, 164u8, 75u8, 52u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " A secondary key's extrinsic permissions."]
      pub fn key_extrinsic_permissions(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 66u8, 215u8, 106u8, 150u8, 225u8, 217u8, 210u8, 44u8, 255u8, 38u8,
          187u8, 4u8, 9u8, 185u8, 157u8, 131u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " A secondary key's asset permissions."]
      pub fn key_asset_permissions(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::polymesh_primitives::subset::SubsetRestriction<::polymesh_api_client::AssetId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 185u8, 144u8, 42u8, 124u8, 79u8, 75u8, 50u8, 231u8, 22u8, 182u8, 5u8,
          71u8, 190u8, 2u8, 122u8, 31u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " A secondary key's portfolio permissions."]
      pub fn key_portfolio_permissions(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::polymesh_primitives::subset::SubsetRestriction<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 51u8, 17u8, 209u8, 116u8, 254u8, 60u8, 114u8, 180u8, 75u8, 236u8,
          206u8, 226u8, 14u8, 117u8, 212u8, 41u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " A reverse double map to allow finding all keys for an identity."]
      pub fn did_keys(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 48u8, 201u8, 137u8, 112u8, 80u8, 239u8, 164u8, 12u8, 73u8, 173u8,
          249u8, 240u8, 185u8, 87u8, 20u8, 244u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Authorization nonce per Identity. Initially is 0."]
      pub fn off_chain_authorization_nonce(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 180u8, 43u8, 244u8, 108u8, 4u8, 166u8, 74u8, 143u8, 8u8, 226u8, 206u8,
          196u8, 229u8, 245u8, 62u8, 152u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " All authorizations that an identity/key has"]
      pub fn authorizations(
        &self,
        key_0: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
      ) -> ::polymesh_api_client::StoragePaged<
        u64,
        types::polymesh_primitives::authorization::Authorization<
          ::polymesh_api_client::AccountId,
          u64,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 104u8, 58u8, 80u8, 244u8, 170u8, 112u8, 186u8, 34u8, 193u8, 127u8,
          221u8, 184u8, 141u8, 38u8, 73u8, 43u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " All authorizations that an identity has given. (Authorizer, auth_id -> authorized)"]
      pub fn authorizations_given(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<
        u64,
        types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 31u8, 154u8, 92u8, 218u8, 166u8, 154u8, 225u8, 139u8, 48u8, 60u8,
          199u8, 128u8, 85u8, 224u8, 137u8, 110u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " How many \"strong\" references to the account key."]
      #[doc = ""]
      #[doc = " Strong references will block a key from leaving it's identity."]
      #[doc = ""]
      #[doc = " Pallets using \"strong\" references to account keys:"]
      #[doc = " * Relayer: For `user_key` and `paying_key`"]
      #[doc = ""]
      pub fn account_key_ref_count(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 231u8, 18u8, 4u8, 202u8, 201u8, 201u8, 123u8, 37u8, 198u8, 89u8, 13u8,
          191u8, 196u8, 34u8, 200u8, 154u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Parent identity if the DID is a child Identity."]
      pub fn parent_did(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::IdentityId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 187u8, 179u8, 70u8, 131u8, 158u8, 200u8, 210u8, 30u8, 255u8, 150u8,
          252u8, 84u8, 192u8, 67u8, 126u8, 27u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " All child identities of a parent (i.e ParentDID, ChildDID, true)"]
      pub fn child_did(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 220u8, 79u8, 118u8, 156u8, 85u8, 150u8, 146u8, 163u8, 144u8, 61u8,
          210u8, 112u8, 12u8, 48u8, 194u8, 208u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " Track the number of authorizations given by each identity."]
      pub fn number_of_given_auths(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 101u8, 202u8, 103u8, 188u8, 53u8, 68u8, 42u8, 200u8, 90u8, 253u8,
          255u8, 123u8, 93u8, 99u8, 239u8, 174u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " Tracks all authorizations that must be deleted"]
      pub fn outdated_authorizations(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        u64,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 254u8, 249u8, 229u8, 86u8, 138u8, 153u8, 19u8, 161u8, 120u8, 28u8,
          28u8, 44u8, 9u8, 135u8, 124u8, 227u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
    }
  }
  pub mod cdd_service_providers {
    use super::*;
    #[derive(Clone)]
    pub struct CddServiceProvidersCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CddServiceProvidersCallApi<'api> {
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_members_limit(
        &self,
        limit: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::set_active_members_limit { limit },
          ))
      }
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(feature = "ink")]
      pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 0u8];
        limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(not(feature = "ink"))]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::disable_member { who, expiry, at },
          ))
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(feature = "ink")]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 1u8];
        who.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(not(feature = "ink"))]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::add_member { who },
          ))
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(feature = "ink")]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 2u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::remove_member { who },
          ))
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(feature = "ink")]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 3u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(not(feature = "ink"))]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::swap_member { remove, add },
          ))
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(feature = "ink")]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 4u8];
        remove.encode_to(&mut buf);
        add.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(not(feature = "ink"))]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::reset_members { members },
          ))
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(feature = "ink")]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 5u8];
        members.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(not(feature = "ink"))]
      pub fn abdicate_membership(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::abdicate_membership,
          ))
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(feature = "ink")]
      pub fn abdicate_membership(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![8u8, 6u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for CddServiceProvidersCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CddServiceProvidersQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CddServiceProvidersQueryApi<'api> {
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8,
          159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn active_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8,
          159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn inactive_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8,
          107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn inactive_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8,
          107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8,
          7u8, 124u8, 249u8, 110u8, 183u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(feature = "ink")]
      pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8,
          7u8, 124u8, 249u8, 110u8, 183u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct CddServiceProvidersPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> CddServiceProvidersPagedQueryApi<'api> {}
  }
  pub mod polymesh_committee {
    use super::*;
    #[derive(Clone)]
    pub struct PolymeshCommitteeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PolymeshCommitteeCallApi<'api> {
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(not(feature = "ink"))]
      pub fn set_vote_threshold(
        &self,
        n: u32,
        d: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_vote_threshold { n, d },
        ))
      }
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(feature = "ink")]
      pub fn set_vote_threshold(&self, n: u32, d: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![9u8, 0u8];
        n.encode_to(&mut buf);
        d.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(not(feature = "ink"))]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_release_coordinator { id },
        ))
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(feature = "ink")]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![9u8, 1u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(not(feature = "ink"))]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_expires_after { expiry },
        ))
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(feature = "ink")]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![9u8, 2u8];
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote_or_propose {
            approve,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![9u8, 3u8];
        approve.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote {
            proposal,
            index,
            approve,
          },
        ))
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![9u8, 4u8];
        proposal.encode_to(&mut buf);
        index.encode_to(&mut buf);
        approve.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for PolymeshCommitteeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PolymeshCommitteeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PolymeshCommitteeQueryApi<'api> {
      #[doc = " The hashes of the active proposals."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposals(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The hashes of the active proposals."]
      #[cfg(feature = "ink")]
      pub fn proposals(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(feature = "ink")]
      pub fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(not(feature = "ink"))]
      pub async fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(feature = "ink")]
      pub fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Proposals so far."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals so far."]
      #[cfg(feature = "ink")]
      pub fn proposal_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(not(feature = "ink"))]
      pub async fn members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(feature = "ink")]
      pub fn members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(not(feature = "ink"))]
      pub async fn vote_threshold(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(feature = "ink")]
      pub fn vote_threshold(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Release coordinator."]
      #[cfg(not(feature = "ink"))]
      pub async fn release_coordinator(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Release coordinator."]
      #[cfg(feature = "ink")]
      pub fn release_coordinator(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ])?;
        Ok(value)
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(not(feature = "ink"))]
      pub async fn expires_after(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(feature = "ink")]
      pub fn expires_after(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_committee::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_committee::Version> {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct PolymeshCommitteePagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> PolymeshCommitteePagedQueryApi<'api> {
      #[doc = " Actual proposal for a given hash."]
      pub fn proposal_of(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<types::primitive_types::H256, runtime::RuntimeCall>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      pub fn voting(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::primitive_types::H256,
        types::pallet_committee::PolymeshVotes<u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
    }
  }
  pub mod committee_membership {
    use super::*;
    #[derive(Clone)]
    pub struct CommitteeMembershipCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CommitteeMembershipCallApi<'api> {
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_members_limit(
        &self,
        limit: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::set_active_members_limit { limit },
          ))
      }
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(feature = "ink")]
      pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 0u8];
        limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(not(feature = "ink"))]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::disable_member { who, expiry, at },
          ))
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(feature = "ink")]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 1u8];
        who.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(not(feature = "ink"))]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::add_member { who },
          ))
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(feature = "ink")]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 2u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::remove_member { who },
          ))
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(feature = "ink")]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 3u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(not(feature = "ink"))]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::swap_member { remove, add },
          ))
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(feature = "ink")]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 4u8];
        remove.encode_to(&mut buf);
        add.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(not(feature = "ink"))]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::reset_members { members },
          ))
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(feature = "ink")]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 5u8];
        members.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(not(feature = "ink"))]
      pub fn abdicate_membership(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::abdicate_membership,
          ))
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(feature = "ink")]
      pub fn abdicate_membership(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![10u8, 6u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for CommitteeMembershipCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CommitteeMembershipQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CommitteeMembershipQueryApi<'api> {
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8,
          159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn active_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8,
          159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn inactive_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8,
          107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn inactive_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8,
          107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8,
          7u8, 124u8, 249u8, 110u8, 183u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(feature = "ink")]
      pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8,
          7u8, 124u8, 249u8, 110u8, 183u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct CommitteeMembershipPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> CommitteeMembershipPagedQueryApi<'api> {}
  }
  pub mod technical_committee {
    use super::*;
    #[derive(Clone)]
    pub struct TechnicalCommitteeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TechnicalCommitteeCallApi<'api> {
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(not(feature = "ink"))]
      pub fn set_vote_threshold(
        &self,
        n: u32,
        d: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_vote_threshold { n, d },
        ))
      }
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(feature = "ink")]
      pub fn set_vote_threshold(&self, n: u32, d: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![11u8, 0u8];
        n.encode_to(&mut buf);
        d.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(not(feature = "ink"))]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_release_coordinator { id },
        ))
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(feature = "ink")]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![11u8, 1u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(not(feature = "ink"))]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_expires_after { expiry },
        ))
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(feature = "ink")]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![11u8, 2u8];
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote_or_propose {
            approve,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![11u8, 3u8];
        approve.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote {
            proposal,
            index,
            approve,
          },
        ))
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![11u8, 4u8];
        proposal.encode_to(&mut buf);
        index.encode_to(&mut buf);
        approve.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for TechnicalCommitteeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TechnicalCommitteeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TechnicalCommitteeQueryApi<'api> {
      #[doc = " The hashes of the active proposals."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposals(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The hashes of the active proposals."]
      #[cfg(feature = "ink")]
      pub fn proposals(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(feature = "ink")]
      pub fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(not(feature = "ink"))]
      pub async fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(feature = "ink")]
      pub fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Proposals so far."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals so far."]
      #[cfg(feature = "ink")]
      pub fn proposal_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(not(feature = "ink"))]
      pub async fn members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(feature = "ink")]
      pub fn members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(not(feature = "ink"))]
      pub async fn vote_threshold(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(feature = "ink")]
      pub fn vote_threshold(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Release coordinator."]
      #[cfg(not(feature = "ink"))]
      pub async fn release_coordinator(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Release coordinator."]
      #[cfg(feature = "ink")]
      pub fn release_coordinator(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ])?;
        Ok(value)
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(not(feature = "ink"))]
      pub async fn expires_after(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(feature = "ink")]
      pub fn expires_after(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_committee::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_committee::Version> {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct TechnicalCommitteePagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> TechnicalCommitteePagedQueryApi<'api> {
      #[doc = " Actual proposal for a given hash."]
      pub fn proposal_of(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<types::primitive_types::H256, runtime::RuntimeCall>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      pub fn voting(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::primitive_types::H256,
        types::pallet_committee::PolymeshVotes<u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
    }
  }
  pub mod technical_committee_membership {
    use super::*;
    #[derive(Clone)]
    pub struct TechnicalCommitteeMembershipCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TechnicalCommitteeMembershipCallApi<'api> {
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_members_limit(
        &self,
        limit: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::set_active_members_limit { limit },
          ))
      }
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(feature = "ink")]
      pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 0u8];
        limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(not(feature = "ink"))]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::disable_member { who, expiry, at },
          ))
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(feature = "ink")]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 1u8];
        who.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(not(feature = "ink"))]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::add_member { who },
          ))
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(feature = "ink")]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 2u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::remove_member { who },
          ))
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(feature = "ink")]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 3u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(not(feature = "ink"))]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::swap_member { remove, add },
          ))
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(feature = "ink")]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 4u8];
        remove.encode_to(&mut buf);
        add.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(not(feature = "ink"))]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::reset_members { members },
          ))
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(feature = "ink")]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 5u8];
        members.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(not(feature = "ink"))]
      pub fn abdicate_membership(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::abdicate_membership,
          ))
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(feature = "ink")]
      pub fn abdicate_membership(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![12u8, 6u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for TechnicalCommitteeMembershipCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TechnicalCommitteeMembershipQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TechnicalCommitteeMembershipQueryApi<'api> {
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8, 159u8,
          240u8, 162u8, 26u8, 38u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn active_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8, 159u8,
          240u8, 162u8, 26u8, 38u8, 76u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn inactive_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8, 107u8, 3u8,
          94u8, 145u8, 7u8, 20u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn inactive_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8, 107u8, 3u8,
          94u8, 145u8, 7u8, 20u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8, 7u8,
          124u8, 249u8, 110u8, 183u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(feature = "ink")]
      pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8, 7u8,
          124u8, 249u8, 110u8, 183u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct TechnicalCommitteeMembershipPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> TechnicalCommitteeMembershipPagedQueryApi<'api> {}
  }
  pub mod upgrade_committee {
    use super::*;
    #[derive(Clone)]
    pub struct UpgradeCommitteeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> UpgradeCommitteeCallApi<'api> {
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(not(feature = "ink"))]
      pub fn set_vote_threshold(
        &self,
        n: u32,
        d: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_vote_threshold { n, d },
        ))
      }
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(feature = "ink")]
      pub fn set_vote_threshold(&self, n: u32, d: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![13u8, 0u8];
        n.encode_to(&mut buf);
        d.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(not(feature = "ink"))]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_release_coordinator { id },
        ))
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(feature = "ink")]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![13u8, 1u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(not(feature = "ink"))]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_expires_after { expiry },
        ))
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(feature = "ink")]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![13u8, 2u8];
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote_or_propose {
            approve,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![13u8, 3u8];
        approve.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote {
            proposal,
            index,
            approve,
          },
        ))
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![13u8, 4u8];
        proposal.encode_to(&mut buf);
        index.encode_to(&mut buf);
        approve.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for UpgradeCommitteeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct UpgradeCommitteeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> UpgradeCommitteeQueryApi<'api> {
      #[doc = " The hashes of the active proposals."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposals(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The hashes of the active proposals."]
      #[cfg(feature = "ink")]
      pub fn proposals(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(feature = "ink")]
      pub fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(not(feature = "ink"))]
      pub async fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(feature = "ink")]
      pub fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Proposals so far."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals so far."]
      #[cfg(feature = "ink")]
      pub fn proposal_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(not(feature = "ink"))]
      pub async fn members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(feature = "ink")]
      pub fn members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(not(feature = "ink"))]
      pub async fn vote_threshold(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(feature = "ink")]
      pub fn vote_threshold(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Release coordinator."]
      #[cfg(not(feature = "ink"))]
      pub async fn release_coordinator(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Release coordinator."]
      #[cfg(feature = "ink")]
      pub fn release_coordinator(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ])?;
        Ok(value)
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(not(feature = "ink"))]
      pub async fn expires_after(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(feature = "ink")]
      pub fn expires_after(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_committee::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_committee::Version> {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct UpgradeCommitteePagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> UpgradeCommitteePagedQueryApi<'api> {
      #[doc = " Actual proposal for a given hash."]
      pub fn proposal_of(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<types::primitive_types::H256, runtime::RuntimeCall>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      pub fn voting(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::primitive_types::H256,
        types::pallet_committee::PolymeshVotes<u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
    }
  }
  pub mod upgrade_committee_membership {
    use super::*;
    #[derive(Clone)]
    pub struct UpgradeCommitteeMembershipCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> UpgradeCommitteeMembershipCallApi<'api> {
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_members_limit(
        &self,
        limit: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::set_active_members_limit { limit },
          ))
      }
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(feature = "ink")]
      pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 0u8];
        limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(not(feature = "ink"))]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::disable_member { who, expiry, at },
          ))
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(feature = "ink")]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 1u8];
        who.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(not(feature = "ink"))]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::add_member { who },
          ))
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(feature = "ink")]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 2u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::remove_member { who },
          ))
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(feature = "ink")]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 3u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(not(feature = "ink"))]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::swap_member { remove, add },
          ))
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(feature = "ink")]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 4u8];
        remove.encode_to(&mut buf);
        add.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(not(feature = "ink"))]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::reset_members { members },
          ))
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(feature = "ink")]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 5u8];
        members.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(not(feature = "ink"))]
      pub fn abdicate_membership(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::abdicate_membership,
          ))
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(feature = "ink")]
      pub fn abdicate_membership(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![14u8, 6u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for UpgradeCommitteeMembershipCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct UpgradeCommitteeMembershipQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> UpgradeCommitteeMembershipQueryApi<'api> {
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8, 159u8,
          240u8, 162u8, 26u8, 38u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn active_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8, 159u8,
          240u8, 162u8, 26u8, 38u8, 76u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn inactive_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8, 107u8,
          3u8, 94u8, 145u8, 7u8, 20u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn inactive_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8, 107u8,
          3u8, 94u8, 145u8, 7u8, 20u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<polymesh_primitives::group::InactiveMember<u64>>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8, 7u8,
          124u8, 249u8, 110u8, 183u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(feature = "ink")]
      pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8, 7u8,
          124u8, 249u8, 110u8, 183u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct UpgradeCommitteeMembershipPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> UpgradeCommitteeMembershipPagedQueryApi<'api> {}
  }
  pub mod multi_sig {
    use super::*;
    #[derive(Clone)]
    pub struct MultiSigCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> MultiSigCallApi<'api> {
      #[doc = "Creates a multisig"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)."]
      #[doc = "* `sigs_required` - Number of sigs required to process a multi-sig tx."]
      #[doc = "* `permissions` - optional custom permissions.  Only the primary key can provide custom permissions."]
      #[cfg(not(feature = "ink"))]
      pub fn create_multisig(
        &self,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        sigs_required: u64,
        permissions: Option<types::polymesh_primitives::secondary_key::Permissions>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::create_multisig {
            signers,
            sigs_required,
            permissions,
          },
        ))
      }
      #[doc = "Creates a multisig"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)."]
      #[doc = "* `sigs_required` - Number of sigs required to process a multi-sig tx."]
      #[doc = "* `permissions` - optional custom permissions.  Only the primary key can provide custom permissions."]
      #[cfg(feature = "ink")]
      pub fn create_multisig(
        &self,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        sigs_required: u64,
        permissions: Option<types::polymesh_primitives::secondary_key::Permissions>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 0u8];
        signers.encode_to(&mut buf);
        sigs_required.encode_to(&mut buf);
        permissions.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Creates a multisig proposal"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = ""]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn create_proposal(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal: runtime::RuntimeCall,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::create_proposal {
            multisig,
            proposal: ::alloc::boxed::Box::new(proposal),
            expiry,
          },
        ))
      }
      #[doc = "Creates a multisig proposal"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = ""]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn create_proposal(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal: runtime::RuntimeCall,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 1u8];
        multisig.encode_to(&mut buf);
        proposal.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Approves a multisig proposal using the caller's secondary key (`AccountId`)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to approve."]
      #[doc = "* `max_weight` - The maximum weight to execute the proposal."]
      #[doc = ""]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn approve(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
        max_weight: Option<::polymesh_api_client::sp_weights::Weight>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::approve {
            multisig,
            proposal_id,
            max_weight,
          },
        ))
      }
      #[doc = "Approves a multisig proposal using the caller's secondary key (`AccountId`)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to approve."]
      #[doc = "* `max_weight` - The maximum weight to execute the proposal."]
      #[doc = ""]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn approve(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
        max_weight: Option<::polymesh_api_client::sp_weights::Weight>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 2u8];
        multisig.encode_to(&mut buf);
        proposal_id.encode_to(&mut buf);
        max_weight.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rejects a multisig proposal using the caller's secondary key (`AccountId`)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to reject."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn reject(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::reject {
            multisig,
            proposal_id,
          },
        ))
      }
      #[doc = "Rejects a multisig proposal using the caller's secondary key (`AccountId`)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to reject."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn reject(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 3u8];
        multisig.encode_to(&mut buf);
        proposal_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accepts a multisig signer authorization given to signer's key (AccountId)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_id` - Auth id of the authorization."]
      #[cfg(not(feature = "ink"))]
      pub fn accept_multisig_signer(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::accept_multisig_signer { auth_id },
        ))
      }
      #[doc = "Accepts a multisig signer authorization given to signer's key (AccountId)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_id` - Auth id of the authorization."]
      #[cfg(feature = "ink")]
      pub fn accept_multisig_signer(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 4u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds signers to the multisig.  This must be called by the multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signers` - Signers to add."]
      #[cfg(not(feature = "ink"))]
      pub fn add_multisig_signers(
        &self,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::add_multisig_signers { signers },
        ))
      }
      #[doc = "Adds signers to the multisig.  This must be called by the multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signers` - Signers to add."]
      #[cfg(feature = "ink")]
      pub fn add_multisig_signers(
        &self,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 5u8];
        signers.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes signers from the multisig.  This must be called by the multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signers` - Signers to remove."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_multisig_signers(
        &self,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::remove_multisig_signers { signers },
        ))
      }
      #[doc = "Removes signers from the multisig.  This must be called by the multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signers` - Signers to remove."]
      #[cfg(feature = "ink")]
      pub fn remove_multisig_signers(
        &self,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 6u8];
        signers.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a signer to the multisig.  This must be called by the admin identity of the"]
      #[doc = "multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - Address of the multi sig"]
      #[doc = "* `signers` - Signers to add."]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub fn add_multisig_signers_via_admin(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::add_multisig_signers_via_admin {
            multisig,
            signers,
          },
        ))
      }
      #[doc = "Adds a signer to the multisig.  This must be called by the admin identity of the"]
      #[doc = "multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - Address of the multi sig"]
      #[doc = "* `signers` - Signers to add."]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn add_multisig_signers_via_admin(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 7u8];
        multisig.encode_to(&mut buf);
        signers.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a signer from the multisig."]
      #[doc = "This must be called by the admin identity of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - Address of the multisig."]
      #[doc = "* `signers` - Signers to remove."]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub fn remove_multisig_signers_via_admin(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::remove_multisig_signers_via_admin {
            multisig,
            signers,
          },
        ))
      }
      #[doc = "Removes a signer from the multisig."]
      #[doc = "This must be called by the admin identity of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - Address of the multisig."]
      #[doc = "* `signers` - Signers to remove."]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn remove_multisig_signers_via_admin(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 8u8];
        multisig.encode_to(&mut buf);
        signers.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the number of signatures required by a multisig.  This must be called by the"]
      #[doc = "multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `sigs_required` - New number of required signatures."]
      #[cfg(not(feature = "ink"))]
      pub fn change_sigs_required(
        &self,
        sigs_required: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::change_sigs_required { sigs_required },
        ))
      }
      #[doc = "Changes the number of signatures required by a multisig.  This must be called by the"]
      #[doc = "multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `sigs_required` - New number of required signatures."]
      #[cfg(feature = "ink")]
      pub fn change_sigs_required(&self, sigs_required: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 9u8];
        sigs_required.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the number of signatures required by a multisig.  This must be called by the admin of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - The account identifier ([`AccountId`]) for the multi signature account."]
      #[doc = "* `signatures_required` - The number of required signatures."]
      #[cfg(not(feature = "ink"))]
      pub fn change_sigs_required_via_admin(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        signatures_required: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::change_sigs_required_via_admin {
            multisig,
            signatures_required,
          },
        ))
      }
      #[doc = "Changes the number of signatures required by a multisig.  This must be called by the admin of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - The account identifier ([`AccountId`]) for the multi signature account."]
      #[doc = "* `signatures_required` - The number of required signatures."]
      #[cfg(feature = "ink")]
      pub fn change_sigs_required_via_admin(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        signatures_required: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 10u8];
        multisig.encode_to(&mut buf);
        signatures_required.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Add an admin identity to the multisig.  This must be called by the multisig itself."]
      #[cfg(not(feature = "ink"))]
      pub fn add_admin(
        &self,
        admin_did: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::add_admin { admin_did },
        ))
      }
      #[doc = "Add an admin identity to the multisig.  This must be called by the multisig itself."]
      #[cfg(feature = "ink")]
      pub fn add_admin(
        &self,
        admin_did: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 11u8];
        admin_did.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the admin identity from the `multisig`.  This must be called by the admin of the multisig."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_admin_via_admin(
        &self,
        multisig: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::remove_admin_via_admin { multisig },
        ))
      }
      #[doc = "Removes the admin identity from the `multisig`.  This must be called by the admin of the multisig."]
      #[cfg(feature = "ink")]
      pub fn remove_admin_via_admin(
        &self,
        multisig: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 12u8];
        multisig.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the paying identity from the `multisig`.  This must be called by the multisig itself."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_payer(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::remove_payer,
        ))
      }
      #[doc = "Removes the paying identity from the `multisig`.  This must be called by the multisig itself."]
      #[cfg(feature = "ink")]
      pub fn remove_payer(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![15u8, 13u8])
      }
      #[doc = "Removes the paying identity from the `multisig`.  This must be called by the paying identity of the multisig."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_payer_via_payer(
        &self,
        multisig: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::remove_payer_via_payer { multisig },
        ))
      }
      #[doc = "Removes the paying identity from the `multisig`.  This must be called by the paying identity of the multisig."]
      #[cfg(feature = "ink")]
      pub fn remove_payer_via_payer(
        &self,
        multisig: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 14u8];
        multisig.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Approves a multisig join identity proposal."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `auth_id` - The join identity authorization to approve."]
      #[doc = ""]
      #[doc = "If quorum is reached, the join identity proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn approve_join_identity(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::approve_join_identity { multisig, auth_id },
        ))
      }
      #[doc = "Approves a multisig join identity proposal."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `auth_id` - The join identity authorization to approve."]
      #[doc = ""]
      #[doc = "If quorum is reached, the join identity proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn approve_join_identity(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        auth_id: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 15u8];
        multisig.encode_to(&mut buf);
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accept a JoinIdentity authorization for this multisig.  This must be called by the multisig itself."]
      #[cfg(not(feature = "ink"))]
      pub fn join_identity(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::join_identity { auth_id },
        ))
      }
      #[doc = "Accept a JoinIdentity authorization for this multisig.  This must be called by the multisig itself."]
      #[cfg(feature = "ink")]
      pub fn join_identity(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 16u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the admin identity from the `multisig`.  This must be called by the multisig itself."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_admin(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::pallet::MultiSigCall::remove_admin,
        ))
      }
      #[doc = "Removes the admin identity from the `multisig`.  This must be called by the multisig itself."]
      #[cfg(feature = "ink")]
      pub fn remove_admin(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![15u8, 17u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for MultiSigCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct MultiSigQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> MultiSigQueryApi<'api> {
      #[doc = " Nonce to ensure unique MultiSig addresses are generated; starts from 1."]
      #[cfg(not(feature = "ink"))]
      pub async fn multi_sig_nonce(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 10u8, 14u8, 167u8, 96u8, 87u8, 167u8, 154u8, 118u8, 104u8, 172u8,
          98u8, 216u8, 200u8, 251u8, 224u8, 34u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Nonce to ensure unique MultiSig addresses are generated; starts from 1."]
      #[cfg(feature = "ink")]
      pub fn multi_sig_nonce(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 10u8, 14u8, 167u8, 96u8, 87u8, 167u8, 154u8, 118u8, 104u8, 172u8,
          98u8, 216u8, 200u8, 251u8, 224u8, 34u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Signers of a multisig. (multisig, signer) => bool."]
      #[cfg(not(feature = "ink"))]
      pub async fn multi_sig_signers(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 87u8, 55u8, 48u8, 162u8, 27u8, 187u8, 140u8, 140u8, 243u8, 200u8,
          51u8, 112u8, 105u8, 135u8, 190u8, 191u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Signers of a multisig. (multisig, signer) => bool."]
      #[cfg(feature = "ink")]
      pub fn multi_sig_signers(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 87u8, 55u8, 48u8, 162u8, 27u8, 187u8, 140u8, 140u8, 243u8, 200u8,
          51u8, 112u8, 105u8, 135u8, 190u8, 191u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of approved/accepted signers of a multisig."]
      #[cfg(not(feature = "ink"))]
      pub async fn number_of_signers(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 71u8, 130u8, 22u8, 60u8, 187u8, 185u8, 53u8, 64u8, 248u8, 2u8, 20u8,
          216u8, 127u8, 68u8, 253u8, 226u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of approved/accepted signers of a multisig."]
      #[cfg(feature = "ink")]
      pub fn number_of_signers(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 71u8, 130u8, 22u8, 60u8, 187u8, 185u8, 53u8, 64u8, 248u8, 2u8, 20u8,
          216u8, 127u8, 68u8, 253u8, 226u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Confirmations required before processing a multisig tx."]
      #[cfg(not(feature = "ink"))]
      pub async fn multi_sig_signs_required(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 186u8, 252u8, 143u8, 56u8, 160u8, 191u8, 27u8, 28u8, 14u8, 157u8,
          223u8, 36u8, 138u8, 28u8, 207u8, 150u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Confirmations required before processing a multisig tx."]
      #[cfg(feature = "ink")]
      pub fn multi_sig_signs_required(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 186u8, 252u8, 143u8, 56u8, 160u8, 191u8, 27u8, 28u8, 14u8, 157u8,
          223u8, 36u8, 138u8, 28u8, 207u8, 150u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Next proposal id for a multisig.  Starts from 0."]
      #[doc = ""]
      #[doc = " multisig => next proposal id"]
      #[cfg(not(feature = "ink"))]
      pub async fn next_proposal_id(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 47u8, 88u8, 243u8, 11u8, 97u8, 166u8, 255u8, 46u8, 140u8, 116u8, 75u8,
          1u8, 215u8, 36u8, 158u8, 12u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Next proposal id for a multisig.  Starts from 0."]
      #[doc = ""]
      #[doc = " multisig => next proposal id"]
      #[cfg(feature = "ink")]
      pub fn next_proposal_id(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 47u8, 88u8, 243u8, 11u8, 97u8, 166u8, 255u8, 46u8, 140u8, 116u8, 75u8,
          1u8, 215u8, 36u8, 158u8, 12u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals presented for voting to a multisig."]
      #[doc = ""]
      #[doc = " multisig -> proposal id => Option<Proposal>."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposals(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Proposals presented for voting to a multisig."]
      #[doc = ""]
      #[doc = " multisig -> proposal id => Option<Proposal>."]
      #[cfg(feature = "ink")]
      pub fn proposals(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Individual multisig signer votes."]
      #[doc = ""]
      #[doc = " (multisig, proposal_id) -> signer => vote."]
      #[cfg(not(feature = "ink"))]
      pub async fn votes(
        &self,
        key_0: (::polymesh_api_client::AccountId, u64),
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8, 230u8, 150u8,
          237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Individual multisig signer votes."]
      #[doc = ""]
      #[doc = " (multisig, proposal_id) -> signer => vote."]
      #[cfg(feature = "ink")]
      pub fn votes(
        &self,
        key_0: (::polymesh_api_client::AccountId, u64),
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8, 230u8, 150u8,
          237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The multisig's paying identity.  The primary key of this identity"]
      #[doc = " pays the transaction/protocal fees of the multisig proposals."]
      #[doc = ""]
      #[doc = " multisig -> Option<IdentityId>."]
      #[cfg(not(feature = "ink"))]
      pub async fn paying_did(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 37u8, 34u8, 79u8, 180u8, 97u8, 160u8, 185u8, 177u8, 98u8, 104u8,
          127u8, 6u8, 92u8, 57u8, 212u8, 208u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The multisig's paying identity.  The primary key of this identity"]
      #[doc = " pays the transaction/protocal fees of the multisig proposals."]
      #[doc = ""]
      #[doc = " multisig -> Option<IdentityId>."]
      #[cfg(feature = "ink")]
      pub fn paying_did(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 37u8, 34u8, 79u8, 180u8, 97u8, 160u8, 185u8, 177u8, 98u8, 104u8,
          127u8, 6u8, 92u8, 57u8, 212u8, 208u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The multisig's admin identity.  The primary key of this identity"]
      #[doc = " has admin control over the multisig."]
      #[doc = ""]
      #[doc = " multisig -> Option<IdentityId>."]
      #[cfg(not(feature = "ink"))]
      pub async fn admin_did(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 58u8, 32u8, 242u8, 176u8, 113u8, 123u8, 137u8, 45u8, 241u8, 118u8,
          159u8, 124u8, 101u8, 106u8, 164u8, 65u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The multisig's admin identity.  The primary key of this identity"]
      #[doc = " has admin control over the multisig."]
      #[doc = ""]
      #[doc = " multisig -> Option<IdentityId>."]
      #[cfg(feature = "ink")]
      pub fn admin_did(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 58u8, 32u8, 242u8, 176u8, 113u8, 123u8, 137u8, 45u8, 241u8, 118u8,
          159u8, 124u8, 101u8, 106u8, 164u8, 65u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The count of approvals/rejections of a multisig proposal."]
      #[doc = ""]
      #[doc = " multisig -> proposal id => Option<ProposalVoteCount>."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_vote_counts(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::multisig::ProposalVoteCount>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 22u8, 28u8, 219u8, 127u8, 2u8, 196u8, 199u8, 111u8, 96u8, 96u8, 228u8,
          243u8, 137u8, 34u8, 97u8, 245u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The count of approvals/rejections of a multisig proposal."]
      #[doc = ""]
      #[doc = " multisig -> proposal id => Option<ProposalVoteCount>."]
      #[cfg(feature = "ink")]
      pub fn proposal_vote_counts(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::multisig::ProposalVoteCount>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 22u8, 28u8, 219u8, 127u8, 2u8, 196u8, 199u8, 111u8, 96u8, 96u8, 228u8,
          243u8, 137u8, 34u8, 97u8, 245u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The state of a multisig proposal"]
      #[doc = ""]
      #[doc = " multisig -> proposal id => Option<ProposalState>."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_states(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::multisig::ProposalState<u64>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8, 102u8, 151u8, 171u8, 71u8,
          106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The state of a multisig proposal"]
      #[doc = ""]
      #[doc = " multisig -> proposal id => Option<ProposalState>."]
      #[cfg(feature = "ink")]
      pub fn proposal_states(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::multisig::ProposalState<u64>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8, 102u8, 151u8, 171u8, 71u8,
          106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Proposal execution reentry guard."]
      #[cfg(not(feature = "ink"))]
      pub async fn execution_reentry(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 34u8, 8u8, 200u8, 58u8, 222u8, 75u8, 189u8, 75u8, 236u8, 60u8, 63u8,
          61u8, 162u8, 33u8, 164u8, 101u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposal execution reentry guard."]
      #[cfg(feature = "ink")]
      pub fn execution_reentry(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 34u8, 8u8, 200u8, 58u8, 222u8, 75u8, 189u8, 75u8, 236u8, 60u8, 63u8,
          61u8, 162u8, 33u8, 164u8, 101u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Pending join identity authorization proposals."]
      #[doc = ""]
      #[doc = " multisig -> auth id => Option<proposal id>."]
      #[cfg(not(feature = "ink"))]
      pub async fn auth_to_proposal_id(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_client::error::Result<Option<u64>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 35u8, 107u8, 174u8, 151u8, 167u8, 187u8, 232u8, 180u8, 151u8, 93u8,
          165u8, 155u8, 96u8, 132u8, 198u8, 82u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Pending join identity authorization proposals."]
      #[doc = ""]
      #[doc = " multisig -> auth id => Option<proposal id>."]
      #[cfg(feature = "ink")]
      pub fn auth_to_proposal_id(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_ink::error::Result<Option<u64>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 35u8, 107u8, 174u8, 151u8, 167u8, 187u8, 232u8, 180u8, 151u8, 93u8,
          165u8, 155u8, 96u8, 132u8, 198u8, 82u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The last transaction version, used for `on_runtime_upgrade`."]
      #[cfg(not(feature = "ink"))]
      pub async fn transaction_version(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 136u8, 215u8, 103u8, 226u8, 158u8, 158u8, 152u8, 49u8, 187u8, 71u8,
          177u8, 173u8, 103u8, 53u8, 72u8, 253u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The last transaction version, used for `on_runtime_upgrade`."]
      #[cfg(feature = "ink")]
      pub fn transaction_version(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 136u8, 215u8, 103u8, 226u8, 158u8, 158u8, 152u8, 49u8, 187u8, 71u8,
          177u8, 173u8, 103u8, 53u8, 72u8, 253u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The last proposal id before the multisig changed signers or signatures required."]
      #[doc = ""]
      #[doc = " multisig => Option<proposal id>"]
      #[cfg(not(feature = "ink"))]
      pub async fn last_invalid_proposal(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<u64>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 20u8, 113u8, 107u8, 81u8, 124u8, 171u8, 163u8, 17u8, 16u8, 5u8, 74u8,
          236u8, 90u8, 228u8, 71u8, 111u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The last proposal id before the multisig changed signers or signatures required."]
      #[doc = ""]
      #[doc = " multisig => Option<proposal id>"]
      #[cfg(feature = "ink")]
      pub fn last_invalid_proposal(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<u64>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 20u8, 113u8, 107u8, 81u8, 124u8, 171u8, 163u8, 17u8, 16u8, 5u8, 74u8,
          236u8, 90u8, 228u8, 71u8, 111u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_multisig::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_multisig::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_multisig::Version> {
        let value = self.api.read_storage(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_multisig::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct MultiSigPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> MultiSigPagedQueryApi<'api> {
      #[doc = " Signers of a multisig. (multisig, signer) => bool."]
      pub fn multi_sig_signers(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 87u8, 55u8, 48u8, 162u8, 27u8, 187u8, 140u8, 140u8, 243u8, 200u8,
          51u8, 112u8, 105u8, 135u8, 190u8, 191u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Number of approved/accepted signers of a multisig."]
      pub fn number_of_signers(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 71u8, 130u8, 22u8, 60u8, 187u8, 185u8, 53u8, 64u8, 248u8, 2u8, 20u8,
          216u8, 127u8, 68u8, 253u8, 226u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " Confirmations required before processing a multisig tx."]
      pub fn multi_sig_signs_required(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 186u8, 252u8, 143u8, 56u8, 160u8, 191u8, 27u8, 28u8, 14u8, 157u8,
          223u8, 36u8, 138u8, 28u8, 207u8, 150u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " Next proposal id for a multisig.  Starts from 0."]
      #[doc = ""]
      #[doc = " multisig => next proposal id"]
      pub fn next_proposal_id(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 47u8, 88u8, 243u8, 11u8, 97u8, 166u8, 255u8, 46u8, 140u8, 116u8, 75u8,
          1u8, 215u8, 36u8, 158u8, 12u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " Proposals presented for voting to a multisig."]
      #[doc = ""]
      #[doc = " multisig -> proposal id => Option<Proposal>."]
      pub fn proposals(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::StoragePaged<u64, runtime::RuntimeCall> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Individual multisig signer votes."]
      #[doc = ""]
      #[doc = " (multisig, proposal_id) -> signer => vote."]
      pub fn votes(
        &self,
        key_0: (::polymesh_api_client::AccountId, u64),
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8, 230u8, 150u8,
          237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The multisig's paying identity.  The primary key of this identity"]
      #[doc = " pays the transaction/protocal fees of the multisig proposals."]
      #[doc = ""]
      #[doc = " multisig -> Option<IdentityId>."]
      pub fn paying_did(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        ::polymesh_api_client::IdentityId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 37u8, 34u8, 79u8, 180u8, 97u8, 160u8, 185u8, 177u8, 98u8, 104u8,
          127u8, 6u8, 92u8, 57u8, 212u8, 208u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " The multisig's admin identity.  The primary key of this identity"]
      #[doc = " has admin control over the multisig."]
      #[doc = ""]
      #[doc = " multisig -> Option<IdentityId>."]
      pub fn admin_did(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        ::polymesh_api_client::IdentityId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 58u8, 32u8, 242u8, 176u8, 113u8, 123u8, 137u8, 45u8, 241u8, 118u8,
          159u8, 124u8, 101u8, 106u8, 164u8, 65u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " The count of approvals/rejections of a multisig proposal."]
      #[doc = ""]
      #[doc = " multisig -> proposal id => Option<ProposalVoteCount>."]
      pub fn proposal_vote_counts(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::StoragePaged<
        u64,
        types::polymesh_primitives::multisig::ProposalVoteCount,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 22u8, 28u8, 219u8, 127u8, 2u8, 196u8, 199u8, 111u8, 96u8, 96u8, 228u8,
          243u8, 137u8, 34u8, 97u8, 245u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The state of a multisig proposal"]
      #[doc = ""]
      #[doc = " multisig -> proposal id => Option<ProposalState>."]
      pub fn proposal_states(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::StoragePaged<
        u64,
        types::polymesh_primitives::multisig::ProposalState<u64>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8, 102u8, 151u8, 171u8, 71u8,
          106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Pending join identity authorization proposals."]
      #[doc = ""]
      #[doc = " multisig -> auth id => Option<proposal id>."]
      pub fn auth_to_proposal_id(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::StoragePaged<u64, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 35u8, 107u8, 174u8, 151u8, 167u8, 187u8, 232u8, 180u8, 151u8, 93u8,
          165u8, 155u8, 96u8, 132u8, 198u8, 82u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The last proposal id before the multisig changed signers or signatures required."]
      #[doc = ""]
      #[doc = " multisig => Option<proposal id>"]
      pub fn last_invalid_proposal(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 20u8, 113u8, 107u8, 81u8, 124u8, 171u8, 163u8, 17u8, 16u8, 5u8, 74u8,
          236u8, 90u8, 228u8, 71u8, 111u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
    }
  }
  pub mod bridge {
    use super::*;
    #[derive(Clone)]
    pub struct BridgeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> BridgeCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for BridgeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct BridgeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> BridgeQueryApi<'api> {
      #[doc = " The multisig account of the bridge controller. The genesis signers accept their"]
      #[doc = " authorizations and are able to get their proposals delivered. The bridge creator"]
      #[doc = " transfers some POLY to their identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn controller(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 183u8, 204u8, 54u8, 145u8, 109u8, 19u8, 45u8, 59u8, 195u8, 248u8,
          242u8, 199u8, 1u8, 23u8, 109u8, 66u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The multisig account of the bridge controller. The genesis signers accept their"]
      #[doc = " authorizations and are able to get their proposals delivered. The bridge creator"]
      #[doc = " transfers some POLY to their identity."]
      #[cfg(feature = "ink")]
      pub fn controller(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 183u8, 204u8, 54u8, 145u8, 109u8, 19u8, 45u8, 59u8, 195u8, 248u8,
          242u8, 199u8, 1u8, 23u8, 109u8, 66u8,
        ])?;
        Ok(value)
      }
      #[doc = " Details of bridge transactions identified with pairs of the recipient account and the"]
      #[doc = " bridge transaction nonce."]
      #[cfg(not(feature = "ink"))]
      pub async fn bridge_tx_details(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u32,
      ) -> ::polymesh_api_client::error::Result<types::pallet_bridge::BridgeTxDetail<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 160u8, 171u8, 250u8, 46u8, 255u8, 186u8, 133u8, 70u8, 5u8, 113u8,
          106u8, 184u8, 89u8, 221u8, 9u8, 230u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8,
          ];
          <types::pallet_bridge::BridgeTxDetail<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Details of bridge transactions identified with pairs of the recipient account and the"]
      #[doc = " bridge transaction nonce."]
      #[cfg(feature = "ink")]
      pub fn bridge_tx_details(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u32,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_bridge::BridgeTxDetail<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 160u8, 171u8, 250u8, 46u8, 255u8, 186u8, 133u8, 70u8, 5u8, 113u8,
          106u8, 184u8, 89u8, 221u8, 9u8, 230u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8,
          ];
          <types::pallet_bridge::BridgeTxDetail<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The admin key."]
      #[cfg(not(feature = "ink"))]
      pub async fn admin(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 173u8, 16u8, 141u8, 89u8, 159u8, 82u8, 234u8, 243u8, 141u8, 183u8,
          130u8, 149u8, 229u8, 208u8, 119u8, 7u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The admin key."]
      #[cfg(feature = "ink")]
      pub fn admin(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 173u8, 16u8, 141u8, 89u8, 159u8, 82u8, 234u8, 243u8, 141u8, 183u8,
          130u8, 149u8, 229u8, 208u8, 119u8, 7u8,
        ])?;
        Ok(value)
      }
      #[doc = " Whether or not the bridge operation is frozen."]
      #[cfg(not(feature = "ink"))]
      pub async fn frozen(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8, 93u8, 238u8, 240u8,
          115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Whether or not the bridge operation is frozen."]
      #[cfg(feature = "ink")]
      pub fn frozen(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8, 93u8, 238u8, 240u8,
          115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Freeze bridge admins.  These accounts can only freeze the bridge."]
      #[cfg(not(feature = "ink"))]
      pub async fn freeze_admins(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 46u8, 14u8, 105u8, 223u8, 24u8, 9u8, 5u8, 55u8, 62u8, 201u8, 158u8,
          14u8, 181u8, 153u8, 155u8, 227u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Freeze bridge admins.  These accounts can only freeze the bridge."]
      #[cfg(feature = "ink")]
      pub fn freeze_admins(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 46u8, 14u8, 105u8, 223u8, 24u8, 9u8, 5u8, 55u8, 62u8, 201u8, 158u8,
          14u8, 181u8, 153u8, 155u8, 227u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The bridge transaction timelock period, in blocks, since the acceptance of the"]
      #[doc = " transaction proposal during which the admin key can freeze the transaction."]
      #[cfg(not(feature = "ink"))]
      pub async fn timelock(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 165u8, 103u8, 110u8, 43u8, 52u8, 147u8, 66u8, 159u8, 203u8, 158u8,
          136u8, 171u8, 49u8, 13u8, 97u8, 241u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The bridge transaction timelock period, in blocks, since the acceptance of the"]
      #[doc = " transaction proposal during which the admin key can freeze the transaction."]
      #[cfg(feature = "ink")]
      pub fn timelock(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 165u8, 103u8, 110u8, 43u8, 52u8, 147u8, 66u8, 159u8, 203u8, 158u8,
          136u8, 171u8, 49u8, 13u8, 97u8, 241u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum number of bridged POLYX per identity within a set interval of"]
      #[doc = " blocks. Fields: POLYX amount and the block interval duration."]
      #[cfg(not(feature = "ink"))]
      pub async fn bridge_limit(&self) -> ::polymesh_api_client::error::Result<(u128, u32)> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 132u8, 135u8, 62u8, 163u8, 160u8, 182u8, 134u8, 35u8, 36u8, 148u8,
          56u8, 64u8, 19u8, 139u8, 235u8, 155u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <(u128, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum number of bridged POLYX per identity within a set interval of"]
      #[doc = " blocks. Fields: POLYX amount and the block interval duration."]
      #[cfg(feature = "ink")]
      pub fn bridge_limit(&self) -> ::polymesh_api_ink::error::Result<(u128, u32)> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 132u8, 135u8, 62u8, 163u8, 160u8, 182u8, 134u8, 35u8, 36u8, 148u8,
          56u8, 64u8, 19u8, 139u8, 235u8, 155u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <(u128, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Amount of POLYX bridged by the identity in last block interval. Fields: the bridged"]
      #[doc = " amount and the last interval number."]
      #[cfg(not(feature = "ink"))]
      pub async fn polyx_bridged(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<(u128, u32)> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 153u8, 172u8, 54u8, 12u8, 240u8, 75u8, 42u8, 186u8, 164u8, 214u8,
          162u8, 172u8, 42u8, 252u8, 113u8, 145u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <(u128, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Amount of POLYX bridged by the identity in last block interval. Fields: the bridged"]
      #[doc = " amount and the last interval number."]
      #[cfg(feature = "ink")]
      pub fn polyx_bridged(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<(u128, u32)> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 153u8, 172u8, 54u8, 12u8, 240u8, 75u8, 42u8, 186u8, 164u8, 214u8,
          162u8, 172u8, 42u8, 252u8, 113u8, 145u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <(u128, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Identities not constrained by the bridge limit."]
      #[cfg(not(feature = "ink"))]
      pub async fn bridge_limit_exempted(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 108u8, 105u8, 144u8, 154u8, 14u8, 188u8, 102u8, 133u8, 14u8, 53u8,
          105u8, 27u8, 178u8, 56u8, 52u8, 155u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Identities not constrained by the bridge limit."]
      #[cfg(feature = "ink")]
      pub fn bridge_limit_exempted(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 108u8, 105u8, 144u8, 154u8, 14u8, 188u8, 102u8, 133u8, 14u8, 53u8,
          105u8, 27u8, 178u8, 56u8, 52u8, 155u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_bridge::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_bridge::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_bridge::Version> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_bridge::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct BridgePagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> BridgePagedQueryApi<'api> {
      #[doc = " Details of bridge transactions identified with pairs of the recipient account and the"]
      #[doc = " bridge transaction nonce."]
      pub fn bridge_tx_details(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::StoragePaged<u32, types::pallet_bridge::BridgeTxDetail<u32>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 160u8, 171u8, 250u8, 46u8, 255u8, 186u8, 133u8, 70u8, 5u8, 113u8,
          106u8, 184u8, 89u8, 221u8, 9u8, 230u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Freeze bridge admins.  These accounts can only freeze the bridge."]
      pub fn freeze_admins(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 46u8, 14u8, 105u8, 223u8, 24u8, 9u8, 5u8, 55u8, 62u8, 201u8, 158u8,
          14u8, 181u8, 153u8, 155u8, 227u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Amount of POLYX bridged by the identity in last block interval. Fields: the bridged"]
      #[doc = " amount and the last interval number."]
      pub fn polyx_bridged(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, (u128, u32)>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 153u8, 172u8, 54u8, 12u8, 240u8, 75u8, 42u8, 186u8, 164u8, 214u8,
          162u8, 172u8, 42u8, 252u8, 113u8, 145u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " Identities not constrained by the bridge limit."]
      pub fn bridge_limit_exempted(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 108u8, 105u8, 144u8, 154u8, 14u8, 188u8, 102u8, 133u8, 14u8, 53u8,
          105u8, 27u8, 178u8, 56u8, 52u8, 155u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod staking {
    use super::*;
    #[derive(Clone)]
    pub struct StakingCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> StakingCallApi<'api> {
      #[doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"]
      #[doc = "be the account that controls it."]
      #[doc = ""]
      #[doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash account."]
      #[doc = ""]
      #[doc = "Emits `Bonded`."]
      #[doc = "## Complexity"]
      #[doc = "- Independent of the arguments. Moderate complexity."]
      #[doc = "- O(1)."]
      #[doc = "- Three extra DB entries."]
      #[doc = ""]
      #[doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"]
      #[doc = "unless the `origin` falls below _existential deposit_ and gets removed as dust."]
      #[cfg(not(feature = "ink"))]
      pub fn bond(
        &self,
        controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::bond {
            controller,
            value,
            payee,
          },
        ))
      }
      #[doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"]
      #[doc = "be the account that controls it."]
      #[doc = ""]
      #[doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash account."]
      #[doc = ""]
      #[doc = "Emits `Bonded`."]
      #[doc = "## Complexity"]
      #[doc = "- Independent of the arguments. Moderate complexity."]
      #[doc = "- O(1)."]
      #[doc = "- Three extra DB entries."]
      #[doc = ""]
      #[doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"]
      #[doc = "unless the `origin` falls below _existential deposit_ and gets removed as dust."]
      #[cfg(feature = "ink")]
      pub fn bond(
        &self,
        controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 0u8];
        controller.encode_to(&mut buf);
        value.encode_to(&mut buf);
        payee.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"]
      #[doc = "for staking."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
      #[doc = ""]
      #[doc = "Use this if there are additional funds in your stash account that you wish to bond."]
      #[doc = "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose"]
      #[doc = "any limitation on the amount that can be added."]
      #[doc = ""]
      #[doc = "Emits `Bonded`."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- O(1)."]
      #[cfg(not(feature = "ink"))]
      pub fn bond_extra(
        &self,
        max_additional: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::bond_extra { max_additional },
        ))
      }
      #[doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"]
      #[doc = "for staking."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
      #[doc = ""]
      #[doc = "Use this if there are additional funds in your stash account that you wish to bond."]
      #[doc = "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose"]
      #[doc = "any limitation on the amount that can be added."]
      #[doc = ""]
      #[doc = "Emits `Bonded`."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- O(1)."]
      #[cfg(feature = "ink")]
      pub fn bond_extra(&self, max_additional: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 1u8];
        max_additional.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"]
      #[doc = "period ends. If this leaves an amount actively bonded less than"]
      #[doc = "T::Currency::minimum_balance(), then it is increased to the full amount."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"]
      #[doc = "the funds out of management ready for transfer."]
      #[doc = ""]
      #[doc = "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)"]
      #[doc = "can co-exists at the same time. If there are no unlocking chunks slots available"]
      #[doc = "[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible)."]
      #[doc = ""]
      #[doc = "If a user encounters the `InsufficientBond` error when calling this extrinsic,"]
      #[doc = "they should call `chill` first in order to free up their bonded funds."]
      #[doc = ""]
      #[doc = "Emits `Unbonded`."]
      #[doc = ""]
      #[doc = "See also [`Call::withdraw_unbonded`]."]
      #[cfg(not(feature = "ink"))]
      pub fn unbond(
        &self,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::unbond { value },
        ))
      }
      #[doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"]
      #[doc = "period ends. If this leaves an amount actively bonded less than"]
      #[doc = "T::Currency::minimum_balance(), then it is increased to the full amount."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"]
      #[doc = "the funds out of management ready for transfer."]
      #[doc = ""]
      #[doc = "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)"]
      #[doc = "can co-exists at the same time. If there are no unlocking chunks slots available"]
      #[doc = "[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible)."]
      #[doc = ""]
      #[doc = "If a user encounters the `InsufficientBond` error when calling this extrinsic,"]
      #[doc = "they should call `chill` first in order to free up their bonded funds."]
      #[doc = ""]
      #[doc = "Emits `Unbonded`."]
      #[doc = ""]
      #[doc = "See also [`Call::withdraw_unbonded`]."]
      #[cfg(feature = "ink")]
      pub fn unbond(&self, value: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 2u8];
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove any unlocked chunks from the `unlocking` queue from our management."]
      #[doc = ""]
      #[doc = "This essentially frees up that balance to be used by the stash account to do"]
      #[doc = "whatever it wants."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller."]
      #[doc = ""]
      #[doc = "Emits `Withdrawn`."]
      #[doc = ""]
      #[doc = "See also [`Call::unbond`]."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "O(S) where S is the number of slashing spans to remove"]
      #[doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."]
      #[cfg(not(feature = "ink"))]
      pub fn withdraw_unbonded(
        &self,
        num_slashing_spans: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::withdraw_unbonded {
            num_slashing_spans,
          },
        ))
      }
      #[doc = "Remove any unlocked chunks from the `unlocking` queue from our management."]
      #[doc = ""]
      #[doc = "This essentially frees up that balance to be used by the stash account to do"]
      #[doc = "whatever it wants."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller."]
      #[doc = ""]
      #[doc = "Emits `Withdrawn`."]
      #[doc = ""]
      #[doc = "See also [`Call::unbond`]."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "O(S) where S is the number of slashing spans to remove"]
      #[doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."]
      #[cfg(feature = "ink")]
      pub fn withdraw_unbonded(&self, num_slashing_spans: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 3u8];
        num_slashing_spans.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Declare the desire to validate for the origin controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[cfg(not(feature = "ink"))]
      pub fn validate(
        &self,
        prefs: types::pallet_staking::ValidatorPrefs,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::validate { prefs },
        ))
      }
      #[doc = "Declare the desire to validate for the origin controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[cfg(feature = "ink")]
      pub fn validate(
        &self,
        prefs: types::pallet_staking::ValidatorPrefs,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 4u8];
        prefs.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Declare the desire to nominate `targets` for the origin controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- The transaction's complexity is proportional to the size of `targets` (N)"]
      #[doc = "which is capped at CompactAssignments::LIMIT (T::MaxNominations)."]
      #[doc = "- Both the reads and writes follow a similar pattern."]
      #[cfg(not(feature = "ink"))]
      pub fn nominate(
        &self,
        targets: ::alloc::vec::Vec<
          ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::nominate { targets },
        ))
      }
      #[doc = "Declare the desire to nominate `targets` for the origin controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- The transaction's complexity is proportional to the size of `targets` (N)"]
      #[doc = "which is capped at CompactAssignments::LIMIT (T::MaxNominations)."]
      #[doc = "- Both the reads and writes follow a similar pattern."]
      #[cfg(feature = "ink")]
      pub fn nominate(
        &self,
        targets: ::alloc::vec::Vec<
          ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 5u8];
        targets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Declare no desire to either validate or nominate."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains one read."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[cfg(not(feature = "ink"))]
      pub fn chill(&self) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::chill,
        ))
      }
      #[doc = "Declare no desire to either validate or nominate."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains one read."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[cfg(feature = "ink")]
      pub fn chill(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![17u8, 6u8])
      }
      #[doc = "(Re-)set the payment target for a controller."]
      #[doc = ""]
      #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(1)"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "---------"]
      #[cfg(not(feature = "ink"))]
      pub fn set_payee(
        &self,
        payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::set_payee { payee },
        ))
      }
      #[doc = "(Re-)set the payment target for a controller."]
      #[doc = ""]
      #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(1)"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "---------"]
      #[cfg(feature = "ink")]
      pub fn set_payee(
        &self,
        payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 7u8];
        payee.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "(Re-)set the controller of a stash."]
      #[doc = ""]
      #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "O(1)"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[cfg(not(feature = "ink"))]
      pub fn set_controller(
        &self,
        controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::set_controller { controller },
        ))
      }
      #[doc = "(Re-)set the controller of a stash."]
      #[doc = ""]
      #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "O(1)"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[cfg(feature = "ink")]
      pub fn set_controller(
        &self,
        controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 8u8];
        controller.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets the ideal number of validators."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "O(1)"]
      #[cfg(not(feature = "ink"))]
      pub fn set_validator_count(
        &self,
        new: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::set_validator_count { new },
        ))
      }
      #[doc = "Sets the ideal number of validators."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "O(1)"]
      #[cfg(feature = "ink")]
      pub fn set_validator_count(&self, new: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 9u8];
        new.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Increments the ideal number of validators upto maximum of"]
      #[doc = "`ElectionProviderBase::MaxWinners`."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "Same as [`Self::set_validator_count`]."]
      #[cfg(not(feature = "ink"))]
      pub fn increase_validator_count(
        &self,
        additional: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::increase_validator_count {
            additional,
          },
        ))
      }
      #[doc = "Increments the ideal number of validators upto maximum of"]
      #[doc = "`ElectionProviderBase::MaxWinners`."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "Same as [`Self::set_validator_count`]."]
      #[cfg(feature = "ink")]
      pub fn increase_validator_count(&self, additional: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 10u8];
        additional.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Scale up the ideal number of validators by a factor upto maximum of"]
      #[doc = "`ElectionProviderBase::MaxWinners`."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "Same as [`Self::set_validator_count`]."]
      #[cfg(not(feature = "ink"))]
      pub fn scale_validator_count(
        &self,
        factor: ::polymesh_api_client::per_things::Percent,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::scale_validator_count { factor },
        ))
      }
      #[doc = "Scale up the ideal number of validators by a factor upto maximum of"]
      #[doc = "`ElectionProviderBase::MaxWinners`."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "Same as [`Self::set_validator_count`]."]
      #[cfg(feature = "ink")]
      pub fn scale_validator_count(
        &self,
        factor: ::polymesh_api_client::per_things::Percent,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 11u8];
        factor.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Force there to be no new eras indefinitely."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# Warning"]
      #[doc = ""]
      #[doc = "The election process starts multiple blocks before the end of the era."]
      #[doc = "Thus the election process may be ongoing when this is called. In this case the"]
      #[doc = "election will continue until the next era is triggered."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- No arguments."]
      #[doc = "- Weight: O(1)"]
      #[cfg(not(feature = "ink"))]
      pub fn force_no_eras(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::force_no_eras,
        ))
      }
      #[doc = "Force there to be no new eras indefinitely."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# Warning"]
      #[doc = ""]
      #[doc = "The election process starts multiple blocks before the end of the era."]
      #[doc = "Thus the election process may be ongoing when this is called. In this case the"]
      #[doc = "election will continue until the next era is triggered."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- No arguments."]
      #[doc = "- Weight: O(1)"]
      #[cfg(feature = "ink")]
      pub fn force_no_eras(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![17u8, 12u8])
      }
      #[doc = "Force there to be a new era at the end of the next session. After this, it will be"]
      #[doc = "reset to normal (non-forced) behaviour."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# Warning"]
      #[doc = ""]
      #[doc = "The election process starts multiple blocks before the end of the era."]
      #[doc = "If this is called just before a new era is triggered, the election process may not"]
      #[doc = "have enough blocks to get a result."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- No arguments."]
      #[doc = "- Weight: O(1)"]
      #[cfg(not(feature = "ink"))]
      pub fn force_new_era(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::force_new_era,
        ))
      }
      #[doc = "Force there to be a new era at the end of the next session. After this, it will be"]
      #[doc = "reset to normal (non-forced) behaviour."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# Warning"]
      #[doc = ""]
      #[doc = "The election process starts multiple blocks before the end of the era."]
      #[doc = "If this is called just before a new era is triggered, the election process may not"]
      #[doc = "have enough blocks to get a result."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- No arguments."]
      #[doc = "- Weight: O(1)"]
      #[cfg(feature = "ink")]
      pub fn force_new_era(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![17u8, 13u8])
      }
      #[doc = "Set the validators who cannot be slashed (if any)."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[cfg(not(feature = "ink"))]
      pub fn set_invulnerables(
        &self,
        invulnerables: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::set_invulnerables { invulnerables },
        ))
      }
      #[doc = "Set the validators who cannot be slashed (if any)."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[cfg(feature = "ink")]
      pub fn set_invulnerables(
        &self,
        invulnerables: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 14u8];
        invulnerables.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Force a current staker to become completely unstaked, immediately."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[cfg(not(feature = "ink"))]
      pub fn force_unstake(
        &self,
        stash: ::polymesh_api_client::AccountId,
        num_slashing_spans: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::force_unstake {
            stash,
            num_slashing_spans,
          },
        ))
      }
      #[doc = "Force a current staker to become completely unstaked, immediately."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[cfg(feature = "ink")]
      pub fn force_unstake(
        &self,
        stash: ::polymesh_api_client::AccountId,
        num_slashing_spans: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 15u8];
        stash.encode_to(&mut buf);
        num_slashing_spans.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Force there to be a new era at the end of sessions indefinitely."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# Warning"]
      #[doc = ""]
      #[doc = "The election process starts multiple blocks before the end of the era."]
      #[doc = "If this is called just before a new era is triggered, the election process may not"]
      #[doc = "have enough blocks to get a result."]
      #[cfg(not(feature = "ink"))]
      pub fn force_new_era_always(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::force_new_era_always,
        ))
      }
      #[doc = "Force there to be a new era at the end of sessions indefinitely."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# Warning"]
      #[doc = ""]
      #[doc = "The election process starts multiple blocks before the end of the era."]
      #[doc = "If this is called just before a new era is triggered, the election process may not"]
      #[doc = "have enough blocks to get a result."]
      #[cfg(feature = "ink")]
      pub fn force_new_era_always(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![17u8, 16u8])
      }
      #[doc = "Cancel enactment of a deferred slash."]
      #[doc = ""]
      #[doc = "Can be called by the `T::AdminOrigin`."]
      #[doc = ""]
      #[doc = "Parameters: era and indices of the slashes for that era to kill."]
      #[cfg(not(feature = "ink"))]
      pub fn cancel_deferred_slash(
        &self,
        era: u32,
        slash_indices: ::alloc::vec::Vec<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::cancel_deferred_slash {
            era,
            slash_indices,
          },
        ))
      }
      #[doc = "Cancel enactment of a deferred slash."]
      #[doc = ""]
      #[doc = "Can be called by the `T::AdminOrigin`."]
      #[doc = ""]
      #[doc = "Parameters: era and indices of the slashes for that era to kill."]
      #[cfg(feature = "ink")]
      pub fn cancel_deferred_slash(
        &self,
        era: u32,
        slash_indices: ::alloc::vec::Vec<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 17u8];
        era.encode_to(&mut buf);
        slash_indices.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Pay out all the stakers behind a single validator for a single era."]
      #[doc = ""]
      #[doc = "- `validator_stash` is the stash account of the validator. Their nominators, up to"]
      #[doc = "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards."]
      #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
      #[doc = ""]
      #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
      #[doc = "it is not one of the stakers."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- At most O(MaxNominatorRewardedPerValidator)."]
      #[cfg(not(feature = "ink"))]
      pub fn payout_stakers(
        &self,
        validator_stash: ::polymesh_api_client::AccountId,
        era: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::payout_stakers {
            validator_stash,
            era,
          },
        ))
      }
      #[doc = "Pay out all the stakers behind a single validator for a single era."]
      #[doc = ""]
      #[doc = "- `validator_stash` is the stash account of the validator. Their nominators, up to"]
      #[doc = "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards."]
      #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
      #[doc = ""]
      #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
      #[doc = "it is not one of the stakers."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- At most O(MaxNominatorRewardedPerValidator)."]
      #[cfg(feature = "ink")]
      pub fn payout_stakers(
        &self,
        validator_stash: ::polymesh_api_client::AccountId,
        era: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 18u8];
        validator_stash.encode_to(&mut buf);
        era.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rebond a portion of the stash scheduled to be unlocked."]
      #[doc = ""]
      #[doc = "The dispatch origin must be signed by the controller."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- Time complexity: O(L), where L is unlocking chunks"]
      #[doc = "- Bounded by `MaxUnlockingChunks`."]
      #[cfg(not(feature = "ink"))]
      pub fn rebond(
        &self,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::rebond { value },
        ))
      }
      #[doc = "Rebond a portion of the stash scheduled to be unlocked."]
      #[doc = ""]
      #[doc = "The dispatch origin must be signed by the controller."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- Time complexity: O(L), where L is unlocking chunks"]
      #[doc = "- Bounded by `MaxUnlockingChunks`."]
      #[cfg(feature = "ink")]
      pub fn rebond(&self, value: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 19u8];
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove all data structures concerning a staker/stash once it is at a state where it can"]
      #[doc = "be considered `dust` in the staking system. The requirements are:"]
      #[doc = ""]
      #[doc = "1. the `total_balance` of the stash is below existential deposit."]
      #[doc = "2. or, the `ledger.total` of the stash is below existential deposit."]
      #[doc = ""]
      #[doc = "The former can happen in cases like a slash; the latter when a fully unbonded account"]
      #[doc = "is still receiving staking rewards in `RewardDestination::Staked`."]
      #[doc = ""]
      #[doc = "It can be called by anyone, as long as `stash` meets the above requirements."]
      #[doc = ""]
      #[doc = "Refunds the transaction fees upon successful execution."]
      #[cfg(not(feature = "ink"))]
      pub fn reap_stash(
        &self,
        stash: ::polymesh_api_client::AccountId,
        num_slashing_spans: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::reap_stash {
            stash,
            num_slashing_spans,
          },
        ))
      }
      #[doc = "Remove all data structures concerning a staker/stash once it is at a state where it can"]
      #[doc = "be considered `dust` in the staking system. The requirements are:"]
      #[doc = ""]
      #[doc = "1. the `total_balance` of the stash is below existential deposit."]
      #[doc = "2. or, the `ledger.total` of the stash is below existential deposit."]
      #[doc = ""]
      #[doc = "The former can happen in cases like a slash; the latter when a fully unbonded account"]
      #[doc = "is still receiving staking rewards in `RewardDestination::Staked`."]
      #[doc = ""]
      #[doc = "It can be called by anyone, as long as `stash` meets the above requirements."]
      #[doc = ""]
      #[doc = "Refunds the transaction fees upon successful execution."]
      #[cfg(feature = "ink")]
      pub fn reap_stash(
        &self,
        stash: ::polymesh_api_client::AccountId,
        num_slashing_spans: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 20u8];
        stash.encode_to(&mut buf);
        num_slashing_spans.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove the given nominations from the calling validator."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "- `who`: A list of nominator stash accounts who are nominating this validator which"]
      #[doc = "  should no longer be nominating this validator."]
      #[doc = ""]
      #[doc = "Note: Making this call only makes sense if you first set the validator preferences to"]
      #[doc = "block any further nominations."]
      #[cfg(not(feature = "ink"))]
      pub fn kick(
        &self,
        who: ::alloc::vec::Vec<
          ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::kick { who },
        ))
      }
      #[doc = "Remove the given nominations from the calling validator."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "- `who`: A list of nominator stash accounts who are nominating this validator which"]
      #[doc = "  should no longer be nominating this validator."]
      #[doc = ""]
      #[doc = "Note: Making this call only makes sense if you first set the validator preferences to"]
      #[doc = "block any further nominations."]
      #[cfg(feature = "ink")]
      pub fn kick(
        &self,
        who: ::alloc::vec::Vec<
          ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 21u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Update the various staking configurations ."]
      #[doc = ""]
      #[doc = "* `min_nominator_bond`: The minimum active bond needed to be a nominator."]
      #[doc = "* `min_validator_bond`: The minimum active bond needed to be a validator."]
      #[doc = "* `max_nominator_count`: The max number of users who can be a nominator at once. When"]
      #[doc = "  set to `None`, no limit is enforced."]
      #[doc = "* `max_validator_count`: The max number of users who can be a validator at once. When"]
      #[doc = "  set to `None`, no limit is enforced."]
      #[doc = "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which"]
      #[doc = "  should be filled in order for the `chill_other` transaction to work."]
      #[doc = "* `min_commission`: The minimum amount of commission that each validators must maintain."]
      #[doc = "  This is checked only upon calling `validate`. Existing validators are not affected."]
      #[doc = ""]
      #[doc = "RuntimeOrigin must be Root to call this function."]
      #[doc = ""]
      #[doc = "NOTE: Existing nominators and validators will not be affected by this update."]
      #[doc = "to kick people under the new limits, `chill_other` should be called."]
      #[cfg(not(feature = "ink"))]
      pub fn set_staking_configs(
        &self,
        min_nominator_bond: types::pallet_staking::pallet::pallet::ConfigOp<u128>,
        min_validator_bond: types::pallet_staking::pallet::pallet::ConfigOp<u128>,
        max_nominator_count: types::pallet_staking::pallet::pallet::ConfigOp<u32>,
        max_validator_count: types::pallet_staking::pallet::pallet::ConfigOp<u32>,
        chill_threshold: types::pallet_staking::pallet::pallet::ConfigOp<
          ::polymesh_api_client::per_things::Percent,
        >,
        min_commission: types::pallet_staking::pallet::pallet::ConfigOp<
          ::polymesh_api_client::per_things::Perbill,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::set_staking_configs {
            min_nominator_bond,
            min_validator_bond,
            max_nominator_count,
            max_validator_count,
            chill_threshold,
            min_commission,
          },
        ))
      }
      #[doc = "Update the various staking configurations ."]
      #[doc = ""]
      #[doc = "* `min_nominator_bond`: The minimum active bond needed to be a nominator."]
      #[doc = "* `min_validator_bond`: The minimum active bond needed to be a validator."]
      #[doc = "* `max_nominator_count`: The max number of users who can be a nominator at once. When"]
      #[doc = "  set to `None`, no limit is enforced."]
      #[doc = "* `max_validator_count`: The max number of users who can be a validator at once. When"]
      #[doc = "  set to `None`, no limit is enforced."]
      #[doc = "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which"]
      #[doc = "  should be filled in order for the `chill_other` transaction to work."]
      #[doc = "* `min_commission`: The minimum amount of commission that each validators must maintain."]
      #[doc = "  This is checked only upon calling `validate`. Existing validators are not affected."]
      #[doc = ""]
      #[doc = "RuntimeOrigin must be Root to call this function."]
      #[doc = ""]
      #[doc = "NOTE: Existing nominators and validators will not be affected by this update."]
      #[doc = "to kick people under the new limits, `chill_other` should be called."]
      #[cfg(feature = "ink")]
      pub fn set_staking_configs(
        &self,
        min_nominator_bond: types::pallet_staking::pallet::pallet::ConfigOp<u128>,
        min_validator_bond: types::pallet_staking::pallet::pallet::ConfigOp<u128>,
        max_nominator_count: types::pallet_staking::pallet::pallet::ConfigOp<u32>,
        max_validator_count: types::pallet_staking::pallet::pallet::ConfigOp<u32>,
        chill_threshold: types::pallet_staking::pallet::pallet::ConfigOp<
          ::polymesh_api_client::per_things::Percent,
        >,
        min_commission: types::pallet_staking::pallet::pallet::ConfigOp<
          ::polymesh_api_client::per_things::Perbill,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 22u8];
        min_nominator_bond.encode_to(&mut buf);
        min_validator_bond.encode_to(&mut buf);
        max_nominator_count.encode_to(&mut buf);
        max_validator_count.encode_to(&mut buf);
        chill_threshold.encode_to(&mut buf);
        min_commission.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Declare a `controller` to stop participating as either a validator or nominator."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_, but can be called by anyone."]
      #[doc = ""]
      #[doc = "If the caller is the same as the controller being targeted, then no further checks are"]
      #[doc = "enforced, and this function behaves just like `chill`."]
      #[doc = ""]
      #[doc = "If the caller is different than the controller being targeted, the following conditions"]
      #[doc = "must be met:"]
      #[doc = ""]
      #[doc = "* `controller` must belong to a nominator who has become non-decodable,"]
      #[doc = ""]
      #[doc = "Or:"]
      #[doc = ""]
      #[doc = "* A `ChillThreshold` must be set and checked which defines how close to the max"]
      #[doc = "  nominators or validators we must reach before users can start chilling one-another."]
      #[doc = "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine"]
      #[doc = "  how close we are to the threshold."]
      #[doc = "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines"]
      #[doc = "  if this is a person that should be chilled because they have not met the threshold"]
      #[doc = "  bond required."]
      #[doc = ""]
      #[doc = "This can be helpful if bond requirements are updated, and we need to remove old users"]
      #[doc = "who do not satisfy these requirements."]
      #[cfg(not(feature = "ink"))]
      pub fn chill_other(
        &self,
        controller: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::chill_other { controller },
        ))
      }
      #[doc = "Declare a `controller` to stop participating as either a validator or nominator."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_, but can be called by anyone."]
      #[doc = ""]
      #[doc = "If the caller is the same as the controller being targeted, then no further checks are"]
      #[doc = "enforced, and this function behaves just like `chill`."]
      #[doc = ""]
      #[doc = "If the caller is different than the controller being targeted, the following conditions"]
      #[doc = "must be met:"]
      #[doc = ""]
      #[doc = "* `controller` must belong to a nominator who has become non-decodable,"]
      #[doc = ""]
      #[doc = "Or:"]
      #[doc = ""]
      #[doc = "* A `ChillThreshold` must be set and checked which defines how close to the max"]
      #[doc = "  nominators or validators we must reach before users can start chilling one-another."]
      #[doc = "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine"]
      #[doc = "  how close we are to the threshold."]
      #[doc = "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines"]
      #[doc = "  if this is a person that should be chilled because they have not met the threshold"]
      #[doc = "  bond required."]
      #[doc = ""]
      #[doc = "This can be helpful if bond requirements are updated, and we need to remove old users"]
      #[doc = "who do not satisfy these requirements."]
      #[cfg(feature = "ink")]
      pub fn chill_other(
        &self,
        controller: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 23u8];
        controller.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Force a validator to have at least the minimum commission. This will not affect a"]
      #[doc = "validator who already has a commission greater than or equal to the minimum. Any account"]
      #[doc = "can call this."]
      #[cfg(not(feature = "ink"))]
      pub fn force_apply_min_commission(
        &self,
        validator_stash: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::force_apply_min_commission {
            validator_stash,
          },
        ))
      }
      #[doc = "Force a validator to have at least the minimum commission. This will not affect a"]
      #[doc = "validator who already has a commission greater than or equal to the minimum. Any account"]
      #[doc = "can call this."]
      #[cfg(feature = "ink")]
      pub fn force_apply_min_commission(
        &self,
        validator_stash: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 24u8];
        validator_stash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets the minimum amount of commission that each validators must maintain."]
      #[doc = ""]
      #[doc = "This call has lower privilege requirements than `set_staking_config` and can be called"]
      #[doc = "by the `T::AdminOrigin`. Root can always call this."]
      #[cfg(not(feature = "ink"))]
      pub fn set_min_commission(
        &self,
        new: ::polymesh_api_client::per_things::Perbill,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::set_min_commission { new },
        ))
      }
      #[doc = "Sets the minimum amount of commission that each validators must maintain."]
      #[doc = ""]
      #[doc = "This call has lower privilege requirements than `set_staking_config` and can be called"]
      #[doc = "by the `T::AdminOrigin`. Root can always call this."]
      #[cfg(feature = "ink")]
      pub fn set_min_commission(
        &self,
        new: ::polymesh_api_client::per_things::Perbill,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 25u8];
        new.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a permissioned identity and sets its preferences."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[cfg(not(feature = "ink"))]
      pub fn add_permissioned_validator(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        intended_count: Option<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::add_permissioned_validator {
            identity,
            intended_count,
          },
        ))
      }
      #[doc = "Adds a permissioned identity and sets its preferences."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[cfg(feature = "ink")]
      pub fn add_permissioned_validator(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        intended_count: Option<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 26u8];
        identity.encode_to(&mut buf);
        intended_count.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin Required origin for removing a potential validator."]
      #[doc = "* identity Validator's IdentityId."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_permissioned_validator(
        &self,
        identity: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::remove_permissioned_validator {
            identity,
          },
        ))
      }
      #[doc = "Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin Required origin for removing a potential validator."]
      #[doc = "* identity Validator's IdentityId."]
      #[cfg(feature = "ink")]
      pub fn remove_permissioned_validator(
        &self,
        identity: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 27u8];
        identity.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Validate the nominators CDD expiry time."]
      #[doc = ""]
      #[doc = "If an account from a given set of address is nominating then check the CDD expiry time"]
      #[doc = "of it and if it is expired then the account should be unbonded and removed from the"]
      #[doc = "nominating process."]
      #[cfg(not(feature = "ink"))]
      pub fn validate_cdd_expiry_nominators(
        &self,
        targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::validate_cdd_expiry_nominators {
            targets,
          },
        ))
      }
      #[doc = "Validate the nominators CDD expiry time."]
      #[doc = ""]
      #[doc = "If an account from a given set of address is nominating then check the CDD expiry time"]
      #[doc = "of it and if it is expired then the account should be unbonded and removed from the"]
      #[doc = "nominating process."]
      #[cfg(feature = "ink")]
      pub fn validate_cdd_expiry_nominators(
        &self,
        targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 28u8];
        targets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[cfg(not(feature = "ink"))]
      pub fn payout_stakers_by_system(
        &self,
        validator_stash: ::polymesh_api_client::AccountId,
        era: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::payout_stakers_by_system {
            validator_stash,
            era,
          },
        ))
      }
      #[cfg(feature = "ink")]
      pub fn payout_stakers_by_system(
        &self,
        validator_stash: ::polymesh_api_client::AccountId,
        era: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 29u8];
        validator_stash.encode_to(&mut buf);
        era.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Switch slashing status on the basis of given `slashing_switch`. Can only be called by root."]
      #[cfg(not(feature = "ink"))]
      pub fn change_slashing_allowed_for(
        &self,
        slashing_switch: types::pallet_staking::types::SlashingSwitch,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::change_slashing_allowed_for {
            slashing_switch,
          },
        ))
      }
      #[doc = "Switch slashing status on the basis of given `slashing_switch`. Can only be called by root."]
      #[cfg(feature = "ink")]
      pub fn change_slashing_allowed_for(
        &self,
        slashing_switch: types::pallet_staking::types::SlashingSwitch,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 30u8];
        slashing_switch.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets the intended count to `new_intended_count` for the given `identity`."]
      #[cfg(not(feature = "ink"))]
      pub fn update_permissioned_validator_intended_count(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        new_intended_count: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: Staking (types :: pallet_staking :: pallet :: pallet :: StakingCall :: update_permissioned_validator_intended_count { identity , new_intended_count , }))
      }
      #[doc = "Sets the intended count to `new_intended_count` for the given `identity`."]
      #[cfg(feature = "ink")]
      pub fn update_permissioned_validator_intended_count(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        new_intended_count: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 31u8];
        identity.encode_to(&mut buf);
        new_intended_count.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Governance council forcefully chills a validator. Effects will be felt at the beginning of the next era."]
      #[cfg(not(feature = "ink"))]
      pub fn chill_from_governance(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        stash_keys: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::chill_from_governance {
            identity,
            stash_keys,
          },
        ))
      }
      #[doc = "Governance council forcefully chills a validator. Effects will be felt at the beginning of the next era."]
      #[cfg(feature = "ink")]
      pub fn chill_from_governance(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        stash_keys: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 32u8];
        identity.encode_to(&mut buf);
        stash_keys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes commission rate which applies to all validators. Only Governance"]
      #[doc = "committee is allowed to change this value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `new_cap` the new commission cap."]
      #[cfg(not(feature = "ink"))]
      pub fn set_commission_cap(
        &self,
        new_cap: ::polymesh_api_client::per_things::Perbill,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::pallet::pallet::StakingCall::set_commission_cap { new_cap },
        ))
      }
      #[doc = "Changes commission rate which applies to all validators. Only Governance"]
      #[doc = "committee is allowed to change this value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `new_cap` the new commission cap."]
      #[cfg(feature = "ink")]
      pub fn set_commission_cap(
        &self,
        new_cap: ::polymesh_api_client::per_things::Perbill,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 33u8];
        new_cap.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for StakingCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct StakingQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> StakingQueryApi<'api> {
      #[doc = " The ideal number of active validators."]
      #[cfg(not(feature = "ink"))]
      pub async fn validator_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 19u8, 142u8, 113u8, 97u8, 36u8, 145u8, 25u8, 45u8, 104u8, 222u8, 171u8,
          126u8, 111u8, 86u8, 63u8, 225u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The ideal number of active validators."]
      #[cfg(feature = "ink")]
      pub fn validator_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 19u8, 142u8, 113u8, 97u8, 36u8, 145u8, 25u8, 45u8, 104u8, 222u8, 171u8,
          126u8, 111u8, 86u8, 63u8, 225u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Minimum number of staking participants before emergency conditions are imposed."]
      #[cfg(not(feature = "ink"))]
      pub async fn minimum_validator_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 180u8, 154u8, 39u8, 56u8, 238u8, 179u8, 8u8, 150u8, 170u8, 203u8, 139u8,
          63u8, 180u8, 100u8, 113u8, 189u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Minimum number of staking participants before emergency conditions are imposed."]
      #[cfg(feature = "ink")]
      pub fn minimum_validator_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 180u8, 154u8, 39u8, 56u8, 238u8, 179u8, 8u8, 150u8, 170u8, 203u8, 139u8,
          63u8, 180u8, 100u8, 113u8, 189u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're"]
      #[doc = " easy to initialize and the performance hit is minimal (we expect no more than four"]
      #[doc = " invulnerables) and restricted to testnets."]
      #[cfg(not(feature = "ink"))]
      pub async fn invulnerables(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::AccountId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 85u8, 121u8, 41u8, 127u8, 77u8, 251u8, 150u8, 9u8, 231u8, 228u8, 194u8,
          235u8, 171u8, 156u8, 228u8, 10u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're"]
      #[doc = " easy to initialize and the performance hit is minimal (we expect no more than four"]
      #[doc = " invulnerables) and restricted to testnets."]
      #[cfg(feature = "ink")]
      pub fn invulnerables(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::AccountId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 85u8, 121u8, 41u8, 127u8, 77u8, 251u8, 150u8, 9u8, 231u8, 228u8, 194u8,
          235u8, 171u8, 156u8, 228u8, 10u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Map from all locked \"stash\" accounts to the controller account."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn bonded(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 62u8, 209u8, 75u8, 69u8, 237u8, 32u8, 208u8, 84u8, 240u8, 94u8, 55u8,
          226u8, 84u8, 44u8, 254u8, 112u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Map from all locked \"stash\" accounts to the controller account."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(feature = "ink")]
      pub fn bonded(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 62u8, 209u8, 75u8, 69u8, 237u8, 32u8, 208u8, 84u8, 240u8, 94u8, 55u8,
          226u8, 84u8, 44u8, 254u8, 112u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The minimum active bond to become and maintain the role of a nominator."]
      #[cfg(not(feature = "ink"))]
      pub async fn min_nominator_bond(&self) -> ::polymesh_api_client::error::Result<u128> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 237u8, 68u8, 28u8, 235u8, 129u8, 50u8, 108u8, 86u8, 38u8, 62u8, 251u8,
          182u8, 12u8, 149u8, 194u8, 228u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum active bond to become and maintain the role of a nominator."]
      #[cfg(feature = "ink")]
      pub fn min_nominator_bond(&self) -> ::polymesh_api_ink::error::Result<u128> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 237u8, 68u8, 28u8, 235u8, 129u8, 50u8, 108u8, 86u8, 38u8, 62u8, 251u8,
          182u8, 12u8, 149u8, 194u8, 228u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum active bond to become and maintain the role of a validator."]
      #[cfg(not(feature = "ink"))]
      pub async fn min_validator_bond(&self) -> ::polymesh_api_client::error::Result<u128> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 102u8, 111u8, 220u8, 187u8, 71u8, 57u8, 133u8, 179u8, 172u8, 147u8, 61u8,
          19u8, 244u8, 172u8, 255u8, 141u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum active bond to become and maintain the role of a validator."]
      #[cfg(feature = "ink")]
      pub fn min_validator_bond(&self) -> ::polymesh_api_ink::error::Result<u128> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 102u8, 111u8, 220u8, 187u8, 71u8, 57u8, 133u8, 179u8, 172u8, 147u8, 61u8,
          19u8, 244u8, 172u8, 255u8, 141u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum active nominator stake of the last successful election."]
      #[cfg(not(feature = "ink"))]
      pub async fn minimum_active_stake(&self) -> ::polymesh_api_client::error::Result<u128> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 250u8, 184u8, 109u8, 38u8, 230u8, 41u8, 227u8, 155u8, 73u8, 3u8, 219u8,
          148u8, 120u8, 111u8, 172u8, 116u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum active nominator stake of the last successful election."]
      #[cfg(feature = "ink")]
      pub fn minimum_active_stake(&self) -> ::polymesh_api_ink::error::Result<u128> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 250u8, 184u8, 109u8, 38u8, 230u8, 41u8, 227u8, 155u8, 73u8, 3u8, 219u8,
          148u8, 120u8, 111u8, 172u8, 116u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum amount of commission that validators can set."]
      #[doc = ""]
      #[doc = " If set to `0`, no limit exists."]
      #[cfg(not(feature = "ink"))]
      pub async fn min_commission(
        &self,
      ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Perbill> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 88u8, 176u8, 201u8, 193u8, 250u8, 108u8, 193u8, 55u8, 89u8, 234u8, 217u8,
          180u8, 45u8, 185u8, 238u8, 190u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum amount of commission that validators can set."]
      #[doc = ""]
      #[doc = " If set to `0`, no limit exists."]
      #[cfg(feature = "ink")]
      pub fn min_commission(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Perbill> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 88u8, 176u8, 201u8, 193u8, 250u8, 108u8, 193u8, 55u8, 89u8, 234u8, 217u8,
          180u8, 45u8, 185u8, 238u8, 190u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."]
      #[cfg(not(feature = "ink"))]
      pub async fn ledger(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_staking::StakingLedger>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 66u8, 42u8, 219u8, 87u8, 159u8, 29u8, 191u8, 79u8, 56u8, 134u8, 197u8,
          207u8, 163u8, 187u8, 140u8, 196u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."]
      #[cfg(feature = "ink")]
      pub fn ledger(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_staking::StakingLedger>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 66u8, 42u8, 219u8, 87u8, 159u8, 29u8, 191u8, 79u8, 56u8, 134u8, 197u8,
          207u8, 163u8, 187u8, 140u8, 196u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Where the reward payment should be made. Keyed by stash."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn payee(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 146u8, 32u8, 225u8, 114u8, 190u8, 211u8, 22u8, 96u8, 95u8, 115u8, 241u8,
          255u8, 123u8, 74u8, 222u8, 152u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Where the reward payment should be made. Keyed by stash."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(feature = "ink")]
      pub fn payee(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 146u8, 32u8, 225u8, 114u8, 190u8, 211u8, 22u8, 96u8, 95u8, 115u8, 241u8,
          255u8, 123u8, 74u8, 222u8, 152u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The map from (wannabe) validator stash key to the preferences of that validator."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn validators(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::ValidatorPrefs> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
          252u8, 214u8, 225u8, 105u8, 3u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The map from (wannabe) validator stash key to the preferences of that validator."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(feature = "ink")]
      pub fn validators(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::ValidatorPrefs> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
          252u8, 214u8, 225u8, 105u8, 3u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = "Counter for the related counted storage map"]
      #[cfg(not(feature = "ink"))]
      pub async fn counter_for_validators(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 109u8, 220u8, 120u8, 9u8, 198u8, 218u8, 155u8, 182u8, 9u8, 62u8, 226u8,
          46u8, 15u8, 218u8, 75u8, 168u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = "Counter for the related counted storage map"]
      #[cfg(feature = "ink")]
      pub fn counter_for_validators(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 109u8, 220u8, 120u8, 9u8, 198u8, 218u8, 155u8, 182u8, 9u8, 62u8, 226u8,
          46u8, 15u8, 218u8, 75u8, 168u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum validator count before we stop allowing new validators to join."]
      #[doc = ""]
      #[doc = " When this value is not set, no limits are enforced."]
      #[cfg(not(feature = "ink"))]
      pub async fn max_validators_count(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 152u8, 194u8, 100u8, 12u8, 218u8, 108u8, 13u8, 128u8, 17u8, 148u8, 168u8,
          166u8, 28u8, 105u8, 146u8, 36u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The maximum validator count before we stop allowing new validators to join."]
      #[doc = ""]
      #[doc = " When this value is not set, no limits are enforced."]
      #[cfg(feature = "ink")]
      pub fn max_validators_count(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 152u8, 194u8, 100u8, 12u8, 218u8, 108u8, 13u8, 128u8, 17u8, 148u8, 168u8,
          166u8, 28u8, 105u8, 146u8, 36u8,
        ])?;
        Ok(value)
      }
      #[doc = " The map from nominator stash key to their nomination preferences, namely the validators that"]
      #[doc = " they wish to support."]
      #[doc = ""]
      #[doc = " Note that the keys of this storage map might become non-decodable in case the"]
      #[doc = " [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators"]
      #[doc = " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`"]
      #[doc = " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable"]
      #[doc = " nominators will effectively not-exist, until they re-submit their preferences such that it"]
      #[doc = " is within the bounds of the newly set `Config::MaxNominations`."]
      #[doc = ""]
      #[doc = " This implies that `::iter_keys().count()` and `::iter().count()` might return different"]
      #[doc = " values for this map. Moreover, the main `::count()` is aligned with the former, namely the"]
      #[doc = " number of keys that exist."]
      #[doc = ""]
      #[doc = " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via"]
      #[doc = " [`Call::chill_other`] dispatchable by anyone."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn nominators(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_staking::Nominations>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 156u8, 106u8, 99u8, 127u8, 98u8, 174u8, 42u8, 241u8, 199u8, 227u8, 30u8,
          237u8, 126u8, 150u8, 190u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The map from nominator stash key to their nomination preferences, namely the validators that"]
      #[doc = " they wish to support."]
      #[doc = ""]
      #[doc = " Note that the keys of this storage map might become non-decodable in case the"]
      #[doc = " [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators"]
      #[doc = " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`"]
      #[doc = " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable"]
      #[doc = " nominators will effectively not-exist, until they re-submit their preferences such that it"]
      #[doc = " is within the bounds of the newly set `Config::MaxNominations`."]
      #[doc = ""]
      #[doc = " This implies that `::iter_keys().count()` and `::iter().count()` might return different"]
      #[doc = " values for this map. Moreover, the main `::count()` is aligned with the former, namely the"]
      #[doc = " number of keys that exist."]
      #[doc = ""]
      #[doc = " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via"]
      #[doc = " [`Call::chill_other`] dispatchable by anyone."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(feature = "ink")]
      pub fn nominators(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_staking::Nominations>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 156u8, 106u8, 99u8, 127u8, 98u8, 174u8, 42u8, 241u8, 199u8, 227u8, 30u8,
          237u8, 126u8, 150u8, 190u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = "Counter for the related counted storage map"]
      #[cfg(not(feature = "ink"))]
      pub async fn counter_for_nominators(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 249u8, 155u8, 37u8, 133u8, 45u8, 61u8, 105u8, 65u8, 152u8, 130u8, 218u8,
          101u8, 19u8, 117u8, 205u8, 179u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = "Counter for the related counted storage map"]
      #[cfg(feature = "ink")]
      pub fn counter_for_nominators(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 249u8, 155u8, 37u8, 133u8, 45u8, 61u8, 105u8, 65u8, 152u8, 130u8, 218u8,
          101u8, 19u8, 117u8, 205u8, 179u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum nominator count before we stop allowing new validators to join."]
      #[doc = ""]
      #[doc = " When this value is not set, no limits are enforced."]
      #[cfg(not(feature = "ink"))]
      pub async fn max_nominators_count(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 214u8, 66u8, 192u8, 10u8, 241u8, 25u8, 173u8, 243u8, 13u8, 193u8, 29u8,
          50u8, 233u8, 240u8, 136u8, 109u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The maximum nominator count before we stop allowing new validators to join."]
      #[doc = ""]
      #[doc = " When this value is not set, no limits are enforced."]
      #[cfg(feature = "ink")]
      pub fn max_nominators_count(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 214u8, 66u8, 192u8, 10u8, 241u8, 25u8, 173u8, 243u8, 13u8, 193u8, 29u8,
          50u8, 233u8, 240u8, 136u8, 109u8,
        ])?;
        Ok(value)
      }
      #[doc = " The current era index."]
      #[doc = ""]
      #[doc = " This is the latest planned era, depending on how the Session pallet queues the validator"]
      #[doc = " set, it might be active or not."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_era(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 11u8, 106u8, 69u8, 50u8, 30u8, 250u8, 233u8, 42u8, 234u8, 21u8, 224u8,
          116u8, 14u8, 199u8, 175u8, 231u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The current era index."]
      #[doc = ""]
      #[doc = " This is the latest planned era, depending on how the Session pallet queues the validator"]
      #[doc = " set, it might be active or not."]
      #[cfg(feature = "ink")]
      pub fn current_era(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 11u8, 106u8, 69u8, 50u8, 30u8, 250u8, 233u8, 42u8, 234u8, 21u8, 224u8,
          116u8, 14u8, 199u8, 175u8, 231u8,
        ])?;
        Ok(value)
      }
      #[doc = " The active era information, it holds index and start."]
      #[doc = ""]
      #[doc = " The active era is the era being currently rewarded. Validator set of this era must be"]
      #[doc = " equal to [`SessionInterface::validators`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_era(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_staking::ActiveEraInfo>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 72u8, 125u8, 244u8, 100u8, 228u8, 74u8, 83u8, 75u8, 166u8, 176u8, 203u8,
          179u8, 36u8, 7u8, 181u8, 135u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The active era information, it holds index and start."]
      #[doc = ""]
      #[doc = " The active era is the era being currently rewarded. Validator set of this era must be"]
      #[doc = " equal to [`SessionInterface::validators`]."]
      #[cfg(feature = "ink")]
      pub fn active_era(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_staking::ActiveEraInfo>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 72u8, 125u8, 244u8, 100u8, 228u8, 74u8, 83u8, 75u8, 166u8, 176u8, 203u8,
          179u8, 36u8, 7u8, 181u8, 135u8,
        ])?;
        Ok(value)
      }
      #[doc = " The session index at which the era start for the last `HISTORY_DEPTH` eras."]
      #[doc = ""]
      #[doc = " Note: This tracks the starting session (i.e. session index when era start being active)"]
      #[doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_start_session_index(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 173u8, 129u8, 28u8, 214u8, 90u8, 71u8, 13u8, 220u8, 95u8, 29u8, 98u8,
          143u8, 240u8, 85u8, 9u8, 130u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The session index at which the era start for the last `HISTORY_DEPTH` eras."]
      #[doc = ""]
      #[doc = " Note: This tracks the starting session (i.e. session index when era start being active)"]
      #[doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."]
      #[cfg(feature = "ink")]
      pub fn eras_start_session_index(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 173u8, 129u8, 28u8, 214u8, 90u8, 71u8, 13u8, 220u8, 95u8, 29u8, 98u8,
          143u8, 240u8, 85u8, 9u8, 130u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Exposure of validator at era."]
      #[doc = ""]
      #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_stakers(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 139u8, 222u8, 10u8, 14u8, 168u8, 134u8, 70u8, 5u8, 227u8, 182u8, 142u8,
          217u8, 203u8, 45u8, 160u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
          <types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Exposure of validator at era."]
      #[doc = ""]
      #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
      #[cfg(feature = "ink")]
      pub fn eras_stakers(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 139u8, 222u8, 10u8, 14u8, 168u8, 134u8, 70u8, 5u8, 227u8, 182u8, 142u8,
          217u8, 203u8, 45u8, 160u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
          <types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Clipped Exposure of validator at era."]
      #[doc = ""]
      #[doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"]
      #[doc = " `T::MaxNominatorRewardedPerValidator` biggest stakers."]
      #[doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."]
      #[doc = " This is used to limit the i/o cost for the nominator payout."]
      #[doc = ""]
      #[doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_stakers_clipped(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 66u8, 152u8, 43u8, 157u8, 108u8, 122u8, 204u8, 153u8, 250u8, 169u8, 9u8,
          76u8, 145u8, 35u8, 114u8, 194u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
          <types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Clipped Exposure of validator at era."]
      #[doc = ""]
      #[doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"]
      #[doc = " `T::MaxNominatorRewardedPerValidator` biggest stakers."]
      #[doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."]
      #[doc = " This is used to limit the i/o cost for the nominator payout."]
      #[doc = ""]
      #[doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
      #[cfg(feature = "ink")]
      pub fn eras_stakers_clipped(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 66u8, 152u8, 43u8, 157u8, 108u8, 122u8, 204u8, 153u8, 250u8, 169u8, 9u8,
          76u8, 145u8, 35u8, 114u8, 194u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
          <types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Similar to `ErasStakers`, this holds the preferences of validators."]
      #[doc = ""]
      #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_validator_prefs(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::ValidatorPrefs> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 104u8, 45u8, 185u8, 45u8, 222u8, 32u8, 161u8, 13u8, 150u8, 208u8, 15u8,
          240u8, 233u8, 226u8, 33u8, 192u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Similar to `ErasStakers`, this holds the preferences of validators."]
      #[doc = ""]
      #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[cfg(feature = "ink")]
      pub fn eras_validator_prefs(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::ValidatorPrefs> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 104u8, 45u8, 185u8, 45u8, 222u8, 32u8, 161u8, 13u8, 150u8, 208u8, 15u8,
          240u8, 233u8, 226u8, 33u8, 192u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total validator era payout for the last `HISTORY_DEPTH` eras."]
      #[doc = ""]
      #[doc = " Eras that haven't finished yet or has been removed doesn't have reward."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_validator_reward(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<Option<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 126u8, 110u8, 210u8, 238u8, 80u8, 124u8, 123u8, 68u8, 65u8, 213u8, 158u8,
          77u8, 237u8, 68u8, 184u8, 162u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The total validator era payout for the last `HISTORY_DEPTH` eras."]
      #[doc = ""]
      #[doc = " Eras that haven't finished yet or has been removed doesn't have reward."]
      #[cfg(feature = "ink")]
      pub fn eras_validator_reward(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<Option<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 126u8, 110u8, 210u8, 238u8, 80u8, 124u8, 123u8, 68u8, 65u8, 213u8, 158u8,
          77u8, 237u8, 68u8, 184u8, 162u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Rewards for the last `HISTORY_DEPTH` eras."]
      #[doc = " If reward hasn't been set or has been removed then 0 reward is returned."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_reward_points(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 128u8, 204u8, 101u8, 116u8, 40u8, 22u8, 113u8, 178u8, 153u8, 193u8, 114u8,
          125u8, 122u8, 198u8, 140u8, 171u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8];
          <types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Rewards for the last `HISTORY_DEPTH` eras."]
      #[doc = " If reward hasn't been set or has been removed then 0 reward is returned."]
      #[cfg(feature = "ink")]
      pub fn eras_reward_points(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<
        types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 128u8, 204u8, 101u8, 116u8, 40u8, 22u8, 113u8, 178u8, 153u8, 193u8, 114u8,
          125u8, 122u8, 198u8, 140u8, 171u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8];
          <types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The total amount staked for the last `HISTORY_DEPTH` eras."]
      #[doc = " If total hasn't been set or has been removed then 0 stake is returned."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_total_stake(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 161u8, 65u8, 196u8, 254u8, 103u8, 194u8, 209u8, 31u8, 74u8, 16u8, 198u8,
          172u8, 167u8, 167u8, 154u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total amount staked for the last `HISTORY_DEPTH` eras."]
      #[doc = " If total hasn't been set or has been removed then 0 stake is returned."]
      #[cfg(feature = "ink")]
      pub fn eras_total_stake(&self, key_0: u32) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 161u8, 65u8, 196u8, 254u8, 103u8, 194u8, 209u8, 31u8, 74u8, 16u8, 198u8,
          172u8, 167u8, 167u8, 154u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Mode of era forcing."]
      #[cfg(not(feature = "ink"))]
      pub async fn force_era(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::Forcing> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 247u8, 218u8, 208u8, 49u8, 115u8, 36u8, 174u8, 202u8, 232u8, 116u8, 75u8,
          135u8, 252u8, 149u8, 242u8, 243u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::Forcing>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Mode of era forcing."]
      #[cfg(feature = "ink")]
      pub fn force_era(&self) -> ::polymesh_api_ink::error::Result<types::pallet_staking::Forcing> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 247u8, 218u8, 208u8, 49u8, 115u8, 36u8, 174u8, 202u8, 232u8, 116u8, 75u8,
          135u8, 252u8, 149u8, 242u8, 243u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::Forcing>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The percentage of the slash that is distributed to reporters."]
      #[doc = ""]
      #[doc = " The rest of the slashed value is handled by the `Slash`."]
      #[cfg(not(feature = "ink"))]
      pub async fn slash_reward_fraction(
        &self,
      ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Perbill> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 194u8, 154u8, 3u8, 16u8, 225u8, 187u8, 69u8, 210u8, 12u8, 172u8, 231u8,
          124u8, 203u8, 98u8, 201u8, 125u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The percentage of the slash that is distributed to reporters."]
      #[doc = ""]
      #[doc = " The rest of the slashed value is handled by the `Slash`."]
      #[cfg(feature = "ink")]
      pub fn slash_reward_fraction(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Perbill> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 194u8, 154u8, 3u8, 16u8, 225u8, 187u8, 69u8, 210u8, 12u8, 172u8, 231u8,
          124u8, 203u8, 98u8, 201u8, 125u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The amount of currency given to reporters of a slash event which was"]
      #[doc = " canceled by extraordinary circumstances (e.g. governance)."]
      #[cfg(not(feature = "ink"))]
      pub async fn canceled_slash_payout(&self) -> ::polymesh_api_client::error::Result<u128> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 40u8, 220u8, 203u8, 85u8, 155u8, 149u8, 196u8, 1u8, 104u8, 161u8, 178u8,
          105u8, 101u8, 129u8, 181u8, 167u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The amount of currency given to reporters of a slash event which was"]
      #[doc = " canceled by extraordinary circumstances (e.g. governance)."]
      #[cfg(feature = "ink")]
      pub fn canceled_slash_payout(&self) -> ::polymesh_api_ink::error::Result<u128> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 40u8, 220u8, 203u8, 85u8, 155u8, 149u8, 196u8, 1u8, 104u8, 161u8, 178u8,
          105u8, 101u8, 129u8, 181u8, 167u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All unapplied slashes that are queued for later."]
      #[cfg(not(feature = "ink"))]
      pub async fn unapplied_slashes(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<
          types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 4u8, 40u8, 36u8, 23u8, 10u8, 93u8, 180u8, 56u8, 31u8, 227u8, 57u8, 80u8,
          57u8, 202u8, 189u8, 36u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
            types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " All unapplied slashes that are queued for later."]
      #[cfg(feature = "ink")]
      pub fn unapplied_slashes(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<
          types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 4u8, 40u8, 36u8, 23u8, 10u8, 93u8, 180u8, 56u8, 31u8, 227u8, 57u8, 80u8,
          57u8, 202u8, 189u8, 36u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
            types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " A mapping from still-bonded eras to the first session index of that era."]
      #[doc = ""]
      #[doc = " Must contains information for eras for the range:"]
      #[doc = " `[active_era - bounding_duration; active_era]`"]
      #[cfg(not(feature = "ink"))]
      pub async fn bonded_eras(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<(u32, u32)>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 234u8, 7u8, 222u8, 43u8, 143u8, 1u8, 5u8, 22u8, 220u8, 163u8, 247u8, 239u8,
          82u8, 247u8, 172u8, 90u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A mapping from still-bonded eras to the first session index of that era."]
      #[doc = ""]
      #[doc = " Must contains information for eras for the range:"]
      #[doc = " `[active_era - bounding_duration; active_era]`"]
      #[cfg(feature = "ink")]
      pub fn bonded_eras(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<(u32, u32)>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 234u8, 7u8, 222u8, 43u8, 143u8, 1u8, 5u8, 22u8, 220u8, 163u8, 247u8, 239u8,
          82u8, 247u8, 172u8, 90u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All slashing events on validators, mapped by era to the highest slash proportion"]
      #[doc = " and slash value of the era."]
      #[cfg(not(feature = "ink"))]
      pub async fn validator_slash_in_era(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<(::polymesh_api_client::per_things::Perbill, u128)>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 173u8, 110u8, 21u8, 238u8, 123u8, 253u8, 93u8, 85u8, 235u8, 161u8, 1u8,
          36u8, 135u8, 211u8, 175u8, 84u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All slashing events on validators, mapped by era to the highest slash proportion"]
      #[doc = " and slash value of the era."]
      #[cfg(feature = "ink")]
      pub fn validator_slash_in_era(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<(::polymesh_api_client::per_things::Perbill, u128)>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 173u8, 110u8, 21u8, 238u8, 123u8, 253u8, 93u8, 85u8, 235u8, 161u8, 1u8,
          36u8, 135u8, 211u8, 175u8, 84u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."]
      #[cfg(not(feature = "ink"))]
      pub async fn nominator_slash_in_era(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 129u8, 80u8, 8u8, 232u8, 33u8, 11u8, 109u8, 108u8, 247u8, 1u8, 226u8, 46u8,
          91u8, 242u8, 113u8, 65u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."]
      #[cfg(feature = "ink")]
      pub fn nominator_slash_in_era(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 129u8, 80u8, 8u8, 232u8, 33u8, 11u8, 109u8, 108u8, 247u8, 1u8, 226u8, 46u8,
          91u8, 242u8, 113u8, 65u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Slashing spans for stash accounts."]
      #[cfg(not(feature = "ink"))]
      pub async fn slashing_spans(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_staking::slashing::SlashingSpans>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 171u8, 106u8, 33u8, 43u8, 192u8, 138u8, 86u8, 3u8, 130u8, 143u8, 51u8,
          249u8, 14u8, 196u8, 161u8, 57u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Slashing spans for stash accounts."]
      #[cfg(feature = "ink")]
      pub fn slashing_spans(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_staking::slashing::SlashingSpans>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 171u8, 106u8, 33u8, 43u8, 192u8, 138u8, 86u8, 3u8, 130u8, 143u8, 51u8,
          249u8, 14u8, 196u8, 161u8, 57u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Records information about the maximum slash of a stash within a slashing span,"]
      #[doc = " as well as how much reward has been paid out."]
      #[cfg(not(feature = "ink"))]
      pub async fn span_slash(
        &self,
        key_0: (::polymesh_api_client::AccountId, u32),
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::slashing::SpanRecord<u128>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 230u8, 47u8, 111u8, 121u8, 126u8, 190u8, 145u8, 56u8, 223u8, 206u8, 217u8,
          66u8, 151u8, 127u8, 234u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::pallet_staking::slashing::SpanRecord<u128>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Records information about the maximum slash of a stash within a slashing span,"]
      #[doc = " as well as how much reward has been paid out."]
      #[cfg(feature = "ink")]
      pub fn span_slash(
        &self,
        key_0: (::polymesh_api_client::AccountId, u32),
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::slashing::SpanRecord<u128>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 230u8, 47u8, 111u8, 121u8, 126u8, 190u8, 145u8, 56u8, 223u8, 206u8, 217u8,
          66u8, 151u8, 127u8, 234u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::pallet_staking::slashing::SpanRecord<u128>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The last planned session scheduled by the session pallet."]
      #[doc = ""]
      #[doc = " This is basically in sync with the call to [`pallet_session::SessionManager::new_session`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_planned_session(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 192u8, 211u8, 159u8, 245u8, 119u8, 175u8, 44u8, 198u8, 182u8, 122u8, 195u8,
          100u8, 31u8, 169u8, 196u8, 231u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The last planned session scheduled by the session pallet."]
      #[doc = ""]
      #[doc = " This is basically in sync with the call to [`pallet_session::SessionManager::new_session`]."]
      #[cfg(feature = "ink")]
      pub fn current_planned_session(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 192u8, 211u8, 159u8, 245u8, 119u8, 175u8, 44u8, 198u8, 182u8, 122u8, 195u8,
          100u8, 31u8, 169u8, 196u8, 231u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Indices of validators that have offended in the active era and whether they are currently"]
      #[doc = " disabled."]
      #[doc = ""]
      #[doc = " This value should be a superset of disabled validators since not all offences lead to the"]
      #[doc = " validator being disabled (if there was no slash). This is needed to track the percentage of"]
      #[doc = " validators that have offended in the current era, ensuring a new era is forced if"]
      #[doc = " `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find"]
      #[doc = " whether a given validator has previously offended using binary search. It gets cleared when"]
      #[doc = " the era ends."]
      #[cfg(not(feature = "ink"))]
      pub async fn offending_validators(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<(u32, bool)>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 162u8, 114u8, 27u8, 95u8, 220u8, 1u8, 159u8, 242u8, 72u8, 47u8, 145u8,
          114u8, 171u8, 136u8, 42u8, 120u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, bool)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Indices of validators that have offended in the active era and whether they are currently"]
      #[doc = " disabled."]
      #[doc = ""]
      #[doc = " This value should be a superset of disabled validators since not all offences lead to the"]
      #[doc = " validator being disabled (if there was no slash). This is needed to track the percentage of"]
      #[doc = " validators that have offended in the current era, ensuring a new era is forced if"]
      #[doc = " `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find"]
      #[doc = " whether a given validator has previously offended using binary search. It gets cleared when"]
      #[doc = " the era ends."]
      #[cfg(feature = "ink")]
      pub fn offending_validators(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<(u32, bool)>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 162u8, 114u8, 27u8, 95u8, 220u8, 1u8, 159u8, 242u8, 72u8, 47u8, 145u8,
          114u8, 171u8, 136u8, 42u8, 120u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, bool)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The threshold for when users can start calling `chill_other` for other validators /"]
      #[doc = " nominators. The threshold is compared to the actual number of validators / nominators"]
      #[doc = " (`CountFor*`) in the system compared to the configured max (`Max*Count`)."]
      #[cfg(not(feature = "ink"))]
      pub async fn chill_threshold(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::per_things::Percent>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 205u8, 220u8, 73u8, 197u8, 243u8, 8u8, 7u8, 212u8, 116u8, 160u8, 157u8,
          112u8, 254u8, 216u8, 165u8, 105u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The threshold for when users can start calling `chill_other` for other validators /"]
      #[doc = " nominators. The threshold is compared to the actual number of validators / nominators"]
      #[doc = " (`CountFor*`) in the system compared to the configured max (`Max*Count`)."]
      #[cfg(feature = "ink")]
      pub fn chill_threshold(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::per_things::Percent>>
      {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 205u8, 220u8, 73u8, 197u8, 243u8, 8u8, 7u8, 212u8, 116u8, 160u8, 157u8,
          112u8, 254u8, 216u8, 165u8, 105u8,
        ])?;
        Ok(value)
      }
      #[doc = " Entities that are allowed to run operator/validator nodes."]
      #[cfg(not(feature = "ink"))]
      pub async fn permissioned_identity(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_staking::types::PermissionedIdentityPrefs>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 43u8, 183u8, 3u8, 134u8, 104u8, 250u8, 251u8, 247u8, 56u8, 149u8, 104u8,
          159u8, 128u8, 103u8, 131u8, 19u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Entities that are allowed to run operator/validator nodes."]
      #[cfg(feature = "ink")]
      pub fn permissioned_identity(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_staking::types::PermissionedIdentityPrefs>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 43u8, 183u8, 3u8, 134u8, 104u8, 250u8, 251u8, 247u8, 56u8, 149u8, 104u8,
          159u8, 128u8, 103u8, 131u8, 19u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Slashing switch for validators & Nominators."]
      #[cfg(not(feature = "ink"))]
      pub async fn slashing_allowed_for(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::types::SlashingSwitch>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 231u8, 118u8, 103u8, 194u8, 236u8, 24u8, 122u8, 5u8, 185u8, 143u8, 2u8,
          137u8, 239u8, 72u8, 161u8, 77u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[2u8];
          <types::pallet_staking::types::SlashingSwitch>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Slashing switch for validators & Nominators."]
      #[cfg(feature = "ink")]
      pub fn slashing_allowed_for(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::types::SlashingSwitch> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 231u8, 118u8, 103u8, 194u8, 236u8, 24u8, 122u8, 5u8, 185u8, 143u8, 2u8,
          137u8, 239u8, 72u8, 161u8, 77u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[2u8];
          <types::pallet_staking::types::SlashingSwitch>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Allows flexibility in commission. Every validator has commission that should be in the range [0, Cap]."]
      #[cfg(not(feature = "ink"))]
      pub async fn validator_commission_cap(
        &self,
      ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Perbill> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 153u8, 11u8, 115u8, 89u8, 10u8, 47u8, 61u8, 123u8, 111u8, 250u8, 62u8, 6u8,
          47u8, 110u8, 11u8, 162u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Allows flexibility in commission. Every validator has commission that should be in the range [0, Cap]."]
      #[cfg(feature = "ink")]
      pub fn validator_commission_cap(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Perbill> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 153u8, 11u8, 115u8, 89u8, 10u8, 47u8, 61u8, 123u8, 111u8, 250u8, 62u8, 6u8,
          47u8, 110u8, 11u8, 162u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(not(feature = "ink"))]
      pub async fn polymesh_storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::pallet::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 229u8, 160u8, 23u8, 132u8, 8u8, 29u8, 246u8, 130u8, 198u8, 250u8, 110u8,
          217u8, 188u8, 5u8, 228u8, 207u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::pallet::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(feature = "ink")]
      pub fn polymesh_storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::pallet::Version> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 229u8, 160u8, 23u8, 132u8, 8u8, 29u8, 246u8, 130u8, 198u8, 250u8, 110u8,
          217u8, 188u8, 5u8, 228u8, 207u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::pallet::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct StakingPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> StakingPagedQueryApi<'api> {
      #[doc = " Map from all locked \"stash\" accounts to the controller account."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      pub fn bonded(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        ::polymesh_api_client::AccountId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 62u8, 209u8, 75u8, 69u8, 237u8, 32u8, 208u8, 84u8, 240u8, 94u8, 55u8,
          226u8, 84u8, 44u8, 254u8, 112u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."]
      pub fn ledger(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_staking::StakingLedger,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 66u8, 42u8, 219u8, 87u8, 159u8, 29u8, 191u8, 79u8, 56u8, 134u8, 197u8,
          207u8, 163u8, 187u8, 140u8, 196u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Where the reward payment should be made. Keyed by stash."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      pub fn payee(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 146u8, 32u8, 225u8, 114u8, 190u8, 211u8, 22u8, 96u8, 95u8, 115u8, 241u8,
          255u8, 123u8, 74u8, 222u8, 152u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The map from (wannabe) validator stash key to the preferences of that validator."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      pub fn validators(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_staking::ValidatorPrefs,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
          252u8, 214u8, 225u8, 105u8, 3u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The map from nominator stash key to their nomination preferences, namely the validators that"]
      #[doc = " they wish to support."]
      #[doc = ""]
      #[doc = " Note that the keys of this storage map might become non-decodable in case the"]
      #[doc = " [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators"]
      #[doc = " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`"]
      #[doc = " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable"]
      #[doc = " nominators will effectively not-exist, until they re-submit their preferences such that it"]
      #[doc = " is within the bounds of the newly set `Config::MaxNominations`."]
      #[doc = ""]
      #[doc = " This implies that `::iter_keys().count()` and `::iter().count()` might return different"]
      #[doc = " values for this map. Moreover, the main `::count()` is aligned with the former, namely the"]
      #[doc = " number of keys that exist."]
      #[doc = ""]
      #[doc = " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via"]
      #[doc = " [`Call::chill_other`] dispatchable by anyone."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      pub fn nominators(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_staking::Nominations,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 156u8, 106u8, 99u8, 127u8, 98u8, 174u8, 42u8, 241u8, 199u8, 227u8, 30u8,
          237u8, 126u8, 150u8, 190u8, 4u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The session index at which the era start for the last `HISTORY_DEPTH` eras."]
      #[doc = ""]
      #[doc = " Note: This tracks the starting session (i.e. session index when era start being active)"]
      #[doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."]
      pub fn eras_start_session_index(&self) -> ::polymesh_api_client::StoragePaged<u32, u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 173u8, 129u8, 28u8, 214u8, 90u8, 71u8, 13u8, 220u8, 95u8, 29u8, 98u8,
          143u8, 240u8, 85u8, 9u8, 130u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Exposure of validator at era."]
      #[doc = ""]
      #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
      pub fn eras_stakers(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 139u8, 222u8, 10u8, 14u8, 168u8, 134u8, 70u8, 5u8, 227u8, 182u8, 142u8,
          217u8, 203u8, 45u8, 160u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Clipped Exposure of validator at era."]
      #[doc = ""]
      #[doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"]
      #[doc = " `T::MaxNominatorRewardedPerValidator` biggest stakers."]
      #[doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."]
      #[doc = " This is used to limit the i/o cost for the nominator payout."]
      #[doc = ""]
      #[doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
      pub fn eras_stakers_clipped(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 66u8, 152u8, 43u8, 157u8, 108u8, 122u8, 204u8, 153u8, 250u8, 169u8, 9u8,
          76u8, 145u8, 35u8, 114u8, 194u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Similar to `ErasStakers`, this holds the preferences of validators."]
      #[doc = ""]
      #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      pub fn eras_validator_prefs(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_staking::ValidatorPrefs,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 104u8, 45u8, 185u8, 45u8, 222u8, 32u8, 161u8, 13u8, 150u8, 208u8, 15u8,
          240u8, 233u8, 226u8, 33u8, 192u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The total validator era payout for the last `HISTORY_DEPTH` eras."]
      #[doc = ""]
      #[doc = " Eras that haven't finished yet or has been removed doesn't have reward."]
      pub fn eras_validator_reward(&self) -> ::polymesh_api_client::StoragePaged<u32, u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 126u8, 110u8, 210u8, 238u8, 80u8, 124u8, 123u8, 68u8, 65u8, 213u8, 158u8,
          77u8, 237u8, 68u8, 184u8, 162u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Rewards for the last `HISTORY_DEPTH` eras."]
      #[doc = " If reward hasn't been set or has been removed then 0 reward is returned."]
      pub fn eras_reward_points(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        u32,
        types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 128u8, 204u8, 101u8, 116u8, 40u8, 22u8, 113u8, 178u8, 153u8, 193u8, 114u8,
          125u8, 122u8, 198u8, 140u8, 171u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The total amount staked for the last `HISTORY_DEPTH` eras."]
      #[doc = " If total hasn't been set or has been removed then 0 stake is returned."]
      pub fn eras_total_stake(&self) -> ::polymesh_api_client::StoragePaged<u32, u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 161u8, 65u8, 196u8, 254u8, 103u8, 194u8, 209u8, 31u8, 74u8, 16u8, 198u8,
          172u8, 167u8, 167u8, 154u8, 4u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " All unapplied slashes that are queued for later."]
      pub fn unapplied_slashes(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        u32,
        ::alloc::vec::Vec<
          types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 4u8, 40u8, 36u8, 23u8, 10u8, 93u8, 180u8, 56u8, 31u8, 227u8, 57u8, 80u8,
          57u8, 202u8, 189u8, 36u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " All slashing events on validators, mapped by era to the highest slash proportion"]
      #[doc = " and slash value of the era."]
      pub fn validator_slash_in_era(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        (::polymesh_api_client::per_things::Perbill, u128),
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 173u8, 110u8, 21u8, 238u8, 123u8, 253u8, 93u8, 85u8, 235u8, 161u8, 1u8,
          36u8, 135u8, 211u8, 175u8, 84u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."]
      pub fn nominator_slash_in_era(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 129u8, 80u8, 8u8, 232u8, 33u8, 11u8, 109u8, 108u8, 247u8, 1u8, 226u8, 46u8,
          91u8, 242u8, 113u8, 65u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Slashing spans for stash accounts."]
      pub fn slashing_spans(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_staking::slashing::SlashingSpans,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 171u8, 106u8, 33u8, 43u8, 192u8, 138u8, 86u8, 3u8, 130u8, 143u8, 51u8,
          249u8, 14u8, 196u8, 161u8, 57u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Records information about the maximum slash of a stash within a slashing span,"]
      #[doc = " as well as how much reward has been paid out."]
      pub fn span_slash(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        (::polymesh_api_client::AccountId, u32),
        types::pallet_staking::slashing::SpanRecord<u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 230u8, 47u8, 111u8, 121u8, 126u8, 190u8, 145u8, 56u8, 223u8, 206u8, 217u8,
          66u8, 151u8, 127u8, 234u8, 80u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Entities that are allowed to run operator/validator nodes."]
      pub fn permissioned_identity(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::IdentityId,
        types::pallet_staking::types::PermissionedIdentityPrefs,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 43u8, 183u8, 3u8, 134u8, 104u8, 250u8, 251u8, 247u8, 56u8, 149u8, 104u8,
          159u8, 128u8, 103u8, 131u8, 19u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod offences {
    use super::*;
    #[derive(Clone)]
    pub struct OffencesCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> OffencesCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for OffencesCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct OffencesQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> OffencesQueryApi<'api> {
      #[doc = " The primary structure that holds all offence records keyed by report identifiers."]
      #[cfg(not(feature = "ink"))]
      pub async fn reports(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::sp_staking::offence::OffenceDetails<
            ::polymesh_api_client::AccountId,
            (
              ::polymesh_api_client::AccountId,
              types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
            ),
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 178u8, 98u8, 233u8, 35u8, 143u8, 164u8, 2u8, 84u8, 12u8, 37u8, 11u8,
          195u8, 245u8, 214u8, 24u8, 141u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The primary structure that holds all offence records keyed by report identifiers."]
      #[cfg(feature = "ink")]
      pub fn reports(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::sp_staking::offence::OffenceDetails<
            ::polymesh_api_client::AccountId,
            (
              ::polymesh_api_client::AccountId,
              types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
            ),
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 178u8, 98u8, 233u8, 35u8, 143u8, 164u8, 2u8, 84u8, 12u8, 37u8, 11u8,
          195u8, 245u8, 214u8, 24u8, 141u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A vector of reports of the same kind that happened at the same time slot."]
      #[cfg(not(feature = "ink"))]
      pub async fn concurrent_reports_index(
        &self,
        key_0: [u8; 16usize],
        key_1: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 96u8, 220u8, 142u8, 240u8, 0u8, 205u8, 189u8, 200u8, 89u8, 221u8,
          53u8, 34u8, 41u8, 206u8, 22u8, 251u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A vector of reports of the same kind that happened at the same time slot."]
      #[cfg(feature = "ink")]
      pub fn concurrent_reports_index(
        &self,
        key_0: [u8; 16usize],
        key_1: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 96u8, 220u8, 142u8, 240u8, 0u8, 205u8, 189u8, 200u8, 89u8, 221u8,
          53u8, 34u8, 41u8, 206u8, 22u8, 251u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Enumerates all reports of a kind along with the time they happened."]
      #[doc = ""]
      #[doc = " All reports are sorted by the time of offence."]
      #[doc = ""]
      #[doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"]
      #[doc = " different types are not supported at the moment so we are doing the manual serialization."]
      #[cfg(not(feature = "ink"))]
      pub async fn reports_by_kind_index(
        &self,
        key_0: [u8; 16usize],
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 53u8, 137u8, 192u8, 218u8, 197u8, 13u8, 166u8, 251u8, 58u8, 54u8,
          17u8, 235u8, 50u8, 188u8, 210u8, 126u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Enumerates all reports of a kind along with the time they happened."]
      #[doc = ""]
      #[doc = " All reports are sorted by the time of offence."]
      #[doc = ""]
      #[doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"]
      #[doc = " different types are not supported at the moment so we are doing the manual serialization."]
      #[cfg(feature = "ink")]
      pub fn reports_by_kind_index(
        &self,
        key_0: [u8; 16usize],
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 53u8, 137u8, 192u8, 218u8, 197u8, 13u8, 166u8, 251u8, 58u8, 54u8,
          17u8, 235u8, 50u8, 188u8, 210u8, 126u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct OffencesPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> OffencesPagedQueryApi<'api> {
      #[doc = " The primary structure that holds all offence records keyed by report identifiers."]
      pub fn reports(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::primitive_types::H256,
        types::sp_staking::offence::OffenceDetails<
          ::polymesh_api_client::AccountId,
          (
            ::polymesh_api_client::AccountId,
            types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
          ),
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 178u8, 98u8, 233u8, 35u8, 143u8, 164u8, 2u8, 84u8, 12u8, 37u8, 11u8,
          195u8, 245u8, 214u8, 24u8, 141u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " A vector of reports of the same kind that happened at the same time slot."]
      pub fn concurrent_reports_index(
        &self,
        key_0: [u8; 16usize],
      ) -> ::polymesh_api_client::StoragePaged<
        ::alloc::vec::Vec<u8>,
        ::alloc::vec::Vec<types::primitive_types::H256>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 96u8, 220u8, 142u8, 240u8, 0u8, 205u8, 189u8, 200u8, 89u8, 221u8,
          53u8, 34u8, 41u8, 206u8, 22u8, 251u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Enumerates all reports of a kind along with the time they happened."]
      #[doc = ""]
      #[doc = " All reports are sorted by the time of offence."]
      #[doc = ""]
      #[doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"]
      #[doc = " different types are not supported at the moment so we are doing the manual serialization."]
      pub fn reports_by_kind_index(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<[u8; 16usize], ::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 53u8, 137u8, 192u8, 218u8, 197u8, 13u8, 166u8, 251u8, 58u8, 54u8,
          17u8, 235u8, 50u8, 188u8, 210u8, 126u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod session {
    use super::*;
    #[derive(Clone)]
    pub struct SessionCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> SessionCallApi<'api> {
      #[doc = "Sets the session key(s) of the function caller to `keys`."]
      #[doc = "Allows an account to set its session key prior to becoming a validator."]
      #[doc = "This doesn't take effect until the next session."]
      #[doc = ""]
      #[doc = "The dispatch origin of this function must be signed."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"]
      #[doc = "  fixed."]
      #[cfg(not(feature = "ink"))]
      pub fn set_keys(
        &self,
        keys: runtime::SessionKeys,
        proof: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Session(
          types::pallet_session::pallet::SessionCall::set_keys { keys, proof },
        ))
      }
      #[doc = "Sets the session key(s) of the function caller to `keys`."]
      #[doc = "Allows an account to set its session key prior to becoming a validator."]
      #[doc = "This doesn't take effect until the next session."]
      #[doc = ""]
      #[doc = "The dispatch origin of this function must be signed."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"]
      #[doc = "  fixed."]
      #[cfg(feature = "ink")]
      pub fn set_keys(
        &self,
        keys: runtime::SessionKeys,
        proof: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![19u8, 0u8];
        keys.encode_to(&mut buf);
        proof.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes any session key(s) of the function caller."]
      #[doc = ""]
      #[doc = "This doesn't take effect until the next session."]
      #[doc = ""]
      #[doc = "The dispatch origin of this function must be Signed and the account must be either be"]
      #[doc = "convertible to a validator ID using the chain's typical addressing system (this usually"]
      #[doc = "means being a controller account) or directly convertible into a validator ID (which"]
      #[doc = "usually means being a stash account)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"]
      #[doc = "  `T::Keys::key_ids()` which is fixed."]
      #[cfg(not(feature = "ink"))]
      pub fn purge_keys(&self) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Session(
          types::pallet_session::pallet::SessionCall::purge_keys,
        ))
      }
      #[doc = "Removes any session key(s) of the function caller."]
      #[doc = ""]
      #[doc = "This doesn't take effect until the next session."]
      #[doc = ""]
      #[doc = "The dispatch origin of this function must be Signed and the account must be either be"]
      #[doc = "convertible to a validator ID using the chain's typical addressing system (this usually"]
      #[doc = "means being a controller account) or directly convertible into a validator ID (which"]
      #[doc = "usually means being a stash account)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"]
      #[doc = "  `T::Keys::key_ids()` which is fixed."]
      #[cfg(feature = "ink")]
      pub fn purge_keys(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![19u8, 1u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for SessionCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct SessionQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> SessionQueryApi<'api> {
      #[doc = " The current set of validators."]
      #[cfg(not(feature = "ink"))]
      pub async fn validators(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::AccountId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8,
          250u8, 252u8, 214u8, 225u8, 105u8, 3u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current set of validators."]
      #[cfg(feature = "ink")]
      pub fn validators(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::AccountId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8,
          250u8, 252u8, 214u8, 225u8, 105u8, 3u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current index of the session."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_index(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 114u8, 118u8, 56u8, 0u8, 163u8, 106u8, 153u8, 253u8, 252u8, 124u8,
          16u8, 246u8, 65u8, 95u8, 110u8, 230u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current index of the session."]
      #[cfg(feature = "ink")]
      pub fn current_index(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 114u8, 118u8, 56u8, 0u8, 163u8, 106u8, 153u8, 253u8, 252u8, 124u8,
          16u8, 246u8, 65u8, 95u8, 110u8, 230u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if the underlying economic identities or weighting behind the validators"]
      #[doc = " has changed in the queued validator set."]
      #[cfg(not(feature = "ink"))]
      pub async fn queued_changed(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 148u8, 80u8, 191u8, 164u8, 185u8, 106u8, 63u8, 167u8, 163u8, 200u8,
          244u8, 13u8, 166u8, 191u8, 50u8, 225u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if the underlying economic identities or weighting behind the validators"]
      #[doc = " has changed in the queued validator set."]
      #[cfg(feature = "ink")]
      pub fn queued_changed(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 148u8, 80u8, 191u8, 164u8, 185u8, 106u8, 63u8, 167u8, 163u8, 200u8,
          244u8, 13u8, 166u8, 191u8, 50u8, 225u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The queued keys for the next session. When the next session begins, these keys"]
      #[doc = " will be used to determine the validator's session keys."]
      #[cfg(not(feature = "ink"))]
      pub async fn queued_keys(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<(::polymesh_api_client::AccountId, runtime::SessionKeys)>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 224u8, 205u8, 208u8, 98u8, 230u8, 234u8, 242u8, 66u8, 149u8, 173u8,
          76u8, 207u8, 196u8, 29u8, 70u8, 9u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(::polymesh_api_client::AccountId, runtime::SessionKeys)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The queued keys for the next session. When the next session begins, these keys"]
      #[doc = " will be used to determine the validator's session keys."]
      #[cfg(feature = "ink")]
      pub fn queued_keys(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<(::polymesh_api_client::AccountId, runtime::SessionKeys)>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 224u8, 205u8, 208u8, 98u8, 230u8, 234u8, 242u8, 66u8, 149u8, 173u8,
          76u8, 207u8, 196u8, 29u8, 70u8, 9u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(::polymesh_api_client::AccountId, runtime::SessionKeys)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Indices of disabled validators."]
      #[doc = ""]
      #[doc = " The vec is always kept sorted so that we can find whether a given validator is"]
      #[doc = " disabled using binary search. It gets cleared when `on_session_ending` returns"]
      #[doc = " a new set of identities."]
      #[cfg(not(feature = "ink"))]
      pub async fn disabled_validators(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 90u8, 154u8, 116u8, 190u8, 74u8, 90u8, 125u8, 246u8, 11u8, 1u8,
          166u8, 192u8, 50u8, 108u8, 94u8, 32u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Indices of disabled validators."]
      #[doc = ""]
      #[doc = " The vec is always kept sorted so that we can find whether a given validator is"]
      #[doc = " disabled using binary search. It gets cleared when `on_session_ending` returns"]
      #[doc = " a new set of identities."]
      #[cfg(feature = "ink")]
      pub fn disabled_validators(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 90u8, 154u8, 116u8, 190u8, 74u8, 90u8, 125u8, 246u8, 11u8, 1u8,
          166u8, 192u8, 50u8, 108u8, 94u8, 32u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next session keys for a validator."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_keys(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<runtime::SessionKeys>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 76u8, 1u8, 78u8, 107u8, 248u8, 184u8, 194u8, 192u8, 17u8, 231u8,
          41u8, 11u8, 133u8, 105u8, 107u8, 179u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The next session keys for a validator."]
      #[cfg(feature = "ink")]
      pub fn next_keys(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<runtime::SessionKeys>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 76u8, 1u8, 78u8, 107u8, 248u8, 184u8, 194u8, 192u8, 17u8, 231u8,
          41u8, 11u8, 133u8, 105u8, 107u8, 179u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."]
      #[cfg(not(feature = "ink"))]
      pub async fn key_owner(
        &self,
        key_0: (types::sp_core::crypto::KeyTypeId, ::alloc::vec::Vec<u8>),
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 114u8, 99u8, 128u8, 64u8, 70u8, 131u8, 252u8, 137u8, 232u8, 35u8,
          52u8, 80u8, 200u8, 170u8, 25u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."]
      #[cfg(feature = "ink")]
      pub fn key_owner(
        &self,
        key_0: (types::sp_core::crypto::KeyTypeId, ::alloc::vec::Vec<u8>),
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 114u8, 99u8, 128u8, 64u8, 70u8, 131u8, 252u8, 137u8, 232u8, 35u8,
          52u8, 80u8, 200u8, 170u8, 25u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct SessionPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> SessionPagedQueryApi<'api> {
      #[doc = " The next session keys for a validator."]
      pub fn next_keys(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, runtime::SessionKeys>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 76u8, 1u8, 78u8, 107u8, 248u8, 184u8, 194u8, 192u8, 17u8, 231u8,
          41u8, 11u8, 133u8, 105u8, 107u8, 179u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."]
      pub fn key_owner(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        (types::sp_core::crypto::KeyTypeId, ::alloc::vec::Vec<u8>),
        ::polymesh_api_client::AccountId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 114u8, 99u8, 128u8, 64u8, 70u8, 131u8, 252u8, 137u8, 232u8, 35u8,
          52u8, 80u8, 200u8, 170u8, 25u8, 80u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod authority_discovery {
    use super::*;
    #[derive(Clone)]
    pub struct AuthorityDiscoveryCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> AuthorityDiscoveryCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for AuthorityDiscoveryCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct AuthorityDiscoveryQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> AuthorityDiscoveryQueryApi<'api> {}
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct AuthorityDiscoveryPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> AuthorityDiscoveryPagedQueryApi<'api> {}
  }
  pub mod grandpa {
    use super::*;
    #[derive(Clone)]
    pub struct GrandpaCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> GrandpaCallApi<'api> {
      #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
      #[doc = "equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence"]
      #[doc = "will be reported."]
      #[cfg(not(feature = "ink"))]
      pub fn report_equivocation(
        &self,
        equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
          types::primitive_types::H256,
          u32,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Grandpa(
          types::pallet_grandpa::pallet::GrandpaCall::report_equivocation {
            equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
            key_owner_proof,
          },
        ))
      }
      #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
      #[doc = "equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence"]
      #[doc = "will be reported."]
      #[cfg(feature = "ink")]
      pub fn report_equivocation(
        &self,
        equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
          types::primitive_types::H256,
          u32,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![21u8, 0u8];
        equivocation_proof.encode_to(&mut buf);
        key_owner_proof.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
      #[doc = "equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence"]
      #[doc = "will be reported."]
      #[doc = ""]
      #[doc = "This extrinsic must be called unsigned and it is expected that only"]
      #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
      #[doc = "if the block author is defined it will be defined as the equivocation"]
      #[doc = "reporter."]
      #[cfg(not(feature = "ink"))]
      pub fn report_equivocation_unsigned(
        &self,
        equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
          types::primitive_types::H256,
          u32,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Grandpa(
          types::pallet_grandpa::pallet::GrandpaCall::report_equivocation_unsigned {
            equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
            key_owner_proof,
          },
        ))
      }
      #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
      #[doc = "equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence"]
      #[doc = "will be reported."]
      #[doc = ""]
      #[doc = "This extrinsic must be called unsigned and it is expected that only"]
      #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
      #[doc = "if the block author is defined it will be defined as the equivocation"]
      #[doc = "reporter."]
      #[cfg(feature = "ink")]
      pub fn report_equivocation_unsigned(
        &self,
        equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
          types::primitive_types::H256,
          u32,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![21u8, 1u8];
        equivocation_proof.encode_to(&mut buf);
        key_owner_proof.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."]
      #[doc = ""]
      #[doc = "This will trigger a forced authority set change at the beginning of the next session, to"]
      #[doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"]
      #[doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."]
      #[doc = "The block production rate (which may be slowed down because of finality lagging) should"]
      #[doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"]
      #[doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"]
      #[doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"]
      #[doc = "block of all validators of the new authority set."]
      #[doc = ""]
      #[doc = "Only callable by root."]
      #[cfg(not(feature = "ink"))]
      pub fn note_stalled(
        &self,
        delay: u32,
        best_finalized_block_number: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Grandpa(
          types::pallet_grandpa::pallet::GrandpaCall::note_stalled {
            delay,
            best_finalized_block_number,
          },
        ))
      }
      #[doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."]
      #[doc = ""]
      #[doc = "This will trigger a forced authority set change at the beginning of the next session, to"]
      #[doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"]
      #[doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."]
      #[doc = "The block production rate (which may be slowed down because of finality lagging) should"]
      #[doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"]
      #[doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"]
      #[doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"]
      #[doc = "block of all validators of the new authority set."]
      #[doc = ""]
      #[doc = "Only callable by root."]
      #[cfg(feature = "ink")]
      pub fn note_stalled(
        &self,
        delay: u32,
        best_finalized_block_number: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![21u8, 2u8];
        delay.encode_to(&mut buf);
        best_finalized_block_number.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for GrandpaCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct GrandpaQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> GrandpaQueryApi<'api> {
      #[doc = " State of the current authority set."]
      #[cfg(not(feature = "ink"))]
      pub async fn state(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_grandpa::StoredState<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 243u8, 154u8, 16u8, 127u8, 45u8, 141u8, 56u8, 84u8, 201u8, 171u8,
          169u8, 176u8, 33u8, 244u8, 61u8, 156u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_grandpa::StoredState<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " State of the current authority set."]
      #[cfg(feature = "ink")]
      pub fn state(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_grandpa::StoredState<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 243u8, 154u8, 16u8, 127u8, 45u8, 141u8, 56u8, 84u8, 201u8, 171u8,
          169u8, 176u8, 33u8, 244u8, 61u8, 156u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_grandpa::StoredState<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Pending change: (signaled at, scheduled change)."]
      #[cfg(not(feature = "ink"))]
      pub async fn pending_change(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_grandpa::StoredPendingChange<u32>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 47u8, 246u8, 89u8, 145u8, 177u8, 201u8, 21u8, 221u8, 108u8, 200u8,
          212u8, 130u8, 94u8, 172u8, 252u8, 180u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Pending change: (signaled at, scheduled change)."]
      #[cfg(feature = "ink")]
      pub fn pending_change(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_grandpa::StoredPendingChange<u32>>>
      {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 47u8, 246u8, 89u8, 145u8, 177u8, 201u8, 21u8, 221u8, 108u8, 200u8,
          212u8, 130u8, 94u8, 172u8, 252u8, 180u8,
        ])?;
        Ok(value)
      }
      #[doc = " next block number where we can force a change."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_forced(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 1u8, 215u8, 129u8, 129u8, 38u8, 189u8, 155u8, 48u8, 116u8, 128u8,
          62u8, 145u8, 244u8, 201u8, 27u8, 89u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " next block number where we can force a change."]
      #[cfg(feature = "ink")]
      pub fn next_forced(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 1u8, 215u8, 129u8, 129u8, 38u8, 189u8, 155u8, 48u8, 116u8, 128u8,
          62u8, 145u8, 244u8, 201u8, 27u8, 89u8,
        ])?;
        Ok(value)
      }
      #[doc = " `true` if we are currently stalled."]
      #[cfg(not(feature = "ink"))]
      pub async fn stalled(&self) -> ::polymesh_api_client::error::Result<Option<(u32, u32)>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 125u8, 221u8, 1u8, 52u8, 97u8, 183u8, 44u8, 48u8, 4u8, 249u8, 192u8,
          202u8, 63u8, 175u8, 158u8, 190u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " `true` if we are currently stalled."]
      #[cfg(feature = "ink")]
      pub fn stalled(&self) -> ::polymesh_api_ink::error::Result<Option<(u32, u32)>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 125u8, 221u8, 1u8, 52u8, 97u8, 183u8, 44u8, 48u8, 4u8, 249u8, 192u8,
          202u8, 63u8, 175u8, 158u8, 190u8,
        ])?;
        Ok(value)
      }
      #[doc = " The number of changes (both in terms of keys and underlying economic responsibilities)"]
      #[doc = " in the \"set\" of Grandpa validators from genesis."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_set_id(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 138u8, 45u8, 9u8, 70u8, 62u8, 255u8, 204u8, 120u8, 162u8, 45u8,
          117u8, 185u8, 203u8, 135u8, 223u8, 252u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The number of changes (both in terms of keys and underlying economic responsibilities)"]
      #[doc = " in the \"set\" of Grandpa validators from genesis."]
      #[cfg(feature = "ink")]
      pub fn current_set_id(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 138u8, 45u8, 9u8, 70u8, 62u8, 255u8, 204u8, 120u8, 162u8, 45u8,
          117u8, 185u8, 203u8, 135u8, 223u8, 252u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"]
      #[doc = " members were responsible."]
      #[doc = ""]
      #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
      #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
      #[doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"]
      #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
      #[doc = " during that session."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: `SetId` is not under user control."]
      #[cfg(not(feature = "ink"))]
      pub async fn set_id_session(
        &self,
        key_0: u64,
      ) -> ::polymesh_api_client::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8, 67u8, 221u8, 251u8,
          54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"]
      #[doc = " members were responsible."]
      #[doc = ""]
      #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
      #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
      #[doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"]
      #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
      #[doc = " during that session."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: `SetId` is not under user control."]
      #[cfg(feature = "ink")]
      pub fn set_id_session(&self, key_0: u64) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8, 67u8, 221u8, 251u8,
          54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct GrandpaPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> GrandpaPagedQueryApi<'api> {
      #[doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"]
      #[doc = " members were responsible."]
      #[doc = ""]
      #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
      #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
      #[doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"]
      #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
      #[doc = " during that session."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: `SetId` is not under user control."]
      pub fn set_id_session(&self) -> ::polymesh_api_client::StoragePaged<u64, u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8, 67u8, 221u8, 251u8,
          54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod historical {
    use super::*;
    #[derive(Clone)]
    pub struct HistoricalCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> HistoricalCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for HistoricalCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct HistoricalQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> HistoricalQueryApi<'api> {}
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct HistoricalPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> HistoricalPagedQueryApi<'api> {}
  }
  pub mod im_online {
    use super::*;
    #[derive(Clone)]
    pub struct ImOnlineCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ImOnlineCallApi<'api> {
      #[doc = "## Complexity:"]
      #[doc = "- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of"]
      #[doc = "  `heartbeat.network_state.external_address`"]
      #[doc = "  - `O(K)`: decoding of length `K`"]
      #[doc = "  - `O(E)`: decoding/encoding of length `E`"]
      #[cfg(not(feature = "ink"))]
      pub fn heartbeat(
        &self,
        heartbeat: types::pallet_im_online::Heartbeat<u32>,
        signature: types::pallet_im_online::sr25519::app_sr25519::Signature,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ImOnline(
          types::pallet_im_online::pallet::ImOnlineCall::heartbeat {
            heartbeat,
            signature,
          },
        ))
      }
      #[doc = "## Complexity:"]
      #[doc = "- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of"]
      #[doc = "  `heartbeat.network_state.external_address`"]
      #[doc = "  - `O(K)`: decoding of length `K`"]
      #[doc = "  - `O(E)`: decoding/encoding of length `E`"]
      #[cfg(feature = "ink")]
      pub fn heartbeat(
        &self,
        heartbeat: types::pallet_im_online::Heartbeat<u32>,
        signature: types::pallet_im_online::sr25519::app_sr25519::Signature,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![23u8, 0u8];
        heartbeat.encode_to(&mut buf);
        signature.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ImOnlineCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ImOnlineQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ImOnlineQueryApi<'api> {
      #[doc = " The block number after which it's ok to send heartbeats in the current"]
      #[doc = " session."]
      #[doc = ""]
      #[doc = " At the beginning of each session we set this to a value that should fall"]
      #[doc = " roughly in the middle of the session duration. The idea is to first wait for"]
      #[doc = " the validators to produce a block in the current session, so that the"]
      #[doc = " heartbeat later on will not be necessary."]
      #[doc = ""]
      #[doc = " This value will only be used as a fallback if we fail to get a proper session"]
      #[doc = " progress estimate from `NextSessionRotation`, as those estimates should be"]
      #[doc = " more accurate then the value we calculate for `HeartbeatAfter`."]
      #[cfg(not(feature = "ink"))]
      pub async fn heartbeat_after(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 138u8, 161u8, 242u8, 201u8, 132u8, 79u8, 17u8, 2u8, 76u8, 29u8,
          32u8, 78u8, 112u8, 90u8, 98u8, 23u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The block number after which it's ok to send heartbeats in the current"]
      #[doc = " session."]
      #[doc = ""]
      #[doc = " At the beginning of each session we set this to a value that should fall"]
      #[doc = " roughly in the middle of the session duration. The idea is to first wait for"]
      #[doc = " the validators to produce a block in the current session, so that the"]
      #[doc = " heartbeat later on will not be necessary."]
      #[doc = ""]
      #[doc = " This value will only be used as a fallback if we fail to get a proper session"]
      #[doc = " progress estimate from `NextSessionRotation`, as those estimates should be"]
      #[doc = " more accurate then the value we calculate for `HeartbeatAfter`."]
      #[cfg(feature = "ink")]
      pub fn heartbeat_after(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 138u8, 161u8, 242u8, 201u8, 132u8, 79u8, 17u8, 2u8, 76u8, 29u8,
          32u8, 78u8, 112u8, 90u8, 98u8, 23u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current set of keys that may issue a heartbeat."]
      #[cfg(not(feature = "ink"))]
      pub async fn keys(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::pallet_im_online::sr25519::app_sr25519::Public>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 159u8, 153u8, 162u8, 206u8, 113u8, 31u8, 58u8, 49u8, 178u8, 252u8,
          5u8, 96u8, 76u8, 147u8, 241u8, 121u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_im_online::sr25519::app_sr25519::Public>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The current set of keys that may issue a heartbeat."]
      #[cfg(feature = "ink")]
      pub fn keys(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::pallet_im_online::sr25519::app_sr25519::Public>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 159u8, 153u8, 162u8, 206u8, 113u8, 31u8, 58u8, 49u8, 178u8, 252u8,
          5u8, 96u8, 76u8, 147u8, 241u8, 121u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_im_online::sr25519::app_sr25519::Public>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to"]
      #[doc = " `WrapperOpaque<BoundedOpaqueNetworkState>`."]
      #[cfg(not(feature = "ink"))]
      pub async fn received_heartbeats(
        &self,
        key_0: u32,
        key_1: u32,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::frame_support::traits::misc::WrapperOpaque<
            types::pallet_im_online::BoundedOpaqueNetworkState,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 204u8, 90u8, 26u8, 166u8, 227u8, 113u8, 99u8, 114u8, 243u8, 110u8,
          241u8, 3u8, 183u8, 227u8, 174u8, 103u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to"]
      #[doc = " `WrapperOpaque<BoundedOpaqueNetworkState>`."]
      #[cfg(feature = "ink")]
      pub fn received_heartbeats(
        &self,
        key_0: u32,
        key_1: u32,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::frame_support::traits::misc::WrapperOpaque<
            types::pallet_im_online::BoundedOpaqueNetworkState,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 204u8, 90u8, 26u8, 166u8, 227u8, 113u8, 99u8, 114u8, 243u8, 110u8,
          241u8, 3u8, 183u8, 227u8, 174u8, 103u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"]
      #[doc = " number of blocks authored by the given authority."]
      #[cfg(not(feature = "ink"))]
      pub async fn authored_blocks(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 177u8, 195u8, 113u8, 222u8, 217u8, 233u8, 197u8, 101u8, 232u8,
          155u8, 167u8, 131u8, 196u8, 213u8, 245u8, 249u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"]
      #[doc = " number of blocks authored by the given authority."]
      #[cfg(feature = "ink")]
      pub fn authored_blocks(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 177u8, 195u8, 113u8, 222u8, 217u8, 233u8, 197u8, 101u8, 232u8,
          155u8, 167u8, 131u8, 196u8, 213u8, 245u8, 249u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct ImOnlinePagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> ImOnlinePagedQueryApi<'api> {
      #[doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to"]
      #[doc = " `WrapperOpaque<BoundedOpaqueNetworkState>`."]
      pub fn received_heartbeats(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::StoragePaged<
        u32,
        types::frame_support::traits::misc::WrapperOpaque<
          types::pallet_im_online::BoundedOpaqueNetworkState,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 204u8, 90u8, 26u8, 166u8, 227u8, 113u8, 99u8, 114u8, 243u8, 110u8,
          241u8, 3u8, 183u8, 227u8, 174u8, 103u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"]
      #[doc = " number of blocks authored by the given authority."]
      pub fn authored_blocks(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 177u8, 195u8, 113u8, 222u8, 217u8, 233u8, 197u8, 101u8, 232u8,
          155u8, 167u8, 131u8, 196u8, 213u8, 245u8, 249u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod randomness_collective_flip {
    use super::*;
    #[derive(Clone)]
    pub struct RandomnessCollectiveFlipCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> RandomnessCollectiveFlipCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for RandomnessCollectiveFlipCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct RandomnessCollectiveFlipQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> RandomnessCollectiveFlipQueryApi<'api> {
      #[doc = " Series of block headers from the last 81 blocks that acts as random seed material. This"]
      #[doc = " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of"]
      #[doc = " the oldest hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn random_material(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 42u8, 82u8, 147u8, 121u8, 71u8, 80u8, 136u8, 211u8, 226u8, 154u8, 145u8, 140u8,
          212u8, 120u8, 114u8, 26u8, 57u8, 236u8, 118u8, 123u8, 213u8, 38u8, 145u8, 17u8, 230u8,
          73u8, 42u8, 22u8, 117u8, 112u8, 42u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Series of block headers from the last 81 blocks that acts as random seed material. This"]
      #[doc = " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of"]
      #[doc = " the oldest hash."]
      #[cfg(feature = "ink")]
      pub fn random_material(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 42u8, 82u8, 147u8, 121u8, 71u8, 80u8, 136u8, 211u8, 226u8, 154u8, 145u8, 140u8,
          212u8, 120u8, 114u8, 26u8, 57u8, 236u8, 118u8, 123u8, 213u8, 38u8, 145u8, 17u8, 230u8,
          73u8, 42u8, 22u8, 117u8, 112u8, 42u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct RandomnessCollectiveFlipPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> RandomnessCollectiveFlipPagedQueryApi<'api> {}
  }
  pub mod asset {
    use super::*;
    #[derive(Clone)]
    pub struct AssetCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> AssetCallApi<'api> {
      #[doc = "Registers a unique ticker or extends the validity of an existing ticker."]
      #[doc = ""]
      #[doc = "This function allows the caller to register a new ticker or extend the registration"]
      #[doc = "of an existing ticker. The ticker validity does not carry forward when renewing."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ticker` - The ticker to register."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerRegistered` - When a ticker is successfully registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerAlreadyRegistered` - If the ticker is already registered."]
      #[doc = "* `TickerTooLong` - If the ticker length exceeds the maximum allowed length."]
      #[doc = "* `InvalidTickerCharacter` - If the ticker contains invalid characters."]
      #[cfg(not(feature = "ink"))]
      pub fn register_unique_ticker(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::register_unique_ticker { ticker },
        ))
      }
      #[doc = "Registers a unique ticker or extends the validity of an existing ticker."]
      #[doc = ""]
      #[doc = "This function allows the caller to register a new ticker or extend the registration"]
      #[doc = "of an existing ticker. The ticker validity does not carry forward when renewing."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ticker` - The ticker to register."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerRegistered` - When a ticker is successfully registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerAlreadyRegistered` - If the ticker is already registered."]
      #[doc = "* `TickerTooLong` - If the ticker length exceeds the maximum allowed length."]
      #[doc = "* `InvalidTickerCharacter` - If the ticker contains invalid characters."]
      #[cfg(feature = "ink")]
      pub fn register_unique_ticker(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 0u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accepts a ticker transfer."]
      #[doc = ""]
      #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `auth_id` - Authorization ID of ticker transfer authorization."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerTransferred` - When a ticker is successfully transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
      #[cfg(not(feature = "ink"))]
      pub fn accept_ticker_transfer(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::accept_ticker_transfer { auth_id },
        ))
      }
      #[doc = "Accepts a ticker transfer."]
      #[doc = ""]
      #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `auth_id` - Authorization ID of ticker transfer authorization."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerTransferred` - When a ticker is successfully transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
      #[cfg(feature = "ink")]
      pub fn accept_ticker_transfer(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 1u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accepts an asset ownership transfer."]
      #[doc = ""]
      #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `auth_id` - Authorization ID of the asset ownership transfer authorization."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetOwnershipTransferred` - When a asset ownership is successfully transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
      #[cfg(not(feature = "ink"))]
      pub fn accept_asset_ownership_transfer(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::accept_asset_ownership_transfer { auth_id },
        ))
      }
      #[doc = "Accepts an asset ownership transfer."]
      #[doc = ""]
      #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `auth_id` - Authorization ID of the asset ownership transfer authorization."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetOwnershipTransferred` - When a asset ownership is successfully transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
      #[cfg(feature = "ink")]
      pub fn accept_asset_ownership_transfer(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 2u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Creates a new asset."]
      #[doc = ""]
      #[doc = "The total supply will initially be zero. To mint tokens, use [`Module::issue`]."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
      #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
      #[doc = "* `asset_type` - The [`AssetType`] of the new asset."]
      #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
      #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetCreated` - When a new asset is successfully created."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
      #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
      #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
      #[cfg(not(feature = "ink"))]
      pub fn create_asset(
        &self,
        asset_name: types::polymesh_primitives::asset::AssetName,
        divisible: bool,
        asset_type: types::polymesh_primitives::asset::AssetType,
        asset_identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
        funding_round_name: Option<types::polymesh_primitives::asset::FundingRoundName>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::create_asset {
            asset_name,
            divisible,
            asset_type,
            asset_identifiers,
            funding_round_name,
          },
        ))
      }
      #[doc = "Creates a new asset."]
      #[doc = ""]
      #[doc = "The total supply will initially be zero. To mint tokens, use [`Module::issue`]."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
      #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
      #[doc = "* `asset_type` - The [`AssetType`] of the new asset."]
      #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
      #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetCreated` - When a new asset is successfully created."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
      #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
      #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
      #[cfg(feature = "ink")]
      pub fn create_asset(
        &self,
        asset_name: types::polymesh_primitives::asset::AssetName,
        divisible: bool,
        asset_type: types::polymesh_primitives::asset::AssetType,
        asset_identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
        funding_round_name: Option<types::polymesh_primitives::asset::FundingRoundName>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 3u8];
        asset_name.encode_to(&mut buf);
        divisible.encode_to(&mut buf);
        asset_type.encode_to(&mut buf);
        asset_identifiers.encode_to(&mut buf);
        funding_round_name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Freezes transfers of a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to freeze transfers of a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The asset to freeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetFrozen` - When an asset is successfully frozen."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `AlreadyFrozen` - If the asset is already frozen."]
      #[cfg(not(feature = "ink"))]
      pub fn freeze(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::freeze { asset_id },
        ))
      }
      #[doc = "Freezes transfers of a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to freeze transfers of a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The asset to freeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetFrozen` - When an asset is successfully frozen."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `AlreadyFrozen` - If the asset is already frozen."]
      #[cfg(feature = "ink")]
      pub fn freeze(&self, asset_id: ::polymesh_api_client::AssetId) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 4u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Unfreezes transfers of a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to unfreeze transfers of a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The asset to unfreeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetUnfrozen` - When an asset is successfully unfrozen."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `NotFrozen` - If the asset is not frozen."]
      #[cfg(not(feature = "ink"))]
      pub fn unfreeze(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::unfreeze { asset_id },
        ))
      }
      #[doc = "Unfreezes transfers of a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to unfreeze transfers of a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The asset to unfreeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetUnfrozen` - When an asset is successfully unfrozen."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `NotFrozen` - If the asset is not frozen."]
      #[cfg(feature = "ink")]
      pub fn unfreeze(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 5u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the [`AssetName`] associated to an asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to update the name of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `asset_name` - The new [`AssetName`] that will be associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetRenamed` - When an asset is successfully renamed."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[cfg(not(feature = "ink"))]
      pub fn rename_asset(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        asset_name: types::polymesh_primitives::asset::AssetName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::rename_asset {
            asset_id,
            asset_name,
          },
        ))
      }
      #[doc = "Updates the [`AssetName`] associated to an asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to update the name of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `asset_name` - The new [`AssetName`] that will be associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetRenamed` - When an asset is successfully renamed."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[cfg(feature = "ink")]
      pub fn rename_asset(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        asset_name: types::polymesh_primitives::asset::AssetName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 6u8];
        asset_id.encode_to(&mut buf);
        asset_name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Issue (i.e mint) new tokens to the caller, which must be an authorized external agent."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to mint new tokens for a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: A signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
      #[doc = "* `amount`: The amount of tokens that will be issued."]
      #[doc = "* `portfolio_kind`: The [`PortfolioKind`] of the portfolio that will receive the minted tokens."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `InvalidGranularity` - If the amount to issue does not meet the granularity requirements."]
      #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
      #[cfg(not(feature = "ink"))]
      pub fn issue(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        amount: u128,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::issue {
            asset_id,
            amount,
            portfolio_kind,
          },
        ))
      }
      #[doc = "Issue (i.e mint) new tokens to the caller, which must be an authorized external agent."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to mint new tokens for a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: A signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
      #[doc = "* `amount`: The amount of tokens that will be issued."]
      #[doc = "* `portfolio_kind`: The [`PortfolioKind`] of the portfolio that will receive the minted tokens."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `InvalidGranularity` - If the amount to issue does not meet the granularity requirements."]
      #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
      #[cfg(feature = "ink")]
      pub fn issue(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        amount: u128,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 7u8];
        asset_id.encode_to(&mut buf);
        amount.encode_to(&mut buf);
        portfolio_kind.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Redeems (i.e burns) existing tokens by reducing the balance of the caller's portfolio and the total supply of the asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to redeem tokens from a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
      #[doc = "* `value`: amount of tokens to redeem."]
      #[doc = "* `portfolio_kind`: the [`PortfolioKind`] that will have its balance reduced."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `InvalidGranularity` - If the value to redeem does not meet the granularity requirements."]
      #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
      #[cfg(not(feature = "ink"))]
      pub fn redeem(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        value: u128,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::redeem {
            asset_id,
            value,
            portfolio_kind,
          },
        ))
      }
      #[doc = "Redeems (i.e burns) existing tokens by reducing the balance of the caller's portfolio and the total supply of the asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to redeem tokens from a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
      #[doc = "* `value`: amount of tokens to redeem."]
      #[doc = "* `portfolio_kind`: the [`PortfolioKind`] that will have its balance reduced."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `InvalidGranularity` - If the value to redeem does not meet the granularity requirements."]
      #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
      #[cfg(feature = "ink")]
      pub fn redeem(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        value: u128,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 8u8];
        asset_id.encode_to(&mut buf);
        value.encode_to(&mut buf);
        portfolio_kind.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "If the asset associated to `asset_id` is indivisible, sets [`AssetDetails::divisible`] to true."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to make an indivisible asset divisible."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `DivisibilityChanged` - When the divisibility of an asset is successfully changed."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `AssetAlreadyDivisible` - If the asset is already divisible."]
      #[cfg(not(feature = "ink"))]
      pub fn make_divisible(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::make_divisible { asset_id },
        ))
      }
      #[doc = "If the asset associated to `asset_id` is indivisible, sets [`AssetDetails::divisible`] to true."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to make an indivisible asset divisible."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `DivisibilityChanged` - When the divisibility of an asset is successfully changed."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `AssetAlreadyDivisible` - If the asset is already divisible."]
      #[cfg(feature = "ink")]
      pub fn make_divisible(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 9u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Add documents for a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to add documents to an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `docs` - Documents to be attached to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `DocumentAdded` - When a document is successfully added to an asset."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `CounterOverflow` - If the document ID counter overflows."]
      #[cfg(not(feature = "ink"))]
      pub fn add_documents(
        &self,
        docs: ::alloc::vec::Vec<types::polymesh_primitives::document::Document>,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::add_documents { docs, asset_id },
        ))
      }
      #[doc = "Add documents for a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to add documents to an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `docs` - Documents to be attached to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `DocumentAdded` - When a document is successfully added to an asset."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `CounterOverflow` - If the document ID counter overflows."]
      #[cfg(feature = "ink")]
      pub fn add_documents(
        &self,
        docs: ::alloc::vec::Vec<types::polymesh_primitives::document::Document>,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 10u8];
        docs.encode_to(&mut buf);
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove documents for a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove documents from an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `docs_id` - A vector of all [`DocumentId`] that will be removed from the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `DocumentRemoved` - When a document is successfully removed from an asset."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_documents(
        &self,
        docs_id: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_documents { docs_id, asset_id },
        ))
      }
      #[doc = "Remove documents for a given asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove documents from an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `docs_id` - A vector of all [`DocumentId`] that will be removed from the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `DocumentRemoved` - When a document is successfully removed from an asset."]
      #[cfg(feature = "ink")]
      pub fn remove_documents(
        &self,
        docs_id: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 11u8];
        docs_id.encode_to(&mut buf);
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets the name of the current funding round."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to set the name of the current funding round for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `funding_round_name` - The [`FundingRoundName`] of the current funding round."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `FundingRoundSet` - When the funding round name is successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FundingRoundNameMaxLengthExceeded` - If the funding round name length exceeds the maximum allowed length."]
      #[cfg(not(feature = "ink"))]
      pub fn set_funding_round(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        funding_round_name: types::polymesh_primitives::asset::FundingRoundName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::set_funding_round {
            asset_id,
            funding_round_name,
          },
        ))
      }
      #[doc = "Sets the name of the current funding round."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to set the name of the current funding round for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `funding_round_name` - The [`FundingRoundName`] of the current funding round."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `FundingRoundSet` - When the funding round name is successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FundingRoundNameMaxLengthExceeded` - If the funding round name length exceeds the maximum allowed length."]
      #[cfg(feature = "ink")]
      pub fn set_funding_round(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        funding_round_name: types::polymesh_primitives::asset::FundingRoundName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 12u8];
        asset_id.encode_to(&mut buf);
        funding_round_name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the asset identifiers associated to the asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to update the asset identifiers for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`] that will be associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `IdentifiersUpdated` - When the asset identifiers are successfully updated."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
      #[cfg(not(feature = "ink"))]
      pub fn update_identifiers(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        asset_identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::update_identifiers {
            asset_id,
            asset_identifiers,
          },
        ))
      }
      #[doc = "Updates the asset identifiers associated to the asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to update the asset identifiers for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`] that will be associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `IdentifiersUpdated` - When the asset identifiers are successfully updated."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
      #[cfg(feature = "ink")]
      pub fn update_identifiers(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        asset_identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 13u8];
        asset_id.encode_to(&mut buf);
        asset_identifiers.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Forces a transfer of tokens from `from_portfolio` to the caller's default portfolio."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to force a transfer of tokens from one portfolio to another."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `value` - The [`Balance`] of tokens that will be transferred."]
      #[doc = "* `from_portfolio` - The [`PortfolioId`] that will have its balance reduced."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `ControllerTransfer` - When tokens are successfully transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `InvalidGranularity` - If the amount to transfer does not meet the granularity requirements."]
      #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
      #[cfg(not(feature = "ink"))]
      pub fn controller_transfer(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        value: u128,
        from_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::controller_transfer {
            asset_id,
            value,
            from_portfolio,
          },
        ))
      }
      #[doc = "Forces a transfer of tokens from `from_portfolio` to the caller's default portfolio."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to force a transfer of tokens from one portfolio to another."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `value` - The [`Balance`] of tokens that will be transferred."]
      #[doc = "* `from_portfolio` - The [`PortfolioId`] that will have its balance reduced."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `ControllerTransfer` - When tokens are successfully transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
      #[doc = "* `InvalidGranularity` - If the amount to transfer does not meet the granularity requirements."]
      #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
      #[cfg(feature = "ink")]
      pub fn controller_transfer(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        value: u128,
        from_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 14u8];
        asset_id.encode_to(&mut buf);
        value.encode_to(&mut buf);
        from_portfolio.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Registers a custom asset type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ty` - Contains the string representation of the asset type."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
      #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
      #[cfg(not(feature = "ink"))]
      pub fn register_custom_asset_type(
        &self,
        ty: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::register_custom_asset_type { ty },
        ))
      }
      #[doc = "Registers a custom asset type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ty` - Contains the string representation of the asset type."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
      #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
      #[cfg(feature = "ink")]
      pub fn register_custom_asset_type(
        &self,
        ty: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 15u8];
        ty.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Creates a new asset with a new custom asset type."]
      #[doc = ""]
      #[doc = "The total supply will initially be zero. To mint tokens, use [`Module::issue`]."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
      #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
      #[doc = "* `custom_asset_type` - The custom asset type of the asset."]
      #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
      #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetCreated` - When a new asset is successfully created."]
      #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
      #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
      #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
      #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
      #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
      #[cfg(not(feature = "ink"))]
      pub fn create_asset_with_custom_type(
        &self,
        asset_name: types::polymesh_primitives::asset::AssetName,
        divisible: bool,
        custom_asset_type: ::alloc::vec::Vec<u8>,
        asset_identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
        funding_round_name: Option<types::polymesh_primitives::asset::FundingRoundName>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::create_asset_with_custom_type {
            asset_name,
            divisible,
            custom_asset_type,
            asset_identifiers,
            funding_round_name,
          },
        ))
      }
      #[doc = "Creates a new asset with a new custom asset type."]
      #[doc = ""]
      #[doc = "The total supply will initially be zero. To mint tokens, use [`Module::issue`]."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
      #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
      #[doc = "* `custom_asset_type` - The custom asset type of the asset."]
      #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
      #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetCreated` - When a new asset is successfully created."]
      #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
      #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
      #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
      #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
      #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
      #[cfg(feature = "ink")]
      pub fn create_asset_with_custom_type(
        &self,
        asset_name: types::polymesh_primitives::asset::AssetName,
        divisible: bool,
        custom_asset_type: ::alloc::vec::Vec<u8>,
        asset_identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
        funding_round_name: Option<types::polymesh_primitives::asset::FundingRoundName>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 16u8];
        asset_name.encode_to(&mut buf);
        divisible.encode_to(&mut buf);
        custom_asset_type.encode_to(&mut buf);
        asset_identifiers.encode_to(&mut buf);
        funding_round_name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set asset metadata value."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to set metadata for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
      #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
      #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
      #[cfg(not(feature = "ink"))]
      pub fn set_asset_metadata(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::set_asset_metadata {
            asset_id,
            key,
            value,
            detail,
          },
        ))
      }
      #[doc = "Set asset metadata value."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to set metadata for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
      #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
      #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
      #[cfg(feature = "ink")]
      pub fn set_asset_metadata(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 17u8];
        asset_id.encode_to(&mut buf);
        key.encode_to(&mut buf);
        value.encode_to(&mut buf);
        detail.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set asset metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to set metadata details for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
      #[doc = "* `details` - The [`AssetMetadataValueDetail`] (expire, lock status) that will be associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `SetAssetMetadataValueDetails` - When the asset metadata value details are successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataValueIsEmpty` - If the metadata value is empty."]
      #[cfg(not(feature = "ink"))]
      pub fn set_asset_metadata_details(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        detail: types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::set_asset_metadata_details {
            asset_id,
            key,
            detail,
          },
        ))
      }
      #[doc = "Set asset metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to set metadata details for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
      #[doc = "* `details` - The [`AssetMetadataValueDetail`] (expire, lock status) that will be associated to the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `SetAssetMetadataValueDetails` - When the asset metadata value details are successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataValueIsEmpty` - If the metadata value is empty."]
      #[cfg(feature = "ink")]
      pub fn set_asset_metadata_details(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        detail: types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 18u8];
        asset_id.encode_to(&mut buf);
        key.encode_to(&mut buf);
        detail.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Registers and set local asset metadata."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to register and set local metadata for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `name` - The [`AssetMetadataName`]."]
      #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
      #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
      #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
      #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
      #[cfg(not(feature = "ink"))]
      pub fn register_and_set_local_asset_metadata(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
        value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::register_and_set_local_asset_metadata {
            asset_id,
            name,
            spec,
            value,
            detail,
          },
        ))
      }
      #[doc = "Registers and set local asset metadata."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to register and set local metadata for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `name` - The [`AssetMetadataName`]."]
      #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
      #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
      #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
      #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
      #[cfg(feature = "ink")]
      pub fn register_and_set_local_asset_metadata(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
        value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 19u8];
        asset_id.encode_to(&mut buf);
        name.encode_to(&mut buf);
        spec.encode_to(&mut buf);
        value.encode_to(&mut buf);
        detail.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Registers asset metadata local type."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to register a local metadata type for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `name` - The [`AssetMetadataName`]."]
      #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
      #[cfg(not(feature = "ink"))]
      pub fn register_asset_metadata_local_type(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::register_asset_metadata_local_type {
            asset_id,
            name,
            spec,
          },
        ))
      }
      #[doc = "Registers asset metadata local type."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to register a local metadata type for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `name` - The [`AssetMetadataName`]."]
      #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
      #[cfg(feature = "ink")]
      pub fn register_asset_metadata_local_type(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 20u8];
        asset_id.encode_to(&mut buf);
        name.encode_to(&mut buf);
        spec.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Registers asset metadata global type."]
      #[doc = ""]
      #[doc = "This function allows the root origin to register a global metadata type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The root origin."]
      #[doc = "* `name` - The [`AssetMetadataName`]."]
      #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RegisterAssetMetadataGlobalType` - When the global asset metadata type is successfully registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataGlobalKeyAlreadyExists` - If the global metadata key already exists."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
      #[cfg(not(feature = "ink"))]
      pub fn register_asset_metadata_global_type(
        &self,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::register_asset_metadata_global_type { name, spec },
        ))
      }
      #[doc = "Registers asset metadata global type."]
      #[doc = ""]
      #[doc = "This function allows the root origin to register a global metadata type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The root origin."]
      #[doc = "* `name` - The [`AssetMetadataName`]."]
      #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RegisterAssetMetadataGlobalType` - When the global asset metadata type is successfully registered."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataGlobalKeyAlreadyExists` - If the global metadata key already exists."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
      #[cfg(feature = "ink")]
      pub fn register_asset_metadata_global_type(
        &self,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 21u8];
        name.encode_to(&mut buf);
        spec.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the type of an asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to update the type of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `asset_type` - The new [`AssetType`] of the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetTypeChanged` - When the asset type is successfully changed."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
      #[doc = "* `IncompatibleAssetTypeUpdate` - If the new asset type is incompatible with the existing asset type."]
      #[cfg(not(feature = "ink"))]
      pub fn update_asset_type(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        asset_type: types::polymesh_primitives::asset::AssetType,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::update_asset_type {
            asset_id,
            asset_type,
          },
        ))
      }
      #[doc = "Updates the type of an asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to update the type of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
      #[doc = "* `asset_type` - The new [`AssetType`] of the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetTypeChanged` - When the asset type is successfully changed."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchAsset` - If the asset does not exist."]
      #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
      #[doc = "* `IncompatibleAssetTypeUpdate` - If the new asset type is incompatible with the existing asset type."]
      #[cfg(feature = "ink")]
      pub fn update_asset_type(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        asset_type: types::polymesh_primitives::asset::AssetType,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 22u8];
        asset_id.encode_to(&mut buf);
        asset_type.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the asset metadata key and value of a local key."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove a local metadata key and its value for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the local metadata key."]
      #[doc = "* `local_key` - The [`AssetMetadataLocalKey`] that will be removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `LocalMetadataKeyDeleted` - When the local metadata key is successfully deleted."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the local metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataKeyBelongsToNFTCollection` - If the metadata key belongs to an NFT collection."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_local_metadata_key(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        local_key: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_local_metadata_key {
            asset_id,
            local_key,
          },
        ))
      }
      #[doc = "Removes the asset metadata key and value of a local key."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove a local metadata key and its value for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the local metadata key."]
      #[doc = "* `local_key` - The [`AssetMetadataLocalKey`] that will be removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `LocalMetadataKeyDeleted` - When the local metadata key is successfully deleted."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the local metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[doc = "* `AssetMetadataKeyBelongsToNFTCollection` - If the metadata key belongs to an NFT collection."]
      #[cfg(feature = "ink")]
      pub fn remove_local_metadata_key(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        local_key: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 23u8];
        asset_id.encode_to(&mut buf);
        local_key.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the asset metadata value of a metadata key."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove a metadata value for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the metadata key."]
      #[doc = "* `metadata_key` - The [`AssetMetadataKey`] that will have its value deleted."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `MetadataValueDeleted` - When the metadata value is successfully deleted."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_metadata_value(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        metadata_key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_metadata_value {
            asset_id,
            metadata_key,
          },
        ))
      }
      #[doc = "Removes the asset metadata value of a metadata key."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove a metadata value for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] associated to the metadata key."]
      #[doc = "* `metadata_key` - The [`AssetMetadataKey`] that will have its value deleted."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `MetadataValueDeleted` - When the metadata value is successfully deleted."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
      #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
      #[cfg(feature = "ink")]
      pub fn remove_metadata_value(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        metadata_key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 24u8];
        asset_id.encode_to(&mut buf);
        metadata_key.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Pre-approves the receivement of the asset for all identities."]
      #[doc = ""]
      #[doc = "This function allows the root origin to pre-approve the receivement of an asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The root origin."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetAffirmationExemption` - When the asset is successfully exempted from affirmation."]
      #[cfg(not(feature = "ink"))]
      pub fn exempt_asset_affirmation(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::exempt_asset_affirmation { asset_id },
        ))
      }
      #[doc = "Pre-approves the receivement of the asset for all identities."]
      #[doc = ""]
      #[doc = "This function allows the root origin to pre-approve the receivement of an asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The root origin."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetAffirmationExemption` - When the asset is successfully exempted from affirmation."]
      #[cfg(feature = "ink")]
      pub fn exempt_asset_affirmation(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 25u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the pre-approval of the asset for all identities."]
      #[doc = ""]
      #[doc = "This function allows the root origin to remove the pre-approval of an asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The root origin."]
      #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RemoveAssetAffirmationExemption` - When the asset's affirmation exemption is successfully removed."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_asset_affirmation_exemption(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_asset_affirmation_exemption { asset_id },
        ))
      }
      #[doc = "Removes the pre-approval of the asset for all identities."]
      #[doc = ""]
      #[doc = "This function allows the root origin to remove the pre-approval of an asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The root origin."]
      #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RemoveAssetAffirmationExemption` - When the asset's affirmation exemption is successfully removed."]
      #[cfg(feature = "ink")]
      pub fn remove_asset_affirmation_exemption(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 26u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Pre-approves the receivement of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `PreApprovedAsset` - When the asset is successfully pre-approved for receivement."]
      #[cfg(not(feature = "ink"))]
      pub fn pre_approve_asset(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::pre_approve_asset { asset_id },
        ))
      }
      #[doc = "Pre-approves the receivement of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `PreApprovedAsset` - When the asset is successfully pre-approved for receivement."]
      #[cfg(feature = "ink")]
      pub fn pre_approve_asset(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 27u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the pre-approval of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RemovePreApprovedAsset` - When the asset's pre-approval is successfully removed."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_asset_pre_approval(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_asset_pre_approval { asset_id },
        ))
      }
      #[doc = "Removes the pre-approval of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `RemovePreApprovedAsset` - When the asset's pre-approval is successfully removed."]
      #[cfg(feature = "ink")]
      pub fn remove_asset_pre_approval(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 28u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets all identities in the `mediators` set as mandatory mediators for any instruction transferring `asset_id`."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to add mandatory mediators for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] of the asset that will require the mediators."]
      #[doc = "* `mediators` - A set of [`IdentityId`] of all the mandatory mediators for the given ticker."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetMediatorsAdded` - When the mandatory mediators are successfully added."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NumberOfAssetMediatorsExceeded` - If the number of mandatory mediators exceeds the maximum allowed limit."]
      #[cfg(not(feature = "ink"))]
      pub fn add_mandatory_mediators(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::add_mandatory_mediators {
            asset_id,
            mediators,
          },
        ))
      }
      #[doc = "Sets all identities in the `mediators` set as mandatory mediators for any instruction transferring `asset_id`."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to add mandatory mediators for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] of the asset that will require the mediators."]
      #[doc = "* `mediators` - A set of [`IdentityId`] of all the mandatory mediators for the given ticker."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetMediatorsAdded` - When the mandatory mediators are successfully added."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NumberOfAssetMediatorsExceeded` - If the number of mandatory mediators exceeds the maximum allowed limit."]
      #[cfg(feature = "ink")]
      pub fn add_mandatory_mediators(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 29u8];
        asset_id.encode_to(&mut buf);
        mediators.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes all identities in the `mediators` set from the mandatory mediators list for the given `asset_id`."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove mandatory mediators for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] of the asset that will have mediators removed."]
      #[doc = "* `mediators` - A set of [`IdentityId`] of all the mediators that will be removed from the mandatory mediators list."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetMediatorsRemoved` - When the mandatory mediators are successfully removed."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_mandatory_mediators(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_mandatory_mediators {
            asset_id,
            mediators,
          },
        ))
      }
      #[doc = "Removes all identities in the `mediators` set from the mandatory mediators list for the given `asset_id`."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to remove mandatory mediators for an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `asset_id` - The [`AssetId`] of the asset that will have mediators removed."]
      #[doc = "* `mediators` - A set of [`IdentityId`] of all the mediators that will be removed from the mandatory mediators list."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `AssetMediatorsRemoved` - When the mandatory mediators are successfully removed."]
      #[cfg(feature = "ink")]
      pub fn remove_mandatory_mediators(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 30u8];
        asset_id.encode_to(&mut buf);
        mediators.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Establishes a connection between a ticker and an AssetId."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to link a ticker to an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ticker` - The [`Ticker`] that will be linked to the given `asset_id`."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be connected to `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerLinkedToAsset` - When the ticker is successfully linked to the asset."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
      #[doc = "* `TickerRegistrationExpired` - If the ticker registration has expired."]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
      #[doc = "* `AssetIsAlreadyLinkedToATicker` - If the asset is already linked to a ticker."]
      #[cfg(not(feature = "ink"))]
      pub fn link_ticker_to_asset_id(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::link_ticker_to_asset_id { ticker, asset_id },
        ))
      }
      #[doc = "Establishes a connection between a ticker and an AssetId."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to link a ticker to an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ticker` - The [`Ticker`] that will be linked to the given `asset_id`."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be connected to `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerLinkedToAsset` - When the ticker is successfully linked to the asset."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
      #[doc = "* `TickerRegistrationExpired` - If the ticker registration has expired."]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
      #[doc = "* `AssetIsAlreadyLinkedToATicker` - If the asset is already linked to a ticker."]
      #[cfg(feature = "ink")]
      pub fn link_ticker_to_asset_id(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 31u8];
        ticker.encode_to(&mut buf);
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the link between a ticker and an asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to unlink a ticker from an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ticker` - The [`Ticker`] that will be unlinked from the given `asset_id`."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be unlinked from `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerUnlinkedFromAsset` - When the ticker is successfully unlinked from the asset."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsNotLinkedToTheAsset` - If the ticker is not linked to the asset."]
      #[cfg(not(feature = "ink"))]
      pub fn unlink_ticker_from_asset_id(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::unlink_ticker_from_asset_id { ticker, asset_id },
        ))
      }
      #[doc = "Removes the link between a ticker and an asset."]
      #[doc = ""]
      #[doc = "This function allows the asset issuer or an external agent to unlink a ticker from an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
      #[doc = "* `ticker` - The [`Ticker`] that will be unlinked from the given `asset_id`."]
      #[doc = "* `asset_id` - The [`AssetId`] that will be unlinked from `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = ""]
      #[doc = "# Events"]
      #[doc = "* `TickerUnlinkedFromAsset` - When the ticker is successfully unlinked from the asset."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
      #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
      #[doc = "* `TickerIsNotLinkedToTheAsset` - If the ticker is not linked to the asset."]
      #[cfg(feature = "ink")]
      pub fn unlink_ticker_from_asset_id(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 32u8];
        ticker.encode_to(&mut buf);
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for AssetCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct AssetQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> AssetQueryApi<'api> {
      #[doc = " Maps each [`Ticker`] to its registration details ([`TickerRegistration`])."]
      #[cfg(not(feature = "ink"))]
      pub async fn unique_ticker_registration(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_asset::types::TickerRegistration<u64>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 121u8, 181u8, 109u8, 199u8, 4u8, 80u8, 93u8, 65u8, 21u8, 24u8, 9u8,
          66u8, 56u8, 123u8, 250u8, 186u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Maps each [`Ticker`] to its registration details ([`TickerRegistration`])."]
      #[cfg(feature = "ink")]
      pub fn unique_ticker_registration(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_asset::types::TickerRegistration<u64>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 121u8, 181u8, 109u8, 199u8, 4u8, 80u8, 93u8, 65u8, 21u8, 24u8, 9u8,
          66u8, 56u8, 123u8, 250u8, 186u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Returns [`TickerRegistrationConfig`] for assessing if a ticker is valid."]
      #[cfg(not(feature = "ink"))]
      pub async fn ticker_config(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_asset::types::TickerRegistrationConfig<u64>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 185u8, 113u8, 30u8, 121u8, 127u8, 46u8, 243u8, 186u8, 159u8, 108u8,
          75u8, 247u8, 236u8, 154u8, 169u8, 176u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_asset::types::TickerRegistrationConfig<u64>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Returns [`TickerRegistrationConfig`] for assessing if a ticker is valid."]
      #[cfg(feature = "ink")]
      pub fn ticker_config(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::pallet_asset::types::TickerRegistrationConfig<u64>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 185u8, 113u8, 30u8, 121u8, 127u8, 46u8, 243u8, 186u8, 159u8, 108u8,
          75u8, 247u8, 236u8, 154u8, 169u8, 176u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_asset::types::TickerRegistrationConfig<u64>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Maps each [`AssetId`] to its underling [`AssetDetails`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn assets(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_asset::types::AssetDetails>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 104u8, 42u8, 89u8, 213u8, 26u8, 185u8, 228u8, 138u8, 140u8, 140u8,
          196u8, 24u8, 255u8, 151u8, 8u8, 210u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Maps each [`AssetId`] to its underling [`AssetDetails`]."]
      #[cfg(feature = "ink")]
      pub fn assets(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_asset::types::AssetDetails>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 104u8, 42u8, 89u8, 213u8, 26u8, 185u8, 228u8, 138u8, 140u8, 140u8,
          196u8, 24u8, 255u8, 151u8, 8u8, 210u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Maps each [`AssetId`] to its underling [`AssetName`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_names(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::asset::AssetName>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 123u8, 195u8, 250u8, 203u8, 235u8, 133u8, 90u8, 23u8, 143u8, 10u8,
          8u8, 53u8, 96u8, 109u8, 5u8, 206u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Maps each [`AssetId`] to its underling [`AssetName`]."]
      #[cfg(feature = "ink")]
      pub fn asset_names(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::asset::AssetName>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 123u8, 195u8, 250u8, 203u8, 235u8, 133u8, 90u8, 23u8, 143u8, 10u8,
          8u8, 53u8, 96u8, 109u8, 5u8, 206u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Tracks the total [`Balance`] for each [`AssetId`] per [`IdentityId`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn balance_of(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 106u8, 75u8, 187u8, 251u8, 206u8, 1u8, 124u8, 102u8, 14u8, 227u8,
          176u8, 68u8, 23u8, 115u8, 19u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks the total [`Balance`] for each [`AssetId`] per [`IdentityId`]."]
      #[cfg(feature = "ink")]
      pub fn balance_of(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 106u8, 75u8, 187u8, 251u8, 206u8, 1u8, 124u8, 102u8, 14u8, 227u8,
          176u8, 68u8, 23u8, 115u8, 19u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps each [`AssetId`] to its asset identifiers ([`AssetIdentifier`])."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_identifiers(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset_identifier::AssetIdentifier>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 178u8, 193u8, 1u8, 161u8, 14u8, 189u8, 176u8, 94u8, 104u8, 54u8,
          170u8, 144u8, 16u8, 162u8, 98u8, 190u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                            types::polymesh_primitives::asset_identifier::AssetIdentifier,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
        }))
      }
      #[doc = " Maps each [`AssetId`] to its asset identifiers ([`AssetIdentifier`])."]
      #[cfg(feature = "ink")]
      pub fn asset_identifiers(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset_identifier::AssetIdentifier>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 178u8, 193u8, 1u8, 161u8, 14u8, 189u8, 176u8, 94u8, 104u8, 54u8,
          170u8, 144u8, 16u8, 162u8, 98u8, 190u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                            types::polymesh_primitives::asset_identifier::AssetIdentifier,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
        }))
      }
      #[doc = " The next `AssetType::Custom` ID in the sequence."]
      #[doc = ""]
      #[doc = " Numbers in the sequence start from 1 rather than 0."]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_type_id_sequence(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::asset::CustomAssetTypeId>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 16u8, 121u8, 19u8, 48u8, 14u8, 106u8, 39u8, 83u8, 29u8, 145u8, 209u8,
          187u8, 190u8, 66u8, 165u8, 176u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset::CustomAssetTypeId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next `AssetType::Custom` ID in the sequence."]
      #[doc = ""]
      #[doc = " Numbers in the sequence start from 1 rather than 0."]
      #[cfg(feature = "ink")]
      pub fn custom_type_id_sequence(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::asset::CustomAssetTypeId>
      {
        let value = self.api.read_storage(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 16u8, 121u8, 19u8, 48u8, 14u8, 106u8, 39u8, 83u8, 29u8, 145u8, 209u8,
          187u8, 190u8, 66u8, 165u8, 176u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset::CustomAssetTypeId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps custom asset type ids to the registered string contents."]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_types(
        &self,
        key_0: types::polymesh_primitives::asset::CustomAssetTypeId,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 214u8, 35u8, 90u8, 254u8, 57u8, 243u8, 210u8, 34u8, 193u8, 0u8, 96u8,
          131u8, 116u8, 109u8, 49u8, 166u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps custom asset type ids to the registered string contents."]
      #[cfg(feature = "ink")]
      pub fn custom_types(
        &self,
        key_0: types::polymesh_primitives::asset::CustomAssetTypeId,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 214u8, 35u8, 90u8, 254u8, 57u8, 243u8, 210u8, 34u8, 193u8, 0u8, 96u8,
          131u8, 116u8, 109u8, 49u8, 166u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Inverse map of `CustomTypes`, from registered string contents to custom asset type ids."]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_types_inverse(
        &self,
        key_0: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset::CustomAssetTypeId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 2u8, 147u8, 168u8, 237u8, 90u8, 35u8, 218u8, 237u8, 169u8, 231u8,
          223u8, 32u8, 46u8, 15u8, 228u8, 85u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Inverse map of `CustomTypes`, from registered string contents to custom asset type ids."]
      #[cfg(feature = "ink")]
      pub fn custom_types_inverse(
        &self,
        key_0: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset::CustomAssetTypeId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 2u8, 147u8, 168u8, 237u8, 90u8, 35u8, 218u8, 237u8, 169u8, 231u8,
          223u8, 32u8, 46u8, 15u8, 228u8, 85u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Maps each [`AssetId`] to the name of its founding round ([`FundingRoundName`])."]
      #[cfg(not(feature = "ink"))]
      pub async fn funding_round(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::asset::FundingRoundName>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 93u8, 34u8, 9u8, 253u8, 168u8, 224u8, 203u8, 196u8, 69u8, 133u8, 25u8,
          204u8, 124u8, 207u8, 104u8, 5u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::asset::FundingRoundName>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps each [`AssetId`] to the name of its founding round ([`FundingRoundName`])."]
      #[cfg(feature = "ink")]
      pub fn funding_round(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::asset::FundingRoundName>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 93u8, 34u8, 9u8, 253u8, 168u8, 224u8, 203u8, 196u8, 69u8, 133u8, 25u8,
          204u8, 124u8, 207u8, 104u8, 5u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::asset::FundingRoundName>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total [`Balance`] of tokens issued in all recorded funding rounds ([`FundingRoundName`])."]
      #[cfg(not(feature = "ink"))]
      pub async fn issued_in_funding_round(
        &self,
        key_0: (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::asset::FundingRoundName,
        ),
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 215u8, 137u8, 60u8, 134u8, 127u8, 54u8, 56u8, 208u8, 215u8, 148u8,
          185u8, 185u8, 12u8, 48u8, 135u8, 44u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total [`Balance`] of tokens issued in all recorded funding rounds ([`FundingRoundName`])."]
      #[cfg(feature = "ink")]
      pub fn issued_in_funding_round(
        &self,
        key_0: (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::asset::FundingRoundName,
        ),
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 215u8, 137u8, 60u8, 134u8, 127u8, 54u8, 56u8, 208u8, 215u8, 148u8,
          185u8, 185u8, 12u8, 48u8, 135u8, 44u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Returns `true` if transfers for the asset are frozen. Otherwise, returns `false`."]
      #[cfg(not(feature = "ink"))]
      pub async fn frozen(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8, 93u8, 238u8, 240u8,
          115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Returns `true` if transfers for the asset are frozen. Otherwise, returns `false`."]
      #[cfg(feature = "ink")]
      pub fn frozen(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8, 93u8, 238u8, 240u8,
          115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All [`Document`] attached to an asset."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_documents(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::document::DocumentId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::document::Document>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 166u8, 167u8, 74u8, 143u8, 116u8, 237u8, 66u8, 137u8, 149u8, 40u8,
          102u8, 20u8, 236u8, 96u8, 52u8, 9u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All [`Document`] attached to an asset."]
      #[cfg(feature = "ink")]
      pub fn asset_documents(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::document::DocumentId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::document::Document>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 166u8, 167u8, 74u8, 143u8, 116u8, 237u8, 66u8, 137u8, 149u8, 40u8,
          102u8, 20u8, 236u8, 96u8, 52u8, 9u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " [`DocumentId`] counter per [`AssetId`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_documents_id_sequence(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::document::DocumentId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 201u8, 198u8, 40u8, 95u8, 195u8, 158u8, 100u8, 69u8, 247u8, 3u8, 87u8,
          5u8, 57u8, 71u8, 8u8, 63u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::document::DocumentId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " [`DocumentId`] counter per [`AssetId`]."]
      #[cfg(feature = "ink")]
      pub fn asset_documents_id_sequence(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::document::DocumentId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 201u8, 198u8, 40u8, 95u8, 195u8, 158u8, 100u8, 69u8, 247u8, 3u8, 87u8,
          5u8, 57u8, 71u8, 8u8, 63u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::document::DocumentId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Metatdata values for an asset."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_values(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataValue>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 12u8, 236u8, 10u8, 112u8, 182u8, 190u8, 51u8, 243u8, 171u8, 240u8,
          46u8, 214u8, 255u8, 55u8, 188u8, 48u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Metatdata values for an asset."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_values(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataValue>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 12u8, 236u8, 10u8, 112u8, 182u8, 190u8, 51u8, 243u8, 171u8, 240u8,
          46u8, 214u8, 255u8, 55u8, 188u8, 48u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Details for an asset's Metadata values."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_value_details(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 177u8, 107u8, 241u8, 225u8, 188u8, 86u8, 141u8, 84u8, 219u8, 116u8,
          115u8, 57u8, 230u8, 243u8, 42u8, 93u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Details for an asset's Metadata values."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_value_details(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 177u8, 107u8, 241u8, 225u8, 188u8, 86u8, 141u8, 84u8, 219u8, 116u8,
          115u8, 57u8, 230u8, 243u8, 42u8, 93u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Name -> Key."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_local_name_to_key(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataName,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 132u8, 79u8, 149u8, 0u8, 75u8, 89u8, 31u8, 241u8, 75u8, 208u8, 41u8,
          159u8, 32u8, 36u8, 73u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Name -> Key."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_local_name_to_key(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataName,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 132u8, 79u8, 149u8, 0u8, 75u8, 89u8, 31u8, 241u8, 75u8, 208u8, 41u8,
          159u8, 32u8, 36u8, 73u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Name -> Key."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_global_name_to_key(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataName,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 27u8, 55u8, 255u8, 139u8, 76u8, 15u8, 234u8, 246u8, 25u8, 194u8,
          110u8, 238u8, 121u8, 209u8, 31u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Name -> Key."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_global_name_to_key(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataName,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 27u8, 55u8, 255u8, 139u8, 76u8, 15u8, 234u8, 246u8, 25u8, 194u8,
          110u8, 238u8, 121u8, 209u8, 31u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Key -> Name."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_local_key_to_name(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 15u8, 104u8, 156u8, 10u8, 116u8, 95u8, 149u8, 200u8, 0u8, 202u8,
          149u8, 7u8, 13u8, 176u8, 112u8, 120u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Key -> Name."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_local_key_to_name(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 15u8, 104u8, 156u8, 10u8, 116u8, 95u8, 149u8, 200u8, 0u8, 202u8,
          149u8, 7u8, 13u8, 176u8, 112u8, 120u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Key -> Name."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_global_key_to_name(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 34u8, 54u8, 201u8, 61u8, 167u8, 233u8, 191u8, 146u8, 116u8, 241u8,
          41u8, 22u8, 57u8, 221u8, 39u8, 238u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Key -> Name."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_global_key_to_name(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 34u8, 54u8, 201u8, 61u8, 167u8, 233u8, 191u8, 146u8, 116u8, 241u8,
          41u8, 22u8, 57u8, 221u8, 39u8, 238u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Key specs."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_local_specs(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 142u8, 233u8, 192u8, 135u8, 176u8, 130u8, 140u8, 179u8, 147u8, 154u8,
          225u8, 87u8, 146u8, 146u8, 58u8, 218u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Key specs."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_local_specs(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 142u8, 233u8, 192u8, 135u8, 176u8, 130u8, 140u8, 179u8, 147u8, 154u8,
          225u8, 87u8, 146u8, 146u8, 58u8, 218u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Key specs."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_global_specs(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 68u8, 154u8, 137u8, 212u8, 2u8, 194u8, 202u8, 170u8, 149u8, 44u8,
          16u8, 103u8, 57u8, 78u8, 188u8, 125u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Key specs."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_global_specs(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 68u8, 154u8, 137u8, 212u8, 2u8, 194u8, 202u8, 170u8, 149u8, 44u8,
          16u8, 103u8, 57u8, 78u8, 188u8, 125u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A list of assets that exempt all users from affirming its receivement."]
      #[cfg(not(feature = "ink"))]
      pub async fn assets_exempt_from_affirmation(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 129u8, 27u8, 14u8, 202u8, 198u8, 201u8, 246u8, 155u8, 120u8, 161u8,
          116u8, 181u8, 202u8, 14u8, 1u8, 151u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A list of assets that exempt all users from affirming its receivement."]
      #[cfg(feature = "ink")]
      pub fn assets_exempt_from_affirmation(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 129u8, 27u8, 14u8, 202u8, 198u8, 201u8, 246u8, 155u8, 120u8, 161u8,
          116u8, 181u8, 202u8, 14u8, 1u8, 151u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All assets that don't need an affirmation to be received by an identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn pre_approved_asset(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 237u8, 164u8, 217u8, 22u8, 24u8, 141u8, 131u8, 204u8, 239u8, 78u8,
          76u8, 53u8, 134u8, 236u8, 32u8, 160u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All assets that don't need an affirmation to be received by an identity."]
      #[cfg(feature = "ink")]
      pub fn pre_approved_asset(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 237u8, 164u8, 217u8, 22u8, 24u8, 141u8, 131u8, 204u8, 239u8, 78u8,
          76u8, 53u8, 134u8, 236u8, 32u8, 160u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The list of mandatory mediators for every ticker."]
      #[cfg(not(feature = "ink"))]
      pub async fn mandatory_mediators(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 24u8, 32u8, 69u8, 175u8, 150u8, 69u8, 91u8, 164u8, 42u8, 209u8, 203u8,
          52u8, 223u8, 58u8, 185u8, 222u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The list of mandatory mediators for every ticker."]
      #[cfg(feature = "ink")]
      pub fn mandatory_mediators(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 24u8, 32u8, 69u8, 175u8, 150u8, 69u8, 91u8, 164u8, 42u8, 209u8, 203u8,
          52u8, 223u8, 58u8, 185u8, 222u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The last [`AssetMetadataLocalKey`] used for [`AssetId`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_asset_metadata_local_key(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 172u8, 170u8, 216u8, 160u8, 251u8, 117u8, 82u8, 193u8, 254u8, 194u8,
          88u8, 218u8, 2u8, 198u8, 198u8, 134u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The last [`AssetMetadataLocalKey`] used for [`AssetId`]."]
      #[cfg(feature = "ink")]
      pub fn current_asset_metadata_local_key(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 172u8, 170u8, 216u8, 160u8, 251u8, 117u8, 82u8, 193u8, 254u8, 194u8,
          88u8, 218u8, 2u8, 198u8, 198u8, 134u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The last [`AssetMetadataGlobalKey`] used for a global key."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_asset_metadata_global_key(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 238u8, 45u8, 135u8, 59u8, 233u8, 209u8, 66u8, 45u8, 163u8, 101u8,
          125u8, 201u8, 185u8, 172u8, 154u8, 43u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The last [`AssetMetadataGlobalKey`] used for a global key."]
      #[cfg(feature = "ink")]
      pub fn current_asset_metadata_global_key(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 238u8, 45u8, 135u8, 59u8, 233u8, 209u8, 66u8, 45u8, 163u8, 101u8,
          125u8, 201u8, 185u8, 172u8, 154u8, 43u8,
        ])?;
        Ok(value)
      }
      #[doc = " All tickers owned by a user."]
      #[cfg(not(feature = "ink"))]
      pub async fn tickers_owned_by_user(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 99u8, 17u8, 132u8, 70u8, 52u8, 22u8, 240u8, 117u8, 69u8, 175u8, 36u8,
          91u8, 192u8, 206u8, 64u8, 180u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All tickers owned by a user."]
      #[cfg(feature = "ink")]
      pub fn tickers_owned_by_user(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 99u8, 17u8, 132u8, 70u8, 52u8, 22u8, 240u8, 117u8, 69u8, 175u8, 36u8,
          91u8, 192u8, 206u8, 64u8, 180u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All assets owned by a user."]
      #[cfg(not(feature = "ink"))]
      pub async fn security_tokens_owned_by_user(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 151u8, 255u8, 204u8, 37u8, 249u8, 197u8, 202u8, 172u8, 255u8, 183u8,
          167u8, 221u8, 109u8, 3u8, 85u8, 163u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All assets owned by a user."]
      #[cfg(feature = "ink")]
      pub fn security_tokens_owned_by_user(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 151u8, 255u8, 204u8, 37u8, 249u8, 197u8, 202u8, 172u8, 255u8, 183u8,
          167u8, 221u8, 109u8, 3u8, 85u8, 163u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps all [`AssetId`] that are mapped to a [`Ticker`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_id_ticker(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::ticker::Ticker>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 113u8, 36u8, 180u8, 254u8, 209u8, 33u8, 154u8, 66u8, 19u8, 18u8,
          173u8, 27u8, 149u8, 213u8, 68u8, 49u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Maps all [`AssetId`] that are mapped to a [`Ticker`]."]
      #[cfg(feature = "ink")]
      pub fn asset_id_ticker(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::ticker::Ticker>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 113u8, 36u8, 180u8, 254u8, 209u8, 33u8, 154u8, 66u8, 19u8, 18u8,
          173u8, 27u8, 149u8, 213u8, 68u8, 49u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Maps all [`Ticker`] that are linked to an [`AssetId`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn ticker_asset_id(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AssetId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 171u8, 113u8, 226u8, 122u8, 108u8, 135u8, 182u8, 231u8, 40u8, 21u8,
          178u8, 73u8, 152u8, 31u8, 27u8, 107u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Maps all [`Ticker`] that are linked to an [`AssetId`]."]
      #[cfg(feature = "ink")]
      pub fn ticker_asset_id(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AssetId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 171u8, 113u8, 226u8, 122u8, 108u8, 135u8, 182u8, 231u8, 40u8, 21u8,
          178u8, 73u8, 152u8, 31u8, 27u8, 107u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A per account nonce that is used for generating an [`AssetId`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_nonce(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 4u8, 19u8, 69u8, 160u8, 99u8, 153u8, 130u8, 144u8, 101u8, 251u8,
          168u8, 63u8, 80u8, 219u8, 22u8, 96u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A per account nonce that is used for generating an [`AssetId`]."]
      #[cfg(feature = "ink")]
      pub fn asset_nonce(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 4u8, 19u8, 69u8, 160u8, 99u8, 153u8, 130u8, 144u8, 101u8, 251u8,
          168u8, 63u8, 80u8, 219u8, 22u8, 96u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_asset::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_asset::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_asset::Version> {
        let value = self.api.read_storage(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_asset::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct AssetPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> AssetPagedQueryApi<'api> {
      #[doc = " Maps each [`Ticker`] to its registration details ([`TickerRegistration`])."]
      pub fn unique_ticker_registration(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::ticker::Ticker,
        types::pallet_asset::types::TickerRegistration<u64>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 121u8, 181u8, 109u8, 199u8, 4u8, 80u8, 93u8, 65u8, 21u8, 24u8, 9u8,
          66u8, 56u8, 123u8, 250u8, 186u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Maps each [`AssetId`] to its underling [`AssetDetails`]."]
      pub fn assets(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::pallet_asset::types::AssetDetails,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 104u8, 42u8, 89u8, 213u8, 26u8, 185u8, 228u8, 138u8, 140u8, 140u8,
          196u8, 24u8, 255u8, 151u8, 8u8, 210u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Maps each [`AssetId`] to its underling [`AssetName`]."]
      pub fn asset_names(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::polymesh_primitives::asset::AssetName,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 123u8, 195u8, 250u8, 203u8, 235u8, 133u8, 90u8, 23u8, 143u8, 10u8,
          8u8, 53u8, 96u8, 109u8, 5u8, 206u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Tracks the total [`Balance`] for each [`AssetId`] per [`IdentityId`]."]
      pub fn balance_of(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 106u8, 75u8, 187u8, 251u8, 206u8, 1u8, 124u8, 102u8, 14u8, 227u8,
          176u8, 68u8, 23u8, 115u8, 19u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " Maps each [`AssetId`] to its asset identifiers ([`AssetIdentifier`])."]
      pub fn asset_identifiers(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        ::alloc::vec::Vec<types::polymesh_primitives::asset_identifier::AssetIdentifier>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 178u8, 193u8, 1u8, 161u8, 14u8, 189u8, 176u8, 94u8, 104u8, 54u8,
          170u8, 144u8, 16u8, 162u8, 98u8, 190u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Maps custom asset type ids to the registered string contents."]
      pub fn custom_types(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::asset::CustomAssetTypeId,
        ::alloc::vec::Vec<u8>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 214u8, 35u8, 90u8, 254u8, 57u8, 243u8, 210u8, 34u8, 193u8, 0u8, 96u8,
          131u8, 116u8, 109u8, 49u8, 166u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Inverse map of `CustomTypes`, from registered string contents to custom asset type ids."]
      pub fn custom_types_inverse(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::alloc::vec::Vec<u8>,
        types::polymesh_primitives::asset::CustomAssetTypeId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 2u8, 147u8, 168u8, 237u8, 90u8, 35u8, 218u8, 237u8, 169u8, 231u8,
          223u8, 32u8, 46u8, 15u8, 228u8, 85u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Maps each [`AssetId`] to the name of its founding round ([`FundingRoundName`])."]
      pub fn funding_round(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::polymesh_primitives::asset::FundingRoundName,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 93u8, 34u8, 9u8, 253u8, 168u8, 224u8, 203u8, 196u8, 69u8, 133u8, 25u8,
          204u8, 124u8, 207u8, 104u8, 5u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The total [`Balance`] of tokens issued in all recorded funding rounds ([`FundingRoundName`])."]
      pub fn issued_in_funding_round(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::asset::FundingRoundName,
        ),
        u128,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 215u8, 137u8, 60u8, 134u8, 127u8, 54u8, 56u8, 208u8, 215u8, 148u8,
          185u8, 185u8, 12u8, 48u8, 135u8, 44u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Returns `true` if transfers for the asset are frozen. Otherwise, returns `false`."]
      pub fn frozen(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8, 93u8, 238u8, 240u8,
          115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " All [`Document`] attached to an asset."]
      pub fn asset_documents(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::document::DocumentId,
        types::polymesh_primitives::document::Document,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 166u8, 167u8, 74u8, 143u8, 116u8, 237u8, 66u8, 137u8, 149u8, 40u8,
          102u8, 20u8, 236u8, 96u8, 52u8, 9u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " [`DocumentId`] counter per [`AssetId`]."]
      pub fn asset_documents_id_sequence(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::polymesh_primitives::document::DocumentId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 201u8, 198u8, 40u8, 95u8, 195u8, 158u8, 100u8, 69u8, 247u8, 3u8, 87u8,
          5u8, 57u8, 71u8, 8u8, 63u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Metatdata values for an asset."]
      pub fn asset_metadata_values(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        types::polymesh_primitives::asset_metadata::AssetMetadataValue,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 12u8, 236u8, 10u8, 112u8, 182u8, 190u8, 51u8, 243u8, 171u8, 240u8,
          46u8, 214u8, 255u8, 55u8, 188u8, 48u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Details for an asset's Metadata values."]
      pub fn asset_metadata_value_details(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 177u8, 107u8, 241u8, 225u8, 188u8, 86u8, 141u8, 84u8, 219u8, 116u8,
          115u8, 57u8, 230u8, 243u8, 42u8, 93u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Asset Metadata Local Name -> Key."]
      pub fn asset_metadata_local_name_to_key(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::asset_metadata::AssetMetadataName,
        types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 132u8, 79u8, 149u8, 0u8, 75u8, 89u8, 31u8, 241u8, 75u8, 208u8, 41u8,
          159u8, 32u8, 36u8, 73u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Asset Metadata Global Name -> Key."]
      pub fn asset_metadata_global_name_to_key(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::asset_metadata::AssetMetadataName,
        types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 27u8, 55u8, 255u8, 139u8, 76u8, 15u8, 234u8, 246u8, 25u8, 194u8,
          110u8, 238u8, 121u8, 209u8, 31u8, 28u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Asset Metadata Local Key -> Name."]
      pub fn asset_metadata_local_key_to_name(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
        types::polymesh_primitives::asset_metadata::AssetMetadataName,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 15u8, 104u8, 156u8, 10u8, 116u8, 95u8, 149u8, 200u8, 0u8, 202u8,
          149u8, 7u8, 13u8, 176u8, 112u8, 120u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Asset Metadata Global Key -> Name."]
      pub fn asset_metadata_global_key_to_name(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
        types::polymesh_primitives::asset_metadata::AssetMetadataName,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 34u8, 54u8, 201u8, 61u8, 167u8, 233u8, 191u8, 146u8, 116u8, 241u8,
          41u8, 22u8, 57u8, 221u8, 39u8, 238u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Asset Metadata Local Key specs."]
      pub fn asset_metadata_local_specs(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
        types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 142u8, 233u8, 192u8, 135u8, 176u8, 130u8, 140u8, 179u8, 147u8, 154u8,
          225u8, 87u8, 146u8, 146u8, 58u8, 218u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Asset Metadata Global Key specs."]
      pub fn asset_metadata_global_specs(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
        types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 68u8, 154u8, 137u8, 212u8, 2u8, 194u8, 202u8, 170u8, 149u8, 44u8,
          16u8, 103u8, 57u8, 78u8, 188u8, 125u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " A list of assets that exempt all users from affirming its receivement."]
      pub fn assets_exempt_from_affirmation(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 129u8, 27u8, 14u8, 202u8, 198u8, 201u8, 246u8, 155u8, 120u8, 161u8,
          116u8, 181u8, 202u8, 14u8, 1u8, 151u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " All assets that don't need an affirmation to be received by an identity."]
      pub fn pre_approved_asset(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 237u8, 164u8, 217u8, 22u8, 24u8, 141u8, 131u8, 204u8, 239u8, 78u8,
          76u8, 53u8, 134u8, 236u8, 32u8, 160u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The list of mandatory mediators for every ticker."]
      pub fn mandatory_mediators(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 24u8, 32u8, 69u8, 175u8, 150u8, 69u8, 91u8, 164u8, 42u8, 209u8, 203u8,
          52u8, 223u8, 58u8, 185u8, 222u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The last [`AssetMetadataLocalKey`] used for [`AssetId`]."]
      pub fn current_asset_metadata_local_key(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 172u8, 170u8, 216u8, 160u8, 251u8, 117u8, 82u8, 193u8, 254u8, 194u8,
          88u8, 218u8, 2u8, 198u8, 198u8, 134u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " All tickers owned by a user."]
      pub fn tickers_owned_by_user(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<types::polymesh_primitives::ticker::Ticker, bool>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 99u8, 17u8, 132u8, 70u8, 52u8, 22u8, 240u8, 117u8, 69u8, 175u8, 36u8,
          91u8, 192u8, 206u8, 64u8, 180u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " All assets owned by a user."]
      pub fn security_tokens_owned_by_user(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 151u8, 255u8, 204u8, 37u8, 249u8, 197u8, 202u8, 172u8, 255u8, 183u8,
          167u8, 221u8, 109u8, 3u8, 85u8, 163u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Maps all [`AssetId`] that are mapped to a [`Ticker`]."]
      pub fn asset_id_ticker(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::polymesh_primitives::ticker::Ticker,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 113u8, 36u8, 180u8, 254u8, 209u8, 33u8, 154u8, 66u8, 19u8, 18u8,
          173u8, 27u8, 149u8, 213u8, 68u8, 49u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Maps all [`Ticker`] that are linked to an [`AssetId`]."]
      pub fn ticker_asset_id(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::ticker::Ticker,
        ::polymesh_api_client::AssetId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 171u8, 113u8, 226u8, 122u8, 108u8, 135u8, 182u8, 231u8, 40u8, 21u8,
          178u8, 73u8, 152u8, 31u8, 27u8, 107u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " A per account nonce that is used for generating an [`AssetId`]."]
      pub fn asset_nonce(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 4u8, 19u8, 69u8, 160u8, 99u8, 153u8, 130u8, 144u8, 101u8, 251u8,
          168u8, 63u8, 80u8, 219u8, 22u8, 96u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
    }
  }
  pub mod capital_distribution {
    use super::*;
    #[derive(Clone)]
    pub struct CapitalDistributionCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CapitalDistributionCallApi<'api> {
      #[doc = "Start and attach a capital distribution, to the CA identified by `ca_id`,"]
      #[doc = "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID."]
      #[doc = ""]
      #[doc = "The distribution will commence at `payment_at` and expire at `expires_at`,"]
      #[doc = "if provided, or if `None`, then there's no expiry."]
      #[doc = ""]
      #[doc = "The funds will be locked in `portfolio` from when `distribute` is called."]
      #[doc = "When there's no expiry, some funds may be locked indefinitely in `portfolio`,"]
      #[doc = "due to claimants not withdrawing or no benefits being pushed to them."]
      #[doc = "For indivisible currencies, unlocked amounts, of less than one whole unit,"]
      #[doc = "will not be transferable from `portfolio`."]
      #[doc = "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units,"]
      #[doc = "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`,"]
      #[doc = "which is now transferrable."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
      #[doc = "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from."]
      #[doc = "- `currency` to withdraw and distribute from the `portfolio`."]
      #[doc = "- `per_share` amount of `currency` to withdraw and distribute."]
      #[doc = "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token."]
      #[doc = "- `amount` of `currency` to withdraw and distribute at most."]
      #[doc = "- `payment_at` specifies when benefits may first be pushed or claimed."]
      #[doc = "- `expires_at` specifies, if provided, when remaining benefits are forfeit"]
      #[doc = "   and may be reclaimed by `origin`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NoRecordDate` if CA has no record date."]
      #[doc = "- `RecordDateAfterStart` if CA's record date > payment_at."]
      #[doc = "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`."]
      #[doc = "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`."]
      #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
      #[doc = "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit"]
      #[doc = "- `DistributionAmountIsZero` if the `amount` is zero."]
      #[doc = "- `DistributionPerShareIsZero` if the `per_share` is zero."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn distribute(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
        currency: ::polymesh_api_client::AssetId,
        per_share: u128,
        amount: u128,
        payment_at: u64,
        expires_at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CapitalDistribution(
            types::pallet_corporate_actions::distribution::CapitalDistributionCall::distribute {
              ca_id,
              portfolio,
              currency,
              per_share,
              amount,
              payment_at,
              expires_at,
            },
          ))
      }
      #[doc = "Start and attach a capital distribution, to the CA identified by `ca_id`,"]
      #[doc = "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID."]
      #[doc = ""]
      #[doc = "The distribution will commence at `payment_at` and expire at `expires_at`,"]
      #[doc = "if provided, or if `None`, then there's no expiry."]
      #[doc = ""]
      #[doc = "The funds will be locked in `portfolio` from when `distribute` is called."]
      #[doc = "When there's no expiry, some funds may be locked indefinitely in `portfolio`,"]
      #[doc = "due to claimants not withdrawing or no benefits being pushed to them."]
      #[doc = "For indivisible currencies, unlocked amounts, of less than one whole unit,"]
      #[doc = "will not be transferable from `portfolio`."]
      #[doc = "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units,"]
      #[doc = "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`,"]
      #[doc = "which is now transferrable."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
      #[doc = "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from."]
      #[doc = "- `currency` to withdraw and distribute from the `portfolio`."]
      #[doc = "- `per_share` amount of `currency` to withdraw and distribute."]
      #[doc = "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token."]
      #[doc = "- `amount` of `currency` to withdraw and distribute at most."]
      #[doc = "- `payment_at` specifies when benefits may first be pushed or claimed."]
      #[doc = "- `expires_at` specifies, if provided, when remaining benefits are forfeit"]
      #[doc = "   and may be reclaimed by `origin`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NoRecordDate` if CA has no record date."]
      #[doc = "- `RecordDateAfterStart` if CA's record date > payment_at."]
      #[doc = "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`."]
      #[doc = "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`."]
      #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
      #[doc = "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit"]
      #[doc = "- `DistributionAmountIsZero` if the `amount` is zero."]
      #[doc = "- `DistributionPerShareIsZero` if the `per_share` is zero."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn distribute(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
        currency: ::polymesh_api_client::AssetId,
        per_share: u128,
        amount: u128,
        payment_at: u64,
        expires_at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![27u8, 0u8];
        ca_id.encode_to(&mut buf);
        portfolio.encode_to(&mut buf);
        currency.encode_to(&mut buf);
        per_share.encode_to(&mut buf);
        amount.encode_to(&mut buf);
        payment_at.encode_to(&mut buf);
        expires_at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Claim a benefit of the capital distribution attached to `ca_id`."]
      #[doc = ""]
      #[doc = "Taxes are withheld as specified by the CA."]
      #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
      #[doc = ""]
      #[doc = "All benefits are rounded by truncation, down to first integer below."]
      #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
      #[doc = "they are rounded down to a whole unit."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be a holder of the asset and eligible for the distribution."]
      #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
      #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
      #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
      #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
      #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
      #[cfg(not(feature = "ink"))]
      pub fn claim(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CapitalDistribution(
            types::pallet_corporate_actions::distribution::CapitalDistributionCall::claim { ca_id },
          ))
      }
      #[doc = "Claim a benefit of the capital distribution attached to `ca_id`."]
      #[doc = ""]
      #[doc = "Taxes are withheld as specified by the CA."]
      #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
      #[doc = ""]
      #[doc = "All benefits are rounded by truncation, down to first integer below."]
      #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
      #[doc = "they are rounded down to a whole unit."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be a holder of the asset and eligible for the distribution."]
      #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
      #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
      #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
      #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
      #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
      #[cfg(feature = "ink")]
      pub fn claim(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![27u8, 1u8];
        ca_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Push benefit of an ongoing distribution to the given `holder`."]
      #[doc = ""]
      #[doc = "Taxes are withheld as specified by the CA."]
      #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
      #[doc = ""]
      #[doc = "All benefits are rounded by truncation, down to first integer below."]
      #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
      #[doc = "they are rounded down to a whole unit."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the CA with a capital distributions to push benefits for."]
      #[doc = "- `holder` to push benefits to."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
      #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `holder`."]
      #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
      #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
      #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
      #[cfg(not(feature = "ink"))]
      pub fn push_benefit(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        holder: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CapitalDistribution(
            types::pallet_corporate_actions::distribution::CapitalDistributionCall::push_benefit {
              ca_id,
              holder,
            },
          ))
      }
      #[doc = "Push benefit of an ongoing distribution to the given `holder`."]
      #[doc = ""]
      #[doc = "Taxes are withheld as specified by the CA."]
      #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
      #[doc = ""]
      #[doc = "All benefits are rounded by truncation, down to first integer below."]
      #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
      #[doc = "they are rounded down to a whole unit."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the CA with a capital distributions to push benefits for."]
      #[doc = "- `holder` to push benefits to."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
      #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `holder`."]
      #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
      #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
      #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
      #[cfg(feature = "ink")]
      pub fn push_benefit(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        holder: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![27u8, 2u8];
        ca_id.encode_to(&mut buf);
        holder.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Assuming a distribution has expired,"]
      #[doc = "unlock the remaining amount in the distributor portfolio."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be the creator of the capital distribution tied to `ca_id`."]
      #[doc = "- `ca_id` identifies the CA with a capital distribution to reclaim for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `AlreadyReclaimed` if this function has already been called successfully."]
      #[doc = "- `NotExpired` if `now < expiry`."]
      #[cfg(not(feature = "ink"))]
      pub fn reclaim(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CapitalDistribution(
            types::pallet_corporate_actions::distribution::CapitalDistributionCall::reclaim {
              ca_id,
            },
          ))
      }
      #[doc = "Assuming a distribution has expired,"]
      #[doc = "unlock the remaining amount in the distributor portfolio."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be the creator of the capital distribution tied to `ca_id`."]
      #[doc = "- `ca_id` identifies the CA with a capital distribution to reclaim for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `AlreadyReclaimed` if this function has already been called successfully."]
      #[doc = "- `NotExpired` if `now < expiry`."]
      #[cfg(feature = "ink")]
      pub fn reclaim(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![27u8, 3u8];
        ca_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a distribution that hasn't started yet,"]
      #[doc = "unlocking the full amount in the distributor portfolio."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `DistributionStarted` if `payment_at <= now`."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_distribution(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: CapitalDistribution (types :: pallet_corporate_actions :: distribution :: CapitalDistributionCall :: remove_distribution { ca_id , }))
      }
      #[doc = "Removes a distribution that hasn't started yet,"]
      #[doc = "unlocking the full amount in the distributor portfolio."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `DistributionStarted` if `payment_at <= now`."]
      #[cfg(feature = "ink")]
      pub fn remove_distribution(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![27u8, 4u8];
        ca_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for CapitalDistributionCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CapitalDistributionQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CapitalDistributionQueryApi<'api> {
      #[doc = " All capital distributions, tied to their respective corporate actions (CAs)."]
      #[doc = ""]
      #[doc = " (CAId) => Distribution"]
      #[cfg(not(feature = "ink"))]
      pub async fn distributions(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_corporate_actions::distribution::Distribution>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 106u8, 209u8, 103u8, 105u8, 114u8, 107u8, 158u8, 5u8, 125u8, 150u8,
          235u8, 86u8, 125u8, 11u8, 175u8, 145u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All capital distributions, tied to their respective corporate actions (CAs)."]
      #[doc = ""]
      #[doc = " (CAId) => Distribution"]
      #[cfg(feature = "ink")]
      pub fn distributions(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_corporate_actions::distribution::Distribution>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 106u8, 209u8, 103u8, 105u8, 114u8, 107u8, 158u8, 5u8, 125u8, 150u8,
          235u8, 86u8, 125u8, 11u8, 175u8, 145u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Has an asset holder been paid yet?"]
      #[doc = ""]
      #[doc = " (CAId, DID) -> Was DID paid in the CAId?"]
      #[cfg(not(feature = "ink"))]
      pub async fn holder_paid(
        &self,
        key_0: (
          types::pallet_corporate_actions::CAId,
          ::polymesh_api_client::IdentityId,
        ),
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 55u8, 215u8, 43u8, 172u8, 158u8, 205u8, 29u8, 130u8, 146u8, 125u8,
          52u8, 215u8, 183u8, 138u8, 60u8, 26u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Has an asset holder been paid yet?"]
      #[doc = ""]
      #[doc = " (CAId, DID) -> Was DID paid in the CAId?"]
      #[cfg(feature = "ink")]
      pub fn holder_paid(
        &self,
        key_0: (
          types::pallet_corporate_actions::CAId,
          ::polymesh_api_client::IdentityId,
        ),
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 55u8, 215u8, 43u8, 172u8, 158u8, 205u8, 29u8, 130u8, 146u8, 125u8,
          52u8, 215u8, 183u8, 138u8, 60u8, 26u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_corporate_actions::distribution::Version,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::distribution::Version>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::distribution::Version>
      {
        let value = self.api.read_storage(::alloc::vec![
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::distribution::Version>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct CapitalDistributionPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> CapitalDistributionPagedQueryApi<'api> {
      #[doc = " All capital distributions, tied to their respective corporate actions (CAs)."]
      #[doc = ""]
      #[doc = " (CAId) => Distribution"]
      pub fn distributions(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_corporate_actions::CAId,
        types::pallet_corporate_actions::distribution::Distribution,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 106u8, 209u8, 103u8, 105u8, 114u8, 107u8, 158u8, 5u8, 125u8, 150u8,
          235u8, 86u8, 125u8, 11u8, 175u8, 145u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Has an asset holder been paid yet?"]
      #[doc = ""]
      #[doc = " (CAId, DID) -> Was DID paid in the CAId?"]
      pub fn holder_paid(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        (
          types::pallet_corporate_actions::CAId,
          ::polymesh_api_client::IdentityId,
        ),
        bool,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 55u8, 215u8, 43u8, 172u8, 158u8, 205u8, 29u8, 130u8, 146u8, 125u8,
          52u8, 215u8, 183u8, 138u8, 60u8, 26u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
    }
  }
  pub mod checkpoint {
    use super::*;
    #[derive(Clone)]
    pub struct CheckpointCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CheckpointCallApi<'api> {
      #[doc = "Creates a single checkpoint at the current time."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` to create the checkpoint for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
      #[doc = "- `CounterOverflow` if the total checkpoint counter would overflow."]
      #[cfg(not(feature = "ink"))]
      pub fn create_checkpoint(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
          types::pallet_asset::checkpoint::CheckpointCall::create_checkpoint { asset_id },
        ))
      }
      #[doc = "Creates a single checkpoint at the current time."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` to create the checkpoint for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
      #[doc = "- `CounterOverflow` if the total checkpoint counter would overflow."]
      #[cfg(feature = "ink")]
      pub fn create_checkpoint(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![28u8, 0u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets the max complexity of a schedule set for an arbitrary asset_id to `max_complexity`."]
      #[doc = "The new maximum is not enforced retroactively,"]
      #[doc = "and only applies once new schedules are made."]
      #[doc = ""]
      #[doc = "Must be called as a PIP (requires \"root\")."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is the root origin."]
      #[doc = "- `max_complexity` allowed for an arbitrary asset's schedule set."]
      #[cfg(not(feature = "ink"))]
      pub fn set_schedules_max_complexity(
        &self,
        max_complexity: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
          types::pallet_asset::checkpoint::CheckpointCall::set_schedules_max_complexity {
            max_complexity,
          },
        ))
      }
      #[doc = "Sets the max complexity of a schedule set for an arbitrary asset_id to `max_complexity`."]
      #[doc = "The new maximum is not enforced retroactively,"]
      #[doc = "and only applies once new schedules are made."]
      #[doc = ""]
      #[doc = "Must be called as a PIP (requires \"root\")."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is the root origin."]
      #[doc = "- `max_complexity` allowed for an arbitrary asset's schedule set."]
      #[cfg(feature = "ink")]
      pub fn set_schedules_max_complexity(&self, max_complexity: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![28u8, 1u8];
        max_complexity.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Creates a schedule generating checkpoints"]
      #[doc = "in the future at either a fixed time or at intervals."]
      #[doc = ""]
      #[doc = "The schedule starts out with `strong_ref_count(schedule_id) <- 0`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
      #[doc = "- `asset_id` to create the schedule for."]
      #[doc = "- `schedule` that will generate checkpoints."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
      #[doc = "- `InsufficientAccountBalance` if the protocol fee could not be charged."]
      #[doc = "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn create_schedule(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        schedule: polymesh_primitives::checkpoint::ScheduleCheckpoints,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
          types::pallet_asset::checkpoint::CheckpointCall::create_schedule { asset_id, schedule },
        ))
      }
      #[doc = "Creates a schedule generating checkpoints"]
      #[doc = "in the future at either a fixed time or at intervals."]
      #[doc = ""]
      #[doc = "The schedule starts out with `strong_ref_count(schedule_id) <- 0`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
      #[doc = "- `asset_id` to create the schedule for."]
      #[doc = "- `schedule` that will generate checkpoints."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
      #[doc = "- `InsufficientAccountBalance` if the protocol fee could not be charged."]
      #[doc = "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn create_schedule(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        schedule: polymesh_primitives::checkpoint::ScheduleCheckpoints,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![28u8, 2u8];
        asset_id.encode_to(&mut buf);
        schedule.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the checkpoint schedule of an asset identified by `id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
      #[doc = "- `asset_id` to remove the schedule from."]
      #[doc = "- `id` of the schedule, when it was created by `created_schedule`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
      #[doc = "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `asset_id`."]
      #[doc = "- `ScheduleNotRemovable` if `id` exists but is not removable."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_schedule(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        id: polymesh_primitives::checkpoint::ScheduleId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
          types::pallet_asset::checkpoint::CheckpointCall::remove_schedule { asset_id, id },
        ))
      }
      #[doc = "Removes the checkpoint schedule of an asset identified by `id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
      #[doc = "- `asset_id` to remove the schedule from."]
      #[doc = "- `id` of the schedule, when it was created by `created_schedule`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
      #[doc = "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `asset_id`."]
      #[doc = "- `ScheduleNotRemovable` if `id` exists but is not removable."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_schedule(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        id: polymesh_primitives::checkpoint::ScheduleId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![28u8, 3u8];
        asset_id.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for CheckpointCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CheckpointQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CheckpointQueryApi<'api> {
      #[doc = " Total supply of the token at the checkpoint."]
      #[doc = ""]
      #[doc = " ([`AssetId`], checkpointId) -> total supply at given checkpoint"]
      #[cfg(not(feature = "ink"))]
      pub async fn total_supply(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset::CheckpointId,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 89u8, 148u8, 207u8, 218u8, 20u8, 205u8, 103u8, 225u8, 88u8, 102u8,
          71u8, 212u8, 0u8, 8u8, 171u8, 170u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Total supply of the token at the checkpoint."]
      #[doc = ""]
      #[doc = " ([`AssetId`], checkpointId) -> total supply at given checkpoint"]
      #[cfg(feature = "ink")]
      pub fn total_supply(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset::CheckpointId,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 89u8, 148u8, 207u8, 218u8, 20u8, 205u8, 103u8, 225u8, 88u8, 102u8,
          71u8, 212u8, 0u8, 8u8, 171u8, 170u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Balance of a DID at a checkpoint."]
      #[doc = ""]
      #[doc = " ([`AssetId`], did, checkpoint ID) -> Balance of a DID at a checkpoint"]
      #[cfg(not(feature = "ink"))]
      pub async fn balance(
        &self,
        key_0: (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::asset::CheckpointId,
        ),
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 78u8, 168u8, 234u8, 12u8, 1u8, 250u8, 164u8, 43u8, 110u8, 179u8,
          68u8, 168u8, 92u8, 71u8, 179u8, 135u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Balance of a DID at a checkpoint."]
      #[doc = ""]
      #[doc = " ([`AssetId`], did, checkpoint ID) -> Balance of a DID at a checkpoint"]
      #[cfg(feature = "ink")]
      pub fn balance(
        &self,
        key_0: (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::asset::CheckpointId,
        ),
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 78u8, 168u8, 234u8, 12u8, 1u8, 250u8, 164u8, 43u8, 110u8, 179u8,
          68u8, 168u8, 92u8, 71u8, 179u8, 135u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoints ID generator sequence."]
      #[doc = " ID of first checkpoint is 1 instead of 0."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> no. of checkpoints"]
      #[cfg(not(feature = "ink"))]
      pub async fn checkpoint_id_sequence(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::asset::CheckpointId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 125u8, 12u8, 59u8, 36u8, 10u8, 236u8, 235u8, 137u8, 107u8, 225u8,
          196u8, 253u8, 46u8, 38u8, 239u8, 219u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset::CheckpointId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoints ID generator sequence."]
      #[doc = " ID of first checkpoint is 1 instead of 0."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> no. of checkpoints"]
      #[cfg(feature = "ink")]
      pub fn checkpoint_id_sequence(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::asset::CheckpointId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 125u8, 12u8, 59u8, 36u8, 10u8, 236u8, 235u8, 137u8, 107u8, 225u8,
          196u8, 253u8, 46u8, 38u8, 239u8, 219u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset::CheckpointId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoints where a DID's balance was updated."]
      #[doc = " ([`AssetId`], did) -> [checkpoint ID where user balance changed]"]
      #[cfg(not(feature = "ink"))]
      pub async fn balance_updates(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 143u8, 217u8, 170u8, 216u8, 91u8, 210u8, 121u8, 231u8, 28u8, 142u8,
          98u8, 99u8, 214u8, 201u8, 229u8, 250u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Checkpoints where a DID's balance was updated."]
      #[doc = " ([`AssetId`], did) -> [checkpoint ID where user balance changed]"]
      #[cfg(feature = "ink")]
      pub fn balance_updates(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 143u8, 217u8, 170u8, 216u8, 91u8, 210u8, 121u8, 231u8, 28u8, 142u8,
          98u8, 99u8, 214u8, 201u8, 229u8, 250u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Checkpoint timestamps."]
      #[doc = ""]
      #[doc = " Every schedule-originated checkpoint maps its ID to its due time."]
      #[doc = " Every checkpoint manually created maps its ID to the time of recording."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> (checkpoint ID) -> checkpoint timestamp"]
      #[cfg(not(feature = "ink"))]
      pub async fn timestamps(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset::CheckpointId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 212u8, 135u8, 3u8, 189u8, 214u8, 233u8, 162u8, 207u8, 215u8, 14u8,
          169u8, 158u8, 121u8, 254u8, 114u8, 232u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoint timestamps."]
      #[doc = ""]
      #[doc = " Every schedule-originated checkpoint maps its ID to its due time."]
      #[doc = " Every checkpoint manually created maps its ID to the time of recording."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> (checkpoint ID) -> checkpoint timestamp"]
      #[cfg(feature = "ink")]
      pub fn timestamps(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::asset::CheckpointId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 212u8, 135u8, 3u8, 189u8, 214u8, 233u8, 162u8, 207u8, 215u8, 14u8,
          169u8, 158u8, 121u8, 254u8, 114u8, 232u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum complexity allowed for an asset's schedules."]
      #[cfg(not(feature = "ink"))]
      pub async fn schedules_max_complexity(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 157u8, 164u8, 151u8, 8u8, 64u8, 141u8, 200u8, 122u8, 167u8, 39u8,
          230u8, 249u8, 114u8, 60u8, 67u8, 180u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum complexity allowed for an asset's schedules."]
      #[cfg(feature = "ink")]
      pub fn schedules_max_complexity(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 157u8, 164u8, 151u8, 8u8, 64u8, 141u8, 200u8, 122u8, 167u8, 39u8,
          230u8, 249u8, 114u8, 60u8, 67u8, 180u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoint schedule ID sequence for assets."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> schedule ID"]
      #[cfg(not(feature = "ink"))]
      pub async fn schedule_id_sequence(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<polymesh_primitives::checkpoint::ScheduleId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 105u8, 127u8, 108u8, 151u8, 163u8, 248u8, 224u8, 135u8, 154u8, 147u8,
          248u8, 192u8, 179u8, 162u8, 41u8, 13u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <polymesh_primitives::checkpoint::ScheduleId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoint schedule ID sequence for assets."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> schedule ID"]
      #[cfg(feature = "ink")]
      pub fn schedule_id_sequence(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<polymesh_primitives::checkpoint::ScheduleId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 105u8, 127u8, 108u8, 151u8, 163u8, 248u8, 224u8, 135u8, 154u8, 147u8,
          248u8, 192u8, 179u8, 162u8, 41u8, 13u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <polymesh_primitives::checkpoint::ScheduleId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Cached next checkpoint for each schedule."]
      #[doc = ""]
      #[doc = " This is used to quickly find the next checkpoint from a asset's schedules."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> next checkpoints"]
      #[cfg(not(feature = "ink"))]
      pub async fn cached_next_checkpoints(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<
        Option<polymesh_primitives::checkpoint::NextCheckpoints>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 80u8, 107u8, 22u8, 3u8, 194u8, 86u8, 107u8, 33u8, 70u8, 40u8, 22u8,
          166u8, 84u8, 108u8, 245u8, 73u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Cached next checkpoint for each schedule."]
      #[doc = ""]
      #[doc = " This is used to quickly find the next checkpoint from a asset's schedules."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> next checkpoints"]
      #[cfg(feature = "ink")]
      pub fn cached_next_checkpoints(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<Option<polymesh_primitives::checkpoint::NextCheckpoints>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 80u8, 107u8, 22u8, 3u8, 194u8, 86u8, 107u8, 33u8, 70u8, 40u8, 22u8,
          166u8, 84u8, 108u8, 245u8, 73u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Scheduled checkpoints."]
      #[doc = ""]
      #[doc = " ([`AssetId`], schedule ID) -> schedule checkpoints"]
      #[cfg(not(feature = "ink"))]
      pub async fn scheduled_checkpoints(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: polymesh_primitives::checkpoint::ScheduleId,
      ) -> ::polymesh_api_client::error::Result<
        Option<polymesh_primitives::checkpoint::ScheduleCheckpoints>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 73u8, 231u8, 184u8, 207u8, 197u8, 218u8, 76u8, 26u8, 125u8, 44u8,
          6u8, 132u8, 44u8, 4u8, 76u8, 237u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Scheduled checkpoints."]
      #[doc = ""]
      #[doc = " ([`AssetId`], schedule ID) -> schedule checkpoints"]
      #[cfg(feature = "ink")]
      pub fn scheduled_checkpoints(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: polymesh_primitives::checkpoint::ScheduleId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<polymesh_primitives::checkpoint::ScheduleCheckpoints>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 73u8, 231u8, 184u8, 207u8, 197u8, 218u8, 76u8, 26u8, 125u8, 44u8,
          6u8, 132u8, 44u8, 4u8, 76u8, 237u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " How many \"strong\" references are there to a given `ScheduleId`?"]
      #[doc = ""]
      #[doc = " The presence of a \"strong\" reference, in the sense of `Rc<T>`,"]
      #[doc = " entails that the referenced schedule cannot be removed."]
      #[doc = " Thus, as long as `strong_ref_count(schedule_id) > 0`,"]
      #[doc = " `remove_schedule(schedule_id)` will error."]
      #[doc = ""]
      #[doc = " ([`AssetId`], schedule ID) -> strong ref count"]
      #[cfg(not(feature = "ink"))]
      pub async fn schedule_ref_count(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: polymesh_primitives::checkpoint::ScheduleId,
      ) -> ::polymesh_api_client::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 237u8, 119u8, 84u8, 159u8, 230u8, 166u8, 65u8, 61u8, 186u8, 244u8,
          172u8, 93u8, 185u8, 128u8, 39u8, 122u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many \"strong\" references are there to a given `ScheduleId`?"]
      #[doc = ""]
      #[doc = " The presence of a \"strong\" reference, in the sense of `Rc<T>`,"]
      #[doc = " entails that the referenced schedule cannot be removed."]
      #[doc = " Thus, as long as `strong_ref_count(schedule_id) > 0`,"]
      #[doc = " `remove_schedule(schedule_id)` will error."]
      #[doc = ""]
      #[doc = " ([`AssetId`], schedule ID) -> strong ref count"]
      #[cfg(feature = "ink")]
      pub fn schedule_ref_count(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: polymesh_primitives::checkpoint::ScheduleId,
      ) -> ::polymesh_api_ink::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 237u8, 119u8, 84u8, 159u8, 230u8, 166u8, 65u8, 61u8, 186u8, 244u8,
          172u8, 93u8, 185u8, 128u8, 39u8, 122u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All the checkpoints a given schedule originated."]
      #[doc = ""]
      #[doc = " ([`AssetId`], schedule ID) -> [checkpoint ID]"]
      #[cfg(not(feature = "ink"))]
      pub async fn schedule_points(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: polymesh_primitives::checkpoint::ScheduleId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 169u8, 253u8, 229u8, 218u8, 162u8, 17u8, 213u8, 206u8, 52u8, 53u8,
          24u8, 44u8, 3u8, 149u8, 70u8, 134u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " All the checkpoints a given schedule originated."]
      #[doc = ""]
      #[doc = " ([`AssetId`], schedule ID) -> [checkpoint ID]"]
      #[cfg(feature = "ink")]
      pub fn schedule_points(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: polymesh_primitives::checkpoint::ScheduleId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 169u8, 253u8, 229u8, 218u8, 162u8, 17u8, 213u8, 206u8, 52u8, 53u8,
          24u8, 44u8, 3u8, 149u8, 70u8, 134u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_asset::checkpoint::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_asset::checkpoint::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_asset::checkpoint::Version> {
        let value = self.api.read_storage(::alloc::vec![
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_asset::checkpoint::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct CheckpointPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> CheckpointPagedQueryApi<'api> {
      #[doc = " Total supply of the token at the checkpoint."]
      #[doc = ""]
      #[doc = " ([`AssetId`], checkpointId) -> total supply at given checkpoint"]
      pub fn total_supply(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<types::polymesh_primitives::asset::CheckpointId, u128>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 89u8, 148u8, 207u8, 218u8, 20u8, 205u8, 103u8, 225u8, 88u8, 102u8,
          71u8, 212u8, 0u8, 8u8, 171u8, 170u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Balance of a DID at a checkpoint."]
      #[doc = ""]
      #[doc = " ([`AssetId`], did, checkpoint ID) -> Balance of a DID at a checkpoint"]
      pub fn balance(
        &self,
        key_0: (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::asset::CheckpointId,
        ),
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 78u8, 168u8, 234u8, 12u8, 1u8, 250u8, 164u8, 43u8, 110u8, 179u8,
          68u8, 168u8, 92u8, 71u8, 179u8, 135u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Checkpoints ID generator sequence."]
      #[doc = " ID of first checkpoint is 1 instead of 0."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> no. of checkpoints"]
      pub fn checkpoint_id_sequence(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::polymesh_primitives::asset::CheckpointId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 125u8, 12u8, 59u8, 36u8, 10u8, 236u8, 235u8, 137u8, 107u8, 225u8,
          196u8, 253u8, 46u8, 38u8, 239u8, 219u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Checkpoints where a DID's balance was updated."]
      #[doc = " ([`AssetId`], did) -> [checkpoint ID where user balance changed]"]
      pub fn balance_updates(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::IdentityId,
        ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 143u8, 217u8, 170u8, 216u8, 91u8, 210u8, 121u8, 231u8, 28u8, 142u8,
          98u8, 99u8, 214u8, 201u8, 229u8, 250u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Checkpoint timestamps."]
      #[doc = ""]
      #[doc = " Every schedule-originated checkpoint maps its ID to its due time."]
      #[doc = " Every checkpoint manually created maps its ID to the time of recording."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> (checkpoint ID) -> checkpoint timestamp"]
      pub fn timestamps(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<types::polymesh_primitives::asset::CheckpointId, u64>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 212u8, 135u8, 3u8, 189u8, 214u8, 233u8, 162u8, 207u8, 215u8, 14u8,
          169u8, 158u8, 121u8, 254u8, 114u8, 232u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Checkpoint schedule ID sequence for assets."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> schedule ID"]
      pub fn schedule_id_sequence(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        polymesh_primitives::checkpoint::ScheduleId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 105u8, 127u8, 108u8, 151u8, 163u8, 248u8, 224u8, 135u8, 154u8, 147u8,
          248u8, 192u8, 179u8, 162u8, 41u8, 13u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Cached next checkpoint for each schedule."]
      #[doc = ""]
      #[doc = " This is used to quickly find the next checkpoint from a asset's schedules."]
      #[doc = ""]
      #[doc = " ([`AssetId`]) -> next checkpoints"]
      pub fn cached_next_checkpoints(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        polymesh_primitives::checkpoint::NextCheckpoints,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 80u8, 107u8, 22u8, 3u8, 194u8, 86u8, 107u8, 33u8, 70u8, 40u8, 22u8,
          166u8, 84u8, 108u8, 245u8, 73u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Scheduled checkpoints."]
      #[doc = ""]
      #[doc = " ([`AssetId`], schedule ID) -> schedule checkpoints"]
      pub fn scheduled_checkpoints(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        polymesh_primitives::checkpoint::ScheduleId,
        polymesh_primitives::checkpoint::ScheduleCheckpoints,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 73u8, 231u8, 184u8, 207u8, 197u8, 218u8, 76u8, 26u8, 125u8, 44u8,
          6u8, 132u8, 44u8, 4u8, 76u8, 237u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " How many \"strong\" references are there to a given `ScheduleId`?"]
      #[doc = ""]
      #[doc = " The presence of a \"strong\" reference, in the sense of `Rc<T>`,"]
      #[doc = " entails that the referenced schedule cannot be removed."]
      #[doc = " Thus, as long as `strong_ref_count(schedule_id) > 0`,"]
      #[doc = " `remove_schedule(schedule_id)` will error."]
      #[doc = ""]
      #[doc = " ([`AssetId`], schedule ID) -> strong ref count"]
      pub fn schedule_ref_count(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<polymesh_primitives::checkpoint::ScheduleId, u32>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 237u8, 119u8, 84u8, 159u8, 230u8, 166u8, 65u8, 61u8, 186u8, 244u8,
          172u8, 93u8, 185u8, 128u8, 39u8, 122u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " All the checkpoints a given schedule originated."]
      #[doc = ""]
      #[doc = " ([`AssetId`], schedule ID) -> [checkpoint ID]"]
      pub fn schedule_points(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        polymesh_primitives::checkpoint::ScheduleId,
        ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 169u8, 253u8, 229u8, 218u8, 162u8, 17u8, 213u8, 206u8, 52u8, 53u8,
          24u8, 44u8, 3u8, 149u8, 70u8, 134u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod compliance_manager {
    use super::*;
    #[derive(Clone)]
    pub struct ComplianceManagerCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ComplianceManagerCallApi<'api> {
      #[doc = "Adds a compliance requirement to an asset given by `asset_id`."]
      #[doc = "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = "* sender_conditions - Sender transfer conditions."]
      #[doc = "* receiver_conditions - Receiver transfer conditions."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn add_compliance_requirement(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        sender_conditions: ::alloc::vec::Vec<types::polymesh_primitives::condition::Condition>,
        receiver_conditions: ::alloc::vec::Vec<types::polymesh_primitives::condition::Condition>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::add_compliance_requirement {
            asset_id,
            sender_conditions,
            receiver_conditions,
          },
        ))
      }
      #[doc = "Adds a compliance requirement to an asset given by `asset_id`."]
      #[doc = "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = "* sender_conditions - Sender transfer conditions."]
      #[doc = "* receiver_conditions - Receiver transfer conditions."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn add_compliance_requirement(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        sender_conditions: ::alloc::vec::Vec<types::polymesh_primitives::condition::Condition>,
        receiver_conditions: ::alloc::vec::Vec<types::polymesh_primitives::condition::Condition>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 0u8];
        asset_id.encode_to(&mut buf);
        sender_conditions.encode_to(&mut buf);
        receiver_conditions.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a compliance requirement from an asset's compliance."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = "* id - Compliance requirement id which is need to be removed"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_compliance_requirement(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        id: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::remove_compliance_requirement {
            asset_id,
            id,
          },
        ))
      }
      #[doc = "Removes a compliance requirement from an asset's compliance."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = "* id - Compliance requirement id which is need to be removed"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_compliance_requirement(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        id: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 1u8];
        asset_id.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Replaces an asset's compliance with a new compliance."]
      #[doc = ""]
      #[doc = "Compliance requirements will be sorted (ascending by id) before"]
      #[doc = "replacing the current requirements."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `asset_id` - the asset asset_id,"]
      #[doc = "* `asset_compliance - the new asset compliance."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `Unauthorized` if `origin` is not the owner of the asset_id."]
      #[doc = "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn replace_asset_compliance(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        asset_compliance: ::alloc::vec::Vec<
          types::polymesh_primitives::compliance_manager::ComplianceRequirement,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::replace_asset_compliance {
            asset_id,
            asset_compliance,
          },
        ))
      }
      #[doc = "Replaces an asset's compliance with a new compliance."]
      #[doc = ""]
      #[doc = "Compliance requirements will be sorted (ascending by id) before"]
      #[doc = "replacing the current requirements."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `asset_id` - the asset asset_id,"]
      #[doc = "* `asset_compliance - the new asset compliance."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `Unauthorized` if `origin` is not the owner of the asset_id."]
      #[doc = "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn replace_asset_compliance(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        asset_compliance: ::alloc::vec::Vec<
          types::polymesh_primitives::compliance_manager::ComplianceRequirement,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 2u8];
        asset_id.encode_to(&mut buf);
        asset_compliance.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes an asset's compliance"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn reset_asset_compliance(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::reset_asset_compliance {
            asset_id,
          },
        ))
      }
      #[doc = "Removes an asset's compliance"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn reset_asset_compliance(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 3u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Pauses the verification of conditions for `asset_id` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn pause_asset_compliance(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::pause_asset_compliance {
            asset_id,
          },
        ))
      }
      #[doc = "Pauses the verification of conditions for `asset_id` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn pause_asset_compliance(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 4u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Resumes the verification of conditions for `asset_id` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn resume_asset_compliance(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::resume_asset_compliance {
            asset_id,
          },
        ))
      }
      #[doc = "Resumes the verification of conditions for `asset_id` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
      #[doc = "* asset_id - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn resume_asset_compliance(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 5u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds another default trusted claim issuer at the asset level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
      #[doc = "* asset_id - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn add_default_trusted_claim_issuer(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        issuer: types::polymesh_primitives::condition::TrustedIssuer,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: ComplianceManagerCall :: add_default_trusted_claim_issuer { asset_id , issuer , }))
      }
      #[doc = "Adds another default trusted claim issuer at the asset level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
      #[doc = "* asset_id - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn add_default_trusted_claim_issuer(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        issuer: types::polymesh_primitives::condition::TrustedIssuer,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 6u8];
        asset_id.encode_to(&mut buf);
        issuer.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the given `issuer` from the set of default trusted claim issuers at the asset level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
      #[doc = "* asset_id - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_default_trusted_claim_issuer(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        issuer: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: ComplianceManagerCall :: remove_default_trusted_claim_issuer { asset_id , issuer , }))
      }
      #[doc = "Removes the given `issuer` from the set of default trusted claim issuers at the asset level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
      #[doc = "* asset_id - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_default_trusted_claim_issuer(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        issuer: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 7u8];
        asset_id.encode_to(&mut buf);
        issuer.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Modify an existing compliance requirement of a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
      #[doc = "* asset_id - Symbol of the asset."]
      #[doc = "* new_req - Compliance requirement."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn change_compliance_requirement(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        new_req: types::polymesh_primitives::compliance_manager::ComplianceRequirement,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::change_compliance_requirement {
            asset_id,
            new_req,
          },
        ))
      }
      #[doc = "Modify an existing compliance requirement of a given asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
      #[doc = "* asset_id - Symbol of the asset."]
      #[doc = "* new_req - Compliance requirement."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn change_compliance_requirement(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        new_req: types::polymesh_primitives::compliance_manager::ComplianceRequirement,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 8u8];
        asset_id.encode_to(&mut buf);
        new_req.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ComplianceManagerCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ComplianceManagerQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ComplianceManagerQueryApi<'api> {
      #[doc = " Compliance for an asset ([`AssetId`] -> [`AssetCompliance`])"]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_compliances(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::compliance_manager::AssetCompliance,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 174u8, 4u8, 188u8, 209u8, 112u8, 119u8, 72u8, 235u8, 75u8, 159u8, 89u8,
          9u8, 248u8, 244u8, 242u8, 195u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::polymesh_primitives::compliance_manager::AssetCompliance>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Compliance for an asset ([`AssetId`] -> [`AssetCompliance`])"]
      #[cfg(feature = "ink")]
      pub fn asset_compliances(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::compliance_manager::AssetCompliance,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 174u8, 4u8, 188u8, 209u8, 112u8, 119u8, 72u8, 235u8, 75u8, 159u8, 89u8,
          9u8, 248u8, 244u8, 242u8, 195u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::polymesh_primitives::compliance_manager::AssetCompliance>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " List of trusted claim issuer [`AssetId`] -> Issuer Identity"]
      #[cfg(not(feature = "ink"))]
      pub async fn trusted_claim_issuer(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 7u8, 112u8, 219u8, 149u8, 59u8, 221u8, 90u8, 127u8, 146u8, 167u8, 42u8,
          117u8, 122u8, 15u8, 129u8, 253u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " List of trusted claim issuer [`AssetId`] -> Issuer Identity"]
      #[cfg(feature = "ink")]
      pub fn trusted_claim_issuer(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 7u8, 112u8, 219u8, 149u8, 59u8, 221u8, 90u8, 127u8, 146u8, 167u8, 42u8,
          117u8, 122u8, 15u8, 129u8, 253u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_compliance_manager::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_compliance_manager::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_compliance_manager::Version> {
        let value = self.api.read_storage(::alloc::vec![
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_compliance_manager::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct ComplianceManagerPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> ComplianceManagerPagedQueryApi<'api> {
      #[doc = " Compliance for an asset ([`AssetId`] -> [`AssetCompliance`])"]
      pub fn asset_compliances(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::polymesh_primitives::compliance_manager::AssetCompliance,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 174u8, 4u8, 188u8, 209u8, 112u8, 119u8, 72u8, 235u8, 75u8, 159u8, 89u8,
          9u8, 248u8, 244u8, 242u8, 195u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " List of trusted claim issuer [`AssetId`] -> Issuer Identity"]
      pub fn trusted_claim_issuer(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        ::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 7u8, 112u8, 219u8, 149u8, 59u8, 221u8, 90u8, 127u8, 146u8, 167u8, 42u8,
          117u8, 122u8, 15u8, 129u8, 253u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
    }
  }
  pub mod corporate_action {
    use super::*;
    #[derive(Clone)]
    pub struct CorporateActionCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CorporateActionCallApi<'api> {
      #[doc = "Set the max `length` of `details` in terms of bytes."]
      #[doc = "May only be called via a PIP."]
      #[cfg(not(feature = "ink"))]
      pub fn set_max_details_length(
        &self,
        length: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::set_max_details_length { length },
        ))
      }
      #[doc = "Set the max `length` of `details` in terms of bytes."]
      #[doc = "May only be called via a PIP."]
      #[cfg(feature = "ink")]
      pub fn set_max_details_length(&self, length: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 0u8];
        length.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the default CA `TargetIdentities` to `targets`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` for which the default identities are changing."]
      #[doc = "- `targets` the default target identities for a CA."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_default_targets(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        targets: types::pallet_corporate_actions::TargetIdentities,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::set_default_targets {
            asset_id,
            targets,
          },
        ))
      }
      #[doc = "Set the default CA `TargetIdentities` to `targets`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` for which the default identities are changing."]
      #[doc = "- `targets` the default target identities for a CA."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_default_targets(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        targets: types::pallet_corporate_actions::TargetIdentities,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 1u8];
        asset_id.encode_to(&mut buf);
        targets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the default withholding tax for all DIDs and CAs relevant to this `asset_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` that the withholding tax will apply to."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_default_withholding_tax(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        tax: ::polymesh_api_client::per_things::Permill,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::set_default_withholding_tax {
            asset_id,
            tax,
          },
        ))
      }
      #[doc = "Set the default withholding tax for all DIDs and CAs relevant to this `asset_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` that the withholding tax will apply to."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_default_withholding_tax(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        tax: ::polymesh_api_client::per_things::Permill,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 2u8];
        asset_id.encode_to(&mut buf);
        tax.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the withholding tax of `asset_id` for `taxed_did` to `tax`."]
      #[doc = "If `Some(tax)`, this overrides the default withholding tax of `asset_id` to `tax` for `taxed_did`."]
      #[doc = "Otherwise, if `None`, the default withholding tax will be used."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` that the withholding tax will apply to."]
      #[doc = "- `taxed_did` that will have its withholding tax updated."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_did_withholding_tax(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        taxed_did: ::polymesh_api_client::IdentityId,
        tax: Option<::polymesh_api_client::per_things::Permill>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::set_did_withholding_tax {
            asset_id,
            taxed_did,
            tax,
          },
        ))
      }
      #[doc = "Set the withholding tax of `asset_id` for `taxed_did` to `tax`."]
      #[doc = "If `Some(tax)`, this overrides the default withholding tax of `asset_id` to `tax` for `taxed_did`."]
      #[doc = "Otherwise, if `None`, the default withholding tax will be used."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` that the withholding tax will apply to."]
      #[doc = "- `taxed_did` that will have its withholding tax updated."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_did_withholding_tax(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        taxed_did: ::polymesh_api_client::IdentityId,
        tax: Option<::polymesh_api_client::per_things::Permill>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 3u8];
        asset_id.encode_to(&mut buf);
        taxed_did.encode_to(&mut buf);
        tax.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Initiates a CA for `asset_id` of `kind` with `details` and other provided arguments."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` that the CA is made for."]
      #[doc = "- `kind` of CA being initiated."]
      #[doc = "- `decl_date` of CA bring initialized."]
      #[doc = "- `record_date`, if any, to calculate the impact of this CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = "- `details` of the CA in free-text form, up to a certain number of bytes in length."]
      #[doc = "- `targets`, if any, which this CA is relevant/irrelevant to."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_targets`)."]
      #[doc = "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)."]
      #[doc = "- `withholding_tax`, if any, provides per-DID withholding tax overrides."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `CounterOverflow` in the unlikely event that so many CAs were created for this `asset_id`,"]
      #[doc = "  that integer overflow would have occured if instead allowed."]
      #[doc = "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`."]
      #[doc = "- `DuplicateDidTax` if a DID is included more than once in `wt`."]
      #[doc = "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`."]
      #[doc = "- `DeclDateInFuture` if the declaration date is not in the past."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn initiate_corporate_action(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        kind: types::pallet_corporate_actions::CAKind,
        decl_date: u64,
        record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
        details: types::pallet_corporate_actions::CADetails,
        targets: Option<types::pallet_corporate_actions::TargetIdentities>,
        default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
        withholding_tax: Option<
          ::alloc::vec::Vec<(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::per_things::Permill,
          )>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::initiate_corporate_action {
            asset_id,
            kind,
            decl_date,
            record_date,
            details,
            targets,
            default_withholding_tax,
            withholding_tax,
          },
        ))
      }
      #[doc = "Initiates a CA for `asset_id` of `kind` with `details` and other provided arguments."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
      #[doc = "- `asset_id` that the CA is made for."]
      #[doc = "- `kind` of CA being initiated."]
      #[doc = "- `decl_date` of CA bring initialized."]
      #[doc = "- `record_date`, if any, to calculate the impact of this CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = "- `details` of the CA in free-text form, up to a certain number of bytes in length."]
      #[doc = "- `targets`, if any, which this CA is relevant/irrelevant to."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_targets`)."]
      #[doc = "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)."]
      #[doc = "- `withholding_tax`, if any, provides per-DID withholding tax overrides."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `CounterOverflow` in the unlikely event that so many CAs were created for this `asset_id`,"]
      #[doc = "  that integer overflow would have occured if instead allowed."]
      #[doc = "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`."]
      #[doc = "- `DuplicateDidTax` if a DID is included more than once in `wt`."]
      #[doc = "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`."]
      #[doc = "- `DeclDateInFuture` if the declaration date is not in the past."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn initiate_corporate_action(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        kind: types::pallet_corporate_actions::CAKind,
        decl_date: u64,
        record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
        details: types::pallet_corporate_actions::CADetails,
        targets: Option<types::pallet_corporate_actions::TargetIdentities>,
        default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
        withholding_tax: Option<
          ::alloc::vec::Vec<(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::per_things::Permill,
          )>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 4u8];
        asset_id.encode_to(&mut buf);
        kind.encode_to(&mut buf);
        decl_date.encode_to(&mut buf);
        record_date.encode_to(&mut buf);
        details.encode_to(&mut buf);
        targets.encode_to(&mut buf);
        default_withholding_tax.encode_to(&mut buf);
        withholding_tax.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Link the given CA `id` to the given `docs`."]
      #[doc = "Any previous links for the CA are removed in favor of `docs`."]
      #[doc = ""]
      #[doc = "The workflow here is to add the documents and initiating the CA in any order desired."]
      #[doc = "Once both exist, they can now be linked together."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `id.asset_id` with relevant permissions."]
      #[doc = "- `id` of the CA to associate with `docs`."]
      #[doc = "- `docs` to associate with the CA with `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- `NoSuchDoc` if any of `docs` does not identify an existing document."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn link_ca_doc(
        &self,
        id: types::pallet_corporate_actions::CAId,
        docs: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::link_ca_doc { id, docs },
        ))
      }
      #[doc = "Link the given CA `id` to the given `docs`."]
      #[doc = "Any previous links for the CA are removed in favor of `docs`."]
      #[doc = ""]
      #[doc = "The workflow here is to add the documents and initiating the CA in any order desired."]
      #[doc = "Once both exist, they can now be linked together."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `id.asset_id` with relevant permissions."]
      #[doc = "- `id` of the CA to associate with `docs`."]
      #[doc = "- `docs` to associate with the CA with `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- `NoSuchDoc` if any of `docs` does not identify an existing document."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn link_ca_doc(
        &self,
        id: types::pallet_corporate_actions::CAId,
        docs: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 5u8];
        id.encode_to(&mut buf);
        docs.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "Associated data, such as document links, ballots,"]
      #[doc = "and capital distributions are also removed."]
      #[doc = ""]
      #[doc = "Any schedule associated with the record date will see"]
      #[doc = "`strong_ref_count(schedule_id)` decremented."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_ca(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::remove_ca { ca_id },
        ))
      }
      #[doc = "Removes the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "Associated data, such as document links, ballots,"]
      #[doc = "and capital distributions are also removed."]
      #[doc = ""]
      #[doc = "Any schedule associated with the record date will see"]
      #[doc = "`strong_ref_count(schedule_id)` decremented."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_ca(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 6u8];
        ca_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the record date of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to alter."]
      #[doc = "- `record_date`, if any, to calculate the impact of the CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn change_record_date(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::change_record_date {
            ca_id,
            record_date,
          },
        ))
      }
      #[doc = "Changes the record date of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to alter."]
      #[doc = "- `record_date`, if any, to calculate the impact of the CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn change_record_date(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 7u8];
        ca_id.encode_to(&mut buf);
        record_date.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Utility extrinsic to batch `initiate_corporate_action` and `distribute`"]
      #[cfg(not(feature = "ink"))]
      pub fn initiate_corporate_action_and_distribute(
        &self,
        ca_args: types::pallet_corporate_actions::InitiateCorporateActionArgs,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
        currency: ::polymesh_api_client::AssetId,
        per_share: u128,
        amount: u128,
        payment_at: u64,
        expires_at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: CorporateAction (types :: pallet_corporate_actions :: CorporateActionCall :: initiate_corporate_action_and_distribute { ca_args , portfolio , currency , per_share , amount , payment_at , expires_at , }))
      }
      #[doc = "Utility extrinsic to batch `initiate_corporate_action` and `distribute`"]
      #[cfg(feature = "ink")]
      pub fn initiate_corporate_action_and_distribute(
        &self,
        ca_args: types::pallet_corporate_actions::InitiateCorporateActionArgs,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
        currency: ::polymesh_api_client::AssetId,
        per_share: u128,
        amount: u128,
        payment_at: u64,
        expires_at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 8u8];
        ca_args.encode_to(&mut buf);
        portfolio.encode_to(&mut buf);
        currency.encode_to(&mut buf);
        per_share.encode_to(&mut buf);
        amount.encode_to(&mut buf);
        payment_at.encode_to(&mut buf);
        expires_at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for CorporateActionCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CorporateActionQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CorporateActionQueryApi<'api> {
      #[doc = " Determines the maximum number of bytes that the free-form `details` of a CA can store."]
      #[doc = ""]
      #[doc = " Note that this is not the number of `char`s or the number of [graphemes]."]
      #[doc = " While this may be unnatural in terms of human understanding of a text's length,"]
      #[doc = " it more closely reflects actual storage costs (`'a'` is cheaper to store than an emoji)."]
      #[doc = ""]
      #[doc = " [graphemes]: https://en.wikipedia.org/wiki/Grapheme"]
      #[cfg(not(feature = "ink"))]
      pub async fn max_details_length(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 35u8, 28u8, 123u8, 214u8, 108u8, 218u8, 59u8, 20u8, 118u8, 8u8, 139u8,
          67u8, 69u8, 136u8, 180u8, 5u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Determines the maximum number of bytes that the free-form `details` of a CA can store."]
      #[doc = ""]
      #[doc = " Note that this is not the number of `char`s or the number of [graphemes]."]
      #[doc = " While this may be unnatural in terms of human understanding of a text's length,"]
      #[doc = " it more closely reflects actual storage costs (`'a'` is cheaper to store than an emoji)."]
      #[doc = ""]
      #[doc = " [graphemes]: https://en.wikipedia.org/wiki/Grapheme"]
      #[cfg(feature = "ink")]
      pub fn max_details_length(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 35u8, 28u8, 123u8, 214u8, 108u8, 218u8, 59u8, 20u8, 118u8, 8u8, 139u8,
          67u8, 69u8, 136u8, 180u8, 5u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The identities targeted by default for CAs for this asset,"]
      #[doc = " either to be excluded or included."]
      #[doc = ""]
      #[doc = " (AssetId => target identities)"]
      #[cfg(not(feature = "ink"))]
      pub async fn default_target_identities(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::TargetIdentities>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 77u8, 99u8, 45u8, 196u8, 84u8, 74u8, 106u8, 171u8, 172u8, 166u8,
          213u8, 51u8, 51u8, 209u8, 34u8, 188u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 1u8];
          <types::pallet_corporate_actions::TargetIdentities>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The identities targeted by default for CAs for this asset,"]
      #[doc = " either to be excluded or included."]
      #[doc = ""]
      #[doc = " (AssetId => target identities)"]
      #[cfg(feature = "ink")]
      pub fn default_target_identities(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::TargetIdentities>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 77u8, 99u8, 45u8, 196u8, 84u8, 74u8, 106u8, 171u8, 172u8, 166u8,
          213u8, 51u8, 51u8, 209u8, 34u8, 188u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 1u8];
          <types::pallet_corporate_actions::TargetIdentities>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The default amount of tax to withhold (\"withholding tax\", WT) for this asset when distributing dividends."]
      #[doc = ""]
      #[doc = " To understand withholding tax, e.g., let's assume that you hold ACME shares."]
      #[doc = " ACME now decides to distribute 100 SEK to Alice."]
      #[doc = " Alice lives in Sweden, so Skatteverket (the Swedish tax authority) wants 30% of that."]
      #[doc = " Then those 100 * 30% are withheld from Alice, and ACME will send them to Skatteverket."]
      #[doc = ""]
      #[doc = " (AssetId => % to withhold)"]
      #[cfg(not(feature = "ink"))]
      pub async fn default_withholding_tax(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Permill> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 170u8, 50u8, 103u8, 81u8, 229u8, 40u8, 244u8, 16u8, 164u8, 129u8,
          103u8, 210u8, 52u8, 41u8, 13u8, 197u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Permill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The default amount of tax to withhold (\"withholding tax\", WT) for this asset when distributing dividends."]
      #[doc = ""]
      #[doc = " To understand withholding tax, e.g., let's assume that you hold ACME shares."]
      #[doc = " ACME now decides to distribute 100 SEK to Alice."]
      #[doc = " Alice lives in Sweden, so Skatteverket (the Swedish tax authority) wants 30% of that."]
      #[doc = " Then those 100 * 30% are withheld from Alice, and ACME will send them to Skatteverket."]
      #[doc = ""]
      #[doc = " (AssetId => % to withhold)"]
      #[cfg(feature = "ink")]
      pub fn default_withholding_tax(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Permill> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 170u8, 50u8, 103u8, 81u8, 229u8, 40u8, 244u8, 16u8, 164u8, 129u8,
          103u8, 210u8, 52u8, 41u8, 13u8, 197u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Permill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The amount of tax to withhold (\"withholding tax\", WT) for a certain AssetId x DID."]
      #[doc = " If an entry exists for a certain DID, it overrides the default in `DefaultWithholdingTax`."]
      #[doc = ""]
      #[doc = " (AssetId => [(did, % to withhold)]"]
      #[cfg(not(feature = "ink"))]
      pub async fn did_withholding_tax(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::per_things::Permill,
        )>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 224u8, 222u8, 223u8, 202u8, 239u8, 39u8, 125u8, 98u8, 152u8, 237u8,
          195u8, 114u8, 134u8, 40u8, 221u8, 13u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::per_things::Permill,
          )>>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The amount of tax to withhold (\"withholding tax\", WT) for a certain AssetId x DID."]
      #[doc = " If an entry exists for a certain DID, it overrides the default in `DefaultWithholdingTax`."]
      #[doc = ""]
      #[doc = " (AssetId => [(did, % to withhold)]"]
      #[cfg(feature = "ink")]
      pub fn did_withholding_tax(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::per_things::Permill,
        )>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 224u8, 222u8, 223u8, 202u8, 239u8, 39u8, 125u8, 98u8, 152u8, 237u8,
          195u8, 114u8, 134u8, 40u8, 221u8, 13u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::per_things::Permill,
          )>>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The next per-`AssetId` CA ID in the sequence."]
      #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence."]
      #[cfg(not(feature = "ink"))]
      pub async fn ca_id_sequence(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::LocalCAId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 82u8, 91u8, 86u8, 204u8, 80u8, 123u8, 119u8, 166u8, 116u8, 44u8,
          136u8, 13u8, 78u8, 115u8, 129u8, 34u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_corporate_actions::LocalCAId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next per-`AssetId` CA ID in the sequence."]
      #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence."]
      #[cfg(feature = "ink")]
      pub fn ca_id_sequence(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::LocalCAId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 82u8, 91u8, 86u8, 204u8, 80u8, 123u8, 119u8, 166u8, 116u8, 44u8,
          136u8, 13u8, 78u8, 115u8, 129u8, 34u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_corporate_actions::LocalCAId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All recorded CAs thus far."]
      #[doc = " Only generic information is stored here."]
      #[doc = " Specific `CAKind`s, e.g., benefits and corporate ballots, may use additional on-chain storage."]
      #[doc = ""]
      #[doc = " (AssetId => local ID => the corporate action)"]
      #[cfg(not(feature = "ink"))]
      pub async fn corporate_actions(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::pallet_corporate_actions::LocalCAId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_corporate_actions::CorporateAction>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 14u8, 36u8, 40u8, 25u8, 103u8, 79u8, 185u8, 193u8, 131u8, 31u8, 153u8,
          37u8, 135u8, 74u8, 8u8, 159u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All recorded CAs thus far."]
      #[doc = " Only generic information is stored here."]
      #[doc = " Specific `CAKind`s, e.g., benefits and corporate ballots, may use additional on-chain storage."]
      #[doc = ""]
      #[doc = " (AssetId => local ID => the corporate action)"]
      #[cfg(feature = "ink")]
      pub fn corporate_actions(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::pallet_corporate_actions::LocalCAId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_corporate_actions::CorporateAction>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 14u8, 36u8, 40u8, 25u8, 103u8, 79u8, 185u8, 193u8, 131u8, 31u8, 153u8,
          37u8, 135u8, 74u8, 8u8, 159u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Associations from CAs to `Document`s via their IDs."]
      #[doc = " (CAId => [DocumentId])"]
      #[doc = ""]
      #[doc = " The `CorporateActions` map stores `AssetId => LocalId => The CA`,"]
      #[doc = " so we can infer `AssetId => CAId`. Therefore, we don't need a double map."]
      #[cfg(not(feature = "ink"))]
      pub async fn ca_doc_link(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 120u8, 114u8, 125u8, 160u8, 162u8, 78u8, 111u8, 100u8, 74u8, 192u8,
          8u8, 173u8, 45u8, 35u8, 163u8, 153u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Associations from CAs to `Document`s via their IDs."]
      #[doc = " (CAId => [DocumentId])"]
      #[doc = ""]
      #[doc = " The `CorporateActions` map stores `AssetId => LocalId => The CA`,"]
      #[doc = " so we can infer `AssetId => CAId`. Therefore, we don't need a double map."]
      #[cfg(feature = "ink")]
      pub fn ca_doc_link(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 120u8, 114u8, 125u8, 160u8, 162u8, 78u8, 111u8, 100u8, 74u8, 192u8,
          8u8, 173u8, 45u8, 35u8, 163u8, 153u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Associates details in free-form text with a CA by its ID."]
      #[doc = " (CAId => CADetails)"]
      #[cfg(not(feature = "ink"))]
      pub async fn details(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::CADetails> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8, 198u8, 220u8,
          28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::CADetails>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Associates details in free-form text with a CA by its ID."]
      #[doc = " (CAId => CADetails)"]
      #[cfg(feature = "ink")]
      pub fn details(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::CADetails> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8, 198u8, 220u8,
          28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::CADetails>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::Version> {
        let value = self.api.read_storage(::alloc::vec![
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct CorporateActionPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> CorporateActionPagedQueryApi<'api> {
      #[doc = " The identities targeted by default for CAs for this asset,"]
      #[doc = " either to be excluded or included."]
      #[doc = ""]
      #[doc = " (AssetId => target identities)"]
      pub fn default_target_identities(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::pallet_corporate_actions::TargetIdentities,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 77u8, 99u8, 45u8, 196u8, 84u8, 74u8, 106u8, 171u8, 172u8, 166u8,
          213u8, 51u8, 51u8, 209u8, 34u8, 188u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The default amount of tax to withhold (\"withholding tax\", WT) for this asset when distributing dividends."]
      #[doc = ""]
      #[doc = " To understand withholding tax, e.g., let's assume that you hold ACME shares."]
      #[doc = " ACME now decides to distribute 100 SEK to Alice."]
      #[doc = " Alice lives in Sweden, so Skatteverket (the Swedish tax authority) wants 30% of that."]
      #[doc = " Then those 100 * 30% are withheld from Alice, and ACME will send them to Skatteverket."]
      #[doc = ""]
      #[doc = " (AssetId => % to withhold)"]
      pub fn default_withholding_tax(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        ::polymesh_api_client::per_things::Permill,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 170u8, 50u8, 103u8, 81u8, 229u8, 40u8, 244u8, 16u8, 164u8, 129u8,
          103u8, 210u8, 52u8, 41u8, 13u8, 197u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The amount of tax to withhold (\"withholding tax\", WT) for a certain AssetId x DID."]
      #[doc = " If an entry exists for a certain DID, it overrides the default in `DefaultWithholdingTax`."]
      #[doc = ""]
      #[doc = " (AssetId => [(did, % to withhold)]"]
      pub fn did_withholding_tax(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        ::alloc::vec::Vec<(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::per_things::Permill,
        )>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 224u8, 222u8, 223u8, 202u8, 239u8, 39u8, 125u8, 98u8, 152u8, 237u8,
          195u8, 114u8, 134u8, 40u8, 221u8, 13u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The next per-`AssetId` CA ID in the sequence."]
      #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence."]
      pub fn ca_id_sequence(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::pallet_corporate_actions::LocalCAId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 82u8, 91u8, 86u8, 204u8, 80u8, 123u8, 119u8, 166u8, 116u8, 44u8,
          136u8, 13u8, 78u8, 115u8, 129u8, 34u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " All recorded CAs thus far."]
      #[doc = " Only generic information is stored here."]
      #[doc = " Specific `CAKind`s, e.g., benefits and corporate ballots, may use additional on-chain storage."]
      #[doc = ""]
      #[doc = " (AssetId => local ID => the corporate action)"]
      pub fn corporate_actions(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_corporate_actions::LocalCAId,
        types::pallet_corporate_actions::CorporateAction,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 14u8, 36u8, 40u8, 25u8, 103u8, 79u8, 185u8, 193u8, 131u8, 31u8, 153u8,
          37u8, 135u8, 74u8, 8u8, 159u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Associations from CAs to `Document`s via their IDs."]
      #[doc = " (CAId => [DocumentId])"]
      #[doc = ""]
      #[doc = " The `CorporateActions` map stores `AssetId => LocalId => The CA`,"]
      #[doc = " so we can infer `AssetId => CAId`. Therefore, we don't need a double map."]
      pub fn ca_doc_link(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_corporate_actions::CAId,
        ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 120u8, 114u8, 125u8, 160u8, 162u8, 78u8, 111u8, 100u8, 74u8, 192u8,
          8u8, 173u8, 45u8, 35u8, 163u8, 153u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Associates details in free-form text with a CA by its ID."]
      #[doc = " (CAId => CADetails)"]
      pub fn details(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_corporate_actions::CAId,
        types::pallet_corporate_actions::CADetails,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8, 198u8, 220u8,
          28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
    }
  }
  pub mod corporate_ballot {
    use super::*;
    #[derive(Clone)]
    pub struct CorporateBallotCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CorporateBallotCallApi<'api> {
      #[doc = "Attach a corporate ballot to the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "The ballot will admit votes within `range`."]
      #[doc = "The ballot's metadata is provided by `meta`,"]
      #[doc = "which includes the ballot title, the motions, their choices, etc."]
      #[doc = "See the `BallotMeta` for more."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the CA to attach the ballot to."]
      #[doc = "- `range` specifies when voting starts and ends."]
      #[doc = "- `meta` specifies the ballot's metadata as aforementioned."]
      #[doc = "- `rcv` specifies whether RCV is enabled for this ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `CANotNotice` if the CA is not of the `IssuerNotice` kind."]
      #[doc = "- `StartAfterEnd` if `range.start > range.end`."]
      #[doc = "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp."]
      #[doc = "- `NoRecordDate` if CA has no record date."]
      #[doc = "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date."]
      #[doc = "- `AlreadyExists` if there's a ballot already."]
      #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
      #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
      #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
      #[cfg(not(feature = "ink"))]
      pub fn attach_ballot(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        range: types::pallet_corporate_actions::ballot::BallotTimeRange,
        meta: types::pallet_corporate_actions::ballot::BallotMeta,
        rcv: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::attach_ballot {
            ca_id,
            range,
            meta,
            rcv,
          },
        ))
      }
      #[doc = "Attach a corporate ballot to the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "The ballot will admit votes within `range`."]
      #[doc = "The ballot's metadata is provided by `meta`,"]
      #[doc = "which includes the ballot title, the motions, their choices, etc."]
      #[doc = "See the `BallotMeta` for more."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the CA to attach the ballot to."]
      #[doc = "- `range` specifies when voting starts and ends."]
      #[doc = "- `meta` specifies the ballot's metadata as aforementioned."]
      #[doc = "- `rcv` specifies whether RCV is enabled for this ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `CANotNotice` if the CA is not of the `IssuerNotice` kind."]
      #[doc = "- `StartAfterEnd` if `range.start > range.end`."]
      #[doc = "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp."]
      #[doc = "- `NoRecordDate` if CA has no record date."]
      #[doc = "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date."]
      #[doc = "- `AlreadyExists` if there's a ballot already."]
      #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
      #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
      #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
      #[cfg(feature = "ink")]
      pub fn attach_ballot(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        range: types::pallet_corporate_actions::ballot::BallotTimeRange,
        meta: types::pallet_corporate_actions::ballot::BallotMeta,
        rcv: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 0u8];
        ca_id.encode_to(&mut buf);
        range.encode_to(&mut buf);
        meta.encode_to(&mut buf);
        rcv.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Cast `votes` in the ballot attached to the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be a permissioned signer targeted by the CA."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `votes` specifies the balances to assign to each choice in the ballot."]
      #[doc = "   The full voting power of `origin`'s DID may be used for each motion in the ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingNotStarted` if the voting period hasn't commenced yet."]
      #[doc = "- `VotingAlreadyEnded` if the voting period has ended."]
      #[doc = "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
      #[doc = "- `InsufficientVotes` if the voting power used for any motion in `votes`"]
      #[doc = "   exceeds `origin`'s DID's voting power."]
      #[cfg(not(feature = "ink"))]
      pub fn vote(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        votes: ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::vote { ca_id, votes },
        ))
      }
      #[doc = "Cast `votes` in the ballot attached to the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be a permissioned signer targeted by the CA."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `votes` specifies the balances to assign to each choice in the ballot."]
      #[doc = "   The full voting power of `origin`'s DID may be used for each motion in the ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingNotStarted` if the voting period hasn't commenced yet."]
      #[doc = "- `VotingAlreadyEnded` if the voting period has ended."]
      #[doc = "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
      #[doc = "- `InsufficientVotes` if the voting power used for any motion in `votes`"]
      #[doc = "   exceeds `origin`'s DID's voting power."]
      #[cfg(feature = "ink")]
      pub fn vote(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        votes: ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 1u8];
        ca_id.encode_to(&mut buf);
        votes.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Amend the end date of the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `end` specifies the new end date of the ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[doc = "- `StartAfterEnd` if `start > end`."]
      #[cfg(not(feature = "ink"))]
      pub fn change_end(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        end: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::change_end { ca_id, end },
        ))
      }
      #[doc = "Amend the end date of the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `end` specifies the new end date of the ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[doc = "- `StartAfterEnd` if `start > end`."]
      #[cfg(feature = "ink")]
      pub fn change_end(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        end: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 2u8];
        ca_id.encode_to(&mut buf);
        end.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `meta` specifies the new metadata."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
      #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
      #[cfg(not(feature = "ink"))]
      pub fn change_meta(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        meta: types::pallet_corporate_actions::ballot::BallotMeta,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::change_meta { ca_id, meta },
        ))
      }
      #[doc = "Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `meta` specifies the new metadata."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
      #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
      #[cfg(feature = "ink")]
      pub fn change_meta(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        meta: types::pallet_corporate_actions::ballot::BallotMeta,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 3u8];
        ca_id.encode_to(&mut buf);
        meta.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Amend RCV support for the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `rcv` specifies if RCV is to be supported or not."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[cfg(not(feature = "ink"))]
      pub fn change_rcv(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        rcv: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::change_rcv { ca_id, rcv },
        ))
      }
      #[doc = "Amend RCV support for the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `rcv` specifies if RCV is to be supported or not."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[cfg(feature = "ink")]
      pub fn change_rcv(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        rcv: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 4u8];
        ca_id.encode_to(&mut buf);
        rcv.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_ballot(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::remove_ballot { ca_id },
        ))
      }
      #[doc = "Remove the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[cfg(feature = "ink")]
      pub fn remove_ballot(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 5u8];
        ca_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for CorporateBallotCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CorporateBallotQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CorporateBallotQueryApi<'api> {
      #[doc = " Metadata of a corporate ballot."]
      #[doc = ""]
      #[doc = " (CAId) => BallotMeta"]
      #[cfg(not(feature = "ink"))]
      pub async fn metas(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_corporate_actions::ballot::BallotMeta>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 156u8, 233u8, 150u8, 83u8, 80u8, 111u8, 149u8, 210u8, 238u8, 76u8,
          158u8, 22u8, 106u8, 202u8, 6u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Metadata of a corporate ballot."]
      #[doc = ""]
      #[doc = " (CAId) => BallotMeta"]
      #[cfg(feature = "ink")]
      pub fn metas(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_corporate_actions::ballot::BallotMeta>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 156u8, 233u8, 150u8, 83u8, 80u8, 111u8, 149u8, 210u8, 238u8, 76u8,
          158u8, 22u8, 106u8, 202u8, 6u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Time details of a corporate ballot associated with a CA."]
      #[doc = " The timestamps denote when voting starts and stops."]
      #[doc = ""]
      #[doc = " (CAId) => BallotTimeRange"]
      #[cfg(not(feature = "ink"))]
      pub async fn time_ranges(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_corporate_actions::ballot::BallotTimeRange>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 224u8, 44u8, 93u8, 167u8, 153u8, 243u8, 193u8, 143u8, 81u8, 133u8,
          254u8, 177u8, 13u8, 204u8, 115u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Time details of a corporate ballot associated with a CA."]
      #[doc = " The timestamps denote when voting starts and stops."]
      #[doc = ""]
      #[doc = " (CAId) => BallotTimeRange"]
      #[cfg(feature = "ink")]
      pub fn time_ranges(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_corporate_actions::ballot::BallotTimeRange>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 224u8, 44u8, 93u8, 167u8, 153u8, 243u8, 193u8, 143u8, 81u8, 133u8,
          254u8, 177u8, 13u8, 204u8, 115u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Stores how many choices there are in each motion."]
      #[doc = ""]
      #[doc = " At all times, the invariant holds that `motion_choices[idx]` is equal to"]
      #[doc = " `metas.unwrap().motions[idx].choices.len()`. That is, this is just a cache,"]
      #[doc = " used to avoid fetching all the motions with their associated texts."]
      #[doc = ""]
      #[doc = " `u16` choices should be more than enough to fit real use cases."]
      #[doc = ""]
      #[doc = " (CAId) => Number of choices in each motion."]
      #[cfg(not(feature = "ink"))]
      pub async fn motion_num_choices(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u16>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 128u8, 121u8, 46u8, 246u8, 146u8, 237u8, 189u8, 150u8, 253u8, 219u8,
          95u8, 102u8, 195u8, 212u8, 151u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u16>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores how many choices there are in each motion."]
      #[doc = ""]
      #[doc = " At all times, the invariant holds that `motion_choices[idx]` is equal to"]
      #[doc = " `metas.unwrap().motions[idx].choices.len()`. That is, this is just a cache,"]
      #[doc = " used to avoid fetching all the motions with their associated texts."]
      #[doc = ""]
      #[doc = " `u16` choices should be more than enough to fit real use cases."]
      #[doc = ""]
      #[doc = " (CAId) => Number of choices in each motion."]
      #[cfg(feature = "ink")]
      pub fn motion_num_choices(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u16>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 128u8, 121u8, 46u8, 246u8, 146u8, 237u8, 189u8, 150u8, 253u8, 219u8,
          95u8, 102u8, 195u8, 212u8, 151u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u16>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Is ranked choice voting (RCV) enabled for this ballot?"]
      #[doc = " For an understanding of how RCV is handled, see note on `BallotVote`'s `fallback` field."]
      #[doc = ""]
      #[doc = " (CAId) => bool"]
      #[cfg(not(feature = "ink"))]
      pub async fn rcv(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 255u8, 206u8, 156u8, 27u8, 141u8, 170u8, 167u8, 14u8, 136u8, 113u8,
          191u8, 30u8, 171u8, 45u8, 90u8, 96u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Is ranked choice voting (RCV) enabled for this ballot?"]
      #[doc = " For an understanding of how RCV is handled, see note on `BallotVote`'s `fallback` field."]
      #[doc = ""]
      #[doc = " (CAId) => bool"]
      #[cfg(feature = "ink")]
      pub fn rcv(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 255u8, 206u8, 156u8, 27u8, 141u8, 170u8, 167u8, 14u8, 136u8, 113u8,
          191u8, 30u8, 171u8, 45u8, 90u8, 96u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores the total vote tally on each choice."]
      #[doc = ""]
      #[doc = " RCV is not accounted for,"]
      #[doc = " as there are too many wants to interpret the graph,"]
      #[doc = " and because it would not be efficient."]
      #[doc = ""]
      #[doc = " (CAId) => [current vote weights]"]
      #[cfg(not(feature = "ink"))]
      pub async fn results(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 2u8, 53u8, 15u8, 184u8, 68u8, 197u8, 167u8, 101u8, 105u8, 101u8,
          134u8, 40u8, 189u8, 68u8, 197u8, 62u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u128>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores the total vote tally on each choice."]
      #[doc = ""]
      #[doc = " RCV is not accounted for,"]
      #[doc = " as there are too many wants to interpret the graph,"]
      #[doc = " and because it would not be efficient."]
      #[doc = ""]
      #[doc = " (CAId) => [current vote weights]"]
      #[cfg(feature = "ink")]
      pub fn results(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 2u8, 53u8, 15u8, 184u8, 68u8, 197u8, 167u8, 101u8, 105u8, 101u8,
          134u8, 40u8, 189u8, 68u8, 197u8, 62u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u128>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores each DID's votes in a given ballot."]
      #[doc = " See the documentation of `BallotVote` for notes on semantics."]
      #[doc = ""]
      #[doc = " (CAId) => (DID) => [vote weight]"]
      #[doc = ""]
      #[doc = " User must enter 0 vote weight if they don't want to vote for a choice."]
      #[cfg(not(feature = "ink"))]
      pub async fn votes(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8, 230u8, 150u8,
          237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Stores each DID's votes in a given ballot."]
      #[doc = " See the documentation of `BallotVote` for notes on semantics."]
      #[doc = ""]
      #[doc = " (CAId) => (DID) => [vote weight]"]
      #[doc = ""]
      #[doc = " User must enter 0 vote weight if they don't want to vote for a choice."]
      #[cfg(feature = "ink")]
      pub fn votes(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8, 230u8, 150u8,
          237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::ballot::Version>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::ballot::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::ballot::Version>
      {
        let value = self.api.read_storage(::alloc::vec![
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::ballot::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct CorporateBallotPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> CorporateBallotPagedQueryApi<'api> {
      #[doc = " Metadata of a corporate ballot."]
      #[doc = ""]
      #[doc = " (CAId) => BallotMeta"]
      pub fn metas(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_corporate_actions::CAId,
        types::pallet_corporate_actions::ballot::BallotMeta,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 156u8, 233u8, 150u8, 83u8, 80u8, 111u8, 149u8, 210u8, 238u8, 76u8,
          158u8, 22u8, 106u8, 202u8, 6u8, 64u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Time details of a corporate ballot associated with a CA."]
      #[doc = " The timestamps denote when voting starts and stops."]
      #[doc = ""]
      #[doc = " (CAId) => BallotTimeRange"]
      pub fn time_ranges(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_corporate_actions::CAId,
        types::pallet_corporate_actions::ballot::BallotTimeRange,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 224u8, 44u8, 93u8, 167u8, 153u8, 243u8, 193u8, 143u8, 81u8, 133u8,
          254u8, 177u8, 13u8, 204u8, 115u8, 80u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Stores how many choices there are in each motion."]
      #[doc = ""]
      #[doc = " At all times, the invariant holds that `motion_choices[idx]` is equal to"]
      #[doc = " `metas.unwrap().motions[idx].choices.len()`. That is, this is just a cache,"]
      #[doc = " used to avoid fetching all the motions with their associated texts."]
      #[doc = ""]
      #[doc = " `u16` choices should be more than enough to fit real use cases."]
      #[doc = ""]
      #[doc = " (CAId) => Number of choices in each motion."]
      pub fn motion_num_choices(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_corporate_actions::CAId,
        ::alloc::vec::Vec<u16>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 128u8, 121u8, 46u8, 246u8, 146u8, 237u8, 189u8, 150u8, 253u8, 219u8,
          95u8, 102u8, 195u8, 212u8, 151u8, 27u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Is ranked choice voting (RCV) enabled for this ballot?"]
      #[doc = " For an understanding of how RCV is handled, see note on `BallotVote`'s `fallback` field."]
      #[doc = ""]
      #[doc = " (CAId) => bool"]
      pub fn rcv(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<types::pallet_corporate_actions::CAId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 255u8, 206u8, 156u8, 27u8, 141u8, 170u8, 167u8, 14u8, 136u8, 113u8,
          191u8, 30u8, 171u8, 45u8, 90u8, 96u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Stores the total vote tally on each choice."]
      #[doc = ""]
      #[doc = " RCV is not accounted for,"]
      #[doc = " as there are too many wants to interpret the graph,"]
      #[doc = " and because it would not be efficient."]
      #[doc = ""]
      #[doc = " (CAId) => [current vote weights]"]
      pub fn results(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_corporate_actions::CAId,
        ::alloc::vec::Vec<u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 2u8, 53u8, 15u8, 184u8, 68u8, 197u8, 167u8, 101u8, 105u8, 101u8,
          134u8, 40u8, 189u8, 68u8, 197u8, 62u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Stores each DID's votes in a given ballot."]
      #[doc = " See the documentation of `BallotVote` for notes on semantics."]
      #[doc = ""]
      #[doc = " (CAId) => (DID) => [vote weight]"]
      #[doc = ""]
      #[doc = " User must enter 0 vote weight if they don't want to vote for a choice."]
      pub fn votes(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::IdentityId,
        ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8, 230u8, 150u8,
          237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
    }
  }
  pub mod permissions {
    use super::*;
    #[derive(Clone)]
    pub struct PermissionsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PermissionsCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for PermissionsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PermissionsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PermissionsQueryApi<'api> {}
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct PermissionsPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> PermissionsPagedQueryApi<'api> {}
  }
  pub mod pips {
    use super::*;
    #[derive(Clone)]
    pub struct PipsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PipsCallApi<'api> {
      #[doc = "Change whether completed PIPs are pruned."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `prune` specifies whether completed PIPs should be pruned."]
      #[cfg(not(feature = "ink"))]
      pub fn set_prune_historical_pips(
        &self,
        prune: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_prune_historical_pips { prune },
        ))
      }
      #[doc = "Change whether completed PIPs are pruned."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `prune` specifies whether completed PIPs should be pruned."]
      #[cfg(feature = "ink")]
      pub fn set_prune_historical_pips(&self, prune: bool) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 0u8];
        prune.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the minimum proposal deposit amount required to start a proposal."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `deposit` the new min deposit required to start a proposal"]
      #[cfg(not(feature = "ink"))]
      pub fn set_min_proposal_deposit(
        &self,
        deposit: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_min_proposal_deposit { deposit },
        ))
      }
      #[doc = "Change the minimum proposal deposit amount required to start a proposal."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `deposit` the new min deposit required to start a proposal"]
      #[cfg(feature = "ink")]
      pub fn set_min_proposal_deposit(&self, deposit: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 1u8];
        deposit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the default enactment period."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `duration` the new default enactment period it takes for a scheduled PIP to be executed."]
      #[cfg(not(feature = "ink"))]
      pub fn set_default_enactment_period(
        &self,
        duration: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_default_enactment_period { duration },
        ))
      }
      #[doc = "Change the default enactment period."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `duration` the new default enactment period it takes for a scheduled PIP to be executed."]
      #[cfg(feature = "ink")]
      pub fn set_default_enactment_period(&self, duration: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 2u8];
        duration.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the amount of blocks after which a pending PIP is expired."]
      #[doc = "If `expiry` is `None` then PIPs never expire."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` the block-time it takes for a still-`Pending` PIP to expire."]
      #[cfg(not(feature = "ink"))]
      pub fn set_pending_pip_expiry(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_pending_pip_expiry { expiry },
        ))
      }
      #[doc = "Change the amount of blocks after which a pending PIP is expired."]
      #[doc = "If `expiry` is `None` then PIPs never expire."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` the block-time it takes for a still-`Pending` PIP to expire."]
      #[cfg(feature = "ink")]
      pub fn set_pending_pip_expiry(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 3u8];
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the maximum skip count (`max_pip_skip_count`)."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `max` skips before a PIP cannot be skipped by GC anymore."]
      #[cfg(not(feature = "ink"))]
      pub fn set_max_pip_skip_count(
        &self,
        max: u8,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_max_pip_skip_count { max },
        ))
      }
      #[doc = "Change the maximum skip count (`max_pip_skip_count`)."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `max` skips before a PIP cannot be skipped by GC anymore."]
      #[cfg(feature = "ink")]
      pub fn set_max_pip_skip_count(&self, max: u8) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 4u8];
        max.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the maximum number of active PIPs before community members cannot propose anything."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` of concurrent active PIPs."]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_pip_limit(
        &self,
        limit: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_active_pip_limit { limit },
        ))
      }
      #[doc = "Change the maximum number of active PIPs before community members cannot propose anything."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` of concurrent active PIPs."]
      #[cfg(feature = "ink")]
      pub fn set_active_pip_limit(&self, limit: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 5u8];
        limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "A network member creates a PIP by submitting a dispatchable which"]
      #[doc = "changes the network in someway. A minimum deposit is required to open a new proposal."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposer` is either a signing key or committee."]
      #[doc = "   Used to understand whether this is a committee proposal and verified against `origin`."]
      #[doc = "* `proposal` a dispatchable call"]
      #[doc = "* `deposit` minimum deposit value, which is ignored if `proposer` is a committee."]
      #[doc = "* `url` a link to a website for proposal discussion"]
      #[cfg(not(feature = "ink"))]
      pub fn propose(
        &self,
        proposal: runtime::RuntimeCall,
        deposit: u128,
        url: Option<types::polymesh_primitives::Url>,
        description: Option<types::pallet_pips::PipDescription>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::propose {
            proposal: ::alloc::boxed::Box::new(proposal),
            deposit,
            url,
            description,
          },
        ))
      }
      #[doc = "A network member creates a PIP by submitting a dispatchable which"]
      #[doc = "changes the network in someway. A minimum deposit is required to open a new proposal."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposer` is either a signing key or committee."]
      #[doc = "   Used to understand whether this is a committee proposal and verified against `origin`."]
      #[doc = "* `proposal` a dispatchable call"]
      #[doc = "* `deposit` minimum deposit value, which is ignored if `proposer` is a committee."]
      #[doc = "* `url` a link to a website for proposal discussion"]
      #[cfg(feature = "ink")]
      pub fn propose(
        &self,
        proposal: runtime::RuntimeCall,
        deposit: u128,
        url: Option<types::polymesh_primitives::Url>,
        description: Option<types::pallet_pips::PipDescription>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 6u8];
        proposal.encode_to(&mut buf);
        deposit.encode_to(&mut buf);
        url.encode_to(&mut buf);
        description.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Vote either in favor (`aye_or_nay` == true) or against a PIP with `id`."]
      #[doc = "The \"convinction\" or strength of the vote is given by `deposit`, which is reserved."]
      #[doc = ""]
      #[doc = "Note that `vote` is *not* additive."]
      #[doc = "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`"]
      #[doc = "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit."]
      #[doc = "To add atop of existing votes, you'll need `existing_deposit + addition`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`, proposal id"]
      #[doc = "* `aye_or_nay`, a bool representing for or against vote"]
      #[doc = "* `deposit`, the \"conviction\" with which the vote is made."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchProposal` if `id` doesn't reference a valid PIP."]
      #[doc = "* `NotFromCommunity` if proposal was made by a committee."]
      #[doc = "* `IncorrectProposalState` if PIP isn't pending."]
      #[doc = "* `InsufficientDeposit` if `origin` cannot reserve `deposit - old_deposit`."]
      #[cfg(not(feature = "ink"))]
      pub fn vote(
        &self,
        id: types::pallet_pips::PipId,
        aye_or_nay: bool,
        deposit: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::vote {
            id,
            aye_or_nay,
            deposit,
          },
        ))
      }
      #[doc = "Vote either in favor (`aye_or_nay` == true) or against a PIP with `id`."]
      #[doc = "The \"convinction\" or strength of the vote is given by `deposit`, which is reserved."]
      #[doc = ""]
      #[doc = "Note that `vote` is *not* additive."]
      #[doc = "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`"]
      #[doc = "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit."]
      #[doc = "To add atop of existing votes, you'll need `existing_deposit + addition`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`, proposal id"]
      #[doc = "* `aye_or_nay`, a bool representing for or against vote"]
      #[doc = "* `deposit`, the \"conviction\" with which the vote is made."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchProposal` if `id` doesn't reference a valid PIP."]
      #[doc = "* `NotFromCommunity` if proposal was made by a committee."]
      #[doc = "* `IncorrectProposalState` if PIP isn't pending."]
      #[doc = "* `InsufficientDeposit` if `origin` cannot reserve `deposit - old_deposit`."]
      #[cfg(feature = "ink")]
      pub fn vote(
        &self,
        id: types::pallet_pips::PipId,
        aye_or_nay: bool,
        deposit: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 7u8];
        id.encode_to(&mut buf);
        aye_or_nay.encode_to(&mut buf);
        deposit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Approves the pending committee PIP given by the `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal isn't pending."]
      #[doc = "* `NotByCommittee` if the proposal isn't by a committee."]
      #[cfg(not(feature = "ink"))]
      pub fn approve_committee_proposal(
        &self,
        id: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::approve_committee_proposal { id },
        ))
      }
      #[doc = "Approves the pending committee PIP given by the `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal isn't pending."]
      #[doc = "* `NotByCommittee` if the proposal isn't by a committee."]
      #[cfg(feature = "ink")]
      pub fn approve_committee_proposal(
        &self,
        id: types::pallet_pips::PipId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 8u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rejects the PIP given by the `id`, refunding any bonded funds,"]
      #[doc = "assuming it hasn't been cancelled or executed."]
      #[doc = "Note that proposals scheduled-for-execution can also be rejected."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal was cancelled or executed."]
      #[cfg(not(feature = "ink"))]
      pub fn reject_proposal(
        &self,
        id: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::reject_proposal { id },
        ))
      }
      #[doc = "Rejects the PIP given by the `id`, refunding any bonded funds,"]
      #[doc = "assuming it hasn't been cancelled or executed."]
      #[doc = "Note that proposals scheduled-for-execution can also be rejected."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal was cancelled or executed."]
      #[cfg(feature = "ink")]
      pub fn reject_proposal(&self, id: types::pallet_pips::PipId) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 9u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Prune the PIP given by the `id`, refunding any funds not already refunded."]
      #[doc = "The PIP may not be active"]
      #[doc = ""]
      #[doc = "This function is intended for storage garbage collection purposes."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal is active."]
      #[cfg(not(feature = "ink"))]
      pub fn prune_proposal(
        &self,
        id: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::prune_proposal { id },
        ))
      }
      #[doc = "Prune the PIP given by the `id`, refunding any funds not already refunded."]
      #[doc = "The PIP may not be active"]
      #[doc = ""]
      #[doc = "This function is intended for storage garbage collection purposes."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal is active."]
      #[cfg(feature = "ink")]
      pub fn prune_proposal(&self, id: types::pallet_pips::PipId) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 10u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the execution schedule of the PIP given by `id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `until` defines the future block where the enactment period will finished."]
      #[doc = "   `None` value means that enactment period is going to finish in the next block."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `RescheduleNotByReleaseCoordinator` unless triggered by release coordinator."]
      #[doc = "* `IncorrectProposalState` unless the proposal was in a scheduled state."]
      #[cfg(not(feature = "ink"))]
      pub fn reschedule_execution(
        &self,
        id: types::pallet_pips::PipId,
        until: Option<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::reschedule_execution { id, until },
        ))
      }
      #[doc = "Updates the execution schedule of the PIP given by `id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `until` defines the future block where the enactment period will finished."]
      #[doc = "   `None` value means that enactment period is going to finish in the next block."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `RescheduleNotByReleaseCoordinator` unless triggered by release coordinator."]
      #[doc = "* `IncorrectProposalState` unless the proposal was in a scheduled state."]
      #[cfg(feature = "ink")]
      pub fn reschedule_execution(
        &self,
        id: types::pallet_pips::PipId,
        until: Option<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 11u8];
        id.encode_to(&mut buf);
        until.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Clears the snapshot and emits the event `SnapshotCleared`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[cfg(not(feature = "ink"))]
      pub fn clear_snapshot(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::clear_snapshot,
        ))
      }
      #[doc = "Clears the snapshot and emits the event `SnapshotCleared`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[cfg(feature = "ink")]
      pub fn clear_snapshot(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![33u8, 12u8])
      }
      #[doc = "Takes a new snapshot of the current list of active && pending PIPs."]
      #[doc = "The PIPs are then sorted into a priority queue based on each PIP's weight."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[cfg(not(feature = "ink"))]
      pub fn snapshot(&self) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::snapshot,
        ))
      }
      #[doc = "Takes a new snapshot of the current list of active && pending PIPs."]
      #[doc = "The PIPs are then sorted into a priority queue based on each PIP's weight."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[cfg(feature = "ink")]
      pub fn snapshot(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![33u8, 13u8])
      }
      #[doc = "Enacts `results` for the PIPs in the snapshot queue."]
      #[doc = "The snapshot will be available for further enactments until it is cleared."]
      #[doc = ""]
      #[doc = "The `results` are encoded a list of `(id, result)` where `result` is applied to `id`."]
      #[doc = "Note that the snapshot priority queue is encoded with the *lowest priority first*."]
      #[doc = "so `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - unless a GC voting majority executes this function."]
      #[doc = "* `CannotSkipPip` - a given PIP has already been skipped too many times."]
      #[doc = "* `SnapshotResultTooLarge` - on len(results) > len(snapshot_queue)."]
      #[doc = "* `SnapshotIdMismatch` - if:"]
      #[doc = "  ```text"]
      #[doc = "   ∃ (i ∈ 0..SnapshotQueue.len())."]
      #[doc = "     results[i].0 ≠ SnapshotQueue[SnapshotQueue.len() - i].id"]
      #[doc = "  ```"]
      #[doc = "   This is protects against clearing queue while GC is voting."]
      #[cfg(not(feature = "ink"))]
      pub fn enact_snapshot_results(
        &self,
        results: ::alloc::vec::Vec<(
          types::pallet_pips::PipId,
          types::pallet_pips::SnapshotResult,
        )>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::enact_snapshot_results { results },
        ))
      }
      #[doc = "Enacts `results` for the PIPs in the snapshot queue."]
      #[doc = "The snapshot will be available for further enactments until it is cleared."]
      #[doc = ""]
      #[doc = "The `results` are encoded a list of `(id, result)` where `result` is applied to `id`."]
      #[doc = "Note that the snapshot priority queue is encoded with the *lowest priority first*."]
      #[doc = "so `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - unless a GC voting majority executes this function."]
      #[doc = "* `CannotSkipPip` - a given PIP has already been skipped too many times."]
      #[doc = "* `SnapshotResultTooLarge` - on len(results) > len(snapshot_queue)."]
      #[doc = "* `SnapshotIdMismatch` - if:"]
      #[doc = "  ```text"]
      #[doc = "   ∃ (i ∈ 0..SnapshotQueue.len())."]
      #[doc = "     results[i].0 ≠ SnapshotQueue[SnapshotQueue.len() - i].id"]
      #[doc = "  ```"]
      #[doc = "   This is protects against clearing queue while GC is voting."]
      #[cfg(feature = "ink")]
      pub fn enact_snapshot_results(
        &self,
        results: ::alloc::vec::Vec<(
          types::pallet_pips::PipId,
          types::pallet_pips::SnapshotResult,
        )>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 14u8];
        results.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Internal dispatchable that handles execution of a PIP."]
      #[cfg(not(feature = "ink"))]
      pub fn execute_scheduled_pip(
        &self,
        id: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::execute_scheduled_pip { id },
        ))
      }
      #[doc = "Internal dispatchable that handles execution of a PIP."]
      #[cfg(feature = "ink")]
      pub fn execute_scheduled_pip(
        &self,
        id: types::pallet_pips::PipId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 15u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Internal dispatchable that handles expiration of a PIP."]
      #[cfg(not(feature = "ink"))]
      pub fn expire_scheduled_pip(
        &self,
        did: ::polymesh_api_client::IdentityId,
        id: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::expire_scheduled_pip { did, id },
        ))
      }
      #[doc = "Internal dispatchable that handles expiration of a PIP."]
      #[cfg(feature = "ink")]
      pub fn expire_scheduled_pip(
        &self,
        did: ::polymesh_api_client::IdentityId,
        id: types::pallet_pips::PipId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 16u8];
        did.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for PipsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PipsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PipsQueryApi<'api> {
      #[doc = " Determines whether historical PIP data is persisted or removed"]
      #[cfg(not(feature = "ink"))]
      pub async fn prune_historical_pips(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 189u8, 16u8, 192u8, 60u8, 149u8, 36u8, 81u8, 199u8, 53u8, 30u8,
          52u8, 222u8, 47u8, 68u8, 166u8, 44u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Determines whether historical PIP data is persisted or removed"]
      #[cfg(feature = "ink")]
      pub fn prune_historical_pips(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 189u8, 16u8, 192u8, 60u8, 149u8, 36u8, 81u8, 199u8, 53u8, 30u8,
          52u8, 222u8, 47u8, 68u8, 166u8, 44u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum amount to be used as a deposit for community PIP creation."]
      #[cfg(not(feature = "ink"))]
      pub async fn minimum_proposal_deposit(&self) -> ::polymesh_api_client::error::Result<u128> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 142u8, 186u8, 24u8, 71u8, 175u8, 165u8, 243u8, 64u8, 139u8, 26u8,
          206u8, 10u8, 193u8, 132u8, 103u8, 2u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum amount to be used as a deposit for community PIP creation."]
      #[cfg(feature = "ink")]
      pub fn minimum_proposal_deposit(&self) -> ::polymesh_api_ink::error::Result<u128> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 142u8, 186u8, 24u8, 71u8, 175u8, 165u8, 243u8, 64u8, 139u8, 26u8,
          206u8, 10u8, 193u8, 132u8, 103u8, 2u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Default enactment period that will be use after a proposal is accepted by GC."]
      #[cfg(not(feature = "ink"))]
      pub async fn default_enactment_period(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 51u8, 170u8, 252u8, 74u8, 212u8, 72u8, 38u8, 0u8, 53u8, 50u8, 101u8,
          120u8, 239u8, 111u8, 130u8, 18u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Default enactment period that will be use after a proposal is accepted by GC."]
      #[cfg(feature = "ink")]
      pub fn default_enactment_period(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 51u8, 170u8, 252u8, 74u8, 212u8, 72u8, 38u8, 0u8, 53u8, 50u8, 101u8,
          120u8, 239u8, 111u8, 130u8, 18u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many blocks will it take, after a `Pending` PIP expires,"]
      #[doc = " assuming it has not transitioned to another `ProposalState`?"]
      #[cfg(not(feature = "ink"))]
      pub async fn pending_pip_expiry(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 58u8, 147u8, 255u8, 239u8, 101u8, 133u8, 6u8, 145u8, 79u8, 53u8,
          65u8, 205u8, 53u8, 56u8, 227u8, 209u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many blocks will it take, after a `Pending` PIP expires,"]
      #[doc = " assuming it has not transitioned to another `ProposalState`?"]
      #[cfg(feature = "ink")]
      pub fn pending_pip_expiry(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 58u8, 147u8, 255u8, 239u8, 101u8, 133u8, 6u8, 145u8, 79u8, 53u8,
          65u8, 205u8, 53u8, 56u8, 227u8, 209u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maximum times a PIP can be skipped before triggering `CannotSkipPip` in `enact_snapshot_results`."]
      #[cfg(not(feature = "ink"))]
      pub async fn max_pip_skip_count(&self) -> ::polymesh_api_client::error::Result<u8> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 220u8, 153u8, 145u8, 58u8, 218u8, 242u8, 187u8, 63u8, 0u8, 101u8,
          235u8, 95u8, 125u8, 163u8, 103u8, 164u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <u8>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maximum times a PIP can be skipped before triggering `CannotSkipPip` in `enact_snapshot_results`."]
      #[cfg(feature = "ink")]
      pub fn max_pip_skip_count(&self) -> ::polymesh_api_ink::error::Result<u8> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 220u8, 153u8, 145u8, 58u8, 218u8, 242u8, 187u8, 63u8, 0u8, 101u8,
          235u8, 95u8, 125u8, 163u8, 103u8, 164u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <u8>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum allowed number for `ActivePipCount`."]
      #[doc = " Once reached, new PIPs cannot be proposed by community members."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_pip_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 142u8, 176u8, 200u8, 221u8, 213u8, 71u8, 139u8, 145u8, 46u8, 82u8,
          219u8, 155u8, 155u8, 174u8, 243u8, 103u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum allowed number for `ActivePipCount`."]
      #[doc = " Once reached, new PIPs cannot be proposed by community members."]
      #[cfg(feature = "ink")]
      pub fn active_pip_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 142u8, 176u8, 200u8, 221u8, 213u8, 71u8, 139u8, 145u8, 46u8, 82u8,
          219u8, 155u8, 155u8, 174u8, 243u8, 103u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals so far. id can be used to keep track of PIPs off-chain."]
      #[cfg(not(feature = "ink"))]
      pub async fn pip_id_sequence(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_pips::PipId> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 89u8, 187u8, 247u8, 248u8, 106u8, 18u8, 26u8, 188u8, 148u8, 170u8,
          211u8, 21u8, 5u8, 34u8, 135u8, 100u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_pips::PipId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals so far. id can be used to keep track of PIPs off-chain."]
      #[cfg(feature = "ink")]
      pub fn pip_id_sequence(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::PipId> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 89u8, 187u8, 247u8, 248u8, 106u8, 18u8, 26u8, 188u8, 148u8, 170u8,
          211u8, 21u8, 5u8, 34u8, 135u8, 100u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_pips::PipId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Snapshots so far. id can be used to keep track of snapshots off-chain."]
      #[cfg(not(feature = "ink"))]
      pub async fn snapshot_id_sequence(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_pips::SnapshotId> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 6u8, 175u8, 149u8, 151u8, 152u8, 112u8, 164u8, 18u8, 129u8, 2u8,
          178u8, 5u8, 64u8, 255u8, 210u8, 228u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_pips::SnapshotId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Snapshots so far. id can be used to keep track of snapshots off-chain."]
      #[cfg(feature = "ink")]
      pub fn snapshot_id_sequence(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::SnapshotId> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 6u8, 175u8, 149u8, 151u8, 152u8, 112u8, 164u8, 18u8, 129u8, 2u8,
          178u8, 5u8, 64u8, 255u8, 210u8, 228u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_pips::SnapshotId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Total count of current pending or scheduled PIPs."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_pip_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 160u8, 15u8, 19u8, 210u8, 89u8, 80u8, 103u8, 48u8, 205u8, 26u8,
          95u8, 188u8, 201u8, 27u8, 117u8, 206u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Total count of current pending or scheduled PIPs."]
      #[cfg(feature = "ink")]
      pub fn active_pip_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 160u8, 15u8, 19u8, 210u8, 89u8, 80u8, 103u8, 48u8, 205u8, 26u8,
          95u8, 188u8, 201u8, 27u8, 117u8, 206u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The metadata of the active proposals."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_metadata(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_pips::PipsMetadata<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 84u8, 36u8, 238u8, 140u8, 56u8, 250u8, 92u8, 7u8, 255u8, 42u8,
          121u8, 197u8, 145u8, 184u8, 96u8, 30u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The metadata of the active proposals."]
      #[cfg(feature = "ink")]
      pub fn proposal_metadata(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_pips::PipsMetadata<u32>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 84u8, 36u8, 238u8, 140u8, 56u8, 250u8, 92u8, 7u8, 255u8, 42u8,
          121u8, 197u8, 145u8, 184u8, 96u8, 30u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Those who have locked a deposit."]
      #[doc = " proposal (id, proposer) -> deposit"]
      #[cfg(not(feature = "ink"))]
      pub async fn deposits(
        &self,
        key_0: types::pallet_pips::PipId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_pips::DepositInfo<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 116u8, 166u8, 20u8, 219u8, 128u8, 33u8, 198u8, 189u8, 10u8, 2u8,
          138u8, 175u8, 223u8, 41u8, 221u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Those who have locked a deposit."]
      #[doc = " proposal (id, proposer) -> deposit"]
      #[cfg(feature = "ink")]
      pub fn deposits(
        &self,
        key_0: types::pallet_pips::PipId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_pips::DepositInfo<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 116u8, 166u8, 20u8, 219u8, 128u8, 33u8, 198u8, 189u8, 10u8, 2u8,
          138u8, 175u8, 223u8, 41u8, 221u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Actual proposal for a given id, if it's current."]
      #[doc = " proposal id -> proposal"]
      #[cfg(not(feature = "ink"))]
      pub async fn proposals(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_pips::Pip<runtime::RuntimeCall, ::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Actual proposal for a given id, if it's current."]
      #[doc = " proposal id -> proposal"]
      #[cfg(feature = "ink")]
      pub fn proposals(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_pips::Pip<runtime::RuntimeCall, ::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[doc = " proposal id -> vote count"]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_result(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_pips::VotingResult> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 239u8, 64u8, 138u8, 67u8, 171u8, 101u8, 203u8, 26u8, 180u8, 173u8,
          95u8, 36u8, 142u8, 58u8, 33u8, 239u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::pallet_pips::VotingResult>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[doc = " proposal id -> vote count"]
      #[cfg(feature = "ink")]
      pub fn proposal_result(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::VotingResult> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 239u8, 64u8, 138u8, 67u8, 171u8, 101u8, 203u8, 26u8, 180u8, 173u8,
          95u8, 36u8, 142u8, 58u8, 33u8, 239u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::pallet_pips::VotingResult>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Votes per Proposal and account. Used to avoid double vote issue."]
      #[doc = " (proposal id, account) -> Vote"]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_votes(
        &self,
        key_0: types::pallet_pips::PipId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_pips::Vote>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 38u8, 65u8, 14u8, 13u8, 124u8, 179u8, 198u8, 250u8, 215u8, 127u8,
          63u8, 42u8, 53u8, 72u8, 177u8, 49u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Votes per Proposal and account. Used to avoid double vote issue."]
      #[doc = " (proposal id, account) -> Vote"]
      #[cfg(feature = "ink")]
      pub fn proposal_votes(
        &self,
        key_0: types::pallet_pips::PipId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_pips::Vote>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 38u8, 65u8, 14u8, 13u8, 124u8, 179u8, 198u8, 250u8, 215u8, 127u8,
          63u8, 42u8, 53u8, 72u8, 177u8, 49u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Maps PIPs to the block at which they will be executed, if any."]
      #[cfg(not(feature = "ink"))]
      pub async fn pip_to_schedule(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 235u8, 79u8, 164u8, 184u8, 26u8, 18u8, 180u8, 116u8, 221u8, 96u8,
          50u8, 249u8, 124u8, 39u8, 211u8, 186u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Maps PIPs to the block at which they will be executed, if any."]
      #[cfg(feature = "ink")]
      pub fn pip_to_schedule(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 235u8, 79u8, 164u8, 184u8, 26u8, 18u8, 180u8, 116u8, 221u8, 96u8,
          50u8, 249u8, 124u8, 39u8, 211u8, 186u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A live priority queue (lowest priority at index 0)"]
      #[doc = " of pending PIPs up to the active limit."]
      #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
      #[doc = ""]
      #[doc = " Unlike `SnapshotQueue`, this queue is live, getting updated with each vote cast."]
      #[doc = " The snapshot is therefore essentially a point-in-time clone of this queue."]
      #[cfg(not(feature = "ink"))]
      pub async fn live_queue(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 199u8, 191u8, 241u8, 183u8, 34u8, 25u8, 14u8, 165u8, 58u8, 69u8,
          114u8, 15u8, 85u8, 83u8, 223u8, 90u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " A live priority queue (lowest priority at index 0)"]
      #[doc = " of pending PIPs up to the active limit."]
      #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
      #[doc = ""]
      #[doc = " Unlike `SnapshotQueue`, this queue is live, getting updated with each vote cast."]
      #[doc = " The snapshot is therefore essentially a point-in-time clone of this queue."]
      #[cfg(feature = "ink")]
      pub fn live_queue(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>
      {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 199u8, 191u8, 241u8, 183u8, 34u8, 25u8, 14u8, 165u8, 58u8, 69u8,
          114u8, 15u8, 85u8, 83u8, 223u8, 90u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The priority queue (lowest priority at index 0) of PIPs at the point of snapshotting."]
      #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
      #[doc = ""]
      #[doc = " A queued PIP can be skipped. Doing so bumps the `pip_skip_count`."]
      #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
      #[cfg(not(feature = "ink"))]
      pub async fn snapshot_queue(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 71u8, 8u8, 47u8, 250u8, 214u8, 91u8, 162u8, 233u8, 118u8, 69u8,
          120u8, 55u8, 47u8, 38u8, 190u8, 247u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The priority queue (lowest priority at index 0) of PIPs at the point of snapshotting."]
      #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
      #[doc = ""]
      #[doc = " A queued PIP can be skipped. Doing so bumps the `pip_skip_count`."]
      #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
      #[cfg(feature = "ink")]
      pub fn snapshot_queue(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>
      {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 71u8, 8u8, 47u8, 250u8, 214u8, 91u8, 162u8, 233u8, 118u8, 69u8,
          120u8, 55u8, 47u8, 38u8, 190u8, 247u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The metadata of the snapshot, if there is one."]
      #[cfg(not(feature = "ink"))]
      pub async fn snapshot_meta(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_pips::SnapshotMetadata<u32, ::polymesh_api_client::AccountId>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 90u8, 74u8, 35u8, 0u8, 255u8, 31u8, 130u8, 141u8, 244u8, 34u8,
          103u8, 253u8, 93u8, 30u8, 199u8, 83u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The metadata of the snapshot, if there is one."]
      #[cfg(feature = "ink")]
      pub fn snapshot_meta(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_pips::SnapshotMetadata<u32, ::polymesh_api_client::AccountId>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 90u8, 74u8, 35u8, 0u8, 255u8, 31u8, 130u8, 141u8, 244u8, 34u8,
          103u8, 253u8, 93u8, 30u8, 199u8, 83u8,
        ])?;
        Ok(value)
      }
      #[doc = " The number of times a certain PIP has been skipped."]
      #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
      #[cfg(not(feature = "ink"))]
      pub async fn pip_skip_count(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<u8> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 225u8, 98u8, 238u8, 82u8, 4u8, 74u8, 74u8, 120u8, 78u8, 232u8,
          200u8, 123u8, 191u8, 156u8, 108u8, 85u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <u8>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The number of times a certain PIP has been skipped."]
      #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
      #[cfg(feature = "ink")]
      pub fn pip_skip_count(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<u8> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 225u8, 98u8, 238u8, 82u8, 4u8, 74u8, 74u8, 120u8, 78u8, 232u8,
          200u8, 123u8, 191u8, 156u8, 108u8, 85u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <u8>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All existing PIPs where the proposer is a committee."]
      #[doc = " This list is a cache of all ids in `Proposals` with `Proposer::Committee(_)`."]
      #[cfg(not(feature = "ink"))]
      pub async fn committee_pips(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::pallet_pips::PipId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 189u8, 121u8, 13u8, 219u8, 47u8, 171u8, 170u8, 240u8, 102u8, 140u8,
          146u8, 163u8, 22u8, 76u8, 210u8, 186u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::PipId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All existing PIPs where the proposer is a committee."]
      #[doc = " This list is a cache of all ids in `Proposals` with `Proposer::Committee(_)`."]
      #[cfg(feature = "ink")]
      pub fn committee_pips(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::pallet_pips::PipId>> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 189u8, 121u8, 13u8, 219u8, 47u8, 171u8, 170u8, 240u8, 102u8, 140u8,
          146u8, 163u8, 22u8, 76u8, 210u8, 186u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::PipId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposal state for a given id."]
      #[doc = " proposal id -> proposalState"]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_states(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_pips::ProposalState>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8, 102u8, 151u8, 171u8, 71u8,
          106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Proposal state for a given id."]
      #[doc = " proposal id -> proposalState"]
      #[cfg(feature = "ink")]
      pub fn proposal_states(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_pips::ProposalState>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8, 102u8, 151u8, 171u8, 71u8,
          106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_pips::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_pips::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::Version> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_pips::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct PipsPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> PipsPagedQueryApi<'api> {
      #[doc = " The metadata of the active proposals."]
      pub fn proposal_metadata(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_pips::PipId,
        types::pallet_pips::PipsMetadata<u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 84u8, 36u8, 238u8, 140u8, 56u8, 250u8, 92u8, 7u8, 255u8, 42u8,
          121u8, 197u8, 145u8, 184u8, 96u8, 30u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Those who have locked a deposit."]
      #[doc = " proposal (id, proposer) -> deposit"]
      pub fn deposits(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_pips::DepositInfo<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 116u8, 166u8, 20u8, 219u8, 128u8, 33u8, 198u8, 189u8, 10u8, 2u8,
          138u8, 175u8, 223u8, 41u8, 221u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Actual proposal for a given id, if it's current."]
      #[doc = " proposal id -> proposal"]
      pub fn proposals(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_pips::PipId,
        types::pallet_pips::Pip<runtime::RuntimeCall, ::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[doc = " proposal id -> vote count"]
      pub fn proposal_result(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_pips::PipId,
        types::pallet_pips::VotingResult,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 239u8, 64u8, 138u8, 67u8, 171u8, 101u8, 203u8, 26u8, 180u8, 173u8,
          95u8, 36u8, 142u8, 58u8, 33u8, 239u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Votes per Proposal and account. Used to avoid double vote issue."]
      #[doc = " (proposal id, account) -> Vote"]
      pub fn proposal_votes(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_pips::Vote,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 38u8, 65u8, 14u8, 13u8, 124u8, 179u8, 198u8, 250u8, 215u8, 127u8,
          63u8, 42u8, 53u8, 72u8, 177u8, 49u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Maps PIPs to the block at which they will be executed, if any."]
      pub fn pip_to_schedule(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<types::pallet_pips::PipId, u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 235u8, 79u8, 164u8, 184u8, 26u8, 18u8, 180u8, 116u8, 221u8, 96u8,
          50u8, 249u8, 124u8, 39u8, 211u8, 186u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The number of times a certain PIP has been skipped."]
      #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
      pub fn pip_skip_count(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<types::pallet_pips::PipId, u8> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 225u8, 98u8, 238u8, 82u8, 4u8, 74u8, 74u8, 120u8, 78u8, 232u8,
          200u8, 123u8, 191u8, 156u8, 108u8, 85u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Proposal state for a given id."]
      #[doc = " proposal id -> proposalState"]
      pub fn proposal_states(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_pips::PipId,
        types::pallet_pips::ProposalState,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8, 102u8, 151u8, 171u8, 71u8,
          106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod portfolio {
    use super::*;
    #[derive(Clone)]
    pub struct PortfolioCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PortfolioCallApi<'api> {
      #[doc = "Creates a portfolio with the given `name`."]
      #[cfg(not(feature = "ink"))]
      pub fn create_portfolio(
        &self,
        name: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::create_portfolio { name },
        ))
      }
      #[doc = "Creates a portfolio with the given `name`."]
      #[cfg(feature = "ink")]
      pub fn create_portfolio(
        &self,
        name: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 0u8];
        name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Deletes a user portfolio. A portfolio can be deleted only if it has no funds."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = "* `PortfolioNotEmpty` if the portfolio still holds any asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn delete_portfolio(
        &self,
        num: types::polymesh_primitives::identity_id::PortfolioNumber,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::delete_portfolio { num },
        ))
      }
      #[doc = "Deletes a user portfolio. A portfolio can be deleted only if it has no funds."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = "* `PortfolioNotEmpty` if the portfolio still holds any asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn delete_portfolio(
        &self,
        num: types::polymesh_primitives::identity_id::PortfolioNumber,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 1u8];
        num.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Renames a non-default portfolio."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn rename_portfolio(
        &self,
        num: types::polymesh_primitives::identity_id::PortfolioNumber,
        to_name: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::rename_portfolio { num, to_name },
        ))
      }
      #[doc = "Renames a non-default portfolio."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn rename_portfolio(
        &self,
        num: types::polymesh_primitives::identity_id::PortfolioNumber,
        to_name: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 2u8];
        num.encode_to(&mut buf);
        to_name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "When called by the custodian of `portfolio_id`,"]
      #[doc = "allows returning the custody of the portfolio to the portfolio owner unilaterally."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn quit_portfolio_custody(
        &self,
        pid: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::quit_portfolio_custody { pid },
        ))
      }
      #[doc = "When called by the custodian of `portfolio_id`,"]
      #[doc = "allows returning the custody of the portfolio to the portfolio owner unilaterally."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn quit_portfolio_custody(
        &self,
        pid: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 3u8];
        pid.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[cfg(not(feature = "ink"))]
      pub fn accept_portfolio_custody(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::accept_portfolio_custody { auth_id },
        ))
      }
      #[cfg(feature = "ink")]
      pub fn accept_portfolio_custody(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 4u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same"]
      #[doc = "identity. Must be called by the custodian of the sender."]
      #[doc = "Funds from deleted portfolios can also be recovered via this method."]
      #[doc = ""]
      #[doc = "A short memo can be added to to each token amount moved."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio."]
      #[doc = "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same"]
      #[doc = "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio"]
      #[doc = "* `InsufficientPortfolioBalance` if the sender does not have enough free balance"]
      #[doc = "* `NoDuplicateAssetsAllowed` the same asset can't be repeated in the items vector."]
      #[doc = "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own."]
      #[doc = "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn move_portfolio_funds(
        &self,
        from: types::polymesh_primitives::identity_id::PortfolioId,
        to: types::polymesh_primitives::identity_id::PortfolioId,
        funds: ::alloc::vec::Vec<types::polymesh_primitives::portfolio::Fund>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::move_portfolio_funds { from, to, funds },
        ))
      }
      #[doc = "Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same"]
      #[doc = "identity. Must be called by the custodian of the sender."]
      #[doc = "Funds from deleted portfolios can also be recovered via this method."]
      #[doc = ""]
      #[doc = "A short memo can be added to to each token amount moved."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio."]
      #[doc = "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same"]
      #[doc = "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio"]
      #[doc = "* `InsufficientPortfolioBalance` if the sender does not have enough free balance"]
      #[doc = "* `NoDuplicateAssetsAllowed` the same asset can't be repeated in the items vector."]
      #[doc = "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own."]
      #[doc = "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn move_portfolio_funds(
        &self,
        from: types::polymesh_primitives::identity_id::PortfolioId,
        to: types::polymesh_primitives::identity_id::PortfolioId,
        funds: ::alloc::vec::Vec<types::polymesh_primitives::portfolio::Fund>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 5u8];
        from.encode_to(&mut buf);
        to.encode_to(&mut buf);
        funds.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Pre-approves the receivement of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn pre_approve_portfolio(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::pre_approve_portfolio {
            asset_id,
            portfolio_id,
          },
        ))
      }
      #[doc = "Pre-approves the receivement of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn pre_approve_portfolio(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 6u8];
        asset_id.encode_to(&mut buf);
        portfolio_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the pre approval of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_portfolio_pre_approval(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::remove_portfolio_pre_approval {
            asset_id,
            portfolio_id,
          },
        ))
      }
      #[doc = "Removes the pre approval of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn remove_portfolio_pre_approval(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 7u8];
        asset_id.encode_to(&mut buf);
        portfolio_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds an identity that will be allowed to create and take custody of a portfolio under the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `trusted_identity` - the [`IdentityId`] that will be allowed to call `create_custody_portfolio`."]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub fn allow_identity_to_create_portfolios(
        &self,
        trusted_identity: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::allow_identity_to_create_portfolios {
            trusted_identity,
          },
        ))
      }
      #[doc = "Adds an identity that will be allowed to create and take custody of a portfolio under the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `trusted_identity` - the [`IdentityId`] that will be allowed to call `create_custody_portfolio`."]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn allow_identity_to_create_portfolios(
        &self,
        trusted_identity: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 8u8];
        trusted_identity.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes permission of an identity to create and take custody of a portfolio under the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `identity` - the [`IdentityId`] that will have the permissions to call `create_custody_portfolio` revoked."]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub fn revoke_create_portfolios_permission(
        &self,
        identity: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::revoke_create_portfolios_permission { identity },
        ))
      }
      #[doc = "Removes permission of an identity to create and take custody of a portfolio under the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `identity` - the [`IdentityId`] that will have the permissions to call `create_custody_portfolio` revoked."]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn revoke_create_portfolios_permission(
        &self,
        identity: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 9u8];
        identity.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Creates a portfolio under the `portfolio_owner_id` identity and transfers its custody to the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `portfolio_owner_id` - the [`IdentityId`] that will own the new portfolio."]
      #[doc = "* `portfolio_name` - the [`PortfolioName`] of the new portfolio."]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub fn create_custody_portfolio(
        &self,
        portfolio_owner_id: ::polymesh_api_client::IdentityId,
        portfolio_name: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::create_custody_portfolio {
            portfolio_owner_id,
            portfolio_name,
          },
        ))
      }
      #[doc = "Creates a portfolio under the `portfolio_owner_id` identity and transfers its custody to the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `portfolio_owner_id` - the [`IdentityId`] that will own the new portfolio."]
      #[doc = "* `portfolio_name` - the [`PortfolioName`] of the new portfolio."]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn create_custody_portfolio(
        &self,
        portfolio_owner_id: ::polymesh_api_client::IdentityId,
        portfolio_name: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 10u8];
        portfolio_owner_id.encode_to(&mut buf);
        portfolio_name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for PortfolioCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PortfolioQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PortfolioQueryApi<'api> {
      #[doc = " The next portfolio sequence number of an identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_portfolio_number(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::identity_id::PortfolioNumber,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 172u8, 83u8, 250u8, 216u8, 150u8, 217u8, 192u8, 44u8, 226u8, 108u8, 214u8,
          101u8, 230u8, 169u8, 16u8, 146u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::identity_id::PortfolioNumber>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The next portfolio sequence number of an identity."]
      #[cfg(feature = "ink")]
      pub fn next_portfolio_number(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::identity_id::PortfolioNumber>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 172u8, 83u8, 250u8, 216u8, 150u8, 217u8, 192u8, 44u8, 226u8, 108u8, 214u8,
          101u8, 230u8, 169u8, 16u8, 146u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::identity_id::PortfolioNumber>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The set of existing portfolios with their names. If a certain pair of a DID and"]
      #[doc = " portfolio number maps to `None` then such a portfolio doesn't exist. Conversely, if a"]
      #[doc = " pair maps to `Some(name)` then such a portfolio exists and is called `name`."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolios(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioNumber,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity_id::PortfolioName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 216u8, 45u8, 233u8, 131u8, 28u8, 44u8, 102u8, 233u8, 160u8, 8u8, 50u8,
          33u8, 79u8, 22u8, 134u8, 96u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The set of existing portfolios with their names. If a certain pair of a DID and"]
      #[doc = " portfolio number maps to `None` then such a portfolio doesn't exist. Conversely, if a"]
      #[doc = " pair maps to `Some(name)` then such a portfolio exists and is called `name`."]
      #[cfg(feature = "ink")]
      pub fn portfolios(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioNumber,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity_id::PortfolioName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 216u8, 45u8, 233u8, 131u8, 28u8, 44u8, 102u8, 233u8, 160u8, 8u8, 50u8,
          33u8, 79u8, 22u8, 134u8, 96u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Inverse map of `Portfolios` used to ensure bijectivitiy,"]
      #[doc = " and uniqueness of names in `Portfolios`."]
      #[cfg(not(feature = "ink"))]
      pub async fn name_to_number(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 201u8, 73u8, 93u8, 142u8, 176u8, 225u8, 64u8, 248u8, 75u8, 153u8, 21u8,
          11u8, 147u8, 73u8, 1u8, 128u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Inverse map of `Portfolios` used to ensure bijectivitiy,"]
      #[doc = " and uniqueness of names in `Portfolios`."]
      #[cfg(feature = "ink")]
      pub fn name_to_number(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 201u8, 73u8, 93u8, 142u8, 176u8, 225u8, 64u8, 248u8, 75u8, 153u8, 21u8,
          11u8, 147u8, 73u8, 1u8, 128u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " How many assets with non-zero balance this portfolio contains."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_asset_count(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 134u8, 1u8, 141u8, 242u8, 36u8, 217u8, 225u8, 140u8, 57u8, 102u8, 61u8,
          167u8, 241u8, 14u8, 193u8, 102u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many assets with non-zero balance this portfolio contains."]
      #[cfg(feature = "ink")]
      pub fn portfolio_asset_count(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 134u8, 1u8, 141u8, 242u8, 36u8, 217u8, 225u8, 140u8, 57u8, 102u8, 61u8,
          167u8, 241u8, 14u8, 193u8, 102u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The asset balances of portfolios."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_asset_balances(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 187u8, 126u8, 217u8, 17u8, 104u8, 223u8, 249u8, 141u8, 179u8, 194u8, 128u8,
          143u8, 216u8, 237u8, 226u8, 9u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The asset balances of portfolios."]
      #[cfg(feature = "ink")]
      pub fn portfolio_asset_balances(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 187u8, 126u8, 217u8, 17u8, 104u8, 223u8, 249u8, 141u8, 179u8, 194u8, 128u8,
          143u8, 216u8, 237u8, 226u8, 9u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Amount of assets locked in a portfolio."]
      #[doc = " These assets show up in portfolio balance but can not be transferred away."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_locked_assets(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 116u8, 19u8, 199u8, 203u8, 198u8, 5u8, 145u8, 166u8, 100u8, 250u8, 216u8,
          43u8, 219u8, 255u8, 196u8, 204u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Amount of assets locked in a portfolio."]
      #[doc = " These assets show up in portfolio balance but can not be transferred away."]
      #[cfg(feature = "ink")]
      pub fn portfolio_locked_assets(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 116u8, 19u8, 199u8, 203u8, 198u8, 5u8, 145u8, 166u8, 100u8, 250u8, 216u8,
          43u8, 219u8, 255u8, 196u8, 204u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The custodian of a particular portfolio. None implies that the identity owner is the custodian."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_custodian(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 10u8, 6u8, 59u8, 83u8, 137u8, 54u8, 238u8, 218u8, 141u8, 253u8, 27u8,
          117u8, 25u8, 62u8, 192u8, 180u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The custodian of a particular portfolio. None implies that the identity owner is the custodian."]
      #[cfg(feature = "ink")]
      pub fn portfolio_custodian(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 10u8, 6u8, 59u8, 83u8, 137u8, 54u8, 238u8, 218u8, 141u8, 253u8, 27u8,
          117u8, 25u8, 62u8, 192u8, 180u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Tracks all the portfolios in custody of a particular identity. Only used by the UIs."]
      #[doc = " When `true` is stored as the value for a given `(did, pid)`, it means that `pid` is in custody of `did`."]
      #[doc = " `false` values are never explicitly stored in the map, and are instead inferred by the absence of a key."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolios_in_custody(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 151u8, 1u8, 246u8, 111u8, 5u8, 25u8, 23u8, 126u8, 54u8, 90u8, 86u8, 176u8,
          77u8, 30u8, 44u8, 29u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks all the portfolios in custody of a particular identity. Only used by the UIs."]
      #[doc = " When `true` is stored as the value for a given `(did, pid)`, it means that `pid` is in custody of `did`."]
      #[doc = " `false` values are never explicitly stored in the map, and are instead inferred by the absence of a key."]
      #[cfg(feature = "ink")]
      pub fn portfolios_in_custody(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 151u8, 1u8, 246u8, 111u8, 5u8, 25u8, 23u8, 126u8, 54u8, 90u8, 86u8, 176u8,
          77u8, 30u8, 44u8, 29u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The nft associated to the portfolio."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_nft(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::nft::NFTId,
        ),
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 173u8, 97u8, 37u8, 11u8, 3u8, 3u8, 23u8, 150u8, 237u8, 156u8, 213u8, 12u8,
          232u8, 116u8, 250u8, 5u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The nft associated to the portfolio."]
      #[cfg(feature = "ink")]
      pub fn portfolio_nft(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::nft::NFTId,
        ),
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 173u8, 97u8, 37u8, 11u8, 3u8, 3u8, 23u8, 150u8, 237u8, 156u8, 213u8, 12u8,
          232u8, 116u8, 250u8, 5u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All locked nft for a given portfolio."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_locked_nft(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::nft::NFTId,
        ),
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 184u8, 241u8, 132u8, 127u8, 220u8, 26u8, 219u8, 97u8, 120u8, 220u8, 63u8,
          134u8, 171u8, 252u8, 234u8, 18u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All locked nft for a given portfolio."]
      #[cfg(feature = "ink")]
      pub fn portfolio_locked_nft(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::nft::NFTId,
        ),
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 184u8, 241u8, 132u8, 127u8, 220u8, 26u8, 219u8, 97u8, 120u8, 220u8, 63u8,
          134u8, 171u8, 252u8, 234u8, 18u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All portfolios that don't need to affirm the receivement of a given [`AssetId`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn pre_approved_portfolios(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 237u8, 212u8, 229u8, 184u8, 97u8, 233u8, 51u8, 24u8, 206u8, 114u8, 208u8,
          215u8, 112u8, 111u8, 171u8, 170u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All portfolios that don't need to affirm the receivement of a given [`AssetId`]."]
      #[cfg(feature = "ink")]
      pub fn pre_approved_portfolios(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 237u8, 212u8, 229u8, 184u8, 97u8, 233u8, 51u8, 24u8, 206u8, 114u8, 208u8,
          215u8, 112u8, 111u8, 171u8, 170u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Custodians allowed to create and take custody of portfolios on an id's behalf."]
      #[cfg(not(feature = "ink"))]
      pub async fn allowed_custodians(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 8u8, 235u8, 240u8, 0u8, 20u8, 57u8, 146u8, 221u8, 92u8, 156u8, 54u8, 141u8,
          201u8, 221u8, 88u8, 89u8,
        ]);
        buf.extend(key_0.encode());
        buf.extend(key_1.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Custodians allowed to create and take custody of portfolios on an id's behalf."]
      #[cfg(feature = "ink")]
      pub fn allowed_custodians(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 8u8, 235u8, 240u8, 0u8, 20u8, 57u8, 146u8, 221u8, 92u8, 156u8, 54u8, 141u8,
          201u8, 221u8, 88u8, 89u8,
        ]);
        buf.extend(key_0.encode());
        buf.extend(key_1.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_portfolio::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8, 169u8,
          77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_portfolio::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_portfolio::Version> {
        let value = self.api.read_storage(::alloc::vec![
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8, 169u8,
          77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_portfolio::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct PortfolioPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> PortfolioPagedQueryApi<'api> {
      #[doc = " The next portfolio sequence number of an identity."]
      pub fn next_portfolio_number(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::IdentityId,
        types::polymesh_primitives::identity_id::PortfolioNumber,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 172u8, 83u8, 250u8, 216u8, 150u8, 217u8, 192u8, 44u8, 226u8, 108u8, 214u8,
          101u8, 230u8, 169u8, 16u8, 146u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " The set of existing portfolios with their names. If a certain pair of a DID and"]
      #[doc = " portfolio number maps to `None` then such a portfolio doesn't exist. Conversely, if a"]
      #[doc = " pair maps to `Some(name)` then such a portfolio exists and is called `name`."]
      pub fn portfolios(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::identity_id::PortfolioNumber,
        types::polymesh_primitives::identity_id::PortfolioName,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 216u8, 45u8, 233u8, 131u8, 28u8, 44u8, 102u8, 233u8, 160u8, 8u8, 50u8,
          33u8, 79u8, 22u8, 134u8, 96u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Inverse map of `Portfolios` used to ensure bijectivitiy,"]
      #[doc = " and uniqueness of names in `Portfolios`."]
      pub fn name_to_number(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::identity_id::PortfolioName,
        types::polymesh_primitives::identity_id::PortfolioNumber,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 201u8, 73u8, 93u8, 142u8, 176u8, 225u8, 64u8, 248u8, 75u8, 153u8, 21u8,
          11u8, 147u8, 73u8, 1u8, 128u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " How many assets with non-zero balance this portfolio contains."]
      pub fn portfolio_asset_count(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::identity_id::PortfolioId,
        u64,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 134u8, 1u8, 141u8, 242u8, 36u8, 217u8, 225u8, 140u8, 57u8, 102u8, 61u8,
          167u8, 241u8, 14u8, 193u8, 102u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The asset balances of portfolios."]
      pub fn portfolio_asset_balances(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 187u8, 126u8, 217u8, 17u8, 104u8, 223u8, 249u8, 141u8, 179u8, 194u8, 128u8,
          143u8, 216u8, 237u8, 226u8, 9u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Amount of assets locked in a portfolio."]
      #[doc = " These assets show up in portfolio balance but can not be transferred away."]
      pub fn portfolio_locked_assets(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 116u8, 19u8, 199u8, 203u8, 198u8, 5u8, 145u8, 166u8, 100u8, 250u8, 216u8,
          43u8, 219u8, 255u8, 196u8, 204u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The custodian of a particular portfolio. None implies that the identity owner is the custodian."]
      pub fn portfolio_custodian(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::identity_id::PortfolioId,
        ::polymesh_api_client::IdentityId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 10u8, 6u8, 59u8, 83u8, 137u8, 54u8, 238u8, 218u8, 141u8, 253u8, 27u8,
          117u8, 25u8, 62u8, 192u8, 180u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Tracks all the portfolios in custody of a particular identity. Only used by the UIs."]
      #[doc = " When `true` is stored as the value for a given `(did, pid)`, it means that `pid` is in custody of `did`."]
      #[doc = " `false` values are never explicitly stored in the map, and are instead inferred by the absence of a key."]
      pub fn portfolios_in_custody(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::identity_id::PortfolioId,
        bool,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 151u8, 1u8, 246u8, 111u8, 5u8, 25u8, 23u8, 126u8, 54u8, 90u8, 86u8, 176u8,
          77u8, 30u8, 44u8, 29u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The nft associated to the portfolio."]
      pub fn portfolio_nft(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::StoragePaged<
        (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::nft::NFTId,
        ),
        bool,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 173u8, 97u8, 37u8, 11u8, 3u8, 3u8, 23u8, 150u8, 237u8, 156u8, 213u8, 12u8,
          232u8, 116u8, 250u8, 5u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " All locked nft for a given portfolio."]
      pub fn portfolio_locked_nft(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::StoragePaged<
        (
          ::polymesh_api_client::AssetId,
          types::polymesh_primitives::nft::NFTId,
        ),
        bool,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 184u8, 241u8, 132u8, 127u8, 220u8, 26u8, 219u8, 97u8, 120u8, 220u8, 63u8,
          134u8, 171u8, 252u8, 234u8, 18u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " All portfolios that don't need to affirm the receivement of a given [`AssetId`]."]
      pub fn pre_approved_portfolios(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 237u8, 212u8, 229u8, 184u8, 97u8, 233u8, 51u8, 24u8, 206u8, 114u8, 208u8,
          215u8, 112u8, 111u8, 171u8, 170u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Custodians allowed to create and take custody of portfolios on an id's behalf."]
      pub fn allowed_custodians(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 8u8, 235u8, 240u8, 0u8, 20u8, 57u8, 146u8, 221u8, 92u8, 156u8, 54u8, 141u8,
          201u8, 221u8, 88u8, 89u8,
        ]);
        buf.extend(key_0.encode());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
    }
  }
  pub mod protocol_fee {
    use super::*;
    #[derive(Clone)]
    pub struct ProtocolFeeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ProtocolFeeCallApi<'api> {
      #[doc = "Changes the fee coefficient for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[cfg(not(feature = "ink"))]
      pub fn change_coefficient(
        &self,
        coefficient: types::polymesh_primitives::PosRatio,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ProtocolFee(
          types::pallet_protocol_fee::ProtocolFeeCall::change_coefficient { coefficient },
        ))
      }
      #[doc = "Changes the fee coefficient for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[cfg(feature = "ink")]
      pub fn change_coefficient(
        &self,
        coefficient: types::polymesh_primitives::PosRatio,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![35u8, 0u8];
        coefficient.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the a base fee for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[cfg(not(feature = "ink"))]
      pub fn change_base_fee(
        &self,
        op: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
        base_fee: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ProtocolFee(
          types::pallet_protocol_fee::ProtocolFeeCall::change_base_fee { op, base_fee },
        ))
      }
      #[doc = "Changes the a base fee for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[cfg(feature = "ink")]
      pub fn change_base_fee(
        &self,
        op: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
        base_fee: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![35u8, 1u8];
        op.encode_to(&mut buf);
        base_fee.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ProtocolFeeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ProtocolFeeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ProtocolFeeQueryApi<'api> {
      #[doc = " The mapping of operation names to the base fees of those operations."]
      #[cfg(not(feature = "ink"))]
      pub async fn base_fees(
        &self,
        key_0: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8, 3u8, 169u8,
          228u8, 161u8, 54u8, 217u8, 243u8, 154u8, 193u8, 14u8, 44u8, 253u8, 114u8, 99u8, 70u8,
          43u8, 154u8, 102u8, 138u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The mapping of operation names to the base fees of those operations."]
      #[cfg(feature = "ink")]
      pub fn base_fees(
        &self,
        key_0: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8, 3u8, 169u8,
          228u8, 161u8, 54u8, 217u8, 243u8, 154u8, 193u8, 14u8, 44u8, 253u8, 114u8, 99u8, 70u8,
          43u8, 154u8, 102u8, 138u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The fee coefficient as a positive rational (numerator, denominator)."]
      #[cfg(not(feature = "ink"))]
      pub async fn coefficient(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::PosRatio> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8, 3u8, 169u8,
          228u8, 161u8, 155u8, 182u8, 208u8, 38u8, 251u8, 72u8, 4u8, 189u8, 110u8, 17u8, 231u8,
          0u8, 23u8, 52u8, 26u8, 97u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::PosRatio>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The fee coefficient as a positive rational (numerator, denominator)."]
      #[cfg(feature = "ink")]
      pub fn coefficient(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::PosRatio> {
        let value = self.api.read_storage(::alloc::vec![
          184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8, 3u8, 169u8,
          228u8, 161u8, 155u8, 182u8, 208u8, 38u8, 251u8, 72u8, 4u8, 189u8, 110u8, 17u8, 231u8,
          0u8, 23u8, 52u8, 26u8, 97u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::PosRatio>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct ProtocolFeePagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> ProtocolFeePagedQueryApi<'api> {
      #[doc = " The mapping of operation names to the base fees of those operations."]
      pub fn base_fees(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_common_utilities::protocol_fee::ProtocolOp,
        u128,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8, 3u8, 169u8,
          228u8, 161u8, 54u8, 217u8, 243u8, 154u8, 193u8, 14u8, 44u8, 253u8, 114u8, 99u8, 70u8,
          43u8, 154u8, 102u8, 138u8, 8u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod scheduler {
    use super::*;
    #[derive(Clone)]
    pub struct SchedulerCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> SchedulerCallApi<'api> {
      #[doc = "Anonymously schedule a task."]
      #[cfg(not(feature = "ink"))]
      pub fn schedule(
        &self,
        when: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::schedule {
            when,
            maybe_periodic,
            priority,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Anonymously schedule a task."]
      #[cfg(feature = "ink")]
      pub fn schedule(
        &self,
        when: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 0u8];
        when.encode_to(&mut buf);
        maybe_periodic.encode_to(&mut buf);
        priority.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Cancel an anonymously scheduled task."]
      #[cfg(not(feature = "ink"))]
      pub fn cancel(
        &self,
        when: u32,
        index: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::cancel { when, index },
        ))
      }
      #[doc = "Cancel an anonymously scheduled task."]
      #[cfg(feature = "ink")]
      pub fn cancel(&self, when: u32, index: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 1u8];
        when.encode_to(&mut buf);
        index.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Schedule a named task."]
      #[cfg(not(feature = "ink"))]
      pub fn schedule_named(
        &self,
        id: [u8; 32usize],
        when: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::schedule_named {
            id,
            when,
            maybe_periodic,
            priority,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Schedule a named task."]
      #[cfg(feature = "ink")]
      pub fn schedule_named(
        &self,
        id: [u8; 32usize],
        when: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 2u8];
        id.encode_to(&mut buf);
        when.encode_to(&mut buf);
        maybe_periodic.encode_to(&mut buf);
        priority.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Cancel a named scheduled task."]
      #[cfg(not(feature = "ink"))]
      pub fn cancel_named(
        &self,
        id: [u8; 32usize],
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::cancel_named { id },
        ))
      }
      #[doc = "Cancel a named scheduled task."]
      #[cfg(feature = "ink")]
      pub fn cancel_named(&self, id: [u8; 32usize]) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 3u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Anonymously schedule a task after a delay."]
      #[cfg(not(feature = "ink"))]
      pub fn schedule_after(
        &self,
        after: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::schedule_after {
            after,
            maybe_periodic,
            priority,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Anonymously schedule a task after a delay."]
      #[cfg(feature = "ink")]
      pub fn schedule_after(
        &self,
        after: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 4u8];
        after.encode_to(&mut buf);
        maybe_periodic.encode_to(&mut buf);
        priority.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Schedule a named task after a delay."]
      #[cfg(not(feature = "ink"))]
      pub fn schedule_named_after(
        &self,
        id: [u8; 32usize],
        after: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::schedule_named_after {
            id,
            after,
            maybe_periodic,
            priority,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Schedule a named task after a delay."]
      #[cfg(feature = "ink")]
      pub fn schedule_named_after(
        &self,
        id: [u8; 32usize],
        after: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 5u8];
        id.encode_to(&mut buf);
        after.encode_to(&mut buf);
        maybe_periodic.encode_to(&mut buf);
        priority.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for SchedulerCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct SchedulerQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> SchedulerQueryApi<'api> {
      #[cfg(not(feature = "ink"))]
      pub async fn incomplete_since(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 247u8, 190u8, 155u8, 11u8, 241u8, 111u8, 132u8, 229u8, 89u8, 165u8,
          129u8, 1u8, 200u8, 145u8, 213u8, 35u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[cfg(feature = "ink")]
      pub fn incomplete_since(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 247u8, 190u8, 155u8, 11u8, 241u8, 111u8, 132u8, 229u8, 89u8, 165u8,
          129u8, 1u8, 200u8, 145u8, 213u8, 35u8,
        ])?;
        Ok(value)
      }
      #[doc = " Items to be executed, indexed by the block number that they should be executed on."]
      #[cfg(not(feature = "ink"))]
      pub async fn agenda(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<
          Option<
            types::pallet_scheduler::Scheduled<
              [u8; 32usize],
              types::frame_support::traits::preimages::Bounded<runtime::RuntimeCall>,
              u32,
              runtime::OriginCaller,
              ::polymesh_api_client::AccountId,
            >,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 22u8, 67u8, 245u8, 65u8, 151u8, 24u8, 33u8, 156u8, 149u8, 103u8,
          157u8, 221u8, 45u8, 130u8, 85u8, 116u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
            Option<
              types::pallet_scheduler::Scheduled<
                [u8; 32usize],
                types::frame_support::traits::preimages::Bounded<runtime::RuntimeCall>,
                u32,
                runtime::OriginCaller,
                ::polymesh_api_client::AccountId,
              >,
            >,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Items to be executed, indexed by the block number that they should be executed on."]
      #[cfg(feature = "ink")]
      pub fn agenda(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<
          Option<
            types::pallet_scheduler::Scheduled<
              [u8; 32usize],
              types::frame_support::traits::preimages::Bounded<runtime::RuntimeCall>,
              u32,
              runtime::OriginCaller,
              ::polymesh_api_client::AccountId,
            >,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 22u8, 67u8, 245u8, 65u8, 151u8, 24u8, 33u8, 156u8, 149u8, 103u8,
          157u8, 221u8, 45u8, 130u8, 85u8, 116u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
            Option<
              types::pallet_scheduler::Scheduled<
                [u8; 32usize],
                types::frame_support::traits::preimages::Bounded<runtime::RuntimeCall>,
                u32,
                runtime::OriginCaller,
                ::polymesh_api_client::AccountId,
              >,
            >,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Lookup from a name to the block number and index of the task."]
      #[doc = ""]
      #[doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"]
      #[doc = " identities."]
      #[cfg(not(feature = "ink"))]
      pub async fn lookup(
        &self,
        key_0: [u8; 32usize],
      ) -> ::polymesh_api_client::error::Result<Option<(u32, u32)>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 137u8, 26u8, 212u8, 87u8, 191u8, 77u8, 165u8, 73u8, 144u8, 250u8,
          132u8, 162u8, 172u8, 177u8, 72u8, 162u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Lookup from a name to the block number and index of the task."]
      #[doc = ""]
      #[doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"]
      #[doc = " identities."]
      #[cfg(feature = "ink")]
      pub fn lookup(
        &self,
        key_0: [u8; 32usize],
      ) -> ::polymesh_api_ink::error::Result<Option<(u32, u32)>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 137u8, 26u8, 212u8, 87u8, 191u8, 77u8, 165u8, 73u8, 144u8, 250u8,
          132u8, 162u8, 172u8, 177u8, 72u8, 162u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct SchedulerPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> SchedulerPagedQueryApi<'api> {
      #[doc = " Items to be executed, indexed by the block number that they should be executed on."]
      pub fn agenda(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        u32,
        ::alloc::vec::Vec<
          Option<
            types::pallet_scheduler::Scheduled<
              [u8; 32usize],
              types::frame_support::traits::preimages::Bounded<runtime::RuntimeCall>,
              u32,
              runtime::OriginCaller,
              ::polymesh_api_client::AccountId,
            >,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 22u8, 67u8, 245u8, 65u8, 151u8, 24u8, 33u8, 156u8, 149u8, 103u8,
          157u8, 221u8, 45u8, 130u8, 85u8, 116u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Lookup from a name to the block number and index of the task."]
      #[doc = ""]
      #[doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"]
      #[doc = " identities."]
      pub fn lookup(&self) -> ::polymesh_api_client::StoragePaged<[u8; 32usize], (u32, u32)> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 137u8, 26u8, 212u8, 87u8, 191u8, 77u8, 165u8, 73u8, 144u8, 250u8,
          132u8, 162u8, 172u8, 177u8, 72u8, 162u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod settlement {
    use super::*;
    #[derive(Clone)]
    pub struct SettlementCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> SettlementCallApi<'api> {
      #[doc = "Registers a new venue."]
      #[doc = ""]
      #[doc = "* `details` - Extra details about a venue"]
      #[doc = "* `signers` - Array of signers that are allowed to sign receipts for this venue"]
      #[doc = "* `typ` - Type of venue being created"]
      #[cfg(not(feature = "ink"))]
      pub fn create_venue(
        &self,
        details: types::polymesh_primitives::settlement::VenueDetails,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        typ: types::polymesh_primitives::settlement::VenueType,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::create_venue {
            details,
            signers,
            typ,
          },
        ))
      }
      #[doc = "Registers a new venue."]
      #[doc = ""]
      #[doc = "* `details` - Extra details about a venue"]
      #[doc = "* `signers` - Array of signers that are allowed to sign receipts for this venue"]
      #[doc = "* `typ` - Type of venue being created"]
      #[cfg(feature = "ink")]
      pub fn create_venue(
        &self,
        details: types::polymesh_primitives::settlement::VenueDetails,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        typ: types::polymesh_primitives::settlement::VenueType,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 0u8];
        details.encode_to(&mut buf);
        signers.encode_to(&mut buf);
        typ.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Edit a venue's details."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `details` specifies the updated venue details."]
      #[cfg(not(feature = "ink"))]
      pub fn update_venue_details(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        details: types::polymesh_primitives::settlement::VenueDetails,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::update_venue_details { id, details },
        ))
      }
      #[doc = "Edit a venue's details."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `details` specifies the updated venue details."]
      #[cfg(feature = "ink")]
      pub fn update_venue_details(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        details: types::polymesh_primitives::settlement::VenueDetails,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 1u8];
        id.encode_to(&mut buf);
        details.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Edit a venue's type."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `type` specifies the new type of the venue."]
      #[cfg(not(feature = "ink"))]
      pub fn update_venue_type(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        typ: types::polymesh_primitives::settlement::VenueType,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::update_venue_type { id, typ },
        ))
      }
      #[doc = "Edit a venue's type."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `type` specifies the new type of the venue."]
      #[cfg(feature = "ink")]
      pub fn update_venue_type(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        typ: types::polymesh_primitives::settlement::VenueType,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 2u8];
        id.encode_to(&mut buf);
        typ.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Affirms an instruction using receipts for offchain transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn affirm_with_receipts(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        receipt_details: ::alloc::vec::Vec<
          types::polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            types::sp_runtime::MultiSignature,
          >,
        >,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::affirm_with_receipts {
            id,
            receipt_details,
            portfolios,
          },
        ))
      }
      #[doc = "Affirms an instruction using receipts for offchain transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn affirm_with_receipts(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        receipt_details: ::alloc::vec::Vec<
          types::polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            types::sp_runtime::MultiSignature,
          >,
        >,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 3u8];
        id.encode_to(&mut buf);
        receipt_details.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Enables or disabled venue filtering for a token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `asset_id` - AssetId of the token in question."]
      #[doc = "* `enabled` - Boolean that decides if the filtering should be enabled."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_venue_filtering(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        enabled: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::set_venue_filtering { asset_id, enabled },
        ))
      }
      #[doc = "Enables or disabled venue filtering for a token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `asset_id` - AssetId of the token in question."]
      #[doc = "* `enabled` - Boolean that decides if the filtering should be enabled."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_venue_filtering(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        enabled: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 4u8];
        asset_id.encode_to(&mut buf);
        enabled.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allows additional venues to create instructions involving an asset."]
      #[doc = ""]
      #[doc = "* `asset_id` - AssetId of the token in question."]
      #[doc = "* `venues` - Array of venues that are allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn allow_venues(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::allow_venues { asset_id, venues },
        ))
      }
      #[doc = "Allows additional venues to create instructions involving an asset."]
      #[doc = ""]
      #[doc = "* `asset_id` - AssetId of the token in question."]
      #[doc = "* `venues` - Array of venues that are allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn allow_venues(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 5u8];
        asset_id.encode_to(&mut buf);
        venues.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Revokes permission given to venues for creating instructions involving a particular asset."]
      #[doc = ""]
      #[doc = "* `asset_id` - AssetId of the token in question."]
      #[doc = "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn disallow_venues(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::disallow_venues { asset_id, venues },
        ))
      }
      #[doc = "Revokes permission given to venues for creating instructions involving a particular asset."]
      #[doc = ""]
      #[doc = "* `asset_id` - AssetId of the token in question."]
      #[doc = "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn disallow_venues(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 6u8];
        asset_id.encode_to(&mut buf);
        venues.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Edit a venue's signers."]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `signers` specifies the signers to add/remove."]
      #[doc = "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false."]
      #[cfg(not(feature = "ink"))]
      pub fn update_venue_signers(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        add_signers: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::update_venue_signers {
            id,
            signers,
            add_signers,
          },
        ))
      }
      #[doc = "Edit a venue's signers."]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `signers` specifies the signers to add/remove."]
      #[doc = "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false."]
      #[cfg(feature = "ink")]
      pub fn update_venue_signers(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        add_signers: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 7u8];
        id.encode_to(&mut buf);
        signers.encode_to(&mut buf);
        add_signers.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Manually executes an instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`: The [`InstructionId`] of the instruction to be executed."]
      #[doc = "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction."]
      #[doc = "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]."]
      #[doc = "* `fungible_transfers`: The number of fungible legs in the instruction."]
      #[doc = "* `nfts_transfers`: The number of nfts being transferred in the instruction."]
      #[doc = "* `offchain_transfers`: The number of offchain legs in the instruction."]
      #[doc = "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction."]
      #[doc = "If the `weight_limit` is less than the required amount, the instruction will fail execution."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters."]
      #[cfg(not(feature = "ink"))]
      pub fn execute_manual_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioId>,
        fungible_transfers: u32,
        nfts_transfers: u32,
        offchain_transfers: u32,
        weight_limit: Option<::polymesh_api_client::sp_weights::Weight>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::execute_manual_instruction {
            id,
            portfolio,
            fungible_transfers,
            nfts_transfers,
            offchain_transfers,
            weight_limit,
          },
        ))
      }
      #[doc = "Manually executes an instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`: The [`InstructionId`] of the instruction to be executed."]
      #[doc = "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction."]
      #[doc = "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]."]
      #[doc = "* `fungible_transfers`: The number of fungible legs in the instruction."]
      #[doc = "* `nfts_transfers`: The number of nfts being transferred in the instruction."]
      #[doc = "* `offchain_transfers`: The number of offchain legs in the instruction."]
      #[doc = "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction."]
      #[doc = "If the `weight_limit` is less than the required amount, the instruction will fail execution."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters."]
      #[cfg(feature = "ink")]
      pub fn execute_manual_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioId>,
        fungible_transfers: u32,
        nfts_transfers: u32,
        offchain_transfers: u32,
        weight_limit: Option<::polymesh_api_client::sp_weights::Weight>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 8u8];
        id.encode_to(&mut buf);
        portfolio.encode_to(&mut buf);
        fungible_transfers.encode_to(&mut buf);
        nfts_transfers.encode_to(&mut buf);
        offchain_transfers.encode_to(&mut buf);
        weight_limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The optional [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
      #[cfg(not(feature = "ink"))]
      pub fn add_instruction(
        &self,
        venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::add_instruction {
            venue_id,
            settlement_type,
            trade_date,
            value_date,
            legs,
            instruction_memo,
          },
        ))
      }
      #[doc = "Adds a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The optional [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
      #[cfg(feature = "ink")]
      pub fn add_instruction(
        &self,
        venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 9u8];
        venue_id.encode_to(&mut buf);
        settlement_type.encode_to(&mut buf);
        trade_date.encode_to(&mut buf);
        value_date.encode_to(&mut buf);
        legs.encode_to(&mut buf);
        instruction_memo.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds and affirms a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn add_and_affirm_instruction(
        &self,
        venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::add_and_affirm_instruction {
            venue_id,
            settlement_type,
            trade_date,
            value_date,
            legs,
            portfolios,
            instruction_memo,
          },
        ))
      }
      #[doc = "Adds and affirms a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn add_and_affirm_instruction(
        &self,
        venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 10u8];
        venue_id.encode_to(&mut buf);
        settlement_type.encode_to(&mut buf);
        trade_date.encode_to(&mut buf);
        value_date.encode_to(&mut buf);
        legs.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        instruction_memo.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Provide affirmation to an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn affirm_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::affirm_instruction { id, portfolios },
        ))
      }
      #[doc = "Provide affirmation to an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn affirm_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 11u8];
        id.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Withdraw an affirmation for a given instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn withdraw_affirmation(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::withdraw_affirmation { id, portfolios },
        ))
      }
      #[doc = "Withdraw an affirmation for a given instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn withdraw_affirmation(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 12u8];
        id.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rejects an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
      #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn reject_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolio: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::reject_instruction { id, portfolio },
        ))
      }
      #[doc = "Rejects an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
      #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn reject_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolio: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 13u8];
        id.encode_to(&mut buf);
        portfolio.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction."]
      #[cfg(not(feature = "ink"))]
      pub fn execute_scheduled_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        weight_limit: ::polymesh_api_client::sp_weights::Weight,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::execute_scheduled_instruction {
            id,
            weight_limit,
          },
        ))
      }
      #[doc = "Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction."]
      #[cfg(feature = "ink")]
      pub fn execute_scheduled_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        weight_limit: ::polymesh_api_client::sp_weights::Weight,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 14u8];
        id.encode_to(&mut buf);
        weight_limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Affirms an instruction using receipts for offchain transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn affirm_with_receipts_with_count(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        receipt_details: ::alloc::vec::Vec<
          types::polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            types::sp_runtime::MultiSignature,
          >,
        >,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
        number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::affirm_with_receipts_with_count {
            id,
            receipt_details,
            portfolios,
            number_of_assets,
          },
        ))
      }
      #[doc = "Affirms an instruction using receipts for offchain transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn affirm_with_receipts_with_count(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        receipt_details: ::alloc::vec::Vec<
          types::polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            types::sp_runtime::MultiSignature,
          >,
        >,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
        number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 15u8];
        id.encode_to(&mut buf);
        receipt_details.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        number_of_assets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Provide affirmation to an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn affirm_instruction_with_count(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
        number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::affirm_instruction_with_count {
            id,
            portfolios,
            number_of_assets,
          },
        ))
      }
      #[doc = "Provide affirmation to an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn affirm_instruction_with_count(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
        number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 16u8];
        id.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        number_of_assets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rejects an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
      #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
      #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn reject_instruction_with_count(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        number_of_assets: Option<types::polymesh_primitives::settlement::AssetCount>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::reject_instruction_with_count {
            id,
            portfolio,
            number_of_assets,
          },
        ))
      }
      #[doc = "Rejects an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
      #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
      #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn reject_instruction_with_count(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        number_of_assets: Option<types::polymesh_primitives::settlement::AssetCount>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 17u8];
        id.encode_to(&mut buf);
        portfolio.encode_to(&mut buf);
        number_of_assets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Withdraw an affirmation for a given instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
      #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn withdraw_affirmation_with_count(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
        number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::withdraw_affirmation_with_count {
            id,
            portfolios,
            number_of_assets,
          },
        ))
      }
      #[doc = "Withdraw an affirmation for a given instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
      #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
      #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn withdraw_affirmation_with_count(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
        number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 18u8];
        id.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        number_of_assets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a new instruction with mediators."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
      #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
      #[cfg(not(feature = "ink"))]
      pub fn add_instruction_with_mediators(
        &self,
        venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::add_instruction_with_mediators {
            venue_id,
            settlement_type,
            trade_date,
            value_date,
            legs,
            instruction_memo,
            mediators,
          },
        ))
      }
      #[doc = "Adds a new instruction with mediators."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
      #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
      #[cfg(feature = "ink")]
      pub fn add_instruction_with_mediators(
        &self,
        venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 19u8];
        venue_id.encode_to(&mut buf);
        settlement_type.encode_to(&mut buf);
        trade_date.encode_to(&mut buf);
        value_date.encode_to(&mut buf);
        legs.encode_to(&mut buf);
        instruction_memo.encode_to(&mut buf);
        mediators.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds and affirms a new instruction with mediators."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
      #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn add_and_affirm_with_mediators(
        &self,
        venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::add_and_affirm_with_mediators {
            venue_id,
            settlement_type,
            trade_date,
            value_date,
            legs,
            portfolios,
            instruction_memo,
            mediators,
          },
        ))
      }
      #[doc = "Adds and affirms a new instruction with mediators."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
      #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
      #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
      #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
      #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
      #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
      #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn add_and_affirm_with_mediators(
        &self,
        venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        portfolios: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::identity_id::PortfolioId,
        >,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
        mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 20u8];
        venue_id.encode_to(&mut buf);
        settlement_type.encode_to(&mut buf);
        trade_date.encode_to(&mut buf);
        value_date.encode_to(&mut buf);
        legs.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        instruction_memo.encode_to(&mut buf);
        mediators.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Affirms the instruction as a mediator - should only be called by mediators, otherwise it will fail."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: The secondary key of the sender."]
      #[doc = "* `instruction_id`: The [`InstructionId`] that will be affirmed by the mediator."]
      #[doc = "* `expiry`: An Optional value for defining when the affirmation will expire (None means it will always be valid)."]
      #[cfg(not(feature = "ink"))]
      pub fn affirm_instruction_as_mediator(
        &self,
        instruction_id: types::polymesh_primitives::settlement::InstructionId,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::affirm_instruction_as_mediator {
            instruction_id,
            expiry,
          },
        ))
      }
      #[doc = "Affirms the instruction as a mediator - should only be called by mediators, otherwise it will fail."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: The secondary key of the sender."]
      #[doc = "* `instruction_id`: The [`InstructionId`] that will be affirmed by the mediator."]
      #[doc = "* `expiry`: An Optional value for defining when the affirmation will expire (None means it will always be valid)."]
      #[cfg(feature = "ink")]
      pub fn affirm_instruction_as_mediator(
        &self,
        instruction_id: types::polymesh_primitives::settlement::InstructionId,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 21u8];
        instruction_id.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the mediator's affirmation for the instruction - should only be called by mediators, otherwise it will fail."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: The secondary key of the sender."]
      #[doc = "* `instruction_id`: The [`InstructionId`] that will have the affirmation removed."]
      #[cfg(not(feature = "ink"))]
      pub fn withdraw_affirmation_as_mediator(
        &self,
        instruction_id: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::withdraw_affirmation_as_mediator {
            instruction_id,
          },
        ))
      }
      #[doc = "Removes the mediator's affirmation for the instruction - should only be called by mediators, otherwise it will fail."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin`: The secondary key of the sender."]
      #[doc = "* `instruction_id`: The [`InstructionId`] that will have the affirmation removed."]
      #[cfg(feature = "ink")]
      pub fn withdraw_affirmation_as_mediator(
        &self,
        instruction_id: types::polymesh_primitives::settlement::InstructionId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 22u8];
        instruction_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rejects an existing instruction - should only be called by mediators, otherwise it will fail."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `instruction_id` - the [`InstructionId`] of the instruction being rejected."]
      #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
      #[cfg(not(feature = "ink"))]
      pub fn reject_instruction_as_mediator(
        &self,
        instruction_id: types::polymesh_primitives::settlement::InstructionId,
        number_of_assets: Option<types::polymesh_primitives::settlement::AssetCount>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::reject_instruction_as_mediator {
            instruction_id,
            number_of_assets,
          },
        ))
      }
      #[doc = "Rejects an existing instruction - should only be called by mediators, otherwise it will fail."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `instruction_id` - the [`InstructionId`] of the instruction being rejected."]
      #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
      #[cfg(feature = "ink")]
      pub fn reject_instruction_as_mediator(
        &self,
        instruction_id: types::polymesh_primitives::settlement::InstructionId,
        number_of_assets: Option<types::polymesh_primitives::settlement::AssetCount>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 23u8];
        instruction_id.encode_to(&mut buf);
        number_of_assets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for SettlementCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct SettlementQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> SettlementQueryApi<'api> {
      #[doc = " Info about a venue. venue_id -> venue"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_info(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::settlement::Venue>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 37u8, 149u8, 35u8, 221u8, 234u8, 221u8, 43u8, 130u8, 235u8, 131u8,
          158u8, 182u8, 118u8, 158u8, 16u8, 163u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Info about a venue. venue_id -> venue"]
      #[cfg(feature = "ink")]
      pub fn venue_info(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::settlement::Venue>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 37u8, 149u8, 35u8, 221u8, 234u8, 221u8, 43u8, 130u8, 235u8, 131u8,
          158u8, 182u8, 118u8, 158u8, 16u8, 163u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Free-form text about a venue. venue_id -> `VenueDetails`"]
      #[doc = " Only needed for the UI."]
      #[cfg(not(feature = "ink"))]
      pub async fn details(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::settlement::VenueDetails>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8, 198u8, 220u8,
          28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::VenueDetails>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Free-form text about a venue. venue_id -> `VenueDetails`"]
      #[doc = " Only needed for the UI."]
      #[cfg(feature = "ink")]
      pub fn details(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::settlement::VenueDetails>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8, 198u8, 220u8,
          28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::VenueDetails>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Instructions under a venue."]
      #[doc = " Only needed for the UI."]
      #[doc = ""]
      #[doc = " venue_id -> instruction_id -> ()"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_instructions(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
        key_1: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 194u8, 12u8, 53u8, 241u8, 21u8, 245u8, 35u8, 172u8, 170u8, 85u8, 47u8,
          113u8, 49u8, 126u8, 98u8, 7u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Instructions under a venue."]
      #[doc = " Only needed for the UI."]
      #[doc = ""]
      #[doc = " venue_id -> instruction_id -> ()"]
      #[cfg(feature = "ink")]
      pub fn venue_instructions(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
        key_1: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 194u8, 12u8, 53u8, 241u8, 21u8, 245u8, 35u8, 172u8, 170u8, 85u8, 47u8,
          113u8, 49u8, 126u8, 98u8, 7u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Signers allowed by the venue. (venue_id, signer) -> bool"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_signers(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 182u8, 5u8, 81u8, 237u8, 11u8, 31u8, 45u8, 224u8, 46u8, 226u8, 44u8,
          156u8, 78u8, 11u8, 160u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Signers allowed by the venue. (venue_id, signer) -> bool"]
      #[cfg(feature = "ink")]
      pub fn venue_signers(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 182u8, 5u8, 81u8, 237u8, 11u8, 31u8, 45u8, 224u8, 46u8, 226u8, 44u8,
          156u8, 78u8, 11u8, 160u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Venues create by an identity."]
      #[doc = " Only needed for the UI."]
      #[doc = ""]
      #[doc = " identity -> venue_id -> ()"]
      #[cfg(not(feature = "ink"))]
      pub async fn user_venues(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 210u8, 109u8, 136u8, 8u8, 7u8, 235u8, 230u8, 119u8, 137u8, 87u8,
          141u8, 192u8, 40u8, 218u8, 115u8, 74u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Venues create by an identity."]
      #[doc = " Only needed for the UI."]
      #[doc = ""]
      #[doc = " identity -> venue_id -> ()"]
      #[cfg(feature = "ink")]
      pub fn user_venues(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_ink::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 210u8, 109u8, 136u8, 8u8, 7u8, 235u8, 230u8, 119u8, 137u8, 87u8,
          141u8, 192u8, 40u8, 218u8, 115u8, 74u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Details about an instruction. instruction_id -> instruction_details"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_details(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::Instruction<u64, u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 139u8, 174u8, 75u8, 191u8, 82u8, 90u8, 68u8, 48u8, 145u8, 19u8, 222u8,
          238u8, 96u8, 255u8, 129u8, 178u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::settlement::Instruction<u64, u32>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Details about an instruction. instruction_id -> instruction_details"]
      #[cfg(feature = "ink")]
      pub fn instruction_details(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::Instruction<u64, u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 139u8, 174u8, 75u8, 191u8, 82u8, 90u8, 68u8, 48u8, 145u8, 19u8, 222u8,
          238u8, 96u8, 255u8, 129u8, 178u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::settlement::Instruction<u64, u32>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Status of a leg under an instruction. (instruction_id, leg_id) -> LegStatus"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_leg_status(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::LegStatus<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 241u8, 210u8, 62u8, 209u8, 210u8, 216u8, 97u8, 163u8, 74u8, 117u8,
          189u8, 72u8, 12u8, 109u8, 191u8, 35u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::LegStatus<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Status of a leg under an instruction. (instruction_id, leg_id) -> LegStatus"]
      #[cfg(feature = "ink")]
      pub fn instruction_leg_status(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::LegStatus<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 241u8, 210u8, 62u8, 209u8, 210u8, 216u8, 97u8, 163u8, 74u8, 117u8,
          189u8, 72u8, 12u8, 109u8, 191u8, 35u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::LegStatus<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Number of affirmations pending before instruction is executed. instruction_id -> affirm_pending"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_affirms_pending(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 84u8, 168u8, 38u8, 237u8, 42u8, 215u8, 233u8, 246u8, 173u8, 70u8, 3u8,
          122u8, 135u8, 90u8, 149u8, 95u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of affirmations pending before instruction is executed. instruction_id -> affirm_pending"]
      #[cfg(feature = "ink")]
      pub fn instruction_affirms_pending(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 84u8, 168u8, 38u8, 237u8, 42u8, 215u8, 233u8, 246u8, 173u8, 70u8, 3u8,
          122u8, 135u8, 90u8, 149u8, 95u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks affirmations received for an instruction. (instruction_id, counter_party) -> AffirmationStatus"]
      #[cfg(not(feature = "ink"))]
      pub async fn affirms_received(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 196u8, 164u8, 249u8, 77u8, 192u8, 14u8, 231u8, 77u8, 10u8, 20u8, 57u8,
          61u8, 241u8, 216u8, 34u8, 202u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Tracks affirmations received for an instruction. (instruction_id, counter_party) -> AffirmationStatus"]
      #[cfg(feature = "ink")]
      pub fn affirms_received(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 196u8, 164u8, 249u8, 77u8, 192u8, 14u8, 231u8, 77u8, 10u8, 20u8, 57u8,
          61u8, 241u8, 216u8, 34u8, 202u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Helps a user track their pending instructions and affirmations (only needed for UI)."]
      #[doc = " (counter_party, instruction_id) -> AffirmationStatus"]
      #[cfg(not(feature = "ink"))]
      pub async fn user_affirmations(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 34u8, 4u8, 158u8, 52u8, 236u8, 109u8, 105u8, 33u8, 29u8, 40u8, 146u8,
          57u8, 70u8, 48u8, 102u8, 159u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Helps a user track their pending instructions and affirmations (only needed for UI)."]
      #[doc = " (counter_party, instruction_id) -> AffirmationStatus"]
      #[cfg(feature = "ink")]
      pub fn user_affirmations(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 34u8, 4u8, 158u8, 52u8, 236u8, 109u8, 105u8, 33u8, 29u8, 40u8, 146u8,
          57u8, 70u8, 48u8, 102u8, 159u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Tracks redemption of receipts. (signer, receipt_uid) -> receipt_used"]
      #[cfg(not(feature = "ink"))]
      pub async fn receipts_used(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 127u8, 126u8, 234u8, 226u8, 61u8, 64u8, 167u8, 253u8, 218u8, 94u8,
          162u8, 111u8, 120u8, 56u8, 116u8, 157u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks redemption of receipts. (signer, receipt_uid) -> receipt_used"]
      #[cfg(feature = "ink")]
      pub fn receipts_used(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 127u8, 126u8, 234u8, 226u8, 61u8, 64u8, 167u8, 253u8, 218u8, 94u8,
          162u8, 111u8, 120u8, 56u8, 116u8, 157u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks if a token has enabled filtering venues that can create instructions involving their token. AssetId -> filtering_enabled"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_filtering(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 242u8, 42u8, 22u8, 99u8, 179u8, 59u8, 93u8, 97u8, 223u8, 90u8, 186u8,
          160u8, 76u8, 19u8, 198u8, 73u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks if a token has enabled filtering venues that can create instructions involving their token. AssetId -> filtering_enabled"]
      #[cfg(feature = "ink")]
      pub fn venue_filtering(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 242u8, 42u8, 22u8, 99u8, 179u8, 59u8, 93u8, 97u8, 223u8, 90u8, 186u8,
          160u8, 76u8, 19u8, 198u8, 73u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Venues that are allowed to create instructions involving a particular asset. Only used if filtering is enabled."]
      #[doc = " ([`AssetId`], venue_id) -> allowed"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_allow_list(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 113u8, 120u8, 81u8, 211u8, 168u8, 229u8, 128u8, 215u8, 96u8, 177u8,
          241u8, 151u8, 120u8, 224u8, 185u8, 22u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Venues that are allowed to create instructions involving a particular asset. Only used if filtering is enabled."]
      #[doc = " ([`AssetId`], venue_id) -> allowed"]
      #[cfg(feature = "ink")]
      pub fn venue_allow_list(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 113u8, 120u8, 81u8, 211u8, 168u8, 229u8, 128u8, 215u8, 96u8, 177u8,
          241u8, 151u8, 120u8, 224u8, 185u8, 22u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of venues in the system (It's one more than the actual number)"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_counter(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::settlement::VenueId>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 117u8, 30u8, 157u8, 0u8, 240u8, 121u8, 103u8, 207u8, 127u8, 87u8,
          212u8, 100u8, 178u8, 100u8, 6u8, 108u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::settlement::VenueId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of venues in the system (It's one more than the actual number)"]
      #[cfg(feature = "ink")]
      pub fn venue_counter(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::settlement::VenueId>
      {
        let value = self.api.read_storage(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 117u8, 30u8, 157u8, 0u8, 240u8, 121u8, 103u8, 207u8, 127u8, 87u8,
          212u8, 100u8, 178u8, 100u8, 6u8, 108u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::settlement::VenueId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of instructions in the system (It's one more than the actual number)"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_counter(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::settlement::InstructionId>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 186u8, 56u8, 151u8, 67u8, 78u8, 201u8, 90u8, 108u8, 36u8, 245u8,
          147u8, 242u8, 23u8, 13u8, 233u8, 58u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::settlement::InstructionId>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Number of instructions in the system (It's one more than the actual number)"]
      #[cfg(feature = "ink")]
      pub fn instruction_counter(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::settlement::InstructionId>
      {
        let value = self.api.read_storage(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 186u8, 56u8, 151u8, 67u8, 78u8, 201u8, 90u8, 108u8, 36u8, 245u8,
          147u8, 242u8, 23u8, 13u8, 233u8, 58u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::settlement::InstructionId>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Instruction memo"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_memos(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::Memo>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 91u8, 46u8, 219u8, 158u8, 9u8, 52u8, 231u8, 25u8, 76u8, 164u8, 67u8,
          166u8, 153u8, 53u8, 138u8, 48u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Instruction memo"]
      #[cfg(feature = "ink")]
      pub fn instruction_memos(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::Memo>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 91u8, 46u8, 219u8, 158u8, 9u8, 52u8, 231u8, 25u8, 76u8, 164u8, 67u8,
          166u8, 153u8, 53u8, 138u8, 48u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Instruction statuses. instruction_id -> InstructionStatus"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_statuses(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::InstructionStatus<u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 129u8, 220u8, 107u8, 190u8, 175u8, 117u8, 37u8, 159u8, 155u8, 144u8,
          126u8, 158u8, 40u8, 0u8, 88u8, 54u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::InstructionStatus<u32>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Instruction statuses. instruction_id -> InstructionStatus"]
      #[cfg(feature = "ink")]
      pub fn instruction_statuses(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::InstructionStatus<u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 129u8, 220u8, 107u8, 190u8, 175u8, 117u8, 37u8, 159u8, 155u8, 144u8,
          126u8, 158u8, 40u8, 0u8, 88u8, 54u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::InstructionStatus<u32>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Legs under an instruction. (instruction_id, leg_id) -> Leg"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_legs(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::settlement::Leg>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 17u8, 1u8, 179u8, 157u8, 113u8, 141u8, 101u8, 250u8, 213u8, 115u8,
          20u8, 61u8, 204u8, 53u8, 74u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Legs under an instruction. (instruction_id, leg_id) -> Leg"]
      #[cfg(feature = "ink")]
      pub fn instruction_legs(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::settlement::Leg>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 17u8, 1u8, 179u8, 157u8, 113u8, 141u8, 101u8, 250u8, 213u8, 115u8,
          20u8, 61u8, 204u8, 53u8, 74u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Tracks the affirmation status for offchain legs in a instruction. [`(InstructionId, LegId)`] -> [`AffirmationStatus`]"]
      #[cfg(not(feature = "ink"))]
      pub async fn off_chain_affirmations(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 83u8, 128u8, 215u8, 35u8, 66u8, 131u8, 241u8, 146u8, 213u8, 20u8,
          216u8, 29u8, 178u8, 153u8, 36u8, 132u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Tracks the affirmation status for offchain legs in a instruction. [`(InstructionId, LegId)`] -> [`AffirmationStatus`]"]
      #[cfg(feature = "ink")]
      pub fn off_chain_affirmations(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 83u8, 128u8, 215u8, 35u8, 66u8, 131u8, 241u8, 146u8, 213u8, 20u8,
          216u8, 29u8, 178u8, 153u8, 36u8, 132u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Tracks the number of signers each venue has."]
      #[cfg(not(feature = "ink"))]
      pub async fn number_of_venue_signers(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 65u8, 49u8, 135u8, 25u8, 96u8, 14u8, 112u8, 10u8, 188u8, 29u8, 148u8,
          244u8, 217u8, 121u8, 111u8, 6u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks the number of signers each venue has."]
      #[cfg(feature = "ink")]
      pub fn number_of_venue_signers(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_ink::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 65u8, 49u8, 135u8, 25u8, 96u8, 14u8, 112u8, 10u8, 188u8, 29u8, 148u8,
          244u8, 217u8, 121u8, 111u8, 6u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The status for the mediators affirmation."]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_mediators_affirmations(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::MediatorAffirmationStatus<u64>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 195u8, 167u8, 176u8, 135u8, 61u8, 124u8, 1u8, 184u8, 154u8, 97u8, 6u8,
          91u8, 221u8, 125u8, 202u8, 39u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::MediatorAffirmationStatus<u64>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The status for the mediators affirmation."]
      #[cfg(feature = "ink")]
      pub fn instruction_mediators_affirmations(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::MediatorAffirmationStatus<u64>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 195u8, 167u8, 176u8, 135u8, 61u8, 124u8, 1u8, 184u8, 154u8, 97u8, 6u8,
          91u8, 221u8, 125u8, 202u8, 39u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::MediatorAffirmationStatus<u64>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_settlement::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_settlement::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_settlement::Version> {
        let value = self.api.read_storage(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_settlement::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct SettlementPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> SettlementPagedQueryApi<'api> {
      #[doc = " Info about a venue. venue_id -> venue"]
      pub fn venue_info(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::VenueId,
        types::polymesh_primitives::settlement::Venue,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 37u8, 149u8, 35u8, 221u8, 234u8, 221u8, 43u8, 130u8, 235u8, 131u8,
          158u8, 182u8, 118u8, 158u8, 16u8, 163u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Free-form text about a venue. venue_id -> `VenueDetails`"]
      #[doc = " Only needed for the UI."]
      pub fn details(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::VenueId,
        types::polymesh_primitives::settlement::VenueDetails,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8, 198u8, 220u8,
          28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Instructions under a venue."]
      #[doc = " Only needed for the UI."]
      #[doc = ""]
      #[doc = " venue_id -> instruction_id -> ()"]
      pub fn venue_instructions(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::InstructionId,
        (),
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 194u8, 12u8, 53u8, 241u8, 21u8, 245u8, 35u8, 172u8, 170u8, 85u8, 47u8,
          113u8, 49u8, 126u8, 98u8, 7u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Signers allowed by the venue. (venue_id, signer) -> bool"]
      pub fn venue_signers(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 182u8, 5u8, 81u8, 237u8, 11u8, 31u8, 45u8, 224u8, 46u8, 226u8, 44u8,
          156u8, 78u8, 11u8, 160u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Venues create by an identity."]
      #[doc = " Only needed for the UI."]
      #[doc = ""]
      #[doc = " identity -> venue_id -> ()"]
      pub fn user_venues(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<types::polymesh_primitives::settlement::VenueId, ()>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 210u8, 109u8, 136u8, 8u8, 7u8, 235u8, 230u8, 119u8, 137u8, 87u8,
          141u8, 192u8, 40u8, 218u8, 115u8, 74u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Details about an instruction. instruction_id -> instruction_details"]
      pub fn instruction_details(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::InstructionId,
        types::polymesh_primitives::settlement::Instruction<u64, u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 139u8, 174u8, 75u8, 191u8, 82u8, 90u8, 68u8, 48u8, 145u8, 19u8, 222u8,
          238u8, 96u8, 255u8, 129u8, 178u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Status of a leg under an instruction. (instruction_id, leg_id) -> LegStatus"]
      pub fn instruction_leg_status(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::LegId,
        types::polymesh_primitives::settlement::LegStatus<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 241u8, 210u8, 62u8, 209u8, 210u8, 216u8, 97u8, 163u8, 74u8, 117u8,
          189u8, 72u8, 12u8, 109u8, 191u8, 35u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Number of affirmations pending before instruction is executed. instruction_id -> affirm_pending"]
      pub fn instruction_affirms_pending(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::InstructionId,
        u64,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 84u8, 168u8, 38u8, 237u8, 42u8, 215u8, 233u8, 246u8, 173u8, 70u8, 3u8,
          122u8, 135u8, 90u8, 149u8, 95u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Tracks affirmations received for an instruction. (instruction_id, counter_party) -> AffirmationStatus"]
      pub fn affirms_received(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::identity_id::PortfolioId,
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 196u8, 164u8, 249u8, 77u8, 192u8, 14u8, 231u8, 77u8, 10u8, 20u8, 57u8,
          61u8, 241u8, 216u8, 34u8, 202u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Helps a user track their pending instructions and affirmations (only needed for UI)."]
      #[doc = " (counter_party, instruction_id) -> AffirmationStatus"]
      pub fn user_affirmations(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::InstructionId,
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 34u8, 4u8, 158u8, 52u8, 236u8, 109u8, 105u8, 33u8, 29u8, 40u8, 146u8,
          57u8, 70u8, 48u8, 102u8, 159u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Tracks redemption of receipts. (signer, receipt_uid) -> receipt_used"]
      pub fn receipts_used(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::StoragePaged<u64, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 127u8, 126u8, 234u8, 226u8, 61u8, 64u8, 167u8, 253u8, 218u8, 94u8,
          162u8, 111u8, 120u8, 56u8, 116u8, 157u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Tracks if a token has enabled filtering venues that can create instructions involving their token. AssetId -> filtering_enabled"]
      pub fn venue_filtering(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 242u8, 42u8, 22u8, 99u8, 179u8, 59u8, 93u8, 97u8, 223u8, 90u8, 186u8,
          160u8, 76u8, 19u8, 198u8, 73u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Venues that are allowed to create instructions involving a particular asset. Only used if filtering is enabled."]
      #[doc = " ([`AssetId`], venue_id) -> allowed"]
      pub fn venue_allow_list(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<types::polymesh_primitives::settlement::VenueId, bool>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 113u8, 120u8, 81u8, 211u8, 168u8, 229u8, 128u8, 215u8, 96u8, 177u8,
          241u8, 151u8, 120u8, 224u8, 185u8, 22u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Instruction memo"]
      pub fn instruction_memos(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::InstructionId,
        types::polymesh_primitives::Memo,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 91u8, 46u8, 219u8, 158u8, 9u8, 52u8, 231u8, 25u8, 76u8, 164u8, 67u8,
          166u8, 153u8, 53u8, 138u8, 48u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Instruction statuses. instruction_id -> InstructionStatus"]
      pub fn instruction_statuses(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::InstructionId,
        types::polymesh_primitives::settlement::InstructionStatus<u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 129u8, 220u8, 107u8, 190u8, 175u8, 117u8, 37u8, 159u8, 155u8, 144u8,
          126u8, 158u8, 40u8, 0u8, 88u8, 54u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Legs under an instruction. (instruction_id, leg_id) -> Leg"]
      pub fn instruction_legs(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::LegId,
        types::polymesh_primitives::settlement::Leg,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 17u8, 1u8, 179u8, 157u8, 113u8, 141u8, 101u8, 250u8, 213u8, 115u8,
          20u8, 61u8, 204u8, 53u8, 74u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Tracks the affirmation status for offchain legs in a instruction. [`(InstructionId, LegId)`] -> [`AffirmationStatus`]"]
      pub fn off_chain_affirmations(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::settlement::LegId,
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 83u8, 128u8, 215u8, 35u8, 66u8, 131u8, 241u8, 146u8, 213u8, 20u8,
          216u8, 29u8, 178u8, 153u8, 36u8, 132u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Tracks the number of signers each venue has."]
      pub fn number_of_venue_signers(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<types::polymesh_primitives::settlement::VenueId, u32>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 65u8, 49u8, 135u8, 25u8, 96u8, 14u8, 112u8, 10u8, 188u8, 29u8, 148u8,
          244u8, 217u8, 121u8, 111u8, 6u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " The status for the mediators affirmation."]
      pub fn instruction_mediators_affirmations(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::IdentityId,
        types::polymesh_primitives::settlement::MediatorAffirmationStatus<u64>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 195u8, 167u8, 176u8, 135u8, 61u8, 124u8, 1u8, 184u8, 154u8, 97u8, 6u8,
          91u8, 221u8, 125u8, 202u8, 39u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
    }
  }
  pub mod statistics {
    use super::*;
    #[derive(Clone)]
    pub struct StatisticsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> StatisticsCallApi<'api> {
      #[doc = "Set the active asset stat_types."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
      #[doc = "- `stat_types` - the new stat types to replace any existing types."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeLimitReached` - too many stat types enabled for the `asset_id`."]
      #[doc = "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_asset_stats(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        stat_types: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::statistics::StatType,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Statistics(
          types::pallet_statistics::StatisticsCall::set_active_asset_stats {
            asset_id,
            stat_types,
          },
        ))
      }
      #[doc = "Set the active asset stat_types."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
      #[doc = "- `stat_types` - the new stat types to replace any existing types."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeLimitReached` - too many stat types enabled for the `asset_id`."]
      #[doc = "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(feature = "ink")]
      pub fn set_active_asset_stats(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        stat_types: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::statistics::StatType,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![38u8, 0u8];
        asset_id.encode_to(&mut buf);
        stat_types.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allow a trusted issuer to init/resync asset/company stats."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
      #[doc = "- `stat_type` - stat type to update."]
      #[doc = "- `values` - Updated values for `stat_type`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeMissing` - `stat_type` is not enabled for the `asset_id`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn batch_update_asset_stats(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        stat_type: types::polymesh_primitives::statistics::StatType,
        values: ::alloc::collections::BTreeSet<types::polymesh_primitives::statistics::StatUpdate>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Statistics(
          types::pallet_statistics::StatisticsCall::batch_update_asset_stats {
            asset_id,
            stat_type,
            values,
          },
        ))
      }
      #[doc = "Allow a trusted issuer to init/resync asset/company stats."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
      #[doc = "- `stat_type` - stat type to update."]
      #[doc = "- `values` - Updated values for `stat_type`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeMissing` - `stat_type` is not enabled for the `asset_id`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(feature = "ink")]
      pub fn batch_update_asset_stats(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        stat_type: types::polymesh_primitives::statistics::StatType,
        values: ::alloc::collections::BTreeSet<types::polymesh_primitives::statistics::StatUpdate>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![38u8, 1u8];
        asset_id.encode_to(&mut buf);
        stat_type.encode_to(&mut buf);
        values.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set asset transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
      #[doc = "- `transfer_conditions` - the new transfer condition to replace any existing conditions."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset_id`."]
      #[doc = "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset_id`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_asset_transfer_compliance(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        transfer_conditions: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::transfer_compliance::TransferCondition,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Statistics(
          types::pallet_statistics::StatisticsCall::set_asset_transfer_compliance {
            asset_id,
            transfer_conditions,
          },
        ))
      }
      #[doc = "Set asset transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
      #[doc = "- `transfer_conditions` - the new transfer condition to replace any existing conditions."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset_id`."]
      #[doc = "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset_id`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(feature = "ink")]
      pub fn set_asset_transfer_compliance(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        transfer_conditions: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::transfer_compliance::TransferCondition,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![38u8, 2u8];
        asset_id.encode_to(&mut buf);
        transfer_conditions.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set/unset entities exempt from an asset's transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`."]
      #[doc = "- `is_exempt` - enable/disable exemption for `entities`."]
      #[doc = "- `exempt_key` - the asset and stat type to exempt the `entities` from."]
      #[doc = "- `entities` - the entities to set/unset the exemption for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_entities_exempt(
        &self,
        is_exempt: bool,
        exempt_key: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
        entities: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Statistics(
          types::pallet_statistics::StatisticsCall::set_entities_exempt {
            is_exempt,
            exempt_key,
            entities,
          },
        ))
      }
      #[doc = "Set/unset entities exempt from an asset's transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`."]
      #[doc = "- `is_exempt` - enable/disable exemption for `entities`."]
      #[doc = "- `exempt_key` - the asset and stat type to exempt the `entities` from."]
      #[doc = "- `entities` - the entities to set/unset the exemption for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(feature = "ink")]
      pub fn set_entities_exempt(
        &self,
        is_exempt: bool,
        exempt_key: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
        entities: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![38u8, 3u8];
        is_exempt.encode_to(&mut buf);
        exempt_key.encode_to(&mut buf);
        entities.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for StatisticsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct StatisticsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> StatisticsQueryApi<'api> {
      #[doc = " Maps a set of [`StatType`] for each [`AssetId`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_asset_stats(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::collections::BTreeSet<types::polymesh_primitives::statistics::StatType>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 239u8, 22u8, 59u8, 174u8, 32u8, 48u8, 119u8, 218u8, 227u8, 43u8,
          193u8, 151u8, 65u8, 213u8, 147u8, 30u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::collections::BTreeSet<
                            types::polymesh_primitives::statistics::StatType,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
        }))
      }
      #[doc = " Maps a set of [`StatType`] for each [`AssetId`]."]
      #[cfg(feature = "ink")]
      pub fn active_asset_stats(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::collections::BTreeSet<types::polymesh_primitives::statistics::StatType>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 239u8, 22u8, 59u8, 174u8, 32u8, 48u8, 119u8, 218u8, 227u8, 43u8,
          193u8, 151u8, 65u8, 213u8, 147u8, 30u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::collections::BTreeSet<
                            types::polymesh_primitives::statistics::StatType,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
        }))
      }
      #[doc = " Asset stats."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_stats(
        &self,
        key_0: types::polymesh_primitives::statistics::Stat1stKey,
        key_1: types::polymesh_primitives::statistics::Stat2ndKey,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 13u8, 224u8, 187u8, 176u8, 120u8, 186u8, 103u8, 210u8, 250u8, 246u8,
          251u8, 70u8, 123u8, 141u8, 62u8, 51u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Asset stats."]
      #[cfg(feature = "ink")]
      pub fn asset_stats(
        &self,
        key_0: types::polymesh_primitives::statistics::Stat1stKey,
        key_1: types::polymesh_primitives::statistics::Stat2ndKey,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 13u8, 224u8, 187u8, 176u8, 120u8, 186u8, 103u8, 210u8, 250u8, 246u8,
          251u8, 70u8, 123u8, 141u8, 62u8, 51u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The [`AssetTransferCompliance`] for each [`AssetId`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_transfer_compliances(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::transfer_compliance::AssetTransferCompliance,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 86u8, 51u8, 252u8, 244u8, 127u8, 54u8, 208u8, 97u8, 49u8, 83u8, 224u8,
          203u8, 24u8, 190u8, 105u8, 124u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::polymesh_primitives::transfer_compliance::AssetTransferCompliance>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The [`AssetTransferCompliance`] for each [`AssetId`]."]
      #[cfg(feature = "ink")]
      pub fn asset_transfer_compliances(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::transfer_compliance::AssetTransferCompliance,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 86u8, 51u8, 252u8, 244u8, 127u8, 54u8, 208u8, 97u8, 49u8, 83u8, 224u8,
          203u8, 24u8, 190u8, 105u8, 124u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::polymesh_primitives::transfer_compliance::AssetTransferCompliance>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Entities exempt from a Transfer Compliance rule."]
      #[cfg(not(feature = "ink"))]
      pub async fn transfer_condition_exempt_entities(
        &self,
        key_0: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 26u8, 48u8, 88u8, 202u8, 218u8, 234u8, 155u8, 104u8, 25u8, 241u8,
          119u8, 22u8, 42u8, 149u8, 27u8, 223u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Entities exempt from a Transfer Compliance rule."]
      #[cfg(feature = "ink")]
      pub fn transfer_condition_exempt_entities(
        &self,
        key_0: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 26u8, 48u8, 88u8, 202u8, 218u8, 234u8, 155u8, 104u8, 25u8, 241u8,
          119u8, 22u8, 42u8, 149u8, 27u8, 223u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage migration version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_statistics::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_statistics::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage migration version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_statistics::Version> {
        let value = self.api.read_storage(::alloc::vec![
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_statistics::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct StatisticsPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> StatisticsPagedQueryApi<'api> {
      #[doc = " Maps a set of [`StatType`] for each [`AssetId`]."]
      pub fn active_asset_stats(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        ::alloc::collections::BTreeSet<types::polymesh_primitives::statistics::StatType>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 239u8, 22u8, 59u8, 174u8, 32u8, 48u8, 119u8, 218u8, 227u8, 43u8,
          193u8, 151u8, 65u8, 213u8, 147u8, 30u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Asset stats."]
      pub fn asset_stats(
        &self,
        key_0: types::polymesh_primitives::statistics::Stat1stKey,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::statistics::Stat2ndKey,
        u128,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 13u8, 224u8, 187u8, 176u8, 120u8, 186u8, 103u8, 210u8, 250u8, 246u8,
          251u8, 70u8, 123u8, 141u8, 62u8, 51u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The [`AssetTransferCompliance`] for each [`AssetId`]."]
      pub fn asset_transfer_compliances(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::polymesh_primitives::transfer_compliance::AssetTransferCompliance,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 86u8, 51u8, 252u8, 244u8, 127u8, 54u8, 208u8, 97u8, 49u8, 83u8, 224u8,
          203u8, 24u8, 190u8, 105u8, 124u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Entities exempt from a Transfer Compliance rule."]
      pub fn transfer_condition_exempt_entities(
        &self,
        key_0: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 26u8, 48u8, 88u8, 202u8, 218u8, 234u8, 155u8, 104u8, 25u8, 241u8,
          119u8, 22u8, 42u8, 149u8, 27u8, 223u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
    }
  }
  pub mod sto {
    use super::*;
    #[derive(Clone)]
    pub struct StoCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> StoCallApi<'api> {
      #[doc = "Create a new fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_portfolio` - Portfolio containing the `offering_asset`."]
      #[doc = "* `offering_asset` - Asset being offered."]
      #[doc = "* `raising_portfolio` - Portfolio containing the `raising_asset`."]
      #[doc = "* `raising_asset` - Asset being exchanged for `offering_asset` on investment."]
      #[doc = "* `tiers` - Price tiers to charge investors on investment."]
      #[doc = "* `venue_id` - Venue to handle settlement."]
      #[doc = "* `start` - Fundraiser start time, if `None` the fundraiser will start immediately."]
      #[doc = "* `end` - Fundraiser end time, if `None` the fundraiser will never expire."]
      #[doc = "* `minimum_investment` - Minimum amount of `raising_asset` that an investor needs to spend to invest in this raise."]
      #[doc = "* `fundraiser_name` - Fundraiser name, only used in the UIs."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn create_fundraiser(
        &self,
        offering_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        offering_asset: ::polymesh_api_client::AssetId,
        raising_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        raising_asset: ::polymesh_api_client::AssetId,
        tiers: ::alloc::vec::Vec<types::pallet_sto::PriceTier>,
        venue_id: types::polymesh_primitives::settlement::VenueId,
        start: Option<u64>,
        end: Option<u64>,
        minimum_investment: u128,
        fundraiser_name: types::pallet_sto::FundraiserName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::create_fundraiser {
            offering_portfolio,
            offering_asset,
            raising_portfolio,
            raising_asset,
            tiers,
            venue_id,
            start,
            end,
            minimum_investment,
            fundraiser_name,
          },
        ))
      }
      #[doc = "Create a new fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_portfolio` - Portfolio containing the `offering_asset`."]
      #[doc = "* `offering_asset` - Asset being offered."]
      #[doc = "* `raising_portfolio` - Portfolio containing the `raising_asset`."]
      #[doc = "* `raising_asset` - Asset being exchanged for `offering_asset` on investment."]
      #[doc = "* `tiers` - Price tiers to charge investors on investment."]
      #[doc = "* `venue_id` - Venue to handle settlement."]
      #[doc = "* `start` - Fundraiser start time, if `None` the fundraiser will start immediately."]
      #[doc = "* `end` - Fundraiser end time, if `None` the fundraiser will never expire."]
      #[doc = "* `minimum_investment` - Minimum amount of `raising_asset` that an investor needs to spend to invest in this raise."]
      #[doc = "* `fundraiser_name` - Fundraiser name, only used in the UIs."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn create_fundraiser(
        &self,
        offering_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        offering_asset: ::polymesh_api_client::AssetId,
        raising_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        raising_asset: ::polymesh_api_client::AssetId,
        tiers: ::alloc::vec::Vec<types::pallet_sto::PriceTier>,
        venue_id: types::polymesh_primitives::settlement::VenueId,
        start: Option<u64>,
        end: Option<u64>,
        minimum_investment: u128,
        fundraiser_name: types::pallet_sto::FundraiserName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 0u8];
        offering_portfolio.encode_to(&mut buf);
        offering_asset.encode_to(&mut buf);
        raising_portfolio.encode_to(&mut buf);
        raising_asset.encode_to(&mut buf);
        tiers.encode_to(&mut buf);
        venue_id.encode_to(&mut buf);
        start.encode_to(&mut buf);
        end.encode_to(&mut buf);
        minimum_investment.encode_to(&mut buf);
        fundraiser_name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Invest in a fundraiser."]
      #[doc = ""]
      #[doc = "* `investment_portfolio` - Portfolio that `offering_asset` will be deposited in."]
      #[doc = "* `funding_portfolio` - Portfolio that will fund the investment."]
      #[doc = "* `offering_asset` - Asset to invest in."]
      #[doc = "* `id` - ID of the fundraiser to invest in."]
      #[doc = "* `purchase_amount` - Amount of `offering_asset` to purchase."]
      #[doc = "* `max_price` - Maximum price to pay per unit of `offering_asset`, If `None`there are no constraints on price."]
      #[doc = "* `receipt` - Off-chain receipt to use instead of on-chain balance in `funding_portfolio`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn invest(
        &self,
        investment_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        funding_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        offering_asset: ::polymesh_api_client::AssetId,
        id: types::pallet_sto::FundraiserId,
        purchase_amount: u128,
        max_price: Option<u128>,
        receipt: Option<
          types::polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            types::sp_runtime::MultiSignature,
          >,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::invest {
            investment_portfolio,
            funding_portfolio,
            offering_asset,
            id,
            purchase_amount,
            max_price,
            receipt,
          },
        ))
      }
      #[doc = "Invest in a fundraiser."]
      #[doc = ""]
      #[doc = "* `investment_portfolio` - Portfolio that `offering_asset` will be deposited in."]
      #[doc = "* `funding_portfolio` - Portfolio that will fund the investment."]
      #[doc = "* `offering_asset` - Asset to invest in."]
      #[doc = "* `id` - ID of the fundraiser to invest in."]
      #[doc = "* `purchase_amount` - Amount of `offering_asset` to purchase."]
      #[doc = "* `max_price` - Maximum price to pay per unit of `offering_asset`, If `None`there are no constraints on price."]
      #[doc = "* `receipt` - Off-chain receipt to use instead of on-chain balance in `funding_portfolio`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn invest(
        &self,
        investment_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        funding_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        offering_asset: ::polymesh_api_client::AssetId,
        id: types::pallet_sto::FundraiserId,
        purchase_amount: u128,
        max_price: Option<u128>,
        receipt: Option<
          types::polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            types::sp_runtime::MultiSignature,
          >,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 1u8];
        investment_portfolio.encode_to(&mut buf);
        funding_portfolio.encode_to(&mut buf);
        offering_asset.encode_to(&mut buf);
        id.encode_to(&mut buf);
        purchase_amount.encode_to(&mut buf);
        max_price.encode_to(&mut buf);
        receipt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Freeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to freeze."]
      #[doc = "* `id` - ID of the fundraiser to freeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn freeze_fundraiser(
        &self,
        offering_asset: ::polymesh_api_client::AssetId,
        id: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::freeze_fundraiser { offering_asset, id },
        ))
      }
      #[doc = "Freeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to freeze."]
      #[doc = "* `id` - ID of the fundraiser to freeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn freeze_fundraiser(
        &self,
        offering_asset: ::polymesh_api_client::AssetId,
        id: types::pallet_sto::FundraiserId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 2u8];
        offering_asset.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Unfreeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to unfreeze."]
      #[doc = "* `id` - ID of the fundraiser to unfreeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn unfreeze_fundraiser(
        &self,
        offering_asset: ::polymesh_api_client::AssetId,
        id: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::unfreeze_fundraiser { offering_asset, id },
        ))
      }
      #[doc = "Unfreeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to unfreeze."]
      #[doc = "* `id` - ID of the fundraiser to unfreeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn unfreeze_fundraiser(
        &self,
        offering_asset: ::polymesh_api_client::AssetId,
        id: types::pallet_sto::FundraiserId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 3u8];
        offering_asset.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Modify the time window a fundraiser is active"]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to modify."]
      #[doc = "* `id` - ID of the fundraiser to modify."]
      #[doc = "* `start` - New start of the fundraiser."]
      #[doc = "* `end` - New end of the fundraiser to modify."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn modify_fundraiser_window(
        &self,
        offering_asset: ::polymesh_api_client::AssetId,
        id: types::pallet_sto::FundraiserId,
        start: u64,
        end: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::modify_fundraiser_window {
            offering_asset,
            id,
            start,
            end,
          },
        ))
      }
      #[doc = "Modify the time window a fundraiser is active"]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to modify."]
      #[doc = "* `id` - ID of the fundraiser to modify."]
      #[doc = "* `start` - New start of the fundraiser."]
      #[doc = "* `end` - New end of the fundraiser to modify."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn modify_fundraiser_window(
        &self,
        offering_asset: ::polymesh_api_client::AssetId,
        id: types::pallet_sto::FundraiserId,
        start: u64,
        end: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 4u8];
        offering_asset.encode_to(&mut buf);
        id.encode_to(&mut buf);
        start.encode_to(&mut buf);
        end.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Stop a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to stop."]
      #[doc = "* `id` - ID of the fundraiser to stop."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn stop(
        &self,
        offering_asset: ::polymesh_api_client::AssetId,
        id: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::stop { offering_asset, id },
        ))
      }
      #[doc = "Stop a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to stop."]
      #[doc = "* `id` - ID of the fundraiser to stop."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn stop(
        &self,
        offering_asset: ::polymesh_api_client::AssetId,
        id: types::pallet_sto::FundraiserId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 5u8];
        offering_asset.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for StoCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct StoQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> StoQueryApi<'api> {
      #[doc = " All fundraisers that are currently running."]
      #[doc = " (AssetId, fundraiser_id) -> Fundraiser"]
      #[cfg(not(feature = "ink"))]
      pub async fn fundraisers(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_sto::Fundraiser<u64>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 200u8, 242u8, 149u8, 77u8, 218u8, 243u8, 200u8, 19u8, 142u8, 65u8,
          23u8, 184u8, 97u8, 230u8, 68u8, 109u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All fundraisers that are currently running."]
      #[doc = " (AssetId, fundraiser_id) -> Fundraiser"]
      #[cfg(feature = "ink")]
      pub fn fundraisers(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_sto::Fundraiser<u64>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 200u8, 242u8, 149u8, 77u8, 218u8, 243u8, 200u8, 19u8, 142u8, 65u8,
          23u8, 184u8, 97u8, 230u8, 68u8, 109u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Total fundraisers created for a token."]
      #[cfg(not(feature = "ink"))]
      pub async fn fundraiser_count(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_sto::FundraiserId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 220u8, 57u8, 49u8, 4u8, 64u8, 150u8, 65u8, 208u8, 189u8, 149u8, 72u8,
          244u8, 76u8, 90u8, 115u8, 235u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::pallet_sto::FundraiserId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Total fundraisers created for a token."]
      #[cfg(feature = "ink")]
      pub fn fundraiser_count(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_sto::FundraiserId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 220u8, 57u8, 49u8, 4u8, 64u8, 150u8, 65u8, 208u8, 189u8, 149u8, 72u8,
          244u8, 76u8, 90u8, 115u8, 235u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::pallet_sto::FundraiserId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Name for the Fundraiser. Only used offchain."]
      #[doc = " (AssetId, fundraiser_id) -> Fundraiser name"]
      #[cfg(not(feature = "ink"))]
      pub async fn fundraiser_names(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_sto::FundraiserName>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 70u8, 206u8, 185u8, 249u8, 61u8, 181u8, 239u8, 65u8, 114u8, 228u8,
          101u8, 54u8, 80u8, 98u8, 238u8, 252u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Name for the Fundraiser. Only used offchain."]
      #[doc = " (AssetId, fundraiser_id) -> Fundraiser name"]
      #[cfg(feature = "ink")]
      pub fn fundraiser_names(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_sto::FundraiserName>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 70u8, 206u8, 185u8, 249u8, 61u8, 181u8, 239u8, 65u8, 114u8, 228u8,
          101u8, 54u8, 80u8, 98u8, 238u8, 252u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Storage migration version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_sto::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_sto::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage migration version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_sto::Version> {
        let value = self.api.read_storage(::alloc::vec![
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_sto::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct StoPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> StoPagedQueryApi<'api> {
      #[doc = " All fundraisers that are currently running."]
      #[doc = " (AssetId, fundraiser_id) -> Fundraiser"]
      pub fn fundraisers(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_sto::FundraiserId,
        types::pallet_sto::Fundraiser<u64>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 200u8, 242u8, 149u8, 77u8, 218u8, 243u8, 200u8, 19u8, 142u8, 65u8,
          23u8, 184u8, 97u8, 230u8, 68u8, 109u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Total fundraisers created for a token."]
      pub fn fundraiser_count(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::pallet_sto::FundraiserId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 220u8, 57u8, 49u8, 4u8, 64u8, 150u8, 65u8, 208u8, 189u8, 149u8, 72u8,
          244u8, 76u8, 90u8, 115u8, 235u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Name for the Fundraiser. Only used offchain."]
      #[doc = " (AssetId, fundraiser_id) -> Fundraiser name"]
      pub fn fundraiser_names(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::pallet_sto::FundraiserId,
        types::pallet_sto::FundraiserName,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 70u8, 206u8, 185u8, 249u8, 61u8, 181u8, 239u8, 65u8, 114u8, 228u8,
          101u8, 54u8, 80u8, 98u8, 238u8, 252u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod treasury {
    use super::*;
    #[derive(Clone)]
    pub struct TreasuryCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TreasuryCallApi<'api> {
      #[doc = "It transfers balances from treasury to each of beneficiaries and the specific amount"]
      #[doc = "for each of them."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = "* `BadOrigin`: Only root can execute transaction."]
      #[doc = "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries."]
      #[doc = "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity."]
      #[cfg(not(feature = "ink"))]
      pub fn disbursement(
        &self,
        beneficiaries: ::alloc::vec::Vec<types::polymesh_primitives::Beneficiary<u128>>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Treasury(
          types::pallet_treasury::TreasuryCall::disbursement { beneficiaries },
        ))
      }
      #[doc = "It transfers balances from treasury to each of beneficiaries and the specific amount"]
      #[doc = "for each of them."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = "* `BadOrigin`: Only root can execute transaction."]
      #[doc = "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries."]
      #[doc = "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity."]
      #[cfg(feature = "ink")]
      pub fn disbursement(
        &self,
        beneficiaries: ::alloc::vec::Vec<types::polymesh_primitives::Beneficiary<u128>>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![40u8, 0u8];
        beneficiaries.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "It transfers the specific `amount` from `origin` account into treasury."]
      #[doc = ""]
      #[doc = "Only accounts which are associated to an identity can make a donation to treasury."]
      #[cfg(not(feature = "ink"))]
      pub fn reimbursement(
        &self,
        amount: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Treasury(
          types::pallet_treasury::TreasuryCall::reimbursement { amount },
        ))
      }
      #[doc = "It transfers the specific `amount` from `origin` account into treasury."]
      #[doc = ""]
      #[doc = "Only accounts which are associated to an identity can make a donation to treasury."]
      #[cfg(feature = "ink")]
      pub fn reimbursement(&self, amount: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![40u8, 1u8];
        amount.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for TreasuryCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TreasuryQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TreasuryQueryApi<'api> {}
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct TreasuryPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> TreasuryPagedQueryApi<'api> {}
  }
  pub mod utility {
    use super::*;
    #[derive(Clone)]
    pub struct UtilityCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> UtilityCallApi<'api> {
      #[doc = "Send a batch of dispatch calls."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[doc = ""]
      #[doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"]
      #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
      #[doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"]
      #[doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"]
      #[doc = "event is deposited."]
      #[cfg(not(feature = "ink"))]
      pub fn batch(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::batch { calls },
        ))
      }
      #[doc = "Send a batch of dispatch calls."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[doc = ""]
      #[doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"]
      #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
      #[doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"]
      #[doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"]
      #[doc = "event is deposited."]
      #[cfg(feature = "ink")]
      pub fn batch(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 0u8];
        calls.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Relay a call for a target from an origin"]
      #[doc = ""]
      #[doc = "Relaying in this context refers to the ability of origin to make a call on behalf of"]
      #[doc = "target."]
      #[doc = ""]
      #[doc = "Fees are charged to origin"]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = "- `target`: Account to be relayed"]
      #[doc = "- `signature`: Signature from target authorizing the relay"]
      #[doc = "- `call`: Call to be relayed on behalf of target"]
      #[doc = ""]
      #[doc = "POLYMESH: added."]
      #[cfg(not(feature = "ink"))]
      pub fn relay_tx(
        &self,
        target: ::polymesh_api_client::AccountId,
        signature: types::sp_runtime::MultiSignature,
        call: types::pallet_utility::UniqueCall<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::relay_tx {
            target,
            signature,
            call,
          },
        ))
      }
      #[doc = "Relay a call for a target from an origin"]
      #[doc = ""]
      #[doc = "Relaying in this context refers to the ability of origin to make a call on behalf of"]
      #[doc = "target."]
      #[doc = ""]
      #[doc = "Fees are charged to origin"]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = "- `target`: Account to be relayed"]
      #[doc = "- `signature`: Signature from target authorizing the relay"]
      #[doc = "- `call`: Call to be relayed on behalf of target"]
      #[doc = ""]
      #[doc = "POLYMESH: added."]
      #[cfg(feature = "ink")]
      pub fn relay_tx(
        &self,
        target: ::polymesh_api_client::AccountId,
        signature: types::sp_runtime::MultiSignature,
        call: types::pallet_utility::UniqueCall<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 1u8];
        target.encode_to(&mut buf);
        signature.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Send a batch of dispatch calls and atomically execute them."]
      #[doc = "The whole transaction will rollback and fail if any of the calls failed."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[cfg(not(feature = "ink"))]
      pub fn batch_all(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::batch_all { calls },
        ))
      }
      #[doc = "Send a batch of dispatch calls and atomically execute them."]
      #[doc = "The whole transaction will rollback and fail if any of the calls failed."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[cfg(feature = "ink")]
      pub fn batch_all(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 2u8];
        calls.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Dispatches a function call with a provided origin."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(1)."]
      #[cfg(not(feature = "ink"))]
      pub fn dispatch_as(
        &self,
        as_origin: runtime::OriginCaller,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::dispatch_as {
            as_origin: ::alloc::boxed::Box::new(as_origin),
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Dispatches a function call with a provided origin."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(1)."]
      #[cfg(feature = "ink")]
      pub fn dispatch_as(
        &self,
        as_origin: runtime::OriginCaller,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 3u8];
        as_origin.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Send a batch of dispatch calls."]
      #[doc = "Unlike `batch`, it allows errors and won't interrupt."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatch without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[cfg(not(feature = "ink"))]
      pub fn force_batch(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::force_batch { calls },
        ))
      }
      #[doc = "Send a batch of dispatch calls."]
      #[doc = "Unlike `batch`, it allows errors and won't interrupt."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatch without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[cfg(feature = "ink")]
      pub fn force_batch(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 4u8];
        calls.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Dispatch a function call with a specified weight."]
      #[doc = ""]
      #[doc = "This function does not check the weight of the call, and instead allows the"]
      #[doc = "Root origin to specify the weight of the call."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[cfg(not(feature = "ink"))]
      pub fn with_weight(
        &self,
        call: runtime::RuntimeCall,
        weight: ::polymesh_api_client::sp_weights::Weight,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::with_weight {
            call: ::alloc::boxed::Box::new(call),
            weight,
          },
        ))
      }
      #[doc = "Dispatch a function call with a specified weight."]
      #[doc = ""]
      #[doc = "This function does not check the weight of the call, and instead allows the"]
      #[doc = "Root origin to specify the weight of the call."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[cfg(feature = "ink")]
      pub fn with_weight(
        &self,
        call: runtime::RuntimeCall,
        weight: ::polymesh_api_client::sp_weights::Weight,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 5u8];
        call.encode_to(&mut buf);
        weight.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Send a call through an indexed pseudonym of the sender."]
      #[doc = ""]
      #[doc = "Filter from origin are passed along. The call will be dispatched with an origin which"]
      #[doc = "use the same filter as the origin of this call."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[cfg(not(feature = "ink"))]
      pub fn as_derivative(
        &self,
        index: u16,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::as_derivative {
            index,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Send a call through an indexed pseudonym of the sender."]
      #[doc = ""]
      #[doc = "Filter from origin are passed along. The call will be dispatched with an origin which"]
      #[doc = "use the same filter as the origin of this call."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[cfg(feature = "ink")]
      pub fn as_derivative(
        &self,
        index: u16,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 9u8];
        index.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for UtilityCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct UtilityQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> UtilityQueryApi<'api> {
      #[doc = " Nonce for `relay_tx`."]
      #[doc = " POLYMESH: added."]
      #[cfg(not(feature = "ink"))]
      pub async fn nonces(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 225u8, 162u8, 250u8, 22u8, 115u8, 44u8, 230u8, 144u8, 97u8, 137u8, 67u8, 140u8,
          10u8, 130u8, 198u8, 194u8, 10u8, 83u8, 78u8, 161u8, 40u8, 231u8, 69u8, 69u8, 109u8,
          162u8, 52u8, 205u8, 165u8, 229u8, 109u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Nonce for `relay_tx`."]
      #[doc = " POLYMESH: added."]
      #[cfg(feature = "ink")]
      pub fn nonces(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 225u8, 162u8, 250u8, 22u8, 115u8, 44u8, 230u8, 144u8, 97u8, 137u8, 67u8, 140u8,
          10u8, 130u8, 198u8, 194u8, 10u8, 83u8, 78u8, 161u8, 40u8, 231u8, 69u8, 69u8, 109u8,
          162u8, 52u8, 205u8, 165u8, 229u8, 109u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct UtilityPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> UtilityPagedQueryApi<'api> {
      #[doc = " Nonce for `relay_tx`."]
      #[doc = " POLYMESH: added."]
      pub fn nonces(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 225u8, 162u8, 250u8, 22u8, 115u8, 44u8, 230u8, 144u8, 97u8, 137u8, 67u8, 140u8,
          10u8, 130u8, 198u8, 194u8, 10u8, 83u8, 78u8, 161u8, 40u8, 231u8, 69u8, 69u8, 109u8,
          162u8, 52u8, 205u8, 165u8, 229u8, 109u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod base {
    use super::*;
    #[derive(Clone)]
    pub struct BaseCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> BaseCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for BaseCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct BaseQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> BaseQueryApi<'api> {}
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct BasePagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> BasePagedQueryApi<'api> {}
  }
  pub mod external_agents {
    use super::*;
    #[derive(Clone)]
    pub struct ExternalAgentsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ExternalAgentsCallApi<'api> {
      #[doc = "Creates a custom agent group (AG) for the given `asset_id`."]
      #[doc = ""]
      #[doc = "The AG will have the permissions as given by `perms`."]
      #[doc = "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`,"]
      #[doc = "which you can use as `AgentGroup::Custom(id)` when adding agents for `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] to add the custom group for."]
      #[doc = "- `perms` that the new AG will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn create_group(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::create_group { asset_id, perms },
        ))
      }
      #[doc = "Creates a custom agent group (AG) for the given `asset_id`."]
      #[doc = ""]
      #[doc = "The AG will have the permissions as given by `perms`."]
      #[doc = "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`,"]
      #[doc = "which you can use as `AgentGroup::Custom(id)` when adding agents for `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] to add the custom group for."]
      #[doc = "- `perms` that the new AG will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn create_group(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 0u8];
        asset_id.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the permissions of the custom AG identified by `id`, for the given `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] the custom AG belongs to."]
      #[doc = "- `id` for the custom AG within `asset_id`."]
      #[doc = "- `perms` to update the custom AG to."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn set_group_permissions(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        id: types::polymesh_primitives::agent::AGId,
        perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::set_group_permissions {
            asset_id,
            id,
            perms,
          },
        ))
      }
      #[doc = "Updates the permissions of the custom AG identified by `id`, for the given `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] the custom AG belongs to."]
      #[doc = "- `id` for the custom AG within `asset_id`."]
      #[doc = "- `perms` to update the custom AG to."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn set_group_permissions(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        id: types::polymesh_primitives::agent::AGId,
        perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 1u8];
        asset_id.encode_to(&mut buf);
        id.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove the given `agent` from `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] that has the `agent` to remove."]
      #[doc = "- `agent` of `asset_id` to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` is the last full one."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_agent(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        agent: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::remove_agent { asset_id, agent },
        ))
      }
      #[doc = "Remove the given `agent` from `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] that has the `agent` to remove."]
      #[doc = "- `agent` of `asset_id` to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` is the last full one."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn remove_agent(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        agent: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 2u8];
        asset_id.encode_to(&mut buf);
        agent.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Abdicate agentship for `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] of which the caller is an agent."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAnAgent` if the caller is not an agent of `asset_id`."]
      #[doc = "- `RemovingLastFullAgent` if the caller is the last full agent."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn abdicate(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::abdicate { asset_id },
        ))
      }
      #[doc = "Abdicate agentship for `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] of which the caller is an agent."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAnAgent` if the caller is not an agent of `asset_id`."]
      #[doc = "- `RemovingLastFullAgent` if the caller is the last full agent."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn abdicate(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 3u8];
        asset_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the agent group that `agent` belongs to in `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] that has the `agent`."]
      #[doc = "- `agent` of `asset_id` to change the group for."]
      #[doc = "- `group` that `agent` will belong to in `asset_id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn change_group(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        agent: ::polymesh_api_client::IdentityId,
        group: types::polymesh_primitives::agent::AgentGroup,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::change_group {
            asset_id,
            agent,
            group,
          },
        ))
      }
      #[doc = "Change the agent group that `agent` belongs to in `asset_id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `assetID` the [`AssetId] that has the `agent`."]
      #[doc = "- `agent` of `asset_id` to change the group for."]
      #[doc = "- `group` that `agent` will belong to in `asset_id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn change_group(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        agent: ::polymesh_api_client::IdentityId,
        group: types::polymesh_primitives::agent::AgentGroup,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 4u8];
        asset_id.encode_to(&mut buf);
        agent.encode_to(&mut buf);
        group.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accept an authorization by an agent \"Alice\" who issued `auth_id`"]
      #[doc = "to also become an agent of the asset Alice specified."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` identifying the authorization to accept."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` is for an auth that has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not for a `BecomeAgent` auth type."]
      #[doc = "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth."]
      #[doc = "- `NoSuchAG` if the group referred to a custom that does not exist."]
      #[doc = "- `AlreadyAnAgent` if the caller is already an agent of the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn accept_become_agent(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::accept_become_agent { auth_id },
        ))
      }
      #[doc = "Accept an authorization by an agent \"Alice\" who issued `auth_id`"]
      #[doc = "to also become an agent of the asset Alice specified."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` identifying the authorization to accept."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` is for an auth that has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not for a `BecomeAgent` auth type."]
      #[doc = "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth."]
      #[doc = "- `NoSuchAG` if the group referred to a custom that does not exist."]
      #[doc = "- `AlreadyAnAgent` if the caller is already an agent of the asset."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn accept_become_agent(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 5u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Utility extrinsic to batch `create_group` and  `add_auth`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn create_group_and_add_auth(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
        target: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::create_group_and_add_auth {
            asset_id,
            perms,
            target,
            expiry,
          },
        ))
      }
      #[doc = "Utility extrinsic to batch `create_group` and  `add_auth`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn create_group_and_add_auth(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
        target: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 6u8];
        asset_id.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        target.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Utility extrinsic to batch `create_group` and  `change_group` for custom groups only."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn create_and_change_custom_group(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
        agent: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::create_and_change_custom_group {
            asset_id,
            perms,
            agent,
          },
        ))
      }
      #[doc = "Utility extrinsic to batch `create_group` and  `change_group` for custom groups only."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn create_and_change_custom_group(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
        agent: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 7u8];
        asset_id.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        agent.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ExternalAgentsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ExternalAgentsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ExternalAgentsQueryApi<'api> {
      #[doc = " The next per-asset AG ID in the sequence."]
      #[doc = ""]
      #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence,"]
      #[doc = " which starts from 1, rather than 0."]
      #[cfg(not(feature = "ink"))]
      pub async fn ag_id_sequence(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::agent::AGId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 12u8, 233u8, 200u8, 225u8, 173u8, 92u8, 11u8, 5u8, 96u8, 24u8,
          174u8, 23u8, 140u8, 103u8, 130u8, 219u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::agent::AGId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next per-asset AG ID in the sequence."]
      #[doc = ""]
      #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence,"]
      #[doc = " which starts from 1, rather than 0."]
      #[cfg(feature = "ink")]
      pub fn ag_id_sequence(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::agent::AGId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 12u8, 233u8, 200u8, 225u8, 173u8, 92u8, 11u8, 5u8, 96u8, 24u8,
          174u8, 23u8, 140u8, 103u8, 130u8, 219u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::agent::AGId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps an agent (`IdentityId`) to all assets they belong to, if any."]
      #[cfg(not(feature = "ink"))]
      pub async fn agent_of(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 53u8, 162u8, 207u8, 202u8, 92u8, 195u8, 4u8, 152u8, 44u8, 119u8,
          99u8, 8u8, 91u8, 94u8, 104u8, 181u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps an agent (`IdentityId`) to all assets they belong to, if any."]
      #[cfg(feature = "ink")]
      pub fn agent_of(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 53u8, 162u8, 207u8, 202u8, 92u8, 195u8, 4u8, 152u8, 44u8, 119u8,
          99u8, 8u8, 91u8, 94u8, 104u8, 181u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps agents (`IdentityId`) for an `AssetId` to what AG they belong to, if any."]
      #[cfg(not(feature = "ink"))]
      pub async fn group_of_agent(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::agent::AgentGroup>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 242u8, 55u8, 209u8, 95u8, 72u8, 97u8, 175u8, 60u8, 82u8, 212u8,
          93u8, 134u8, 226u8, 228u8, 249u8, 241u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Maps agents (`IdentityId`) for an `AssetId` to what AG they belong to, if any."]
      #[cfg(feature = "ink")]
      pub fn group_of_agent(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::agent::AgentGroup>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 242u8, 55u8, 209u8, 95u8, 72u8, 97u8, 175u8, 60u8, 82u8, 212u8,
          93u8, 134u8, 226u8, 228u8, 249u8, 241u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Maps an `AssetId` to the number of `Full` agents for it."]
      #[cfg(not(feature = "ink"))]
      pub async fn num_full_agents(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 73u8, 199u8, 126u8, 22u8, 129u8, 58u8, 64u8, 117u8, 2u8, 182u8,
          198u8, 217u8, 175u8, 14u8, 213u8, 191u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps an `AssetId` to the number of `Full` agents for it."]
      #[cfg(feature = "ink")]
      pub fn num_full_agents(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 73u8, 199u8, 126u8, 22u8, 129u8, 58u8, 64u8, 117u8, 2u8, 182u8,
          198u8, 217u8, 175u8, 14u8, 213u8, 191u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " For custom AGs of an `AssetId`, maps to what permissions an agent in that AG would have."]
      #[cfg(not(feature = "ink"))]
      pub async fn group_permissions(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::agent::AGId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::secondary_key::ExtrinsicPermissions>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 228u8, 175u8, 240u8, 58u8, 197u8, 94u8, 151u8, 139u8, 185u8, 101u8,
          37u8, 225u8, 222u8, 165u8, 102u8, 172u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " For custom AGs of an `AssetId`, maps to what permissions an agent in that AG would have."]
      #[cfg(feature = "ink")]
      pub fn group_permissions(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::agent::AGId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::secondary_key::ExtrinsicPermissions>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 228u8, 175u8, 240u8, 58u8, 197u8, 94u8, 151u8, 139u8, 185u8, 101u8,
          37u8, 225u8, 222u8, 165u8, 102u8, 172u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_external_agents::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_external_agents::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_external_agents::Version> {
        let value = self.api.read_storage(::alloc::vec![
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_external_agents::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct ExternalAgentsPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> ExternalAgentsPagedQueryApi<'api> {
      #[doc = " The next per-asset AG ID in the sequence."]
      #[doc = ""]
      #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence,"]
      #[doc = " which starts from 1, rather than 0."]
      pub fn ag_id_sequence(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::polymesh_primitives::agent::AGId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 12u8, 233u8, 200u8, 225u8, 173u8, 92u8, 11u8, 5u8, 96u8, 24u8,
          174u8, 23u8, 140u8, 103u8, 130u8, 219u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Maps an agent (`IdentityId`) to all assets they belong to, if any."]
      pub fn agent_of(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, ()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 53u8, 162u8, 207u8, 202u8, 92u8, 195u8, 4u8, 152u8, 44u8, 119u8,
          99u8, 8u8, 91u8, 94u8, 104u8, 181u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Maps agents (`IdentityId`) for an `AssetId` to what AG they belong to, if any."]
      pub fn group_of_agent(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::IdentityId,
        types::polymesh_primitives::agent::AgentGroup,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 242u8, 55u8, 209u8, 95u8, 72u8, 97u8, 175u8, 60u8, 82u8, 212u8,
          93u8, 134u8, 226u8, 228u8, 249u8, 241u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Maps an `AssetId` to the number of `Full` agents for it."]
      pub fn num_full_agents(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 73u8, 199u8, 126u8, 22u8, 129u8, 58u8, 64u8, 117u8, 2u8, 182u8,
          198u8, 217u8, 175u8, 14u8, 213u8, 191u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " For custom AGs of an `AssetId`, maps to what permissions an agent in that AG would have."]
      pub fn group_permissions(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::agent::AGId,
        types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 228u8, 175u8, 240u8, 58u8, 197u8, 94u8, 151u8, 139u8, 185u8, 101u8,
          37u8, 225u8, 222u8, 165u8, 102u8, 172u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod relayer {
    use super::*;
    #[derive(Clone)]
    pub struct RelayerCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> RelayerCallApi<'api> {
      #[doc = "Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to subsidise."]
      #[doc = "- `polyx_limit` the initial POLYX limit for this subsidy."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(not(feature = "ink"))]
      pub fn set_paying_key(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::set_paying_key {
            user_key,
            polyx_limit,
          },
        ))
      }
      #[doc = "Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to subsidise."]
      #[doc = "- `polyx_limit` the initial POLYX limit for this subsidy."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(feature = "ink")]
      pub fn set_paying_key(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 0u8];
        user_key.encode_to(&mut buf);
        polyx_limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accepts a `paying_key` authorization."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` the authorization id to accept a `paying_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` the authorization has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not a `AddRelayerPayingKey` authorization."]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`."]
      #[doc = "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity."]
      #[doc = "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity."]
      #[doc = "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(not(feature = "ink"))]
      pub fn accept_paying_key(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::accept_paying_key { auth_id },
        ))
      }
      #[doc = "Accepts a `paying_key` authorization."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` the authorization id to accept a `paying_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` the authorization has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not a `AddRelayerPayingKey` authorization."]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`."]
      #[doc = "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity."]
      #[doc = "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity."]
      #[doc = "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(feature = "ink")]
      pub fn accept_paying_key(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 1u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the `paying_key` from a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to remove the subsidy from."]
      #[doc = "- `paying_key` the paying key that was subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`."]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_paying_key(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        paying_key: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::remove_paying_key {
            user_key,
            paying_key,
          },
        ))
      }
      #[doc = "Removes the `paying_key` from a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to remove the subsidy from."]
      #[doc = "- `paying_key` the paying key that was subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`."]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(feature = "ink")]
      pub fn remove_paying_key(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        paying_key: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 2u8];
        user_key.encode_to(&mut buf);
        paying_key.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(not(feature = "ink"))]
      pub fn update_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::update_polyx_limit {
            user_key,
            polyx_limit,
          },
        ))
      }
      #[doc = "Updates the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(feature = "ink")]
      pub fn update_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 3u8];
        user_key.encode_to(&mut buf);
        polyx_limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Increase the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to add to the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`."]
      #[cfg(not(feature = "ink"))]
      pub fn increase_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::increase_polyx_limit { user_key, amount },
        ))
      }
      #[doc = "Increase the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to add to the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`."]
      #[cfg(feature = "ink")]
      pub fn increase_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 4u8];
        user_key.encode_to(&mut buf);
        amount.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Decrease the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to remove from the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy has less then `amount` POLYX remaining."]
      #[cfg(not(feature = "ink"))]
      pub fn decrease_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::decrease_polyx_limit { user_key, amount },
        ))
      }
      #[doc = "Decrease the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to remove from the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy has less then `amount` POLYX remaining."]
      #[cfg(feature = "ink")]
      pub fn decrease_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 5u8];
        user_key.encode_to(&mut buf);
        amount.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for RelayerCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct RelayerQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> RelayerQueryApi<'api> {
      #[doc = " The subsidy for a `user_key` if they are being subsidised,"]
      #[doc = " as a map `user_key` => `Subsidy`."]
      #[doc = ""]
      #[doc = " A key can only have one subsidy at a time.  To change subsidisers"]
      #[doc = " a key needs to call `remove_paying_key` to remove the current subsidy,"]
      #[doc = " before they can accept a new subsidiser."]
      #[cfg(not(feature = "ink"))]
      pub async fn subsidies(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_relayer::Subsidy<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          5u8, 71u8, 187u8, 31u8, 121u8, 115u8, 160u8, 127u8, 217u8, 78u8, 1u8, 160u8, 208u8,
          220u8, 209u8, 106u8, 75u8, 74u8, 110u8, 95u8, 140u8, 115u8, 246u8, 81u8, 202u8, 177u8,
          63u8, 253u8, 143u8, 76u8, 227u8, 53u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The subsidy for a `user_key` if they are being subsidised,"]
      #[doc = " as a map `user_key` => `Subsidy`."]
      #[doc = ""]
      #[doc = " A key can only have one subsidy at a time.  To change subsidisers"]
      #[doc = " a key needs to call `remove_paying_key` to remove the current subsidy,"]
      #[doc = " before they can accept a new subsidiser."]
      #[cfg(feature = "ink")]
      pub fn subsidies(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_relayer::Subsidy<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          5u8, 71u8, 187u8, 31u8, 121u8, 115u8, 160u8, 127u8, 217u8, 78u8, 1u8, 160u8, 208u8,
          220u8, 209u8, 106u8, 75u8, 74u8, 110u8, 95u8, 140u8, 115u8, 246u8, 81u8, 202u8, 177u8,
          63u8, 253u8, 143u8, 76u8, 227u8, 53u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct RelayerPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> RelayerPagedQueryApi<'api> {
      #[doc = " The subsidy for a `user_key` if they are being subsidised,"]
      #[doc = " as a map `user_key` => `Subsidy`."]
      #[doc = ""]
      #[doc = " A key can only have one subsidy at a time.  To change subsidisers"]
      #[doc = " a key needs to call `remove_paying_key` to remove the current subsidy,"]
      #[doc = " before they can accept a new subsidiser."]
      pub fn subsidies(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_relayer::Subsidy<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          5u8, 71u8, 187u8, 31u8, 121u8, 115u8, 160u8, 127u8, 217u8, 78u8, 1u8, 160u8, 208u8,
          220u8, 209u8, 106u8, 75u8, 74u8, 110u8, 95u8, 140u8, 115u8, 246u8, 81u8, 202u8, 177u8,
          63u8, 253u8, 143u8, 76u8, 227u8, 53u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
    }
  }
  pub mod contracts {
    use super::*;
    #[derive(Clone)]
    pub struct ContractsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ContractsCallApi<'api> {
      #[doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."]
      #[cfg(not(feature = "ink"))]
      pub fn call_old_weight(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        gas_limit: ::polymesh_api_client::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        data: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::call_old_weight {
            dest,
            value,
            gas_limit,
            storage_deposit_limit,
            data,
          },
        ))
      }
      #[doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."]
      #[cfg(feature = "ink")]
      pub fn call_old_weight(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        gas_limit: ::polymesh_api_client::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        data: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 0u8];
        dest.encode_to(&mut buf);
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        data.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_with_code_old_weight(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::instantiate_with_code_old_weight {
            value,
            gas_limit,
            storage_deposit_limit,
            code,
            data,
            salt,
          },
        ))
      }
      #[doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."]
      #[cfg(feature = "ink")]
      pub fn instantiate_with_code_old_weight(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 1u8];
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_old_weight(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::instantiate_old_weight {
            value,
            gas_limit,
            storage_deposit_limit,
            code_hash,
            data,
            salt,
          },
        ))
      }
      #[doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."]
      #[cfg(feature = "ink")]
      pub fn instantiate_old_weight(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 2u8];
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code_hash.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Upload new `code` without instantiating a contract from it."]
      #[doc = ""]
      #[doc = "If the code does not already exist a deposit is reserved from the caller"]
      #[doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"]
      #[doc = "depends on the instrumented size of the the supplied `code`."]
      #[doc = ""]
      #[doc = "If the code already exists in storage it will still return `Ok` and upgrades"]
      #[doc = "the in storage version to the current"]
      #[doc = "[`InstructionWeights::version`](InstructionWeights)."]
      #[doc = ""]
      #[doc = "- `determinism`: If this is set to any other value but [`Determinism::Deterministic`]"]
      #[doc = "  then the only way to use this code is to delegate call into it from an offchain"]
      #[doc = "  execution. Set to [`Determinism::Deterministic`] if in doubt."]
      #[doc = ""]
      #[doc = "# Note"]
      #[doc = ""]
      #[doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."]
      #[doc = "To avoid this situation a constructor could employ access control so that it can"]
      #[doc = "only be instantiated by permissioned entities. The same is true when uploading"]
      #[doc = "through [`Self::instantiate_with_code`]."]
      #[cfg(not(feature = "ink"))]
      pub fn upload_code(
        &self,
        code: ::alloc::vec::Vec<u8>,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        determinism: types::pallet_contracts::wasm::Determinism,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::upload_code {
            code,
            storage_deposit_limit,
            determinism,
          },
        ))
      }
      #[doc = "Upload new `code` without instantiating a contract from it."]
      #[doc = ""]
      #[doc = "If the code does not already exist a deposit is reserved from the caller"]
      #[doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"]
      #[doc = "depends on the instrumented size of the the supplied `code`."]
      #[doc = ""]
      #[doc = "If the code already exists in storage it will still return `Ok` and upgrades"]
      #[doc = "the in storage version to the current"]
      #[doc = "[`InstructionWeights::version`](InstructionWeights)."]
      #[doc = ""]
      #[doc = "- `determinism`: If this is set to any other value but [`Determinism::Deterministic`]"]
      #[doc = "  then the only way to use this code is to delegate call into it from an offchain"]
      #[doc = "  execution. Set to [`Determinism::Deterministic`] if in doubt."]
      #[doc = ""]
      #[doc = "# Note"]
      #[doc = ""]
      #[doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."]
      #[doc = "To avoid this situation a constructor could employ access control so that it can"]
      #[doc = "only be instantiated by permissioned entities. The same is true when uploading"]
      #[doc = "through [`Self::instantiate_with_code`]."]
      #[cfg(feature = "ink")]
      pub fn upload_code(
        &self,
        code: ::alloc::vec::Vec<u8>,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        determinism: types::pallet_contracts::wasm::Determinism,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 3u8];
        code.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        determinism.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."]
      #[doc = ""]
      #[doc = "A code can only be removed by its original uploader (its owner) and only if it is"]
      #[doc = "not used by any contract."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_code(
        &self,
        code_hash: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::remove_code { code_hash },
        ))
      }
      #[doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."]
      #[doc = ""]
      #[doc = "A code can only be removed by its original uploader (its owner) and only if it is"]
      #[doc = "not used by any contract."]
      #[cfg(feature = "ink")]
      pub fn remove_code(
        &self,
        code_hash: types::primitive_types::H256,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 4u8];
        code_hash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Privileged function that changes the code of an existing contract."]
      #[doc = ""]
      #[doc = "This takes care of updating refcounts and all other necessary operations. Returns"]
      #[doc = "an error if either the `code_hash` or `dest` do not exist."]
      #[doc = ""]
      #[doc = "# Note"]
      #[doc = ""]
      #[doc = "This does **not** change the address of the contract in question. This means"]
      #[doc = "that the contract address is no longer derived from its code hash after calling"]
      #[doc = "this dispatchable."]
      #[cfg(not(feature = "ink"))]
      pub fn set_code(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        code_hash: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::set_code { dest, code_hash },
        ))
      }
      #[doc = "Privileged function that changes the code of an existing contract."]
      #[doc = ""]
      #[doc = "This takes care of updating refcounts and all other necessary operations. Returns"]
      #[doc = "an error if either the `code_hash` or `dest` do not exist."]
      #[doc = ""]
      #[doc = "# Note"]
      #[doc = ""]
      #[doc = "This does **not** change the address of the contract in question. This means"]
      #[doc = "that the contract address is no longer derived from its code hash after calling"]
      #[doc = "this dispatchable."]
      #[cfg(feature = "ink")]
      pub fn set_code(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        code_hash: types::primitive_types::H256,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 5u8];
        dest.encode_to(&mut buf);
        code_hash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Makes a call to an account, optionally transferring some balance."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = ""]
      #[doc = "* `dest`: Address of the contract to call."]
      #[doc = "* `value`: The balance to transfer from the `origin` to `dest`."]
      #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
      #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"]
      #[doc = "  caller to pay for the storage consumed."]
      #[doc = "* `data`: The input data to pass to the contract."]
      #[doc = ""]
      #[doc = "* If the account is a smart-contract account, the associated code will be"]
      #[doc = "executed and any value will be transferred."]
      #[doc = "* If the account is a regular account, any value will be transferred."]
      #[doc = "* If no account exists and the call value is not less than `existential_deposit`,"]
      #[doc = "a regular account will be created and any value will be transferred."]
      #[cfg(not(feature = "ink"))]
      pub fn call(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        data: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::call {
            dest,
            value,
            gas_limit,
            storage_deposit_limit,
            data,
          },
        ))
      }
      #[doc = "Makes a call to an account, optionally transferring some balance."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = ""]
      #[doc = "* `dest`: Address of the contract to call."]
      #[doc = "* `value`: The balance to transfer from the `origin` to `dest`."]
      #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
      #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"]
      #[doc = "  caller to pay for the storage consumed."]
      #[doc = "* `data`: The input data to pass to the contract."]
      #[doc = ""]
      #[doc = "* If the account is a smart-contract account, the associated code will be"]
      #[doc = "executed and any value will be transferred."]
      #[doc = "* If the account is a regular account, any value will be transferred."]
      #[doc = "* If no account exists and the call value is not less than `existential_deposit`,"]
      #[doc = "a regular account will be created and any value will be transferred."]
      #[cfg(feature = "ink")]
      pub fn call(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        data: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 6u8];
        dest.encode_to(&mut buf);
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        data.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Instantiates a new contract from the supplied `code` optionally transferring"]
      #[doc = "some balance."]
      #[doc = ""]
      #[doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"]
      #[doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"]
      #[doc = "also check the documentation of [`Self::upload_code`]."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = ""]
      #[doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."]
      #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
      #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "* `code`: The contract code to deploy in raw bytes."]
      #[doc = "* `data`: The input data to pass to the contract constructor."]
      #[doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."]
      #[doc = ""]
      #[doc = "Instantiation is executed as follows:"]
      #[doc = ""]
      #[doc = "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that"]
      #[doc = "  code."]
      #[doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."]
      #[doc = "- The destination address is computed based on the sender, code_hash and the salt."]
      #[doc = "- The smart-contract account is created at the computed address."]
      #[doc = "- The `value` is transferred to the new account."]
      #[doc = "- The `deploy` function is executed in the context of the newly-created account."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_with_code(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::instantiate_with_code {
            value,
            gas_limit,
            storage_deposit_limit,
            code,
            data,
            salt,
          },
        ))
      }
      #[doc = "Instantiates a new contract from the supplied `code` optionally transferring"]
      #[doc = "some balance."]
      #[doc = ""]
      #[doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"]
      #[doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"]
      #[doc = "also check the documentation of [`Self::upload_code`]."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = ""]
      #[doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."]
      #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
      #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "* `code`: The contract code to deploy in raw bytes."]
      #[doc = "* `data`: The input data to pass to the contract constructor."]
      #[doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."]
      #[doc = ""]
      #[doc = "Instantiation is executed as follows:"]
      #[doc = ""]
      #[doc = "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that"]
      #[doc = "  code."]
      #[doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."]
      #[doc = "- The destination address is computed based on the sender, code_hash and the salt."]
      #[doc = "- The smart-contract account is created at the computed address."]
      #[doc = "- The `value` is transferred to the new account."]
      #[doc = "- The `deploy` function is executed in the context of the newly-created account."]
      #[cfg(feature = "ink")]
      pub fn instantiate_with_code(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 7u8];
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Instantiates a contract from a previously deployed wasm binary."]
      #[doc = ""]
      #[doc = "This function is identical to [`Self::instantiate_with_code`] but without the"]
      #[doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"]
      #[doc = "must be supplied."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::instantiate {
            value,
            gas_limit,
            storage_deposit_limit,
            code_hash,
            data,
            salt,
          },
        ))
      }
      #[doc = "Instantiates a contract from a previously deployed wasm binary."]
      #[doc = ""]
      #[doc = "This function is identical to [`Self::instantiate_with_code`] but without the"]
      #[doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"]
      #[doc = "must be supplied."]
      #[cfg(feature = "ink")]
      pub fn instantiate(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 8u8];
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code_hash.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ContractsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ContractsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ContractsQueryApi<'api> {
      #[doc = " A mapping from an original code hash to the original code, untouched by instrumentation."]
      #[cfg(not(feature = "ink"))]
      pub async fn pristine_code(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<::alloc::vec::Vec<u8>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 77u8, 108u8, 43u8, 3u8, 185u8, 0u8, 40u8, 243u8, 191u8, 64u8, 126u8,
          180u8, 51u8, 233u8, 99u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A mapping from an original code hash to the original code, untouched by instrumentation."]
      #[cfg(feature = "ink")]
      pub fn pristine_code(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<::alloc::vec::Vec<u8>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 77u8, 108u8, 43u8, 3u8, 185u8, 0u8, 40u8, 243u8, 191u8, 64u8, 126u8,
          180u8, 51u8, 233u8, 99u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A mapping between an original code hash and instrumented wasm code, ready for execution."]
      #[cfg(not(feature = "ink"))]
      pub async fn code_storage(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_contracts::wasm::PrefabWasmModule>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 34u8, 252u8, 169u8, 6u8, 17u8, 186u8, 139u8, 121u8, 66u8, 248u8,
          189u8, 179u8, 185u8, 127u8, 101u8, 128u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A mapping between an original code hash and instrumented wasm code, ready for execution."]
      #[cfg(feature = "ink")]
      pub fn code_storage(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_contracts::wasm::PrefabWasmModule>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 34u8, 252u8, 169u8, 6u8, 17u8, 186u8, 139u8, 121u8, 66u8, 248u8,
          189u8, 179u8, 185u8, 127u8, 101u8, 128u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A mapping between an original code hash and its owner information."]
      #[cfg(not(feature = "ink"))]
      pub async fn owner_info_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_contracts::wasm::OwnerInfo>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 83u8, 241u8, 63u8, 211u8, 25u8, 160u8, 60u8, 33u8, 19u8, 55u8, 199u8,
          110u8, 15u8, 231u8, 118u8, 223u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A mapping between an original code hash and its owner information."]
      #[cfg(feature = "ink")]
      pub fn owner_info_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_contracts::wasm::OwnerInfo>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 83u8, 241u8, 63u8, 211u8, 25u8, 160u8, 60u8, 33u8, 19u8, 55u8, 199u8,
          110u8, 15u8, 231u8, 118u8, 223u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " This is a **monotonic** counter incremented on contract instantiation."]
      #[doc = ""]
      #[doc = " This is used in order to generate unique trie ids for contracts."]
      #[doc = " The trie id of a new contract is calculated from hash(account_id, nonce)."]
      #[doc = " The nonce is required because otherwise the following sequence would lead to"]
      #[doc = " a possible collision of storage:"]
      #[doc = ""]
      #[doc = " 1. Create a new contract."]
      #[doc = " 2. Terminate the contract."]
      #[doc = " 3. Immediately recreate the contract with the same account_id."]
      #[doc = ""]
      #[doc = " This is bad because the contents of a trie are deleted lazily and there might be"]
      #[doc = " storage of the old instantiation still in it when the new contract is created. Please"]
      #[doc = " note that we can't replace the counter by the block number because the sequence above"]
      #[doc = " can happen in the same block. We also can't keep the account counter in memory only"]
      #[doc = " because storage is the only way to communicate across different extrinsics in the"]
      #[doc = " same block."]
      #[doc = ""]
      #[doc = " # Note"]
      #[doc = ""]
      #[doc = " Do not use it to determine the number of contracts. It won't be decremented if"]
      #[doc = " a contract is destroyed."]
      #[cfg(not(feature = "ink"))]
      pub async fn nonce(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 113u8, 131u8, 104u8, 160u8, 172u8, 227u8, 110u8, 43u8, 27u8, 139u8,
          109u8, 189u8, 127u8, 128u8, 147u8, 192u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " This is a **monotonic** counter incremented on contract instantiation."]
      #[doc = ""]
      #[doc = " This is used in order to generate unique trie ids for contracts."]
      #[doc = " The trie id of a new contract is calculated from hash(account_id, nonce)."]
      #[doc = " The nonce is required because otherwise the following sequence would lead to"]
      #[doc = " a possible collision of storage:"]
      #[doc = ""]
      #[doc = " 1. Create a new contract."]
      #[doc = " 2. Terminate the contract."]
      #[doc = " 3. Immediately recreate the contract with the same account_id."]
      #[doc = ""]
      #[doc = " This is bad because the contents of a trie are deleted lazily and there might be"]
      #[doc = " storage of the old instantiation still in it when the new contract is created. Please"]
      #[doc = " note that we can't replace the counter by the block number because the sequence above"]
      #[doc = " can happen in the same block. We also can't keep the account counter in memory only"]
      #[doc = " because storage is the only way to communicate across different extrinsics in the"]
      #[doc = " same block."]
      #[doc = ""]
      #[doc = " # Note"]
      #[doc = ""]
      #[doc = " Do not use it to determine the number of contracts. It won't be decremented if"]
      #[doc = " a contract is destroyed."]
      #[cfg(feature = "ink")]
      pub fn nonce(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 113u8, 131u8, 104u8, 160u8, 172u8, 227u8, 110u8, 43u8, 27u8, 139u8,
          109u8, 189u8, 127u8, 128u8, 147u8, 192u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The code associated with a given account."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn contract_info_of(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_contracts::storage::ContractInfo>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 6u8, 14u8, 153u8, 229u8, 55u8, 142u8, 86u8, 37u8, 55u8, 207u8, 59u8,
          201u8, 131u8, 225u8, 123u8, 145u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The code associated with a given account."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(feature = "ink")]
      pub fn contract_info_of(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_contracts::storage::ContractInfo>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 6u8, 14u8, 153u8, 229u8, 55u8, 142u8, 86u8, 37u8, 55u8, 207u8, 59u8,
          201u8, 131u8, 225u8, 123u8, 145u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Evicted contracts that await child trie deletion."]
      #[doc = ""]
      #[doc = " Child trie deletion is a heavy operation depending on the amount of storage items"]
      #[doc = " stored in said trie. Therefore this operation is performed lazily in `on_initialize`."]
      #[cfg(not(feature = "ink"))]
      pub async fn deletion_queue(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::pallet_contracts::storage::DeletedContract>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 41u8, 22u8, 33u8, 17u8, 173u8, 25u8, 239u8, 20u8, 81u8, 85u8, 238u8,
          85u8, 42u8, 239u8, 45u8, 17u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_contracts::storage::DeletedContract>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Evicted contracts that await child trie deletion."]
      #[doc = ""]
      #[doc = " Child trie deletion is a heavy operation depending on the amount of storage items"]
      #[doc = " stored in said trie. Therefore this operation is performed lazily in `on_initialize`."]
      #[cfg(feature = "ink")]
      pub fn deletion_queue(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::pallet_contracts::storage::DeletedContract>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 41u8, 22u8, 33u8, 17u8, 173u8, 25u8, 239u8, 20u8, 81u8, 85u8, 238u8,
          85u8, 42u8, 239u8, 45u8, 17u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_contracts::storage::DeletedContract>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct ContractsPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> ContractsPagedQueryApi<'api> {
      #[doc = " A mapping from an original code hash to the original code, untouched by instrumentation."]
      pub fn pristine_code(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<types::primitive_types::H256, ::alloc::vec::Vec<u8>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 77u8, 108u8, 43u8, 3u8, 185u8, 0u8, 40u8, 243u8, 191u8, 64u8, 126u8,
          180u8, 51u8, 233u8, 99u8, 137u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " A mapping between an original code hash and instrumented wasm code, ready for execution."]
      pub fn code_storage(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::primitive_types::H256,
        types::pallet_contracts::wasm::PrefabWasmModule,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 34u8, 252u8, 169u8, 6u8, 17u8, 186u8, 139u8, 121u8, 66u8, 248u8,
          189u8, 179u8, 185u8, 127u8, 101u8, 128u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " A mapping between an original code hash and its owner information."]
      pub fn owner_info_of(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::primitive_types::H256,
        types::pallet_contracts::wasm::OwnerInfo,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 83u8, 241u8, 63u8, 211u8, 25u8, 160u8, 60u8, 33u8, 19u8, 55u8, 199u8,
          110u8, 15u8, 231u8, 118u8, 223u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " The code associated with a given account."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      pub fn contract_info_of(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AccountId,
        types::pallet_contracts::storage::ContractInfo,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 6u8, 14u8, 153u8, 229u8, 55u8, 142u8, 86u8, 37u8, 55u8, 207u8, 59u8,
          201u8, 131u8, 225u8, 123u8, 145u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod polymesh_contracts {
    use super::*;
    #[derive(Clone)]
    pub struct PolymeshContractsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PolymeshContractsCallApi<'api> {
      #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code` with the WASM binary defining the smart contract."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_with_code_perms(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshContracts(
          types::polymesh_contracts::PolymeshContractsCall::instantiate_with_code_perms {
            endowment,
            gas_limit,
            storage_deposit_limit,
            code,
            data,
            salt,
            perms,
          },
        ))
      }
      #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code` with the WASM binary defining the smart contract."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[cfg(feature = "ink")]
      pub fn instantiate_with_code_perms(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![47u8, 0u8];
        endowment.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
      #[doc = ""]
      #[doc = "Unlike `instantiate_with_code`,"]
      #[doc = "this assumes that at least one contract with the same WASM code has already been uploaded."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code_hash` of an already uploaded WASM binary."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_with_hash_perms(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshContracts(
          types::polymesh_contracts::PolymeshContractsCall::instantiate_with_hash_perms {
            endowment,
            gas_limit,
            storage_deposit_limit,
            code_hash,
            data,
            salt,
            perms,
          },
        ))
      }
      #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
      #[doc = ""]
      #[doc = "Unlike `instantiate_with_code`,"]
      #[doc = "this assumes that at least one contract with the same WASM code has already been uploaded."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code_hash` of an already uploaded WASM binary."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[cfg(feature = "ink")]
      pub fn instantiate_with_hash_perms(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![47u8, 1u8];
        endowment.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code_hash.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Update CallRuntime whitelist."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = ""]
      #[doc = "# Errors"]
      #[cfg(not(feature = "ink"))]
      pub fn update_call_runtime_whitelist(
        &self,
        updates: ::alloc::vec::Vec<(
          types::polymesh_contracts::chain_extension::ExtrinsicId,
          bool,
        )>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshContracts(
          types::polymesh_contracts::PolymeshContractsCall::update_call_runtime_whitelist {
            updates,
          },
        ))
      }
      #[doc = "Update CallRuntime whitelist."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = ""]
      #[doc = "# Errors"]
      #[cfg(feature = "ink")]
      pub fn update_call_runtime_whitelist(
        &self,
        updates: ::alloc::vec::Vec<(
          types::polymesh_contracts::chain_extension::ExtrinsicId,
          bool,
        )>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![47u8, 2u8];
        updates.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
      #[doc = ""]
      #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment`: Amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit`: For how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
      #[doc = "- `code`: The WASM binary defining the smart contract."]
      #[doc = "- `data`: The input data to pass to the contract constructor."]
      #[doc = "- `salt`: Used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_with_code_as_primary_key(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshContracts(
          types::polymesh_contracts::PolymeshContractsCall::instantiate_with_code_as_primary_key {
            endowment,
            gas_limit,
            storage_deposit_limit,
            code,
            data,
            salt,
          },
        ))
      }
      #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
      #[doc = ""]
      #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment`: Amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit`: For how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
      #[doc = "- `code`: The WASM binary defining the smart contract."]
      #[doc = "- `data`: The input data to pass to the contract constructor."]
      #[doc = "- `salt`: Used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn instantiate_with_code_as_primary_key(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![47u8, 3u8];
        endowment.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
      #[doc = ""]
      #[doc = "Unlike `instantiate_with_code`, this assumes that at least one contract with the same WASM code has already been uploaded."]
      #[doc = ""]
      #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment`: amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit`: for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
      #[doc = "- `code_hash`: of an already uploaded WASM binary."]
      #[doc = "- `data`: The input data to pass to the contract constructor."]
      #[doc = "- `salt`: used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_with_hash_as_primary_key(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshContracts(
          types::polymesh_contracts::PolymeshContractsCall::instantiate_with_hash_as_primary_key {
            endowment,
            gas_limit,
            storage_deposit_limit,
            code_hash,
            data,
            salt,
          },
        ))
      }
      #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
      #[doc = ""]
      #[doc = "Unlike `instantiate_with_code`, this assumes that at least one contract with the same WASM code has already been uploaded."]
      #[doc = ""]
      #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment`: amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit`: for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
      #[doc = "- `code_hash`: of an already uploaded WASM binary."]
      #[doc = "- `data`: The input data to pass to the contract constructor."]
      #[doc = "- `salt`: used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn instantiate_with_hash_as_primary_key(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![47u8, 4u8];
        endowment.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code_hash.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[cfg(not(feature = "ink"))]
      pub fn upgrade_api(
        &self,
        api: types::polymesh_contracts::Api,
        next_upgrade: types::polymesh_contracts::NextUpgrade,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshContracts(
          types::polymesh_contracts::PolymeshContractsCall::upgrade_api { api, next_upgrade },
        ))
      }
      #[cfg(feature = "ink")]
      pub fn upgrade_api(
        &self,
        api: types::polymesh_contracts::Api,
        next_upgrade: types::polymesh_contracts::NextUpgrade,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![47u8, 5u8];
        api.encode_to(&mut buf);
        next_upgrade.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for PolymeshContractsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PolymeshContractsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PolymeshContractsQueryApi<'api> {
      #[doc = " Whitelist of extrinsics allowed to be called from contracts."]
      #[cfg(not(feature = "ink"))]
      pub async fn call_runtime_whitelist(
        &self,
        key_0: types::polymesh_contracts::chain_extension::ExtrinsicId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 18u8, 86u8, 78u8, 236u8, 93u8, 99u8, 65u8, 206u8, 211u8, 34u8, 76u8,
          171u8, 105u8, 214u8, 137u8, 42u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Whitelist of extrinsics allowed to be called from contracts."]
      #[cfg(feature = "ink")]
      pub fn call_runtime_whitelist(
        &self,
        key_0: types::polymesh_contracts::chain_extension::ExtrinsicId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 18u8, 86u8, 78u8, 236u8, 93u8, 99u8, 65u8, 206u8, 211u8, 34u8, 76u8,
          171u8, 105u8, 214u8, 137u8, 42u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_contracts::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_contracts::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_contracts::Version> {
        let value = self.api.read_storage(::alloc::vec![
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_contracts::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores the chain version and code hash for the next chain upgrade."]
      #[cfg(not(feature = "ink"))]
      pub async fn api_next_upgrade(
        &self,
        key_0: types::polymesh_contracts::Api,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_contracts::NextUpgrade>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 114u8, 234u8, 160u8, 152u8, 251u8, 78u8, 157u8, 47u8, 30u8, 165u8,
          58u8, 78u8, 190u8, 160u8, 122u8, 239u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Stores the chain version and code hash for the next chain upgrade."]
      #[cfg(feature = "ink")]
      pub fn api_next_upgrade(
        &self,
        key_0: types::polymesh_contracts::Api,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_contracts::NextUpgrade>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 114u8, 234u8, 160u8, 152u8, 251u8, 78u8, 157u8, 47u8, 30u8, 165u8,
          58u8, 78u8, 190u8, 160u8, 122u8, 239u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Stores the code hash for the current api."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_api_hash(
        &self,
        key_0: types::polymesh_contracts::Api,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_contracts::ApiCodeHash>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 179u8, 48u8, 43u8, 247u8, 216u8, 48u8, 112u8, 2u8, 78u8, 184u8, 137u8,
          253u8, 37u8, 61u8, 234u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Stores the code hash for the current api."]
      #[cfg(feature = "ink")]
      pub fn current_api_hash(
        &self,
        key_0: types::polymesh_contracts::Api,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_contracts::ApiCodeHash>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 179u8, 48u8, 43u8, 247u8, 216u8, 48u8, 112u8, 2u8, 78u8, 184u8, 137u8,
          253u8, 37u8, 61u8, 234u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct PolymeshContractsPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> PolymeshContractsPagedQueryApi<'api> {
      #[doc = " Whitelist of extrinsics allowed to be called from contracts."]
      pub fn call_runtime_whitelist(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_contracts::chain_extension::ExtrinsicId,
        bool,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 18u8, 86u8, 78u8, 236u8, 93u8, 99u8, 65u8, 206u8, 211u8, 34u8, 76u8,
          171u8, 105u8, 214u8, 137u8, 42u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " Stores the chain version and code hash for the next chain upgrade."]
      pub fn api_next_upgrade(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_contracts::Api,
        types::polymesh_contracts::NextUpgrade,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 114u8, 234u8, 160u8, 152u8, 251u8, 78u8, 157u8, 47u8, 30u8, 165u8,
          58u8, 78u8, 190u8, 160u8, 122u8, 239u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
      #[doc = " Stores the code hash for the current api."]
      pub fn current_api_hash(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_contracts::Api,
        types::polymesh_contracts::ApiCodeHash,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 179u8, 48u8, 43u8, 247u8, 216u8, 48u8, 112u8, 2u8, 78u8, 184u8, 137u8,
          253u8, 37u8, 61u8, 234u8, 27u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
  pub mod preimage {
    use super::*;
    #[derive(Clone)]
    pub struct PreimageCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PreimageCallApi<'api> {
      #[doc = "Register a preimage on-chain."]
      #[doc = ""]
      #[doc = "If the preimage was previously requested, no fees or deposits are taken for providing"]
      #[doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."]
      #[cfg(not(feature = "ink"))]
      pub fn note_preimage(
        &self,
        bytes: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Preimage(
          types::pallet_preimage::pallet::PreimageCall::note_preimage { bytes },
        ))
      }
      #[doc = "Register a preimage on-chain."]
      #[doc = ""]
      #[doc = "If the preimage was previously requested, no fees or deposits are taken for providing"]
      #[doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."]
      #[cfg(feature = "ink")]
      pub fn note_preimage(&self, bytes: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![48u8, 0u8];
        bytes.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Clear an unrequested preimage from the runtime storage."]
      #[doc = ""]
      #[doc = "If `len` is provided, then it will be a much cheaper operation."]
      #[doc = ""]
      #[doc = "- `hash`: The hash of the preimage to be removed from the store."]
      #[doc = "- `len`: The length of the preimage of `hash`."]
      #[cfg(not(feature = "ink"))]
      pub fn unnote_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Preimage(
          types::pallet_preimage::pallet::PreimageCall::unnote_preimage { hash },
        ))
      }
      #[doc = "Clear an unrequested preimage from the runtime storage."]
      #[doc = ""]
      #[doc = "If `len` is provided, then it will be a much cheaper operation."]
      #[doc = ""]
      #[doc = "- `hash`: The hash of the preimage to be removed from the store."]
      #[doc = "- `len`: The length of the preimage of `hash`."]
      #[cfg(feature = "ink")]
      pub fn unnote_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![48u8, 1u8];
        hash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."]
      #[doc = ""]
      #[doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"]
      #[doc = "a user may have paid, and take the control of the preimage out of their hands."]
      #[cfg(not(feature = "ink"))]
      pub fn request_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Preimage(
          types::pallet_preimage::pallet::PreimageCall::request_preimage { hash },
        ))
      }
      #[doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."]
      #[doc = ""]
      #[doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"]
      #[doc = "a user may have paid, and take the control of the preimage out of their hands."]
      #[cfg(feature = "ink")]
      pub fn request_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![48u8, 2u8];
        hash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Clear a previously made request for a preimage."]
      #[doc = ""]
      #[doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."]
      #[cfg(not(feature = "ink"))]
      pub fn unrequest_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Preimage(
          types::pallet_preimage::pallet::PreimageCall::unrequest_preimage { hash },
        ))
      }
      #[doc = "Clear a previously made request for a preimage."]
      #[doc = ""]
      #[doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."]
      #[cfg(feature = "ink")]
      pub fn unrequest_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![48u8, 3u8];
        hash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for PreimageCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PreimageQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PreimageQueryApi<'api> {
      #[doc = " The request status of a given hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn status_for(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_preimage::RequestStatus<::polymesh_api_client::AccountId, u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8, 70u8, 86u8,
          164u8, 72u8, 37u8, 85u8, 177u8, 174u8, 142u8, 206u8, 213u8, 82u8, 47u8, 60u8, 64u8, 73u8,
          188u8, 132u8, 237u8, 164u8, 168u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The request status of a given hash."]
      #[cfg(feature = "ink")]
      pub fn status_for(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_preimage::RequestStatus<::polymesh_api_client::AccountId, u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8, 70u8, 86u8,
          164u8, 72u8, 37u8, 85u8, 177u8, 174u8, 142u8, 206u8, 213u8, 82u8, 47u8, 60u8, 64u8, 73u8,
          188u8, 132u8, 237u8, 164u8, 168u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[cfg(not(feature = "ink"))]
      pub async fn preimage_for(
        &self,
        key_0: (types::primitive_types::H256, u32),
      ) -> ::polymesh_api_client::error::Result<Option<::alloc::vec::Vec<u8>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8, 70u8, 86u8,
          164u8, 72u8, 37u8, 124u8, 125u8, 218u8, 133u8, 201u8, 194u8, 151u8, 153u8, 159u8, 208u8,
          34u8, 21u8, 232u8, 200u8, 249u8, 222u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[cfg(feature = "ink")]
      pub fn preimage_for(
        &self,
        key_0: (types::primitive_types::H256, u32),
      ) -> ::polymesh_api_ink::error::Result<Option<::alloc::vec::Vec<u8>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8, 70u8, 86u8,
          164u8, 72u8, 37u8, 124u8, 125u8, 218u8, 133u8, 201u8, 194u8, 151u8, 153u8, 159u8, 208u8,
          34u8, 21u8, 232u8, 200u8, 249u8, 222u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct PreimagePagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> PreimagePagedQueryApi<'api> {
      #[doc = " The request status of a given hash."]
      pub fn status_for(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::primitive_types::H256,
        types::pallet_preimage::RequestStatus<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8, 70u8, 86u8,
          164u8, 72u8, 37u8, 85u8, 177u8, 174u8, 142u8, 206u8, 213u8, 82u8, 47u8, 60u8, 64u8, 73u8,
          188u8, 132u8, 237u8, 164u8, 168u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      pub fn preimage_for(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        (types::primitive_types::H256, u32),
        ::alloc::vec::Vec<u8>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8, 70u8, 86u8,
          164u8, 72u8, 37u8, 124u8, 125u8, 218u8, 133u8, 201u8, 194u8, 151u8, 153u8, 159u8, 208u8,
          34u8, 21u8, 232u8, 200u8, 249u8, 222u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
    }
  }
  pub mod nft {
    use super::*;
    #[derive(Clone)]
    pub struct NftCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> NftCallApi<'api> {
      #[doc = "Cretes a new `NFTCollection`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `asset_id` - optional [`AssetId`] associated to the new collection. `None` will create a new asset."]
      #[doc = "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type."]
      #[doc = "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionAlredyRegistered` - if the asset_id is already associated to an NFT collection."]
      #[doc = "- `InvalidAssetType` - if the associated asset is not of type NFT."]
      #[doc = "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed."]
      #[doc = "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn create_nft_collection(
        &self,
        asset_id: Option<::polymesh_api_client::AssetId>,
        nft_type: Option<types::polymesh_primitives::asset::NonFungibleType>,
        collection_keys: types::polymesh_primitives::nft::NFTCollectionKeys,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Nft(
          types::pallet_nft::NftCall::create_nft_collection {
            asset_id,
            nft_type,
            collection_keys,
          },
        ))
      }
      #[doc = "Cretes a new `NFTCollection`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `asset_id` - optional [`AssetId`] associated to the new collection. `None` will create a new asset."]
      #[doc = "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type."]
      #[doc = "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionAlredyRegistered` - if the asset_id is already associated to an NFT collection."]
      #[doc = "- `InvalidAssetType` - if the associated asset is not of type NFT."]
      #[doc = "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed."]
      #[doc = "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn create_nft_collection(
        &self,
        asset_id: Option<::polymesh_api_client::AssetId>,
        nft_type: Option<types::polymesh_primitives::asset::NonFungibleType>,
        collection_keys: types::polymesh_primitives::nft::NFTCollectionKeys,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![49u8, 0u8];
        asset_id.encode_to(&mut buf);
        nft_type.encode_to(&mut buf);
        collection_keys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Issues an NFT to the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
      #[doc = "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT."]
      #[doc = "- `portfolio_kind` - the portfolio that will receive the minted nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
      #[doc = "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn issue_nft(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        nft_metadata_attributes: ::alloc::vec::Vec<
          types::polymesh_primitives::nft::NFTMetadataAttribute,
        >,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Nft(
          types::pallet_nft::NftCall::issue_nft {
            asset_id,
            nft_metadata_attributes,
            portfolio_kind,
          },
        ))
      }
      #[doc = "Issues an NFT to the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
      #[doc = "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT."]
      #[doc = "- `portfolio_kind` - the portfolio that will receive the minted nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
      #[doc = "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn issue_nft(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        nft_metadata_attributes: ::alloc::vec::Vec<
          types::polymesh_primitives::nft::NFTMetadataAttribute,
        >,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![49u8, 1u8];
        asset_id.encode_to(&mut buf);
        nft_metadata_attributes.encode_to(&mut buf);
        portfolio_kind.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Redeems the given NFT from the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
      #[doc = "* `nft_id` - the id of the NFT to be burned."]
      #[doc = "* `portfolio_kind` - the portfolio that contains the nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
      #[doc = "- `NFTNotFound` - if the given NFT does not exist in the portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn redeem_nft(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        nft_id: types::polymesh_primitives::nft::NFTId,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
        number_of_keys: Option<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Nft(
          types::pallet_nft::NftCall::redeem_nft {
            asset_id,
            nft_id,
            portfolio_kind,
            number_of_keys,
          },
        ))
      }
      #[doc = "Redeems the given NFT from the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
      #[doc = "* `nft_id` - the id of the NFT to be burned."]
      #[doc = "* `portfolio_kind` - the portfolio that contains the nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
      #[doc = "- `NFTNotFound` - if the given NFT does not exist in the portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn redeem_nft(
        &self,
        asset_id: ::polymesh_api_client::AssetId,
        nft_id: types::polymesh_primitives::nft::NFTId,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
        number_of_keys: Option<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![49u8, 2u8];
        asset_id.encode_to(&mut buf);
        nft_id.encode_to(&mut buf);
        portfolio_kind.encode_to(&mut buf);
        number_of_keys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Forces the transfer of NFTs from a given portfolio to the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `nft_id` - the [`NFTId`] of the NFT to be transferred."]
      #[doc = "* `source_portfolio` - the [`PortfolioId`] that currently holds the NFT."]
      #[doc = "* `callers_portfolio_kind` - the [`PortfolioKind`] of the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn controller_transfer(
        &self,
        nfts: types::polymesh_primitives::nft::NFTs,
        source_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        callers_portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Nft(
          types::pallet_nft::NftCall::controller_transfer {
            nfts,
            source_portfolio,
            callers_portfolio_kind,
          },
        ))
      }
      #[doc = "Forces the transfer of NFTs from a given portfolio to the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
      #[doc = "* `nft_id` - the [`NFTId`] of the NFT to be transferred."]
      #[doc = "* `source_portfolio` - the [`PortfolioId`] that currently holds the NFT."]
      #[doc = "* `callers_portfolio_kind` - the [`PortfolioKind`] of the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn controller_transfer(
        &self,
        nfts: types::polymesh_primitives::nft::NFTs,
        source_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        callers_portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![49u8, 3u8];
        nfts.encode_to(&mut buf);
        source_portfolio.encode_to(&mut buf);
        callers_portfolio_kind.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for NftCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct NftQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> NftQueryApi<'api> {
      #[doc = " The total number of NFTs per identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn number_of_nf_ts(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 170u8, 210u8, 252u8, 218u8, 7u8, 81u8, 234u8, 12u8, 131u8, 54u8,
          33u8, 16u8, 193u8, 164u8, 16u8, 164u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total number of NFTs per identity."]
      #[cfg(feature = "ink")]
      pub fn number_of_nf_ts(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 170u8, 210u8, 252u8, 218u8, 7u8, 81u8, 234u8, 12u8, 131u8, 54u8,
          33u8, 16u8, 193u8, 164u8, 16u8, 164u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The collection id corresponding to each asset."]
      #[cfg(not(feature = "ink"))]
      pub async fn collection_asset(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::nft::NFTCollectionId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 42u8, 68u8, 186u8, 69u8, 7u8, 24u8, 71u8, 138u8, 166u8, 31u8, 83u8,
          159u8, 177u8, 242u8, 13u8, 1u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::nft::NFTCollectionId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The collection id corresponding to each asset."]
      #[cfg(feature = "ink")]
      pub fn collection_asset(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::nft::NFTCollectionId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 42u8, 68u8, 186u8, 69u8, 7u8, 24u8, 71u8, 138u8, 166u8, 31u8, 83u8,
          159u8, 177u8, 242u8, 13u8, 1u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::nft::NFTCollectionId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All collection details for a given collection id."]
      #[cfg(not(feature = "ink"))]
      pub async fn collection(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::nft::NFTCollection>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 55u8, 92u8, 77u8, 37u8, 190u8, 245u8, 30u8, 47u8, 50u8, 254u8,
          233u8, 252u8, 85u8, 123u8, 24u8, 32u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::nft::NFTCollection>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All collection details for a given collection id."]
      #[cfg(feature = "ink")]
      pub fn collection(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::nft::NFTCollection> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 55u8, 92u8, 77u8, 37u8, 190u8, 245u8, 30u8, 47u8, 50u8, 254u8,
          233u8, 252u8, 85u8, 123u8, 24u8, 32u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::nft::NFTCollection>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All mandatory metadata keys for a given collection."]
      #[cfg(not(feature = "ink"))]
      pub async fn collection_keys(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::collections::BTreeSet<
          types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 240u8, 0u8, 218u8, 102u8, 211u8, 19u8, 174u8, 223u8, 42u8, 70u8,
          29u8, 80u8, 78u8, 220u8, 122u8, 141u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::collections::BTreeSet<
            types::polymesh_primitives::asset_metadata::AssetMetadataKey,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " All mandatory metadata keys for a given collection."]
      #[cfg(feature = "ink")]
      pub fn collection_keys(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::collections::BTreeSet<
          types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 240u8, 0u8, 218u8, 102u8, 211u8, 19u8, 174u8, 223u8, 42u8, 70u8,
          29u8, 80u8, 78u8, 220u8, 122u8, 141u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::collections::BTreeSet<
            types::polymesh_primitives::asset_metadata::AssetMetadataKey,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The metadata value of an nft given its collection id, token id and metadata key."]
      #[cfg(not(feature = "ink"))]
      pub async fn metadata_value(
        &self,
        key_0: (
          types::polymesh_primitives::nft::NFTCollectionId,
          types::polymesh_primitives::nft::NFTId,
        ),
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::asset_metadata::AssetMetadataValue,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 60u8, 250u8, 177u8, 34u8, 185u8, 246u8, 58u8, 62u8, 106u8, 129u8,
          169u8, 121u8, 18u8, 218u8, 95u8, 196u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::asset_metadata::AssetMetadataValue>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The metadata value of an nft given its collection id, token id and metadata key."]
      #[cfg(feature = "ink")]
      pub fn metadata_value(
        &self,
        key_0: (
          types::polymesh_primitives::nft::NFTCollectionId,
          types::polymesh_primitives::nft::NFTId,
        ),
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::asset_metadata::AssetMetadataValue,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 60u8, 250u8, 177u8, 34u8, 185u8, 246u8, 58u8, 62u8, 106u8, 129u8,
          169u8, 121u8, 18u8, 218u8, 95u8, 196u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::asset_metadata::AssetMetadataValue>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The total number of NFTs in a collection"]
      #[cfg(not(feature = "ink"))]
      pub async fn nf_ts_in_collection(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 144u8, 90u8, 125u8, 255u8, 15u8, 215u8, 82u8, 78u8, 160u8, 192u8,
          231u8, 54u8, 218u8, 113u8, 117u8, 197u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total number of NFTs in a collection"]
      #[cfg(feature = "ink")]
      pub fn nf_ts_in_collection(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 144u8, 90u8, 125u8, 255u8, 15u8, 215u8, 82u8, 78u8, 160u8, 192u8,
          231u8, 54u8, 218u8, 113u8, 117u8, 197u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks the owner of an NFT"]
      #[cfg(not(feature = "ink"))]
      pub async fn nft_owner(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::nft::NFTId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity_id::PortfolioId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 91u8, 94u8, 244u8, 236u8, 188u8, 25u8, 19u8, 255u8, 125u8, 167u8,
          228u8, 155u8, 11u8, 54u8, 138u8, 234u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Tracks the owner of an NFT"]
      #[cfg(feature = "ink")]
      pub fn nft_owner(
        &self,
        key_0: ::polymesh_api_client::AssetId,
        key_1: types::polymesh_primitives::nft::NFTId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity_id::PortfolioId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 91u8, 94u8, 244u8, 236u8, 188u8, 25u8, 19u8, 255u8, 125u8, 167u8,
          228u8, 155u8, 11u8, 54u8, 138u8, 234u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The last `NFTId` used for an NFT."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_nft_id(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::nft::NFTId>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 108u8, 101u8, 2u8, 244u8, 210u8, 82u8, 242u8, 26u8, 42u8, 247u8,
          205u8, 136u8, 217u8, 79u8, 37u8, 195u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The last `NFTId` used for an NFT."]
      #[cfg(feature = "ink")]
      pub fn current_nft_id(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::nft::NFTId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 108u8, 101u8, 2u8, 244u8, 210u8, 82u8, 242u8, 26u8, 42u8, 247u8,
          205u8, 136u8, 217u8, 79u8, 37u8, 195u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The last `NFTCollectionId` used for a collection."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_collection_id(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::nft::NFTCollectionId>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 165u8, 141u8, 144u8, 50u8, 190u8, 120u8, 13u8, 0u8, 103u8, 139u8,
          64u8, 60u8, 240u8, 205u8, 212u8, 75u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The last `NFTCollectionId` used for a collection."]
      #[cfg(feature = "ink")]
      pub fn current_collection_id(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::nft::NFTCollectionId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 165u8, 141u8, 144u8, 50u8, 190u8, 120u8, 13u8, 0u8, 103u8, 139u8,
          64u8, 60u8, 240u8, 205u8, 212u8, 75u8,
        ])?;
        Ok(value)
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_nft::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_nft::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_nft::Version> {
        let value = self.api.read_storage(::alloc::vec![
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_nft::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct NftPagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> NftPagedQueryApi<'api> {
      #[doc = " The total number of NFTs per identity."]
      pub fn number_of_nf_ts(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 170u8, 210u8, 252u8, 218u8, 7u8, 81u8, 234u8, 12u8, 131u8, 54u8,
          33u8, 16u8, 193u8, 164u8, 16u8, 164u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
      }
      #[doc = " The collection id corresponding to each asset."]
      pub fn collection_asset(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        ::polymesh_api_client::AssetId,
        types::polymesh_primitives::nft::NFTCollectionId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 42u8, 68u8, 186u8, 69u8, 7u8, 24u8, 71u8, 138u8, 166u8, 31u8, 83u8,
          159u8, 177u8, 242u8, 13u8, 1u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " All collection details for a given collection id."]
      pub fn collection(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::nft::NFTCollectionId,
        types::polymesh_primitives::nft::NFTCollection,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 55u8, 92u8, 77u8, 37u8, 190u8, 245u8, 30u8, 47u8, 50u8, 254u8,
          233u8, 252u8, 85u8, 123u8, 24u8, 32u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " All mandatory metadata keys for a given collection."]
      pub fn collection_keys(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::nft::NFTCollectionId,
        ::alloc::collections::BTreeSet<
          types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 240u8, 0u8, 218u8, 102u8, 211u8, 19u8, 174u8, 223u8, 42u8, 70u8,
          29u8, 80u8, 78u8, 220u8, 122u8, 141u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The metadata value of an nft given its collection id, token id and metadata key."]
      pub fn metadata_value(
        &self,
        key_0: (
          types::polymesh_primitives::nft::NFTCollectionId,
          types::polymesh_primitives::nft::NFTId,
        ),
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        types::polymesh_primitives::asset_metadata::AssetMetadataValue,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 60u8, 250u8, 177u8, 34u8, 185u8, 246u8, 58u8, 62u8, 106u8, 129u8,
          169u8, 121u8, 18u8, 218u8, 95u8, 196u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The total number of NFTs in a collection"]
      pub fn nf_ts_in_collection(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 144u8, 90u8, 125u8, 255u8, 15u8, 215u8, 82u8, 78u8, 160u8, 192u8,
          231u8, 54u8, 218u8, 113u8, 117u8, 197u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " Tracks the owner of an NFT"]
      pub fn nft_owner(
        &self,
        key_0: ::polymesh_api_client::AssetId,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::nft::NFTId,
        types::polymesh_primitives::identity_id::PortfolioId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 91u8, 94u8, 244u8, 236u8, 188u8, 25u8, 19u8, 255u8, 125u8, 167u8,
          228u8, 155u8, 11u8, 54u8, 138u8, 234u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
      #[doc = " The last `NFTId` used for an NFT."]
      pub fn current_nft_id(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        types::polymesh_primitives::nft::NFTCollectionId,
        types::polymesh_primitives::nft::NFTId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 108u8, 101u8, 2u8, 244u8, 210u8, 82u8, 242u8, 26u8, 42u8, 247u8,
          205u8, 136u8, 217u8, 79u8, 37u8, 195u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(16), self.at)
      }
    }
  }
  pub mod election_provider_multi_phase {
    use super::*;
    #[derive(Clone)]
    pub struct ElectionProviderMultiPhaseCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ElectionProviderMultiPhaseCallApi<'api> {
      #[doc = "Submit a solution for the unsigned phase."]
      #[doc = ""]
      #[doc = "The dispatch origin fo this call must be __none__."]
      #[doc = ""]
      #[doc = "This submission is checked on the fly. Moreover, this unsigned solution is only"]
      #[doc = "validated when submitted to the pool from the **local** node. Effectively, this means"]
      #[doc = "that only active validators can submit this transaction when authoring a block (similar"]
      #[doc = "to an inherent)."]
      #[doc = ""]
      #[doc = "To prevent any incorrect solution (and thus wasted time/weight), this transaction will"]
      #[doc = "panic if the solution submitted by the validator is invalid in any way, effectively"]
      #[doc = "putting their authoring reward at risk."]
      #[doc = ""]
      #[doc = "No deposit or reward is associated with this submission."]
      #[cfg(not(feature = "ink"))]
      pub fn submit_unsigned(
        &self,
        raw_solution: types::pallet_election_provider_multi_phase::RawSolution<
          types::polymesh_runtime_common::NposSolution16,
        >,
        witness: types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: ElectionProviderMultiPhase (types :: pallet_election_provider_multi_phase :: pallet :: ElectionProviderMultiPhaseCall :: submit_unsigned { raw_solution : :: alloc :: boxed :: Box :: new (raw_solution) , witness , }))
      }
      #[doc = "Submit a solution for the unsigned phase."]
      #[doc = ""]
      #[doc = "The dispatch origin fo this call must be __none__."]
      #[doc = ""]
      #[doc = "This submission is checked on the fly. Moreover, this unsigned solution is only"]
      #[doc = "validated when submitted to the pool from the **local** node. Effectively, this means"]
      #[doc = "that only active validators can submit this transaction when authoring a block (similar"]
      #[doc = "to an inherent)."]
      #[doc = ""]
      #[doc = "To prevent any incorrect solution (and thus wasted time/weight), this transaction will"]
      #[doc = "panic if the solution submitted by the validator is invalid in any way, effectively"]
      #[doc = "putting their authoring reward at risk."]
      #[doc = ""]
      #[doc = "No deposit or reward is associated with this submission."]
      #[cfg(feature = "ink")]
      pub fn submit_unsigned(
        &self,
        raw_solution: types::pallet_election_provider_multi_phase::RawSolution<
          types::polymesh_runtime_common::NposSolution16,
        >,
        witness: types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![50u8, 0u8];
        raw_solution.encode_to(&mut buf);
        witness.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set a new value for `MinimumUntrustedScore`."]
      #[doc = ""]
      #[doc = "Dispatch origin must be aligned with `T::ForceOrigin`."]
      #[doc = ""]
      #[doc = "This check can be turned off by setting the value to `None`."]
      #[cfg(not(feature = "ink"))]
      pub fn set_minimum_untrusted_score(
        &self,
        maybe_next_score: Option<types::sp_npos_elections::ElectionScore>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: ElectionProviderMultiPhase (types :: pallet_election_provider_multi_phase :: pallet :: ElectionProviderMultiPhaseCall :: set_minimum_untrusted_score { maybe_next_score , }))
      }
      #[doc = "Set a new value for `MinimumUntrustedScore`."]
      #[doc = ""]
      #[doc = "Dispatch origin must be aligned with `T::ForceOrigin`."]
      #[doc = ""]
      #[doc = "This check can be turned off by setting the value to `None`."]
      #[cfg(feature = "ink")]
      pub fn set_minimum_untrusted_score(
        &self,
        maybe_next_score: Option<types::sp_npos_elections::ElectionScore>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![50u8, 1u8];
        maybe_next_score.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set a solution in the queue, to be handed out to the client of this pallet in the next"]
      #[doc = "call to `ElectionProvider::elect`."]
      #[doc = ""]
      #[doc = "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`."]
      #[doc = ""]
      #[doc = "The solution is not checked for any feasibility and is assumed to be trustworthy, as any"]
      #[doc = "feasibility check itself can in principle cause the election process to fail (due to"]
      #[doc = "memory/weight constrains)."]
      #[cfg(not(feature = "ink"))]
      pub fn set_emergency_election_result(
        &self,
        supports: ::alloc::vec::Vec<(
          ::polymesh_api_client::AccountId,
          types::sp_npos_elections::Support<::polymesh_api_client::AccountId>,
        )>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: ElectionProviderMultiPhase (types :: pallet_election_provider_multi_phase :: pallet :: ElectionProviderMultiPhaseCall :: set_emergency_election_result { supports , }))
      }
      #[doc = "Set a solution in the queue, to be handed out to the client of this pallet in the next"]
      #[doc = "call to `ElectionProvider::elect`."]
      #[doc = ""]
      #[doc = "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`."]
      #[doc = ""]
      #[doc = "The solution is not checked for any feasibility and is assumed to be trustworthy, as any"]
      #[doc = "feasibility check itself can in principle cause the election process to fail (due to"]
      #[doc = "memory/weight constrains)."]
      #[cfg(feature = "ink")]
      pub fn set_emergency_election_result(
        &self,
        supports: ::alloc::vec::Vec<(
          ::polymesh_api_client::AccountId,
          types::sp_npos_elections::Support<::polymesh_api_client::AccountId>,
        )>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![50u8, 2u8];
        supports.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Submit a solution for the signed phase."]
      #[doc = ""]
      #[doc = "The dispatch origin fo this call must be __signed__."]
      #[doc = ""]
      #[doc = "The solution is potentially queued, based on the claimed score and processed at the end"]
      #[doc = "of the signed phase."]
      #[doc = ""]
      #[doc = "A deposit is reserved and recorded for the solution. Based on the outcome, the solution"]
      #[doc = "might be rewarded, slashed, or get all or a part of the deposit back."]
      #[cfg(not(feature = "ink"))]
      pub fn submit(
        &self,
        raw_solution: types::pallet_election_provider_multi_phase::RawSolution<
          types::polymesh_runtime_common::NposSolution16,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: ElectionProviderMultiPhase (types :: pallet_election_provider_multi_phase :: pallet :: ElectionProviderMultiPhaseCall :: submit { raw_solution : :: alloc :: boxed :: Box :: new (raw_solution) , }))
      }
      #[doc = "Submit a solution for the signed phase."]
      #[doc = ""]
      #[doc = "The dispatch origin fo this call must be __signed__."]
      #[doc = ""]
      #[doc = "The solution is potentially queued, based on the claimed score and processed at the end"]
      #[doc = "of the signed phase."]
      #[doc = ""]
      #[doc = "A deposit is reserved and recorded for the solution. Based on the outcome, the solution"]
      #[doc = "might be rewarded, slashed, or get all or a part of the deposit back."]
      #[cfg(feature = "ink")]
      pub fn submit(
        &self,
        raw_solution: types::pallet_election_provider_multi_phase::RawSolution<
          types::polymesh_runtime_common::NposSolution16,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![50u8, 3u8];
        raw_solution.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Trigger the governance fallback."]
      #[doc = ""]
      #[doc = "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to"]
      #[doc = "calling [`Call::set_emergency_election_result`]."]
      #[cfg(not(feature = "ink"))]
      pub fn governance_fallback(
        &self,
        maybe_max_voters: Option<u32>,
        maybe_max_targets: Option<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: ElectionProviderMultiPhase (types :: pallet_election_provider_multi_phase :: pallet :: ElectionProviderMultiPhaseCall :: governance_fallback { maybe_max_voters , maybe_max_targets , }))
      }
      #[doc = "Trigger the governance fallback."]
      #[doc = ""]
      #[doc = "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to"]
      #[doc = "calling [`Call::set_emergency_election_result`]."]
      #[cfg(feature = "ink")]
      pub fn governance_fallback(
        &self,
        maybe_max_voters: Option<u32>,
        maybe_max_targets: Option<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![50u8, 4u8];
        maybe_max_voters.encode_to(&mut buf);
        maybe_max_targets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ElectionProviderMultiPhaseCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ElectionProviderMultiPhaseQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ElectionProviderMultiPhaseQueryApi<'api> {
      #[doc = " Internal counter for the number of rounds."]
      #[doc = ""]
      #[doc = " This is useful for de-duplication of transactions submitted to the pool, and general"]
      #[doc = " diagnostics of the pallet."]
      #[doc = ""]
      #[doc = " This is merely incremented once per every time that an upstream `elect` is called."]
      #[cfg(not(feature = "ink"))]
      pub async fn round(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 19u8, 121u8, 46u8, 120u8, 81u8, 104u8, 247u8, 37u8, 182u8, 14u8,
          41u8, 105u8, 199u8, 252u8, 37u8, 82u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Internal counter for the number of rounds."]
      #[doc = ""]
      #[doc = " This is useful for de-duplication of transactions submitted to the pool, and general"]
      #[doc = " diagnostics of the pallet."]
      #[doc = ""]
      #[doc = " This is merely incremented once per every time that an upstream `elect` is called."]
      #[cfg(feature = "ink")]
      pub fn round(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 19u8, 121u8, 46u8, 120u8, 81u8, 104u8, 247u8, 37u8, 182u8, 14u8,
          41u8, 105u8, 199u8, 252u8, 37u8, 82u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current phase."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_phase(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_election_provider_multi_phase::Phase<u32>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 217u8, 118u8, 68u8, 1u8, 148u8, 29u8, 247u8, 247u8, 7u8, 164u8,
          123u8, 167u8, 219u8, 100u8, 166u8, 234u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_election_provider_multi_phase::Phase<u32>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Current phase."]
      #[cfg(feature = "ink")]
      pub fn current_phase(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_election_provider_multi_phase::Phase<u32>>
      {
        let value = self.api.read_storage(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 217u8, 118u8, 68u8, 1u8, 148u8, 29u8, 247u8, 247u8, 7u8, 164u8,
          123u8, 167u8, 219u8, 100u8, 166u8, 234u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_election_provider_multi_phase::Phase<u32>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Current best solution, signed or unsigned, queued to be returned upon `elect`."]
      #[cfg(not(feature = "ink"))]
      pub async fn queued_solution(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_election_provider_multi_phase::ReadySolution>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 72u8, 12u8, 161u8, 163u8, 76u8, 172u8, 219u8, 18u8, 175u8, 252u8,
          103u8, 236u8, 195u8, 160u8, 128u8, 4u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Current best solution, signed or unsigned, queued to be returned upon `elect`."]
      #[cfg(feature = "ink")]
      pub fn queued_solution(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_election_provider_multi_phase::ReadySolution>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 72u8, 12u8, 161u8, 163u8, 76u8, 172u8, 219u8, 18u8, 175u8, 252u8,
          103u8, 236u8, 195u8, 160u8, 128u8, 4u8,
        ])?;
        Ok(value)
      }
      #[doc = " Snapshot data of the round."]
      #[doc = ""]
      #[doc = " This is created at the beginning of the signed phase and cleared upon calling `elect`."]
      #[cfg(not(feature = "ink"))]
      pub async fn snapshot(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_election_provider_multi_phase::RoundSnapshot>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 150u8, 211u8, 143u8, 212u8, 91u8, 192u8, 56u8, 250u8, 169u8, 88u8,
          111u8, 169u8, 58u8, 160u8, 62u8, 247u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Snapshot data of the round."]
      #[doc = ""]
      #[doc = " This is created at the beginning of the signed phase and cleared upon calling `elect`."]
      #[cfg(feature = "ink")]
      pub fn snapshot(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_election_provider_multi_phase::RoundSnapshot>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 150u8, 211u8, 143u8, 212u8, 91u8, 192u8, 56u8, 250u8, 169u8, 88u8,
          111u8, 169u8, 58u8, 160u8, 62u8, 247u8,
        ])?;
        Ok(value)
      }
      #[doc = " Desired number of targets to elect for this round."]
      #[doc = ""]
      #[doc = " Only exists when [`Snapshot`] is present."]
      #[cfg(not(feature = "ink"))]
      pub async fn desired_targets(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 114u8, 11u8, 112u8, 253u8, 71u8, 251u8, 237u8, 135u8, 90u8, 58u8,
          45u8, 173u8, 67u8, 120u8, 236u8, 77u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Desired number of targets to elect for this round."]
      #[doc = ""]
      #[doc = " Only exists when [`Snapshot`] is present."]
      #[cfg(feature = "ink")]
      pub fn desired_targets(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 114u8, 11u8, 112u8, 253u8, 71u8, 251u8, 237u8, 135u8, 90u8, 58u8,
          45u8, 173u8, 67u8, 120u8, 236u8, 77u8,
        ])?;
        Ok(value)
      }
      #[doc = " The metadata of the [`RoundSnapshot`]"]
      #[doc = ""]
      #[doc = " Only exists when [`Snapshot`] is present."]
      #[cfg(not(feature = "ink"))]
      pub async fn snapshot_metadata(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 42u8, 62u8, 95u8, 29u8, 70u8, 27u8, 247u8, 99u8, 167u8, 96u8, 19u8,
          224u8, 98u8, 180u8, 108u8, 14u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The metadata of the [`RoundSnapshot`]"]
      #[doc = ""]
      #[doc = " Only exists when [`Snapshot`] is present."]
      #[cfg(feature = "ink")]
      pub fn snapshot_metadata(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 42u8, 62u8, 95u8, 29u8, 70u8, 27u8, 247u8, 99u8, 167u8, 96u8, 19u8,
          224u8, 98u8, 180u8, 108u8, 14u8,
        ])?;
        Ok(value)
      }
      #[doc = " The next index to be assigned to an incoming signed submission."]
      #[doc = ""]
      #[doc = " Every accepted submission is assigned a unique index; that index is bound to that particular"]
      #[doc = " submission for the duration of the election. On election finalization, the next index is"]
      #[doc = " reset to 0."]
      #[doc = ""]
      #[doc = " We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its"]
      #[doc = " capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,"]
      #[doc = " because iteration is slow. Instead, we store the value here."]
      #[cfg(not(feature = "ink"))]
      pub async fn signed_submission_next_index(
        &self,
      ) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 20u8, 206u8, 58u8, 102u8, 6u8, 50u8, 80u8, 247u8, 30u8, 10u8, 17u8,
          165u8, 23u8, 234u8, 64u8, 98u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next index to be assigned to an incoming signed submission."]
      #[doc = ""]
      #[doc = " Every accepted submission is assigned a unique index; that index is bound to that particular"]
      #[doc = " submission for the duration of the election. On election finalization, the next index is"]
      #[doc = " reset to 0."]
      #[doc = ""]
      #[doc = " We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its"]
      #[doc = " capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,"]
      #[doc = " because iteration is slow. Instead, we store the value here."]
      #[cfg(feature = "ink")]
      pub fn signed_submission_next_index(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 20u8, 206u8, 58u8, 102u8, 6u8, 50u8, 80u8, 247u8, 30u8, 10u8, 17u8,
          165u8, 23u8, 234u8, 64u8, 98u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A sorted, bounded vector of `(score, block_number, index)`, where each `index` points to a"]
      #[doc = " value in `SignedSubmissions`."]
      #[doc = ""]
      #[doc = " We never need to process more than a single signed submission at a time. Signed submissions"]
      #[doc = " can be quite large, so we're willing to pay the cost of multiple database accesses to access"]
      #[doc = " them one at a time instead of reading and decoding all of them at once."]
      #[cfg(not(feature = "ink"))]
      pub async fn signed_submission_indices(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<(types::sp_npos_elections::ElectionScore, u32, u32)>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 11u8, 177u8, 211u8, 90u8, 139u8, 77u8, 49u8, 172u8, 236u8, 47u8,
          204u8, 188u8, 240u8, 23u8, 47u8, 196u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(types::sp_npos_elections::ElectionScore, u32, u32)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " A sorted, bounded vector of `(score, block_number, index)`, where each `index` points to a"]
      #[doc = " value in `SignedSubmissions`."]
      #[doc = ""]
      #[doc = " We never need to process more than a single signed submission at a time. Signed submissions"]
      #[doc = " can be quite large, so we're willing to pay the cost of multiple database accesses to access"]
      #[doc = " them one at a time instead of reading and decoding all of them at once."]
      #[cfg(feature = "ink")]
      pub fn signed_submission_indices(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<(types::sp_npos_elections::ElectionScore, u32, u32)>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 11u8, 177u8, 211u8, 90u8, 139u8, 77u8, 49u8, 172u8, 236u8, 47u8,
          204u8, 188u8, 240u8, 23u8, 47u8, 196u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(types::sp_npos_elections::ElectionScore, u32, u32)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Unchecked, signed solutions."]
      #[doc = ""]
      #[doc = " Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while"]
      #[doc = " allowing us to keep only a single one in memory at a time."]
      #[doc = ""]
      #[doc = " Twox note: the key of the map is an auto-incrementing index which users cannot inspect or"]
      #[doc = " affect; we shouldn't need a cryptographically secure hasher."]
      #[cfg(not(feature = "ink"))]
      pub async fn signed_submissions_map(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::pallet_election_provider_multi_phase::signed::SignedSubmission<
            ::polymesh_api_client::AccountId,
            u128,
            types::polymesh_runtime_common::NposSolution16,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 179u8, 209u8, 198u8, 67u8, 192u8, 212u8, 94u8, 43u8, 185u8, 38u8,
          154u8, 200u8, 108u8, 29u8, 205u8, 160u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Unchecked, signed solutions."]
      #[doc = ""]
      #[doc = " Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while"]
      #[doc = " allowing us to keep only a single one in memory at a time."]
      #[doc = ""]
      #[doc = " Twox note: the key of the map is an auto-incrementing index which users cannot inspect or"]
      #[doc = " affect; we shouldn't need a cryptographically secure hasher."]
      #[cfg(feature = "ink")]
      pub fn signed_submissions_map(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::pallet_election_provider_multi_phase::signed::SignedSubmission<
            ::polymesh_api_client::AccountId,
            u128,
            types::polymesh_runtime_common::NposSolution16,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 179u8, 209u8, 198u8, 67u8, 192u8, 212u8, 94u8, 43u8, 185u8, 38u8,
          154u8, 200u8, 108u8, 29u8, 205u8, 160u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The minimum score that each 'untrusted' solution must attain in order to be considered"]
      #[doc = " feasible."]
      #[doc = ""]
      #[doc = " Can be set via `set_minimum_untrusted_score`."]
      #[cfg(not(feature = "ink"))]
      pub async fn minimum_untrusted_score(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<types::sp_npos_elections::ElectionScore>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 109u8, 139u8, 189u8, 163u8, 187u8, 186u8, 212u8, 108u8, 197u8, 125u8,
          67u8, 130u8, 93u8, 208u8, 64u8, 197u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The minimum score that each 'untrusted' solution must attain in order to be considered"]
      #[doc = " feasible."]
      #[doc = ""]
      #[doc = " Can be set via `set_minimum_untrusted_score`."]
      #[cfg(feature = "ink")]
      pub fn minimum_untrusted_score(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::sp_npos_elections::ElectionScore>>
      {
        let value = self.api.read_storage(::alloc::vec![
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 109u8, 139u8, 189u8, 163u8, 187u8, 186u8, 212u8, 108u8, 197u8, 125u8,
          67u8, 130u8, 93u8, 208u8, 64u8, 197u8,
        ])?;
        Ok(value)
      }
    }
    #[derive(Clone)]
    #[cfg(not(feature = "ink"))]
    pub struct ElectionProviderMultiPhasePagedQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    #[cfg(not(feature = "ink"))]
    impl<'api> ElectionProviderMultiPhasePagedQueryApi<'api> {
      #[doc = " Unchecked, signed solutions."]
      #[doc = ""]
      #[doc = " Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while"]
      #[doc = " allowing us to keep only a single one in memory at a time."]
      #[doc = ""]
      #[doc = " Twox note: the key of the map is an auto-incrementing index which users cannot inspect or"]
      #[doc = " affect; we shouldn't need a cryptographically secure hasher."]
      pub fn signed_submissions_map(
        &self,
      ) -> ::polymesh_api_client::StoragePaged<
        u32,
        types::pallet_election_provider_multi_phase::signed::SignedSubmission<
          ::polymesh_api_client::AccountId,
          u128,
          types::polymesh_runtime_common::NposSolution16,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8, 119u8, 252u8,
          37u8, 117u8, 227u8, 179u8, 209u8, 198u8, 67u8, 192u8, 212u8, 94u8, 43u8, 185u8, 38u8,
          154u8, 200u8, 108u8, 29u8, 205u8, 160u8,
        ]);
        let prefix = ::polymesh_api_client::StorageKey(buf);
        ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
      }
    }
  }
}
#[derive(Clone)]
pub struct Api {
  #[cfg(not(feature = "ink"))]
  client: ::polymesh_api_client::Client,
}
impl Api {
  #[cfg(feature = "ink")]
  pub fn new() -> Self {
    Self {}
  }
  #[cfg(feature = "ink")]
  pub fn runtime(&self) -> ::polymesh_api_ink::extension::PolymeshRuntimeInstance {
    ::polymesh_api_ink::extension::new_instance()
  }
  #[cfg(feature = "ink")]
  pub fn read_storage<T: ::codec::Decode>(
    &self,
    key: ::alloc::vec::Vec<u8>,
  ) -> ::polymesh_api_ink::error::Result<Option<T>> {
    let runtime = self.runtime();
    let value = runtime
      .read_storage(key.into())?
      .map(|data| T::decode(&mut data.as_slice()))
      .transpose()?;
    Ok(value)
  }
  #[cfg(not(feature = "ink"))]
  pub async fn new(url: &str) -> ::polymesh_api_client::error::Result<Self> {
    Ok(Self {
      client: ::polymesh_api_client::Client::new(url).await?,
    })
  }
  pub fn call(&self) -> CallApi {
    CallApi { api: self }
  }
  #[cfg(not(feature = "ink"))]
  pub fn query(&self) -> QueryApi {
    QueryApi {
      api: self,
      at: None,
    }
  }
  #[cfg(feature = "ink")]
  pub fn query(&self) -> QueryApi {
    QueryApi { api: self }
  }
  #[cfg(not(feature = "ink"))]
  pub fn query_at(&self, block: ::polymesh_api_client::BlockHash) -> QueryApi {
    QueryApi {
      api: self,
      at: Some(block),
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn paged_query(&self) -> PagedQueryApi {
    PagedQueryApi {
      api: self,
      at: None,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn paged_query_at(&self, block: ::polymesh_api_client::BlockHash) -> PagedQueryApi {
    PagedQueryApi {
      api: self,
      at: Some(block),
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn wrap_call(
    &self,
    call: types::runtime::RuntimeCall,
  ) -> ::polymesh_api_client::Result<WrappedCall> {
    Ok(WrappedCall::new(self, call))
  }
  #[cfg(feature = "ink")]
  pub fn wrap_call(&self, call: ::alloc::vec::Vec<u8>) -> WrappedCall {
    WrappedCall::new(call)
  }
}
#[cfg(not(feature = "ink"))]
use alloc::boxed::Box;
#[async_trait::async_trait]
#[cfg(not(feature = "ink"))]
impl ::polymesh_api_client::ChainApi for Api {
  type RuntimeCall = types::runtime::RuntimeCall;
  type RuntimeEvent = types::runtime::RuntimeEvent;
  type DispatchInfo = types::frame_support::dispatch::DispatchInfo;
  type DispatchError = types::sp_runtime::DispatchError;
  async fn get_nonce(
    &self,
    account: ::polymesh_api_client::AccountId,
  ) -> ::polymesh_api_client::Result<u32> {
    let info = self.query().system().account(account).await?;
    Ok(info.nonce)
  }
  async fn block_events(
    &self,
    block: Option<::polymesh_api_client::BlockHash>,
  ) -> ::polymesh_api_client::Result<
    ::alloc::vec::Vec<::polymesh_api_client::EventRecord<Self::RuntimeEvent>>,
  > {
    let system = match block {
      Some(block) => self.query_at(block).system(),
      None => self.query().system(),
    };
    Ok(system.events().await?)
  }
  fn event_to_extrinsic_result(
    event: &::polymesh_api_client::EventRecord<Self::RuntimeEvent>,
  ) -> Option<::polymesh_api_client::ExtrinsicResult<Self>> {
    match &event.event {
      types::runtime::RuntimeEvent::System(
        types::frame_system::pallet::SystemEvent::ExtrinsicSuccess { dispatch_info },
      ) => Some(::polymesh_api_client::ExtrinsicResult::Success(
        dispatch_info.clone(),
      )),
      types::runtime::RuntimeEvent::System(
        types::frame_system::pallet::SystemEvent::ExtrinsicFailed {
          dispatch_info,
          dispatch_error,
        },
      ) => Some(::polymesh_api_client::ExtrinsicResult::Failed(
        dispatch_info.clone(),
        dispatch_error.clone(),
      )),
      _ => None,
    }
  }
  fn client(&self) -> &::polymesh_api_client::Client {
    &self.client
  }
}
#[derive(Clone)]
pub struct CallApi<'api> {
  api: &'api Api,
}
impl<'api> CallApi<'api> {
  pub fn system(&self) -> api::system::SystemCallApi<'api> {
    api::system::SystemCallApi::from(self.api)
  }
  pub fn babe(&self) -> api::babe::BabeCallApi<'api> {
    api::babe::BabeCallApi::from(self.api)
  }
  pub fn timestamp(&self) -> api::timestamp::TimestampCallApi<'api> {
    api::timestamp::TimestampCallApi::from(self.api)
  }
  pub fn indices(&self) -> api::indices::IndicesCallApi<'api> {
    api::indices::IndicesCallApi::from(self.api)
  }
  pub fn authorship(&self) -> api::authorship::AuthorshipCallApi<'api> {
    api::authorship::AuthorshipCallApi::from(self.api)
  }
  pub fn balances(&self) -> api::balances::BalancesCallApi<'api> {
    api::balances::BalancesCallApi::from(self.api)
  }
  pub fn transaction_payment(&self) -> api::transaction_payment::TransactionPaymentCallApi<'api> {
    api::transaction_payment::TransactionPaymentCallApi::from(self.api)
  }
  pub fn identity(&self) -> api::identity::IdentityCallApi<'api> {
    api::identity::IdentityCallApi::from(self.api)
  }
  pub fn cdd_service_providers(
    &self,
  ) -> api::cdd_service_providers::CddServiceProvidersCallApi<'api> {
    api::cdd_service_providers::CddServiceProvidersCallApi::from(self.api)
  }
  pub fn polymesh_committee(&self) -> api::polymesh_committee::PolymeshCommitteeCallApi<'api> {
    api::polymesh_committee::PolymeshCommitteeCallApi::from(self.api)
  }
  pub fn committee_membership(
    &self,
  ) -> api::committee_membership::CommitteeMembershipCallApi<'api> {
    api::committee_membership::CommitteeMembershipCallApi::from(self.api)
  }
  pub fn technical_committee(&self) -> api::technical_committee::TechnicalCommitteeCallApi<'api> {
    api::technical_committee::TechnicalCommitteeCallApi::from(self.api)
  }
  pub fn technical_committee_membership(
    &self,
  ) -> api::technical_committee_membership::TechnicalCommitteeMembershipCallApi<'api> {
    api::technical_committee_membership::TechnicalCommitteeMembershipCallApi::from(self.api)
  }
  pub fn upgrade_committee(&self) -> api::upgrade_committee::UpgradeCommitteeCallApi<'api> {
    api::upgrade_committee::UpgradeCommitteeCallApi::from(self.api)
  }
  pub fn upgrade_committee_membership(
    &self,
  ) -> api::upgrade_committee_membership::UpgradeCommitteeMembershipCallApi<'api> {
    api::upgrade_committee_membership::UpgradeCommitteeMembershipCallApi::from(self.api)
  }
  pub fn multi_sig(&self) -> api::multi_sig::MultiSigCallApi<'api> {
    api::multi_sig::MultiSigCallApi::from(self.api)
  }
  pub fn bridge(&self) -> api::bridge::BridgeCallApi<'api> {
    api::bridge::BridgeCallApi::from(self.api)
  }
  pub fn staking(&self) -> api::staking::StakingCallApi<'api> {
    api::staking::StakingCallApi::from(self.api)
  }
  pub fn offences(&self) -> api::offences::OffencesCallApi<'api> {
    api::offences::OffencesCallApi::from(self.api)
  }
  pub fn session(&self) -> api::session::SessionCallApi<'api> {
    api::session::SessionCallApi::from(self.api)
  }
  pub fn authority_discovery(&self) -> api::authority_discovery::AuthorityDiscoveryCallApi<'api> {
    api::authority_discovery::AuthorityDiscoveryCallApi::from(self.api)
  }
  pub fn grandpa(&self) -> api::grandpa::GrandpaCallApi<'api> {
    api::grandpa::GrandpaCallApi::from(self.api)
  }
  pub fn historical(&self) -> api::historical::HistoricalCallApi<'api> {
    api::historical::HistoricalCallApi::from(self.api)
  }
  pub fn im_online(&self) -> api::im_online::ImOnlineCallApi<'api> {
    api::im_online::ImOnlineCallApi::from(self.api)
  }
  pub fn randomness_collective_flip(
    &self,
  ) -> api::randomness_collective_flip::RandomnessCollectiveFlipCallApi<'api> {
    api::randomness_collective_flip::RandomnessCollectiveFlipCallApi::from(self.api)
  }
  pub fn asset(&self) -> api::asset::AssetCallApi<'api> {
    api::asset::AssetCallApi::from(self.api)
  }
  pub fn capital_distribution(
    &self,
  ) -> api::capital_distribution::CapitalDistributionCallApi<'api> {
    api::capital_distribution::CapitalDistributionCallApi::from(self.api)
  }
  pub fn checkpoint(&self) -> api::checkpoint::CheckpointCallApi<'api> {
    api::checkpoint::CheckpointCallApi::from(self.api)
  }
  pub fn compliance_manager(&self) -> api::compliance_manager::ComplianceManagerCallApi<'api> {
    api::compliance_manager::ComplianceManagerCallApi::from(self.api)
  }
  pub fn corporate_action(&self) -> api::corporate_action::CorporateActionCallApi<'api> {
    api::corporate_action::CorporateActionCallApi::from(self.api)
  }
  pub fn corporate_ballot(&self) -> api::corporate_ballot::CorporateBallotCallApi<'api> {
    api::corporate_ballot::CorporateBallotCallApi::from(self.api)
  }
  pub fn permissions(&self) -> api::permissions::PermissionsCallApi<'api> {
    api::permissions::PermissionsCallApi::from(self.api)
  }
  pub fn pips(&self) -> api::pips::PipsCallApi<'api> {
    api::pips::PipsCallApi::from(self.api)
  }
  pub fn portfolio(&self) -> api::portfolio::PortfolioCallApi<'api> {
    api::portfolio::PortfolioCallApi::from(self.api)
  }
  pub fn protocol_fee(&self) -> api::protocol_fee::ProtocolFeeCallApi<'api> {
    api::protocol_fee::ProtocolFeeCallApi::from(self.api)
  }
  pub fn scheduler(&self) -> api::scheduler::SchedulerCallApi<'api> {
    api::scheduler::SchedulerCallApi::from(self.api)
  }
  pub fn settlement(&self) -> api::settlement::SettlementCallApi<'api> {
    api::settlement::SettlementCallApi::from(self.api)
  }
  pub fn statistics(&self) -> api::statistics::StatisticsCallApi<'api> {
    api::statistics::StatisticsCallApi::from(self.api)
  }
  pub fn sto(&self) -> api::sto::StoCallApi<'api> {
    api::sto::StoCallApi::from(self.api)
  }
  pub fn treasury(&self) -> api::treasury::TreasuryCallApi<'api> {
    api::treasury::TreasuryCallApi::from(self.api)
  }
  pub fn utility(&self) -> api::utility::UtilityCallApi<'api> {
    api::utility::UtilityCallApi::from(self.api)
  }
  pub fn base(&self) -> api::base::BaseCallApi<'api> {
    api::base::BaseCallApi::from(self.api)
  }
  pub fn external_agents(&self) -> api::external_agents::ExternalAgentsCallApi<'api> {
    api::external_agents::ExternalAgentsCallApi::from(self.api)
  }
  pub fn relayer(&self) -> api::relayer::RelayerCallApi<'api> {
    api::relayer::RelayerCallApi::from(self.api)
  }
  pub fn contracts(&self) -> api::contracts::ContractsCallApi<'api> {
    api::contracts::ContractsCallApi::from(self.api)
  }
  pub fn polymesh_contracts(&self) -> api::polymesh_contracts::PolymeshContractsCallApi<'api> {
    api::polymesh_contracts::PolymeshContractsCallApi::from(self.api)
  }
  pub fn preimage(&self) -> api::preimage::PreimageCallApi<'api> {
    api::preimage::PreimageCallApi::from(self.api)
  }
  pub fn nft(&self) -> api::nft::NftCallApi<'api> {
    api::nft::NftCallApi::from(self.api)
  }
  pub fn election_provider_multi_phase(
    &self,
  ) -> api::election_provider_multi_phase::ElectionProviderMultiPhaseCallApi<'api> {
    api::election_provider_multi_phase::ElectionProviderMultiPhaseCallApi::from(self.api)
  }
}
#[cfg(not(feature = "ink"))]
pub type WrappedCall = ::polymesh_api_client::Call<Api>;
#[cfg(not(feature = "ink"))]
pub type TransactionResults = ::polymesh_api_client::TransactionResults<Api>;
#[cfg(feature = "ink")]
pub type WrappedCall = ::polymesh_api_ink::Call;
#[cfg(not(feature = "ink"))]
impl From<WrappedCall> for types::runtime::RuntimeCall {
  fn from(wrapped: WrappedCall) -> Self {
    wrapped.into_runtime_call()
  }
}
#[cfg(not(feature = "ink"))]
impl From<&WrappedCall> for types::runtime::RuntimeCall {
  fn from(wrapped: &WrappedCall) -> Self {
    wrapped.runtime_call().clone()
  }
}
#[derive(Clone)]
pub struct QueryApi<'api> {
  api: &'api Api,
  #[cfg(not(feature = "ink"))]
  at: Option<::polymesh_api_client::BlockHash>,
}
impl<'api> QueryApi<'api> {
  pub fn system(&self) -> api::system::SystemQueryApi<'api> {
    api::system::SystemQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn babe(&self) -> api::babe::BabeQueryApi<'api> {
    api::babe::BabeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn timestamp(&self) -> api::timestamp::TimestampQueryApi<'api> {
    api::timestamp::TimestampQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn indices(&self) -> api::indices::IndicesQueryApi<'api> {
    api::indices::IndicesQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn authorship(&self) -> api::authorship::AuthorshipQueryApi<'api> {
    api::authorship::AuthorshipQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn balances(&self) -> api::balances::BalancesQueryApi<'api> {
    api::balances::BalancesQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn transaction_payment(&self) -> api::transaction_payment::TransactionPaymentQueryApi<'api> {
    api::transaction_payment::TransactionPaymentQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn identity(&self) -> api::identity::IdentityQueryApi<'api> {
    api::identity::IdentityQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn cdd_service_providers(
    &self,
  ) -> api::cdd_service_providers::CddServiceProvidersQueryApi<'api> {
    api::cdd_service_providers::CddServiceProvidersQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn polymesh_committee(&self) -> api::polymesh_committee::PolymeshCommitteeQueryApi<'api> {
    api::polymesh_committee::PolymeshCommitteeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn committee_membership(
    &self,
  ) -> api::committee_membership::CommitteeMembershipQueryApi<'api> {
    api::committee_membership::CommitteeMembershipQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn technical_committee(&self) -> api::technical_committee::TechnicalCommitteeQueryApi<'api> {
    api::technical_committee::TechnicalCommitteeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn technical_committee_membership(
    &self,
  ) -> api::technical_committee_membership::TechnicalCommitteeMembershipQueryApi<'api> {
    api::technical_committee_membership::TechnicalCommitteeMembershipQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn upgrade_committee(&self) -> api::upgrade_committee::UpgradeCommitteeQueryApi<'api> {
    api::upgrade_committee::UpgradeCommitteeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn upgrade_committee_membership(
    &self,
  ) -> api::upgrade_committee_membership::UpgradeCommitteeMembershipQueryApi<'api> {
    api::upgrade_committee_membership::UpgradeCommitteeMembershipQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn multi_sig(&self) -> api::multi_sig::MultiSigQueryApi<'api> {
    api::multi_sig::MultiSigQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn bridge(&self) -> api::bridge::BridgeQueryApi<'api> {
    api::bridge::BridgeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn staking(&self) -> api::staking::StakingQueryApi<'api> {
    api::staking::StakingQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn offences(&self) -> api::offences::OffencesQueryApi<'api> {
    api::offences::OffencesQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn session(&self) -> api::session::SessionQueryApi<'api> {
    api::session::SessionQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn authority_discovery(&self) -> api::authority_discovery::AuthorityDiscoveryQueryApi<'api> {
    api::authority_discovery::AuthorityDiscoveryQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn grandpa(&self) -> api::grandpa::GrandpaQueryApi<'api> {
    api::grandpa::GrandpaQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn historical(&self) -> api::historical::HistoricalQueryApi<'api> {
    api::historical::HistoricalQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn im_online(&self) -> api::im_online::ImOnlineQueryApi<'api> {
    api::im_online::ImOnlineQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn randomness_collective_flip(
    &self,
  ) -> api::randomness_collective_flip::RandomnessCollectiveFlipQueryApi<'api> {
    api::randomness_collective_flip::RandomnessCollectiveFlipQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn asset(&self) -> api::asset::AssetQueryApi<'api> {
    api::asset::AssetQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn capital_distribution(
    &self,
  ) -> api::capital_distribution::CapitalDistributionQueryApi<'api> {
    api::capital_distribution::CapitalDistributionQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn checkpoint(&self) -> api::checkpoint::CheckpointQueryApi<'api> {
    api::checkpoint::CheckpointQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn compliance_manager(&self) -> api::compliance_manager::ComplianceManagerQueryApi<'api> {
    api::compliance_manager::ComplianceManagerQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn corporate_action(&self) -> api::corporate_action::CorporateActionQueryApi<'api> {
    api::corporate_action::CorporateActionQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn corporate_ballot(&self) -> api::corporate_ballot::CorporateBallotQueryApi<'api> {
    api::corporate_ballot::CorporateBallotQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn permissions(&self) -> api::permissions::PermissionsQueryApi<'api> {
    api::permissions::PermissionsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn pips(&self) -> api::pips::PipsQueryApi<'api> {
    api::pips::PipsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn portfolio(&self) -> api::portfolio::PortfolioQueryApi<'api> {
    api::portfolio::PortfolioQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn protocol_fee(&self) -> api::protocol_fee::ProtocolFeeQueryApi<'api> {
    api::protocol_fee::ProtocolFeeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn scheduler(&self) -> api::scheduler::SchedulerQueryApi<'api> {
    api::scheduler::SchedulerQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn settlement(&self) -> api::settlement::SettlementQueryApi<'api> {
    api::settlement::SettlementQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn statistics(&self) -> api::statistics::StatisticsQueryApi<'api> {
    api::statistics::StatisticsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn sto(&self) -> api::sto::StoQueryApi<'api> {
    api::sto::StoQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn treasury(&self) -> api::treasury::TreasuryQueryApi<'api> {
    api::treasury::TreasuryQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn utility(&self) -> api::utility::UtilityQueryApi<'api> {
    api::utility::UtilityQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn base(&self) -> api::base::BaseQueryApi<'api> {
    api::base::BaseQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn external_agents(&self) -> api::external_agents::ExternalAgentsQueryApi<'api> {
    api::external_agents::ExternalAgentsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn relayer(&self) -> api::relayer::RelayerQueryApi<'api> {
    api::relayer::RelayerQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn contracts(&self) -> api::contracts::ContractsQueryApi<'api> {
    api::contracts::ContractsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn polymesh_contracts(&self) -> api::polymesh_contracts::PolymeshContractsQueryApi<'api> {
    api::polymesh_contracts::PolymeshContractsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn preimage(&self) -> api::preimage::PreimageQueryApi<'api> {
    api::preimage::PreimageQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn nft(&self) -> api::nft::NftQueryApi<'api> {
    api::nft::NftQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn election_provider_multi_phase(
    &self,
  ) -> api::election_provider_multi_phase::ElectionProviderMultiPhaseQueryApi<'api> {
    api::election_provider_multi_phase::ElectionProviderMultiPhaseQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
}
#[derive(Clone)]
#[cfg(not(feature = "ink"))]
pub struct PagedQueryApi<'api> {
  api: &'api Api,
  at: Option<::polymesh_api_client::BlockHash>,
}
#[cfg(not(feature = "ink"))]
impl<'api> PagedQueryApi<'api> {
  #[cfg(not(feature = "ink"))]
  pub fn system(&self) -> api::system::SystemPagedQueryApi<'api> {
    api::system::SystemPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn babe(&self) -> api::babe::BabePagedQueryApi<'api> {
    api::babe::BabePagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn timestamp(&self) -> api::timestamp::TimestampPagedQueryApi<'api> {
    api::timestamp::TimestampPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn indices(&self) -> api::indices::IndicesPagedQueryApi<'api> {
    api::indices::IndicesPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn authorship(&self) -> api::authorship::AuthorshipPagedQueryApi<'api> {
    api::authorship::AuthorshipPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn balances(&self) -> api::balances::BalancesPagedQueryApi<'api> {
    api::balances::BalancesPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn transaction_payment(
    &self,
  ) -> api::transaction_payment::TransactionPaymentPagedQueryApi<'api> {
    api::transaction_payment::TransactionPaymentPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn identity(&self) -> api::identity::IdentityPagedQueryApi<'api> {
    api::identity::IdentityPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn cdd_service_providers(
    &self,
  ) -> api::cdd_service_providers::CddServiceProvidersPagedQueryApi<'api> {
    api::cdd_service_providers::CddServiceProvidersPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn polymesh_committee(
    &self,
  ) -> api::polymesh_committee::PolymeshCommitteePagedQueryApi<'api> {
    api::polymesh_committee::PolymeshCommitteePagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn committee_membership(
    &self,
  ) -> api::committee_membership::CommitteeMembershipPagedQueryApi<'api> {
    api::committee_membership::CommitteeMembershipPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn technical_committee(
    &self,
  ) -> api::technical_committee::TechnicalCommitteePagedQueryApi<'api> {
    api::technical_committee::TechnicalCommitteePagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn technical_committee_membership(
    &self,
  ) -> api::technical_committee_membership::TechnicalCommitteeMembershipPagedQueryApi<'api> {
    api::technical_committee_membership::TechnicalCommitteeMembershipPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn upgrade_committee(&self) -> api::upgrade_committee::UpgradeCommitteePagedQueryApi<'api> {
    api::upgrade_committee::UpgradeCommitteePagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn upgrade_committee_membership(
    &self,
  ) -> api::upgrade_committee_membership::UpgradeCommitteeMembershipPagedQueryApi<'api> {
    api::upgrade_committee_membership::UpgradeCommitteeMembershipPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn multi_sig(&self) -> api::multi_sig::MultiSigPagedQueryApi<'api> {
    api::multi_sig::MultiSigPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn bridge(&self) -> api::bridge::BridgePagedQueryApi<'api> {
    api::bridge::BridgePagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn staking(&self) -> api::staking::StakingPagedQueryApi<'api> {
    api::staking::StakingPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn offences(&self) -> api::offences::OffencesPagedQueryApi<'api> {
    api::offences::OffencesPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn session(&self) -> api::session::SessionPagedQueryApi<'api> {
    api::session::SessionPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn authority_discovery(
    &self,
  ) -> api::authority_discovery::AuthorityDiscoveryPagedQueryApi<'api> {
    api::authority_discovery::AuthorityDiscoveryPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn grandpa(&self) -> api::grandpa::GrandpaPagedQueryApi<'api> {
    api::grandpa::GrandpaPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn historical(&self) -> api::historical::HistoricalPagedQueryApi<'api> {
    api::historical::HistoricalPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn im_online(&self) -> api::im_online::ImOnlinePagedQueryApi<'api> {
    api::im_online::ImOnlinePagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn randomness_collective_flip(
    &self,
  ) -> api::randomness_collective_flip::RandomnessCollectiveFlipPagedQueryApi<'api> {
    api::randomness_collective_flip::RandomnessCollectiveFlipPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn asset(&self) -> api::asset::AssetPagedQueryApi<'api> {
    api::asset::AssetPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn capital_distribution(
    &self,
  ) -> api::capital_distribution::CapitalDistributionPagedQueryApi<'api> {
    api::capital_distribution::CapitalDistributionPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn checkpoint(&self) -> api::checkpoint::CheckpointPagedQueryApi<'api> {
    api::checkpoint::CheckpointPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn compliance_manager(
    &self,
  ) -> api::compliance_manager::ComplianceManagerPagedQueryApi<'api> {
    api::compliance_manager::ComplianceManagerPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn corporate_action(&self) -> api::corporate_action::CorporateActionPagedQueryApi<'api> {
    api::corporate_action::CorporateActionPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn corporate_ballot(&self) -> api::corporate_ballot::CorporateBallotPagedQueryApi<'api> {
    api::corporate_ballot::CorporateBallotPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn permissions(&self) -> api::permissions::PermissionsPagedQueryApi<'api> {
    api::permissions::PermissionsPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn pips(&self) -> api::pips::PipsPagedQueryApi<'api> {
    api::pips::PipsPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn portfolio(&self) -> api::portfolio::PortfolioPagedQueryApi<'api> {
    api::portfolio::PortfolioPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn protocol_fee(&self) -> api::protocol_fee::ProtocolFeePagedQueryApi<'api> {
    api::protocol_fee::ProtocolFeePagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn scheduler(&self) -> api::scheduler::SchedulerPagedQueryApi<'api> {
    api::scheduler::SchedulerPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn settlement(&self) -> api::settlement::SettlementPagedQueryApi<'api> {
    api::settlement::SettlementPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn statistics(&self) -> api::statistics::StatisticsPagedQueryApi<'api> {
    api::statistics::StatisticsPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn sto(&self) -> api::sto::StoPagedQueryApi<'api> {
    api::sto::StoPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn treasury(&self) -> api::treasury::TreasuryPagedQueryApi<'api> {
    api::treasury::TreasuryPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn utility(&self) -> api::utility::UtilityPagedQueryApi<'api> {
    api::utility::UtilityPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn base(&self) -> api::base::BasePagedQueryApi<'api> {
    api::base::BasePagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn external_agents(&self) -> api::external_agents::ExternalAgentsPagedQueryApi<'api> {
    api::external_agents::ExternalAgentsPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn relayer(&self) -> api::relayer::RelayerPagedQueryApi<'api> {
    api::relayer::RelayerPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn contracts(&self) -> api::contracts::ContractsPagedQueryApi<'api> {
    api::contracts::ContractsPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn polymesh_contracts(
    &self,
  ) -> api::polymesh_contracts::PolymeshContractsPagedQueryApi<'api> {
    api::polymesh_contracts::PolymeshContractsPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn preimage(&self) -> api::preimage::PreimagePagedQueryApi<'api> {
    api::preimage::PreimagePagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn nft(&self) -> api::nft::NftPagedQueryApi<'api> {
    api::nft::NftPagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn election_provider_multi_phase(
    &self,
  ) -> api::election_provider_multi_phase::ElectionProviderMultiPhasePagedQueryApi<'api> {
    api::election_provider_multi_phase::ElectionProviderMultiPhasePagedQueryApi {
      api: self.api,
      at: self.at,
    }
  }
}
