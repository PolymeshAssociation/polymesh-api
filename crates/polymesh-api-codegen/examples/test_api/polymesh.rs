#[allow(dead_code, unused_imports, non_camel_case_types)]
pub mod types {
  use super::WrappedCall;
  pub mod pallet_babe {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum BabeError {
        #[doc = "An equivocation proof provided as part of an equivocation report is invalid."]
        #[codec(index = 0u8)]
        InvalidEquivocationProof,
        #[doc = "A key ownership proof provided as part of an equivocation report is invalid."]
        #[codec(index = 1u8)]
        InvalidKeyOwnershipProof,
        #[doc = "A given equivocation report is valid but already previously reported."]
        #[codec(index = 2u8)]
        DuplicateOffenceReport,
        #[doc = "Submitted configuration is invalid."]
        #[codec(index = 3u8)]
        InvalidConfiguration,
      }
      impl BabeError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidEquivocationProof => "Babe.InvalidEquivocationProof",
            Self::InvalidKeyOwnershipProof => "Babe.InvalidKeyOwnershipProof",
            Self::DuplicateOffenceReport => "Babe.DuplicateOffenceReport",
            Self::InvalidConfiguration => "Babe.InvalidConfiguration",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for BabeError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidEquivocationProof => {
              &["An equivocation proof provided as part of an equivocation report is invalid."]
            }
            Self::InvalidKeyOwnershipProof => {
              &["A key ownership proof provided as part of an equivocation report is invalid."]
            }
            Self::DuplicateOffenceReport => {
              &["A given equivocation report is valid but already previously reported."]
            }
            Self::InvalidConfiguration => &["Submitted configuration is invalid."],
            _ => &[""],
          }
        }
      }
      impl From<BabeError> for &'static str {
        fn from(v: BabeError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&BabeError> for &'static str {
        fn from(v: &BabeError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum BabeCall {
        #[doc = "Report authority equivocation/misbehavior. This method will verify"]
        #[doc = "the equivocation proof and validate the given key ownership proof"]
        #[doc = "against the extracted offender. If both are valid, the offence will"]
        #[doc = "be reported."]
        #[codec(index = 0u8)]
        report_equivocation {
          equivocation_proof: ::alloc::boxed::Box<
            sp_consensus_slots::EquivocationProof<
              sp_runtime::generic::header::Header<u32, sp_runtime::traits::BlakeTwo256>,
              sp_consensus_babe::app::Public,
            >,
          >,
          key_owner_proof: sp_session::MembershipProof,
        },
        #[doc = "Report authority equivocation/misbehavior. This method will verify"]
        #[doc = "the equivocation proof and validate the given key ownership proof"]
        #[doc = "against the extracted offender. If both are valid, the offence will"]
        #[doc = "be reported."]
        #[doc = "This extrinsic must be called unsigned and it is expected that only"]
        #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
        #[doc = "if the block author is defined it will be defined as the equivocation"]
        #[doc = "reporter."]
        #[codec(index = 1u8)]
        report_equivocation_unsigned {
          equivocation_proof: ::alloc::boxed::Box<
            sp_consensus_slots::EquivocationProof<
              sp_runtime::generic::header::Header<u32, sp_runtime::traits::BlakeTwo256>,
              sp_consensus_babe::app::Public,
            >,
          >,
          key_owner_proof: sp_session::MembershipProof,
        },
        #[doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"]
        #[doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."]
        #[doc = "Multiple calls to this method will replace any existing planned config change that had"]
        #[doc = "not been enacted yet."]
        #[codec(index = 2u8)]
        plan_config_change {
          config: sp_consensus_babe::digests::NextConfigDescriptor,
        },
      }
      impl BabeCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::report_equivocation { .. } => "Babe.report_equivocation",
            Self::report_equivocation_unsigned { .. } => "Babe.report_equivocation_unsigned",
            Self::plan_config_change { .. } => "Babe.plan_config_change",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for BabeCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: report_equivocation { .. } => { & ["Report authority equivocation/misbehavior. This method will verify" , "the equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence will" , "be reported." ,] } , Self :: report_equivocation_unsigned { .. } => { & ["Report authority equivocation/misbehavior. This method will verify" , "the equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence will" , "be reported." , "This extrinsic must be called unsigned and it is expected that only" , "block authors will call it (validated in `ValidateUnsigned`), as such" , "if the block author is defined it will be defined as the equivocation" , "reporter." ,] } , Self :: plan_config_change { .. } => { & ["Plan an epoch config change. The epoch config change is recorded and will be enacted on" , "the next call to `enact_epoch_change`. The config will be activated one epoch after." , "Multiple calls to this method will replace any existing planned config change that had" , "not been enacted yet." ,] } , _ => & [""] , }
        }
      }
      impl From<BabeCall> for &'static str {
        fn from(v: BabeCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&BabeCall> for &'static str {
        fn from(v: &BabeCall) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod sp_session {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct MembershipProof {
      pub session: u32,
      pub trie_nodes: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
      pub validator_count: u32,
    }
  }
  pub mod pallet_committee {
    use super::*;
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum UpgradeCommitteeEvent<Hash, BlockNumber, I> {
      #[doc = "A motion (given hash) has been proposed (by given account) with a threshold (given `MemberCount`)."]
      #[doc = "Parameters: caller DID, proposal index, proposal hash."]
      #[codec(index = 0u8)]
      Proposed(::polymesh_api_client::IdentityId, BlockNumber, Hash),
      #[doc = "A motion (given hash) has been voted on by given account, leaving"]
      #[doc = "a tally (yes votes, no votes and total seats given respectively as `MemberCount`)."]
      #[doc = "caller DID, Proposal index, Proposal hash, current vote, yay vote count, nay vote count, total seats."]
      #[codec(index = 1u8)]
      Voted(
        ::polymesh_api_client::IdentityId,
        BlockNumber,
        Hash,
        bool,
        BlockNumber,
        BlockNumber,
        BlockNumber,
      ),
      #[doc = "A vote on a motion (given hash) has been retracted."]
      #[doc = "caller DID, ProposalIndex, Proposal hash, vote that was retracted"]
      #[codec(index = 2u8)]
      VoteRetracted(::polymesh_api_client::IdentityId, BlockNumber, Hash, bool),
      #[doc = "Final votes on a motion (given hash)"]
      #[doc = "caller DID, ProposalIndex, Proposal hash, yes voters, no voter"]
      #[codec(index = 3u8)]
      FinalVotes(
        ::polymesh_api_client::IdentityId,
        BlockNumber,
        Hash,
        ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
        ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ),
      #[doc = "A motion was approved by the required threshold with the following"]
      #[doc = "tally (yes votes, no votes and total seats given respectively as `MemberCount`)."]
      #[doc = "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats."]
      #[codec(index = 4u8)]
      Approved(
        ::polymesh_api_client::IdentityId,
        Hash,
        BlockNumber,
        BlockNumber,
        BlockNumber,
      ),
      #[doc = "A motion was rejected by the required threshold with the following"]
      #[doc = "tally (yes votes, no votes and total seats given respectively as `MemberCount`)."]
      #[doc = "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats."]
      #[codec(index = 5u8)]
      Rejected(
        ::polymesh_api_client::IdentityId,
        Hash,
        BlockNumber,
        BlockNumber,
        BlockNumber,
      ),
      #[doc = "A motion was executed; `DispatchResult` is `Ok(())` if returned without error."]
      #[doc = "Parameters: caller DID, proposal hash, result of proposal dispatch."]
      #[codec(index = 6u8)]
      Executed(
        ::polymesh_api_client::IdentityId,
        Hash,
        Result<(), sp_runtime::DispatchError>,
      ),
      #[doc = "Release coordinator has been updated."]
      #[doc = "Parameters: caller DID, DID of the release coordinator."]
      #[codec(index = 7u8)]
      ReleaseCoordinatorUpdated(
        ::polymesh_api_client::IdentityId,
        Option<::polymesh_api_client::IdentityId>,
      ),
      #[doc = "Proposal expiry time has been updated."]
      #[doc = "Parameters: caller DID, new expiry time (if any)."]
      #[codec(index = 8u8)]
      ExpiresAfterUpdated(
        ::polymesh_api_client::IdentityId,
        polymesh_common_utilities::MaybeBlock<BlockNumber>,
      ),
      #[doc = "Voting threshold has been updated"]
      #[doc = "Parameters: caller DID, numerator, denominator"]
      #[codec(index = 9u8)]
      VoteThresholdUpdated(::polymesh_api_client::IdentityId, BlockNumber, BlockNumber),
      PhantomDataVariant(core::marker::PhantomData<I>),
    }
    impl<Hash, BlockNumber, I> UpgradeCommitteeEvent<Hash, BlockNumber, I> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::Proposed(_, _, _) => "UpgradeCommittee.Proposed",
          Self::Voted(_, _, _, _, _, _, _) => "UpgradeCommittee.Voted",
          Self::VoteRetracted(_, _, _, _) => "UpgradeCommittee.VoteRetracted",
          Self::FinalVotes(_, _, _, _, _) => "UpgradeCommittee.FinalVotes",
          Self::Approved(_, _, _, _, _) => "UpgradeCommittee.Approved",
          Self::Rejected(_, _, _, _, _) => "UpgradeCommittee.Rejected",
          Self::Executed(_, _, _) => "UpgradeCommittee.Executed",
          Self::ReleaseCoordinatorUpdated(_, _) => "UpgradeCommittee.ReleaseCoordinatorUpdated",
          Self::ExpiresAfterUpdated(_, _) => "UpgradeCommittee.ExpiresAfterUpdated",
          Self::VoteThresholdUpdated(_, _, _) => "UpgradeCommittee.VoteThresholdUpdated",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<Hash, BlockNumber, I> ::polymesh_api_client::EnumInfo
      for UpgradeCommitteeEvent<Hash, BlockNumber, I>
    {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: Proposed (_ , _ , _) => { & ["A motion (given hash) has been proposed (by given account) with a threshold (given `MemberCount`)." , "Parameters: caller DID, proposal index, proposal hash." ,] } , Self :: Voted (_ , _ , _ , _ , _ , _ , _) => { & ["A motion (given hash) has been voted on by given account, leaving" , "a tally (yes votes, no votes and total seats given respectively as `MemberCount`)." , "caller DID, Proposal index, Proposal hash, current vote, yay vote count, nay vote count, total seats." ,] } , Self :: VoteRetracted (_ , _ , _ , _) => { & ["A vote on a motion (given hash) has been retracted." , "caller DID, ProposalIndex, Proposal hash, vote that was retracted" ,] } , Self :: FinalVotes (_ , _ , _ , _ , _) => { & ["Final votes on a motion (given hash)" , "caller DID, ProposalIndex, Proposal hash, yes voters, no voter" ,] } , Self :: Approved (_ , _ , _ , _ , _) => { & ["A motion was approved by the required threshold with the following" , "tally (yes votes, no votes and total seats given respectively as `MemberCount`)." , "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats." ,] } , Self :: Rejected (_ , _ , _ , _ , _) => { & ["A motion was rejected by the required threshold with the following" , "tally (yes votes, no votes and total seats given respectively as `MemberCount`)." , "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats." ,] } , Self :: Executed (_ , _ , _) => { & ["A motion was executed; `DispatchResult` is `Ok(())` if returned without error." , "Parameters: caller DID, proposal hash, result of proposal dispatch." ,] } , Self :: ReleaseCoordinatorUpdated (_ , _) => { & ["Release coordinator has been updated." , "Parameters: caller DID, DID of the release coordinator." ,] } , Self :: ExpiresAfterUpdated (_ , _) => { & ["Proposal expiry time has been updated." , "Parameters: caller DID, new expiry time (if any)." ,] } , Self :: VoteThresholdUpdated (_ , _ , _) => { & ["Voting threshold has been updated" , "Parameters: caller DID, numerator, denominator" ,] } , _ => & [""] , }
      }
    }
    impl<Hash, BlockNumber, I> From<UpgradeCommitteeEvent<Hash, BlockNumber, I>> for &'static str {
      fn from(v: UpgradeCommitteeEvent<Hash, BlockNumber, I>) -> Self {
        v.as_static_str()
      }
    }
    impl<Hash, BlockNumber, I> From<&UpgradeCommitteeEvent<Hash, BlockNumber, I>> for &'static str {
      fn from(v: &UpgradeCommitteeEvent<Hash, BlockNumber, I>) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance3();
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum UpgradeCommitteeCall {
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[codec(index = 0u8)]
      set_vote_threshold { n: u32, d: u32 },
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[codec(index = 1u8)]
      set_release_coordinator {
        id: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[codec(index = 2u8)]
      set_expires_after {
        expiry: polymesh_common_utilities::MaybeBlock<u32>,
      },
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[codec(index = 3u8)]
      vote_or_propose {
        approve: bool,
        call: ::alloc::boxed::Box<runtime::RuntimeCall>,
      },
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[codec(index = 4u8)]
      vote {
        proposal: primitive_types::H256,
        index: u32,
        approve: bool,
      },
    }
    impl UpgradeCommitteeCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_vote_threshold { .. } => "UpgradeCommittee.set_vote_threshold",
          Self::set_release_coordinator { .. } => "UpgradeCommittee.set_release_coordinator",
          Self::set_expires_after { .. } => "UpgradeCommittee.set_expires_after",
          Self::vote_or_propose { .. } => "UpgradeCommittee.vote_or_propose",
          Self::vote { .. } => "UpgradeCommittee.vote",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_vote_threshold { .. } => { & ["Change the vote threshold the determines the winning proposal." , "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"." , "" , "# Arguments" , "* `n` - Numerator of the fraction representing vote threshold." , "* `d` - Denominator of the fraction representing vote threshold." ,] } , Self :: set_release_coordinator { .. } => { & ["Changes the release coordinator." , "" , "# Arguments" , "* `id` - The DID of the new release coordinator." , "" , "# Errors" , "* `NotAMember`, If the new coordinator `id` is not part of the committee." ,] } , Self :: set_expires_after { .. } => { & ["Changes the time after which a proposal expires." , "" , "# Arguments" , "* `expiry` - The new expiry time." ,] } , Self :: vote_or_propose { .. } => { & ["Proposes to the committee that `call` should be executed in its name." , "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed," , "then this call counts as a vote, i.e., as if `vote_by_hash` was called." , "" , "# Weight" , "" , "The weight of this dispatchable is that of `call` as well as the complexity" , "for recording the vote itself." , "" , "# Arguments" , "* `approve` - is this an approving vote?" , "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`." , "* `call` - the call to propose for execution." , "" , "# Errors" , "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`." , "* `NotAMember`, if the `origin` is not a member of this committee." ,] } , Self :: vote { .. } => { & ["Votes `approve`ingly (or not, if `false`)" , "on an existing `proposal` given by its hash, `index`." , "" , "# Arguments" , "* `proposal` - A hash of the proposal to be voted on." , "* `index` - The proposal index." , "* `approve` - If `true` than this is a `for` vote, and `against` otherwise." , "" , "# Errors" , "* `NotAMember`, if the `origin` is not a member of this committee." ,] } , _ => & [""] , }
      }
    }
    impl From<UpgradeCommitteeCall> for &'static str {
      fn from(v: UpgradeCommitteeCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&UpgradeCommitteeCall> for &'static str {
      fn from(v: &UpgradeCommitteeCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RawOrigin<AccountId, I> {
      #[codec(index = 0u8)]
      Endorsed,
      PhantomDataVariant(core::marker::PhantomData<(AccountId, I)>),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum UpgradeCommitteeError {
      #[doc = "Duplicate votes are not allowed."]
      #[codec(index = 0u8)]
      DuplicateVote,
      #[doc = "A DID isn't part of the committee."]
      #[doc = "The DID may either be a caller or some other context."]
      #[codec(index = 1u8)]
      NotAMember,
      #[doc = "No such proposal."]
      #[codec(index = 2u8)]
      NoSuchProposal,
      #[doc = "Proposal exists, but it has expired."]
      #[codec(index = 3u8)]
      ProposalExpired,
      #[doc = "Duplicate proposal."]
      #[codec(index = 4u8)]
      DuplicateProposal,
      #[doc = "Mismatched voting index."]
      #[codec(index = 5u8)]
      MismatchedVotingIndex,
      #[doc = "Proportion must be a rational number."]
      #[codec(index = 6u8)]
      InvalidProportion,
      #[doc = "First vote on a proposal creates it, so it must be an approval."]
      #[doc = "All proposals are motions to execute something as \"GC majority\"."]
      #[doc = "To reject e.g., a PIP, a motion to reject should be *approved*."]
      #[codec(index = 7u8)]
      FirstVoteReject,
      #[doc = "Maximum number of proposals has been reached."]
      #[codec(index = 8u8)]
      ProposalsLimitReached,
    }
    impl UpgradeCommitteeError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::DuplicateVote => "UpgradeCommittee.DuplicateVote",
          Self::NotAMember => "UpgradeCommittee.NotAMember",
          Self::NoSuchProposal => "UpgradeCommittee.NoSuchProposal",
          Self::ProposalExpired => "UpgradeCommittee.ProposalExpired",
          Self::DuplicateProposal => "UpgradeCommittee.DuplicateProposal",
          Self::MismatchedVotingIndex => "UpgradeCommittee.MismatchedVotingIndex",
          Self::InvalidProportion => "UpgradeCommittee.InvalidProportion",
          Self::FirstVoteReject => "UpgradeCommittee.FirstVoteReject",
          Self::ProposalsLimitReached => "UpgradeCommittee.ProposalsLimitReached",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::DuplicateVote => &["Duplicate votes are not allowed."],
          Self::NotAMember => &[
            "A DID isn't part of the committee.",
            "The DID may either be a caller or some other context.",
          ],
          Self::NoSuchProposal => &["No such proposal."],
          Self::ProposalExpired => &["Proposal exists, but it has expired."],
          Self::DuplicateProposal => &["Duplicate proposal."],
          Self::MismatchedVotingIndex => &["Mismatched voting index."],
          Self::InvalidProportion => &["Proportion must be a rational number."],
          Self::FirstVoteReject => &[
            "First vote on a proposal creates it, so it must be an approval.",
            "All proposals are motions to execute something as \"GC majority\".",
            "To reject e.g., a PIP, a motion to reject should be *approved*.",
          ],
          Self::ProposalsLimitReached => &["Maximum number of proposals has been reached."],
          _ => &[""],
        }
      }
    }
    impl From<UpgradeCommitteeError> for &'static str {
      fn from(v: UpgradeCommitteeError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&UpgradeCommitteeError> for &'static str {
      fn from(v: &UpgradeCommitteeError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PolymeshVotes<BlockNumber> {
      pub index: BlockNumber,
      pub ayes: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      pub nays: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      pub expiry: polymesh_common_utilities::MaybeBlock<BlockNumber>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance1();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance4();
  }
  pub mod pallet_bridge {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum HandledTxStatus {
      #[codec(index = 0u8)]
      Success,
      #[codec(index = 1u8)]
      Error(::alloc::vec::Vec<u8>),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct BridgeTx<Account> {
      pub nonce: u32,
      pub recipient: Account,
      pub amount: u128,
      pub tx_hash: primitive_types::H256,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BridgeTxStatus {
      #[codec(index = 0u8)]
      Absent,
      #[codec(index = 1u8)]
      Pending(u8),
      #[codec(index = 2u8)]
      Frozen,
      #[codec(index = 3u8)]
      Timelocked,
      #[codec(index = 4u8)]
      Handled,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BridgeError {
      #[doc = "The bridge controller address is not set."]
      #[codec(index = 0u8)]
      ControllerNotSet,
      #[doc = "The origin is not the controller or the admin address."]
      #[codec(index = 1u8)]
      BadCaller,
      #[doc = "The origin is not the admin address."]
      #[codec(index = 2u8)]
      BadAdmin,
      #[doc = "The recipient DID has no valid CDD."]
      #[codec(index = 3u8)]
      NoValidCdd,
      #[doc = "The bridge transaction proposal has already been handled and the funds minted."]
      #[codec(index = 4u8)]
      ProposalAlreadyHandled,
      #[doc = "Unauthorized to perform an operation."]
      #[codec(index = 5u8)]
      Unauthorized,
      #[doc = "The bridge is already frozen."]
      #[codec(index = 6u8)]
      Frozen,
      #[doc = "The bridge is not frozen."]
      #[codec(index = 7u8)]
      NotFrozen,
      #[doc = "The transaction is frozen."]
      #[codec(index = 8u8)]
      FrozenTx,
      #[doc = "The identity's minted total has reached the bridge limit."]
      #[codec(index = 9u8)]
      BridgeLimitReached,
      #[doc = "The identity's minted total has overflowed."]
      #[codec(index = 10u8)]
      Overflow,
      #[doc = "The block interval duration is zero. Cannot divide."]
      #[codec(index = 11u8)]
      DivisionByZero,
      #[doc = "The transaction is timelocked."]
      #[codec(index = 12u8)]
      TimelockedTx,
    }
    impl BridgeError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::ControllerNotSet => "Bridge.ControllerNotSet",
          Self::BadCaller => "Bridge.BadCaller",
          Self::BadAdmin => "Bridge.BadAdmin",
          Self::NoValidCdd => "Bridge.NoValidCdd",
          Self::ProposalAlreadyHandled => "Bridge.ProposalAlreadyHandled",
          Self::Unauthorized => "Bridge.Unauthorized",
          Self::Frozen => "Bridge.Frozen",
          Self::NotFrozen => "Bridge.NotFrozen",
          Self::FrozenTx => "Bridge.FrozenTx",
          Self::BridgeLimitReached => "Bridge.BridgeLimitReached",
          Self::Overflow => "Bridge.Overflow",
          Self::DivisionByZero => "Bridge.DivisionByZero",
          Self::TimelockedTx => "Bridge.TimelockedTx",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for BridgeError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::ControllerNotSet => &["The bridge controller address is not set."],
          Self::BadCaller => &["The origin is not the controller or the admin address."],
          Self::BadAdmin => &["The origin is not the admin address."],
          Self::NoValidCdd => &["The recipient DID has no valid CDD."],
          Self::ProposalAlreadyHandled => {
            &["The bridge transaction proposal has already been handled and the funds minted."]
          }
          Self::Unauthorized => &["Unauthorized to perform an operation."],
          Self::Frozen => &["The bridge is already frozen."],
          Self::NotFrozen => &["The bridge is not frozen."],
          Self::FrozenTx => &["The transaction is frozen."],
          Self::BridgeLimitReached => {
            &["The identity's minted total has reached the bridge limit."]
          }
          Self::Overflow => &["The identity's minted total has overflowed."],
          Self::DivisionByZero => &["The block interval duration is zero. Cannot divide."],
          Self::TimelockedTx => &["The transaction is timelocked."],
          _ => &[""],
        }
      }
    }
    impl From<BridgeError> for &'static str {
      fn from(v: BridgeError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&BridgeError> for &'static str {
      fn from(v: &BridgeError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BridgeCall {
      #[doc = "Changes the controller account as admin."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[codec(index = 0u8)]
      change_controller {
        controller: ::polymesh_api_client::AccountId,
      },
      #[doc = "Changes the bridge admin key."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[codec(index = 1u8)]
      change_admin {
        admin: ::polymesh_api_client::AccountId,
      },
      #[doc = "Changes the timelock period."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[codec(index = 2u8)]
      change_timelock { timelock: u32 },
      #[doc = "Freezes transaction handling in the bridge module if it is not already frozen. When the"]
      #[doc = "bridge is frozen, attempted transactions get postponed instead of getting handled."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[codec(index = 3u8)]
      freeze,
      #[doc = "Unfreezes transaction handling in the bridge module if it is frozen."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[codec(index = 4u8)]
      unfreeze,
      #[doc = "Changes the bridge limits."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = "- `DivisionByZero` if `duration` is zero."]
      #[codec(index = 5u8)]
      change_bridge_limit { amount: u128, duration: u32 },
      #[doc = "Changes the bridge limit exempted list."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[codec(index = 6u8)]
      change_bridge_exempted {
        exempted: ::alloc::vec::Vec<(::polymesh_api_client::IdentityId, bool)>,
      },
      #[doc = "Forces handling a transaction by bypassing the bridge limit and timelock."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = "- `NoValidCdd` if `bridge_tx.recipient` does not have a valid CDD claim."]
      #[codec(index = 7u8)]
      force_handle_bridge_tx {
        bridge_tx: pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      },
      #[doc = "Proposes a vector of bridge transactions. The vector is processed until the first"]
      #[doc = "proposal which causes an error, in which case the error is returned and the rest of"]
      #[doc = "proposals are not processed."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `ControllerNotSet` if `Controllers` was not set."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`500_000_000 + 7_000_000 * bridge_txs.len()`"]
      #[codec(index = 8u8)]
      batch_propose_bridge_tx {
        bridge_txs: ::alloc::vec::Vec<pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>>,
      },
      #[doc = "Proposes a bridge transaction, which amounts to making a multisig proposal for the"]
      #[doc = "bridge transaction if the transaction is new or approving an existing proposal if the"]
      #[doc = "transaction has already been proposed."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `ControllerNotSet` if `Controllers` was not set."]
      #[codec(index = 9u8)]
      propose_bridge_tx {
        bridge_tx: pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      },
      #[doc = "Handles an approved bridge transaction proposal."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadCaller` if `origin` is not `Self::controller` or  `Self::admin`."]
      #[doc = "- `TimelockedTx` if the transaction status is `Timelocked`."]
      #[doc = "- `ProposalAlreadyHandled` if the transaction status is `Handled`."]
      #[codec(index = 10u8)]
      handle_bridge_tx {
        bridge_tx: pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      },
      #[doc = "Freezes given bridge transactions."]
      #[doc = "If any bridge txn is already handled then this function will just ignore it and process next one."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`400_000_000 + 2_000_000 * bridge_txs.len()`"]
      #[codec(index = 11u8)]
      freeze_txs {
        bridge_txs: ::alloc::vec::Vec<pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>>,
      },
      #[doc = "Unfreezes given bridge transactions."]
      #[doc = "If any bridge txn is already handled then this function will just ignore it and process next one."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`400_000_000 + 7_000_000 * bridge_txs.len()`"]
      #[codec(index = 12u8)]
      unfreeze_txs {
        bridge_txs: ::alloc::vec::Vec<pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>>,
      },
      #[doc = "Root callable extrinsic, used as an internal call to handle a scheduled timelocked bridge transaction."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `BadOrigin` if `origin` is not root."]
      #[doc = "- `ProposalAlreadyHandled` if transaction status is `Handled`."]
      #[doc = "- `FrozenTx` if transaction status is `Frozen`."]
      #[codec(index = 13u8)]
      handle_scheduled_bridge_tx {
        bridge_tx: pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      },
      #[doc = "Add a freeze admin."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[codec(index = 14u8)]
      add_freeze_admin {
        freeze_admin: ::polymesh_api_client::AccountId,
      },
      #[doc = "Remove a freeze admin."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[codec(index = 15u8)]
      remove_freeze_admin {
        freeze_admin: ::polymesh_api_client::AccountId,
      },
      #[doc = "Remove given bridge transactions."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = "- `NotFrozen` if a tx in `bridge_txs` is not frozen."]
      #[codec(index = 16u8)]
      remove_txs {
        bridge_txs: ::alloc::vec::Vec<pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>>,
      },
    }
    impl BridgeCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::change_controller { .. } => "Bridge.change_controller",
          Self::change_admin { .. } => "Bridge.change_admin",
          Self::change_timelock { .. } => "Bridge.change_timelock",
          Self::freeze => "Bridge.freeze",
          Self::unfreeze => "Bridge.unfreeze",
          Self::change_bridge_limit { .. } => "Bridge.change_bridge_limit",
          Self::change_bridge_exempted { .. } => "Bridge.change_bridge_exempted",
          Self::force_handle_bridge_tx { .. } => "Bridge.force_handle_bridge_tx",
          Self::batch_propose_bridge_tx { .. } => "Bridge.batch_propose_bridge_tx",
          Self::propose_bridge_tx { .. } => "Bridge.propose_bridge_tx",
          Self::handle_bridge_tx { .. } => "Bridge.handle_bridge_tx",
          Self::freeze_txs { .. } => "Bridge.freeze_txs",
          Self::unfreeze_txs { .. } => "Bridge.unfreeze_txs",
          Self::handle_scheduled_bridge_tx { .. } => "Bridge.handle_scheduled_bridge_tx",
          Self::add_freeze_admin { .. } => "Bridge.add_freeze_admin",
          Self::remove_freeze_admin { .. } => "Bridge.remove_freeze_admin",
          Self::remove_txs { .. } => "Bridge.remove_txs",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for BridgeCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: change_controller { .. } => { & ["Changes the controller account as admin." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." ,] } , Self :: change_admin { .. } => { & ["Changes the bridge admin key." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." ,] } , Self :: change_timelock { .. } => { & ["Changes the timelock period." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." ,] } , Self :: freeze => { & ["Freezes transaction handling in the bridge module if it is not already frozen. When the" , "bridge is frozen, attempted transactions get postponed instead of getting handled." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." ,] } , Self :: unfreeze => { & ["Unfreezes transaction handling in the bridge module if it is frozen." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." ,] } , Self :: change_bridge_limit { .. } => { & ["Changes the bridge limits." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." , "- `DivisionByZero` if `duration` is zero." ,] } , Self :: change_bridge_exempted { .. } => { & ["Changes the bridge limit exempted list." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." ,] } , Self :: force_handle_bridge_tx { .. } => { & ["Forces handling a transaction by bypassing the bridge limit and timelock." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." , "- `NoValidCdd` if `bridge_tx.recipient` does not have a valid CDD claim." ,] } , Self :: batch_propose_bridge_tx { .. } => { & ["Proposes a vector of bridge transactions. The vector is processed until the first" , "proposal which causes an error, in which case the error is returned and the rest of" , "proposals are not processed." , "" , "## Errors" , "- `ControllerNotSet` if `Controllers` was not set." , "" , "# Weight" , "`500_000_000 + 7_000_000 * bridge_txs.len()`" ,] } , Self :: propose_bridge_tx { .. } => { & ["Proposes a bridge transaction, which amounts to making a multisig proposal for the" , "bridge transaction if the transaction is new or approving an existing proposal if the" , "transaction has already been proposed." , "" , "## Errors" , "- `ControllerNotSet` if `Controllers` was not set." ,] } , Self :: handle_bridge_tx { .. } => { & ["Handles an approved bridge transaction proposal." , "" , "## Errors" , "- `BadCaller` if `origin` is not `Self::controller` or  `Self::admin`." , "- `TimelockedTx` if the transaction status is `Timelocked`." , "- `ProposalAlreadyHandled` if the transaction status is `Handled`." ,] } , Self :: freeze_txs { .. } => { & ["Freezes given bridge transactions." , "If any bridge txn is already handled then this function will just ignore it and process next one." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." , "" , "# Weight" , "`400_000_000 + 2_000_000 * bridge_txs.len()`" ,] } , Self :: unfreeze_txs { .. } => { & ["Unfreezes given bridge transactions." , "If any bridge txn is already handled then this function will just ignore it and process next one." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." , "" , "# Weight" , "`400_000_000 + 7_000_000 * bridge_txs.len()`" ,] } , Self :: handle_scheduled_bridge_tx { .. } => { & ["Root callable extrinsic, used as an internal call to handle a scheduled timelocked bridge transaction." , "" , "# Errors" , "- `BadOrigin` if `origin` is not root." , "- `ProposalAlreadyHandled` if transaction status is `Handled`." , "- `FrozenTx` if transaction status is `Frozen`." ,] } , Self :: add_freeze_admin { .. } => { & ["Add a freeze admin." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." ,] } , Self :: remove_freeze_admin { .. } => { & ["Remove a freeze admin." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." ,] } , Self :: remove_txs { .. } => { & ["Remove given bridge transactions." , "" , "## Errors" , "- `BadAdmin` if `origin` is not `Self::admin()` account." , "- `NotFrozen` if a tx in `bridge_txs` is not frozen." ,] } , _ => & [""] , }
      }
    }
    impl From<BridgeCall> for &'static str {
      fn from(v: BridgeCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&BridgeCall> for &'static str {
      fn from(v: &BridgeCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct BridgeTxDetail<BlockNumber> {
      pub amount: u128,
      pub status: pallet_bridge::BridgeTxStatus,
      pub execution_block: BlockNumber,
      pub tx_hash: primitive_types::H256,
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BridgeEvent<AccountId, BlockNumber> {
      #[doc = "Confirmation of a signer set change."]
      #[codec(index = 0u8)]
      ControllerChanged(::polymesh_api_client::IdentityId, AccountId),
      #[doc = "Confirmation of Admin change."]
      #[codec(index = 1u8)]
      AdminChanged(::polymesh_api_client::IdentityId, AccountId),
      #[doc = "Confirmation of default timelock change."]
      #[codec(index = 2u8)]
      TimelockChanged(::polymesh_api_client::IdentityId, BlockNumber),
      #[doc = "Confirmation of POLYX upgrade on Polymesh from POLY tokens on Ethereum."]
      #[codec(index = 3u8)]
      Bridged(
        ::polymesh_api_client::IdentityId,
        pallet_bridge::BridgeTx<AccountId>,
      ),
      #[doc = "Notification of freezing the bridge."]
      #[codec(index = 4u8)]
      Frozen(::polymesh_api_client::IdentityId),
      #[doc = "Notification of unfreezing the bridge."]
      #[codec(index = 5u8)]
      Unfrozen(::polymesh_api_client::IdentityId),
      #[doc = "Notification of freezing a transaction."]
      #[codec(index = 6u8)]
      FrozenTx(
        ::polymesh_api_client::IdentityId,
        pallet_bridge::BridgeTx<AccountId>,
      ),
      #[doc = "Notification of unfreezing a transaction."]
      #[codec(index = 7u8)]
      UnfrozenTx(
        ::polymesh_api_client::IdentityId,
        pallet_bridge::BridgeTx<AccountId>,
      ),
      #[doc = "Exemption status of an identity has been updated."]
      #[codec(index = 8u8)]
      ExemptedUpdated(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::IdentityId,
        bool,
      ),
      #[doc = "Bridge limit has been updated."]
      #[codec(index = 9u8)]
      BridgeLimitUpdated(::polymesh_api_client::IdentityId, u128, BlockNumber),
      #[doc = "An event emitted after a vector of transactions is handled. The parameter is a vector of"]
      #[doc = "tuples of recipient account, its nonce, and the status of the processed transaction."]
      #[codec(index = 10u8)]
      TxsHandled(::alloc::vec::Vec<(AccountId, BlockNumber, pallet_bridge::HandledTxStatus)>),
      #[doc = "Bridge Tx Scheduled."]
      #[codec(index = 11u8)]
      BridgeTxScheduled(
        ::polymesh_api_client::IdentityId,
        pallet_bridge::BridgeTx<AccountId>,
        BlockNumber,
      ),
      #[doc = "Failed to schedule Bridge Tx."]
      #[codec(index = 12u8)]
      BridgeTxScheduleFailed(
        ::polymesh_api_client::IdentityId,
        pallet_bridge::BridgeTx<AccountId>,
        ::alloc::vec::Vec<u8>,
      ),
      #[doc = "A new freeze admin has been added."]
      #[codec(index = 13u8)]
      FreezeAdminAdded(::polymesh_api_client::IdentityId, AccountId),
      #[doc = "A freeze admin has been removed."]
      #[codec(index = 14u8)]
      FreezeAdminRemoved(::polymesh_api_client::IdentityId, AccountId),
      #[doc = "Notification of removing a transaction."]
      #[codec(index = 15u8)]
      TxRemoved(
        ::polymesh_api_client::IdentityId,
        pallet_bridge::BridgeTx<AccountId>,
      ),
      #[doc = "Bridge Tx failed.  Recipient missing CDD or limit reached."]
      #[codec(index = 16u8)]
      BridgeTxFailed(
        ::polymesh_api_client::IdentityId,
        pallet_bridge::BridgeTx<AccountId>,
        sp_runtime::DispatchError,
      ),
    }
    impl<AccountId, BlockNumber> BridgeEvent<AccountId, BlockNumber> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::ControllerChanged(_, _) => "Bridge.ControllerChanged",
          Self::AdminChanged(_, _) => "Bridge.AdminChanged",
          Self::TimelockChanged(_, _) => "Bridge.TimelockChanged",
          Self::Bridged(_, _) => "Bridge.Bridged",
          Self::Frozen(_) => "Bridge.Frozen",
          Self::Unfrozen(_) => "Bridge.Unfrozen",
          Self::FrozenTx(_, _) => "Bridge.FrozenTx",
          Self::UnfrozenTx(_, _) => "Bridge.UnfrozenTx",
          Self::ExemptedUpdated(_, _, _) => "Bridge.ExemptedUpdated",
          Self::BridgeLimitUpdated(_, _, _) => "Bridge.BridgeLimitUpdated",
          Self::TxsHandled(_) => "Bridge.TxsHandled",
          Self::BridgeTxScheduled(_, _, _) => "Bridge.BridgeTxScheduled",
          Self::BridgeTxScheduleFailed(_, _, _) => "Bridge.BridgeTxScheduleFailed",
          Self::FreezeAdminAdded(_, _) => "Bridge.FreezeAdminAdded",
          Self::FreezeAdminRemoved(_, _) => "Bridge.FreezeAdminRemoved",
          Self::TxRemoved(_, _) => "Bridge.TxRemoved",
          Self::BridgeTxFailed(_, _, _) => "Bridge.BridgeTxFailed",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<AccountId, BlockNumber> ::polymesh_api_client::EnumInfo
      for BridgeEvent<AccountId, BlockNumber>
    {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: ControllerChanged (_ , _) => { & ["Confirmation of a signer set change." ,] } , Self :: AdminChanged (_ , _) => { & ["Confirmation of Admin change." ,] } , Self :: TimelockChanged (_ , _) => { & ["Confirmation of default timelock change." ,] } , Self :: Bridged (_ , _) => { & ["Confirmation of POLYX upgrade on Polymesh from POLY tokens on Ethereum." ,] } , Self :: Frozen (_) => { & ["Notification of freezing the bridge." ,] } , Self :: Unfrozen (_) => { & ["Notification of unfreezing the bridge." ,] } , Self :: FrozenTx (_ , _) => { & ["Notification of freezing a transaction." ,] } , Self :: UnfrozenTx (_ , _) => { & ["Notification of unfreezing a transaction." ,] } , Self :: ExemptedUpdated (_ , _ , _) => { & ["Exemption status of an identity has been updated." ,] } , Self :: BridgeLimitUpdated (_ , _ , _) => { & ["Bridge limit has been updated." ,] } , Self :: TxsHandled (_) => { & ["An event emitted after a vector of transactions is handled. The parameter is a vector of" , "tuples of recipient account, its nonce, and the status of the processed transaction." ,] } , Self :: BridgeTxScheduled (_ , _ , _) => { & ["Bridge Tx Scheduled." ,] } , Self :: BridgeTxScheduleFailed (_ , _ , _) => { & ["Failed to schedule Bridge Tx." ,] } , Self :: FreezeAdminAdded (_ , _) => { & ["A new freeze admin has been added." ,] } , Self :: FreezeAdminRemoved (_ , _) => { & ["A freeze admin has been removed." ,] } , Self :: TxRemoved (_ , _) => { & ["Notification of removing a transaction." ,] } , Self :: BridgeTxFailed (_ , _ , _) => { & ["Bridge Tx failed.  Recipient missing CDD or limit reached." ,] } , _ => & [""] , }
      }
    }
    impl<AccountId, BlockNumber> From<BridgeEvent<AccountId, BlockNumber>> for &'static str {
      fn from(v: BridgeEvent<AccountId, BlockNumber>) -> Self {
        v.as_static_str()
      }
    }
    impl<AccountId, BlockNumber> From<&BridgeEvent<AccountId, BlockNumber>> for &'static str {
      fn from(v: &BridgeEvent<AccountId, BlockNumber>) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod sp_consensus_grandpa {
    use super::*;
    pub mod app {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Signature(pub sp_core::ed25519::Signature);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Public(pub sp_core::ed25519::Public);
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct EquivocationProof<H, N> {
      pub set_id: u64,
      pub equivocation: sp_consensus_grandpa::Equivocation<H, N>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Equivocation<H, N> {
      #[codec(index = 0u8)]
      Prevote(
        finality_grandpa::Equivocation<
          sp_consensus_grandpa::app::Public,
          finality_grandpa::Prevote<H, N>,
          sp_consensus_grandpa::app::Signature,
        >,
      ),
      #[codec(index = 1u8)]
      Precommit(
        finality_grandpa::Equivocation<
          sp_consensus_grandpa::app::Public,
          finality_grandpa::Precommit<H, N>,
          sp_consensus_grandpa::app::Signature,
        >,
      ),
    }
  }
  pub mod polymesh_contracts {
    use super::*;
    pub mod chain_extension {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ExtrinsicId(pub u8, pub u8);
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PolymeshContractsCall {
      #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code` with the WASM binary defining the smart contract."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[codec(index = 0u8)]
      instantiate_with_code_perms {
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: polymesh_primitives::secondary_key::Permissions,
      },
      #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
      #[doc = ""]
      #[doc = "Unlike `instantiate_with_code`,"]
      #[doc = "this assumes that at least one contract with the same WASM code has already been uploaded."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code_hash` of an already uploaded WASM binary."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[codec(index = 1u8)]
      instantiate_with_hash_perms {
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code_hash: primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: polymesh_primitives::secondary_key::Permissions,
      },
      #[doc = "Update CallRuntime whitelist."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = ""]
      #[doc = "# Errors"]
      #[codec(index = 2u8)]
      update_call_runtime_whitelist {
        updates: ::alloc::vec::Vec<(polymesh_contracts::chain_extension::ExtrinsicId, bool)>,
      },
    }
    impl PolymeshContractsCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::instantiate_with_code_perms { .. } => {
            "PolymeshContracts.instantiate_with_code_perms"
          }
          Self::instantiate_with_hash_perms { .. } => {
            "PolymeshContracts.instantiate_with_hash_perms"
          }
          Self::update_call_runtime_whitelist { .. } => {
            "PolymeshContracts.update_call_runtime_whitelist"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PolymeshContractsCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: instantiate_with_code_perms { .. } => { & ["Instantiates a smart contract defining it with the given `code` and `salt`." , "" , "The contract will be attached as a secondary key," , "with `perms` as its permissions, to `origin`'s identity." , "" , "The contract is transferred `endowment` amount of POLYX." , "This is distinct from the `gas_limit`," , "which controls how much gas the deployment code may at most consume." , "" , "# Arguments" , "- `endowment` amount of POLYX to transfer to the contract." , "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume." , "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved" , "  from the caller to pay for the storage consumed." , "- `code` with the WASM binary defining the smart contract." , "- `data` The input data to pass to the contract constructor." , "- `salt` used for contract address derivation." , "   By varying this, the same `code` can be used under the same identity." , "- `perms` that the new secondary key will have." , "" , "# Errors" , "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here." , "- CDD/Permissions are checked, unlike in `pallet_contracts`." , "- Errors that arise when adding a new secondary key can also occur here." ,] } , Self :: instantiate_with_hash_perms { .. } => { & ["Instantiates a smart contract defining using the given `code_hash` and `salt`." , "" , "Unlike `instantiate_with_code`," , "this assumes that at least one contract with the same WASM code has already been uploaded." , "" , "The contract will be attached as a secondary key," , "with `perms` as its permissions, to `origin`'s identity." , "" , "The contract is transferred `endowment` amount of POLYX." , "This is distinct from the `gas_limit`," , "which controls how much gas the deployment code may at most consume." , "" , "# Arguments" , "- `endowment` amount of POLYX to transfer to the contract." , "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume." , "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved" , "  from the caller to pay for the storage consumed." , "- `code_hash` of an already uploaded WASM binary." , "- `data` The input data to pass to the contract constructor." , "- `salt` used for contract address derivation." , "   By varying this, the same `code` can be used under the same identity." , "- `perms` that the new secondary key will have." , "" , "# Errors" , "- All the errors in `pallet_contracts::Call::instantiate` can also happen here." , "- CDD/Permissions are checked, unlike in `pallet_contracts`." , "- Errors that arise when adding a new secondary key can also occur here." ,] } , Self :: update_call_runtime_whitelist { .. } => { & ["Update CallRuntime whitelist." , "" , "# Arguments" , "" , "# Errors" ,] } , _ => & [""] , }
      }
    }
    impl From<PolymeshContractsCall> for &'static str {
      fn from(v: PolymeshContractsCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PolymeshContractsCall> for &'static str {
      fn from(v: &PolymeshContractsCall) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PolymeshContractsEvent {}
    impl PolymeshContractsEvent {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PolymeshContractsEvent {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          _ => &[""],
        }
      }
    }
    impl From<PolymeshContractsEvent> for &'static str {
      fn from(v: PolymeshContractsEvent) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PolymeshContractsEvent> for &'static str {
      fn from(v: &PolymeshContractsEvent) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PolymeshContractsError {
      #[doc = "Invalid `func_id` provided from contract."]
      #[codec(index = 0u8)]
      InvalidFuncId,
      #[doc = "Failed to decode a valid `RuntimeCall`."]
      #[codec(index = 1u8)]
      InvalidRuntimeCall,
      #[doc = "`ReadStorage` failed to write value into the contract's buffer."]
      #[codec(index = 2u8)]
      ReadStorageFailed,
      #[doc = "Data left in input when decoding arguments of a call."]
      #[codec(index = 3u8)]
      DataLeftAfterDecoding,
      #[doc = "Input data that a contract passed when using the ChainExtension was too large."]
      #[codec(index = 4u8)]
      InLenTooLarge,
      #[doc = "Output data returned from the ChainExtension was too large."]
      #[codec(index = 5u8)]
      OutLenTooLarge,
      #[doc = "A contract was attempted to be instantiated,"]
      #[doc = "but no identity was given to associate the new contract's key with."]
      #[codec(index = 6u8)]
      InstantiatorWithNoIdentity,
      #[doc = "Extrinsic is not allowed to be called by contracts."]
      #[codec(index = 7u8)]
      RuntimeCallDenied,
    }
    impl PolymeshContractsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::InvalidFuncId => "PolymeshContracts.InvalidFuncId",
          Self::InvalidRuntimeCall => "PolymeshContracts.InvalidRuntimeCall",
          Self::ReadStorageFailed => "PolymeshContracts.ReadStorageFailed",
          Self::DataLeftAfterDecoding => "PolymeshContracts.DataLeftAfterDecoding",
          Self::InLenTooLarge => "PolymeshContracts.InLenTooLarge",
          Self::OutLenTooLarge => "PolymeshContracts.OutLenTooLarge",
          Self::InstantiatorWithNoIdentity => "PolymeshContracts.InstantiatorWithNoIdentity",
          Self::RuntimeCallDenied => "PolymeshContracts.RuntimeCallDenied",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PolymeshContractsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::InvalidFuncId => &["Invalid `func_id` provided from contract."],
          Self::InvalidRuntimeCall => &["Failed to decode a valid `RuntimeCall`."],
          Self::ReadStorageFailed => {
            &["`ReadStorage` failed to write value into the contract's buffer."]
          }
          Self::DataLeftAfterDecoding => &["Data left in input when decoding arguments of a call."],
          Self::InLenTooLarge => {
            &["Input data that a contract passed when using the ChainExtension was too large."]
          }
          Self::OutLenTooLarge => &["Output data returned from the ChainExtension was too large."],
          Self::InstantiatorWithNoIdentity => &[
            "A contract was attempted to be instantiated,",
            "but no identity was given to associate the new contract's key with.",
          ],
          Self::RuntimeCallDenied => &["Extrinsic is not allowed to be called by contracts."],
          _ => &[""],
        }
      }
    }
    impl From<PolymeshContractsError> for &'static str {
      fn from(v: PolymeshContractsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PolymeshContractsError> for &'static str {
      fn from(v: &PolymeshContractsError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod sp_npos_elections {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ElectionScore {
      pub minimal_stake: u128,
      pub sum_stake: u128,
      pub sum_stake_squared: u128,
    }
  }
  pub mod pallet_permissions {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct StoreCallMetadata();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PermissionsError {
      #[doc = "The caller is not authorized to call the current extrinsic."]
      #[codec(index = 0u8)]
      UnauthorizedCaller,
    }
    impl PermissionsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::UnauthorizedCaller => "Permissions.UnauthorizedCaller",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PermissionsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::UnauthorizedCaller => {
            &["The caller is not authorized to call the current extrinsic."]
          }
          _ => &[""],
        }
      }
    }
    impl From<PermissionsError> for &'static str {
      fn from(v: PermissionsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PermissionsError> for &'static str {
      fn from(v: &PermissionsError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_nft {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum NftError {
      #[doc = "An overflow while calculating the balance."]
      #[codec(index = 0u8)]
      BalanceOverflow,
      #[doc = "An underflow while calculating the balance."]
      #[codec(index = 1u8)]
      BalanceUnderflow,
      #[doc = "The ticker is already associated to an NFT collection."]
      #[codec(index = 2u8)]
      CollectionAlredyRegistered,
      #[doc = "The NFT collection does not exist."]
      #[codec(index = 3u8)]
      CollectionNotFound,
      #[doc = "A duplicate metadata key has been passed as parameter."]
      #[codec(index = 4u8)]
      DuplicateMetadataKey,
      #[doc = "Duplicate ids are not allowed."]
      #[codec(index = 5u8)]
      DuplicatedNFTId,
      #[doc = "The asset must be of type non-fungible."]
      #[codec(index = 6u8)]
      InvalidAssetType,
      #[doc = "Either the number of keys or the key identifier does not match the keys defined for the collection."]
      #[codec(index = 7u8)]
      InvalidMetadataAttribute,
      #[doc = "Failed to transfer an NFT - NFT collection not found."]
      #[codec(index = 8u8)]
      InvalidNFTTransferCollectionNotFound,
      #[doc = "Failed to transfer an NFT - attempt to move to the same portfolio."]
      #[codec(index = 9u8)]
      InvalidNFTTransferSamePortfolio,
      #[doc = "Failed to transfer an NFT - NFT not found in portfolio."]
      #[codec(index = 10u8)]
      InvalidNFTTransferNFTNotOwned,
      #[doc = "Failed to transfer an NFT - identity count would overflow."]
      #[codec(index = 11u8)]
      InvalidNFTTransferCountOverflow,
      #[doc = "Failed to transfer an NFT - compliance failed."]
      #[codec(index = 12u8)]
      InvalidNFTTransferComplianceFailure,
      #[doc = "Failed to transfer an NFT - asset is frozen."]
      #[codec(index = 13u8)]
      InvalidNFTTransferFrozenAsset,
      #[doc = "Failed to transfer an NFT - the number of nfts in the identity is insufficient."]
      #[codec(index = 14u8)]
      InvalidNFTTransferInsufficientCount,
      #[doc = "The maximum number of metadata keys was exceeded."]
      #[codec(index = 15u8)]
      MaxNumberOfKeysExceeded,
      #[doc = "The maximum number of nfts being transferred in one leg was exceeded."]
      #[codec(index = 16u8)]
      MaxNumberOfNFTsPerLegExceeded,
      #[doc = "The NFT does not exist."]
      #[codec(index = 17u8)]
      NFTNotFound,
      #[doc = "At least one of the metadata keys has not been registered."]
      #[codec(index = 18u8)]
      UnregisteredMetadataKey,
      #[doc = "It is not possible to transferr zero nft."]
      #[codec(index = 19u8)]
      ZeroCount,
    }
    impl NftError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::BalanceOverflow => "Nft.BalanceOverflow",
          Self::BalanceUnderflow => "Nft.BalanceUnderflow",
          Self::CollectionAlredyRegistered => "Nft.CollectionAlredyRegistered",
          Self::CollectionNotFound => "Nft.CollectionNotFound",
          Self::DuplicateMetadataKey => "Nft.DuplicateMetadataKey",
          Self::DuplicatedNFTId => "Nft.DuplicatedNFTId",
          Self::InvalidAssetType => "Nft.InvalidAssetType",
          Self::InvalidMetadataAttribute => "Nft.InvalidMetadataAttribute",
          Self::InvalidNFTTransferCollectionNotFound => "Nft.InvalidNFTTransferCollectionNotFound",
          Self::InvalidNFTTransferSamePortfolio => "Nft.InvalidNFTTransferSamePortfolio",
          Self::InvalidNFTTransferNFTNotOwned => "Nft.InvalidNFTTransferNFTNotOwned",
          Self::InvalidNFTTransferCountOverflow => "Nft.InvalidNFTTransferCountOverflow",
          Self::InvalidNFTTransferComplianceFailure => "Nft.InvalidNFTTransferComplianceFailure",
          Self::InvalidNFTTransferFrozenAsset => "Nft.InvalidNFTTransferFrozenAsset",
          Self::InvalidNFTTransferInsufficientCount => "Nft.InvalidNFTTransferInsufficientCount",
          Self::MaxNumberOfKeysExceeded => "Nft.MaxNumberOfKeysExceeded",
          Self::MaxNumberOfNFTsPerLegExceeded => "Nft.MaxNumberOfNFTsPerLegExceeded",
          Self::NFTNotFound => "Nft.NFTNotFound",
          Self::UnregisteredMetadataKey => "Nft.UnregisteredMetadataKey",
          Self::ZeroCount => "Nft.ZeroCount",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for NftError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: BalanceOverflow => { & ["An overflow while calculating the balance." ,] } , Self :: BalanceUnderflow => { & ["An underflow while calculating the balance." ,] } , Self :: CollectionAlredyRegistered => { & ["The ticker is already associated to an NFT collection." ,] } , Self :: CollectionNotFound => { & ["The NFT collection does not exist." ,] } , Self :: DuplicateMetadataKey => { & ["A duplicate metadata key has been passed as parameter." ,] } , Self :: DuplicatedNFTId => { & ["Duplicate ids are not allowed." ,] } , Self :: InvalidAssetType => { & ["The asset must be of type non-fungible." ,] } , Self :: InvalidMetadataAttribute => { & ["Either the number of keys or the key identifier does not match the keys defined for the collection." ,] } , Self :: InvalidNFTTransferCollectionNotFound => { & ["Failed to transfer an NFT - NFT collection not found." ,] } , Self :: InvalidNFTTransferSamePortfolio => { & ["Failed to transfer an NFT - attempt to move to the same portfolio." ,] } , Self :: InvalidNFTTransferNFTNotOwned => { & ["Failed to transfer an NFT - NFT not found in portfolio." ,] } , Self :: InvalidNFTTransferCountOverflow => { & ["Failed to transfer an NFT - identity count would overflow." ,] } , Self :: InvalidNFTTransferComplianceFailure => { & ["Failed to transfer an NFT - compliance failed." ,] } , Self :: InvalidNFTTransferFrozenAsset => { & ["Failed to transfer an NFT - asset is frozen." ,] } , Self :: InvalidNFTTransferInsufficientCount => { & ["Failed to transfer an NFT - the number of nfts in the identity is insufficient." ,] } , Self :: MaxNumberOfKeysExceeded => { & ["The maximum number of metadata keys was exceeded." ,] } , Self :: MaxNumberOfNFTsPerLegExceeded => { & ["The maximum number of nfts being transferred in one leg was exceeded." ,] } , Self :: NFTNotFound => { & ["The NFT does not exist." ,] } , Self :: UnregisteredMetadataKey => { & ["At least one of the metadata keys has not been registered." ,] } , Self :: ZeroCount => { & ["It is not possible to transferr zero nft." ,] } , _ => & [""] , }
      }
    }
    impl From<NftError> for &'static str {
      fn from(v: NftError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&NftError> for &'static str {
      fn from(v: &NftError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum NftCall {
      #[doc = "Cretes a new `NFTCollection`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `ticker` - the ticker associated to the new collection."]
      #[doc = "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type."]
      #[doc = "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionAlredyRegistered` - if the ticker is already associated to an NFT collection."]
      #[doc = "- `InvalidAssetType` - if the associated asset is not of type NFT."]
      #[doc = "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed."]
      #[doc = "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 0u8)]
      create_nft_collection {
        ticker: polymesh_primitives::ticker::Ticker,
        nft_type: Option<polymesh_primitives::asset::NonFungibleType>,
        collection_keys: polymesh_primitives::nft::NFTCollectionKeys,
      },
      #[doc = "Issues an NFT to the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the NFT collection."]
      #[doc = "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT."]
      #[doc = "- `portfolio_kind` - the portfolio that will receive the minted nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given ticker has not been created."]
      #[doc = "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[codec(index = 1u8)]
      issue_nft {
        ticker: polymesh_primitives::ticker::Ticker,
        nft_metadata_attributes: ::alloc::vec::Vec<polymesh_primitives::nft::NFTMetadataAttribute>,
        portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
      },
      #[doc = "Redeems the given NFT from the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the NFT collection."]
      #[doc = "* `nft_id` - the id of the NFT to be burned."]
      #[doc = "* `portfolio_kind` - the portfolio that contains the nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given ticker has not been created."]
      #[doc = "- `NFTNotFound` - if the given NFT does not exist in the portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[codec(index = 2u8)]
      redeem_nft {
        ticker: polymesh_primitives::ticker::Ticker,
        nft_id: polymesh_primitives::nft::NFTId,
        portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
      },
    }
    impl NftCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_nft_collection { .. } => "Nft.create_nft_collection",
          Self::issue_nft { .. } => "Nft.issue_nft",
          Self::redeem_nft { .. } => "Nft.redeem_nft",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for NftCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: create_nft_collection { .. } => { & ["Cretes a new `NFTCollection`." , "" , "# Arguments" , "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)." , "* `ticker` - the ticker associated to the new collection." , "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type." , "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have." , "" , "## Errors" , "- `CollectionAlredyRegistered` - if the ticker is already associated to an NFT collection." , "- `InvalidAssetType` - if the associated asset is not of type NFT." , "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed." , "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered." , "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input." , "" , "# Permissions" , "* Asset" ,] } , Self :: issue_nft { .. } => { & ["Issues an NFT to the caller." , "" , "# Arguments" , "* `origin` - is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` - the ticker of the NFT collection." , "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT." , "- `portfolio_kind` - the portfolio that will receive the minted nft." , "" , "## Errors" , "- `CollectionNotFound` - if the collection associated to the given ticker has not been created." , "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection." , "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input." , "" , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: redeem_nft { .. } => { & ["Redeems the given NFT from the caller's portfolio." , "" , "# Arguments" , "* `origin` - is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` - the ticker of the NFT collection." , "* `nft_id` - the id of the NFT to be burned." , "* `portfolio_kind` - the portfolio that contains the nft." , "" , "## Errors" , "- `CollectionNotFound` - if the collection associated to the given ticker has not been created." , "- `NFTNotFound` - if the given NFT does not exist in the portfolio." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , _ => & [""] , }
      }
    }
    impl From<NftCall> for &'static str {
      fn from(v: NftCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&NftCall> for &'static str {
      fn from(v: &NftCall) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod polymesh_common_utilities {
    use super::*;
    pub mod protocol_fee {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ProtocolOp {
        #[codec(index = 0u8)]
        AssetRegisterTicker,
        #[codec(index = 1u8)]
        AssetIssue,
        #[codec(index = 2u8)]
        AssetAddDocuments,
        #[codec(index = 3u8)]
        AssetCreateAsset,
        #[codec(index = 4u8)]
        CheckpointCreateSchedule,
        #[codec(index = 5u8)]
        ComplianceManagerAddComplianceRequirement,
        #[codec(index = 6u8)]
        IdentityCddRegisterDid,
        #[codec(index = 7u8)]
        IdentityAddClaim,
        #[codec(index = 8u8)]
        IdentityAddSecondaryKeysWithAuthorization,
        #[codec(index = 9u8)]
        PipsPropose,
        #[codec(index = 10u8)]
        ContractsPutCode,
        #[codec(index = 11u8)]
        CorporateBallotAttachBallot,
        #[codec(index = 12u8)]
        CapitalDistributionDistribute,
        #[codec(index = 13u8)]
        NFTCreateCollection,
        #[codec(index = 14u8)]
        NFTMint,
        #[codec(index = 15u8)]
        IdentityCreateChildIdentity,
      }
    }
    pub mod traits {
      use super::*;
      pub mod compliance_manager {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum ComplianceManagerEvent {
          #[doc = "Emitted when new compliance requirement is created."]
          #[doc = "(caller DID, Ticker, ComplianceRequirement)."]
          #[codec(index = 0u8)]
          ComplianceRequirementCreated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::compliance_manager::ComplianceRequirement,
          ),
          #[doc = "Emitted when a compliance requirement is removed."]
          #[doc = "(caller DID, Ticker, requirement_id)."]
          #[codec(index = 1u8)]
          ComplianceRequirementRemoved(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            u32,
          ),
          #[doc = "Emitted when an asset compliance is replaced."]
          #[doc = "Parameters: caller DID, ticker, new asset compliance."]
          #[codec(index = 2u8)]
          AssetComplianceReplaced(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::alloc::vec::Vec<polymesh_primitives::compliance_manager::ComplianceRequirement>,
          ),
          #[doc = "Emitted when an asset compliance of a ticker is reset."]
          #[doc = "(caller DID, Ticker)."]
          #[codec(index = 3u8)]
          AssetComplianceReset(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
          ),
          #[doc = "Emitted when an asset compliance for a given ticker gets resume."]
          #[doc = "(caller DID, Ticker)."]
          #[codec(index = 4u8)]
          AssetComplianceResumed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
          ),
          #[doc = "Emitted when an asset compliance for a given ticker gets paused."]
          #[doc = "(caller DID, Ticker)."]
          #[codec(index = 5u8)]
          AssetCompliancePaused(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
          ),
          #[doc = "Emitted when compliance requirement get modified/change."]
          #[doc = "(caller DID, Ticker, ComplianceRequirement)."]
          #[codec(index = 6u8)]
          ComplianceRequirementChanged(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::compliance_manager::ComplianceRequirement,
          ),
          #[doc = "Emitted when default claim issuer list for a given ticker gets added."]
          #[doc = "(caller DID, Ticker, Added TrustedIssuer)."]
          #[codec(index = 7u8)]
          TrustedDefaultClaimIssuerAdded(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::condition::TrustedIssuer,
          ),
          #[doc = "Emitted when default claim issuer list for a given ticker get removed."]
          #[doc = "(caller DID, Ticker, Removed TrustedIssuer)."]
          #[codec(index = 8u8)]
          TrustedDefaultClaimIssuerRemoved(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::polymesh_api_client::IdentityId,
          ),
        }
        impl ComplianceManagerEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::ComplianceRequirementCreated(_, _, _) => {
                "ComplianceManager.ComplianceRequirementCreated"
              }
              Self::ComplianceRequirementRemoved(_, _, _) => {
                "ComplianceManager.ComplianceRequirementRemoved"
              }
              Self::AssetComplianceReplaced(_, _, _) => "ComplianceManager.AssetComplianceReplaced",
              Self::AssetComplianceReset(_, _) => "ComplianceManager.AssetComplianceReset",
              Self::AssetComplianceResumed(_, _) => "ComplianceManager.AssetComplianceResumed",
              Self::AssetCompliancePaused(_, _) => "ComplianceManager.AssetCompliancePaused",
              Self::ComplianceRequirementChanged(_, _, _) => {
                "ComplianceManager.ComplianceRequirementChanged"
              }
              Self::TrustedDefaultClaimIssuerAdded(_, _, _) => {
                "ComplianceManager.TrustedDefaultClaimIssuerAdded"
              }
              Self::TrustedDefaultClaimIssuerRemoved(_, _, _) => {
                "ComplianceManager.TrustedDefaultClaimIssuerRemoved"
              }
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for ComplianceManagerEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::ComplianceRequirementCreated(_, _, _) => &[
                "Emitted when new compliance requirement is created.",
                "(caller DID, Ticker, ComplianceRequirement).",
              ],
              Self::ComplianceRequirementRemoved(_, _, _) => &[
                "Emitted when a compliance requirement is removed.",
                "(caller DID, Ticker, requirement_id).",
              ],
              Self::AssetComplianceReplaced(_, _, _) => &[
                "Emitted when an asset compliance is replaced.",
                "Parameters: caller DID, ticker, new asset compliance.",
              ],
              Self::AssetComplianceReset(_, _) => &[
                "Emitted when an asset compliance of a ticker is reset.",
                "(caller DID, Ticker).",
              ],
              Self::AssetComplianceResumed(_, _) => &[
                "Emitted when an asset compliance for a given ticker gets resume.",
                "(caller DID, Ticker).",
              ],
              Self::AssetCompliancePaused(_, _) => &[
                "Emitted when an asset compliance for a given ticker gets paused.",
                "(caller DID, Ticker).",
              ],
              Self::ComplianceRequirementChanged(_, _, _) => &[
                "Emitted when compliance requirement get modified/change.",
                "(caller DID, Ticker, ComplianceRequirement).",
              ],
              Self::TrustedDefaultClaimIssuerAdded(_, _, _) => &[
                "Emitted when default claim issuer list for a given ticker gets added.",
                "(caller DID, Ticker, Added TrustedIssuer).",
              ],
              Self::TrustedDefaultClaimIssuerRemoved(_, _, _) => &[
                "Emitted when default claim issuer list for a given ticker get removed.",
                "(caller DID, Ticker, Removed TrustedIssuer).",
              ],
              _ => &[""],
            }
          }
        }
        impl From<ComplianceManagerEvent> for &'static str {
          fn from(v: ComplianceManagerEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&ComplianceManagerEvent> for &'static str {
          fn from(v: &ComplianceManagerEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod external_agents {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum ExternalAgentsEvent {
          #[doc = "An Agent Group was created."]
          #[doc = ""]
          #[doc = "(Caller DID, AG's ticker, AG's ID, AG's permissions)"]
          #[codec(index = 0u8)]
          GroupCreated(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::agent::AGId,
            polymesh_primitives::subset::SubsetRestriction<
              polymesh_primitives::secondary_key::PalletPermissions,
            >,
          ),
          #[doc = "An Agent Group's permissions was updated."]
          #[doc = ""]
          #[doc = "(Caller DID, AG's ticker, AG's ID, AG's new permissions)"]
          #[codec(index = 1u8)]
          GroupPermissionsUpdated(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::agent::AGId,
            polymesh_primitives::subset::SubsetRestriction<
              polymesh_primitives::secondary_key::PalletPermissions,
            >,
          ),
          #[doc = "An agent was added."]
          #[doc = ""]
          #[doc = "(Caller/Agent DID, Agent's ticker, Agent's group)"]
          #[codec(index = 2u8)]
          AgentAdded(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::agent::AgentGroup,
          ),
          #[doc = "An agent was removed."]
          #[doc = ""]
          #[doc = "(Caller DID, Agent's ticker, Agent's DID)"]
          #[codec(index = 3u8)]
          AgentRemoved(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            polymesh_primitives::ticker::Ticker,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "An agent's group was changed."]
          #[doc = ""]
          #[doc = "(Caller DID, Agent's ticker, Agent's DID, The new group of the agent)"]
          #[codec(index = 4u8)]
          GroupChanged(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            polymesh_primitives::ticker::Ticker,
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::agent::AgentGroup,
          ),
        }
        impl ExternalAgentsEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::GroupCreated(_, _, _, _) => "ExternalAgents.GroupCreated",
              Self::GroupPermissionsUpdated(_, _, _, _) => "ExternalAgents.GroupPermissionsUpdated",
              Self::AgentAdded(_, _, _) => "ExternalAgents.AgentAdded",
              Self::AgentRemoved(_, _, _) => "ExternalAgents.AgentRemoved",
              Self::GroupChanged(_, _, _, _) => "ExternalAgents.GroupChanged",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for ExternalAgentsEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::GroupCreated(_, _, _, _) => &[
                "An Agent Group was created.",
                "",
                "(Caller DID, AG's ticker, AG's ID, AG's permissions)",
              ],
              Self::GroupPermissionsUpdated(_, _, _, _) => &[
                "An Agent Group's permissions was updated.",
                "",
                "(Caller DID, AG's ticker, AG's ID, AG's new permissions)",
              ],
              Self::AgentAdded(_, _, _) => &[
                "An agent was added.",
                "",
                "(Caller/Agent DID, Agent's ticker, Agent's group)",
              ],
              Self::AgentRemoved(_, _, _) => &[
                "An agent was removed.",
                "",
                "(Caller DID, Agent's ticker, Agent's DID)",
              ],
              Self::GroupChanged(_, _, _, _) => &[
                "An agent's group was changed.",
                "",
                "(Caller DID, Agent's ticker, Agent's DID, The new group of the agent)",
              ],
              _ => &[""],
            }
          }
        }
        impl From<ExternalAgentsEvent> for &'static str {
          fn from(v: ExternalAgentsEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&ExternalAgentsEvent> for &'static str {
          fn from(v: &ExternalAgentsEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod group {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct InactiveMember<Moment> {
          pub id: ::polymesh_api_client::IdentityId,
          pub deactivated_at: Moment,
          pub expiry: Option<Moment>,
        }
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I> {
          #[doc = "The given member was added; see the transaction for who."]
          #[doc = "caller DID, New member DID."]
          #[codec(index = 0u8)]
          MemberAdded(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "The given member was removed; see the transaction for who."]
          #[doc = "caller DID, member DID that get removed."]
          #[codec(index = 1u8)]
          MemberRemoved(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "The given member has been revoked at specific time-stamp."]
          #[doc = "caller DID, member DID that get revoked."]
          #[codec(index = 2u8)]
          MemberRevoked(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "Two members were swapped; see the transaction for who."]
          #[doc = "caller DID, Removed DID, New add DID."]
          #[codec(index = 3u8)]
          MembersSwapped(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "The membership was reset; see the transaction for who the new set is."]
          #[doc = "caller DID, List of new members."]
          #[codec(index = 4u8)]
          MembersReset(
            ::polymesh_api_client::IdentityId,
            ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
          ),
          #[doc = "The limit of how many active members there can be concurrently was changed."]
          #[codec(index = 5u8)]
          ActiveLimitChanged(::polymesh_api_client::IdentityId, u32, u32),
          #[doc = "Phantom member, never used."]
          #[codec(index = 6u8)]
          Dummy,
          PhantomDataVariant(core::marker::PhantomData<(AccountId, RuntimeEvent, I)>),
        }
        impl<AccountId, RuntimeEvent, I> UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I> {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::MemberAdded(_, _) => "UpgradeCommitteeMembership.MemberAdded",
              Self::MemberRemoved(_, _) => "UpgradeCommitteeMembership.MemberRemoved",
              Self::MemberRevoked(_, _) => "UpgradeCommitteeMembership.MemberRevoked",
              Self::MembersSwapped(_, _, _) => "UpgradeCommitteeMembership.MembersSwapped",
              Self::MembersReset(_, _) => "UpgradeCommitteeMembership.MembersReset",
              Self::ActiveLimitChanged(_, _, _) => "UpgradeCommitteeMembership.ActiveLimitChanged",
              Self::Dummy => "UpgradeCommitteeMembership.Dummy",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl<AccountId, RuntimeEvent, I> ::polymesh_api_client::EnumInfo
          for UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I>
        {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::MemberAdded(_, _) => &[
                "The given member was added; see the transaction for who.",
                "caller DID, New member DID.",
              ],
              Self::MemberRemoved(_, _) => &[
                "The given member was removed; see the transaction for who.",
                "caller DID, member DID that get removed.",
              ],
              Self::MemberRevoked(_, _) => &[
                "The given member has been revoked at specific time-stamp.",
                "caller DID, member DID that get revoked.",
              ],
              Self::MembersSwapped(_, _, _) => &[
                "Two members were swapped; see the transaction for who.",
                "caller DID, Removed DID, New add DID.",
              ],
              Self::MembersReset(_, _) => &[
                "The membership was reset; see the transaction for who the new set is.",
                "caller DID, List of new members.",
              ],
              Self::ActiveLimitChanged(_, _, _) => {
                &["The limit of how many active members there can be concurrently was changed."]
              }
              Self::Dummy => &["Phantom member, never used."],
              _ => &[""],
            }
          }
        }
        impl<AccountId, RuntimeEvent, I>
          From<UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I>> for &'static str
        {
          fn from(v: UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I>) -> Self {
            v.as_static_str()
          }
        }
        impl<AccountId, RuntimeEvent, I>
          From<&UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I>> for &'static str
        {
          fn from(v: &UpgradeCommitteeMembershipEvent<AccountId, RuntimeEvent, I>) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod multisig {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum MultiSigEvent<AccountId> {
          #[doc = "Event emitted after creation of a multisig."]
          #[doc = "Arguments: caller DID, multisig address, signers (pending approval), signatures required."]
          #[codec(index = 0u8)]
          MultiSigCreated(
            ::polymesh_api_client::IdentityId,
            AccountId,
            AccountId,
            ::alloc::vec::Vec<polymesh_primitives::secondary_key::Signatory<AccountId>>,
            u64,
          ),
          #[doc = "Event emitted after adding a proposal."]
          #[doc = "Arguments: caller DID, multisig, proposal ID."]
          #[codec(index = 1u8)]
          ProposalAdded(::polymesh_api_client::IdentityId, AccountId, u64),
          #[doc = "Event emitted when a proposal is executed."]
          #[doc = "Arguments: caller DID, multisig, proposal ID, result."]
          #[codec(index = 2u8)]
          ProposalExecuted(::polymesh_api_client::IdentityId, AccountId, u64, bool),
          #[doc = "Event emitted when a signatory is added."]
          #[doc = "Arguments: caller DID, multisig, added signer."]
          #[codec(index = 3u8)]
          MultiSigSignerAdded(
            ::polymesh_api_client::IdentityId,
            AccountId,
            polymesh_primitives::secondary_key::Signatory<AccountId>,
          ),
          #[doc = "Event emitted when a multisig signatory is authorized to be added."]
          #[doc = "Arguments: caller DID, multisig, authorized signer."]
          #[codec(index = 4u8)]
          MultiSigSignerAuthorized(
            ::polymesh_api_client::IdentityId,
            AccountId,
            polymesh_primitives::secondary_key::Signatory<AccountId>,
          ),
          #[doc = "Event emitted when a multisig signatory is removed."]
          #[doc = "Arguments: caller DID, multisig, removed signer."]
          #[codec(index = 5u8)]
          MultiSigSignerRemoved(
            ::polymesh_api_client::IdentityId,
            AccountId,
            polymesh_primitives::secondary_key::Signatory<AccountId>,
          ),
          #[doc = "Event emitted when the number of required signatures is changed."]
          #[doc = "Arguments: caller DID, multisig, new required signatures."]
          #[codec(index = 6u8)]
          MultiSigSignaturesRequiredChanged(::polymesh_api_client::IdentityId, AccountId, u64),
          #[doc = "Event emitted when the proposal get approved."]
          #[doc = "Arguments: caller DID, multisig, authorized signer, proposal id."]
          #[codec(index = 7u8)]
          ProposalApproved(
            ::polymesh_api_client::IdentityId,
            AccountId,
            polymesh_primitives::secondary_key::Signatory<AccountId>,
            u64,
          ),
          #[doc = "Event emitted when a vote is cast in favor of rejecting a proposal."]
          #[doc = "Arguments: caller DID, multisig, authorized signer, proposal id."]
          #[codec(index = 8u8)]
          ProposalRejectionVote(
            ::polymesh_api_client::IdentityId,
            AccountId,
            polymesh_primitives::secondary_key::Signatory<AccountId>,
            u64,
          ),
          #[doc = "Event emitted when a proposal is rejected."]
          #[doc = "Arguments: caller DID, multisig, proposal ID."]
          #[codec(index = 9u8)]
          ProposalRejected(::polymesh_api_client::IdentityId, AccountId, u64),
          #[doc = "Event emitted when there's an error in proposal execution"]
          #[codec(index = 10u8)]
          ProposalExecutionFailed(sp_runtime::DispatchError),
          #[doc = "Scheduling of proposal fails."]
          #[codec(index = 11u8)]
          SchedulingFailed(sp_runtime::DispatchError),
        }
        impl<AccountId> MultiSigEvent<AccountId> {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::MultiSigCreated(_, _, _, _, _) => "MultiSig.MultiSigCreated",
              Self::ProposalAdded(_, _, _) => "MultiSig.ProposalAdded",
              Self::ProposalExecuted(_, _, _, _) => "MultiSig.ProposalExecuted",
              Self::MultiSigSignerAdded(_, _, _) => "MultiSig.MultiSigSignerAdded",
              Self::MultiSigSignerAuthorized(_, _, _) => "MultiSig.MultiSigSignerAuthorized",
              Self::MultiSigSignerRemoved(_, _, _) => "MultiSig.MultiSigSignerRemoved",
              Self::MultiSigSignaturesRequiredChanged(_, _, _) => {
                "MultiSig.MultiSigSignaturesRequiredChanged"
              }
              Self::ProposalApproved(_, _, _, _) => "MultiSig.ProposalApproved",
              Self::ProposalRejectionVote(_, _, _, _) => "MultiSig.ProposalRejectionVote",
              Self::ProposalRejected(_, _, _) => "MultiSig.ProposalRejected",
              Self::ProposalExecutionFailed(_) => "MultiSig.ProposalExecutionFailed",
              Self::SchedulingFailed(_) => "MultiSig.SchedulingFailed",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl<AccountId> ::polymesh_api_client::EnumInfo for MultiSigEvent<AccountId> {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: MultiSigCreated (_ , _ , _ , _ , _) => { & ["Event emitted after creation of a multisig." , "Arguments: caller DID, multisig address, signers (pending approval), signatures required." ,] } , Self :: ProposalAdded (_ , _ , _) => { & ["Event emitted after adding a proposal." , "Arguments: caller DID, multisig, proposal ID." ,] } , Self :: ProposalExecuted (_ , _ , _ , _) => { & ["Event emitted when a proposal is executed." , "Arguments: caller DID, multisig, proposal ID, result." ,] } , Self :: MultiSigSignerAdded (_ , _ , _) => { & ["Event emitted when a signatory is added." , "Arguments: caller DID, multisig, added signer." ,] } , Self :: MultiSigSignerAuthorized (_ , _ , _) => { & ["Event emitted when a multisig signatory is authorized to be added." , "Arguments: caller DID, multisig, authorized signer." ,] } , Self :: MultiSigSignerRemoved (_ , _ , _) => { & ["Event emitted when a multisig signatory is removed." , "Arguments: caller DID, multisig, removed signer." ,] } , Self :: MultiSigSignaturesRequiredChanged (_ , _ , _) => { & ["Event emitted when the number of required signatures is changed." , "Arguments: caller DID, multisig, new required signatures." ,] } , Self :: ProposalApproved (_ , _ , _ , _) => { & ["Event emitted when the proposal get approved." , "Arguments: caller DID, multisig, authorized signer, proposal id." ,] } , Self :: ProposalRejectionVote (_ , _ , _ , _) => { & ["Event emitted when a vote is cast in favor of rejecting a proposal." , "Arguments: caller DID, multisig, authorized signer, proposal id." ,] } , Self :: ProposalRejected (_ , _ , _) => { & ["Event emitted when a proposal is rejected." , "Arguments: caller DID, multisig, proposal ID." ,] } , Self :: ProposalExecutionFailed (_) => { & ["Event emitted when there's an error in proposal execution" ,] } , Self :: SchedulingFailed (_) => { & ["Scheduling of proposal fails." ,] } , _ => & [""] , }
          }
        }
        impl<AccountId> From<MultiSigEvent<AccountId>> for &'static str {
          fn from(v: MultiSigEvent<AccountId>) -> Self {
            v.as_static_str()
          }
        }
        impl<AccountId> From<&MultiSigEvent<AccountId>> for &'static str {
          fn from(v: &MultiSigEvent<AccountId>) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod base {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum BaseEvent {
          #[doc = "An unexpected error happened that should be investigated."]
          #[codec(index = 0u8)]
          UnexpectedError(Option<sp_runtime::DispatchError>),
        }
        impl BaseEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::UnexpectedError(_) => "Base.UnexpectedError",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for BaseEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::UnexpectedError(_) => {
                &["An unexpected error happened that should be investigated."]
              }
              _ => &[""],
            }
          }
        }
        impl From<BaseEvent> for &'static str {
          fn from(v: BaseEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&BaseEvent> for &'static str {
          fn from(v: &BaseEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod nft {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum NftEvent {
          #[doc = "Emitted when a new nft collection is created."]
          #[codec(index = 0u8)]
          NftCollectionCreated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::nft::NFTCollectionId,
          ),
          #[doc = "Emitted when NFTs were issued, redeemed or transferred."]
          #[doc = "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`NFTs`], the [`PortfolioId`] of the source, the [`PortfolioId`]"]
          #[doc = "of the destination and the [`PortfolioUpdateReason`]."]
          #[codec(index = 1u8)]
          NFTPortfolioUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::nft::NFTs,
            Option<polymesh_primitives::identity_id::PortfolioId>,
            Option<polymesh_primitives::identity_id::PortfolioId>,
            polymesh_primitives::portfolio::PortfolioUpdateReason,
          ),
        }
        impl NftEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::NftCollectionCreated(_, _, _) => "Nft.NftCollectionCreated",
              Self::NFTPortfolioUpdated(_, _, _, _, _) => "Nft.NFTPortfolioUpdated",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for NftEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: NftCollectionCreated (_ , _ , _) => { & ["Emitted when a new nft collection is created." ,] } , Self :: NFTPortfolioUpdated (_ , _ , _ , _ , _) => { & ["Emitted when NFTs were issued, redeemed or transferred." , "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`NFTs`], the [`PortfolioId`] of the source, the [`PortfolioId`]" , "of the destination and the [`PortfolioUpdateReason`]." ,] } , _ => & [""] , }
          }
        }
        impl From<NftEvent> for &'static str {
          fn from(v: NftEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&NftEvent> for &'static str {
          fn from(v: &NftEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod checkpoint {
        use super::*;
        #[derive(
          Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
        )]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ScheduleId(pub u64);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ScheduleCheckpoints {
          pub pending: ::alloc::collections::BTreeSet<u64>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct NextCheckpoints {
          pub next_at: u64,
          pub total_pending: u64,
          pub schedules: ::alloc::collections::BTreeMap<
            polymesh_common_utilities::traits::checkpoint::ScheduleId,
            u64,
          >,
        }
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum CheckpointEvent {
          #[doc = "A checkpoint was created."]
          #[doc = ""]
          #[doc = "(caller DID, ticker, checkpoint ID, total supply, checkpoint timestamp)"]
          #[codec(index = 0u8)]
          CheckpointCreated(
            Option<::polymesh_api_client::IdentityId>,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::asset::CheckpointId,
            u128,
            u64,
          ),
          #[doc = "The maximum complexity for an arbitrary ticker's schedule set was changed."]
          #[doc = ""]
          #[doc = "(GC DID, the new maximum)"]
          #[codec(index = 1u8)]
          MaximumSchedulesComplexityChanged(::polymesh_api_client::IdentityId, u64),
          #[doc = "A checkpoint schedule was created."]
          #[doc = ""]
          #[doc = "(caller DID, ticker, schedule id, schedule)"]
          #[codec(index = 2u8)]
          ScheduleCreated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_common_utilities::traits::checkpoint::ScheduleId,
            polymesh_common_utilities::traits::checkpoint::ScheduleCheckpoints,
          ),
          #[doc = "A checkpoint schedule was removed."]
          #[doc = ""]
          #[doc = "(caller DID, ticker, schedule id, schedule)"]
          #[codec(index = 3u8)]
          ScheduleRemoved(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_common_utilities::traits::checkpoint::ScheduleId,
            polymesh_common_utilities::traits::checkpoint::ScheduleCheckpoints,
          ),
        }
        impl CheckpointEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::CheckpointCreated(_, _, _, _, _) => "Checkpoint.CheckpointCreated",
              Self::MaximumSchedulesComplexityChanged(_, _) => {
                "Checkpoint.MaximumSchedulesComplexityChanged"
              }
              Self::ScheduleCreated(_, _, _, _) => "Checkpoint.ScheduleCreated",
              Self::ScheduleRemoved(_, _, _, _) => "Checkpoint.ScheduleRemoved",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for CheckpointEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::CheckpointCreated(_, _, _, _, _) => &[
                "A checkpoint was created.",
                "",
                "(caller DID, ticker, checkpoint ID, total supply, checkpoint timestamp)",
              ],
              Self::MaximumSchedulesComplexityChanged(_, _) => &[
                "The maximum complexity for an arbitrary ticker's schedule set was changed.",
                "",
                "(GC DID, the new maximum)",
              ],
              Self::ScheduleCreated(_, _, _, _) => &[
                "A checkpoint schedule was created.",
                "",
                "(caller DID, ticker, schedule id, schedule)",
              ],
              Self::ScheduleRemoved(_, _, _, _) => &[
                "A checkpoint schedule was removed.",
                "",
                "(caller DID, ticker, schedule id, schedule)",
              ],
              _ => &[""],
            }
          }
        }
        impl From<CheckpointEvent> for &'static str {
          fn from(v: CheckpointEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&CheckpointEvent> for &'static str {
          fn from(v: &CheckpointEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod balances {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Reasons {
          #[codec(index = 0u8)]
          Fee,
          #[codec(index = 1u8)]
          Misc,
          #[codec(index = 2u8)]
          All,
        }
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum BalancesEvent<AccountId> {
          #[doc = "An account was created with some free balance. \\[did, account, free_balance]"]
          #[codec(index = 0u8)]
          Endowed(Option<::polymesh_api_client::IdentityId>, AccountId, u128),
          #[doc = "Transfer succeeded (from_did, from, to_did, to, value, memo)."]
          #[codec(index = 1u8)]
          Transfer(
            Option<::polymesh_api_client::IdentityId>,
            AccountId,
            Option<::polymesh_api_client::IdentityId>,
            AccountId,
            u128,
            Option<polymesh_primitives::Memo>,
          ),
          #[doc = "A balance was set by root (did, who, free, reserved)."]
          #[codec(index = 2u8)]
          BalanceSet(::polymesh_api_client::IdentityId, AccountId, u128, u128),
          #[doc = "The account and the amount of unlocked balance of that account that was burned."]
          #[doc = "(caller Id, caller account, amount)"]
          #[codec(index = 3u8)]
          AccountBalanceBurned(::polymesh_api_client::IdentityId, AccountId, u128),
          #[doc = "Some balance was reserved (moved from free to reserved). \\[who, value]"]
          #[codec(index = 4u8)]
          Reserved(AccountId, u128),
          #[doc = "Some balance was unreserved (moved from reserved to free). \\[who, value]"]
          #[codec(index = 5u8)]
          Unreserved(AccountId, u128),
          #[doc = "Some balance was moved from the reserve of the first account to the second account."]
          #[doc = "Final argument indicates the destination balance type."]
          #[doc = "\\[from, to, balance, destination_status]"]
          #[codec(index = 6u8)]
          ReserveRepatriated(
            AccountId,
            AccountId,
            u128,
            frame_support::traits::tokens::misc::BalanceStatus,
          ),
        }
        impl<AccountId> BalancesEvent<AccountId> {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::Endowed(_, _, _) => "Balances.Endowed",
              Self::Transfer(_, _, _, _, _, _) => "Balances.Transfer",
              Self::BalanceSet(_, _, _, _) => "Balances.BalanceSet",
              Self::AccountBalanceBurned(_, _, _) => "Balances.AccountBalanceBurned",
              Self::Reserved(_, _) => "Balances.Reserved",
              Self::Unreserved(_, _) => "Balances.Unreserved",
              Self::ReserveRepatriated(_, _, _, _) => "Balances.ReserveRepatriated",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl<AccountId> ::polymesh_api_client::EnumInfo for BalancesEvent<AccountId> {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: Endowed (_ , _ , _) => { & ["An account was created with some free balance. \\[did, account, free_balance]" ,] } , Self :: Transfer (_ , _ , _ , _ , _ , _) => { & ["Transfer succeeded (from_did, from, to_did, to, value, memo)." ,] } , Self :: BalanceSet (_ , _ , _ , _) => { & ["A balance was set by root (did, who, free, reserved)." ,] } , Self :: AccountBalanceBurned (_ , _ , _) => { & ["The account and the amount of unlocked balance of that account that was burned." , "(caller Id, caller account, amount)" ,] } , Self :: Reserved (_ , _) => { & ["Some balance was reserved (moved from free to reserved). \\[who, value]" ,] } , Self :: Unreserved (_ , _) => { & ["Some balance was unreserved (moved from reserved to free). \\[who, value]" ,] } , Self :: ReserveRepatriated (_ , _ , _ , _) => { & ["Some balance was moved from the reserve of the first account to the second account." , "Final argument indicates the destination balance type." , "\\[from, to, balance, destination_status]" ,] } , _ => & [""] , }
          }
        }
        impl<AccountId> From<BalancesEvent<AccountId>> for &'static str {
          fn from(v: BalancesEvent<AccountId>) -> Self {
            v.as_static_str()
          }
        }
        impl<AccountId> From<&BalancesEvent<AccountId>> for &'static str {
          fn from(v: &BalancesEvent<AccountId>) -> Self {
            v.as_static_str()
          }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct AccountData {
          pub free: u128,
          pub reserved: u128,
          pub misc_frozen: u128,
          pub fee_frozen: u128,
        }
      }
      pub mod statistics {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum StatisticsEvent {
          #[doc = "Stat types added to asset."]
          #[doc = ""]
          #[doc = "(Caller DID, Asset, Stat types)"]
          #[codec(index = 0u8)]
          StatTypesAdded(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::statistics::AssetScope,
            ::alloc::vec::Vec<polymesh_primitives::statistics::StatType>,
          ),
          #[doc = "Stat types removed from asset."]
          #[doc = ""]
          #[doc = "(Caller DID, Asset, Stat types)"]
          #[codec(index = 1u8)]
          StatTypesRemoved(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::statistics::AssetScope,
            ::alloc::vec::Vec<polymesh_primitives::statistics::StatType>,
          ),
          #[doc = "Asset stats updated."]
          #[doc = ""]
          #[doc = "(Caller DID, Asset, Stat type, Updates)"]
          #[codec(index = 2u8)]
          AssetStatsUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::statistics::AssetScope,
            polymesh_primitives::statistics::StatType,
            ::alloc::vec::Vec<polymesh_primitives::statistics::StatUpdate>,
          ),
          #[doc = "Set Transfer compliance rules for asset."]
          #[doc = ""]
          #[doc = "(Caller DID, Asset, Transfer conditions)"]
          #[codec(index = 3u8)]
          SetAssetTransferCompliance(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::statistics::AssetScope,
            ::alloc::vec::Vec<polymesh_primitives::transfer_compliance::TransferCondition>,
          ),
          #[doc = "Add `IdentityId`s exempt for transfer conditions matching exempt key."]
          #[doc = ""]
          #[doc = "(Caller DID, Exempt key, Entities)"]
          #[codec(index = 4u8)]
          TransferConditionExemptionsAdded(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
            ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
          ),
          #[doc = "Remove `IdentityId`s exempt for transfer conditions matching exempt key."]
          #[doc = ""]
          #[doc = "(Caller DID, Exempt key, Entities)"]
          #[codec(index = 5u8)]
          TransferConditionExemptionsRemoved(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
            ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
          ),
        }
        impl StatisticsEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::StatTypesAdded(_, _, _) => "Statistics.StatTypesAdded",
              Self::StatTypesRemoved(_, _, _) => "Statistics.StatTypesRemoved",
              Self::AssetStatsUpdated(_, _, _, _) => "Statistics.AssetStatsUpdated",
              Self::SetAssetTransferCompliance(_, _, _) => "Statistics.SetAssetTransferCompliance",
              Self::TransferConditionExemptionsAdded(_, _, _) => {
                "Statistics.TransferConditionExemptionsAdded"
              }
              Self::TransferConditionExemptionsRemoved(_, _, _) => {
                "Statistics.TransferConditionExemptionsRemoved"
              }
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for StatisticsEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::StatTypesAdded(_, _, _) => &[
                "Stat types added to asset.",
                "",
                "(Caller DID, Asset, Stat types)",
              ],
              Self::StatTypesRemoved(_, _, _) => &[
                "Stat types removed from asset.",
                "",
                "(Caller DID, Asset, Stat types)",
              ],
              Self::AssetStatsUpdated(_, _, _, _) => &[
                "Asset stats updated.",
                "",
                "(Caller DID, Asset, Stat type, Updates)",
              ],
              Self::SetAssetTransferCompliance(_, _, _) => &[
                "Set Transfer compliance rules for asset.",
                "",
                "(Caller DID, Asset, Transfer conditions)",
              ],
              Self::TransferConditionExemptionsAdded(_, _, _) => &[
                "Add `IdentityId`s exempt for transfer conditions matching exempt key.",
                "",
                "(Caller DID, Exempt key, Entities)",
              ],
              Self::TransferConditionExemptionsRemoved(_, _, _) => &[
                "Remove `IdentityId`s exempt for transfer conditions matching exempt key.",
                "",
                "(Caller DID, Exempt key, Entities)",
              ],
              _ => &[""],
            }
          }
        }
        impl From<StatisticsEvent> for &'static str {
          fn from(v: StatisticsEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&StatisticsEvent> for &'static str {
          fn from(v: &StatisticsEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod identity {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct SecondaryKeyWithAuth<AccountId> {
          pub secondary_key: polymesh_primitives::secondary_key::SecondaryKey<AccountId>,
          pub auth_signature: primitive_types::H512,
        }
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum IdentityEvent<AccountId, Moment> {
          #[doc = "Identity created."]
          #[doc = ""]
          #[doc = "(DID, primary key, secondary keys)"]
          #[codec(index = 0u8)]
          DidCreated(
            ::polymesh_api_client::IdentityId,
            AccountId,
            ::alloc::vec::Vec<polymesh_primitives::secondary_key::SecondaryKey<AccountId>>,
          ),
          #[doc = "Secondary keys added to identity."]
          #[doc = ""]
          #[doc = "(DID, new keys)"]
          #[codec(index = 1u8)]
          SecondaryKeysAdded(
            ::polymesh_api_client::IdentityId,
            ::alloc::vec::Vec<polymesh_primitives::secondary_key::SecondaryKey<AccountId>>,
          ),
          #[doc = "Secondary keys removed from identity."]
          #[doc = ""]
          #[doc = "(DID, the keys that got removed)"]
          #[codec(index = 2u8)]
          SecondaryKeysRemoved(
            ::polymesh_api_client::IdentityId,
            ::alloc::vec::Vec<AccountId>,
          ),
          #[doc = "A secondary key left their identity."]
          #[doc = ""]
          #[doc = "(DID, secondary key)"]
          #[codec(index = 3u8)]
          SecondaryKeyLeftIdentity(::polymesh_api_client::IdentityId, AccountId),
          #[doc = "Secondary key permissions updated."]
          #[doc = ""]
          #[doc = "(DID, updated secondary key, previous permissions, new permissions)"]
          #[codec(index = 4u8)]
          SecondaryKeyPermissionsUpdated(
            ::polymesh_api_client::IdentityId,
            AccountId,
            polymesh_primitives::secondary_key::Permissions,
            polymesh_primitives::secondary_key::Permissions,
          ),
          #[doc = "Primary key of identity changed."]
          #[doc = ""]
          #[doc = "(DID, old primary key account ID, new ID)"]
          #[codec(index = 5u8)]
          PrimaryKeyUpdated(::polymesh_api_client::IdentityId, AccountId, AccountId),
          #[doc = "Claim added to identity."]
          #[doc = ""]
          #[doc = "(DID, claim)"]
          #[codec(index = 6u8)]
          ClaimAdded(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_claim::IdentityClaim,
          ),
          #[doc = "Claim revoked from identity."]
          #[doc = ""]
          #[doc = "(DID, claim)"]
          #[codec(index = 7u8)]
          ClaimRevoked(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_claim::IdentityClaim,
          ),
          #[doc = "Asset's identity registered."]
          #[doc = ""]
          #[doc = "(Asset DID, ticker)"]
          #[codec(index = 8u8)]
          AssetDidRegistered(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
          ),
          #[doc = "New authorization added."]
          #[doc = ""]
          #[doc = "(authorised_by, target_did, target_key, auth_id, authorization_data, expiry)"]
          #[codec(index = 9u8)]
          AuthorizationAdded(
            ::polymesh_api_client::IdentityId,
            Option<::polymesh_api_client::IdentityId>,
            Option<AccountId>,
            Moment,
            polymesh_primitives::authorization::AuthorizationData<AccountId>,
            Option<Moment>,
          ),
          #[doc = "Authorization revoked by the authorizer."]
          #[doc = ""]
          #[doc = "(authorized_identity, authorized_key, auth_id)"]
          #[codec(index = 10u8)]
          AuthorizationRevoked(
            Option<::polymesh_api_client::IdentityId>,
            Option<AccountId>,
            Moment,
          ),
          #[doc = "Authorization rejected by the user who was authorized."]
          #[doc = ""]
          #[doc = "(authorized_identity, authorized_key, auth_id)"]
          #[codec(index = 11u8)]
          AuthorizationRejected(
            Option<::polymesh_api_client::IdentityId>,
            Option<AccountId>,
            Moment,
          ),
          #[doc = "Authorization consumed."]
          #[doc = ""]
          #[doc = "(authorized_identity, authorized_key, auth_id)"]
          #[codec(index = 12u8)]
          AuthorizationConsumed(
            Option<::polymesh_api_client::IdentityId>,
            Option<AccountId>,
            Moment,
          ),
          #[doc = "Accepting Authorization retry limit reached."]
          #[doc = ""]
          #[doc = "(authorized_identity, authorized_key, auth_id)"]
          #[codec(index = 13u8)]
          AuthorizationRetryLimitReached(
            Option<::polymesh_api_client::IdentityId>,
            Option<AccountId>,
            Moment,
          ),
          #[doc = "CDD requirement for updating primary key changed."]
          #[doc = ""]
          #[doc = "(new_requirement)"]
          #[codec(index = 14u8)]
          CddRequirementForPrimaryKeyUpdated(bool),
          #[doc = "CDD claims generated by `IdentityId` (a CDD Provider) have been invalidated from"]
          #[doc = "`Moment`."]
          #[doc = ""]
          #[doc = "(CDD provider DID, disable from date)"]
          #[codec(index = 15u8)]
          CddClaimsInvalidated(::polymesh_api_client::IdentityId, Moment),
          #[doc = "All Secondary keys of the identity ID are frozen."]
          #[doc = ""]
          #[doc = "(DID)"]
          #[codec(index = 16u8)]
          SecondaryKeysFrozen(::polymesh_api_client::IdentityId),
          #[doc = "All Secondary keys of the identity ID are unfrozen."]
          #[doc = ""]
          #[doc = "(DID)"]
          #[codec(index = 17u8)]
          SecondaryKeysUnfrozen(::polymesh_api_client::IdentityId),
          #[doc = "A new CustomClaimType was added."]
          #[doc = ""]
          #[doc = "(DID, id, Type)"]
          #[codec(index = 18u8)]
          CustomClaimTypeAdded(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_claim::CustomClaimTypeId,
            ::alloc::vec::Vec<u8>,
          ),
          #[doc = "Child identity created."]
          #[doc = ""]
          #[doc = "(Parent DID, Child DID, primary key)"]
          #[codec(index = 19u8)]
          ChildDidCreated(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
            AccountId,
          ),
          #[doc = "Child identity unlinked from parent identity."]
          #[doc = ""]
          #[doc = "(Caller DID, Parent DID, Child DID)"]
          #[codec(index = 20u8)]
          ChildDidUnlinked(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
          ),
        }
        impl<AccountId, Moment> IdentityEvent<AccountId, Moment> {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::DidCreated(_, _, _) => "Identity.DidCreated",
              Self::SecondaryKeysAdded(_, _) => "Identity.SecondaryKeysAdded",
              Self::SecondaryKeysRemoved(_, _) => "Identity.SecondaryKeysRemoved",
              Self::SecondaryKeyLeftIdentity(_, _) => "Identity.SecondaryKeyLeftIdentity",
              Self::SecondaryKeyPermissionsUpdated(_, _, _, _) => {
                "Identity.SecondaryKeyPermissionsUpdated"
              }
              Self::PrimaryKeyUpdated(_, _, _) => "Identity.PrimaryKeyUpdated",
              Self::ClaimAdded(_, _) => "Identity.ClaimAdded",
              Self::ClaimRevoked(_, _) => "Identity.ClaimRevoked",
              Self::AssetDidRegistered(_, _) => "Identity.AssetDidRegistered",
              Self::AuthorizationAdded(_, _, _, _, _, _) => "Identity.AuthorizationAdded",
              Self::AuthorizationRevoked(_, _, _) => "Identity.AuthorizationRevoked",
              Self::AuthorizationRejected(_, _, _) => "Identity.AuthorizationRejected",
              Self::AuthorizationConsumed(_, _, _) => "Identity.AuthorizationConsumed",
              Self::AuthorizationRetryLimitReached(_, _, _) => {
                "Identity.AuthorizationRetryLimitReached"
              }
              Self::CddRequirementForPrimaryKeyUpdated(_) => {
                "Identity.CddRequirementForPrimaryKeyUpdated"
              }
              Self::CddClaimsInvalidated(_, _) => "Identity.CddClaimsInvalidated",
              Self::SecondaryKeysFrozen(_) => "Identity.SecondaryKeysFrozen",
              Self::SecondaryKeysUnfrozen(_) => "Identity.SecondaryKeysUnfrozen",
              Self::CustomClaimTypeAdded(_, _, _) => "Identity.CustomClaimTypeAdded",
              Self::ChildDidCreated(_, _, _) => "Identity.ChildDidCreated",
              Self::ChildDidUnlinked(_, _, _) => "Identity.ChildDidUnlinked",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl<AccountId, Moment> ::polymesh_api_client::EnumInfo for IdentityEvent<AccountId, Moment> {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::DidCreated(_, _, _) => &[
                "Identity created.",
                "",
                "(DID, primary key, secondary keys)",
              ],
              Self::SecondaryKeysAdded(_, _) => {
                &["Secondary keys added to identity.", "", "(DID, new keys)"]
              }
              Self::SecondaryKeysRemoved(_, _) => &[
                "Secondary keys removed from identity.",
                "",
                "(DID, the keys that got removed)",
              ],
              Self::SecondaryKeyLeftIdentity(_, _) => &[
                "A secondary key left their identity.",
                "",
                "(DID, secondary key)",
              ],
              Self::SecondaryKeyPermissionsUpdated(_, _, _, _) => &[
                "Secondary key permissions updated.",
                "",
                "(DID, updated secondary key, previous permissions, new permissions)",
              ],
              Self::PrimaryKeyUpdated(_, _, _) => &[
                "Primary key of identity changed.",
                "",
                "(DID, old primary key account ID, new ID)",
              ],
              Self::ClaimAdded(_, _) => &["Claim added to identity.", "", "(DID, claim)"],
              Self::ClaimRevoked(_, _) => &["Claim revoked from identity.", "", "(DID, claim)"],
              Self::AssetDidRegistered(_, _) => {
                &["Asset's identity registered.", "", "(Asset DID, ticker)"]
              }
              Self::AuthorizationAdded(_, _, _, _, _, _) => &[
                "New authorization added.",
                "",
                "(authorised_by, target_did, target_key, auth_id, authorization_data, expiry)",
              ],
              Self::AuthorizationRevoked(_, _, _) => &[
                "Authorization revoked by the authorizer.",
                "",
                "(authorized_identity, authorized_key, auth_id)",
              ],
              Self::AuthorizationRejected(_, _, _) => &[
                "Authorization rejected by the user who was authorized.",
                "",
                "(authorized_identity, authorized_key, auth_id)",
              ],
              Self::AuthorizationConsumed(_, _, _) => &[
                "Authorization consumed.",
                "",
                "(authorized_identity, authorized_key, auth_id)",
              ],
              Self::AuthorizationRetryLimitReached(_, _, _) => &[
                "Accepting Authorization retry limit reached.",
                "",
                "(authorized_identity, authorized_key, auth_id)",
              ],
              Self::CddRequirementForPrimaryKeyUpdated(_) => &[
                "CDD requirement for updating primary key changed.",
                "",
                "(new_requirement)",
              ],
              Self::CddClaimsInvalidated(_, _) => &[
                "CDD claims generated by `IdentityId` (a CDD Provider) have been invalidated from",
                "`Moment`.",
                "",
                "(CDD provider DID, disable from date)",
              ],
              Self::SecondaryKeysFrozen(_) => &[
                "All Secondary keys of the identity ID are frozen.",
                "",
                "(DID)",
              ],
              Self::SecondaryKeysUnfrozen(_) => &[
                "All Secondary keys of the identity ID are unfrozen.",
                "",
                "(DID)",
              ],
              Self::CustomClaimTypeAdded(_, _, _) => {
                &["A new CustomClaimType was added.", "", "(DID, id, Type)"]
              }
              Self::ChildDidCreated(_, _, _) => &[
                "Child identity created.",
                "",
                "(Parent DID, Child DID, primary key)",
              ],
              Self::ChildDidUnlinked(_, _, _) => &[
                "Child identity unlinked from parent identity.",
                "",
                "(Caller DID, Parent DID, Child DID)",
              ],
              _ => &[""],
            }
          }
        }
        impl<AccountId, Moment> From<IdentityEvent<AccountId, Moment>> for &'static str {
          fn from(v: IdentityEvent<AccountId, Moment>) -> Self {
            v.as_static_str()
          }
        }
        impl<AccountId, Moment> From<&IdentityEvent<AccountId, Moment>> for &'static str {
          fn from(v: &IdentityEvent<AccountId, Moment>) -> Self {
            v.as_static_str()
          }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CreateChildIdentityWithAuth<AccountId> {
          pub key: AccountId,
          pub auth_signature: primitive_types::H512,
        }
      }
      pub mod portfolio {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum PortfolioEvent {
          #[doc = "The portfolio has been successfully created."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* origin DID"]
          #[doc = "* portfolio number"]
          #[doc = "* portfolio name"]
          #[codec(index = 0u8)]
          PortfolioCreated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioNumber,
            polymesh_primitives::identity_id::PortfolioName,
          ),
          #[doc = "The portfolio has been successfully removed."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* origin DID"]
          #[doc = "* portfolio number"]
          #[codec(index = 1u8)]
          PortfolioDeleted(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioNumber,
          ),
          #[doc = "The portfolio identified with `num` has been renamed to `name`."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* origin DID"]
          #[doc = "* portfolio number"]
          #[doc = "* portfolio name"]
          #[codec(index = 2u8)]
          PortfolioRenamed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioNumber,
            polymesh_primitives::identity_id::PortfolioName,
          ),
          #[doc = "All non-default portfolio numbers and names of a DID."]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* origin DID"]
          #[doc = "* vector of number-name pairs"]
          #[codec(index = 3u8)]
          UserPortfolios(
            ::polymesh_api_client::IdentityId,
            ::alloc::vec::Vec<(
              polymesh_primitives::identity_id::PortfolioNumber,
              polymesh_primitives::identity_id::PortfolioName,
            )>,
          ),
          #[doc = "Custody of a portfolio has been given to a different identity"]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* origin DID"]
          #[doc = "* portfolio id"]
          #[doc = "* portfolio custodian did"]
          #[codec(index = 4u8)]
          PortfolioCustodianChanged(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "Funds have moved between portfolios"]
          #[doc = ""]
          #[doc = "# Parameters"]
          #[doc = "* Origin DID."]
          #[doc = "* Source portfolio."]
          #[doc = "* Destination portfolio."]
          #[doc = "* The type of fund that was moved."]
          #[doc = "* Optional memo for the move."]
          #[codec(index = 5u8)]
          FundsMovedBetweenPortfolios(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            polymesh_primitives::identity_id::PortfolioId,
            polymesh_primitives::portfolio::FundDescription,
            Option<polymesh_primitives::Memo>,
          ),
        }
        impl PortfolioEvent {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::PortfolioCreated(_, _, _) => "Portfolio.PortfolioCreated",
              Self::PortfolioDeleted(_, _) => "Portfolio.PortfolioDeleted",
              Self::PortfolioRenamed(_, _, _) => "Portfolio.PortfolioRenamed",
              Self::UserPortfolios(_, _) => "Portfolio.UserPortfolios",
              Self::PortfolioCustodianChanged(_, _, _) => "Portfolio.PortfolioCustodianChanged",
              Self::FundsMovedBetweenPortfolios(_, _, _, _, _) => {
                "Portfolio.FundsMovedBetweenPortfolios"
              }
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for PortfolioEvent {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::PortfolioCreated(_, _, _) => &[
                "The portfolio has been successfully created.",
                "",
                "# Parameters",
                "* origin DID",
                "* portfolio number",
                "* portfolio name",
              ],
              Self::PortfolioDeleted(_, _) => &[
                "The portfolio has been successfully removed.",
                "",
                "# Parameters",
                "* origin DID",
                "* portfolio number",
              ],
              Self::PortfolioRenamed(_, _, _) => &[
                "The portfolio identified with `num` has been renamed to `name`.",
                "",
                "# Parameters",
                "* origin DID",
                "* portfolio number",
                "* portfolio name",
              ],
              Self::UserPortfolios(_, _) => &[
                "All non-default portfolio numbers and names of a DID.",
                "",
                "# Parameters",
                "* origin DID",
                "* vector of number-name pairs",
              ],
              Self::PortfolioCustodianChanged(_, _, _) => &[
                "Custody of a portfolio has been given to a different identity",
                "",
                "# Parameters",
                "* origin DID",
                "* portfolio id",
                "* portfolio custodian did",
              ],
              Self::FundsMovedBetweenPortfolios(_, _, _, _, _) => &[
                "Funds have moved between portfolios",
                "",
                "# Parameters",
                "* Origin DID.",
                "* Source portfolio.",
                "* Destination portfolio.",
                "* The type of fund that was moved.",
                "* Optional memo for the move.",
              ],
              _ => &[""],
            }
          }
        }
        impl From<PortfolioEvent> for &'static str {
          fn from(v: PortfolioEvent) -> Self {
            v.as_static_str()
          }
        }
        impl From<&PortfolioEvent> for &'static str {
          fn from(v: &PortfolioEvent) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod settlement {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum SettlementEvent<Moment, BlockNumber, AccountId> {
          #[doc = "A new venue has been created (did, venue_id, details, type)"]
          #[codec(index = 0u8)]
          VenueCreated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::VenueId,
            polymesh_primitives::settlement::VenueDetails,
            polymesh_primitives::settlement::VenueType,
          ),
          #[doc = "An existing venue's details has been updated (did, venue_id, details)"]
          #[codec(index = 1u8)]
          VenueDetailsUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::VenueId,
            polymesh_primitives::settlement::VenueDetails,
          ),
          #[doc = "An existing venue's type has been updated (did, venue_id, type)"]
          #[codec(index = 2u8)]
          VenueTypeUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::VenueId,
            polymesh_primitives::settlement::VenueType,
          ),
          #[doc = "An instruction has been affirmed (did, portfolio, instruction_id)"]
          #[codec(index = 3u8)]
          InstructionAffirmed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "An affirmation has been withdrawn (did, portfolio, instruction_id)"]
          #[codec(index = 4u8)]
          AffirmationWithdrawn(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::identity_id::PortfolioId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "An instruction has been rejected (did, instruction_id)"]
          #[codec(index = 5u8)]
          InstructionRejected(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "A receipt has been claimed (did, instruction_id, leg_id, receipt_uid, signer, receipt metadata)"]
          #[codec(index = 6u8)]
          ReceiptClaimed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
            polymesh_primitives::settlement::LegId,
            Moment,
            AccountId,
            Option<polymesh_primitives::settlement::ReceiptMetadata>,
          ),
          #[doc = "Venue filtering has been enabled or disabled for a ticker (did, ticker, filtering_enabled)"]
          #[codec(index = 7u8)]
          VenueFiltering(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            bool,
          ),
          #[doc = "Venues added to allow list (did, ticker, vec<venue_id>)"]
          #[codec(index = 8u8)]
          VenuesAllowed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
          ),
          #[doc = "Venues added to block list (did, ticker, vec<venue_id>)"]
          #[codec(index = 9u8)]
          VenuesBlocked(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
          ),
          #[doc = "Execution of a leg failed (did, instruction_id, leg_id)"]
          #[codec(index = 10u8)]
          LegFailedExecution(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
            polymesh_primitives::settlement::LegId,
          ),
          #[doc = "Instruction failed execution (did, instruction_id)"]
          #[codec(index = 11u8)]
          InstructionFailed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "Instruction executed successfully(did, instruction_id)"]
          #[codec(index = 12u8)]
          InstructionExecuted(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "Venue not part of the token's allow list (did, Ticker, venue_id)"]
          #[codec(index = 13u8)]
          VenueUnauthorized(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::settlement::VenueId,
          ),
          #[doc = "Scheduling of instruction fails."]
          #[codec(index = 14u8)]
          SchedulingFailed(sp_runtime::DispatchError),
          #[doc = "Instruction is rescheduled."]
          #[doc = "(caller DID, instruction_id)"]
          #[codec(index = 15u8)]
          InstructionRescheduled(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "An existing venue's signers has been updated (did, venue_id, signers, update_type)"]
          #[codec(index = 16u8)]
          VenueSignersUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::VenueId,
            ::alloc::vec::Vec<AccountId>,
            bool,
          ),
          #[doc = "Settlement manually executed (did, id)"]
          #[codec(index = 17u8)]
          SettlementManuallyExecuted(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::InstructionId,
          ),
          #[doc = "A new instruction has been created"]
          #[doc = "(did, venue_id, instruction_id, settlement_type, trade_date, value_date, legs, memo)"]
          #[codec(index = 18u8)]
          InstructionCreated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::settlement::VenueId,
            polymesh_primitives::settlement::InstructionId,
            polymesh_primitives::settlement::SettlementType<BlockNumber>,
            Option<Moment>,
            Option<Moment>,
            ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
            Option<polymesh_primitives::Memo>,
          ),
          #[doc = "Failed to execute instruction."]
          #[codec(index = 19u8)]
          FailedToExecuteInstruction(
            polymesh_primitives::settlement::InstructionId,
            sp_runtime::DispatchError,
          ),
        }
        impl<Moment, BlockNumber, AccountId> SettlementEvent<Moment, BlockNumber, AccountId> {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::VenueCreated(_, _, _, _) => "Settlement.VenueCreated",
              Self::VenueDetailsUpdated(_, _, _) => "Settlement.VenueDetailsUpdated",
              Self::VenueTypeUpdated(_, _, _) => "Settlement.VenueTypeUpdated",
              Self::InstructionAffirmed(_, _, _) => "Settlement.InstructionAffirmed",
              Self::AffirmationWithdrawn(_, _, _) => "Settlement.AffirmationWithdrawn",
              Self::InstructionRejected(_, _) => "Settlement.InstructionRejected",
              Self::ReceiptClaimed(_, _, _, _, _, _) => "Settlement.ReceiptClaimed",
              Self::VenueFiltering(_, _, _) => "Settlement.VenueFiltering",
              Self::VenuesAllowed(_, _, _) => "Settlement.VenuesAllowed",
              Self::VenuesBlocked(_, _, _) => "Settlement.VenuesBlocked",
              Self::LegFailedExecution(_, _, _) => "Settlement.LegFailedExecution",
              Self::InstructionFailed(_, _) => "Settlement.InstructionFailed",
              Self::InstructionExecuted(_, _) => "Settlement.InstructionExecuted",
              Self::VenueUnauthorized(_, _, _) => "Settlement.VenueUnauthorized",
              Self::SchedulingFailed(_) => "Settlement.SchedulingFailed",
              Self::InstructionRescheduled(_, _) => "Settlement.InstructionRescheduled",
              Self::VenueSignersUpdated(_, _, _, _) => "Settlement.VenueSignersUpdated",
              Self::SettlementManuallyExecuted(_, _) => "Settlement.SettlementManuallyExecuted",
              Self::InstructionCreated(_, _, _, _, _, _, _, _) => "Settlement.InstructionCreated",
              Self::FailedToExecuteInstruction(_, _) => "Settlement.FailedToExecuteInstruction",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl<Moment, BlockNumber, AccountId> ::polymesh_api_client::EnumInfo
          for SettlementEvent<Moment, BlockNumber, AccountId>
        {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: VenueCreated (_ , _ , _ , _) => { & ["A new venue has been created (did, venue_id, details, type)" ,] } , Self :: VenueDetailsUpdated (_ , _ , _) => { & ["An existing venue's details has been updated (did, venue_id, details)" ,] } , Self :: VenueTypeUpdated (_ , _ , _) => { & ["An existing venue's type has been updated (did, venue_id, type)" ,] } , Self :: InstructionAffirmed (_ , _ , _) => { & ["An instruction has been affirmed (did, portfolio, instruction_id)" ,] } , Self :: AffirmationWithdrawn (_ , _ , _) => { & ["An affirmation has been withdrawn (did, portfolio, instruction_id)" ,] } , Self :: InstructionRejected (_ , _) => { & ["An instruction has been rejected (did, instruction_id)" ,] } , Self :: ReceiptClaimed (_ , _ , _ , _ , _ , _) => { & ["A receipt has been claimed (did, instruction_id, leg_id, receipt_uid, signer, receipt metadata)" ,] } , Self :: VenueFiltering (_ , _ , _) => { & ["Venue filtering has been enabled or disabled for a ticker (did, ticker, filtering_enabled)" ,] } , Self :: VenuesAllowed (_ , _ , _) => { & ["Venues added to allow list (did, ticker, vec<venue_id>)" ,] } , Self :: VenuesBlocked (_ , _ , _) => { & ["Venues added to block list (did, ticker, vec<venue_id>)" ,] } , Self :: LegFailedExecution (_ , _ , _) => { & ["Execution of a leg failed (did, instruction_id, leg_id)" ,] } , Self :: InstructionFailed (_ , _) => { & ["Instruction failed execution (did, instruction_id)" ,] } , Self :: InstructionExecuted (_ , _) => { & ["Instruction executed successfully(did, instruction_id)" ,] } , Self :: VenueUnauthorized (_ , _ , _) => { & ["Venue not part of the token's allow list (did, Ticker, venue_id)" ,] } , Self :: SchedulingFailed (_) => { & ["Scheduling of instruction fails." ,] } , Self :: InstructionRescheduled (_ , _) => { & ["Instruction is rescheduled." , "(caller DID, instruction_id)" ,] } , Self :: VenueSignersUpdated (_ , _ , _ , _) => { & ["An existing venue's signers has been updated (did, venue_id, signers, update_type)" ,] } , Self :: SettlementManuallyExecuted (_ , _) => { & ["Settlement manually executed (did, id)" ,] } , Self :: InstructionCreated (_ , _ , _ , _ , _ , _ , _ , _) => { & ["A new instruction has been created" , "(did, venue_id, instruction_id, settlement_type, trade_date, value_date, legs, memo)" ,] } , Self :: FailedToExecuteInstruction (_ , _) => { & ["Failed to execute instruction." ,] } , _ => & [""] , }
          }
        }
        impl<Moment, BlockNumber, AccountId> From<SettlementEvent<Moment, BlockNumber, AccountId>>
          for &'static str
        {
          fn from(v: SettlementEvent<Moment, BlockNumber, AccountId>) -> Self {
            v.as_static_str()
          }
        }
        impl<Moment, BlockNumber, AccountId> From<&SettlementEvent<Moment, BlockNumber, AccountId>>
          for &'static str
        {
          fn from(v: &SettlementEvent<Moment, BlockNumber, AccountId>) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod relayer {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum RelayerEvent<AccountId> {
          #[doc = "Authorization given for `paying_key` to `user_key`."]
          #[doc = ""]
          #[doc = "(Caller DID, User Key, Paying Key, Initial POLYX limit, Auth ID)"]
          #[codec(index = 0u8)]
          AuthorizedPayingKey(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            AccountId,
            AccountId,
            u128,
            u64,
          ),
          #[doc = "Accepted paying key."]
          #[doc = ""]
          #[doc = "(Caller DID, User Key, Paying Key)"]
          #[codec(index = 1u8)]
          AcceptedPayingKey(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            AccountId,
            AccountId,
          ),
          #[doc = "Removed paying key."]
          #[doc = ""]
          #[doc = "(Caller DID, User Key, Paying Key)"]
          #[codec(index = 2u8)]
          RemovedPayingKey(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            AccountId,
            AccountId,
          ),
          #[doc = "Updated polyx limit."]
          #[doc = ""]
          #[doc = "(Caller DID, User Key, Paying Key, POLYX limit, old remaining POLYX)"]
          #[codec(index = 3u8)]
          UpdatedPolyxLimit(
            polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
            AccountId,
            AccountId,
            u128,
            u128,
          ),
        }
        impl<AccountId> RelayerEvent<AccountId> {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::AuthorizedPayingKey(_, _, _, _, _) => "Relayer.AuthorizedPayingKey",
              Self::AcceptedPayingKey(_, _, _) => "Relayer.AcceptedPayingKey",
              Self::RemovedPayingKey(_, _, _) => "Relayer.RemovedPayingKey",
              Self::UpdatedPolyxLimit(_, _, _, _, _) => "Relayer.UpdatedPolyxLimit",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl<AccountId> ::polymesh_api_client::EnumInfo for RelayerEvent<AccountId> {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            #[allow(unreachable_patterns)]
            match self {
              Self::AuthorizedPayingKey(_, _, _, _, _) => &[
                "Authorization given for `paying_key` to `user_key`.",
                "",
                "(Caller DID, User Key, Paying Key, Initial POLYX limit, Auth ID)",
              ],
              Self::AcceptedPayingKey(_, _, _) => &[
                "Accepted paying key.",
                "",
                "(Caller DID, User Key, Paying Key)",
              ],
              Self::RemovedPayingKey(_, _, _) => &[
                "Removed paying key.",
                "",
                "(Caller DID, User Key, Paying Key)",
              ],
              Self::UpdatedPolyxLimit(_, _, _, _, _) => &[
                "Updated polyx limit.",
                "",
                "(Caller DID, User Key, Paying Key, POLYX limit, old remaining POLYX)",
              ],
              _ => &[""],
            }
          }
        }
        impl<AccountId> From<RelayerEvent<AccountId>> for &'static str {
          fn from(v: RelayerEvent<AccountId>) -> Self {
            v.as_static_str()
          }
        }
        impl<AccountId> From<&RelayerEvent<AccountId>> for &'static str {
          fn from(v: &RelayerEvent<AccountId>) -> Self {
            v.as_static_str()
          }
        }
      }
      pub mod asset {
        use super::*;
        #[doc = "Events for this module."]
        #[doc = ""]
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum AssetEvent<Moment, AccountId> {
          #[doc = "Event for creation of the asset."]
          #[doc = "caller DID/ owner DID, ticker, divisibility, asset type, beneficiary DID, asset name, identifiers, funding round"]
          #[codec(index = 0u8)]
          AssetCreated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            bool,
            polymesh_primitives::asset::AssetType,
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::asset::AssetName,
            ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
            Option<polymesh_primitives::asset::FundingRoundName>,
          ),
          #[doc = "Event emitted when any token identifiers are updated."]
          #[doc = "caller DID, ticker, a vector of (identifier type, identifier value)"]
          #[codec(index = 1u8)]
          IdentifiersUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
          ),
          #[doc = "Event for change in divisibility."]
          #[doc = "caller DID, ticker, divisibility"]
          #[codec(index = 2u8)]
          DivisibilityChanged(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            bool,
          ),
          #[doc = "An additional event to Transfer; emitted when `transfer_with_data` is called."]
          #[doc = "caller DID , ticker, from DID, to DID, value, data"]
          #[codec(index = 3u8)]
          TransferWithData(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::IdentityId,
            u128,
            ::alloc::vec::Vec<u8>,
          ),
          #[doc = "is_issuable() output"]
          #[doc = "ticker, return value (true if issuable)"]
          #[codec(index = 4u8)]
          IsIssuable(polymesh_primitives::ticker::Ticker, bool),
          #[doc = "Emit when ticker is registered."]
          #[doc = "caller DID / ticker owner did, ticker, ticker owner, expiry"]
          #[codec(index = 5u8)]
          TickerRegistered(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            Option<Moment>,
          ),
          #[doc = "Emit when ticker is transferred."]
          #[doc = "caller DID / ticker transferred to DID, ticker, from"]
          #[codec(index = 6u8)]
          TickerTransferred(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "Emit when token ownership is transferred."]
          #[doc = "caller DID / token ownership transferred to DID, ticker, from"]
          #[codec(index = 7u8)]
          AssetOwnershipTransferred(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            ::polymesh_api_client::IdentityId,
          ),
          #[doc = "An event emitted when an asset is frozen."]
          #[doc = "Parameter: caller DID, ticker."]
          #[codec(index = 8u8)]
          AssetFrozen(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
          ),
          #[doc = "An event emitted when an asset is unfrozen."]
          #[doc = "Parameter: caller DID, ticker."]
          #[codec(index = 9u8)]
          AssetUnfrozen(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
          ),
          #[doc = "An event emitted when a token is renamed."]
          #[doc = "Parameters: caller DID, ticker, new token name."]
          #[codec(index = 10u8)]
          AssetRenamed(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::asset::AssetName,
          ),
          #[doc = "An event carrying the name of the current funding round of a ticker."]
          #[doc = "Parameters: caller DID, ticker, funding round name."]
          #[codec(index = 11u8)]
          FundingRoundSet(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::asset::FundingRoundName,
          ),
          #[doc = "A new document attached to an asset"]
          #[codec(index = 12u8)]
          DocumentAdded(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::document::DocumentId,
            polymesh_primitives::document::Document,
          ),
          #[doc = "A document removed from an asset"]
          #[codec(index = 13u8)]
          DocumentRemoved(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::document::DocumentId,
          ),
          #[doc = "A extension got removed."]
          #[doc = "caller DID, ticker, AccountId"]
          #[codec(index = 14u8)]
          ExtensionRemoved(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            AccountId,
          ),
          #[doc = "Event for when a forced transfer takes place."]
          #[doc = "caller DID/ controller DID, ticker, Portfolio of token holder, value."]
          #[codec(index = 15u8)]
          ControllerTransfer(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::identity_id::PortfolioId,
            u128,
          ),
          #[doc = "A custom asset type already exists on-chain."]
          #[doc = "caller DID, the ID of the custom asset type, the string contents registered."]
          #[codec(index = 16u8)]
          CustomAssetTypeExists(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::asset::CustomAssetTypeId,
            ::alloc::vec::Vec<u8>,
          ),
          #[doc = "A custom asset type was registered on-chain."]
          #[doc = "caller DID, the ID of the custom asset type, the string contents registered."]
          #[codec(index = 17u8)]
          CustomAssetTypeRegistered(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::asset::CustomAssetTypeId,
            ::alloc::vec::Vec<u8>,
          ),
          #[doc = "Set asset metadata value."]
          #[doc = "(Caller DID, ticker, metadata value, optional value details)"]
          #[codec(index = 18u8)]
          SetAssetMetadataValue(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::asset_metadata::AssetMetadataValue,
            Option<polymesh_primitives::asset_metadata::AssetMetadataValueDetail<Moment>>,
          ),
          #[doc = "Set asset metadata value details (expire, lock status)."]
          #[doc = "(Caller DID, ticker, value details)"]
          #[codec(index = 19u8)]
          SetAssetMetadataValueDetails(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::asset_metadata::AssetMetadataValueDetail<Moment>,
          ),
          #[doc = "Register asset metadata local type."]
          #[doc = "(Caller DID, ticker, Local type name, Local type key, type specs)"]
          #[codec(index = 20u8)]
          RegisterAssetMetadataLocalType(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::asset_metadata::AssetMetadataName,
            polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
            polymesh_primitives::asset_metadata::AssetMetadataSpec,
          ),
          #[doc = "Register asset metadata global type."]
          #[doc = "(Global type name, Global type key, type specs)"]
          #[codec(index = 21u8)]
          RegisterAssetMetadataGlobalType(
            polymesh_primitives::asset_metadata::AssetMetadataName,
            polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
            polymesh_primitives::asset_metadata::AssetMetadataSpec,
          ),
          #[doc = "An event emitted when the type of an asset changed."]
          #[doc = "Parameters: caller DID, ticker, new token type."]
          #[codec(index = 22u8)]
          AssetTypeChanged(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::asset::AssetType,
          ),
          #[doc = "An event emitted when a local metadata key has been removed."]
          #[doc = "Parameters: caller ticker, Local type name"]
          #[codec(index = 23u8)]
          LocalMetadataKeyDeleted(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
          ),
          #[doc = "An event emitted when a local metadata value has been removed."]
          #[doc = "Parameters: caller ticker, Local type name"]
          #[codec(index = 24u8)]
          MetadataValueDeleted(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            polymesh_primitives::asset_metadata::AssetMetadataKey,
          ),
          #[doc = "Emitted when Tokens were issued, redeemed or transferred."]
          #[doc = "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`Ticker`] for the token, the balance that was issued/transferred/redeemed,"]
          #[doc = "the [`PortfolioId`] of the source, the [`PortfolioId`] of the destination and the [`PortfolioUpdateReason`]."]
          #[codec(index = 25u8)]
          AssetBalanceUpdated(
            ::polymesh_api_client::IdentityId,
            polymesh_primitives::ticker::Ticker,
            u128,
            Option<polymesh_primitives::identity_id::PortfolioId>,
            Option<polymesh_primitives::identity_id::PortfolioId>,
            polymesh_primitives::portfolio::PortfolioUpdateReason,
          ),
        }
        impl<Moment, AccountId> AssetEvent<Moment, AccountId> {
          pub fn as_static_str(&self) -> &'static str {
            #[allow(unreachable_patterns)]
            match self {
              Self::AssetCreated(_, _, _, _, _, _, _, _) => "Asset.AssetCreated",
              Self::IdentifiersUpdated(_, _, _) => "Asset.IdentifiersUpdated",
              Self::DivisibilityChanged(_, _, _) => "Asset.DivisibilityChanged",
              Self::TransferWithData(_, _, _, _, _, _) => "Asset.TransferWithData",
              Self::IsIssuable(_, _) => "Asset.IsIssuable",
              Self::TickerRegistered(_, _, _) => "Asset.TickerRegistered",
              Self::TickerTransferred(_, _, _) => "Asset.TickerTransferred",
              Self::AssetOwnershipTransferred(_, _, _) => "Asset.AssetOwnershipTransferred",
              Self::AssetFrozen(_, _) => "Asset.AssetFrozen",
              Self::AssetUnfrozen(_, _) => "Asset.AssetUnfrozen",
              Self::AssetRenamed(_, _, _) => "Asset.AssetRenamed",
              Self::FundingRoundSet(_, _, _) => "Asset.FundingRoundSet",
              Self::DocumentAdded(_, _, _, _) => "Asset.DocumentAdded",
              Self::DocumentRemoved(_, _, _) => "Asset.DocumentRemoved",
              Self::ExtensionRemoved(_, _, _) => "Asset.ExtensionRemoved",
              Self::ControllerTransfer(_, _, _, _) => "Asset.ControllerTransfer",
              Self::CustomAssetTypeExists(_, _, _) => "Asset.CustomAssetTypeExists",
              Self::CustomAssetTypeRegistered(_, _, _) => "Asset.CustomAssetTypeRegistered",
              Self::SetAssetMetadataValue(_, _, _, _) => "Asset.SetAssetMetadataValue",
              Self::SetAssetMetadataValueDetails(_, _, _) => "Asset.SetAssetMetadataValueDetails",
              Self::RegisterAssetMetadataLocalType(_, _, _, _, _) => {
                "Asset.RegisterAssetMetadataLocalType"
              }
              Self::RegisterAssetMetadataGlobalType(_, _, _) => {
                "Asset.RegisterAssetMetadataGlobalType"
              }
              Self::AssetTypeChanged(_, _, _) => "Asset.AssetTypeChanged",
              Self::LocalMetadataKeyDeleted(_, _, _) => "Asset.LocalMetadataKeyDeleted",
              Self::MetadataValueDeleted(_, _, _) => "Asset.MetadataValueDeleted",
              Self::AssetBalanceUpdated(_, _, _, _, _, _) => "Asset.AssetBalanceUpdated",
              _ => "Unknown",
            }
          }
        }
        #[cfg(not(feature = "ink"))]
        impl<Moment, AccountId> ::polymesh_api_client::EnumInfo for AssetEvent<Moment, AccountId> {
          fn as_name(&self) -> &'static str {
            self.as_static_str()
          }
          fn as_docs(&self) -> &'static [&'static str] {
            # [allow (unreachable_patterns)] match self { Self :: AssetCreated (_ , _ , _ , _ , _ , _ , _ , _) => { & ["Event for creation of the asset." , "caller DID/ owner DID, ticker, divisibility, asset type, beneficiary DID, asset name, identifiers, funding round" ,] } , Self :: IdentifiersUpdated (_ , _ , _) => { & ["Event emitted when any token identifiers are updated." , "caller DID, ticker, a vector of (identifier type, identifier value)" ,] } , Self :: DivisibilityChanged (_ , _ , _) => { & ["Event for change in divisibility." , "caller DID, ticker, divisibility" ,] } , Self :: TransferWithData (_ , _ , _ , _ , _ , _) => { & ["An additional event to Transfer; emitted when `transfer_with_data` is called." , "caller DID , ticker, from DID, to DID, value, data" ,] } , Self :: IsIssuable (_ , _) => { & ["is_issuable() output" , "ticker, return value (true if issuable)" ,] } , Self :: TickerRegistered (_ , _ , _) => { & ["Emit when ticker is registered." , "caller DID / ticker owner did, ticker, ticker owner, expiry" ,] } , Self :: TickerTransferred (_ , _ , _) => { & ["Emit when ticker is transferred." , "caller DID / ticker transferred to DID, ticker, from" ,] } , Self :: AssetOwnershipTransferred (_ , _ , _) => { & ["Emit when token ownership is transferred." , "caller DID / token ownership transferred to DID, ticker, from" ,] } , Self :: AssetFrozen (_ , _) => { & ["An event emitted when an asset is frozen." , "Parameter: caller DID, ticker." ,] } , Self :: AssetUnfrozen (_ , _) => { & ["An event emitted when an asset is unfrozen." , "Parameter: caller DID, ticker." ,] } , Self :: AssetRenamed (_ , _ , _) => { & ["An event emitted when a token is renamed." , "Parameters: caller DID, ticker, new token name." ,] } , Self :: FundingRoundSet (_ , _ , _) => { & ["An event carrying the name of the current funding round of a ticker." , "Parameters: caller DID, ticker, funding round name." ,] } , Self :: DocumentAdded (_ , _ , _ , _) => { & ["A new document attached to an asset" ,] } , Self :: DocumentRemoved (_ , _ , _) => { & ["A document removed from an asset" ,] } , Self :: ExtensionRemoved (_ , _ , _) => { & ["A extension got removed." , "caller DID, ticker, AccountId" ,] } , Self :: ControllerTransfer (_ , _ , _ , _) => { & ["Event for when a forced transfer takes place." , "caller DID/ controller DID, ticker, Portfolio of token holder, value." ,] } , Self :: CustomAssetTypeExists (_ , _ , _) => { & ["A custom asset type already exists on-chain." , "caller DID, the ID of the custom asset type, the string contents registered." ,] } , Self :: CustomAssetTypeRegistered (_ , _ , _) => { & ["A custom asset type was registered on-chain." , "caller DID, the ID of the custom asset type, the string contents registered." ,] } , Self :: SetAssetMetadataValue (_ , _ , _ , _) => { & ["Set asset metadata value." , "(Caller DID, ticker, metadata value, optional value details)" ,] } , Self :: SetAssetMetadataValueDetails (_ , _ , _) => { & ["Set asset metadata value details (expire, lock status)." , "(Caller DID, ticker, value details)" ,] } , Self :: RegisterAssetMetadataLocalType (_ , _ , _ , _ , _) => { & ["Register asset metadata local type." , "(Caller DID, ticker, Local type name, Local type key, type specs)" ,] } , Self :: RegisterAssetMetadataGlobalType (_ , _ , _) => { & ["Register asset metadata global type." , "(Global type name, Global type key, type specs)" ,] } , Self :: AssetTypeChanged (_ , _ , _) => { & ["An event emitted when the type of an asset changed." , "Parameters: caller DID, ticker, new token type." ,] } , Self :: LocalMetadataKeyDeleted (_ , _ , _) => { & ["An event emitted when a local metadata key has been removed." , "Parameters: caller ticker, Local type name" ,] } , Self :: MetadataValueDeleted (_ , _ , _) => { & ["An event emitted when a local metadata value has been removed." , "Parameters: caller ticker, Local type name" ,] } , Self :: AssetBalanceUpdated (_ , _ , _ , _ , _ , _) => { & ["Emitted when Tokens were issued, redeemed or transferred." , "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`Ticker`] for the token, the balance that was issued/transferred/redeemed," , "the [`PortfolioId`] of the source, the [`PortfolioId`] of the destination and the [`PortfolioUpdateReason`]." ,] } , _ => & [""] , }
          }
        }
        impl<Moment, AccountId> From<AssetEvent<Moment, AccountId>> for &'static str {
          fn from(v: AssetEvent<Moment, AccountId>) -> Self {
            v.as_static_str()
          }
        }
        impl<Moment, AccountId> From<&AssetEvent<Moment, AccountId>> for &'static str {
          fn from(v: &AssetEvent<Moment, AccountId>) -> Self {
            v.as_static_str()
          }
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum MaybeBlock<BlockNumber> {
      #[codec(index = 0u8)]
      Some(BlockNumber),
      #[codec(index = 1u8)]
      None,
    }
  }
  pub mod pallet_protocol_fee {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ProtocolFeeError {
      #[doc = "Insufficient account balance to pay the fee."]
      #[codec(index = 0u8)]
      InsufficientAccountBalance,
      #[doc = "Not able to handled the imbalances"]
      #[codec(index = 1u8)]
      UnHandledImbalances,
      #[doc = "Insufficient subsidy balance to pay the fee."]
      #[codec(index = 2u8)]
      InsufficientSubsidyBalance,
    }
    impl ProtocolFeeError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::InsufficientAccountBalance => "ProtocolFee.InsufficientAccountBalance",
          Self::UnHandledImbalances => "ProtocolFee.UnHandledImbalances",
          Self::InsufficientSubsidyBalance => "ProtocolFee.InsufficientSubsidyBalance",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ProtocolFeeError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::InsufficientAccountBalance => &["Insufficient account balance to pay the fee."],
          Self::UnHandledImbalances => &["Not able to handled the imbalances"],
          Self::InsufficientSubsidyBalance => &["Insufficient subsidy balance to pay the fee."],
          _ => &[""],
        }
      }
    }
    impl From<ProtocolFeeError> for &'static str {
      fn from(v: ProtocolFeeError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ProtocolFeeError> for &'static str {
      fn from(v: &ProtocolFeeError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ProtocolFeeCall {
      #[doc = "Changes the fee coefficient for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[codec(index = 0u8)]
      change_coefficient {
        coefficient: polymesh_primitives::PosRatio,
      },
      #[doc = "Changes the a base fee for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[codec(index = 1u8)]
      change_base_fee {
        op: polymesh_common_utilities::protocol_fee::ProtocolOp,
        base_fee: u128,
      },
    }
    impl ProtocolFeeCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::change_coefficient { .. } => "ProtocolFee.change_coefficient",
          Self::change_base_fee { .. } => "ProtocolFee.change_base_fee",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ProtocolFeeCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::change_coefficient { .. } => &[
            "Changes the fee coefficient for the root origin.",
            "",
            "# Errors",
            "* `BadOrigin` - Only root allowed.",
          ],
          Self::change_base_fee { .. } => &[
            "Changes the a base fee for the root origin.",
            "",
            "# Errors",
            "* `BadOrigin` - Only root allowed.",
          ],
          _ => &[""],
        }
      }
    }
    impl From<ProtocolFeeCall> for &'static str {
      fn from(v: ProtocolFeeCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ProtocolFeeCall> for &'static str {
      fn from(v: &ProtocolFeeCall) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ProtocolFeeEvent<AccountId> {
      #[doc = "The protocol fee of an operation."]
      #[codec(index = 0u8)]
      FeeSet(::polymesh_api_client::IdentityId, u128),
      #[doc = "The fee coefficient."]
      #[codec(index = 1u8)]
      CoefficientSet(
        ::polymesh_api_client::IdentityId,
        polymesh_primitives::PosRatio,
      ),
      #[doc = "Fee charged."]
      #[codec(index = 2u8)]
      FeeCharged(AccountId, u128),
    }
    impl<AccountId> ProtocolFeeEvent<AccountId> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::FeeSet(_, _) => "ProtocolFee.FeeSet",
          Self::CoefficientSet(_, _) => "ProtocolFee.CoefficientSet",
          Self::FeeCharged(_, _) => "ProtocolFee.FeeCharged",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<AccountId> ::polymesh_api_client::EnumInfo for ProtocolFeeEvent<AccountId> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::FeeSet(_, _) => &["The protocol fee of an operation."],
          Self::CoefficientSet(_, _) => &["The fee coefficient."],
          Self::FeeCharged(_, _) => &["Fee charged."],
          _ => &[""],
        }
      }
    }
    impl<AccountId> From<ProtocolFeeEvent<AccountId>> for &'static str {
      fn from(v: ProtocolFeeEvent<AccountId>) -> Self {
        v.as_static_str()
      }
    }
    impl<AccountId> From<&ProtocolFeeEvent<AccountId>> for &'static str {
      fn from(v: &ProtocolFeeEvent<AccountId>) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod sp_runtime {
    use super::*;
    pub mod traits {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BlakeTwo256();
    }
    pub mod generic {
      use super::*;
      pub mod unchecked_extrinsic {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct UncheckedExtrinsic<Address, Call, Signature, Extra>(
          pub ::alloc::vec::Vec<u8>,
          core::marker::PhantomData<(Address, Call, Signature, Extra)>,
        );
      }
      pub mod header {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Header<Number, Hash> {
          pub parent_hash: primitive_types::H256,
          #[codec(compact)]
          pub number: Number,
          pub state_root: primitive_types::H256,
          pub extrinsics_root: primitive_types::H256,
          pub digest: sp_runtime::generic::digest::Digest,
          _phantom_data: core::marker::PhantomData<Hash>,
        }
      }
      pub mod digest {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Digest {
          pub logs: ::alloc::vec::Vec<sp_runtime::generic::digest::DigestItem>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum DigestItem {
          #[codec(index = 6u8)]
          PreRuntime([u8; 4usize], ::alloc::vec::Vec<u8>),
          #[codec(index = 4u8)]
          Consensus([u8; 4usize], ::alloc::vec::Vec<u8>),
          #[codec(index = 5u8)]
          Seal([u8; 4usize], ::alloc::vec::Vec<u8>),
          #[codec(index = 0u8)]
          Other(::alloc::vec::Vec<u8>),
          #[codec(index = 8u8)]
          RuntimeEnvironmentUpdated,
        }
      }
      pub mod era {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Era {
          #[codec(index = 0u8)]
          Immortal,
          #[codec(index = 1u8)]
          Mortal1(u8),
          #[codec(index = 2u8)]
          Mortal2(u8),
          #[codec(index = 3u8)]
          Mortal3(u8),
          #[codec(index = 4u8)]
          Mortal4(u8),
          #[codec(index = 5u8)]
          Mortal5(u8),
          #[codec(index = 6u8)]
          Mortal6(u8),
          #[codec(index = 7u8)]
          Mortal7(u8),
          #[codec(index = 8u8)]
          Mortal8(u8),
          #[codec(index = 9u8)]
          Mortal9(u8),
          #[codec(index = 10u8)]
          Mortal10(u8),
          #[codec(index = 11u8)]
          Mortal11(u8),
          #[codec(index = 12u8)]
          Mortal12(u8),
          #[codec(index = 13u8)]
          Mortal13(u8),
          #[codec(index = 14u8)]
          Mortal14(u8),
          #[codec(index = 15u8)]
          Mortal15(u8),
          #[codec(index = 16u8)]
          Mortal16(u8),
          #[codec(index = 17u8)]
          Mortal17(u8),
          #[codec(index = 18u8)]
          Mortal18(u8),
          #[codec(index = 19u8)]
          Mortal19(u8),
          #[codec(index = 20u8)]
          Mortal20(u8),
          #[codec(index = 21u8)]
          Mortal21(u8),
          #[codec(index = 22u8)]
          Mortal22(u8),
          #[codec(index = 23u8)]
          Mortal23(u8),
          #[codec(index = 24u8)]
          Mortal24(u8),
          #[codec(index = 25u8)]
          Mortal25(u8),
          #[codec(index = 26u8)]
          Mortal26(u8),
          #[codec(index = 27u8)]
          Mortal27(u8),
          #[codec(index = 28u8)]
          Mortal28(u8),
          #[codec(index = 29u8)]
          Mortal29(u8),
          #[codec(index = 30u8)]
          Mortal30(u8),
          #[codec(index = 31u8)]
          Mortal31(u8),
          #[codec(index = 32u8)]
          Mortal32(u8),
          #[codec(index = 33u8)]
          Mortal33(u8),
          #[codec(index = 34u8)]
          Mortal34(u8),
          #[codec(index = 35u8)]
          Mortal35(u8),
          #[codec(index = 36u8)]
          Mortal36(u8),
          #[codec(index = 37u8)]
          Mortal37(u8),
          #[codec(index = 38u8)]
          Mortal38(u8),
          #[codec(index = 39u8)]
          Mortal39(u8),
          #[codec(index = 40u8)]
          Mortal40(u8),
          #[codec(index = 41u8)]
          Mortal41(u8),
          #[codec(index = 42u8)]
          Mortal42(u8),
          #[codec(index = 43u8)]
          Mortal43(u8),
          #[codec(index = 44u8)]
          Mortal44(u8),
          #[codec(index = 45u8)]
          Mortal45(u8),
          #[codec(index = 46u8)]
          Mortal46(u8),
          #[codec(index = 47u8)]
          Mortal47(u8),
          #[codec(index = 48u8)]
          Mortal48(u8),
          #[codec(index = 49u8)]
          Mortal49(u8),
          #[codec(index = 50u8)]
          Mortal50(u8),
          #[codec(index = 51u8)]
          Mortal51(u8),
          #[codec(index = 52u8)]
          Mortal52(u8),
          #[codec(index = 53u8)]
          Mortal53(u8),
          #[codec(index = 54u8)]
          Mortal54(u8),
          #[codec(index = 55u8)]
          Mortal55(u8),
          #[codec(index = 56u8)]
          Mortal56(u8),
          #[codec(index = 57u8)]
          Mortal57(u8),
          #[codec(index = 58u8)]
          Mortal58(u8),
          #[codec(index = 59u8)]
          Mortal59(u8),
          #[codec(index = 60u8)]
          Mortal60(u8),
          #[codec(index = 61u8)]
          Mortal61(u8),
          #[codec(index = 62u8)]
          Mortal62(u8),
          #[codec(index = 63u8)]
          Mortal63(u8),
          #[codec(index = 64u8)]
          Mortal64(u8),
          #[codec(index = 65u8)]
          Mortal65(u8),
          #[codec(index = 66u8)]
          Mortal66(u8),
          #[codec(index = 67u8)]
          Mortal67(u8),
          #[codec(index = 68u8)]
          Mortal68(u8),
          #[codec(index = 69u8)]
          Mortal69(u8),
          #[codec(index = 70u8)]
          Mortal70(u8),
          #[codec(index = 71u8)]
          Mortal71(u8),
          #[codec(index = 72u8)]
          Mortal72(u8),
          #[codec(index = 73u8)]
          Mortal73(u8),
          #[codec(index = 74u8)]
          Mortal74(u8),
          #[codec(index = 75u8)]
          Mortal75(u8),
          #[codec(index = 76u8)]
          Mortal76(u8),
          #[codec(index = 77u8)]
          Mortal77(u8),
          #[codec(index = 78u8)]
          Mortal78(u8),
          #[codec(index = 79u8)]
          Mortal79(u8),
          #[codec(index = 80u8)]
          Mortal80(u8),
          #[codec(index = 81u8)]
          Mortal81(u8),
          #[codec(index = 82u8)]
          Mortal82(u8),
          #[codec(index = 83u8)]
          Mortal83(u8),
          #[codec(index = 84u8)]
          Mortal84(u8),
          #[codec(index = 85u8)]
          Mortal85(u8),
          #[codec(index = 86u8)]
          Mortal86(u8),
          #[codec(index = 87u8)]
          Mortal87(u8),
          #[codec(index = 88u8)]
          Mortal88(u8),
          #[codec(index = 89u8)]
          Mortal89(u8),
          #[codec(index = 90u8)]
          Mortal90(u8),
          #[codec(index = 91u8)]
          Mortal91(u8),
          #[codec(index = 92u8)]
          Mortal92(u8),
          #[codec(index = 93u8)]
          Mortal93(u8),
          #[codec(index = 94u8)]
          Mortal94(u8),
          #[codec(index = 95u8)]
          Mortal95(u8),
          #[codec(index = 96u8)]
          Mortal96(u8),
          #[codec(index = 97u8)]
          Mortal97(u8),
          #[codec(index = 98u8)]
          Mortal98(u8),
          #[codec(index = 99u8)]
          Mortal99(u8),
          #[codec(index = 100u8)]
          Mortal100(u8),
          #[codec(index = 101u8)]
          Mortal101(u8),
          #[codec(index = 102u8)]
          Mortal102(u8),
          #[codec(index = 103u8)]
          Mortal103(u8),
          #[codec(index = 104u8)]
          Mortal104(u8),
          #[codec(index = 105u8)]
          Mortal105(u8),
          #[codec(index = 106u8)]
          Mortal106(u8),
          #[codec(index = 107u8)]
          Mortal107(u8),
          #[codec(index = 108u8)]
          Mortal108(u8),
          #[codec(index = 109u8)]
          Mortal109(u8),
          #[codec(index = 110u8)]
          Mortal110(u8),
          #[codec(index = 111u8)]
          Mortal111(u8),
          #[codec(index = 112u8)]
          Mortal112(u8),
          #[codec(index = 113u8)]
          Mortal113(u8),
          #[codec(index = 114u8)]
          Mortal114(u8),
          #[codec(index = 115u8)]
          Mortal115(u8),
          #[codec(index = 116u8)]
          Mortal116(u8),
          #[codec(index = 117u8)]
          Mortal117(u8),
          #[codec(index = 118u8)]
          Mortal118(u8),
          #[codec(index = 119u8)]
          Mortal119(u8),
          #[codec(index = 120u8)]
          Mortal120(u8),
          #[codec(index = 121u8)]
          Mortal121(u8),
          #[codec(index = 122u8)]
          Mortal122(u8),
          #[codec(index = 123u8)]
          Mortal123(u8),
          #[codec(index = 124u8)]
          Mortal124(u8),
          #[codec(index = 125u8)]
          Mortal125(u8),
          #[codec(index = 126u8)]
          Mortal126(u8),
          #[codec(index = 127u8)]
          Mortal127(u8),
          #[codec(index = 128u8)]
          Mortal128(u8),
          #[codec(index = 129u8)]
          Mortal129(u8),
          #[codec(index = 130u8)]
          Mortal130(u8),
          #[codec(index = 131u8)]
          Mortal131(u8),
          #[codec(index = 132u8)]
          Mortal132(u8),
          #[codec(index = 133u8)]
          Mortal133(u8),
          #[codec(index = 134u8)]
          Mortal134(u8),
          #[codec(index = 135u8)]
          Mortal135(u8),
          #[codec(index = 136u8)]
          Mortal136(u8),
          #[codec(index = 137u8)]
          Mortal137(u8),
          #[codec(index = 138u8)]
          Mortal138(u8),
          #[codec(index = 139u8)]
          Mortal139(u8),
          #[codec(index = 140u8)]
          Mortal140(u8),
          #[codec(index = 141u8)]
          Mortal141(u8),
          #[codec(index = 142u8)]
          Mortal142(u8),
          #[codec(index = 143u8)]
          Mortal143(u8),
          #[codec(index = 144u8)]
          Mortal144(u8),
          #[codec(index = 145u8)]
          Mortal145(u8),
          #[codec(index = 146u8)]
          Mortal146(u8),
          #[codec(index = 147u8)]
          Mortal147(u8),
          #[codec(index = 148u8)]
          Mortal148(u8),
          #[codec(index = 149u8)]
          Mortal149(u8),
          #[codec(index = 150u8)]
          Mortal150(u8),
          #[codec(index = 151u8)]
          Mortal151(u8),
          #[codec(index = 152u8)]
          Mortal152(u8),
          #[codec(index = 153u8)]
          Mortal153(u8),
          #[codec(index = 154u8)]
          Mortal154(u8),
          #[codec(index = 155u8)]
          Mortal155(u8),
          #[codec(index = 156u8)]
          Mortal156(u8),
          #[codec(index = 157u8)]
          Mortal157(u8),
          #[codec(index = 158u8)]
          Mortal158(u8),
          #[codec(index = 159u8)]
          Mortal159(u8),
          #[codec(index = 160u8)]
          Mortal160(u8),
          #[codec(index = 161u8)]
          Mortal161(u8),
          #[codec(index = 162u8)]
          Mortal162(u8),
          #[codec(index = 163u8)]
          Mortal163(u8),
          #[codec(index = 164u8)]
          Mortal164(u8),
          #[codec(index = 165u8)]
          Mortal165(u8),
          #[codec(index = 166u8)]
          Mortal166(u8),
          #[codec(index = 167u8)]
          Mortal167(u8),
          #[codec(index = 168u8)]
          Mortal168(u8),
          #[codec(index = 169u8)]
          Mortal169(u8),
          #[codec(index = 170u8)]
          Mortal170(u8),
          #[codec(index = 171u8)]
          Mortal171(u8),
          #[codec(index = 172u8)]
          Mortal172(u8),
          #[codec(index = 173u8)]
          Mortal173(u8),
          #[codec(index = 174u8)]
          Mortal174(u8),
          #[codec(index = 175u8)]
          Mortal175(u8),
          #[codec(index = 176u8)]
          Mortal176(u8),
          #[codec(index = 177u8)]
          Mortal177(u8),
          #[codec(index = 178u8)]
          Mortal178(u8),
          #[codec(index = 179u8)]
          Mortal179(u8),
          #[codec(index = 180u8)]
          Mortal180(u8),
          #[codec(index = 181u8)]
          Mortal181(u8),
          #[codec(index = 182u8)]
          Mortal182(u8),
          #[codec(index = 183u8)]
          Mortal183(u8),
          #[codec(index = 184u8)]
          Mortal184(u8),
          #[codec(index = 185u8)]
          Mortal185(u8),
          #[codec(index = 186u8)]
          Mortal186(u8),
          #[codec(index = 187u8)]
          Mortal187(u8),
          #[codec(index = 188u8)]
          Mortal188(u8),
          #[codec(index = 189u8)]
          Mortal189(u8),
          #[codec(index = 190u8)]
          Mortal190(u8),
          #[codec(index = 191u8)]
          Mortal191(u8),
          #[codec(index = 192u8)]
          Mortal192(u8),
          #[codec(index = 193u8)]
          Mortal193(u8),
          #[codec(index = 194u8)]
          Mortal194(u8),
          #[codec(index = 195u8)]
          Mortal195(u8),
          #[codec(index = 196u8)]
          Mortal196(u8),
          #[codec(index = 197u8)]
          Mortal197(u8),
          #[codec(index = 198u8)]
          Mortal198(u8),
          #[codec(index = 199u8)]
          Mortal199(u8),
          #[codec(index = 200u8)]
          Mortal200(u8),
          #[codec(index = 201u8)]
          Mortal201(u8),
          #[codec(index = 202u8)]
          Mortal202(u8),
          #[codec(index = 203u8)]
          Mortal203(u8),
          #[codec(index = 204u8)]
          Mortal204(u8),
          #[codec(index = 205u8)]
          Mortal205(u8),
          #[codec(index = 206u8)]
          Mortal206(u8),
          #[codec(index = 207u8)]
          Mortal207(u8),
          #[codec(index = 208u8)]
          Mortal208(u8),
          #[codec(index = 209u8)]
          Mortal209(u8),
          #[codec(index = 210u8)]
          Mortal210(u8),
          #[codec(index = 211u8)]
          Mortal211(u8),
          #[codec(index = 212u8)]
          Mortal212(u8),
          #[codec(index = 213u8)]
          Mortal213(u8),
          #[codec(index = 214u8)]
          Mortal214(u8),
          #[codec(index = 215u8)]
          Mortal215(u8),
          #[codec(index = 216u8)]
          Mortal216(u8),
          #[codec(index = 217u8)]
          Mortal217(u8),
          #[codec(index = 218u8)]
          Mortal218(u8),
          #[codec(index = 219u8)]
          Mortal219(u8),
          #[codec(index = 220u8)]
          Mortal220(u8),
          #[codec(index = 221u8)]
          Mortal221(u8),
          #[codec(index = 222u8)]
          Mortal222(u8),
          #[codec(index = 223u8)]
          Mortal223(u8),
          #[codec(index = 224u8)]
          Mortal224(u8),
          #[codec(index = 225u8)]
          Mortal225(u8),
          #[codec(index = 226u8)]
          Mortal226(u8),
          #[codec(index = 227u8)]
          Mortal227(u8),
          #[codec(index = 228u8)]
          Mortal228(u8),
          #[codec(index = 229u8)]
          Mortal229(u8),
          #[codec(index = 230u8)]
          Mortal230(u8),
          #[codec(index = 231u8)]
          Mortal231(u8),
          #[codec(index = 232u8)]
          Mortal232(u8),
          #[codec(index = 233u8)]
          Mortal233(u8),
          #[codec(index = 234u8)]
          Mortal234(u8),
          #[codec(index = 235u8)]
          Mortal235(u8),
          #[codec(index = 236u8)]
          Mortal236(u8),
          #[codec(index = 237u8)]
          Mortal237(u8),
          #[codec(index = 238u8)]
          Mortal238(u8),
          #[codec(index = 239u8)]
          Mortal239(u8),
          #[codec(index = 240u8)]
          Mortal240(u8),
          #[codec(index = 241u8)]
          Mortal241(u8),
          #[codec(index = 242u8)]
          Mortal242(u8),
          #[codec(index = 243u8)]
          Mortal243(u8),
          #[codec(index = 244u8)]
          Mortal244(u8),
          #[codec(index = 245u8)]
          Mortal245(u8),
          #[codec(index = 246u8)]
          Mortal246(u8),
          #[codec(index = 247u8)]
          Mortal247(u8),
          #[codec(index = 248u8)]
          Mortal248(u8),
          #[codec(index = 249u8)]
          Mortal249(u8),
          #[codec(index = 250u8)]
          Mortal250(u8),
          #[codec(index = 251u8)]
          Mortal251(u8),
          #[codec(index = 252u8)]
          Mortal252(u8),
          #[codec(index = 253u8)]
          Mortal253(u8),
          #[codec(index = 254u8)]
          Mortal254(u8),
          #[codec(index = 255u8)]
          Mortal255(u8),
        }
      }
    }
    pub mod multiaddress {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum MultiAddress<AccountId, AccountIndex> {
        #[codec(index = 0u8)]
        Id(AccountId),
        #[codec(index = 1u8)]
        Index(#[codec(compact)] AccountIndex),
        #[codec(index = 2u8)]
        Raw(::alloc::vec::Vec<u8>),
        #[codec(index = 3u8)]
        Address32([u8; 32usize]),
        #[codec(index = 4u8)]
        Address20([u8; 20usize]),
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum MultiSignature {
      #[codec(index = 0u8)]
      Ed25519(sp_core::ed25519::Signature),
      #[codec(index = 1u8)]
      Sr25519(sp_core::sr25519::Signature),
      #[codec(index = 2u8)]
      Ecdsa(sp_core::ecdsa::Signature),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TransactionalError {
      #[codec(index = 0u8)]
      LimitReached,
      #[codec(index = 1u8)]
      NoLayer,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TokenError {
      #[codec(index = 0u8)]
      NoFunds,
      #[codec(index = 1u8)]
      WouldDie,
      #[codec(index = 2u8)]
      BelowMinimum,
      #[codec(index = 3u8)]
      CannotCreate,
      #[codec(index = 4u8)]
      UnknownAsset,
      #[codec(index = 5u8)]
      Frozen,
      #[codec(index = 6u8)]
      Unsupported,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum DispatchError {
      Other,
      CannotLookup,
      BadOrigin,
      Module(ModuleError),
      ConsumerRemaining,
      NoProviders,
      TooManyConsumers,
      Token(TokenError),
      Arithmetic(::sp_arithmetic::ArithmeticError),
    }
    impl DispatchError {
      pub fn as_static_str(&self) -> &'static str {
        match self {
          Self::Other => "Other",
          Self::CannotLookup => "CannotLookup",
          Self::BadOrigin => "BadOrigin",
          Self::Module(err) => err.as_static_str(),
          Self::ConsumerRemaining => "ConsumerRemaining",
          Self::NoProviders => "NoProviders",
          Self::TooManyConsumers => "TooManyConsumers",
          Self::Token(err) => match err {
            TokenError::NoFunds => "Token::NoFunds",
            TokenError::WouldDie => "Token::WouldDie",
            TokenError::BelowMinimum => "Token::BelowMinimum",
            TokenError::CannotCreate => "Token::CannotCreate",
            TokenError::UnknownAsset => "Token::UnknownAsset",
            TokenError::Frozen => "Token::Frozen",
            TokenError::Unsupported => "Token::Unsupported",
          },
          Self::Arithmetic(err) => match err {
            ::sp_arithmetic::ArithmeticError::Underflow => "Arithmetic::Underflow",
            ::sp_arithmetic::ArithmeticError::Overflow => "Arithmetic::Overflow",
            ::sp_arithmetic::ArithmeticError::DivisionByZero => "Arithmetic::DivisionByZero",
          },
        }
      }
    }
    impl From<DispatchError> for &'static str {
      fn from(v: DispatchError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&DispatchError> for &'static str {
      fn from(v: &DispatchError) -> Self {
        v.as_static_str()
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for DispatchError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        match self {
          Self::Other => &["Some error occurred."],
          Self::CannotLookup => &["Failed to lookup some data."],
          Self::BadOrigin => &["A bad origin."],
          Self::Module(err) => err.as_docs(),
          Self::ConsumerRemaining => {
            &["At least one consumer is remaining so the account cannot be destroyed."]
          }
          Self::NoProviders => &["There are no providers so the account cannot be created."],
          Self::TooManyConsumers => {
            &["There are too many consumers so the account cannot be created."]
          }
          Self::Token(err) => match err {
            TokenError::NoFunds => &["Funds are unavailable."],
            TokenError::WouldDie => &["Account that must exist would die."],
            TokenError::BelowMinimum => {
              &["Account cannot exist with the funds that would be given."]
            }
            TokenError::CannotCreate => &["Account cannot be created."],
            TokenError::UnknownAsset => &["The asset in question is unknown."],
            TokenError::Frozen => &["Funds exist but are frozen."],
            TokenError::Unsupported => &["Operation is not supported by the asset."],
          },
          Self::Arithmetic(err) => match err {
            ::sp_arithmetic::ArithmeticError::Underflow => &["Arithmetic underflow"],
            ::sp_arithmetic::ArithmeticError::Overflow => &["Arithmetic overflow"],
            ::sp_arithmetic::ArithmeticError::DivisionByZero => &["Arithmetic divide by zero"],
          },
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RuntimeError {
      #[codec(index = 0u8)]
      System(frame_system::pallet::SystemError),
      #[codec(index = 1u8)]
      Babe(pallet_babe::pallet::BabeError),
      #[codec(index = 3u8)]
      Indices(pallet_indices::pallet::IndicesError),
      #[codec(index = 5u8)]
      Balances(pallet_balances::BalancesError),
      #[codec(index = 7u8)]
      Identity(pallet_identity::IdentityError),
      #[codec(index = 8u8)]
      CddServiceProviders(pallet_group::UpgradeCommitteeMembershipError),
      #[codec(index = 9u8)]
      PolymeshCommittee(pallet_committee::UpgradeCommitteeError),
      #[codec(index = 10u8)]
      CommitteeMembership(pallet_group::UpgradeCommitteeMembershipError),
      #[codec(index = 11u8)]
      TechnicalCommittee(pallet_committee::UpgradeCommitteeError),
      #[codec(index = 12u8)]
      TechnicalCommitteeMembership(pallet_group::UpgradeCommitteeMembershipError),
      #[codec(index = 13u8)]
      UpgradeCommittee(pallet_committee::UpgradeCommitteeError),
      #[codec(index = 14u8)]
      UpgradeCommitteeMembership(pallet_group::UpgradeCommitteeMembershipError),
      #[codec(index = 15u8)]
      MultiSig(pallet_multisig::MultiSigError),
      #[codec(index = 16u8)]
      Bridge(pallet_bridge::BridgeError),
      #[codec(index = 17u8)]
      Staking(pallet_staking::StakingError),
      #[codec(index = 19u8)]
      Session(pallet_session::pallet::SessionError),
      #[codec(index = 21u8)]
      Grandpa(pallet_grandpa::pallet::GrandpaError),
      #[codec(index = 23u8)]
      ImOnline(pallet_im_online::pallet::ImOnlineError),
      #[codec(index = 25u8)]
      Sudo(pallet_sudo::SudoError),
      #[codec(index = 26u8)]
      Asset(pallet_asset::AssetError),
      #[codec(index = 27u8)]
      CapitalDistribution(pallet_corporate_actions::distribution::CapitalDistributionError),
      #[codec(index = 28u8)]
      Checkpoint(pallet_asset::checkpoint::CheckpointError),
      #[codec(index = 29u8)]
      ComplianceManager(pallet_compliance_manager::ComplianceManagerError),
      #[codec(index = 30u8)]
      CorporateAction(pallet_corporate_actions::CorporateActionError),
      #[codec(index = 31u8)]
      CorporateBallot(pallet_corporate_actions::ballot::CorporateBallotError),
      #[codec(index = 32u8)]
      Permissions(pallet_permissions::PermissionsError),
      #[codec(index = 33u8)]
      Pips(pallet_pips::PipsError),
      #[codec(index = 34u8)]
      Portfolio(pallet_portfolio::PortfolioError),
      #[codec(index = 35u8)]
      ProtocolFee(pallet_protocol_fee::ProtocolFeeError),
      #[codec(index = 36u8)]
      Scheduler(pallet_scheduler::pallet::SchedulerError),
      #[codec(index = 37u8)]
      Settlement(pallet_settlement::SettlementError),
      #[codec(index = 38u8)]
      Statistics(pallet_statistics::StatisticsError),
      #[codec(index = 39u8)]
      Sto(pallet_sto::StoError),
      #[codec(index = 40u8)]
      Treasury(pallet_treasury::TreasuryError),
      #[codec(index = 41u8)]
      Utility(pallet_utility::pallet::UtilityError),
      #[codec(index = 42u8)]
      Base(pallet_base::BaseError),
      #[codec(index = 43u8)]
      ExternalAgents(pallet_external_agents::ExternalAgentsError),
      #[codec(index = 44u8)]
      Relayer(pallet_relayer::RelayerError),
      #[codec(index = 46u8)]
      Contracts(pallet_contracts::pallet::ContractsError),
      #[codec(index = 47u8)]
      PolymeshContracts(polymesh_contracts::PolymeshContractsError),
      #[codec(index = 48u8)]
      Preimage(pallet_preimage::pallet::PreimageError),
      #[codec(index = 49u8)]
      Nft(pallet_nft::NftError),
      #[codec(index = 50u8)]
      TestUtils(pallet_test_utils::TestUtilsError),
    }
    impl RuntimeError {
      pub fn as_static_str(&self) -> &'static str {
        match self {
          RuntimeError::System(err) => err.as_static_str(),
          RuntimeError::Babe(err) => err.as_static_str(),
          RuntimeError::Indices(err) => err.as_static_str(),
          RuntimeError::Balances(err) => err.as_static_str(),
          RuntimeError::Identity(err) => err.as_static_str(),
          RuntimeError::CddServiceProviders(err) => err.as_static_str(),
          RuntimeError::PolymeshCommittee(err) => err.as_static_str(),
          RuntimeError::CommitteeMembership(err) => err.as_static_str(),
          RuntimeError::TechnicalCommittee(err) => err.as_static_str(),
          RuntimeError::TechnicalCommitteeMembership(err) => err.as_static_str(),
          RuntimeError::UpgradeCommittee(err) => err.as_static_str(),
          RuntimeError::UpgradeCommitteeMembership(err) => err.as_static_str(),
          RuntimeError::MultiSig(err) => err.as_static_str(),
          RuntimeError::Bridge(err) => err.as_static_str(),
          RuntimeError::Staking(err) => err.as_static_str(),
          RuntimeError::Session(err) => err.as_static_str(),
          RuntimeError::Grandpa(err) => err.as_static_str(),
          RuntimeError::ImOnline(err) => err.as_static_str(),
          RuntimeError::Sudo(err) => err.as_static_str(),
          RuntimeError::Asset(err) => err.as_static_str(),
          RuntimeError::CapitalDistribution(err) => err.as_static_str(),
          RuntimeError::Checkpoint(err) => err.as_static_str(),
          RuntimeError::ComplianceManager(err) => err.as_static_str(),
          RuntimeError::CorporateAction(err) => err.as_static_str(),
          RuntimeError::CorporateBallot(err) => err.as_static_str(),
          RuntimeError::Permissions(err) => err.as_static_str(),
          RuntimeError::Pips(err) => err.as_static_str(),
          RuntimeError::Portfolio(err) => err.as_static_str(),
          RuntimeError::ProtocolFee(err) => err.as_static_str(),
          RuntimeError::Scheduler(err) => err.as_static_str(),
          RuntimeError::Settlement(err) => err.as_static_str(),
          RuntimeError::Statistics(err) => err.as_static_str(),
          RuntimeError::Sto(err) => err.as_static_str(),
          RuntimeError::Treasury(err) => err.as_static_str(),
          RuntimeError::Utility(err) => err.as_static_str(),
          RuntimeError::Base(err) => err.as_static_str(),
          RuntimeError::ExternalAgents(err) => err.as_static_str(),
          RuntimeError::Relayer(err) => err.as_static_str(),
          RuntimeError::Contracts(err) => err.as_static_str(),
          RuntimeError::PolymeshContracts(err) => err.as_static_str(),
          RuntimeError::Preimage(err) => err.as_static_str(),
          RuntimeError::Nft(err) => err.as_static_str(),
          RuntimeError::TestUtils(err) => err.as_static_str(),
        }
      }
    }
    impl From<RuntimeError> for &'static str {
      fn from(v: RuntimeError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&RuntimeError> for &'static str {
      fn from(v: &RuntimeError) -> Self {
        v.as_static_str()
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for RuntimeError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        match self {
          RuntimeError::System(err) => err.as_docs(),
          RuntimeError::Babe(err) => err.as_docs(),
          RuntimeError::Indices(err) => err.as_docs(),
          RuntimeError::Balances(err) => err.as_docs(),
          RuntimeError::Identity(err) => err.as_docs(),
          RuntimeError::CddServiceProviders(err) => err.as_docs(),
          RuntimeError::PolymeshCommittee(err) => err.as_docs(),
          RuntimeError::CommitteeMembership(err) => err.as_docs(),
          RuntimeError::TechnicalCommittee(err) => err.as_docs(),
          RuntimeError::TechnicalCommitteeMembership(err) => err.as_docs(),
          RuntimeError::UpgradeCommittee(err) => err.as_docs(),
          RuntimeError::UpgradeCommitteeMembership(err) => err.as_docs(),
          RuntimeError::MultiSig(err) => err.as_docs(),
          RuntimeError::Bridge(err) => err.as_docs(),
          RuntimeError::Staking(err) => err.as_docs(),
          RuntimeError::Session(err) => err.as_docs(),
          RuntimeError::Grandpa(err) => err.as_docs(),
          RuntimeError::ImOnline(err) => err.as_docs(),
          RuntimeError::Sudo(err) => err.as_docs(),
          RuntimeError::Asset(err) => err.as_docs(),
          RuntimeError::CapitalDistribution(err) => err.as_docs(),
          RuntimeError::Checkpoint(err) => err.as_docs(),
          RuntimeError::ComplianceManager(err) => err.as_docs(),
          RuntimeError::CorporateAction(err) => err.as_docs(),
          RuntimeError::CorporateBallot(err) => err.as_docs(),
          RuntimeError::Permissions(err) => err.as_docs(),
          RuntimeError::Pips(err) => err.as_docs(),
          RuntimeError::Portfolio(err) => err.as_docs(),
          RuntimeError::ProtocolFee(err) => err.as_docs(),
          RuntimeError::Scheduler(err) => err.as_docs(),
          RuntimeError::Settlement(err) => err.as_docs(),
          RuntimeError::Statistics(err) => err.as_docs(),
          RuntimeError::Sto(err) => err.as_docs(),
          RuntimeError::Treasury(err) => err.as_docs(),
          RuntimeError::Utility(err) => err.as_docs(),
          RuntimeError::Base(err) => err.as_docs(),
          RuntimeError::ExternalAgents(err) => err.as_docs(),
          RuntimeError::Relayer(err) => err.as_docs(),
          RuntimeError::Contracts(err) => err.as_docs(),
          RuntimeError::PolymeshContracts(err) => err.as_docs(),
          RuntimeError::Preimage(err) => err.as_docs(),
          RuntimeError::Nft(err) => err.as_docs(),
          RuntimeError::TestUtils(err) => err.as_docs(),
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ModuleError(pub RuntimeError);
    impl ::codec::Encode for ModuleError {
      fn encode_to<T: ::codec::Output + ?Sized>(&self, output: &mut T) {
        let mut raw = self.0.encode();
        raw.resize(5usize, 0);
        output.write(raw.as_slice());
      }
    }
    impl ::codec::Decode for ModuleError {
      fn decode<I: ::codec::Input>(input: &mut I) -> Result<Self, ::codec::Error> {
        let raw: [u8; 5usize] = ::codec::Decode::decode(input)?;
        Ok(Self(RuntimeError::decode(&mut &raw[..])?))
      }
    }
    impl ModuleError {
      pub fn as_static_str(&self) -> &'static str {
        self.0.as_static_str()
      }
    }
    impl From<ModuleError> for &'static str {
      fn from(v: ModuleError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ModuleError> for &'static str {
      fn from(v: &ModuleError) -> Self {
        v.as_static_str()
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ModuleError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        self.0.as_docs()
      }
    }
  }
  pub mod pallet_compliance_manager {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ComplianceManagerCall {
      #[doc = "Adds a compliance requirement to an asset's compliance by ticker."]
      #[doc = "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = "* sender_conditions - Sender transfer conditions."]
      #[doc = "* receiver_conditions - Receiver transfer conditions."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 0u8)]
      add_compliance_requirement {
        ticker: polymesh_primitives::ticker::Ticker,
        sender_conditions: ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
        receiver_conditions: ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
      },
      #[doc = "Removes a compliance requirement from an asset's compliance."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = "* id - Compliance requirement id which is need to be removed"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 1u8)]
      remove_compliance_requirement {
        ticker: polymesh_primitives::ticker::Ticker,
        id: u32,
      },
      #[doc = "Replaces an asset's compliance by ticker with a new compliance."]
      #[doc = ""]
      #[doc = "Compliance requirements will be sorted (ascending by id) before"]
      #[doc = "replacing the current requirements."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `ticker` - the asset ticker,"]
      #[doc = "* `asset_compliance - the new asset compliance."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `Unauthorized` if `origin` is not the owner of the ticker."]
      #[doc = "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 2u8)]
      replace_asset_compliance {
        ticker: polymesh_primitives::ticker::Ticker,
        asset_compliance:
          ::alloc::vec::Vec<polymesh_primitives::compliance_manager::ComplianceRequirement>,
      },
      #[doc = "Removes an asset's compliance"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 3u8)]
      reset_asset_compliance {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Pauses the verification of conditions for `ticker` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 4u8)]
      pause_asset_compliance {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Resumes the verification of conditions for `ticker` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 5u8)]
      resume_asset_compliance {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Adds another default trusted claim issuer at the ticker level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker."]
      #[doc = "* ticker - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 6u8)]
      add_default_trusted_claim_issuer {
        ticker: polymesh_primitives::ticker::Ticker,
        issuer: polymesh_primitives::condition::TrustedIssuer,
      },
      #[doc = "Removes the given `issuer` from the set of default trusted claim issuers at the ticker level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker."]
      #[doc = "* ticker - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 7u8)]
      remove_default_trusted_claim_issuer {
        ticker: polymesh_primitives::ticker::Ticker,
        issuer: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Modify an existing compliance requirement of a given ticker."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker."]
      #[doc = "* ticker - Symbol of the asset."]
      #[doc = "* new_req - Compliance requirement."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 8u8)]
      change_compliance_requirement {
        ticker: polymesh_primitives::ticker::Ticker,
        new_req: polymesh_primitives::compliance_manager::ComplianceRequirement,
      },
    }
    impl ComplianceManagerCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::add_compliance_requirement { .. } => "ComplianceManager.add_compliance_requirement",
          Self::remove_compliance_requirement { .. } => {
            "ComplianceManager.remove_compliance_requirement"
          }
          Self::replace_asset_compliance { .. } => "ComplianceManager.replace_asset_compliance",
          Self::reset_asset_compliance { .. } => "ComplianceManager.reset_asset_compliance",
          Self::pause_asset_compliance { .. } => "ComplianceManager.pause_asset_compliance",
          Self::resume_asset_compliance { .. } => "ComplianceManager.resume_asset_compliance",
          Self::add_default_trusted_claim_issuer { .. } => {
            "ComplianceManager.add_default_trusted_claim_issuer"
          }
          Self::remove_default_trusted_claim_issuer { .. } => {
            "ComplianceManager.remove_default_trusted_claim_issuer"
          }
          Self::change_compliance_requirement { .. } => {
            "ComplianceManager.change_compliance_requirement"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ComplianceManagerCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: add_compliance_requirement { .. } => { & ["Adds a compliance requirement to an asset's compliance by ticker." , "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the ticker" , "* ticker - Symbol of the asset" , "* sender_conditions - Sender transfer conditions." , "* receiver_conditions - Receiver transfer conditions." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_compliance_requirement { .. } => { & ["Removes a compliance requirement from an asset's compliance." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the ticker" , "* ticker - Symbol of the asset" , "* id - Compliance requirement id which is need to be removed" , "" , "# Permissions" , "* Asset" ,] } , Self :: replace_asset_compliance { .. } => { & ["Replaces an asset's compliance by ticker with a new compliance." , "" , "Compliance requirements will be sorted (ascending by id) before" , "replacing the current requirements." , "" , "# Arguments" , "* `ticker` - the asset ticker," , "* `asset_compliance - the new asset compliance." , "" , "# Errors" , "* `Unauthorized` if `origin` is not the owner of the ticker." , "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`." , "" , "# Permissions" , "* Asset" ,] } , Self :: reset_asset_compliance { .. } => { & ["Removes an asset's compliance" , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the ticker" , "* ticker - Symbol of the asset" , "" , "# Permissions" , "* Asset" ,] } , Self :: pause_asset_compliance { .. } => { & ["Pauses the verification of conditions for `ticker` during transfers." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the ticker" , "* ticker - Symbol of the asset" , "" , "# Permissions" , "* Asset" ,] } , Self :: resume_asset_compliance { .. } => { & ["Resumes the verification of conditions for `ticker` during transfers." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the ticker" , "* ticker - Symbol of the asset" , "" , "# Permissions" , "* Asset" ,] } , Self :: add_default_trusted_claim_issuer { .. } => { & ["Adds another default trusted claim issuer at the ticker level." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the ticker." , "* ticker - Symbol of the asset." , "* issuer - IdentityId of the trusted claim issuer." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_default_trusted_claim_issuer { .. } => { & ["Removes the given `issuer` from the set of default trusted claim issuers at the ticker level." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the ticker." , "* ticker - Symbol of the asset." , "* issuer - IdentityId of the trusted claim issuer." , "" , "# Permissions" , "* Asset" ,] } , Self :: change_compliance_requirement { .. } => { & ["Modify an existing compliance requirement of a given ticker." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the ticker." , "* ticker - Symbol of the asset." , "* new_req - Compliance requirement." , "" , "# Permissions" , "* Asset" ,] } , _ => & [""] , }
      }
    }
    impl From<ComplianceManagerCall> for &'static str {
      fn from(v: ComplianceManagerCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ComplianceManagerCall> for &'static str {
      fn from(v: &ComplianceManagerCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ComplianceManagerError {
      #[doc = "User is not authorized."]
      #[codec(index = 0u8)]
      Unauthorized,
      #[doc = "Did not exist."]
      #[codec(index = 1u8)]
      DidNotExist,
      #[doc = "Compliance requirement id doesn't exist."]
      #[codec(index = 2u8)]
      InvalidComplianceRequirementId,
      #[doc = "Issuer exist but trying to add it again."]
      #[codec(index = 3u8)]
      IncorrectOperationOnTrustedIssuer,
      #[doc = "There are duplicate compliance requirements."]
      #[codec(index = 4u8)]
      DuplicateComplianceRequirements,
      #[doc = "The worst case scenario of the compliance requirement is too complex."]
      #[codec(index = 5u8)]
      ComplianceRequirementTooComplex,
      #[doc = "The maximum weight limit for executing the function was exceeded."]
      #[codec(index = 6u8)]
      WeightLimitExceeded,
    }
    impl ComplianceManagerError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::Unauthorized => "ComplianceManager.Unauthorized",
          Self::DidNotExist => "ComplianceManager.DidNotExist",
          Self::InvalidComplianceRequirementId => {
            "ComplianceManager.InvalidComplianceRequirementId"
          }
          Self::IncorrectOperationOnTrustedIssuer => {
            "ComplianceManager.IncorrectOperationOnTrustedIssuer"
          }
          Self::DuplicateComplianceRequirements => {
            "ComplianceManager.DuplicateComplianceRequirements"
          }
          Self::ComplianceRequirementTooComplex => {
            "ComplianceManager.ComplianceRequirementTooComplex"
          }
          Self::WeightLimitExceeded => "ComplianceManager.WeightLimitExceeded",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ComplianceManagerError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::Unauthorized => &["User is not authorized."],
          Self::DidNotExist => &["Did not exist."],
          Self::InvalidComplianceRequirementId => &["Compliance requirement id doesn't exist."],
          Self::IncorrectOperationOnTrustedIssuer => &["Issuer exist but trying to add it again."],
          Self::DuplicateComplianceRequirements => {
            &["There are duplicate compliance requirements."]
          }
          Self::ComplianceRequirementTooComplex => {
            &["The worst case scenario of the compliance requirement is too complex."]
          }
          Self::WeightLimitExceeded => {
            &["The maximum weight limit for executing the function was exceeded."]
          }
          _ => &[""],
        }
      }
    }
    impl From<ComplianceManagerError> for &'static str {
      fn from(v: ComplianceManagerError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ComplianceManagerError> for &'static str {
      fn from(v: &ComplianceManagerError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_settlement {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[doc = "Errors for the Settlement module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum SettlementError {
      #[doc = "Venue does not exist."]
      #[codec(index = 0u8)]
      InvalidVenue,
      #[doc = "Sender does not have required permissions."]
      #[codec(index = 1u8)]
      Unauthorized,
      #[doc = "Instruction has not been affirmed."]
      #[codec(index = 2u8)]
      InstructionNotAffirmed,
      #[doc = "Signer is not authorized by the venue."]
      #[codec(index = 3u8)]
      UnauthorizedSigner,
      #[doc = "Receipt already used."]
      #[codec(index = 4u8)]
      ReceiptAlreadyClaimed,
      #[doc = "Venue does not have required permissions."]
      #[codec(index = 5u8)]
      UnauthorizedVenue,
      #[doc = "Instruction has invalid dates"]
      #[codec(index = 6u8)]
      InstructionDatesInvalid,
      #[doc = "Instruction's target settle block reached."]
      #[codec(index = 7u8)]
      InstructionSettleBlockPassed,
      #[doc = "Offchain signature is invalid."]
      #[codec(index = 8u8)]
      InvalidSignature,
      #[doc = "Sender and receiver are the same."]
      #[codec(index = 9u8)]
      SameSenderReceiver,
      #[doc = "The provided settlement block number is in the past and cannot be used by the scheduler."]
      #[codec(index = 10u8)]
      SettleOnPastBlock,
      #[doc = "The current instruction affirmation status does not support the requested action."]
      #[codec(index = 11u8)]
      UnexpectedAffirmationStatus,
      #[doc = "Scheduling of an instruction fails."]
      #[codec(index = 12u8)]
      FailedToSchedule,
      #[doc = "Instruction status is unknown"]
      #[codec(index = 13u8)]
      UnknownInstruction,
      #[doc = "Signer is already added to venue."]
      #[codec(index = 14u8)]
      SignerAlreadyExists,
      #[doc = "Signer is not added to venue."]
      #[codec(index = 15u8)]
      SignerDoesNotExist,
      #[doc = "Instruction leg amount can't be zero."]
      #[codec(index = 16u8)]
      ZeroAmount,
      #[doc = "Instruction settlement block has not yet been reached."]
      #[codec(index = 17u8)]
      InstructionSettleBlockNotReached,
      #[doc = "The caller is not a party of this instruction."]
      #[codec(index = 18u8)]
      CallerIsNotAParty,
      #[doc = "The number of nfts being transferred in the instruction was exceeded."]
      #[codec(index = 19u8)]
      MaxNumberOfNFTsExceeded,
      #[doc = "The given number of nfts being transferred was underestimated."]
      #[codec(index = 20u8)]
      NumberOfTransferredNFTsUnderestimated,
      #[doc = "Off-chain receipts can only be used for off-chain leg type."]
      #[codec(index = 21u8)]
      ReceiptForInvalidLegType,
      #[doc = "The maximum weight limit for executing the function was exceeded."]
      #[codec(index = 22u8)]
      WeightLimitExceeded,
      #[doc = "The maximum number of fungible assets was exceeded."]
      #[codec(index = 23u8)]
      MaxNumberOfFungibleAssetsExceeded,
      #[doc = "The maximum number of off-chain assets was exceeded."]
      #[codec(index = 24u8)]
      MaxNumberOfOffChainAssetsExceeded,
      #[doc = "The given number of fungible transfers was underestimated."]
      #[codec(index = 25u8)]
      NumberOfFungibleTransfersUnderestimated,
      #[doc = "Ticker could not be found on chain."]
      #[codec(index = 26u8)]
      UnexpectedOFFChainAsset,
      #[doc = "Off-Chain assets cannot be locked."]
      #[codec(index = 27u8)]
      OffChainAssetCantBeLocked,
      #[doc = "The given number of off-chain transfers was underestimated."]
      #[codec(index = 28u8)]
      NumberOfOffChainTransfersUnderestimated,
      #[doc = "No leg with the given id was found"]
      #[codec(index = 29u8)]
      LegNotFound,
      #[doc = "The input weight is less than the minimum required."]
      #[codec(index = 30u8)]
      InputWeightIsLessThanMinimum,
      #[doc = "The maximum number of receipts was exceeded."]
      #[codec(index = 31u8)]
      MaxNumberOfReceiptsExceeded,
      #[doc = "There are parties who have not affirmed the instruction."]
      #[codec(index = 32u8)]
      NotAllAffirmationsHaveBeenReceived,
      #[doc = "Only [`InstructionStatus::Pending`] or [`InstructionStatus::Failed`] instructions can be executed."]
      #[codec(index = 33u8)]
      InvalidInstructionStatusForExecution,
      #[doc = "The instruction failed to release asset locks or transfer the assets."]
      #[codec(index = 34u8)]
      FailedToReleaseLockOrTransferAssets,
      #[doc = "No duplicate uid are allowed for different receipts."]
      #[codec(index = 35u8)]
      DuplicateReceiptUid,
      #[doc = "The instruction id in all receipts must match the extrinsic parameter."]
      #[codec(index = 36u8)]
      ReceiptInstructionIdMissmatch,
      #[doc = "Multiple receipts for the same leg are not allowed."]
      #[codec(index = 37u8)]
      MultipleReceiptsForOneLeg,
      #[doc = "An invalid has been reached."]
      #[codec(index = 38u8)]
      UnexpectedLegStatus,
      #[doc = "The maximum number of venue signers was exceeded."]
      #[codec(index = 39u8)]
      NumberOfVenueSignersExceeded,
    }
    impl SettlementError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::InvalidVenue => "Settlement.InvalidVenue",
          Self::Unauthorized => "Settlement.Unauthorized",
          Self::InstructionNotAffirmed => "Settlement.InstructionNotAffirmed",
          Self::UnauthorizedSigner => "Settlement.UnauthorizedSigner",
          Self::ReceiptAlreadyClaimed => "Settlement.ReceiptAlreadyClaimed",
          Self::UnauthorizedVenue => "Settlement.UnauthorizedVenue",
          Self::InstructionDatesInvalid => "Settlement.InstructionDatesInvalid",
          Self::InstructionSettleBlockPassed => "Settlement.InstructionSettleBlockPassed",
          Self::InvalidSignature => "Settlement.InvalidSignature",
          Self::SameSenderReceiver => "Settlement.SameSenderReceiver",
          Self::SettleOnPastBlock => "Settlement.SettleOnPastBlock",
          Self::UnexpectedAffirmationStatus => "Settlement.UnexpectedAffirmationStatus",
          Self::FailedToSchedule => "Settlement.FailedToSchedule",
          Self::UnknownInstruction => "Settlement.UnknownInstruction",
          Self::SignerAlreadyExists => "Settlement.SignerAlreadyExists",
          Self::SignerDoesNotExist => "Settlement.SignerDoesNotExist",
          Self::ZeroAmount => "Settlement.ZeroAmount",
          Self::InstructionSettleBlockNotReached => "Settlement.InstructionSettleBlockNotReached",
          Self::CallerIsNotAParty => "Settlement.CallerIsNotAParty",
          Self::MaxNumberOfNFTsExceeded => "Settlement.MaxNumberOfNFTsExceeded",
          Self::NumberOfTransferredNFTsUnderestimated => {
            "Settlement.NumberOfTransferredNFTsUnderestimated"
          }
          Self::ReceiptForInvalidLegType => "Settlement.ReceiptForInvalidLegType",
          Self::WeightLimitExceeded => "Settlement.WeightLimitExceeded",
          Self::MaxNumberOfFungibleAssetsExceeded => "Settlement.MaxNumberOfFungibleAssetsExceeded",
          Self::MaxNumberOfOffChainAssetsExceeded => "Settlement.MaxNumberOfOffChainAssetsExceeded",
          Self::NumberOfFungibleTransfersUnderestimated => {
            "Settlement.NumberOfFungibleTransfersUnderestimated"
          }
          Self::UnexpectedOFFChainAsset => "Settlement.UnexpectedOFFChainAsset",
          Self::OffChainAssetCantBeLocked => "Settlement.OffChainAssetCantBeLocked",
          Self::NumberOfOffChainTransfersUnderestimated => {
            "Settlement.NumberOfOffChainTransfersUnderestimated"
          }
          Self::LegNotFound => "Settlement.LegNotFound",
          Self::InputWeightIsLessThanMinimum => "Settlement.InputWeightIsLessThanMinimum",
          Self::MaxNumberOfReceiptsExceeded => "Settlement.MaxNumberOfReceiptsExceeded",
          Self::NotAllAffirmationsHaveBeenReceived => {
            "Settlement.NotAllAffirmationsHaveBeenReceived"
          }
          Self::InvalidInstructionStatusForExecution => {
            "Settlement.InvalidInstructionStatusForExecution"
          }
          Self::FailedToReleaseLockOrTransferAssets => {
            "Settlement.FailedToReleaseLockOrTransferAssets"
          }
          Self::DuplicateReceiptUid => "Settlement.DuplicateReceiptUid",
          Self::ReceiptInstructionIdMissmatch => "Settlement.ReceiptInstructionIdMissmatch",
          Self::MultipleReceiptsForOneLeg => "Settlement.MultipleReceiptsForOneLeg",
          Self::UnexpectedLegStatus => "Settlement.UnexpectedLegStatus",
          Self::NumberOfVenueSignersExceeded => "Settlement.NumberOfVenueSignersExceeded",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for SettlementError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: InvalidVenue => { & ["Venue does not exist." ,] } , Self :: Unauthorized => { & ["Sender does not have required permissions." ,] } , Self :: InstructionNotAffirmed => { & ["Instruction has not been affirmed." ,] } , Self :: UnauthorizedSigner => { & ["Signer is not authorized by the venue." ,] } , Self :: ReceiptAlreadyClaimed => { & ["Receipt already used." ,] } , Self :: UnauthorizedVenue => { & ["Venue does not have required permissions." ,] } , Self :: InstructionDatesInvalid => { & ["Instruction has invalid dates" ,] } , Self :: InstructionSettleBlockPassed => { & ["Instruction's target settle block reached." ,] } , Self :: InvalidSignature => { & ["Offchain signature is invalid." ,] } , Self :: SameSenderReceiver => { & ["Sender and receiver are the same." ,] } , Self :: SettleOnPastBlock => { & ["The provided settlement block number is in the past and cannot be used by the scheduler." ,] } , Self :: UnexpectedAffirmationStatus => { & ["The current instruction affirmation status does not support the requested action." ,] } , Self :: FailedToSchedule => { & ["Scheduling of an instruction fails." ,] } , Self :: UnknownInstruction => { & ["Instruction status is unknown" ,] } , Self :: SignerAlreadyExists => { & ["Signer is already added to venue." ,] } , Self :: SignerDoesNotExist => { & ["Signer is not added to venue." ,] } , Self :: ZeroAmount => { & ["Instruction leg amount can't be zero." ,] } , Self :: InstructionSettleBlockNotReached => { & ["Instruction settlement block has not yet been reached." ,] } , Self :: CallerIsNotAParty => { & ["The caller is not a party of this instruction." ,] } , Self :: MaxNumberOfNFTsExceeded => { & ["The number of nfts being transferred in the instruction was exceeded." ,] } , Self :: NumberOfTransferredNFTsUnderestimated => { & ["The given number of nfts being transferred was underestimated." ,] } , Self :: ReceiptForInvalidLegType => { & ["Off-chain receipts can only be used for off-chain leg type." ,] } , Self :: WeightLimitExceeded => { & ["The maximum weight limit for executing the function was exceeded." ,] } , Self :: MaxNumberOfFungibleAssetsExceeded => { & ["The maximum number of fungible assets was exceeded." ,] } , Self :: MaxNumberOfOffChainAssetsExceeded => { & ["The maximum number of off-chain assets was exceeded." ,] } , Self :: NumberOfFungibleTransfersUnderestimated => { & ["The given number of fungible transfers was underestimated." ,] } , Self :: UnexpectedOFFChainAsset => { & ["Ticker could not be found on chain." ,] } , Self :: OffChainAssetCantBeLocked => { & ["Off-Chain assets cannot be locked." ,] } , Self :: NumberOfOffChainTransfersUnderestimated => { & ["The given number of off-chain transfers was underestimated." ,] } , Self :: LegNotFound => { & ["No leg with the given id was found" ,] } , Self :: InputWeightIsLessThanMinimum => { & ["The input weight is less than the minimum required." ,] } , Self :: MaxNumberOfReceiptsExceeded => { & ["The maximum number of receipts was exceeded." ,] } , Self :: NotAllAffirmationsHaveBeenReceived => { & ["There are parties who have not affirmed the instruction." ,] } , Self :: InvalidInstructionStatusForExecution => { & ["Only [`InstructionStatus::Pending`] or [`InstructionStatus::Failed`] instructions can be executed." ,] } , Self :: FailedToReleaseLockOrTransferAssets => { & ["The instruction failed to release asset locks or transfer the assets." ,] } , Self :: DuplicateReceiptUid => { & ["No duplicate uid are allowed for different receipts." ,] } , Self :: ReceiptInstructionIdMissmatch => { & ["The instruction id in all receipts must match the extrinsic parameter." ,] } , Self :: MultipleReceiptsForOneLeg => { & ["Multiple receipts for the same leg are not allowed." ,] } , Self :: UnexpectedLegStatus => { & ["An invalid has been reached." ,] } , Self :: NumberOfVenueSignersExceeded => { & ["The maximum number of venue signers was exceeded." ,] } , _ => & [""] , }
      }
    }
    impl From<SettlementError> for &'static str {
      fn from(v: SettlementError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&SettlementError> for &'static str {
      fn from(v: &SettlementError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum SettlementCall {
      #[doc = "Registers a new venue."]
      #[doc = ""]
      #[doc = "* `details` - Extra details about a venue"]
      #[doc = "* `signers` - Array of signers that are allowed to sign receipts for this venue"]
      #[doc = "* `typ` - Type of venue being created"]
      #[codec(index = 0u8)]
      create_venue {
        details: polymesh_primitives::settlement::VenueDetails,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        typ: polymesh_primitives::settlement::VenueType,
      },
      #[doc = "Edit a venue's details."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `details` specifies the updated venue details."]
      #[codec(index = 1u8)]
      update_venue_details {
        id: polymesh_primitives::settlement::VenueId,
        details: polymesh_primitives::settlement::VenueDetails,
      },
      #[doc = "Edit a venue's type."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `type` specifies the new type of the venue."]
      #[codec(index = 2u8)]
      update_venue_type {
        id: polymesh_primitives::settlement::VenueId,
        typ: polymesh_primitives::settlement::VenueType,
      },
      #[doc = "Accepts an instruction and claims a signed receipt."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - Target instruction id."]
      #[doc = "* `leg_id` - Target leg id for the receipt"]
      #[doc = "* `receipt_uid` - Receipt ID generated by the signer."]
      #[doc = "* `signer` - Signer of the receipt."]
      #[doc = "* `signed_data` - Signed receipt."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to accept this instruction with."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 3u8)]
      affirm_with_receipts {
        id: polymesh_primitives::settlement::InstructionId,
        receipt_details: ::alloc::vec::Vec<
          polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            sp_runtime::MultiSignature,
          >,
        >,
        portfolios: ::alloc::vec::Vec<polymesh_primitives::identity_id::PortfolioId>,
      },
      #[doc = "Enables or disabled venue filtering for a token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `ticker` - Ticker of the token in question."]
      #[doc = "* `enabled` - Boolean that decides if the filtering should be enabled."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 4u8)]
      set_venue_filtering {
        ticker: polymesh_primitives::ticker::Ticker,
        enabled: bool,
      },
      #[doc = "Allows additional venues to create instructions involving an asset."]
      #[doc = ""]
      #[doc = "* `ticker` - Ticker of the token in question."]
      #[doc = "* `venues` - Array of venues that are allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 5u8)]
      allow_venues {
        ticker: polymesh_primitives::ticker::Ticker,
        venues: ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
      },
      #[doc = "Revokes permission given to venues for creating instructions involving a particular asset."]
      #[doc = ""]
      #[doc = "* `ticker` - Ticker of the token in question."]
      #[doc = "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 6u8)]
      disallow_venues {
        ticker: polymesh_primitives::ticker::Ticker,
        venues: ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
      },
      #[doc = "Edit a venue's signers."]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `signers` specifies the signers to add/remove."]
      #[doc = "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false."]
      #[codec(index = 7u8)]
      update_venue_signers {
        id: polymesh_primitives::settlement::VenueId,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        add_signers: bool,
      },
      #[doc = "Manually executes an instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`: The [`InstructionId`] of the instruction to be executed."]
      #[doc = "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction."]
      #[doc = "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]."]
      #[doc = "* `fungible_transfers`: The number of fungible legs in the instruction."]
      #[doc = "* `nfts_transfers`: The number of nfts being transferred in the instruction."]
      #[doc = "* `offchain_transfers`: The number of offchain legs in the instruction."]
      #[doc = "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction."]
      #[doc = "If the `weight_limit` is less than the required amount, the instruction will fail execution."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters."]
      #[codec(index = 8u8)]
      execute_manual_instruction {
        id: polymesh_primitives::settlement::InstructionId,
        portfolio: Option<polymesh_primitives::identity_id::PortfolioId>,
        fungible_transfers: u32,
        nfts_transfers: u32,
        offchain_transfers: u32,
        weight_limit: Option<::polymesh_api_client::sp_weights::Weight>,
      },
      #[doc = "Adds a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id` - ID of the venue this instruction belongs to."]
      #[doc = "* `settlement_type` - Defines if the instruction should be settled in the next block, after receiving all affirmations"]
      #[doc = "or waiting till a specific block."]
      #[doc = "* `trade_date` - Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date` - Optional date after which the instruction should be settled (not enforced)"]
      #[doc = "* `legs` - Legs included in this instruction."]
      #[doc = "* `memo` - Memo field for this instruction."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`950_000_000 + 1_000_000 * legs.len()`"]
      #[codec(index = 9u8)]
      add_instruction {
        venue_id: polymesh_primitives::settlement::VenueId,
        settlement_type: polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
        instruction_memo: Option<polymesh_primitives::Memo>,
      },
      #[doc = "Adds and affirms a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id` - ID of the venue this instruction belongs to."]
      #[doc = "* `settlement_type` - Defines if the instruction should be settled in the next block, after receiving all affirmations"]
      #[doc = "or waiting till a specific block."]
      #[doc = "* `trade_date` - Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date` - Optional date after which the instruction should be settled (not enforced)"]
      #[doc = "* `legs` - Legs included in this instruction."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to use in this affirmations."]
      #[doc = "* `instruction_memo` - Memo field for this instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 10u8)]
      add_and_affirm_instruction {
        venue_id: polymesh_primitives::settlement::VenueId,
        settlement_type: polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
        portfolios: ::alloc::vec::Vec<polymesh_primitives::identity_id::PortfolioId>,
        instruction_memo: Option<polymesh_primitives::Memo>,
      },
      #[doc = "Provide affirmation to an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The `InstructionId` of the instruction to be affirmed."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to affirm this instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 11u8)]
      affirm_instruction {
        id: polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::vec::Vec<polymesh_primitives::identity_id::PortfolioId>,
      },
      #[doc = "Withdraw an affirmation for a given instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - Instruction id for that affirmation get withdrawn."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to withdraw affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 12u8)]
      withdraw_affirmation {
        id: polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::vec::Vec<polymesh_primitives::identity_id::PortfolioId>,
      },
      #[doc = "Rejects an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - Instruction id to reject."]
      #[doc = "* `portfolio` - Portfolio to reject the instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 13u8)]
      reject_instruction {
        id: polymesh_primitives::settlement::InstructionId,
        portfolio: polymesh_primitives::identity_id::PortfolioId,
      },
      #[doc = "Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction."]
      #[codec(index = 14u8)]
      execute_scheduled_instruction {
        id: polymesh_primitives::settlement::InstructionId,
        weight_limit: ::polymesh_api_client::sp_weights::Weight,
      },
    }
    impl SettlementCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_venue { .. } => "Settlement.create_venue",
          Self::update_venue_details { .. } => "Settlement.update_venue_details",
          Self::update_venue_type { .. } => "Settlement.update_venue_type",
          Self::affirm_with_receipts { .. } => "Settlement.affirm_with_receipts",
          Self::set_venue_filtering { .. } => "Settlement.set_venue_filtering",
          Self::allow_venues { .. } => "Settlement.allow_venues",
          Self::disallow_venues { .. } => "Settlement.disallow_venues",
          Self::update_venue_signers { .. } => "Settlement.update_venue_signers",
          Self::execute_manual_instruction { .. } => "Settlement.execute_manual_instruction",
          Self::add_instruction { .. } => "Settlement.add_instruction",
          Self::add_and_affirm_instruction { .. } => "Settlement.add_and_affirm_instruction",
          Self::affirm_instruction { .. } => "Settlement.affirm_instruction",
          Self::withdraw_affirmation { .. } => "Settlement.withdraw_affirmation",
          Self::reject_instruction { .. } => "Settlement.reject_instruction",
          Self::execute_scheduled_instruction { .. } => "Settlement.execute_scheduled_instruction",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for SettlementCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: create_venue { .. } => { & ["Registers a new venue." , "" , "* `details` - Extra details about a venue" , "* `signers` - Array of signers that are allowed to sign receipts for this venue" , "* `typ` - Type of venue being created" ,] } , Self :: update_venue_details { .. } => { & ["Edit a venue's details." , "" , "* `id` specifies the ID of the venue to edit." , "* `details` specifies the updated venue details." ,] } , Self :: update_venue_type { .. } => { & ["Edit a venue's type." , "" , "* `id` specifies the ID of the venue to edit." , "* `type` specifies the new type of the venue." ,] } , Self :: affirm_with_receipts { .. } => { & ["Accepts an instruction and claims a signed receipt." , "" , "# Arguments" , "* `id` - Target instruction id." , "* `leg_id` - Target leg id for the receipt" , "* `receipt_uid` - Receipt ID generated by the signer." , "* `signer` - Signer of the receipt." , "* `signed_data` - Signed receipt." , "* `portfolios` - Portfolios that the sender controls and wants to accept this instruction with." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: set_venue_filtering { .. } => { & ["Enables or disabled venue filtering for a token." , "" , "# Arguments" , "* `ticker` - Ticker of the token in question." , "* `enabled` - Boolean that decides if the filtering should be enabled." , "" , "# Permissions" , "* Asset" ,] } , Self :: allow_venues { .. } => { & ["Allows additional venues to create instructions involving an asset." , "" , "* `ticker` - Ticker of the token in question." , "* `venues` - Array of venues that are allowed to create instructions for the token in question." , "" , "# Permissions" , "* Asset" ,] } , Self :: disallow_venues { .. } => { & ["Revokes permission given to venues for creating instructions involving a particular asset." , "" , "* `ticker` - Ticker of the token in question." , "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question." , "" , "# Permissions" , "* Asset" ,] } , Self :: update_venue_signers { .. } => { & ["Edit a venue's signers." , "* `id` specifies the ID of the venue to edit." , "* `signers` specifies the signers to add/remove." , "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false." ,] } , Self :: execute_manual_instruction { .. } => { & ["Manually executes an instruction." , "" , "# Arguments" , "* `id`: The [`InstructionId`] of the instruction to be executed." , "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction." , "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]." , "* `fungible_transfers`: The number of fungible legs in the instruction." , "* `nfts_transfers`: The number of nfts being transferred in the instruction." , "* `offchain_transfers`: The number of offchain legs in the instruction." , "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction." , "If the `weight_limit` is less than the required amount, the instruction will fail execution." , "" , "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters." ,] } , Self :: add_instruction { .. } => { & ["Adds a new instruction." , "" , "# Arguments" , "* `venue_id` - ID of the venue this instruction belongs to." , "* `settlement_type` - Defines if the instruction should be settled in the next block, after receiving all affirmations" , "or waiting till a specific block." , "* `trade_date` - Optional date from which people can interact with this instruction." , "* `value_date` - Optional date after which the instruction should be settled (not enforced)" , "* `legs` - Legs included in this instruction." , "* `memo` - Memo field for this instruction." , "" , "# Weight" , "`950_000_000 + 1_000_000 * legs.len()`" ,] } , Self :: add_and_affirm_instruction { .. } => { & ["Adds and affirms a new instruction." , "" , "# Arguments" , "* `venue_id` - ID of the venue this instruction belongs to." , "* `settlement_type` - Defines if the instruction should be settled in the next block, after receiving all affirmations" , "or waiting till a specific block." , "* `trade_date` - Optional date from which people can interact with this instruction." , "* `value_date` - Optional date after which the instruction should be settled (not enforced)" , "* `legs` - Legs included in this instruction." , "* `portfolios` - Portfolios that the sender controls and wants to use in this affirmations." , "* `instruction_memo` - Memo field for this instruction." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: affirm_instruction { .. } => { & ["Provide affirmation to an existing instruction." , "" , "# Arguments" , "* `id` - The `InstructionId` of the instruction to be affirmed." , "* `portfolios` - Portfolios that the sender controls and wants to affirm this instruction." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: withdraw_affirmation { .. } => { & ["Withdraw an affirmation for a given instruction." , "" , "# Arguments" , "* `id` - Instruction id for that affirmation get withdrawn." , "* `portfolios` - Portfolios that the sender controls and wants to withdraw affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: reject_instruction { .. } => { & ["Rejects an existing instruction." , "" , "# Arguments" , "* `id` - Instruction id to reject." , "* `portfolio` - Portfolio to reject the instruction." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: execute_scheduled_instruction { .. } => { & ["Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction." ,] } , _ => & [""] , }
      }
    }
    impl From<SettlementCall> for &'static str {
      fn from(v: SettlementCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&SettlementCall> for &'static str {
      fn from(v: &SettlementCall) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_statistics {
    use super::*;
    #[doc = "Statistics module errors."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StatisticsError {
      #[doc = "Transfer not allowed."]
      #[codec(index = 0u8)]
      InvalidTransfer,
      #[doc = "StatType is not enabled."]
      #[codec(index = 1u8)]
      StatTypeMissing,
      #[doc = "StatType is needed by TransferCondition."]
      #[codec(index = 2u8)]
      StatTypeNeededByTransferCondition,
      #[doc = "A Stattype is in use and can't be removed."]
      #[codec(index = 3u8)]
      CannotRemoveStatTypeInUse,
      #[doc = "The limit of StatTypes allowed for an asset has been reached."]
      #[codec(index = 4u8)]
      StatTypeLimitReached,
      #[doc = "The limit of TransferConditions allowed for an asset has been reached."]
      #[codec(index = 5u8)]
      TransferConditionLimitReached,
      #[doc = "The maximum weight limit for executing the function was exceeded."]
      #[codec(index = 6u8)]
      WeightLimitExceeded,
    }
    impl StatisticsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::InvalidTransfer => "Statistics.InvalidTransfer",
          Self::StatTypeMissing => "Statistics.StatTypeMissing",
          Self::StatTypeNeededByTransferCondition => "Statistics.StatTypeNeededByTransferCondition",
          Self::CannotRemoveStatTypeInUse => "Statistics.CannotRemoveStatTypeInUse",
          Self::StatTypeLimitReached => "Statistics.StatTypeLimitReached",
          Self::TransferConditionLimitReached => "Statistics.TransferConditionLimitReached",
          Self::WeightLimitExceeded => "Statistics.WeightLimitExceeded",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for StatisticsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::InvalidTransfer => &["Transfer not allowed."],
          Self::StatTypeMissing => &["StatType is not enabled."],
          Self::StatTypeNeededByTransferCondition => &["StatType is needed by TransferCondition."],
          Self::CannotRemoveStatTypeInUse => &["A Stattype is in use and can't be removed."],
          Self::StatTypeLimitReached => {
            &["The limit of StatTypes allowed for an asset has been reached."]
          }
          Self::TransferConditionLimitReached => {
            &["The limit of TransferConditions allowed for an asset has been reached."]
          }
          Self::WeightLimitExceeded => {
            &["The maximum weight limit for executing the function was exceeded."]
          }
          _ => &[""],
        }
      }
    }
    impl From<StatisticsError> for &'static str {
      fn from(v: StatisticsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&StatisticsError> for &'static str {
      fn from(v: &StatisticsError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StatisticsCall {
      #[doc = "Set the active asset stat_types."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset`."]
      #[doc = "- `asset` - the asset to change the active stats on."]
      #[doc = "- `stat_types` - the new stat types to replace any existing types."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeLimitReached` - too many stat types enabled for the `asset`."]
      #[doc = "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[codec(index = 0u8)]
      set_active_asset_stats {
        asset: polymesh_primitives::statistics::AssetScope,
        stat_types: ::alloc::collections::BTreeSet<polymesh_primitives::statistics::StatType>,
      },
      #[doc = "Allow a trusted issuer to init/resync ticker/company stats."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset`."]
      #[doc = "- `asset` - the asset to change the active stats on."]
      #[doc = "- `stat_type` - stat type to update."]
      #[doc = "- `values` - Updated values for `stat_type`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeMissing` - `stat_type` is not enabled for the `asset`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[codec(index = 1u8)]
      batch_update_asset_stats {
        asset: polymesh_primitives::statistics::AssetScope,
        stat_type: polymesh_primitives::statistics::StatType,
        values: ::alloc::collections::BTreeSet<polymesh_primitives::statistics::StatUpdate>,
      },
      #[doc = "Set asset transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset`."]
      #[doc = "- `asset` - the asset to change the active stats on."]
      #[doc = "- `transfer_conditions` - the new transfer condition to replace any existing conditions."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset`."]
      #[doc = "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[codec(index = 2u8)]
      set_asset_transfer_compliance {
        asset: polymesh_primitives::statistics::AssetScope,
        transfer_conditions: ::alloc::collections::BTreeSet<
          polymesh_primitives::transfer_compliance::TransferCondition,
        >,
      },
      #[doc = "Set/unset entities exempt from an asset's transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`."]
      #[doc = "- `is_exempt` - enable/disable exemption for `entities`."]
      #[doc = "- `exempt_key` - the asset and stat type to exempt the `entities` from."]
      #[doc = "- `entities` - the entities to set/unset the exemption for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[codec(index = 3u8)]
      set_entities_exempt {
        is_exempt: bool,
        exempt_key: polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
        entities: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      },
    }
    impl StatisticsCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_active_asset_stats { .. } => "Statistics.set_active_asset_stats",
          Self::batch_update_asset_stats { .. } => "Statistics.batch_update_asset_stats",
          Self::set_asset_transfer_compliance { .. } => "Statistics.set_asset_transfer_compliance",
          Self::set_entities_exempt { .. } => "Statistics.set_entities_exempt",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for StatisticsCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_active_asset_stats { .. } => { & ["Set the active asset stat_types." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `asset`." , "- `asset` - the asset to change the active stats on." , "- `stat_types` - the new stat types to replace any existing types." , "" , "# Errors" , "- `StatTypeLimitReached` - too many stat types enabled for the `asset`." , "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , Self :: batch_update_asset_stats { .. } => { & ["Allow a trusted issuer to init/resync ticker/company stats." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `asset`." , "- `asset` - the asset to change the active stats on." , "- `stat_type` - stat type to update." , "- `values` - Updated values for `stat_type`." , "" , "# Errors" , "- `StatTypeMissing` - `stat_type` is not enabled for the `asset`." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , Self :: set_asset_transfer_compliance { .. } => { & ["Set asset transfer compliance rules." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `asset`." , "- `asset` - the asset to change the active stats on." , "- `transfer_conditions` - the new transfer condition to replace any existing conditions." , "" , "# Errors" , "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset`." , "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset`." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , Self :: set_entities_exempt { .. } => { & ["Set/unset entities exempt from an asset's transfer compliance rules." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`." , "- `is_exempt` - enable/disable exemption for `entities`." , "- `exempt_key` - the asset and stat type to exempt the `entities` from." , "- `entities` - the entities to set/unset the exemption for." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , _ => & [""] , }
      }
    }
    impl From<StatisticsCall> for &'static str {
      fn from(v: StatisticsCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&StatisticsCall> for &'static str {
      fn from(v: &StatisticsCall) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_session {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Error for the session pallet."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SessionError {
        #[doc = "Invalid ownership proof."]
        #[codec(index = 0u8)]
        InvalidProof,
        #[doc = "No associated validator ID for account."]
        #[codec(index = 1u8)]
        NoAssociatedValidatorId,
        #[doc = "Registered duplicate key."]
        #[codec(index = 2u8)]
        DuplicatedKey,
        #[doc = "No keys are associated with this account."]
        #[codec(index = 3u8)]
        NoKeys,
        #[doc = "Key setting account is not live, so it's impossible to associate keys."]
        #[codec(index = 4u8)]
        NoAccount,
      }
      impl SessionError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidProof => "Session.InvalidProof",
            Self::NoAssociatedValidatorId => "Session.NoAssociatedValidatorId",
            Self::DuplicatedKey => "Session.DuplicatedKey",
            Self::NoKeys => "Session.NoKeys",
            Self::NoAccount => "Session.NoAccount",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SessionError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidProof => &["Invalid ownership proof."],
            Self::NoAssociatedValidatorId => &["No associated validator ID for account."],
            Self::DuplicatedKey => &["Registered duplicate key."],
            Self::NoKeys => &["No keys are associated with this account."],
            Self::NoAccount => {
              &["Key setting account is not live, so it's impossible to associate keys."]
            }
            _ => &[""],
          }
        }
      }
      impl From<SessionError> for &'static str {
        fn from(v: SessionError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SessionError> for &'static str {
        fn from(v: &SessionError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SessionEvent {
        #[doc = "New session has happened. Note that the argument is the session index, not the"]
        #[doc = "block number as the type might suggest."]
        #[codec(index = 0u8)]
        NewSession { session_index: u32 },
      }
      impl SessionEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::NewSession { .. } => "Session.NewSession",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SessionEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::NewSession { .. } => &[
              "New session has happened. Note that the argument is the session index, not the",
              "block number as the type might suggest.",
            ],
            _ => &[""],
          }
        }
      }
      impl From<SessionEvent> for &'static str {
        fn from(v: SessionEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SessionEvent> for &'static str {
        fn from(v: &SessionEvent) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SessionCall {
        #[doc = "Sets the session key(s) of the function caller to `keys`."]
        #[doc = "Allows an account to set its session key prior to becoming a validator."]
        #[doc = "This doesn't take effect until the next session."]
        #[doc = ""]
        #[doc = "The dispatch origin of this function must be signed."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"]
        #[doc = "  fixed."]
        #[codec(index = 0u8)]
        set_keys {
          keys: runtime::SessionKeys,
          proof: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Removes any session key(s) of the function caller."]
        #[doc = ""]
        #[doc = "This doesn't take effect until the next session."]
        #[doc = ""]
        #[doc = "The dispatch origin of this function must be Signed and the account must be either be"]
        #[doc = "convertible to a validator ID using the chain's typical addressing system (this usually"]
        #[doc = "means being a controller account) or directly convertible into a validator ID (which"]
        #[doc = "usually means being a stash account)."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"]
        #[doc = "  `T::Keys::key_ids()` which is fixed."]
        #[codec(index = 1u8)]
        purge_keys,
      }
      impl SessionCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::set_keys { .. } => "Session.set_keys",
            Self::purge_keys => "Session.purge_keys",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SessionCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: set_keys { .. } => { & ["Sets the session key(s) of the function caller to `keys`." , "Allows an account to set its session key prior to becoming a validator." , "This doesn't take effect until the next session." , "" , "The dispatch origin of this function must be signed." , "" , "## Complexity" , "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is" , "  fixed." ,] } , Self :: purge_keys => { & ["Removes any session key(s) of the function caller." , "" , "This doesn't take effect until the next session." , "" , "The dispatch origin of this function must be Signed and the account must be either be" , "convertible to a validator ID using the chain's typical addressing system (this usually" , "means being a controller account) or directly convertible into a validator ID (which" , "usually means being a stash account)." , "" , "## Complexity" , "- `O(1)` in number of key types. Actual cost depends on the number of length of" , "  `T::Keys::key_ids()` which is fixed." ,] } , _ => & [""] , }
        }
      }
      impl From<SessionCall> for &'static str {
        fn from(v: SessionCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SessionCall> for &'static str {
        fn from(v: &SessionCall) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod pallet_corporate_actions {
    use super::*;
    pub mod ballot {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BallotTitle(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BallotMeta {
        pub title: pallet_corporate_actions::ballot::BallotTitle,
        pub motions: ::alloc::vec::Vec<pallet_corporate_actions::ballot::Motion>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Motion {
        pub title: pallet_corporate_actions::ballot::MotionTitle,
        pub info_link: pallet_corporate_actions::ballot::MotionInfoLink,
        pub choices: ::alloc::vec::Vec<pallet_corporate_actions::ballot::ChoiceTitle>,
      }
      #[doc = "Dispatchable calls."]
      #[doc = ""]
      #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CorporateBallotCall {
        #[doc = "Attach a corporate ballot to the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "The ballot will admit votes within `range`."]
        #[doc = "The ballot's metadata is provided by `meta`,"]
        #[doc = "which includes the ballot title, the motions, their choices, etc."]
        #[doc = "See the `BallotMeta` for more."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
        #[doc = "- `ca_id` identifies the CA to attach the ballot to."]
        #[doc = "- `range` specifies when voting starts and ends."]
        #[doc = "- `meta` specifies the ballot's metadata as aforementioned."]
        #[doc = "- `rcv` specifies whether RCV is enabled for this ballot."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
        #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
        #[doc = "- `CANotNotice` if the CA is not of the `IssuerNotice` kind."]
        #[doc = "- `StartAfterEnd` if `range.start > range.end`."]
        #[doc = "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp."]
        #[doc = "- `NoRecordDate` if CA has no record date."]
        #[doc = "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date."]
        #[doc = "- `AlreadyExists` if there's a ballot already."]
        #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
        #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
        #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
        #[codec(index = 0u8)]
        attach_ballot {
          ca_id: pallet_corporate_actions::CAId,
          range: pallet_corporate_actions::ballot::BallotTimeRange,
          meta: pallet_corporate_actions::ballot::BallotMeta,
          rcv: bool,
        },
        #[doc = "Cast `votes` in the ballot attached to the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` which must be a permissioned signer targeted by the CA."]
        #[doc = "- `ca_id` identifies the attached ballot's CA."]
        #[doc = "- `votes` specifies the balances to assign to each choice in the ballot."]
        #[doc = "   The full voting power of `origin`'s DID may be used for each motion in the ballot."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
        #[doc = "- `VotingNotStarted` if the voting period hasn't commenced yet."]
        #[doc = "- `VotingAlreadyEnded` if the voting period has ended."]
        #[doc = "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`."]
        #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
        #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
        #[doc = "- `InsufficientVotes` if the voting power used for any motion in `votes`"]
        #[doc = "   exceeds `origin`'s DID's voting power."]
        #[codec(index = 1u8)]
        vote {
          ca_id: pallet_corporate_actions::CAId,
          votes: ::alloc::vec::Vec<pallet_corporate_actions::ballot::BallotVote>,
        },
        #[doc = "Amend the end date of the ballot of the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
        #[doc = "- `ca_id` identifies the attached ballot's CA."]
        #[doc = "- `end` specifies the new end date of the ballot."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
        #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
        #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
        #[doc = "- `StartAfterEnd` if `start > end`."]
        #[codec(index = 2u8)]
        change_end {
          ca_id: pallet_corporate_actions::CAId,
          end: u64,
        },
        #[doc = "Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
        #[doc = "- `ca_id` identifies the attached ballot's CA."]
        #[doc = "- `meta` specifies the new metadata."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
        #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
        #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
        #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
        #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
        #[codec(index = 3u8)]
        change_meta {
          ca_id: pallet_corporate_actions::CAId,
          meta: pallet_corporate_actions::ballot::BallotMeta,
        },
        #[doc = "Amend RCV support for the ballot of the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
        #[doc = "- `ca_id` identifies the attached ballot's CA."]
        #[doc = "- `rcv` specifies if RCV is to be supported or not."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
        #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
        #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
        #[codec(index = 4u8)]
        change_rcv {
          ca_id: pallet_corporate_actions::CAId,
          rcv: bool,
        },
        #[doc = "Remove the ballot of the CA identified by `ca_id`."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
        #[doc = "- `ca_id` identifies the attached ballot's CA."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
        #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
        #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
        #[codec(index = 5u8)]
        remove_ballot {
          ca_id: pallet_corporate_actions::CAId,
        },
      }
      impl CorporateBallotCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::attach_ballot { .. } => "CorporateBallot.attach_ballot",
            Self::vote { .. } => "CorporateBallot.vote",
            Self::change_end { .. } => "CorporateBallot.change_end",
            Self::change_meta { .. } => "CorporateBallot.change_meta",
            Self::change_rcv { .. } => "CorporateBallot.change_rcv",
            Self::remove_ballot { .. } => "CorporateBallot.remove_ballot",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CorporateBallotCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: attach_ballot { .. } => { & ["Attach a corporate ballot to the CA identified by `ca_id`." , "" , "The ballot will admit votes within `range`." , "The ballot's metadata is provided by `meta`," , "which includes the ballot title, the motions, their choices, etc." , "See the `BallotMeta` for more." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`." , "- `ca_id` identifies the CA to attach the ballot to." , "- `range` specifies when voting starts and ends." , "- `meta` specifies the ballot's metadata as aforementioned." , "- `rcv` specifies whether RCV is enabled for this ballot." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `CANotNotice` if the CA is not of the `IssuerNotice` kind." , "- `StartAfterEnd` if `range.start > range.end`." , "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp." , "- `NoRecordDate` if CA has no record date." , "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date." , "- `AlreadyExists` if there's a ballot already." , "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`." , "- `TooLong` if any of the embedded strings in `meta` are too long." , "- `InsufficientBalance` if the protocol fee couldn't be charged." ,] } , Self :: vote { .. } => { & ["Cast `votes` in the ballot attached to the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` which must be a permissioned signer targeted by the CA." , "- `ca_id` identifies the attached ballot's CA." , "- `votes` specifies the balances to assign to each choice in the ballot." , "   The full voting power of `origin`'s DID may be used for each motion in the ballot." , "" , "# Errors" , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingNotStarted` if the voting period hasn't commenced yet." , "- `VotingAlreadyEnded` if the voting period has ended." , "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NotTargetedByCA` if the CA does not target `origin`'s DID." , "- `InsufficientVotes` if the voting power used for any motion in `votes`" , "   exceeds `origin`'s DID's voting power." ,] } , Self :: change_end { .. } => { & ["Amend the end date of the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`." , "- `ca_id` identifies the attached ballot's CA." , "- `end` specifies the new end date of the ballot." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." , "- `StartAfterEnd` if `start > end`." ,] } , Self :: change_meta { .. } => { & ["Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`." , "- `ca_id` identifies the attached ballot's CA." , "- `meta` specifies the new metadata." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." , "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`." , "- `TooLong` if any of the embedded strings in `meta` are too long." ,] } , Self :: change_rcv { .. } => { & ["Amend RCV support for the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`." , "- `ca_id` identifies the attached ballot's CA." , "- `rcv` specifies if RCV is to be supported or not." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." ,] } , Self :: remove_ballot { .. } => { & ["Remove the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`." , "- `ca_id` identifies the attached ballot's CA." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." ,] } , _ => & [""] , }
        }
      }
      impl From<CorporateBallotCall> for &'static str {
        fn from(v: CorporateBallotCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CorporateBallotCall> for &'static str {
        fn from(v: &CorporateBallotCall) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct MotionInfoLink(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BallotTimeRange {
        pub start: u64,
        pub end: u64,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct MotionTitle(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ChoiceTitle(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BallotVote {
        pub power: u128,
        pub fallback: Option<u16>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CorporateBallotError {
        #[doc = "A corporate ballot was made for a non `IssuerNotice` CA."]
        #[codec(index = 0u8)]
        CANotNotice,
        #[doc = "A corporate ballot already exists for this CA."]
        #[codec(index = 1u8)]
        AlreadyExists,
        #[doc = "A corporate ballot doesn't exist for this CA."]
        #[codec(index = 2u8)]
        NoSuchBallot,
        #[doc = "A corporate ballot's start time was strictly after the ballot's end."]
        #[codec(index = 3u8)]
        StartAfterEnd,
        #[doc = "A corporate ballot's end time was strictly before the current time."]
        #[codec(index = 4u8)]
        NowAfterEnd,
        #[doc = "If some motion in a corporate ballot has more choices than would fit in `u16`."]
        #[codec(index = 5u8)]
        NumberOfChoicesOverflow,
        #[doc = "Voting started already. Amending a ballot is no longer possible."]
        #[codec(index = 6u8)]
        VotingAlreadyStarted,
        #[doc = "Voting hasn't started yet."]
        #[codec(index = 7u8)]
        VotingNotStarted,
        #[doc = "Voting ended already."]
        #[codec(index = 8u8)]
        VotingAlreadyEnded,
        #[doc = "Provided list of balances does not match the total number of choices."]
        #[codec(index = 9u8)]
        WrongVoteCount,
        #[doc = "Voting power used by a DID on a motion exceeds that which is available to them."]
        #[codec(index = 10u8)]
        InsufficientVotes,
        #[doc = "The RCV fallback of some choice does not exist."]
        #[codec(index = 11u8)]
        NoSuchRCVFallback,
        #[doc = "The RCV fallback points to the origin choice."]
        #[codec(index = 12u8)]
        RCVSelfCycle,
        #[doc = "RCV is not allowed for this ballot."]
        #[codec(index = 13u8)]
        RCVNotAllowed,
      }
      impl CorporateBallotError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::CANotNotice => "CorporateBallot.CANotNotice",
            Self::AlreadyExists => "CorporateBallot.AlreadyExists",
            Self::NoSuchBallot => "CorporateBallot.NoSuchBallot",
            Self::StartAfterEnd => "CorporateBallot.StartAfterEnd",
            Self::NowAfterEnd => "CorporateBallot.NowAfterEnd",
            Self::NumberOfChoicesOverflow => "CorporateBallot.NumberOfChoicesOverflow",
            Self::VotingAlreadyStarted => "CorporateBallot.VotingAlreadyStarted",
            Self::VotingNotStarted => "CorporateBallot.VotingNotStarted",
            Self::VotingAlreadyEnded => "CorporateBallot.VotingAlreadyEnded",
            Self::WrongVoteCount => "CorporateBallot.WrongVoteCount",
            Self::InsufficientVotes => "CorporateBallot.InsufficientVotes",
            Self::NoSuchRCVFallback => "CorporateBallot.NoSuchRCVFallback",
            Self::RCVSelfCycle => "CorporateBallot.RCVSelfCycle",
            Self::RCVNotAllowed => "CorporateBallot.RCVNotAllowed",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CorporateBallotError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::CANotNotice => &["A corporate ballot was made for a non `IssuerNotice` CA."],
            Self::AlreadyExists => &["A corporate ballot already exists for this CA."],
            Self::NoSuchBallot => &["A corporate ballot doesn't exist for this CA."],
            Self::StartAfterEnd => {
              &["A corporate ballot's start time was strictly after the ballot's end."]
            }
            Self::NowAfterEnd => {
              &["A corporate ballot's end time was strictly before the current time."]
            }
            Self::NumberOfChoicesOverflow => {
              &["If some motion in a corporate ballot has more choices than would fit in `u16`."]
            }
            Self::VotingAlreadyStarted => {
              &["Voting started already. Amending a ballot is no longer possible."]
            }
            Self::VotingNotStarted => &["Voting hasn't started yet."],
            Self::VotingAlreadyEnded => &["Voting ended already."],
            Self::WrongVoteCount => {
              &["Provided list of balances does not match the total number of choices."]
            }
            Self::InsufficientVotes => {
              &["Voting power used by a DID on a motion exceeds that which is available to them."]
            }
            Self::NoSuchRCVFallback => &["The RCV fallback of some choice does not exist."],
            Self::RCVSelfCycle => &["The RCV fallback points to the origin choice."],
            Self::RCVNotAllowed => &["RCV is not allowed for this ballot."],
            _ => &[""],
          }
        }
      }
      impl From<CorporateBallotError> for &'static str {
        fn from(v: CorporateBallotError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CorporateBallotError> for &'static str {
        fn from(v: &CorporateBallotError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Events for this module."]
      #[doc = ""]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CorporateBallotEvent {
        #[doc = "A corporate ballot was created."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, Voting start/end, Ballot metadata, RCV enabled?)"]
        #[codec(index = 0u8)]
        Created(
          ::polymesh_api_client::IdentityId,
          pallet_corporate_actions::CAId,
          pallet_corporate_actions::ballot::BallotTimeRange,
          pallet_corporate_actions::ballot::BallotMeta,
          bool,
        ),
        #[doc = "A vote was cast in a corporate ballot."]
        #[doc = ""]
        #[doc = "(voter DID, CAId, Votes)"]
        #[codec(index = 1u8)]
        VoteCast(
          ::polymesh_api_client::IdentityId,
          pallet_corporate_actions::CAId,
          ::alloc::vec::Vec<pallet_corporate_actions::ballot::BallotVote>,
        ),
        #[doc = "A corporate ballot changed its start/end date range."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, Voting start/end)"]
        #[codec(index = 2u8)]
        RangeChanged(
          ::polymesh_api_client::IdentityId,
          pallet_corporate_actions::CAId,
          pallet_corporate_actions::ballot::BallotTimeRange,
        ),
        #[doc = "A corporate ballot changed its metadata."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, New metadata)"]
        #[codec(index = 3u8)]
        MetaChanged(
          ::polymesh_api_client::IdentityId,
          pallet_corporate_actions::CAId,
          pallet_corporate_actions::ballot::BallotMeta,
        ),
        #[doc = "A corporate ballot changed its RCV support."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, New support)"]
        #[codec(index = 4u8)]
        RCVChanged(
          ::polymesh_api_client::IdentityId,
          pallet_corporate_actions::CAId,
          bool,
        ),
        #[doc = "A corporate ballot was removed."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID)"]
        #[codec(index = 5u8)]
        Removed(
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          pallet_corporate_actions::CAId,
        ),
      }
      impl CorporateBallotEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Created(_, _, _, _, _) => "CorporateBallot.Created",
            Self::VoteCast(_, _, _) => "CorporateBallot.VoteCast",
            Self::RangeChanged(_, _, _) => "CorporateBallot.RangeChanged",
            Self::MetaChanged(_, _, _) => "CorporateBallot.MetaChanged",
            Self::RCVChanged(_, _, _) => "CorporateBallot.RCVChanged",
            Self::Removed(_, _) => "CorporateBallot.Removed",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CorporateBallotEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::Created(_, _, _, _, _) => &[
              "A corporate ballot was created.",
              "",
              "(Agent DID, CA's ID, Voting start/end, Ballot metadata, RCV enabled?)",
            ],
            Self::VoteCast(_, _, _) => &[
              "A vote was cast in a corporate ballot.",
              "",
              "(voter DID, CAId, Votes)",
            ],
            Self::RangeChanged(_, _, _) => &[
              "A corporate ballot changed its start/end date range.",
              "",
              "(Agent DID, CA's ID, Voting start/end)",
            ],
            Self::MetaChanged(_, _, _) => &[
              "A corporate ballot changed its metadata.",
              "",
              "(Agent DID, CA's ID, New metadata)",
            ],
            Self::RCVChanged(_, _, _) => &[
              "A corporate ballot changed its RCV support.",
              "",
              "(Agent DID, CA's ID, New support)",
            ],
            Self::Removed(_, _) => &[
              "A corporate ballot was removed.",
              "",
              "(Agent DID, CA's ID)",
            ],
            _ => &[""],
          }
        }
      }
      impl From<CorporateBallotEvent> for &'static str {
        fn from(v: CorporateBallotEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CorporateBallotEvent> for &'static str {
        fn from(v: &CorporateBallotEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    pub mod distribution {
      use super::*;
      #[doc = "Events for this module."]
      #[doc = ""]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CapitalDistributionEvent {
        #[doc = "A capital distribution, with details included,"]
        #[doc = "was created by the DID (permissioned agent) for the CA identified by `CAId`."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, distribution details)"]
        #[codec(index = 0u8)]
        Created(
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          pallet_corporate_actions::CAId,
          pallet_corporate_actions::distribution::Distribution,
        ),
        #[doc = "A token holder's benefit of a capital distribution for the given `CAId` was claimed."]
        #[doc = ""]
        #[doc = "(Caller DID, Holder/Claimant DID, CA's ID, updated distribution details, DID's benefit, DID's tax %)"]
        #[codec(index = 1u8)]
        BenefitClaimed(
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          pallet_corporate_actions::CAId,
          pallet_corporate_actions::distribution::Distribution,
          u128,
          ::polymesh_api_client::per_things::Permill,
        ),
        #[doc = "Stats from `push_benefit` was emitted."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID, max requested DIDs, processed DIDs, failed DIDs)"]
        #[codec(index = 2u8)]
        Reclaimed(
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          pallet_corporate_actions::CAId,
          u128,
        ),
        #[doc = "A capital distribution was removed."]
        #[doc = ""]
        #[doc = "(Agent DID, CA's ID)"]
        #[codec(index = 3u8)]
        Removed(
          polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
          pallet_corporate_actions::CAId,
        ),
      }
      impl CapitalDistributionEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Created(_, _, _) => "CapitalDistribution.Created",
            Self::BenefitClaimed(_, _, _, _, _, _) => "CapitalDistribution.BenefitClaimed",
            Self::Reclaimed(_, _, _) => "CapitalDistribution.Reclaimed",
            Self::Removed(_, _) => "CapitalDistribution.Removed",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CapitalDistributionEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: Created (_ , _ , _) => { & ["A capital distribution, with details included," , "was created by the DID (permissioned agent) for the CA identified by `CAId`." , "" , "(Agent DID, CA's ID, distribution details)" ,] } , Self :: BenefitClaimed (_ , _ , _ , _ , _ , _) => { & ["A token holder's benefit of a capital distribution for the given `CAId` was claimed." , "" , "(Caller DID, Holder/Claimant DID, CA's ID, updated distribution details, DID's benefit, DID's tax %)" ,] } , Self :: Reclaimed (_ , _ , _) => { & ["Stats from `push_benefit` was emitted." , "" , "(Agent DID, CA's ID, max requested DIDs, processed DIDs, failed DIDs)" ,] } , Self :: Removed (_ , _) => { & ["A capital distribution was removed." , "" , "(Agent DID, CA's ID)" ,] } , _ => & [""] , }
        }
      }
      impl From<CapitalDistributionEvent> for &'static str {
        fn from(v: CapitalDistributionEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CapitalDistributionEvent> for &'static str {
        fn from(v: &CapitalDistributionEvent) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CapitalDistributionError {
        #[doc = "A capital distribution was made for a non-benefit CA."]
        #[codec(index = 0u8)]
        CANotBenefit,
        #[doc = "A distribution already exists for this CA."]
        #[codec(index = 1u8)]
        AlreadyExists,
        #[doc = "A distributions provided expiry date was strictly before its payment date."]
        #[doc = "In other words, everything to distribute would immediately be forfeited."]
        #[codec(index = 2u8)]
        ExpiryBeforePayment,
        #[doc = "The token holder has already been paid their benefit."]
        #[codec(index = 3u8)]
        HolderAlreadyPaid,
        #[doc = "A capital distribution doesn't exist for this CA."]
        #[codec(index = 4u8)]
        NoSuchDistribution,
        #[doc = "Distribution allotment cannot be claimed as the current time is before start-of-payment."]
        #[codec(index = 5u8)]
        CannotClaimBeforeStart,
        #[doc = "Distribution's expiry has passed. DID cannot claim anymore and has forfeited the benefits."]
        #[codec(index = 6u8)]
        CannotClaimAfterExpiry,
        #[doc = "Multiplication of the balance with the per share payout amount overflowed."]
        #[codec(index = 7u8)]
        BalancePerShareProductOverflowed,
        #[doc = "DID is not the one who created the distribution."]
        #[codec(index = 8u8)]
        NotDistributionCreator,
        #[doc = "DID who created the distribution already did reclaim."]
        #[codec(index = 9u8)]
        AlreadyReclaimed,
        #[doc = "Distribution had not expired yet, or there's no expiry date."]
        #[codec(index = 10u8)]
        NotExpired,
        #[doc = "A distribution has been activated, as `payment_at <= now` holds."]
        #[codec(index = 11u8)]
        DistributionStarted,
        #[doc = "A distribution has insufficient remaining amount of currency to distribute."]
        #[codec(index = 12u8)]
        InsufficientRemainingAmount,
        #[doc = "Distribution `amount` cannot be zero."]
        #[codec(index = 13u8)]
        DistributionAmountIsZero,
        #[doc = "Distribution `per_share` cannot be zero."]
        #[codec(index = 14u8)]
        DistributionPerShareIsZero,
      }
      impl CapitalDistributionError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::CANotBenefit => "CapitalDistribution.CANotBenefit",
            Self::AlreadyExists => "CapitalDistribution.AlreadyExists",
            Self::ExpiryBeforePayment => "CapitalDistribution.ExpiryBeforePayment",
            Self::HolderAlreadyPaid => "CapitalDistribution.HolderAlreadyPaid",
            Self::NoSuchDistribution => "CapitalDistribution.NoSuchDistribution",
            Self::CannotClaimBeforeStart => "CapitalDistribution.CannotClaimBeforeStart",
            Self::CannotClaimAfterExpiry => "CapitalDistribution.CannotClaimAfterExpiry",
            Self::BalancePerShareProductOverflowed => {
              "CapitalDistribution.BalancePerShareProductOverflowed"
            }
            Self::NotDistributionCreator => "CapitalDistribution.NotDistributionCreator",
            Self::AlreadyReclaimed => "CapitalDistribution.AlreadyReclaimed",
            Self::NotExpired => "CapitalDistribution.NotExpired",
            Self::DistributionStarted => "CapitalDistribution.DistributionStarted",
            Self::InsufficientRemainingAmount => "CapitalDistribution.InsufficientRemainingAmount",
            Self::DistributionAmountIsZero => "CapitalDistribution.DistributionAmountIsZero",
            Self::DistributionPerShareIsZero => "CapitalDistribution.DistributionPerShareIsZero",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CapitalDistributionError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: CANotBenefit => { & ["A capital distribution was made for a non-benefit CA." ,] } , Self :: AlreadyExists => { & ["A distribution already exists for this CA." ,] } , Self :: ExpiryBeforePayment => { & ["A distributions provided expiry date was strictly before its payment date." , "In other words, everything to distribute would immediately be forfeited." ,] } , Self :: HolderAlreadyPaid => { & ["The token holder has already been paid their benefit." ,] } , Self :: NoSuchDistribution => { & ["A capital distribution doesn't exist for this CA." ,] } , Self :: CannotClaimBeforeStart => { & ["Distribution allotment cannot be claimed as the current time is before start-of-payment." ,] } , Self :: CannotClaimAfterExpiry => { & ["Distribution's expiry has passed. DID cannot claim anymore and has forfeited the benefits." ,] } , Self :: BalancePerShareProductOverflowed => { & ["Multiplication of the balance with the per share payout amount overflowed." ,] } , Self :: NotDistributionCreator => { & ["DID is not the one who created the distribution." ,] } , Self :: AlreadyReclaimed => { & ["DID who created the distribution already did reclaim." ,] } , Self :: NotExpired => { & ["Distribution had not expired yet, or there's no expiry date." ,] } , Self :: DistributionStarted => { & ["A distribution has been activated, as `payment_at <= now` holds." ,] } , Self :: InsufficientRemainingAmount => { & ["A distribution has insufficient remaining amount of currency to distribute." ,] } , Self :: DistributionAmountIsZero => { & ["Distribution `amount` cannot be zero." ,] } , Self :: DistributionPerShareIsZero => { & ["Distribution `per_share` cannot be zero." ,] } , _ => & [""] , }
        }
      }
      impl From<CapitalDistributionError> for &'static str {
        fn from(v: CapitalDistributionError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CapitalDistributionError> for &'static str {
        fn from(v: &CapitalDistributionError) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Distribution {
        pub from: polymesh_primitives::identity_id::PortfolioId,
        pub currency: polymesh_primitives::ticker::Ticker,
        pub per_share: u128,
        pub amount: u128,
        pub remaining: u128,
        pub reclaimed: bool,
        pub payment_at: u64,
        pub expires_at: Option<u64>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Version(pub u8);
      #[doc = "Dispatchable calls."]
      #[doc = ""]
      #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CapitalDistributionCall {
        #[doc = "Start and attach a capital distribution, to the CA identified by `ca_id`,"]
        #[doc = "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID."]
        #[doc = ""]
        #[doc = "The distribution will commence at `payment_at` and expire at `expires_at`,"]
        #[doc = "if provided, or if `None`, then there's no expiry."]
        #[doc = ""]
        #[doc = "The funds will be locked in `portfolio` from when `distribute` is called."]
        #[doc = "When there's no expiry, some funds may be locked indefinitely in `portfolio`,"]
        #[doc = "due to claimants not withdrawing or no benefits being pushed to them."]
        #[doc = "For indivisible currencies, unlocked amounts, of less than one whole unit,"]
        #[doc = "will not be transferable from `portfolio`."]
        #[doc = "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units,"]
        #[doc = "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`,"]
        #[doc = "which is now transferrable."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
        #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
        #[doc = "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from."]
        #[doc = "- `currency` to withdraw and distribute from the `portfolio`."]
        #[doc = "- `per_share` amount of `currency` to withdraw and distribute."]
        #[doc = "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token."]
        #[doc = "- `amount` of `currency` to withdraw and distribute at most."]
        #[doc = "- `payment_at` specifies when benefits may first be pushed or claimed."]
        #[doc = "- `expires_at` specifies, if provided, when remaining benefits are forfeit"]
        #[doc = "   and may be reclaimed by `origin`."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
        #[doc = "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`."]
        #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
        #[doc = "- `NoRecordDate` if CA has no record date."]
        #[doc = "- `RecordDateAfterStart` if CA's record date > payment_at."]
        #[doc = "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`."]
        #[doc = "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`."]
        #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
        #[doc = "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit"]
        #[doc = "- `DistributionAmountIsZero` if the `amount` is zero."]
        #[doc = "- `DistributionPerShareIsZero` if the `per_share` is zero."]
        #[doc = ""]
        #[doc = "# Permissions"]
        #[doc = "* Asset"]
        #[doc = "* Portfolio"]
        #[codec(index = 0u8)]
        distribute {
          ca_id: pallet_corporate_actions::CAId,
          portfolio: Option<polymesh_primitives::identity_id::PortfolioNumber>,
          currency: polymesh_primitives::ticker::Ticker,
          per_share: u128,
          amount: u128,
          payment_at: u64,
          expires_at: Option<u64>,
        },
        #[doc = "Claim a benefit of the capital distribution attached to `ca_id`."]
        #[doc = ""]
        #[doc = "Taxes are withheld as specified by the CA."]
        #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
        #[doc = ""]
        #[doc = "All benefits are rounded by truncation, down to first integer below."]
        #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
        #[doc = "they are rounded down to a whole unit."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` which must be a holder of the asset and eligible for the distribution."]
        #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit."]
        #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
        #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
        #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
        #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
        #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
        #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
        #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
        #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
        #[codec(index = 1u8)]
        claim {
          ca_id: pallet_corporate_actions::CAId,
        },
        #[doc = "Push benefit of an ongoing distribution to the given `holder`."]
        #[doc = ""]
        #[doc = "Taxes are withheld as specified by the CA."]
        #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
        #[doc = ""]
        #[doc = "All benefits are rounded by truncation, down to first integer below."]
        #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
        #[doc = "they are rounded down to a whole unit."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
        #[doc = "- `ca_id` identifies the CA with a capital distributions to push benefits for."]
        #[doc = "- `holder` to push benefits to."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
        #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
        #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
        #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
        #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
        #[doc = "- `NotTargetedByCA` if the CA does not target `holder`."]
        #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
        #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
        #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
        #[codec(index = 2u8)]
        push_benefit {
          ca_id: pallet_corporate_actions::CAId,
          holder: ::polymesh_api_client::IdentityId,
        },
        #[doc = "Assuming a distribution has expired,"]
        #[doc = "unlock the remaining amount in the distributor portfolio."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` which must be the creator of the capital distribution tied to `ca_id`."]
        #[doc = "- `ca_id` identifies the CA with a capital distribution to reclaim for."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
        #[doc = "- `AlreadyReclaimed` if this function has already been called successfully."]
        #[doc = "- `NotExpired` if `now < expiry`."]
        #[codec(index = 3u8)]
        reclaim {
          ca_id: pallet_corporate_actions::CAId,
        },
        #[doc = "Removes a distribution that hasn't started yet,"]
        #[doc = "unlocking the full amount in the distributor portfolio."]
        #[doc = ""]
        #[doc = "## Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
        #[doc = "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
        #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
        #[doc = "- `DistributionStarted` if `payment_at <= now`."]
        #[codec(index = 4u8)]
        remove_distribution {
          ca_id: pallet_corporate_actions::CAId,
        },
      }
      impl CapitalDistributionCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::distribute { .. } => "CapitalDistribution.distribute",
            Self::claim { .. } => "CapitalDistribution.claim",
            Self::push_benefit { .. } => "CapitalDistribution.push_benefit",
            Self::reclaim { .. } => "CapitalDistribution.reclaim",
            Self::remove_distribution { .. } => "CapitalDistribution.remove_distribution",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CapitalDistributionCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: distribute { .. } => { & ["Start and attach a capital distribution, to the CA identified by `ca_id`," , "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID." , "" , "The distribution will commence at `payment_at` and expire at `expires_at`," , "if provided, or if `None`, then there's no expiry." , "" , "The funds will be locked in `portfolio` from when `distribute` is called." , "When there's no expiry, some funds may be locked indefinitely in `portfolio`," , "due to claimants not withdrawing or no benefits being pushed to them." , "For indivisible currencies, unlocked amounts, of less than one whole unit," , "will not be transferable from `portfolio`." , "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units," , "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`," , "which is now transferrable." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`." , "- `ca_id` identifies the CA to start a capital distribution for." , "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from." , "- `currency` to withdraw and distribute from the `portfolio`." , "- `per_share` amount of `currency` to withdraw and distribute." , "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token." , "- `amount` of `currency` to withdraw and distribute at most." , "- `payment_at` specifies when benefits may first be pushed or claimed." , "- `expires_at` specifies, if provided, when remaining benefits are forfeit" , "   and may be reclaimed by `origin`." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NoRecordDate` if CA has no record date." , "- `RecordDateAfterStart` if CA's record date > payment_at." , "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`." , "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`." , "- `InsufficientBalance` if the protocol fee couldn't be charged." , "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit" , "- `DistributionAmountIsZero` if the `amount` is zero." , "- `DistributionPerShareIsZero` if the `per_share` is zero." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: claim { .. } => { & ["Claim a benefit of the capital distribution attached to `ca_id`." , "" , "Taxes are withheld as specified by the CA." , "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID." , "" , "All benefits are rounded by truncation, down to first integer below." , "Moreover, before post-tax earnings, in indivisible currencies are transferred," , "they are rounded down to a whole unit." , "" , "## Arguments" , "- `origin` which must be a holder of the asset and eligible for the distribution." , "- `ca_id` identifies the CA to start a capital distribution for." , "" , "# Errors" , "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit." , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `CannotClaimBeforeStart` if `now < payment_at`." , "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NotTargetedByCA` if the CA does not target `origin`'s DID." , "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow." , "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow." , "- Other errors can occur if the compliance manager rejects the transfer." ,] } , Self :: push_benefit { .. } => { & ["Push benefit of an ongoing distribution to the given `holder`." , "" , "Taxes are withheld as specified by the CA." , "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID." , "" , "All benefits are rounded by truncation, down to first integer below." , "Moreover, before post-tax earnings, in indivisible currencies are transferred," , "they are rounded down to a whole unit." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`." , "- `ca_id` identifies the CA with a capital distributions to push benefits for." , "- `holder` to push benefits to." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `CannotClaimBeforeStart` if `now < payment_at`." , "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NotTargetedByCA` if the CA does not target `holder`." , "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow." , "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow." , "- Other errors can occur if the compliance manager rejects the transfer." ,] } , Self :: reclaim { .. } => { & ["Assuming a distribution has expired," , "unlock the remaining amount in the distributor portfolio." , "" , "## Arguments" , "- `origin` which must be the creator of the capital distribution tied to `ca_id`." , "- `ca_id` identifies the CA with a capital distribution to reclaim for." , "" , "# Errors" , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `AlreadyReclaimed` if this function has already been called successfully." , "- `NotExpired` if `now < expiry`." ,] } , Self :: remove_distribution { .. } => { & ["Removes a distribution that hasn't started yet," , "unlocking the full amount in the distributor portfolio." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`." , "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `DistributionStarted` if `payment_at <= now`." ,] } , _ => & [""] , }
        }
      }
      impl From<CapitalDistributionCall> for &'static str {
        fn from(v: CapitalDistributionCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CapitalDistributionCall> for &'static str {
        fn from(v: &CapitalDistributionCall) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum CorporateActionError {
      #[doc = "The `details` of a CA exceeded the max allowed length."]
      #[codec(index = 0u8)]
      DetailsTooLong,
      #[doc = "A withholding tax override for a given DID was specified more than once."]
      #[doc = "The chain refused to make a choice, and hence there was an error."]
      #[codec(index = 1u8)]
      DuplicateDidTax,
      #[doc = "Too many withholding tax overrides were specified."]
      #[codec(index = 2u8)]
      TooManyDidTaxes,
      #[doc = "Too many identities in `TargetIdentities` were specified."]
      #[codec(index = 3u8)]
      TooManyTargetIds,
      #[doc = "On CA creation, a checkpoint ID was provided which doesn't exist."]
      #[codec(index = 4u8)]
      NoSuchCheckpointId,
      #[doc = "A CA with the given `CAId` did not exist."]
      #[codec(index = 5u8)]
      NoSuchCA,
      #[doc = "The CA did not have a record date."]
      #[codec(index = 6u8)]
      NoRecordDate,
      #[doc = "A CA's record date was strictly after the \"start\" time,"]
      #[doc = "where \"start\" is context dependent."]
      #[doc = "For example, it could be the start of a ballot, or the start-of-payment in capital distribution."]
      #[codec(index = 7u8)]
      RecordDateAfterStart,
      #[doc = "A CA's declaration date was strictly after its record date."]
      #[codec(index = 8u8)]
      DeclDateAfterRecordDate,
      #[doc = "A CA's declaration date occurs in the future."]
      #[codec(index = 9u8)]
      DeclDateInFuture,
      #[doc = "CA does not target the DID."]
      #[codec(index = 10u8)]
      NotTargetedByCA,
    }
    impl CorporateActionError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::DetailsTooLong => "CorporateAction.DetailsTooLong",
          Self::DuplicateDidTax => "CorporateAction.DuplicateDidTax",
          Self::TooManyDidTaxes => "CorporateAction.TooManyDidTaxes",
          Self::TooManyTargetIds => "CorporateAction.TooManyTargetIds",
          Self::NoSuchCheckpointId => "CorporateAction.NoSuchCheckpointId",
          Self::NoSuchCA => "CorporateAction.NoSuchCA",
          Self::NoRecordDate => "CorporateAction.NoRecordDate",
          Self::RecordDateAfterStart => "CorporateAction.RecordDateAfterStart",
          Self::DeclDateAfterRecordDate => "CorporateAction.DeclDateAfterRecordDate",
          Self::DeclDateInFuture => "CorporateAction.DeclDateInFuture",
          Self::NotTargetedByCA => "CorporateAction.NotTargetedByCA",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for CorporateActionError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: DetailsTooLong => { & ["The `details` of a CA exceeded the max allowed length." ,] } , Self :: DuplicateDidTax => { & ["A withholding tax override for a given DID was specified more than once." , "The chain refused to make a choice, and hence there was an error." ,] } , Self :: TooManyDidTaxes => { & ["Too many withholding tax overrides were specified." ,] } , Self :: TooManyTargetIds => { & ["Too many identities in `TargetIdentities` were specified." ,] } , Self :: NoSuchCheckpointId => { & ["On CA creation, a checkpoint ID was provided which doesn't exist." ,] } , Self :: NoSuchCA => { & ["A CA with the given `CAId` did not exist." ,] } , Self :: NoRecordDate => { & ["The CA did not have a record date." ,] } , Self :: RecordDateAfterStart => { & ["A CA's record date was strictly after the \"start\" time," , "where \"start\" is context dependent." , "For example, it could be the start of a ballot, or the start-of-payment in capital distribution." ,] } , Self :: DeclDateAfterRecordDate => { & ["A CA's declaration date was strictly after its record date." ,] } , Self :: DeclDateInFuture => { & ["A CA's declaration date occurs in the future." ,] } , Self :: NotTargetedByCA => { & ["CA does not target the DID." ,] } , _ => & [""] , }
      }
    }
    impl From<CorporateActionError> for &'static str {
      fn from(v: CorporateActionError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&CorporateActionError> for &'static str {
      fn from(v: &CorporateActionError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum CorporateActionEvent {
      #[doc = "The maximum length of `details` in bytes was changed."]
      #[doc = "(GC DID, new length)"]
      #[codec(index = 0u8)]
      MaxDetailsLengthChanged(::polymesh_api_client::IdentityId, u32),
      #[doc = "The set of default `TargetIdentities` for a ticker changed."]
      #[doc = "(Agent DID, Ticker, New TargetIdentities)"]
      #[codec(index = 1u8)]
      DefaultTargetIdentitiesChanged(
        ::polymesh_api_client::IdentityId,
        polymesh_primitives::ticker::Ticker,
        pallet_corporate_actions::TargetIdentities,
      ),
      #[doc = "The default withholding tax for a ticker changed."]
      #[doc = "(Agent DID, Ticker, New Tax)."]
      #[codec(index = 2u8)]
      DefaultWithholdingTaxChanged(
        ::polymesh_api_client::IdentityId,
        polymesh_primitives::ticker::Ticker,
        ::polymesh_api_client::per_things::Permill,
      ),
      #[doc = "The withholding tax specific to a DID for a ticker changed."]
      #[doc = "(Agent DID, Ticker, Taxed DID, New Tax)."]
      #[codec(index = 3u8)]
      DidWithholdingTaxChanged(
        ::polymesh_api_client::IdentityId,
        polymesh_primitives::ticker::Ticker,
        ::polymesh_api_client::IdentityId,
        Option<::polymesh_api_client::per_things::Permill>,
      ),
      #[doc = "A CA was initiated."]
      #[doc = "(Agent DID, CA id, the CA, the CA details)"]
      #[codec(index = 4u8)]
      CAInitiated(
        polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
        pallet_corporate_actions::CAId,
        pallet_corporate_actions::CorporateAction,
        pallet_corporate_actions::CADetails,
      ),
      #[doc = "A CA was linked to a set of docs."]
      #[doc = "(Agent DID, CA Id, List of doc identifiers)"]
      #[codec(index = 5u8)]
      CALinkedToDoc(
        ::polymesh_api_client::IdentityId,
        pallet_corporate_actions::CAId,
        ::alloc::vec::Vec<polymesh_primitives::document::DocumentId>,
      ),
      #[doc = "A CA was removed."]
      #[doc = "(Agent DID, CA Id)"]
      #[codec(index = 6u8)]
      CARemoved(
        polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
        pallet_corporate_actions::CAId,
      ),
      #[doc = "A CA's record date changed."]
      #[codec(index = 7u8)]
      RecordDateChanged(
        polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
        pallet_corporate_actions::CAId,
        pallet_corporate_actions::CorporateAction,
      ),
    }
    impl CorporateActionEvent {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::MaxDetailsLengthChanged(_, _) => "CorporateAction.MaxDetailsLengthChanged",
          Self::DefaultTargetIdentitiesChanged(_, _, _) => {
            "CorporateAction.DefaultTargetIdentitiesChanged"
          }
          Self::DefaultWithholdingTaxChanged(_, _, _) => {
            "CorporateAction.DefaultWithholdingTaxChanged"
          }
          Self::DidWithholdingTaxChanged(_, _, _, _) => "CorporateAction.DidWithholdingTaxChanged",
          Self::CAInitiated(_, _, _, _) => "CorporateAction.CAInitiated",
          Self::CALinkedToDoc(_, _, _) => "CorporateAction.CALinkedToDoc",
          Self::CARemoved(_, _) => "CorporateAction.CARemoved",
          Self::RecordDateChanged(_, _, _) => "CorporateAction.RecordDateChanged",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for CorporateActionEvent {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::MaxDetailsLengthChanged(_, _) => &[
            "The maximum length of `details` in bytes was changed.",
            "(GC DID, new length)",
          ],
          Self::DefaultTargetIdentitiesChanged(_, _, _) => &[
            "The set of default `TargetIdentities` for a ticker changed.",
            "(Agent DID, Ticker, New TargetIdentities)",
          ],
          Self::DefaultWithholdingTaxChanged(_, _, _) => &[
            "The default withholding tax for a ticker changed.",
            "(Agent DID, Ticker, New Tax).",
          ],
          Self::DidWithholdingTaxChanged(_, _, _, _) => &[
            "The withholding tax specific to a DID for a ticker changed.",
            "(Agent DID, Ticker, Taxed DID, New Tax).",
          ],
          Self::CAInitiated(_, _, _, _) => &[
            "A CA was initiated.",
            "(Agent DID, CA id, the CA, the CA details)",
          ],
          Self::CALinkedToDoc(_, _, _) => &[
            "A CA was linked to a set of docs.",
            "(Agent DID, CA Id, List of doc identifiers)",
          ],
          Self::CARemoved(_, _) => &["A CA was removed.", "(Agent DID, CA Id)"],
          Self::RecordDateChanged(_, _, _) => &["A CA's record date changed."],
          _ => &[""],
        }
      }
    }
    impl From<CorporateActionEvent> for &'static str {
      fn from(v: CorporateActionEvent) -> Self {
        v.as_static_str()
      }
    }
    impl From<&CorporateActionEvent> for &'static str {
      fn from(v: &CorporateActionEvent) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct LocalCAId(pub u32);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum CACheckpoint {
      #[codec(index = 0u8)]
      Scheduled(
        polymesh_common_utilities::traits::checkpoint::ScheduleId,
        u64,
      ),
      #[codec(index = 1u8)]
      Existing(polymesh_primitives::asset::CheckpointId),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct CAId {
      pub ticker: polymesh_primitives::ticker::Ticker,
      pub local_id: pallet_corporate_actions::LocalCAId,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct InitiateCorporateActionArgs {
      pub ticker: polymesh_primitives::ticker::Ticker,
      pub kind: pallet_corporate_actions::CAKind,
      pub decl_date: u64,
      pub record_date: Option<pallet_corporate_actions::RecordDateSpec>,
      pub details: pallet_corporate_actions::CADetails,
      pub targets: Option<pallet_corporate_actions::TargetIdentities>,
      pub default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
      pub withholding_tax: Option<
        ::alloc::vec::Vec<(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::per_things::Permill,
        )>,
      >,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum CAKind {
      #[codec(index = 0u8)]
      PredictableBenefit,
      #[codec(index = 1u8)]
      UnpredictableBenefit,
      #[codec(index = 2u8)]
      IssuerNotice,
      #[codec(index = 3u8)]
      Reorganization,
      #[codec(index = 4u8)]
      Other,
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum CorporateActionCall {
      #[doc = "Set the max `length` of `details` in terms of bytes."]
      #[doc = "May only be called via a PIP."]
      #[codec(index = 0u8)]
      set_max_details_length { length: u32 },
      #[doc = "Set the default CA `TargetIdentities` to `targets`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` for which the default identities are changing."]
      #[doc = "- `targets` the default target identities for a CA."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 1u8)]
      set_default_targets {
        ticker: polymesh_primitives::ticker::Ticker,
        targets: pallet_corporate_actions::TargetIdentities,
      },
      #[doc = "Set the default withholding tax for all DIDs and CAs relevant to this `ticker`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` that the withholding tax will apply to."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 2u8)]
      set_default_withholding_tax {
        ticker: polymesh_primitives::ticker::Ticker,
        tax: ::polymesh_api_client::per_things::Permill,
      },
      #[doc = "Set the withholding tax of `ticker` for `taxed_did` to `tax`."]
      #[doc = "If `Some(tax)`, this overrides the default withholding tax of `ticker` to `tax` for `taxed_did`."]
      #[doc = "Otherwise, if `None`, the default withholding tax will be used."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` that the withholding tax will apply to."]
      #[doc = "- `taxed_did` that will have its withholding tax updated."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 3u8)]
      set_did_withholding_tax {
        ticker: polymesh_primitives::ticker::Ticker,
        taxed_did: ::polymesh_api_client::IdentityId,
        tax: Option<::polymesh_api_client::per_things::Permill>,
      },
      #[doc = "Initiates a CA for `ticker` of `kind` with `details` and other provided arguments."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` that the CA is made for."]
      #[doc = "- `kind` of CA being initiated."]
      #[doc = "- `decl_date` of CA bring initialized."]
      #[doc = "- `record_date`, if any, to calculate the impact of this CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = "- `details` of the CA in free-text form, up to a certain number of bytes in length."]
      #[doc = "- `targets`, if any, which this CA is relevant/irrelevant to."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_targets`)."]
      #[doc = "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)."]
      #[doc = "- `withholding_tax`, if any, provides per-DID withholding tax overrides."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `CounterOverflow` in the unlikely event that so many CAs were created for this `ticker`,"]
      #[doc = "  that integer overflow would have occured if instead allowed."]
      #[doc = "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`."]
      #[doc = "- `DuplicateDidTax` if a DID is included more than once in `wt`."]
      #[doc = "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`."]
      #[doc = "- `DeclDateInFuture` if the declaration date is not in the past."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 4u8)]
      initiate_corporate_action {
        ticker: polymesh_primitives::ticker::Ticker,
        kind: pallet_corporate_actions::CAKind,
        decl_date: u64,
        record_date: Option<pallet_corporate_actions::RecordDateSpec>,
        details: pallet_corporate_actions::CADetails,
        targets: Option<pallet_corporate_actions::TargetIdentities>,
        default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
        withholding_tax: Option<
          ::alloc::vec::Vec<(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::per_things::Permill,
          )>,
        >,
      },
      #[doc = "Link the given CA `id` to the given `docs`."]
      #[doc = "Any previous links for the CA are removed in favor of `docs`."]
      #[doc = ""]
      #[doc = "The workflow here is to add the documents and initiating the CA in any order desired."]
      #[doc = "Once both exist, they can now be linked together."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `id.ticker` with relevant permissions."]
      #[doc = "- `id` of the CA to associate with `docs`."]
      #[doc = "- `docs` to associate with the CA with `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- `NoSuchDoc` if any of `docs` does not identify an existing document."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 5u8)]
      link_ca_doc {
        id: pallet_corporate_actions::CAId,
        docs: ::alloc::vec::Vec<polymesh_primitives::document::DocumentId>,
      },
      #[doc = "Removes the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "Associated data, such as document links, ballots,"]
      #[doc = "and capital distributions are also removed."]
      #[doc = ""]
      #[doc = "Any schedule associated with the record date will see"]
      #[doc = "`strong_ref_count(schedule_id)` decremented."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.ticker` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 6u8)]
      remove_ca {
        ca_id: pallet_corporate_actions::CAId,
      },
      #[doc = "Changes the record date of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.ticker` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to alter."]
      #[doc = "- `record_date`, if any, to calculate the impact of the CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 7u8)]
      change_record_date {
        ca_id: pallet_corporate_actions::CAId,
        record_date: Option<pallet_corporate_actions::RecordDateSpec>,
      },
      #[doc = "Utility extrinsic to batch `initiate_corporate_action` and `distribute`"]
      #[codec(index = 8u8)]
      initiate_corporate_action_and_distribute {
        ca_args: pallet_corporate_actions::InitiateCorporateActionArgs,
        portfolio: Option<polymesh_primitives::identity_id::PortfolioNumber>,
        currency: polymesh_primitives::ticker::Ticker,
        per_share: u128,
        amount: u128,
        payment_at: u64,
        expires_at: Option<u64>,
      },
    }
    impl CorporateActionCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_max_details_length { .. } => "CorporateAction.set_max_details_length",
          Self::set_default_targets { .. } => "CorporateAction.set_default_targets",
          Self::set_default_withholding_tax { .. } => "CorporateAction.set_default_withholding_tax",
          Self::set_did_withholding_tax { .. } => "CorporateAction.set_did_withholding_tax",
          Self::initiate_corporate_action { .. } => "CorporateAction.initiate_corporate_action",
          Self::link_ca_doc { .. } => "CorporateAction.link_ca_doc",
          Self::remove_ca { .. } => "CorporateAction.remove_ca",
          Self::change_record_date { .. } => "CorporateAction.change_record_date",
          Self::initiate_corporate_action_and_distribute { .. } => {
            "CorporateAction.initiate_corporate_action_and_distribute"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for CorporateActionCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_max_details_length { .. } => { & ["Set the max `length` of `details` in terms of bytes." , "May only be called via a PIP." ,] } , Self :: set_default_targets { .. } => { & ["Set the default CA `TargetIdentities` to `targets`." , "" , "## Arguments" , "- `origin` which must be an external agent of `ticker` with relevant permissions." , "- `ticker` for which the default identities are changing." , "- `targets` the default target identities for a CA." , "" , "## Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`." , "" , "# Permissions" , "* Asset" ,] } , Self :: set_default_withholding_tax { .. } => { & ["Set the default withholding tax for all DIDs and CAs relevant to this `ticker`." , "" , "## Arguments" , "- `origin` which must be an external agent of `ticker` with relevant permissions." , "- `ticker` that the withholding tax will apply to." , "- `tax` that should be withheld when distributing dividends, etc." , "" , "## Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "" , "# Permissions" , "* Asset" ,] } , Self :: set_did_withholding_tax { .. } => { & ["Set the withholding tax of `ticker` for `taxed_did` to `tax`." , "If `Some(tax)`, this overrides the default withholding tax of `ticker` to `tax` for `taxed_did`." , "Otherwise, if `None`, the default withholding tax will be used." , "" , "## Arguments" , "- `origin` which must be an external agent of `ticker` with relevant permissions." , "- `ticker` that the withholding tax will apply to." , "- `taxed_did` that will have its withholding tax updated." , "- `tax` that should be withheld when distributing dividends, etc." , "" , "## Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`." , "" , "# Permissions" , "* Asset" ,] } , Self :: initiate_corporate_action { .. } => { & ["Initiates a CA for `ticker` of `kind` with `details` and other provided arguments." , "" , "## Arguments" , "- `origin` which must be an external agent of `ticker` with relevant permissions." , "- `ticker` that the CA is made for." , "- `kind` of CA being initiated." , "- `decl_date` of CA bring initialized." , "- `record_date`, if any, to calculate the impact of this CA." , "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date." , "- `details` of the CA in free-text form, up to a certain number of bytes in length." , "- `targets`, if any, which this CA is relevant/irrelevant to." , "   Overrides, if provided, the default at the asset level (`set_default_targets`)." , "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA." , "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)." , "- `withholding_tax`, if any, provides per-DID withholding tax overrides." , "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)." , "" , "# Errors" , "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `CounterOverflow` in the unlikely event that so many CAs were created for this `ticker`," , "  that integer overflow would have occured if instead allowed." , "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`." , "- `DuplicateDidTax` if a DID is included more than once in `wt`." , "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`." , "- `DeclDateInFuture` if the declaration date is not in the past." , "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur." , "" , "# Permissions" , "* Asset" ,] } , Self :: link_ca_doc { .. } => { & ["Link the given CA `id` to the given `docs`." , "Any previous links for the CA are removed in favor of `docs`." , "" , "The workflow here is to add the documents and initiating the CA in any order desired." , "Once both exist, they can now be linked together." , "" , "## Arguments" , "- `origin` which must be an external agent of `id.ticker` with relevant permissions." , "- `id` of the CA to associate with `docs`." , "- `docs` to associate with the CA with `id`." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `NoSuchCA` if `id` does not identify an existing CA." , "- `NoSuchDoc` if any of `docs` does not identify an existing document." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_ca { .. } => { & ["Removes the CA identified by `ca_id`." , "" , "Associated data, such as document links, ballots," , "and capital distributions are also removed." , "" , "Any schedule associated with the record date will see" , "`strong_ref_count(schedule_id)` decremented." , "" , "## Arguments" , "- `origin` which must be an external agent of `ca_id.ticker` with relevant permissions." , "- `ca_id` of the CA to remove." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `NoSuchCA` if `id` does not identify an existing CA." , "" , "# Permissions" , "* Asset" ,] } , Self :: change_record_date { .. } => { & ["Changes the record date of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` which must be an external agent of `ca_id.ticker` with relevant permissions." , "- `ca_id` of the CA to alter." , "- `record_date`, if any, to calculate the impact of the CA." , "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`." , "- `NoSuchCA` if `id` does not identify an existing CA." , "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur." , "" , "# Permissions" , "* Asset" ,] } , Self :: initiate_corporate_action_and_distribute { .. } => { & ["Utility extrinsic to batch `initiate_corporate_action` and `distribute`" ,] } , _ => & [""] , }
      }
    }
    impl From<CorporateActionCall> for &'static str {
      fn from(v: CorporateActionCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&CorporateActionCall> for &'static str {
      fn from(v: &CorporateActionCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct TargetIdentities {
      pub identities: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      pub treatment: pallet_corporate_actions::TargetTreatment,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct CorporateAction {
      pub kind: pallet_corporate_actions::CAKind,
      pub decl_date: u64,
      pub record_date: Option<pallet_corporate_actions::RecordDate>,
      pub targets: pallet_corporate_actions::TargetIdentities,
      pub default_withholding_tax: ::polymesh_api_client::per_things::Permill,
      pub withholding_tax: ::alloc::vec::Vec<(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::per_things::Permill,
      )>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct CADetails(pub ::alloc::vec::Vec<u8>);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct RecordDate {
      pub date: u64,
      pub checkpoint: pallet_corporate_actions::CACheckpoint,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TargetTreatment {
      #[codec(index = 0u8)]
      Include,
      #[codec(index = 1u8)]
      Exclude,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RecordDateSpec {
      #[codec(index = 0u8)]
      Scheduled(u64),
      #[codec(index = 1u8)]
      ExistingSchedule(polymesh_common_utilities::traits::checkpoint::ScheduleId),
      #[codec(index = 2u8)]
      Existing(polymesh_primitives::asset::CheckpointId),
    }
  }
  pub mod pallet_base {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BaseCall {}
    impl BaseCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for BaseCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          _ => &[""],
        }
      }
    }
    impl From<BaseCall> for &'static str {
      fn from(v: BaseCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&BaseCall> for &'static str {
      fn from(v: &BaseCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BaseError {
      #[doc = "Exceeded a generic length limit."]
      #[doc = "The limit could be for any sort of lists of things, including a string."]
      #[codec(index = 0u8)]
      TooLong,
      #[doc = "The sequence counter for something overflowed."]
      #[doc = ""]
      #[doc = "When this happens depends on e.g., the capacity of the identifier type."]
      #[doc = "For example, we might have `pub struct PipId(u32);`, with `u32::MAX` capacity."]
      #[doc = "In practice, these errors will never happen but no code path should result in a panic,"]
      #[doc = "so these corner cases need to be covered with an error variant."]
      #[codec(index = 1u8)]
      CounterOverflow,
    }
    impl BaseError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::TooLong => "Base.TooLong",
          Self::CounterOverflow => "Base.CounterOverflow",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for BaseError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: TooLong => { & ["Exceeded a generic length limit." , "The limit could be for any sort of lists of things, including a string." ,] } , Self :: CounterOverflow => { & ["The sequence counter for something overflowed." , "" , "When this happens depends on e.g., the capacity of the identifier type." , "For example, we might have `pub struct PipId(u32);`, with `u32::MAX` capacity." , "In practice, these errors will never happen but no code path should result in a panic," , "so these corner cases need to be covered with an error variant." ,] } , _ => & [""] , }
      }
    }
    impl From<BaseError> for &'static str {
      fn from(v: BaseError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&BaseError> for &'static str {
      fn from(v: &BaseError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_relayer {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Subsidy<Acc> {
      pub paying_key: Acc,
      pub remaining: u128,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RelayerError {
      #[doc = "The `user_key` is not attached to a CDD'd identity."]
      #[codec(index = 0u8)]
      UserKeyCddMissing,
      #[doc = "The `user_key` is not attached to a CDD'd identity."]
      #[codec(index = 1u8)]
      PayingKeyCddMissing,
      #[doc = "The `user_key` doesn't have a `paying_key`."]
      #[codec(index = 2u8)]
      NoPayingKey,
      #[doc = "The `user_key` has a different `paying_key`."]
      #[codec(index = 3u8)]
      NotPayingKey,
      #[doc = "The signer is not authorized for `paying_key`."]
      #[codec(index = 4u8)]
      NotAuthorizedForPayingKey,
      #[doc = "The signer is not authorized for `user_key`."]
      #[codec(index = 5u8)]
      NotAuthorizedForUserKey,
      #[doc = "The remaining POLYX for `user_key` overflowed."]
      #[codec(index = 6u8)]
      Overflow,
    }
    impl RelayerError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::UserKeyCddMissing => "Relayer.UserKeyCddMissing",
          Self::PayingKeyCddMissing => "Relayer.PayingKeyCddMissing",
          Self::NoPayingKey => "Relayer.NoPayingKey",
          Self::NotPayingKey => "Relayer.NotPayingKey",
          Self::NotAuthorizedForPayingKey => "Relayer.NotAuthorizedForPayingKey",
          Self::NotAuthorizedForUserKey => "Relayer.NotAuthorizedForUserKey",
          Self::Overflow => "Relayer.Overflow",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for RelayerError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::UserKeyCddMissing => &["The `user_key` is not attached to a CDD'd identity."],
          Self::PayingKeyCddMissing => &["The `user_key` is not attached to a CDD'd identity."],
          Self::NoPayingKey => &["The `user_key` doesn't have a `paying_key`."],
          Self::NotPayingKey => &["The `user_key` has a different `paying_key`."],
          Self::NotAuthorizedForPayingKey => &["The signer is not authorized for `paying_key`."],
          Self::NotAuthorizedForUserKey => &["The signer is not authorized for `user_key`."],
          Self::Overflow => &["The remaining POLYX for `user_key` overflowed."],
          _ => &[""],
        }
      }
    }
    impl From<RelayerError> for &'static str {
      fn from(v: RelayerError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&RelayerError> for &'static str {
      fn from(v: &RelayerError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RelayerCall {
      #[doc = "Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to subsidise."]
      #[doc = "- `polyx_limit` the initial POLYX limit for this subsidy."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[codec(index = 0u8)]
      set_paying_key {
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      },
      #[doc = "Accepts a `paying_key` authorization."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` the authorization id to accept a `paying_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` the authorization has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not a `AddRelayerPayingKey` authorization."]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`."]
      #[doc = "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity."]
      #[doc = "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity."]
      #[doc = "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[codec(index = 1u8)]
      accept_paying_key { auth_id: u64 },
      #[doc = "Removes the `paying_key` from a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to remove the subsidy from."]
      #[doc = "- `paying_key` the paying key that was subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`."]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[codec(index = 2u8)]
      remove_paying_key {
        user_key: ::polymesh_api_client::AccountId,
        paying_key: ::polymesh_api_client::AccountId,
      },
      #[doc = "Updates the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[codec(index = 3u8)]
      update_polyx_limit {
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      },
      #[doc = "Increase the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to add to the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`."]
      #[codec(index = 4u8)]
      increase_polyx_limit {
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      },
      #[doc = "Decrease the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to remove from the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy has less then `amount` POLYX remaining."]
      #[codec(index = 5u8)]
      decrease_polyx_limit {
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      },
    }
    impl RelayerCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_paying_key { .. } => "Relayer.set_paying_key",
          Self::accept_paying_key { .. } => "Relayer.accept_paying_key",
          Self::remove_paying_key { .. } => "Relayer.remove_paying_key",
          Self::update_polyx_limit { .. } => "Relayer.update_polyx_limit",
          Self::increase_polyx_limit { .. } => "Relayer.increase_polyx_limit",
          Self::decrease_polyx_limit { .. } => "Relayer.decrease_polyx_limit",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for RelayerCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_paying_key { .. } => { & ["Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser." , "" , "# Arguments" , "- `user_key` the user key to subsidise." , "- `polyx_limit` the initial POLYX limit for this subsidy." , "" , "# Errors" , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: accept_paying_key { .. } => { & ["Accepts a `paying_key` authorization." , "" , "# Arguments" , "- `auth_id` the authorization id to accept a `paying_key`." , "" , "# Errors" , "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller." , "- `AuthorizationError::Expired` if `auth_id` the authorization has expired." , "- `AuthorizationError::BadType` if `auth_id` was not a `AddRelayerPayingKey` authorization." , "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`." , "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity." , "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity." , "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: remove_paying_key { .. } => { & ["Removes the `paying_key` from a `user_key`." , "" , "# Arguments" , "- `user_key` the user key to remove the subsidy from." , "- `paying_key` the paying key that was subsidising the `user_key`." , "" , "# Errors" , "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`." , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: update_polyx_limit { .. } => { & ["Updates the available POLYX for a `user_key`." , "" , "# Arguments" , "- `user_key` the user key of the subsidy to update the available POLYX." , "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`." , "" , "# Errors" , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if `origin` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: increase_polyx_limit { .. } => { & ["Increase the available POLYX for a `user_key`." , "" , "# Arguments" , "- `user_key` the user key of the subsidy to update the available POLYX." , "- `amount` the amount of POLYX to add to the subsidy of `user_key`." , "" , "# Errors" , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if `origin` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." , "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`." ,] } , Self :: decrease_polyx_limit { .. } => { & ["Decrease the available POLYX for a `user_key`." , "" , "# Arguments" , "- `user_key` the user key of the subsidy to update the available POLYX." , "- `amount` the amount of POLYX to remove from the subsidy of `user_key`." , "" , "# Errors" , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if `origin` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." , "- `Overlow` if the subsidy has less then `amount` POLYX remaining." ,] } , _ => & [""] , }
      }
    }
    impl From<RelayerCall> for &'static str {
      fn from(v: RelayerCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&RelayerCall> for &'static str {
      fn from(v: &RelayerCall) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_timestamp {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum TimestampCall {
        #[doc = "Set the current time."]
        #[doc = ""]
        #[doc = "This call should be invoked exactly once per block. It will panic at the finalization"]
        #[doc = "phase, if this call hasn't been invoked by that time."]
        #[doc = ""]
        #[doc = "The timestamp should be greater than the previous one by the amount specified by"]
        #[doc = "`MinimumPeriod`."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be `Inherent`."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"]
        #[doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"]
        #[doc = "  `on_finalize`)"]
        #[doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."]
        #[codec(index = 0u8)]
        set {
          #[codec(compact)]
          now: u64,
        },
      }
      impl TimestampCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::set { .. } => "Timestamp.set",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for TimestampCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: set { .. } => { & ["Set the current time." , "" , "This call should be invoked exactly once per block. It will panic at the finalization" , "phase, if this call hasn't been invoked by that time." , "" , "The timestamp should be greater than the previous one by the amount specified by" , "`MinimumPeriod`." , "" , "The dispatch origin for this call must be `Inherent`." , "" , "## Complexity" , "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)" , "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in" , "  `on_finalize`)" , "- 1 event handler `on_timestamp_set`. Must be `O(1)`." ,] } , _ => & [""] , }
        }
      }
      impl From<TimestampCall> for &'static str {
        fn from(v: TimestampCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&TimestampCall> for &'static str {
        fn from(v: &TimestampCall) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod polymesh_primitives {
    use super::*;
    pub mod condition {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Condition {
        pub condition_type: polymesh_primitives::condition::ConditionType,
        pub issuers: ::alloc::vec::Vec<polymesh_primitives::condition::TrustedIssuer>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum TargetIdentity {
        #[codec(index = 0u8)]
        ExternalAgent,
        #[codec(index = 1u8)]
        Specific(::polymesh_api_client::IdentityId),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ConditionType {
        #[codec(index = 0u8)]
        IsPresent(polymesh_primitives::identity_claim::Claim),
        #[codec(index = 1u8)]
        IsAbsent(polymesh_primitives::identity_claim::Claim),
        #[codec(index = 2u8)]
        IsAnyOf(::alloc::vec::Vec<polymesh_primitives::identity_claim::Claim>),
        #[codec(index = 3u8)]
        IsNoneOf(::alloc::vec::Vec<polymesh_primitives::identity_claim::Claim>),
        #[codec(index = 4u8)]
        IsIdentity(polymesh_primitives::condition::TargetIdentity),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct TrustedIssuer {
        pub issuer: ::polymesh_api_client::IdentityId,
        pub trusted_for: polymesh_primitives::condition::TrustedFor,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum TrustedFor {
        #[codec(index = 0u8)]
        Any,
        #[codec(index = 1u8)]
        Specific(::alloc::vec::Vec<polymesh_primitives::identity_claim::ClaimType>),
      }
    }
    pub mod multisig {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ProposalStatus {
        #[codec(index = 0u8)]
        Invalid,
        #[codec(index = 1u8)]
        ActiveOrExpired,
        #[codec(index = 2u8)]
        ExecutionSuccessful,
        #[codec(index = 3u8)]
        ExecutionFailed,
        #[codec(index = 4u8)]
        Rejected,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ProposalDetails<T> {
        pub approvals: T,
        pub rejections: T,
        pub status: polymesh_primitives::multisig::ProposalStatus,
        pub expiry: Option<T>,
        pub auto_close: bool,
      }
    }
    pub mod cdd_id {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct CddId(pub [u8; 32usize]);
    }
    pub mod statistics {
      use super::*;
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum StatOpType {
        #[codec(index = 0u8)]
        Count,
        #[codec(index = 1u8)]
        Balance,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AssetScope {
        #[codec(index = 0u8)]
        Ticker(polymesh_primitives::ticker::Ticker),
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct StatType {
        pub op: polymesh_primitives::statistics::StatOpType,
        pub claim_issuer: Option<(
          polymesh_primitives::identity_claim::ClaimType,
          ::polymesh_api_client::IdentityId,
        )>,
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Stat2ndKey {
        #[codec(index = 0u8)]
        NoClaimStat,
        #[codec(index = 1u8)]
        Claim(polymesh_primitives::statistics::StatClaim),
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum StatClaim {
        #[codec(index = 0u8)]
        Accredited(bool),
        #[codec(index = 1u8)]
        Affiliate(bool),
        #[codec(index = 2u8)]
        Jurisdiction(Option<polymesh_primitives::jurisdiction::CountryCode>),
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct StatUpdate {
        pub key2: polymesh_primitives::statistics::Stat2ndKey,
        pub value: Option<u128>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Stat1stKey {
        pub asset: polymesh_primitives::statistics::AssetScope,
        pub stat_type: polymesh_primitives::statistics::StatType,
      }
    }
    pub mod event_only {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct EventOnly<T>(pub T);
    }
    pub mod nft {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTCollectionKeys(
        pub ::alloc::vec::Vec<polymesh_primitives::asset_metadata::AssetMetadataKey>,
      );
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTMetadataAttribute {
        pub key: polymesh_primitives::asset_metadata::AssetMetadataKey,
        pub value: polymesh_primitives::asset_metadata::AssetMetadataValue,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTCollection {
        pub id: polymesh_primitives::nft::NFTCollectionId,
        pub ticker: polymesh_primitives::ticker::Ticker,
      }
      #[derive(Clone, Debug, PartialEq, Eq)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTs {
        pub ticker: polymesh_primitives::ticker::Ticker,
        pub ids: ::alloc::vec::Vec<polymesh_primitives::nft::NFTId>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadAllocate))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTId(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct NFTCollectionId(pub u64);
    }
    pub mod compliance_manager {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetCompliance {
        pub paused: bool,
        pub requirements:
          ::alloc::vec::Vec<polymesh_primitives::compliance_manager::ComplianceRequirement>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ComplianceRequirement {
        pub sender_conditions: ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
        pub receiver_conditions: ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
        pub id: u32,
      }
    }
    pub mod identity {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DidRecord<AccountId> {
        pub primary_key: Option<AccountId>,
      }
    }
    pub mod document {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DocumentUri(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DocumentName(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DocumentId(pub u32);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Document {
        pub uri: polymesh_primitives::document::DocumentUri,
        pub content_hash: polymesh_primitives::document_hash::DocumentHash,
        pub name: polymesh_primitives::document::DocumentName,
        pub doc_type: Option<polymesh_primitives::document::DocumentType>,
        pub filing_date: Option<u64>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DocumentType(pub ::alloc::vec::Vec<u8>);
    }
    pub mod document_hash {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum DocumentHash {
        #[codec(index = 0u8)]
        None,
        #[codec(index = 1u8)]
        H512(
          #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))] [u8; 64usize],
        ),
        #[codec(index = 2u8)]
        H384(
          #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))] [u8; 48usize],
        ),
        #[codec(index = 3u8)]
        H320(
          #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))] [u8; 40usize],
        ),
        #[codec(index = 4u8)]
        H256([u8; 32usize]),
        #[codec(index = 5u8)]
        H224([u8; 28usize]),
        #[codec(index = 6u8)]
        H192([u8; 24usize]),
        #[codec(index = 7u8)]
        H160([u8; 20usize]),
        #[codec(index = 8u8)]
        H128([u8; 16usize]),
      }
    }
    pub mod asset_metadata {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataSpec {
        pub url: Option<polymesh_primitives::Url>,
        pub description: Option<polymesh_primitives::asset_metadata::AssetMetadataDescription>,
        pub type_def: Option<::alloc::vec::Vec<u8>>,
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataGlobalKey(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataName(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataValue(pub ::alloc::vec::Vec<u8>);
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataLocalKey(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataDescription(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AssetMetadataLockStatus<Moment> {
        #[codec(index = 0u8)]
        Unlocked,
        #[codec(index = 1u8)]
        Locked,
        #[codec(index = 2u8)]
        LockedUntil(Moment),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetMetadataValueDetail<Moment> {
        pub expire: Option<Moment>,
        pub lock_status: polymesh_primitives::asset_metadata::AssetMetadataLockStatus<Moment>,
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AssetMetadataKey {
        #[codec(index = 0u8)]
        Global(polymesh_primitives::asset_metadata::AssetMetadataGlobalKey),
        #[codec(index = 1u8)]
        Local(polymesh_primitives::asset_metadata::AssetMetadataLocalKey),
      }
    }
    pub mod jurisdiction {
      use super::*;
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CountryCode {
        #[codec(index = 0u8)]
        AF,
        #[codec(index = 1u8)]
        AX,
        #[codec(index = 2u8)]
        AL,
        #[codec(index = 3u8)]
        DZ,
        #[codec(index = 4u8)]
        AS,
        #[codec(index = 5u8)]
        AD,
        #[codec(index = 6u8)]
        AO,
        #[codec(index = 7u8)]
        AI,
        #[codec(index = 8u8)]
        AQ,
        #[codec(index = 9u8)]
        AG,
        #[codec(index = 10u8)]
        AR,
        #[codec(index = 11u8)]
        AM,
        #[codec(index = 12u8)]
        AW,
        #[codec(index = 13u8)]
        AU,
        #[codec(index = 14u8)]
        AT,
        #[codec(index = 15u8)]
        AZ,
        #[codec(index = 16u8)]
        BS,
        #[codec(index = 17u8)]
        BH,
        #[codec(index = 18u8)]
        BD,
        #[codec(index = 19u8)]
        BB,
        #[codec(index = 20u8)]
        BY,
        #[codec(index = 21u8)]
        BE,
        #[codec(index = 22u8)]
        BZ,
        #[codec(index = 23u8)]
        BJ,
        #[codec(index = 24u8)]
        BM,
        #[codec(index = 25u8)]
        BT,
        #[codec(index = 26u8)]
        BO,
        #[codec(index = 27u8)]
        BA,
        #[codec(index = 28u8)]
        BW,
        #[codec(index = 29u8)]
        BV,
        #[codec(index = 30u8)]
        BR,
        #[codec(index = 31u8)]
        VG,
        #[codec(index = 32u8)]
        IO,
        #[codec(index = 33u8)]
        BN,
        #[codec(index = 34u8)]
        BG,
        #[codec(index = 35u8)]
        BF,
        #[codec(index = 36u8)]
        BI,
        #[codec(index = 37u8)]
        KH,
        #[codec(index = 38u8)]
        CM,
        #[codec(index = 39u8)]
        CA,
        #[codec(index = 40u8)]
        CV,
        #[codec(index = 41u8)]
        KY,
        #[codec(index = 42u8)]
        CF,
        #[codec(index = 43u8)]
        TD,
        #[codec(index = 44u8)]
        CL,
        #[codec(index = 45u8)]
        CN,
        #[codec(index = 46u8)]
        HK,
        #[codec(index = 47u8)]
        MO,
        #[codec(index = 48u8)]
        CX,
        #[codec(index = 49u8)]
        CC,
        #[codec(index = 50u8)]
        CO,
        #[codec(index = 51u8)]
        KM,
        #[codec(index = 52u8)]
        CG,
        #[codec(index = 53u8)]
        CD,
        #[codec(index = 54u8)]
        CK,
        #[codec(index = 55u8)]
        CR,
        #[codec(index = 56u8)]
        CI,
        #[codec(index = 57u8)]
        HR,
        #[codec(index = 58u8)]
        CU,
        #[codec(index = 59u8)]
        CY,
        #[codec(index = 60u8)]
        CZ,
        #[codec(index = 61u8)]
        DK,
        #[codec(index = 62u8)]
        DJ,
        #[codec(index = 63u8)]
        DM,
        #[codec(index = 64u8)]
        DO,
        #[codec(index = 65u8)]
        EC,
        #[codec(index = 66u8)]
        EG,
        #[codec(index = 67u8)]
        SV,
        #[codec(index = 68u8)]
        GQ,
        #[codec(index = 69u8)]
        ER,
        #[codec(index = 70u8)]
        EE,
        #[codec(index = 71u8)]
        ET,
        #[codec(index = 72u8)]
        FK,
        #[codec(index = 73u8)]
        FO,
        #[codec(index = 74u8)]
        FJ,
        #[codec(index = 75u8)]
        FI,
        #[codec(index = 76u8)]
        FR,
        #[codec(index = 77u8)]
        GF,
        #[codec(index = 78u8)]
        PF,
        #[codec(index = 79u8)]
        TF,
        #[codec(index = 80u8)]
        GA,
        #[codec(index = 81u8)]
        GM,
        #[codec(index = 82u8)]
        GE,
        #[codec(index = 83u8)]
        DE,
        #[codec(index = 84u8)]
        GH,
        #[codec(index = 85u8)]
        GI,
        #[codec(index = 86u8)]
        GR,
        #[codec(index = 87u8)]
        GL,
        #[codec(index = 88u8)]
        GD,
        #[codec(index = 89u8)]
        GP,
        #[codec(index = 90u8)]
        GU,
        #[codec(index = 91u8)]
        GT,
        #[codec(index = 92u8)]
        GG,
        #[codec(index = 93u8)]
        GN,
        #[codec(index = 94u8)]
        GW,
        #[codec(index = 95u8)]
        GY,
        #[codec(index = 96u8)]
        HT,
        #[codec(index = 97u8)]
        HM,
        #[codec(index = 98u8)]
        VA,
        #[codec(index = 99u8)]
        HN,
        #[codec(index = 100u8)]
        HU,
        #[codec(index = 101u8)]
        IS,
        #[codec(index = 102u8)]
        IN,
        #[codec(index = 103u8)]
        ID,
        #[codec(index = 104u8)]
        IR,
        #[codec(index = 105u8)]
        IQ,
        #[codec(index = 106u8)]
        IE,
        #[codec(index = 107u8)]
        IM,
        #[codec(index = 108u8)]
        IL,
        #[codec(index = 109u8)]
        IT,
        #[codec(index = 110u8)]
        JM,
        #[codec(index = 111u8)]
        JP,
        #[codec(index = 112u8)]
        JE,
        #[codec(index = 113u8)]
        JO,
        #[codec(index = 114u8)]
        KZ,
        #[codec(index = 115u8)]
        KE,
        #[codec(index = 116u8)]
        KI,
        #[codec(index = 117u8)]
        KP,
        #[codec(index = 118u8)]
        KR,
        #[codec(index = 119u8)]
        KW,
        #[codec(index = 120u8)]
        KG,
        #[codec(index = 121u8)]
        LA,
        #[codec(index = 122u8)]
        LV,
        #[codec(index = 123u8)]
        LB,
        #[codec(index = 124u8)]
        LS,
        #[codec(index = 125u8)]
        LR,
        #[codec(index = 126u8)]
        LY,
        #[codec(index = 127u8)]
        LI,
        #[codec(index = 128u8)]
        LT,
        #[codec(index = 129u8)]
        LU,
        #[codec(index = 130u8)]
        MK,
        #[codec(index = 131u8)]
        MG,
        #[codec(index = 132u8)]
        MW,
        #[codec(index = 133u8)]
        MY,
        #[codec(index = 134u8)]
        MV,
        #[codec(index = 135u8)]
        ML,
        #[codec(index = 136u8)]
        MT,
        #[codec(index = 137u8)]
        MH,
        #[codec(index = 138u8)]
        MQ,
        #[codec(index = 139u8)]
        MR,
        #[codec(index = 140u8)]
        MU,
        #[codec(index = 141u8)]
        YT,
        #[codec(index = 142u8)]
        MX,
        #[codec(index = 143u8)]
        FM,
        #[codec(index = 144u8)]
        MD,
        #[codec(index = 145u8)]
        MC,
        #[codec(index = 146u8)]
        MN,
        #[codec(index = 147u8)]
        ME,
        #[codec(index = 148u8)]
        MS,
        #[codec(index = 149u8)]
        MA,
        #[codec(index = 150u8)]
        MZ,
        #[codec(index = 151u8)]
        MM,
        #[codec(index = 152u8)]
        NA,
        #[codec(index = 153u8)]
        NR,
        #[codec(index = 154u8)]
        NP,
        #[codec(index = 155u8)]
        NL,
        #[codec(index = 156u8)]
        AN,
        #[codec(index = 157u8)]
        NC,
        #[codec(index = 158u8)]
        NZ,
        #[codec(index = 159u8)]
        NI,
        #[codec(index = 160u8)]
        NE,
        #[codec(index = 161u8)]
        NG,
        #[codec(index = 162u8)]
        NU,
        #[codec(index = 163u8)]
        NF,
        #[codec(index = 164u8)]
        MP,
        #[codec(index = 165u8)]
        NO,
        #[codec(index = 166u8)]
        OM,
        #[codec(index = 167u8)]
        PK,
        #[codec(index = 168u8)]
        PW,
        #[codec(index = 169u8)]
        PS,
        #[codec(index = 170u8)]
        PA,
        #[codec(index = 171u8)]
        PG,
        #[codec(index = 172u8)]
        PY,
        #[codec(index = 173u8)]
        PE,
        #[codec(index = 174u8)]
        PH,
        #[codec(index = 175u8)]
        PN,
        #[codec(index = 176u8)]
        PL,
        #[codec(index = 177u8)]
        PT,
        #[codec(index = 178u8)]
        PR,
        #[codec(index = 179u8)]
        QA,
        #[codec(index = 180u8)]
        RE,
        #[codec(index = 181u8)]
        RO,
        #[codec(index = 182u8)]
        RU,
        #[codec(index = 183u8)]
        RW,
        #[codec(index = 184u8)]
        BL,
        #[codec(index = 185u8)]
        SH,
        #[codec(index = 186u8)]
        KN,
        #[codec(index = 187u8)]
        LC,
        #[codec(index = 188u8)]
        MF,
        #[codec(index = 189u8)]
        PM,
        #[codec(index = 190u8)]
        VC,
        #[codec(index = 191u8)]
        WS,
        #[codec(index = 192u8)]
        SM,
        #[codec(index = 193u8)]
        ST,
        #[codec(index = 194u8)]
        SA,
        #[codec(index = 195u8)]
        SN,
        #[codec(index = 196u8)]
        RS,
        #[codec(index = 197u8)]
        SC,
        #[codec(index = 198u8)]
        SL,
        #[codec(index = 199u8)]
        SG,
        #[codec(index = 200u8)]
        SK,
        #[codec(index = 201u8)]
        SI,
        #[codec(index = 202u8)]
        SB,
        #[codec(index = 203u8)]
        SO,
        #[codec(index = 204u8)]
        ZA,
        #[codec(index = 205u8)]
        GS,
        #[codec(index = 206u8)]
        SS,
        #[codec(index = 207u8)]
        ES,
        #[codec(index = 208u8)]
        LK,
        #[codec(index = 209u8)]
        SD,
        #[codec(index = 210u8)]
        SR,
        #[codec(index = 211u8)]
        SJ,
        #[codec(index = 212u8)]
        SZ,
        #[codec(index = 213u8)]
        SE,
        #[codec(index = 214u8)]
        CH,
        #[codec(index = 215u8)]
        SY,
        #[codec(index = 216u8)]
        TW,
        #[codec(index = 217u8)]
        TJ,
        #[codec(index = 218u8)]
        TZ,
        #[codec(index = 219u8)]
        TH,
        #[codec(index = 220u8)]
        TL,
        #[codec(index = 221u8)]
        TG,
        #[codec(index = 222u8)]
        TK,
        #[codec(index = 223u8)]
        TO,
        #[codec(index = 224u8)]
        TT,
        #[codec(index = 225u8)]
        TN,
        #[codec(index = 226u8)]
        TR,
        #[codec(index = 227u8)]
        TM,
        #[codec(index = 228u8)]
        TC,
        #[codec(index = 229u8)]
        TV,
        #[codec(index = 230u8)]
        UG,
        #[codec(index = 231u8)]
        UA,
        #[codec(index = 232u8)]
        AE,
        #[codec(index = 233u8)]
        GB,
        #[codec(index = 234u8)]
        US,
        #[codec(index = 235u8)]
        UM,
        #[codec(index = 236u8)]
        UY,
        #[codec(index = 237u8)]
        UZ,
        #[codec(index = 238u8)]
        VU,
        #[codec(index = 239u8)]
        VE,
        #[codec(index = 240u8)]
        VN,
        #[codec(index = 241u8)]
        VI,
        #[codec(index = 242u8)]
        WF,
        #[codec(index = 243u8)]
        EH,
        #[codec(index = 244u8)]
        YE,
        #[codec(index = 245u8)]
        ZM,
        #[codec(index = 246u8)]
        ZW,
        #[codec(index = 247u8)]
        BQ,
        #[codec(index = 248u8)]
        CW,
        #[codec(index = 249u8)]
        SX,
      }
    }
    pub mod asset_identifier {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AssetIdentifier {
        #[codec(index = 0u8)]
        CUSIP([u8; 9usize]),
        #[codec(index = 1u8)]
        CINS([u8; 9usize]),
        #[codec(index = 2u8)]
        ISIN([u8; 12usize]),
        #[codec(index = 3u8)]
        LEI([u8; 20usize]),
        #[codec(index = 4u8)]
        FIGI([u8; 12usize]),
      }
    }
    pub mod ticker {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy, Default)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadAllocate))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Ticker(pub [u8; 12usize]);
    }
    pub mod settlement {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Leg {
        #[codec(index = 0u8)]
        Fungible {
          sender: polymesh_primitives::identity_id::PortfolioId,
          receiver: polymesh_primitives::identity_id::PortfolioId,
          ticker: polymesh_primitives::ticker::Ticker,
          amount: u128,
        },
        #[codec(index = 1u8)]
        NonFungible {
          sender: polymesh_primitives::identity_id::PortfolioId,
          receiver: polymesh_primitives::identity_id::PortfolioId,
          nfts: polymesh_primitives::nft::NFTs,
        },
        #[codec(index = 2u8)]
        OffChain {
          sender_identity: ::polymesh_api_client::IdentityId,
          receiver_identity: ::polymesh_api_client::IdentityId,
          ticker: polymesh_primitives::ticker::Ticker,
          amount: u128,
        },
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ReceiptMetadata(pub [u8; 32usize]);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Instruction<Moment, BlockNumber> {
        pub instruction_id: polymesh_primitives::settlement::InstructionId,
        pub venue_id: polymesh_primitives::settlement::VenueId,
        pub settlement_type: polymesh_primitives::settlement::SettlementType<BlockNumber>,
        pub created_at: Option<Moment>,
        pub trade_date: Option<Moment>,
        pub value_date: Option<Moment>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadAllocate))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct LegId(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadAllocate))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct VenueId(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum VenueType {
        #[codec(index = 0u8)]
        Other,
        #[codec(index = 1u8)]
        Distribution,
        #[codec(index = 2u8)]
        Sto,
        #[codec(index = 3u8)]
        Exchange,
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum LegStatus<AccountId> {
        #[codec(index = 0u8)]
        PendingTokenLock,
        #[codec(index = 1u8)]
        ExecutionPending,
        #[codec(index = 2u8)]
        ExecutionToBeSkipped(AccountId, u64),
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum InstructionStatus<BlockNumber> {
        #[codec(index = 0u8)]
        Unknown,
        #[codec(index = 1u8)]
        Pending,
        #[codec(index = 2u8)]
        Failed,
        #[codec(index = 3u8)]
        Success(BlockNumber),
        #[codec(index = 4u8)]
        Rejected(BlockNumber),
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SettlementType<BlockNumber> {
        #[codec(index = 0u8)]
        SettleOnAffirmation,
        #[codec(index = 1u8)]
        SettleOnBlock(BlockNumber),
        #[codec(index = 2u8)]
        SettleManual(BlockNumber),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ReceiptDetails<AccountId, OffChainSignature> {
        pub uid: u64,
        pub instruction_id: polymesh_primitives::settlement::InstructionId,
        pub leg_id: polymesh_primitives::settlement::LegId,
        pub signer: AccountId,
        pub signature: OffChainSignature,
        pub metadata: Option<polymesh_primitives::settlement::ReceiptMetadata>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadAllocate))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct InstructionId(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, Default)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadAllocate))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct VenueDetails(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Venue {
        pub creator: ::polymesh_api_client::IdentityId,
        pub venue_type: polymesh_primitives::settlement::VenueType,
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AffirmationStatus {
        #[codec(index = 0u8)]
        Unknown,
        #[codec(index = 1u8)]
        Pending,
        #[codec(index = 2u8)]
        Affirmed,
      }
    }
    pub mod transfer_compliance {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct TransferConditionExemptKey {
        pub asset: polymesh_primitives::statistics::AssetScope,
        pub op: polymesh_primitives::statistics::StatOpType,
        pub claim_type: Option<polymesh_primitives::identity_claim::ClaimType>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetTransferCompliance {
        pub paused: bool,
        pub requirements: bounded_collections::bounded_btree_set::BoundedBTreeSet<
          polymesh_primitives::transfer_compliance::TransferCondition,
        >,
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum TransferCondition {
        #[codec(index = 0u8)]
        MaxInvestorCount(u64),
        #[codec(index = 1u8)]
        MaxInvestorOwnership(::polymesh_api_client::per_things::Permill),
        #[codec(index = 2u8)]
        ClaimCount(
          polymesh_primitives::statistics::StatClaim,
          ::polymesh_api_client::IdentityId,
          u64,
          Option<u64>,
        ),
        #[codec(index = 3u8)]
        ClaimOwnership(
          polymesh_primitives::statistics::StatClaim,
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::per_things::Permill,
          ::polymesh_api_client::per_things::Permill,
        ),
      }
    }
    pub mod secondary_key {
      use super::*;
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PalletPermissions {
        pub pallet_name: polymesh_primitives::PalletName,
        pub dispatchable_names:
          polymesh_primitives::subset::SubsetRestriction<polymesh_primitives::DispatchableName>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Signatory<AccountId> {
        #[codec(index = 0u8)]
        Identity(::polymesh_api_client::IdentityId),
        #[codec(index = 1u8)]
        Account(AccountId),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Permissions {
        pub asset:
          polymesh_primitives::subset::SubsetRestriction<polymesh_primitives::ticker::Ticker>,
        pub extrinsic: polymesh_primitives::subset::SubsetRestriction<
          polymesh_primitives::secondary_key::PalletPermissions,
        >,
        pub portfolio: polymesh_primitives::subset::SubsetRestriction<
          polymesh_primitives::identity_id::PortfolioId,
        >,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SecondaryKey<AccountId> {
        pub key: AccountId,
        pub permissions: polymesh_primitives::secondary_key::Permissions,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum KeyRecord<AccountId> {
        #[codec(index = 0u8)]
        PrimaryKey(::polymesh_api_client::IdentityId),
        #[codec(index = 1u8)]
        SecondaryKey(
          ::polymesh_api_client::IdentityId,
          polymesh_primitives::secondary_key::Permissions,
        ),
        #[codec(index = 2u8)]
        MultiSigSignerKey(AccountId),
      }
    }
    pub mod subset {
      use super::*;
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SubsetRestriction<A: Ord> {
        #[codec(index = 0u8)]
        Whole,
        #[codec(index = 1u8)]
        These(::alloc::collections::BTreeSet<A>),
        #[codec(index = 2u8)]
        Except(::alloc::collections::BTreeSet<A>),
      }
    }
    pub mod authorization {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Authorization<AccountId, Moment> {
        pub authorization_data: polymesh_primitives::authorization::AuthorizationData<AccountId>,
        pub authorized_by: ::polymesh_api_client::IdentityId,
        pub expiry: Option<Moment>,
        pub auth_id: Moment,
        pub count: u32,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AuthorizationData<AccountId> {
        #[codec(index = 0u8)]
        AttestPrimaryKeyRotation(::polymesh_api_client::IdentityId),
        #[codec(index = 1u8)]
        RotatePrimaryKey,
        #[codec(index = 2u8)]
        TransferTicker(polymesh_primitives::ticker::Ticker),
        #[codec(index = 3u8)]
        AddMultiSigSigner(AccountId),
        #[codec(index = 4u8)]
        TransferAssetOwnership(polymesh_primitives::ticker::Ticker),
        #[codec(index = 5u8)]
        JoinIdentity(polymesh_primitives::secondary_key::Permissions),
        #[codec(index = 6u8)]
        PortfolioCustody(polymesh_primitives::identity_id::PortfolioId),
        #[codec(index = 7u8)]
        BecomeAgent(
          polymesh_primitives::ticker::Ticker,
          polymesh_primitives::agent::AgentGroup,
        ),
        #[codec(index = 8u8)]
        AddRelayerPayingKey(AccountId, AccountId, u128),
        #[codec(index = 9u8)]
        RotatePrimaryKeyToSecondary(polymesh_primitives::secondary_key::Permissions),
      }
    }
    pub mod identity_claim {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Claim {
        #[codec(index = 0u8)]
        Accredited(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 1u8)]
        Affiliate(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 2u8)]
        BuyLockup(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 3u8)]
        SellLockup(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 4u8)]
        CustomerDueDiligence(polymesh_primitives::cdd_id::CddId),
        #[codec(index = 5u8)]
        KnowYourCustomer(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 6u8)]
        Jurisdiction(
          polymesh_primitives::jurisdiction::CountryCode,
          polymesh_primitives::identity_claim::Scope,
        ),
        #[codec(index = 7u8)]
        Exempted(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 8u8)]
        Blocked(polymesh_primitives::identity_claim::Scope),
        #[codec(index = 9u8)]
        Custom(
          polymesh_primitives::identity_claim::CustomClaimTypeId,
          Option<polymesh_primitives::identity_claim::Scope>,
        ),
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct IdentityClaim {
        pub claim_issuer: ::polymesh_api_client::IdentityId,
        pub issuance_date: u64,
        pub last_update_date: u64,
        pub expiry: Option<u64>,
        pub claim: polymesh_primitives::identity_claim::Claim,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Scope {
        #[codec(index = 0u8)]
        Identity(::polymesh_api_client::IdentityId),
        #[codec(index = 1u8)]
        Ticker(polymesh_primitives::ticker::Ticker),
        #[codec(index = 2u8)]
        Custom(::alloc::vec::Vec<u8>),
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct CustomClaimTypeId(pub u32);
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ClaimType {
        #[codec(index = 0u8)]
        Accredited,
        #[codec(index = 1u8)]
        Affiliate,
        #[codec(index = 2u8)]
        BuyLockup,
        #[codec(index = 3u8)]
        SellLockup,
        #[codec(index = 4u8)]
        CustomerDueDiligence,
        #[codec(index = 5u8)]
        KnowYourCustomer,
        #[codec(index = 6u8)]
        Jurisdiction,
        #[codec(index = 7u8)]
        Exempted,
        #[codec(index = 8u8)]
        Blocked,
        #[codec(index = 9u8)]
        Custom(polymesh_primitives::identity_claim::CustomClaimTypeId),
      }
    }
    pub mod agent {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AgentGroup {
        #[codec(index = 0u8)]
        Full,
        #[codec(index = 1u8)]
        Custom(polymesh_primitives::agent::AGId),
        #[codec(index = 2u8)]
        ExceptMeta,
        #[codec(index = 3u8)]
        PolymeshV1CAA,
        #[codec(index = 4u8)]
        PolymeshV1PIA,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AGId(pub u32);
    }
    pub mod identity_id {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PortfolioId {
        pub did: ::polymesh_api_client::IdentityId,
        pub kind: polymesh_primitives::identity_id::PortfolioKind,
      }
      #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy, Default)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadAllocate))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PortfolioNumber(pub u64);
      #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PortfolioKind {
        #[codec(index = 0u8)]
        Default,
        #[codec(index = 1u8)]
        User(polymesh_primitives::identity_id::PortfolioNumber),
      }
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct IdentityId(pub [u8; 32usize]);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PortfolioName(pub ::alloc::vec::Vec<u8>);
    }
    pub mod asset {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, Default)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadAllocate))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct FundingRoundName(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadAllocate))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct CustomAssetTypeId(pub u32);
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum AssetType {
        #[codec(index = 0u8)]
        EquityCommon,
        #[codec(index = 1u8)]
        EquityPreferred,
        #[codec(index = 2u8)]
        Commodity,
        #[codec(index = 3u8)]
        FixedIncome,
        #[codec(index = 4u8)]
        REIT,
        #[codec(index = 5u8)]
        Fund,
        #[codec(index = 6u8)]
        RevenueShareAgreement,
        #[codec(index = 7u8)]
        StructuredProduct,
        #[codec(index = 8u8)]
        Derivative,
        #[codec(index = 9u8)]
        Custom(polymesh_primitives::asset::CustomAssetTypeId),
        #[codec(index = 10u8)]
        StableCoin,
        #[codec(index = 11u8)]
        NonFungible(polymesh_primitives::asset::NonFungibleType),
      }
      #[derive(Clone, Debug, PartialEq, Eq, Copy)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum NonFungibleType {
        #[codec(index = 0u8)]
        Derivative,
        #[codec(index = 1u8)]
        FixedIncome,
        #[codec(index = 2u8)]
        Invoice,
        #[codec(index = 3u8)]
        Custom(polymesh_primitives::asset::CustomAssetTypeId),
      }
      #[derive(Clone, Debug, PartialEq, Eq, Default)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadAllocate))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AssetName(pub ::alloc::vec::Vec<u8>);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct CheckpointId(pub u64);
    }
    pub mod portfolio {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Fund {
        pub description: polymesh_primitives::portfolio::FundDescription,
        pub memo: Option<polymesh_primitives::Memo>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PortfolioUpdateReason {
        #[codec(index = 0u8)]
        Issued {
          funding_round_name: Option<polymesh_primitives::asset::FundingRoundName>,
        },
        #[codec(index = 1u8)]
        Redeemed,
        #[codec(index = 2u8)]
        Transferred {
          instruction_id: Option<polymesh_primitives::settlement::InstructionId>,
          instruction_memo: Option<polymesh_primitives::Memo>,
        },
      }
      #[derive(Clone, Debug, PartialEq, Eq)]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
      #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
      #[cfg_attr(
        all(feature = "ink", feature = "std"),
        derive(::ink_storage::traits::StorageLayout)
      )]
      #[derive(:: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum FundDescription {
        #[codec(index = 0u8)]
        Fungible {
          ticker: polymesh_primitives::ticker::Ticker,
          amount: u128,
        },
        #[codec(index = 1u8)]
        NonFungible(polymesh_primitives::nft::NFTs),
      }
    }
    #[derive(
      Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
    )]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PalletName(pub ::alloc::vec::Vec<u8>);
    #[derive(Clone, Debug, PartialEq, Eq)]
    #[cfg_attr(feature = "ink", derive(::ink_storage::traits::SpreadLayout))]
    #[cfg_attr(feature = "ink", derive(::ink_storage::traits::PackedLayout))]
    #[cfg_attr(
      all(feature = "ink", feature = "std"),
      derive(::ink_storage::traits::StorageLayout)
    )]
    #[derive(:: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Memo(pub [u8; 32usize]);
    #[derive(
      Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
    )]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct DispatchableName(pub ::alloc::vec::Vec<u8>);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Url(pub ::alloc::vec::Vec<u8>);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PosRatio(pub u32, pub u32);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Beneficiary<Balance> {
      pub id: ::polymesh_api_client::IdentityId,
      pub amount: Balance,
    }
  }
  pub mod bounded_collections {
    use super::*;
    pub mod weak_bounded_vec {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct WeakBoundedVec<T>(pub ::alloc::vec::Vec<T>);
    }
    pub mod bounded_vec {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BoundedVec<T>(pub ::alloc::vec::Vec<T>);
    }
    pub mod bounded_btree_set {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BoundedBTreeSet<T: Ord>(pub ::alloc::collections::BTreeSet<T>);
    }
  }
  pub mod pallet_group {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance1();
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum UpgradeCommitteeMembershipCall {
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[codec(index = 0u8)]
      set_active_members_limit { limit: u32 },
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[codec(index = 1u8)]
      disable_member {
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      },
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[codec(index = 2u8)]
      add_member {
        who: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[codec(index = 3u8)]
      remove_member {
        who: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[codec(index = 4u8)]
      swap_member {
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[codec(index = 5u8)]
      reset_members {
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      },
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[codec(index = 6u8)]
      abdicate_membership,
    }
    impl UpgradeCommitteeMembershipCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_active_members_limit { .. } => {
            "UpgradeCommitteeMembership.set_active_members_limit"
          }
          Self::disable_member { .. } => "UpgradeCommitteeMembership.disable_member",
          Self::add_member { .. } => "UpgradeCommitteeMembership.add_member",
          Self::remove_member { .. } => "UpgradeCommitteeMembership.remove_member",
          Self::swap_member { .. } => "UpgradeCommitteeMembership.swap_member",
          Self::reset_members { .. } => "UpgradeCommitteeMembership.reset_members",
          Self::abdicate_membership => "UpgradeCommitteeMembership.abdicate_membership",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeMembershipCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_active_members_limit { .. } => { & ["Change this group's limit for how many concurrent active members they may be." , "" , "# Arguments" , "* `limit` - the number of active members there may be concurrently." ,] } , Self :: disable_member { .. } => { & ["Disables a member at specific moment." , "" , "Please note that if member is already revoked (a \"valid member\"), its revocation" , "time-stamp will be updated." , "" , "Any disabled member should NOT allow to act like an active member of the group. For" , "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any" , "generated claim issued before `at` would be considered as a valid one." , "" , "If you want to invalidate any generated claim, you should use `Self::remove_member`." , "" , "# Arguments" , "* `at` - Revocation time-stamp." , "* `who` - Target member of the group." , "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the" , "generated claims will be \"invalid\" as `who` is not considered a member of the group." ,] } , Self :: add_member { .. } => { & ["Adds a member `who` to the group. May only be called from `AddOrigin` or root." , "" , "# Arguments" , "* `origin` - Origin representing `AddOrigin` or root" , "* `who` - IdentityId to be added to the group." ,] } , Self :: remove_member { .. } => { & ["Removes a member `who` from the set. May only be called from `RemoveOrigin` or root." , "" , "Any claim previously generated by this member is not valid as a group claim. For" , "instance, if a CDD member group generated a claim for a target identity and then it is" , "removed, that claim will be invalid.  In case you want to keep the validity of generated" , "claims, you have to use `Self::disable_member` function" , "" , "# Arguments" , "* `origin` - Origin representing `RemoveOrigin` or root" , "* `who` - IdentityId to be removed from the group." ,] } , Self :: swap_member { .. } => { & ["Swaps out one member `remove` for another member `add`." , "" , "May only be called from `SwapOrigin` or root." , "" , "# Arguments" , "* `origin` - Origin representing `SwapOrigin` or root" , "* `remove` - IdentityId to be removed from the group." , "* `add` - IdentityId to be added in place of `remove`." ,] } , Self :: reset_members { .. } => { & ["Changes the membership to a new set, disregarding the existing membership." , "May only be called from `ResetOrigin` or root." , "" , "# Arguments" , "* `origin` - Origin representing `ResetOrigin` or root" , "* `members` - New set of identities" ,] } , Self :: abdicate_membership => { & ["Allows the calling member to *unilaterally quit* without this being subject to a GC" , "vote." , "" , "# Arguments" , "* `origin` - Member of committee who wants to quit." , "" , "# Error" , "" , "* Only primary key can abdicate." , "* Last member of a group cannot abdicate." ,] } , _ => & [""] , }
      }
    }
    impl From<UpgradeCommitteeMembershipCall> for &'static str {
      fn from(v: UpgradeCommitteeMembershipCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&UpgradeCommitteeMembershipCall> for &'static str {
      fn from(v: &UpgradeCommitteeMembershipCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance4();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum UpgradeCommitteeMembershipError {
      #[doc = "Only primary key of the identity is allowed."]
      #[codec(index = 0u8)]
      OnlyPrimaryKeyAllowed,
      #[doc = "Group member was added already."]
      #[codec(index = 1u8)]
      DuplicateMember,
      #[doc = "Can't remove a member that doesn't exist."]
      #[codec(index = 2u8)]
      NoSuchMember,
      #[doc = "Last member of the committee can not quit."]
      #[codec(index = 3u8)]
      LastMemberCannotQuit,
      #[doc = "Missing current DID"]
      #[codec(index = 4u8)]
      MissingCurrentIdentity,
      #[doc = "The limit for the number of concurrent active members for this group has been exceeded."]
      #[codec(index = 5u8)]
      ActiveMembersLimitExceeded,
      #[doc = "Active member limit was greater than maximum committee members limit."]
      #[codec(index = 6u8)]
      ActiveMembersLimitOverflow,
    }
    impl UpgradeCommitteeMembershipError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::OnlyPrimaryKeyAllowed => "UpgradeCommitteeMembership.OnlyPrimaryKeyAllowed",
          Self::DuplicateMember => "UpgradeCommitteeMembership.DuplicateMember",
          Self::NoSuchMember => "UpgradeCommitteeMembership.NoSuchMember",
          Self::LastMemberCannotQuit => "UpgradeCommitteeMembership.LastMemberCannotQuit",
          Self::MissingCurrentIdentity => "UpgradeCommitteeMembership.MissingCurrentIdentity",
          Self::ActiveMembersLimitExceeded => {
            "UpgradeCommitteeMembership.ActiveMembersLimitExceeded"
          }
          Self::ActiveMembersLimitOverflow => {
            "UpgradeCommitteeMembership.ActiveMembersLimitOverflow"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeMembershipError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: OnlyPrimaryKeyAllowed => { & ["Only primary key of the identity is allowed." ,] } , Self :: DuplicateMember => { & ["Group member was added already." ,] } , Self :: NoSuchMember => { & ["Can't remove a member that doesn't exist." ,] } , Self :: LastMemberCannotQuit => { & ["Last member of the committee can not quit." ,] } , Self :: MissingCurrentIdentity => { & ["Missing current DID" ,] } , Self :: ActiveMembersLimitExceeded => { & ["The limit for the number of concurrent active members for this group has been exceeded." ,] } , Self :: ActiveMembersLimitOverflow => { & ["Active member limit was greater than maximum committee members limit." ,] } , _ => & [""] , }
      }
    }
    impl From<UpgradeCommitteeMembershipError> for &'static str {
      fn from(v: UpgradeCommitteeMembershipError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&UpgradeCommitteeMembershipError> for &'static str {
      fn from(v: &UpgradeCommitteeMembershipError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance2();
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Instance3();
  }
  pub mod pallet_staking {
    use super::*;
    pub mod slashing {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SlashingSpans {
        pub span_index: u32,
        pub last_start: u32,
        pub last_nonzero_slash: u32,
        pub prior: ::alloc::vec::Vec<u32>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SpanRecord<Balance> {
        pub slashed: Balance,
        pub paid_out: Balance,
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ElectionCompute {
      #[codec(index = 0u8)]
      OnChain,
      #[codec(index = 1u8)]
      Signed,
      #[codec(index = 2u8)]
      Unsigned,
    }
    #[doc = "Error for the staking module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StakingError {
      #[doc = "Not a controller account."]
      #[codec(index = 0u8)]
      NotController,
      #[doc = "Not a stash account."]
      #[codec(index = 1u8)]
      NotStash,
      #[doc = "Stash is already bonded."]
      #[codec(index = 2u8)]
      AlreadyBonded,
      #[doc = "Controller is already paired."]
      #[codec(index = 3u8)]
      AlreadyPaired,
      #[doc = "Targets cannot be empty."]
      #[codec(index = 4u8)]
      EmptyTargets,
      #[doc = "Slash record index out of bounds."]
      #[codec(index = 5u8)]
      InvalidSlashIndex,
      #[doc = "Can not bond with value less than minimum balance."]
      #[codec(index = 6u8)]
      InsufficientValue,
      #[doc = "Can not schedule more unlock chunks."]
      #[codec(index = 7u8)]
      NoMoreChunks,
      #[doc = "Can not rebond without unlocking chunks."]
      #[codec(index = 8u8)]
      NoUnlockChunk,
      #[doc = "Attempting to target a stash that still has funds."]
      #[codec(index = 9u8)]
      FundedTarget,
      #[doc = "Invalid era to reward."]
      #[codec(index = 10u8)]
      InvalidEraToReward,
      #[doc = "Items are not sorted and unique."]
      #[codec(index = 11u8)]
      NotSortedAndUnique,
      #[doc = "Rewards for this era have already been claimed for this validator."]
      #[codec(index = 12u8)]
      AlreadyClaimed,
      #[doc = "The submitted result is received out of the open window."]
      #[codec(index = 13u8)]
      OffchainElectionEarlySubmission,
      #[doc = "The submitted result is not as good as the one stored on chain."]
      #[codec(index = 14u8)]
      OffchainElectionWeakSubmission,
      #[doc = "The snapshot data of the current window is missing."]
      #[codec(index = 15u8)]
      SnapshotUnavailable,
      #[doc = "Incorrect number of winners were presented."]
      #[codec(index = 16u8)]
      OffchainElectionBogusWinnerCount,
      #[doc = "One of the submitted winners is not an active candidate on chain (index is out of range"]
      #[doc = "in snapshot)."]
      #[codec(index = 17u8)]
      OffchainElectionBogusWinner,
      #[doc = "Error while building the assignment type from the compact. This can happen if an index"]
      #[doc = "is invalid, or if the weights _overflow_."]
      #[codec(index = 18u8)]
      OffchainElectionBogusCompact,
      #[doc = "One of the submitted nominators is not an active nominator on chain."]
      #[codec(index = 19u8)]
      OffchainElectionBogusNominator,
      #[doc = "One of the submitted nominators has an edge to which they have not voted on chain."]
      #[codec(index = 20u8)]
      OffchainElectionBogusNomination,
      #[doc = "One of the submitted nominators has an edge which is submitted before the last non-zero"]
      #[doc = "slash of the target."]
      #[codec(index = 21u8)]
      OffchainElectionSlashedNomination,
      #[doc = "A self vote must only be originated from a validator to ONLY themselves."]
      #[codec(index = 22u8)]
      OffchainElectionBogusSelfVote,
      #[doc = "The submitted result has unknown edges that are not among the presented winners."]
      #[codec(index = 23u8)]
      OffchainElectionBogusEdge,
      #[doc = "The claimed score does not match with the one computed from the data."]
      #[codec(index = 24u8)]
      OffchainElectionBogusScore,
      #[doc = "The election size is invalid."]
      #[codec(index = 25u8)]
      OffchainElectionBogusElectionSize,
      #[doc = "The call is not allowed at the given time due to restrictions of election period."]
      #[codec(index = 26u8)]
      CallNotAllowed,
      #[doc = "Incorrect number of slashing spans provided."]
      #[codec(index = 27u8)]
      IncorrectSlashingSpans,
      #[doc = "Permissioned validator already exists."]
      #[codec(index = 28u8)]
      AlreadyExists,
      #[doc = "Permissioned validator not exists."]
      #[codec(index = 29u8)]
      NotExists,
      #[doc = "Updates with same value."]
      #[codec(index = 30u8)]
      NoChange,
      #[doc = "Given potential validator identity is invalid."]
      #[codec(index = 31u8)]
      InvalidValidatorIdentity,
      #[doc = "Validator prefs are not in valid range."]
      #[codec(index = 32u8)]
      InvalidValidatorCommission,
      #[doc = "Validator or nominator stash identity does not exist."]
      #[codec(index = 33u8)]
      StashIdentityDoesNotExist,
      #[doc = "Validator stash identity was not permissioned."]
      #[codec(index = 34u8)]
      StashIdentityNotPermissioned,
      #[doc = "Nominator stash was not CDDed."]
      #[codec(index = 35u8)]
      StashIdentityNotCDDed,
      #[doc = "Running validator count hit the intended count."]
      #[codec(index = 36u8)]
      HitIntendedValidatorCount,
      #[doc = "When the intended number of validators to run is >= 2/3 of `validator_count`."]
      #[codec(index = 37u8)]
      IntendedCountIsExceedingConsensusLimit,
      #[doc = "When the amount to be bonded is less than `MinimumBond`"]
      #[codec(index = 38u8)]
      BondTooSmall,
      #[doc = "Internal state has become somehow corrupted and the operation cannot continue."]
      #[codec(index = 39u8)]
      BadState,
      #[doc = "Too many nomination targets supplied."]
      #[codec(index = 40u8)]
      TooManyTargets,
      #[doc = "A nomination target was supplied that was blocked or otherwise not a validator."]
      #[codec(index = 41u8)]
      BadTarget,
      #[doc = "Validator should have minimum 50k POLYX bonded."]
      #[codec(index = 42u8)]
      InvalidValidatorUnbondAmount,
    }
    impl StakingError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::NotController => "Staking.NotController",
          Self::NotStash => "Staking.NotStash",
          Self::AlreadyBonded => "Staking.AlreadyBonded",
          Self::AlreadyPaired => "Staking.AlreadyPaired",
          Self::EmptyTargets => "Staking.EmptyTargets",
          Self::InvalidSlashIndex => "Staking.InvalidSlashIndex",
          Self::InsufficientValue => "Staking.InsufficientValue",
          Self::NoMoreChunks => "Staking.NoMoreChunks",
          Self::NoUnlockChunk => "Staking.NoUnlockChunk",
          Self::FundedTarget => "Staking.FundedTarget",
          Self::InvalidEraToReward => "Staking.InvalidEraToReward",
          Self::NotSortedAndUnique => "Staking.NotSortedAndUnique",
          Self::AlreadyClaimed => "Staking.AlreadyClaimed",
          Self::OffchainElectionEarlySubmission => "Staking.OffchainElectionEarlySubmission",
          Self::OffchainElectionWeakSubmission => "Staking.OffchainElectionWeakSubmission",
          Self::SnapshotUnavailable => "Staking.SnapshotUnavailable",
          Self::OffchainElectionBogusWinnerCount => "Staking.OffchainElectionBogusWinnerCount",
          Self::OffchainElectionBogusWinner => "Staking.OffchainElectionBogusWinner",
          Self::OffchainElectionBogusCompact => "Staking.OffchainElectionBogusCompact",
          Self::OffchainElectionBogusNominator => "Staking.OffchainElectionBogusNominator",
          Self::OffchainElectionBogusNomination => "Staking.OffchainElectionBogusNomination",
          Self::OffchainElectionSlashedNomination => "Staking.OffchainElectionSlashedNomination",
          Self::OffchainElectionBogusSelfVote => "Staking.OffchainElectionBogusSelfVote",
          Self::OffchainElectionBogusEdge => "Staking.OffchainElectionBogusEdge",
          Self::OffchainElectionBogusScore => "Staking.OffchainElectionBogusScore",
          Self::OffchainElectionBogusElectionSize => "Staking.OffchainElectionBogusElectionSize",
          Self::CallNotAllowed => "Staking.CallNotAllowed",
          Self::IncorrectSlashingSpans => "Staking.IncorrectSlashingSpans",
          Self::AlreadyExists => "Staking.AlreadyExists",
          Self::NotExists => "Staking.NotExists",
          Self::NoChange => "Staking.NoChange",
          Self::InvalidValidatorIdentity => "Staking.InvalidValidatorIdentity",
          Self::InvalidValidatorCommission => "Staking.InvalidValidatorCommission",
          Self::StashIdentityDoesNotExist => "Staking.StashIdentityDoesNotExist",
          Self::StashIdentityNotPermissioned => "Staking.StashIdentityNotPermissioned",
          Self::StashIdentityNotCDDed => "Staking.StashIdentityNotCDDed",
          Self::HitIntendedValidatorCount => "Staking.HitIntendedValidatorCount",
          Self::IntendedCountIsExceedingConsensusLimit => {
            "Staking.IntendedCountIsExceedingConsensusLimit"
          }
          Self::BondTooSmall => "Staking.BondTooSmall",
          Self::BadState => "Staking.BadState",
          Self::TooManyTargets => "Staking.TooManyTargets",
          Self::BadTarget => "Staking.BadTarget",
          Self::InvalidValidatorUnbondAmount => "Staking.InvalidValidatorUnbondAmount",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for StakingError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: NotController => { & ["Not a controller account." ,] } , Self :: NotStash => { & ["Not a stash account." ,] } , Self :: AlreadyBonded => { & ["Stash is already bonded." ,] } , Self :: AlreadyPaired => { & ["Controller is already paired." ,] } , Self :: EmptyTargets => { & ["Targets cannot be empty." ,] } , Self :: InvalidSlashIndex => { & ["Slash record index out of bounds." ,] } , Self :: InsufficientValue => { & ["Can not bond with value less than minimum balance." ,] } , Self :: NoMoreChunks => { & ["Can not schedule more unlock chunks." ,] } , Self :: NoUnlockChunk => { & ["Can not rebond without unlocking chunks." ,] } , Self :: FundedTarget => { & ["Attempting to target a stash that still has funds." ,] } , Self :: InvalidEraToReward => { & ["Invalid era to reward." ,] } , Self :: NotSortedAndUnique => { & ["Items are not sorted and unique." ,] } , Self :: AlreadyClaimed => { & ["Rewards for this era have already been claimed for this validator." ,] } , Self :: OffchainElectionEarlySubmission => { & ["The submitted result is received out of the open window." ,] } , Self :: OffchainElectionWeakSubmission => { & ["The submitted result is not as good as the one stored on chain." ,] } , Self :: SnapshotUnavailable => { & ["The snapshot data of the current window is missing." ,] } , Self :: OffchainElectionBogusWinnerCount => { & ["Incorrect number of winners were presented." ,] } , Self :: OffchainElectionBogusWinner => { & ["One of the submitted winners is not an active candidate on chain (index is out of range" , "in snapshot)." ,] } , Self :: OffchainElectionBogusCompact => { & ["Error while building the assignment type from the compact. This can happen if an index" , "is invalid, or if the weights _overflow_." ,] } , Self :: OffchainElectionBogusNominator => { & ["One of the submitted nominators is not an active nominator on chain." ,] } , Self :: OffchainElectionBogusNomination => { & ["One of the submitted nominators has an edge to which they have not voted on chain." ,] } , Self :: OffchainElectionSlashedNomination => { & ["One of the submitted nominators has an edge which is submitted before the last non-zero" , "slash of the target." ,] } , Self :: OffchainElectionBogusSelfVote => { & ["A self vote must only be originated from a validator to ONLY themselves." ,] } , Self :: OffchainElectionBogusEdge => { & ["The submitted result has unknown edges that are not among the presented winners." ,] } , Self :: OffchainElectionBogusScore => { & ["The claimed score does not match with the one computed from the data." ,] } , Self :: OffchainElectionBogusElectionSize => { & ["The election size is invalid." ,] } , Self :: CallNotAllowed => { & ["The call is not allowed at the given time due to restrictions of election period." ,] } , Self :: IncorrectSlashingSpans => { & ["Incorrect number of slashing spans provided." ,] } , Self :: AlreadyExists => { & ["Permissioned validator already exists." ,] } , Self :: NotExists => { & ["Permissioned validator not exists." ,] } , Self :: NoChange => { & ["Updates with same value." ,] } , Self :: InvalidValidatorIdentity => { & ["Given potential validator identity is invalid." ,] } , Self :: InvalidValidatorCommission => { & ["Validator prefs are not in valid range." ,] } , Self :: StashIdentityDoesNotExist => { & ["Validator or nominator stash identity does not exist." ,] } , Self :: StashIdentityNotPermissioned => { & ["Validator stash identity was not permissioned." ,] } , Self :: StashIdentityNotCDDed => { & ["Nominator stash was not CDDed." ,] } , Self :: HitIntendedValidatorCount => { & ["Running validator count hit the intended count." ,] } , Self :: IntendedCountIsExceedingConsensusLimit => { & ["When the intended number of validators to run is >= 2/3 of `validator_count`." ,] } , Self :: BondTooSmall => { & ["When the amount to be bonded is less than `MinimumBond`" ,] } , Self :: BadState => { & ["Internal state has become somehow corrupted and the operation cannot continue." ,] } , Self :: TooManyTargets => { & ["Too many nomination targets supplied." ,] } , Self :: BadTarget => { & ["A nomination target was supplied that was blocked or otherwise not a validator." ,] } , Self :: InvalidValidatorUnbondAmount => { & ["Validator should have minimum 50k POLYX bonded." ,] } , _ => & [""] , }
      }
    }
    impl From<StakingError> for &'static str {
      fn from(v: StakingError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&StakingError> for &'static str {
      fn from(v: &StakingError) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ActiveEraInfo {
      pub index: u32,
      pub start: Option<u64>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct UnappliedSlash<AccountId, Balance> {
      pub validator: AccountId,
      pub own: Balance,
      pub others: ::alloc::vec::Vec<(AccountId, Balance)>,
      pub reporters: ::alloc::vec::Vec<AccountId>,
      pub payout: Balance,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ElectionSize {
      #[codec(compact)]
      pub validators: u16,
      #[codec(compact)]
      pub nominators: u32,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct StakingLedger<AccountId, Balance> {
      pub stash: AccountId,
      #[codec(compact)]
      pub total: Balance,
      #[codec(compact)]
      pub active: Balance,
      pub unlocking: ::alloc::vec::Vec<pallet_staking::UnlockChunk<Balance>>,
      pub claimed_rewards: ::alloc::vec::Vec<u32>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ElectionResult<AccountId, Balance> {
      pub elected_stashes: ::alloc::vec::Vec<AccountId>,
      pub exposures: ::alloc::vec::Vec<(AccountId, pallet_staking::Exposure<AccountId, Balance>)>,
      pub compute: pallet_staking::ElectionCompute,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RewardDestination<AccountId> {
      #[codec(index = 0u8)]
      Staked,
      #[codec(index = 1u8)]
      Stash,
      #[codec(index = 2u8)]
      Controller,
      #[codec(index = 3u8)]
      Account(AccountId),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct UnlockChunk<Balance> {
      #[codec(compact)]
      pub value: Balance,
      #[codec(compact)]
      pub era: u32,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ValidatorPrefs {
      #[codec(compact)]
      pub commission: ::polymesh_api_client::per_things::Perbill,
      pub blocked: bool,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PermissionedIdentityPrefs {
      pub intended_count: u32,
      pub running_count: u32,
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StakingCall {
      #[doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"]
      #[doc = "be the account that controls it."]
      #[doc = ""]
      #[doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash account."]
      #[doc = ""]
      #[doc = "Emits `Bonded`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Moderate complexity."]
      #[doc = "- O(1)."]
      #[doc = "- Three extra DB entries."]
      #[doc = ""]
      #[doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"]
      #[doc = "unless the `origin` falls below _existential deposit_ and gets removed as dust."]
      #[doc = "------------------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks"]
      #[doc = "- Write: Bonded, Payee, [Origin Account], Locks, Ledger"]
      #[doc = "# </weight>"]
      #[codec(index = 0u8)]
      bond {
        controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        #[codec(compact)]
        value: u128,
        payee: pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      },
      #[doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"]
      #[doc = "for staking."]
      #[doc = ""]
      #[doc = "Use this if there are additional funds in your stash account that you wish to bond."]
      #[doc = "Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount"]
      #[doc = "that can be added."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller and"]
      #[doc = "it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "Emits `Bonded`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- O(1)."]
      #[doc = "- One DB entry."]
      #[doc = "------------"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Era Election Status, Bonded, Ledger, [Origin Account], Locks"]
      #[doc = "- Write: [Origin Account], Locks, Ledger"]
      #[doc = "# </weight>"]
      #[codec(index = 1u8)]
      bond_extra {
        #[codec(compact)]
        max_additional: u128,
      },
      #[doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"]
      #[doc = "period ends. If this leaves an amount actively bonded less than"]
      #[doc = "T::Currency::minimum_balance(), then it is increased to the full amount."]
      #[doc = ""]
      #[doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"]
      #[doc = "the funds out of management ready for transfer."]
      #[doc = ""]
      #[doc = "No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)"]
      #[doc = "can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need"]
      #[doc = "to be called first to remove some of the chunks (if possible)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "Emits `Unbonded`."]
      #[doc = ""]
      #[doc = "See also [`Call::withdraw_unbonded`]."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Limited but potentially exploitable complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Each call (requires the remainder of the bonded balance to be above `minimum_balance`)"]
      #[doc = "  will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage."]
      #[doc = "  The only way to clean the aforementioned storage item is also user-controlled via"]
      #[doc = "  `withdraw_unbonded`."]
      #[doc = "- One DB entry."]
      #[doc = "----------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: EraElectionStatus, Ledger, CurrentEra, Locks, \\[Origin Account\\]"]
      #[doc = "- Write: Locks, Ledger, \\[Origin Account\\]"]
      #[doc = "</weight>"]
      #[codec(index = 2u8)]
      unbond {
        #[codec(compact)]
        value: u128,
      },
      #[doc = "Remove any unlocked chunks from the `unlocking` queue from our management."]
      #[doc = ""]
      #[doc = "This essentially frees up that balance to be used by the stash account to do"]
      #[doc = "whatever it wants."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "Emits `Withdrawn`."]
      #[doc = ""]
      #[doc = "See also [`Call::unbond`]."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Could be dependent on the `origin` argument and how much `unlocking` chunks exist."]
      #[doc = " It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is"]
      #[doc = " indirectly user-controlled. See [`unbond`] for more detail."]
      #[doc = "- Contains a limited number of reads, yet the size of which could be large based on `ledger`."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "---------------"]
      #[doc = "Complexity O(S) where S is the number of slashing spans to remove"]
      #[doc = "Update:"]
      #[doc = "- Reads: EraElectionStatus, Ledger, Current Era, Locks, [Origin Account]"]
      #[doc = "- Writes: [Origin Account], Locks, Ledger"]
      #[doc = "Kill:"]
      #[doc = "- Reads: EraElectionStatus, Ledger, Current Era, Bonded, Slashing Spans, [Origin"]
      #[doc = "  Account], Locks"]
      #[doc = "- Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators,"]
      #[doc = "  [Origin Account], Locks"]
      #[doc = "- Writes Each: SpanSlash * S"]
      #[doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."]
      #[doc = "# </weight>"]
      #[codec(index = 3u8)]
      withdraw_unbonded { num_slashing_spans: u32 },
      #[doc = "Declare the desire to validate for the origin controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "-----------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Era Election Status, Ledger"]
      #[doc = "- Write: Nominators, Validators"]
      #[doc = "# </weight>"]
      #[codec(index = 4u8)]
      validate {
        prefs: pallet_staking::ValidatorPrefs,
      },
      #[doc = "Declare the desire to nominate `targets` for the origin controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era. This can only be called when"]
      #[doc = "[`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- The transaction's complexity is proportional to the size of `targets` (N)"]
      #[doc = "which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS)."]
      #[doc = "- Both the reads and writes follow a similar pattern."]
      #[doc = "---------"]
      #[doc = "Weight: O(N)"]
      #[doc = "where N is the number of targets"]
      #[doc = "DB Weight:"]
      #[doc = "- Reads: Era Election Status, Ledger, Current Era"]
      #[doc = "- Writes: Validators, Nominators"]
      #[doc = "# </weight>"]
      #[codec(index = 5u8)]
      nominate {
        targets: ::alloc::vec::Vec<
          ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        >,
      },
      #[doc = "Declare no desire to either validate or nominate."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains one read."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "--------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: EraElectionStatus, Ledger"]
      #[doc = "- Write: Validators, Nominators"]
      #[doc = "# </weight>"]
      #[codec(index = 6u8)]
      chill,
      #[doc = "(Re-)set the payment target for a controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "---------"]
      #[doc = "- Weight: O(1)"]
      #[doc = "- DB Weight:"]
      #[doc = "    - Read: Ledger"]
      #[doc = "    - Write: Payee"]
      #[doc = "# </weight>"]
      #[codec(index = 7u8)]
      set_payee {
        payee: pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      },
      #[doc = "(Re-)set the controller of a stash."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "----------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Bonded, Ledger New Controller, Ledger Old Controller"]
      #[doc = "- Write: Bonded, Ledger New Controller, Ledger Old Controller"]
      #[doc = "# </weight>"]
      #[codec(index = 8u8)]
      set_controller {
        controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
      },
      #[doc = "Sets the ideal number of validators."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Weight: O(1)"]
      #[doc = "Write: Validator Count"]
      #[doc = "# </weight>"]
      #[codec(index = 9u8)]
      set_validator_count {
        #[codec(compact)]
        new: u32,
      },
      #[doc = "Increments the ideal number of validators."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Same as [`set_validator_count`]."]
      #[doc = "# </weight>"]
      #[codec(index = 10u8)]
      increase_validator_count {
        #[codec(compact)]
        additional: u32,
      },
      #[doc = "Scale up the ideal number of validators by a factor."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Same as [`set_validator_count`]."]
      #[doc = "# </weight>"]
      #[codec(index = 11u8)]
      scale_validator_count {
        factor: ::polymesh_api_client::per_things::Percent,
      },
      #[doc = "Governance committee on 2/3 rds majority can introduce a new potential identity"]
      #[doc = "to the pool of permissioned entities who can run validators. Staking module uses `PermissionedIdentity`"]
      #[doc = "to ensure validators have completed KYB compliance and considers them for validation."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin Required origin for adding a potential validator."]
      #[doc = "* identity Validator's IdentityId."]
      #[doc = "* intended_count No. of validators given identity intends to run."]
      #[codec(index = 12u8)]
      add_permissioned_validator {
        identity: ::polymesh_api_client::IdentityId,
        intended_count: Option<u32>,
      },
      #[doc = "Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session."]
      #[doc = "Staking module checks `PermissionedIdentity` to ensure validators have"]
      #[doc = "completed KYB compliance"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin Required origin for removing a potential validator."]
      #[doc = "* identity Validator's IdentityId."]
      #[codec(index = 13u8)]
      remove_permissioned_validator {
        identity: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Validate the nominators CDD expiry time."]
      #[doc = ""]
      #[doc = "If an account from a given set of address is nominating then"]
      #[doc = "check the CDD expiry time of it and if it is expired"]
      #[doc = "then the account should be unbonded and removed from the nominating process."]
      #[doc = ""]
      #[doc = "#<weight>"]
      #[doc = "- Depends on passed list of AccountId."]
      #[doc = "- Depends on the no. of claim issuers an accountId has for the CDD expiry."]
      #[doc = "#</weight>"]
      #[codec(index = 14u8)]
      validate_cdd_expiry_nominators {
        targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      },
      #[doc = "Changes commission rate which applies to all validators. Only Governance"]
      #[doc = "committee is allowed to change this value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `new_cap` the new commission cap."]
      #[codec(index = 15u8)]
      set_commission_cap {
        new_cap: ::polymesh_api_client::per_things::Perbill,
      },
      #[doc = "Changes min bond value to be used in validate(). Only Governance"]
      #[doc = "committee is allowed to change this value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `new_value` the new minimum"]
      #[codec(index = 16u8)]
      set_min_bond_threshold { new_value: u128 },
      #[doc = "Force there to be no new eras indefinitely."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- No arguments."]
      #[doc = "- Weight: O(1)"]
      #[doc = "- Write: ForceEra"]
      #[doc = "# </weight>"]
      #[codec(index = 17u8)]
      force_no_eras,
      #[doc = "Force there to be a new era at the end of the next session. After this, it will be"]
      #[doc = "reset to normal (non-forced) behaviour."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- No arguments."]
      #[doc = "- Weight: O(1)"]
      #[doc = "- Write ForceEra"]
      #[doc = "# </weight>"]
      #[codec(index = 18u8)]
      force_new_era,
      #[doc = "Set the validators who cannot be slashed (if any)."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(V)"]
      #[doc = "- Write: Invulnerables"]
      #[doc = "# </weight>"]
      #[codec(index = 19u8)]
      set_invulnerables {
        invulnerables: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      },
      #[doc = "Force a current staker to become completely unstaked, immediately."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "O(S) where S is the number of slashing spans to be removed"]
      #[doc = "Reads: Bonded, Slashing Spans, Account, Locks"]
      #[doc = "Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks"]
      #[doc = "Writes Each: SpanSlash * S"]
      #[doc = "# </weight>"]
      #[codec(index = 20u8)]
      force_unstake {
        stash: ::polymesh_api_client::AccountId,
        num_slashing_spans: u32,
      },
      #[doc = "Force there to be a new era at the end of sessions indefinitely."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Weight: O(1)"]
      #[doc = "- Write: ForceEra"]
      #[doc = "# </weight>"]
      #[codec(index = 21u8)]
      force_new_era_always,
      #[doc = "Cancel enactment of a deferred slash."]
      #[doc = ""]
      #[doc = "Can be called by the `T::SlashCancelOrigin`."]
      #[doc = ""]
      #[doc = "Parameters: era and indices of the slashes for that era to kill."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Complexity: O(U + S)"]
      #[doc = "with U unapplied slashes weighted with U=1000"]
      #[doc = "and S is the number of slash indices to be canceled."]
      #[doc = "- Read: Unapplied Slashes"]
      #[doc = "- Write: Unapplied Slashes"]
      #[doc = "# </weight>"]
      #[codec(index = 22u8)]
      cancel_deferred_slash {
        era: u32,
        slash_indices: ::alloc::vec::Vec<u32>,
      },
      #[doc = "Pay out all the stakers behind a single validator for a single era."]
      #[doc = ""]
      #[doc = "- `validator_stash` is the stash account of the validator. Their nominators, up to"]
      #[doc = "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards."]
      #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
      #[doc = ""]
      #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
      #[doc = "it is not one of the stakers."]
      #[doc = ""]
      #[doc = "This can only be called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Time complexity: at most O(MaxNominatorRewardedPerValidator)."]
      #[doc = "- Contains a limited number of reads and writes."]
      #[doc = "-----------"]
      #[doc = "N is the Number of payouts for the validator (including the validator)"]
      #[doc = "Weight:"]
      #[doc = "- Reward Destination Staked: O(N)"]
      #[doc = "- Reward Destination Controller (Creating): O(N)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: EraElectionStatus, CurrentEra, HistoryDepth, ErasValidatorReward,"]
      #[doc = "        ErasStakersClipped, ErasRewardPoints, ErasValidatorPrefs (8 items)"]
      #[doc = "- Read Each: Bonded, Ledger, Payee, Locks, System Account (5 items)"]
      #[doc = "- Write Each: System Account, Locks, Ledger (3 items)"]
      #[doc = "# </weight>"]
      #[codec(index = 23u8)]
      payout_stakers {
        validator_stash: ::polymesh_api_client::AccountId,
        era: u32,
      },
      #[doc = "Rebond a portion of the stash scheduled to be unlocked."]
      #[doc = ""]
      #[doc = "The dispatch origin must be signed by the controller, and it can be only called when"]
      #[doc = "[`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Time complexity: O(L), where L is unlocking chunks"]
      #[doc = "- Bounded by `MAX_UNLOCKING_CHUNKS`."]
      #[doc = "- Storage changes: Can't increase storage, only decrease it."]
      #[doc = "---------------"]
      #[doc = "- DB Weight:"]
      #[doc = "    - Reads: EraElectionStatus, Ledger, Locks, [Origin Account]"]
      #[doc = "    - Writes: [Origin Account], Locks, Ledger"]
      #[doc = "# </weight>"]
      #[codec(index = 24u8)]
      rebond {
        #[codec(compact)]
        value: u128,
      },
      #[doc = "Set `HistoryDepth` value. This function will delete any history information"]
      #[doc = "when `HistoryDepth` is reduced."]
      #[doc = ""]
      #[doc = "Parameters:"]
      #[doc = "- `new_history_depth`: The new history depth you would like to set."]
      #[doc = "- `era_items_deleted`: The number of items that will be deleted by this dispatch."]
      #[doc = "   This should report all the storage items that will be deleted by clearing old"]
      #[doc = "   era history. Needed to report an accurate weight for the dispatch. Trusted by"]
      #[doc = "   `Root` to report an accurate number."]
      #[doc = ""]
      #[doc = "Origin must be root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- E: Number of history depths removed, i.e. 10 -> 7 = 3"]
      #[doc = "- Weight: O(E)"]
      #[doc = "- DB Weight:"]
      #[doc = "    - Reads: Current Era, History Depth"]
      #[doc = "    - Writes: History Depth"]
      #[doc = "    - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs"]
      #[doc = "    - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex"]
      #[doc = "# </weight>"]
      #[codec(index = 25u8)]
      set_history_depth {
        #[codec(compact)]
        new_history_depth: u32,
        #[codec(compact)]
        _era_items_deleted: u32,
      },
      #[doc = "Remove all data structure concerning a staker/stash once its balance is at the minimum."]
      #[doc = "This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone"]
      #[doc = "and the target `stash` must have no funds left beyond the ED."]
      #[doc = ""]
      #[doc = "This can be called from any origin."]
      #[doc = ""]
      #[doc = "- `stash`: The stash account to reap. Its balance must be zero."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Complexity: O(S) where S is the number of slashing spans on the account."]
      #[doc = "DB Weight:"]
      #[doc = "- Reads: Stash Account, Bonded, Slashing Spans, Locks"]
      #[doc = "- Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks"]
      #[doc = "- Writes Each: SpanSlash * S"]
      #[doc = "# </weight>"]
      #[codec(index = 26u8)]
      reap_stash {
        stash: ::polymesh_api_client::AccountId,
        num_slashing_spans: u32,
      },
      #[doc = "Submit an election result to the chain. If the solution:"]
      #[doc = ""]
      #[doc = "1. is valid."]
      #[doc = "2. has a better score than a potentially existing solution on chain."]
      #[doc = ""]
      #[doc = "then, it will be _put_ on chain."]
      #[doc = ""]
      #[doc = "A solution consists of two pieces of data:"]
      #[doc = ""]
      #[doc = "1. `winners`: a flat vector of all the winners of the round."]
      #[doc = "2. `assignments`: the compact version of an assignment vector that encodes the edge"]
      #[doc = "   weights."]
      #[doc = ""]
      #[doc = "Both of which may be computed using _phragmen_, or any other algorithm."]
      #[doc = ""]
      #[doc = "Additionally, the submitter must provide:"]
      #[doc = ""]
      #[doc = "- The `score` that they claim their solution has."]
      #[doc = ""]
      #[doc = "Both validators and nominators will be represented by indices in the solution. The"]
      #[doc = "indices should respect the corresponding types ([`ValidatorIndex`] and"]
      #[doc = "[`NominatorIndex`]). Moreover, they should be valid when used to index into"]
      #[doc = "[`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the"]
      #[doc = "solution to be rejected. These two storage items are set during the election window and"]
      #[doc = "may be used to determine the indices."]
      #[doc = ""]
      #[doc = "A solution is valid if:"]
      #[doc = ""]
      #[doc = "0. It is submitted when [`EraElectionStatus`] is `Open`."]
      #[doc = "1. Its claimed score is equal to the score computed on-chain."]
      #[doc = "2. Presents the correct number of winners."]
      #[doc = "3. All indexes must be value according to the snapshot vectors. All edge values must"]
      #[doc = "   also be correct and should not overflow the granularity of the ratio type (i.e. 256"]
      #[doc = "   or billion)."]
      #[doc = "4. For each edge, all targets are actually nominated by the voter."]
      #[doc = "5. Has correct self-votes."]
      #[doc = ""]
      #[doc = "A solutions score is consisted of 3 parameters:"]
      #[doc = ""]
      #[doc = "1. `min { support.total }` for each support of a winner. This value should be maximized."]
      #[doc = "2. `sum { support.total }` for each support of a winner. This value should be minimized."]
      #[doc = "3. `sum { support.total^2 }` for each support of a winner. This value should be"]
      #[doc = "   minimized (to ensure less variance)"]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "The transaction is assumed to be the longest path, a better solution."]
      #[doc = "  - Initial solution is almost the same."]
      #[doc = "  - Worse solution is retraced in pre-dispatch-checks which sets its own weight."]
      #[doc = "# </weight>"]
      #[codec(index = 27u8)]
      submit_election_solution {
        winners: ::alloc::vec::Vec<u16>,
        compact: pallet_staking::CompactAssignments,
        score: sp_npos_elections::ElectionScore,
        era: u32,
        size: pallet_staking::ElectionSize,
      },
      #[doc = "Unsigned version of `submit_election_solution`."]
      #[doc = ""]
      #[doc = "Note that this must pass the [`ValidateUnsigned`] check which only allows transactions"]
      #[doc = "from the local node to be included. In other words, only the block author can include a"]
      #[doc = "transaction in the block."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "See [`submit_election_solution`]."]
      #[doc = "# </weight>"]
      #[codec(index = 28u8)]
      submit_election_solution_unsigned {
        winners: ::alloc::vec::Vec<u16>,
        compact: pallet_staking::CompactAssignments,
        score: sp_npos_elections::ElectionScore,
        era: u32,
        size: pallet_staking::ElectionSize,
      },
      #[doc = "System version of `payout_stakers()`. Only be called by the root origin."]
      #[codec(index = 29u8)]
      payout_stakers_by_system {
        validator_stash: ::polymesh_api_client::AccountId,
        era: u32,
      },
      #[doc = "Switch slashing status on the basis of given `SlashingSwitch`. Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - AccountId of root."]
      #[doc = "* slashing_switch - Switch used to set the targets for slashing."]
      #[codec(index = 30u8)]
      change_slashing_allowed_for {
        slashing_switch: pallet_staking::SlashingSwitch,
      },
      #[doc = "Update the intended validator count for a given DID."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin which must be the required origin for adding a potential validator."]
      #[doc = "* identity to add as a validator."]
      #[doc = "* new_intended_count New value of intended count."]
      #[codec(index = 31u8)]
      update_permissioned_validator_intended_count {
        identity: ::polymesh_api_client::IdentityId,
        new_intended_count: u32,
      },
      #[doc = "GC forcefully chills a validator."]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin which must be a GC."]
      #[doc = "* identity must be permissioned to run operator/validator nodes."]
      #[doc = "* stash_keys contains the secondary keys of the permissioned identity"]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` The origin was not a GC member."]
      #[doc = "* `CallNotAllowed` The call is not allowed at the given time due to restrictions of election period."]
      #[doc = "* `NotExists` Permissioned validator doesn't exist."]
      #[doc = "* `NotStash` Not a stash account for the permissioned identity."]
      #[codec(index = 32u8)]
      chill_from_governance {
        identity: ::polymesh_api_client::IdentityId,
        stash_keys: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      },
    }
    impl StakingCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::bond { .. } => "Staking.bond",
          Self::bond_extra { .. } => "Staking.bond_extra",
          Self::unbond { .. } => "Staking.unbond",
          Self::withdraw_unbonded { .. } => "Staking.withdraw_unbonded",
          Self::validate { .. } => "Staking.validate",
          Self::nominate { .. } => "Staking.nominate",
          Self::chill => "Staking.chill",
          Self::set_payee { .. } => "Staking.set_payee",
          Self::set_controller { .. } => "Staking.set_controller",
          Self::set_validator_count { .. } => "Staking.set_validator_count",
          Self::increase_validator_count { .. } => "Staking.increase_validator_count",
          Self::scale_validator_count { .. } => "Staking.scale_validator_count",
          Self::add_permissioned_validator { .. } => "Staking.add_permissioned_validator",
          Self::remove_permissioned_validator { .. } => "Staking.remove_permissioned_validator",
          Self::validate_cdd_expiry_nominators { .. } => "Staking.validate_cdd_expiry_nominators",
          Self::set_commission_cap { .. } => "Staking.set_commission_cap",
          Self::set_min_bond_threshold { .. } => "Staking.set_min_bond_threshold",
          Self::force_no_eras => "Staking.force_no_eras",
          Self::force_new_era => "Staking.force_new_era",
          Self::set_invulnerables { .. } => "Staking.set_invulnerables",
          Self::force_unstake { .. } => "Staking.force_unstake",
          Self::force_new_era_always => "Staking.force_new_era_always",
          Self::cancel_deferred_slash { .. } => "Staking.cancel_deferred_slash",
          Self::payout_stakers { .. } => "Staking.payout_stakers",
          Self::rebond { .. } => "Staking.rebond",
          Self::set_history_depth { .. } => "Staking.set_history_depth",
          Self::reap_stash { .. } => "Staking.reap_stash",
          Self::submit_election_solution { .. } => "Staking.submit_election_solution",
          Self::submit_election_solution_unsigned { .. } => {
            "Staking.submit_election_solution_unsigned"
          }
          Self::payout_stakers_by_system { .. } => "Staking.payout_stakers_by_system",
          Self::change_slashing_allowed_for { .. } => "Staking.change_slashing_allowed_for",
          Self::update_permissioned_validator_intended_count { .. } => {
            "Staking.update_permissioned_validator_intended_count"
          }
          Self::chill_from_governance { .. } => "Staking.chill_from_governance",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for StakingCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: bond { .. } => { & ["Take the origin account as a stash and lock up `value` of its balance. `controller` will" , "be the account that controls it." , "" , "`value` must be more than the `minimum_balance` specified by `T::Currency`." , "" , "The dispatch origin for this call must be _Signed_ by the stash account." , "" , "Emits `Bonded`." , "" , "# <weight>" , "- Independent of the arguments. Moderate complexity." , "- O(1)." , "- Three extra DB entries." , "" , "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned" , "unless the `origin` falls below _existential deposit_ and gets removed as dust." , "------------------" , "Weight: O(1)" , "DB Weight:" , "- Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks" , "- Write: Bonded, Payee, [Origin Account], Locks, Ledger" , "# </weight>" ,] } , Self :: bond_extra { .. } => { & ["Add some extra amount that have appeared in the stash `free_balance` into the balance up" , "for staking." , "" , "Use this if there are additional funds in your stash account that you wish to bond." , "Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount" , "that can be added." , "" , "The dispatch origin for this call must be _Signed_ by the stash, not the controller and" , "it can be only called when [`EraElectionStatus`] is `Closed`." , "" , "Emits `Bonded`." , "" , "# <weight>" , "- Independent of the arguments. Insignificant complexity." , "- O(1)." , "- One DB entry." , "------------" , "DB Weight:" , "- Read: Era Election Status, Bonded, Ledger, [Origin Account], Locks" , "- Write: [Origin Account], Locks, Ledger" , "# </weight>" ,] } , Self :: unbond { .. } => { & ["Schedule a portion of the stash to be unlocked ready for transfer out after the bond" , "period ends. If this leaves an amount actively bonded less than" , "T::Currency::minimum_balance(), then it is increased to the full amount." , "" , "Once the unlock period is done, you can call `withdraw_unbonded` to actually move" , "the funds out of management ready for transfer." , "" , "No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)" , "can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need" , "to be called first to remove some of the chunks (if possible)." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "And, it can be only called when [`EraElectionStatus`] is `Closed`." , "" , "Emits `Unbonded`." , "" , "See also [`Call::withdraw_unbonded`]." , "" , "# <weight>" , "- Independent of the arguments. Limited but potentially exploitable complexity." , "- Contains a limited number of reads." , "- Each call (requires the remainder of the bonded balance to be above `minimum_balance`)" , "  will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage." , "  The only way to clean the aforementioned storage item is also user-controlled via" , "  `withdraw_unbonded`." , "- One DB entry." , "----------" , "Weight: O(1)" , "DB Weight:" , "- Read: EraElectionStatus, Ledger, CurrentEra, Locks, \\[Origin Account\\]" , "- Write: Locks, Ledger, \\[Origin Account\\]" , "</weight>" ,] } , Self :: withdraw_unbonded { .. } => { & ["Remove any unlocked chunks from the `unlocking` queue from our management." , "" , "This essentially frees up that balance to be used by the stash account to do" , "whatever it wants." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "And, it can be only called when [`EraElectionStatus`] is `Closed`." , "" , "Emits `Withdrawn`." , "" , "See also [`Call::unbond`]." , "" , "# <weight>" , "- Could be dependent on the `origin` argument and how much `unlocking` chunks exist." , " It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is" , " indirectly user-controlled. See [`unbond`] for more detail." , "- Contains a limited number of reads, yet the size of which could be large based on `ledger`." , "- Writes are limited to the `origin` account key." , "---------------" , "Complexity O(S) where S is the number of slashing spans to remove" , "Update:" , "- Reads: EraElectionStatus, Ledger, Current Era, Locks, [Origin Account]" , "- Writes: [Origin Account], Locks, Ledger" , "Kill:" , "- Reads: EraElectionStatus, Ledger, Current Era, Bonded, Slashing Spans, [Origin" , "  Account], Locks" , "- Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators," , "  [Origin Account], Locks" , "- Writes Each: SpanSlash * S" , "NOTE: Weight annotation is the kill scenario, we refund otherwise." , "# </weight>" ,] } , Self :: validate { .. } => { & ["Declare the desire to validate for the origin controller." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "And, it can be only called when [`EraElectionStatus`] is `Closed`." , "" , "# <weight>" , "- Independent of the arguments. Insignificant complexity." , "- Contains a limited number of reads." , "- Writes are limited to the `origin` account key." , "-----------" , "Weight: O(1)" , "DB Weight:" , "- Read: Era Election Status, Ledger" , "- Write: Nominators, Validators" , "# </weight>" ,] } , Self :: nominate { .. } => { & ["Declare the desire to nominate `targets` for the origin controller." , "" , "Effects will be felt at the beginning of the next era. This can only be called when" , "[`EraElectionStatus`] is `Closed`." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "And, it can be only called when [`EraElectionStatus`] is `Closed`." , "" , "# <weight>" , "- The transaction's complexity is proportional to the size of `targets` (N)" , "which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS)." , "- Both the reads and writes follow a similar pattern." , "---------" , "Weight: O(N)" , "where N is the number of targets" , "DB Weight:" , "- Reads: Era Election Status, Ledger, Current Era" , "- Writes: Validators, Nominators" , "# </weight>" ,] } , Self :: chill => { & ["Declare no desire to either validate or nominate." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "And, it can be only called when [`EraElectionStatus`] is `Closed`." , "" , "# <weight>" , "- Independent of the arguments. Insignificant complexity." , "- Contains one read." , "- Writes are limited to the `origin` account key." , "--------" , "Weight: O(1)" , "DB Weight:" , "- Read: EraElectionStatus, Ledger" , "- Write: Validators, Nominators" , "# </weight>" ,] } , Self :: set_payee { .. } => { & ["(Re-)set the payment target for a controller." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "# <weight>" , "- Independent of the arguments. Insignificant complexity." , "- Contains a limited number of reads." , "- Writes are limited to the `origin` account key." , "---------" , "- Weight: O(1)" , "- DB Weight:" , "    - Read: Ledger" , "    - Write: Payee" , "# </weight>" ,] } , Self :: set_controller { .. } => { & ["(Re-)set the controller of a stash." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the stash, not the controller." , "" , "# <weight>" , "- Independent of the arguments. Insignificant complexity." , "- Contains a limited number of reads." , "- Writes are limited to the `origin` account key." , "----------" , "Weight: O(1)" , "DB Weight:" , "- Read: Bonded, Ledger New Controller, Ledger Old Controller" , "- Write: Bonded, Ledger New Controller, Ledger Old Controller" , "# </weight>" ,] } , Self :: set_validator_count { .. } => { & ["Sets the ideal number of validators." , "" , "The dispatch origin must be Root." , "" , "# <weight>" , "Weight: O(1)" , "Write: Validator Count" , "# </weight>" ,] } , Self :: increase_validator_count { .. } => { & ["Increments the ideal number of validators." , "" , "The dispatch origin must be Root." , "" , "# <weight>" , "Same as [`set_validator_count`]." , "# </weight>" ,] } , Self :: scale_validator_count { .. } => { & ["Scale up the ideal number of validators by a factor." , "" , "The dispatch origin must be Root." , "" , "# <weight>" , "Same as [`set_validator_count`]." , "# </weight>" ,] } , Self :: add_permissioned_validator { .. } => { & ["Governance committee on 2/3 rds majority can introduce a new potential identity" , "to the pool of permissioned entities who can run validators. Staking module uses `PermissionedIdentity`" , "to ensure validators have completed KYB compliance and considers them for validation." , "" , "# Arguments" , "* origin Required origin for adding a potential validator." , "* identity Validator's IdentityId." , "* intended_count No. of validators given identity intends to run." ,] } , Self :: remove_permissioned_validator { .. } => { & ["Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session." , "Staking module checks `PermissionedIdentity` to ensure validators have" , "completed KYB compliance" , "" , "# Arguments" , "* origin Required origin for removing a potential validator." , "* identity Validator's IdentityId." ,] } , Self :: validate_cdd_expiry_nominators { .. } => { & ["Validate the nominators CDD expiry time." , "" , "If an account from a given set of address is nominating then" , "check the CDD expiry time of it and if it is expired" , "then the account should be unbonded and removed from the nominating process." , "" , "#<weight>" , "- Depends on passed list of AccountId." , "- Depends on the no. of claim issuers an accountId has for the CDD expiry." , "#</weight>" ,] } , Self :: set_commission_cap { .. } => { & ["Changes commission rate which applies to all validators. Only Governance" , "committee is allowed to change this value." , "" , "# Arguments" , "* `new_cap` the new commission cap." ,] } , Self :: set_min_bond_threshold { .. } => { & ["Changes min bond value to be used in validate(). Only Governance" , "committee is allowed to change this value." , "" , "# Arguments" , "* `new_value` the new minimum" ,] } , Self :: force_no_eras => { & ["Force there to be no new eras indefinitely." , "" , "The dispatch origin must be Root." , "" , "# <weight>" , "- No arguments." , "- Weight: O(1)" , "- Write: ForceEra" , "# </weight>" ,] } , Self :: force_new_era => { & ["Force there to be a new era at the end of the next session. After this, it will be" , "reset to normal (non-forced) behaviour." , "" , "The dispatch origin must be Root." , "" , "# <weight>" , "- No arguments." , "- Weight: O(1)" , "- Write ForceEra" , "# </weight>" ,] } , Self :: set_invulnerables { .. } => { & ["Set the validators who cannot be slashed (if any)." , "" , "The dispatch origin must be Root." , "" , "# <weight>" , "- O(V)" , "- Write: Invulnerables" , "# </weight>" ,] } , Self :: force_unstake { .. } => { & ["Force a current staker to become completely unstaked, immediately." , "" , "The dispatch origin must be Root." , "" , "# <weight>" , "O(S) where S is the number of slashing spans to be removed" , "Reads: Bonded, Slashing Spans, Account, Locks" , "Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks" , "Writes Each: SpanSlash * S" , "# </weight>" ,] } , Self :: force_new_era_always => { & ["Force there to be a new era at the end of sessions indefinitely." , "" , "The dispatch origin must be Root." , "" , "# <weight>" , "- Weight: O(1)" , "- Write: ForceEra" , "# </weight>" ,] } , Self :: cancel_deferred_slash { .. } => { & ["Cancel enactment of a deferred slash." , "" , "Can be called by the `T::SlashCancelOrigin`." , "" , "Parameters: era and indices of the slashes for that era to kill." , "" , "# <weight>" , "Complexity: O(U + S)" , "with U unapplied slashes weighted with U=1000" , "and S is the number of slash indices to be canceled." , "- Read: Unapplied Slashes" , "- Write: Unapplied Slashes" , "# </weight>" ,] } , Self :: payout_stakers { .. } => { & ["Pay out all the stakers behind a single validator for a single era." , "" , "- `validator_stash` is the stash account of the validator. Their nominators, up to" , "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards." , "- `era` may be any era between `[current_era - history_depth; current_era]`." , "" , "The origin of this call must be _Signed_. Any account can call this function, even if" , "it is not one of the stakers." , "" , "This can only be called when [`EraElectionStatus`] is `Closed`." , "" , "# <weight>" , "- Time complexity: at most O(MaxNominatorRewardedPerValidator)." , "- Contains a limited number of reads and writes." , "-----------" , "N is the Number of payouts for the validator (including the validator)" , "Weight:" , "- Reward Destination Staked: O(N)" , "- Reward Destination Controller (Creating): O(N)" , "DB Weight:" , "- Read: EraElectionStatus, CurrentEra, HistoryDepth, ErasValidatorReward," , "        ErasStakersClipped, ErasRewardPoints, ErasValidatorPrefs (8 items)" , "- Read Each: Bonded, Ledger, Payee, Locks, System Account (5 items)" , "- Write Each: System Account, Locks, Ledger (3 items)" , "# </weight>" ,] } , Self :: rebond { .. } => { & ["Rebond a portion of the stash scheduled to be unlocked." , "" , "The dispatch origin must be signed by the controller, and it can be only called when" , "[`EraElectionStatus`] is `Closed`." , "" , "# <weight>" , "- Time complexity: O(L), where L is unlocking chunks" , "- Bounded by `MAX_UNLOCKING_CHUNKS`." , "- Storage changes: Can't increase storage, only decrease it." , "---------------" , "- DB Weight:" , "    - Reads: EraElectionStatus, Ledger, Locks, [Origin Account]" , "    - Writes: [Origin Account], Locks, Ledger" , "# </weight>" ,] } , Self :: set_history_depth { .. } => { & ["Set `HistoryDepth` value. This function will delete any history information" , "when `HistoryDepth` is reduced." , "" , "Parameters:" , "- `new_history_depth`: The new history depth you would like to set." , "- `era_items_deleted`: The number of items that will be deleted by this dispatch." , "   This should report all the storage items that will be deleted by clearing old" , "   era history. Needed to report an accurate weight for the dispatch. Trusted by" , "   `Root` to report an accurate number." , "" , "Origin must be root." , "" , "# <weight>" , "- E: Number of history depths removed, i.e. 10 -> 7 = 3" , "- Weight: O(E)" , "- DB Weight:" , "    - Reads: Current Era, History Depth" , "    - Writes: History Depth" , "    - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs" , "    - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex" , "# </weight>" ,] } , Self :: reap_stash { .. } => { & ["Remove all data structure concerning a staker/stash once its balance is at the minimum." , "This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone" , "and the target `stash` must have no funds left beyond the ED." , "" , "This can be called from any origin." , "" , "- `stash`: The stash account to reap. Its balance must be zero." , "" , "# <weight>" , "Complexity: O(S) where S is the number of slashing spans on the account." , "DB Weight:" , "- Reads: Stash Account, Bonded, Slashing Spans, Locks" , "- Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks" , "- Writes Each: SpanSlash * S" , "# </weight>" ,] } , Self :: submit_election_solution { .. } => { & ["Submit an election result to the chain. If the solution:" , "" , "1. is valid." , "2. has a better score than a potentially existing solution on chain." , "" , "then, it will be _put_ on chain." , "" , "A solution consists of two pieces of data:" , "" , "1. `winners`: a flat vector of all the winners of the round." , "2. `assignments`: the compact version of an assignment vector that encodes the edge" , "   weights." , "" , "Both of which may be computed using _phragmen_, or any other algorithm." , "" , "Additionally, the submitter must provide:" , "" , "- The `score` that they claim their solution has." , "" , "Both validators and nominators will be represented by indices in the solution. The" , "indices should respect the corresponding types ([`ValidatorIndex`] and" , "[`NominatorIndex`]). Moreover, they should be valid when used to index into" , "[`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the" , "solution to be rejected. These two storage items are set during the election window and" , "may be used to determine the indices." , "" , "A solution is valid if:" , "" , "0. It is submitted when [`EraElectionStatus`] is `Open`." , "1. Its claimed score is equal to the score computed on-chain." , "2. Presents the correct number of winners." , "3. All indexes must be value according to the snapshot vectors. All edge values must" , "   also be correct and should not overflow the granularity of the ratio type (i.e. 256" , "   or billion)." , "4. For each edge, all targets are actually nominated by the voter." , "5. Has correct self-votes." , "" , "A solutions score is consisted of 3 parameters:" , "" , "1. `min { support.total }` for each support of a winner. This value should be maximized." , "2. `sum { support.total }` for each support of a winner. This value should be minimized." , "3. `sum { support.total^2 }` for each support of a winner. This value should be" , "   minimized (to ensure less variance)" , "" , "# <weight>" , "The transaction is assumed to be the longest path, a better solution." , "  - Initial solution is almost the same." , "  - Worse solution is retraced in pre-dispatch-checks which sets its own weight." , "# </weight>" ,] } , Self :: submit_election_solution_unsigned { .. } => { & ["Unsigned version of `submit_election_solution`." , "" , "Note that this must pass the [`ValidateUnsigned`] check which only allows transactions" , "from the local node to be included. In other words, only the block author can include a" , "transaction in the block." , "" , "# <weight>" , "See [`submit_election_solution`]." , "# </weight>" ,] } , Self :: payout_stakers_by_system { .. } => { & ["System version of `payout_stakers()`. Only be called by the root origin." ,] } , Self :: change_slashing_allowed_for { .. } => { & ["Switch slashing status on the basis of given `SlashingSwitch`. Can only be called by root." , "" , "# Arguments" , "* origin - AccountId of root." , "* slashing_switch - Switch used to set the targets for slashing." ,] } , Self :: update_permissioned_validator_intended_count { .. } => { & ["Update the intended validator count for a given DID." , "" , "# Arguments" , "* origin which must be the required origin for adding a potential validator." , "* identity to add as a validator." , "* new_intended_count New value of intended count." ,] } , Self :: chill_from_governance { .. } => { & ["GC forcefully chills a validator." , "Effects will be felt at the beginning of the next era." , "And, it can be only called when [`EraElectionStatus`] is `Closed`." , "" , "# Arguments" , "* origin which must be a GC." , "* identity must be permissioned to run operator/validator nodes." , "* stash_keys contains the secondary keys of the permissioned identity" , "" , "# Errors" , "* `BadOrigin` The origin was not a GC member." , "* `CallNotAllowed` The call is not allowed at the given time due to restrictions of election period." , "* `NotExists` Permissioned validator doesn't exist." , "* `NotStash` Not a stash account for the permissioned identity." ,] } , _ => & [""] , }
      }
    }
    impl From<StakingCall> for &'static str {
      fn from(v: StakingCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&StakingCall> for &'static str {
      fn from(v: &StakingCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Nominations<AccountId> {
      pub targets: ::alloc::vec::Vec<AccountId>,
      pub submitted_in: u32,
      pub suppressed: bool,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct EraRewardPoints<AccountId: Ord> {
      pub total: u32,
      pub individual: ::alloc::collections::BTreeMap<AccountId, u32>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Exposure<AccountId, Balance> {
      #[codec(compact)]
      pub total: Balance,
      #[codec(compact)]
      pub own: Balance,
      pub others: ::alloc::vec::Vec<pallet_staking::IndividualExposure<AccountId, Balance>>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct IndividualExposure<AccountId, Balance> {
      pub who: AccountId,
      #[codec(compact)]
      pub value: Balance,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Forcing {
      #[codec(index = 0u8)]
      NotForcing,
      #[codec(index = 1u8)]
      ForceNew,
      #[codec(index = 2u8)]
      ForceNone,
      #[codec(index = 3u8)]
      ForceAlways,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct CompactAssignments {
      pub votes1: ::alloc::vec::Vec<(::codec::Compact<u32>, ::codec::Compact<u16>)>,
      pub votes2: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        (
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ),
        ::codec::Compact<u16>,
      )>,
      pub votes3: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 2usize],
        ::codec::Compact<u16>,
      )>,
      pub votes4: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 3usize],
        ::codec::Compact<u16>,
      )>,
      pub votes5: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 4usize],
        ::codec::Compact<u16>,
      )>,
      pub votes6: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 5usize],
        ::codec::Compact<u16>,
      )>,
      pub votes7: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 6usize],
        ::codec::Compact<u16>,
      )>,
      pub votes8: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 7usize],
        ::codec::Compact<u16>,
      )>,
      pub votes9: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 8usize],
        ::codec::Compact<u16>,
      )>,
      pub votes10: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 9usize],
        ::codec::Compact<u16>,
      )>,
      pub votes11: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 10usize],
        ::codec::Compact<u16>,
      )>,
      pub votes12: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 11usize],
        ::codec::Compact<u16>,
      )>,
      pub votes13: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 12usize],
        ::codec::Compact<u16>,
      )>,
      pub votes14: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 13usize],
        ::codec::Compact<u16>,
      )>,
      pub votes15: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 14usize],
        ::codec::Compact<u16>,
      )>,
      pub votes16: ::alloc::vec::Vec<(
        ::codec::Compact<u32>,
        [(
          ::codec::Compact<u16>,
          ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
        ); 15usize],
        ::codec::Compact<u16>,
      )>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ElectionStatus<BlockNumber> {
      #[codec(index = 0u8)]
      Closed,
      #[codec(index = 1u8)]
      Open(BlockNumber),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Releases {
      #[codec(index = 0u8)]
      V1_0_0Ancient,
      #[codec(index = 1u8)]
      V2_0_0,
      #[codec(index = 2u8)]
      V3_0_0,
      #[codec(index = 3u8)]
      V4_0_0,
      #[codec(index = 4u8)]
      V5_0_0,
      #[codec(index = 5u8)]
      V6_0_0,
      #[codec(index = 6u8)]
      V6_0_1,
      #[codec(index = 7u8)]
      V7_0_0,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum SlashingSwitch {
      #[codec(index = 0u8)]
      Validator,
      #[codec(index = 1u8)]
      ValidatorAndNominator,
      #[codec(index = 2u8)]
      None,
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StakingEvent<Balance, AccountId> {
      #[doc = "The era payout has been set; the first balance is the validator-payout; the second is"]
      #[doc = "the remainder from the maximum amount of reward."]
      #[doc = "\\[era_index, validator_payout, remainder\\]"]
      #[codec(index = 0u8)]
      EraPayout(u32, Balance, Balance),
      #[doc = "The staker has been rewarded by this amount. \\[stash_identity, stash, amount\\]"]
      #[codec(index = 1u8)]
      Reward(::polymesh_api_client::IdentityId, AccountId, Balance),
      #[doc = "One validator (and its nominators) has been slashed by the given amount."]
      #[doc = "\\[validator, amount\\]"]
      #[codec(index = 2u8)]
      Slash(AccountId, Balance),
      #[doc = "An old slashing report from a prior era was discarded because it could"]
      #[doc = "not be processed. \\[session_index\\]"]
      #[codec(index = 3u8)]
      OldSlashingReportDiscarded(u32),
      #[doc = "A new set of stakers was elected with the given \\[compute\\]."]
      #[codec(index = 4u8)]
      StakingElection(pallet_staking::ElectionCompute),
      #[doc = "A new solution for the upcoming election has been stored. \\[compute\\]"]
      #[codec(index = 5u8)]
      SolutionStored(pallet_staking::ElectionCompute),
      #[doc = "An account has bonded this amount. \\[did, stash, amount\\]"]
      #[doc = ""]
      #[doc = "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,"]
      #[doc = "it will not be emitted for staking rewards when they are added to stake."]
      #[codec(index = 6u8)]
      Bonded(::polymesh_api_client::IdentityId, AccountId, Balance),
      #[doc = "An account has unbonded this amount. \\[did, stash, amount\\]"]
      #[codec(index = 7u8)]
      Unbonded(::polymesh_api_client::IdentityId, AccountId, Balance),
      #[doc = "User has updated their nominations"]
      #[codec(index = 8u8)]
      Nominated(
        ::polymesh_api_client::IdentityId,
        AccountId,
        ::alloc::vec::Vec<AccountId>,
      ),
      #[doc = "An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`"]
      #[doc = "from the unlocking queue. \\[stash, amount\\]"]
      #[codec(index = 9u8)]
      Withdrawn(AccountId, Balance),
      #[doc = "An DID has issued a candidacy. See the transaction for who."]
      #[doc = "GC identity , Validator's identity."]
      #[codec(index = 10u8)]
      PermissionedIdentityAdded(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::IdentityId,
      ),
      #[doc = "The given member was removed. See the transaction for who."]
      #[doc = "GC identity , Validator's identity."]
      #[codec(index = 11u8)]
      PermissionedIdentityRemoved(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::IdentityId,
      ),
      #[doc = "Remove the nominators from the valid nominators when there CDD expired."]
      #[doc = "Caller, Stash accountId of nominators"]
      #[codec(index = 12u8)]
      InvalidatedNominators(
        ::polymesh_api_client::IdentityId,
        AccountId,
        ::alloc::vec::Vec<AccountId>,
      ),
      #[doc = "When commission cap get updated."]
      #[doc = "(old value, new value)"]
      #[codec(index = 13u8)]
      CommissionCapUpdated(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::per_things::Perbill,
        ::polymesh_api_client::per_things::Perbill,
      ),
      #[doc = "Min bond threshold was updated (new value)."]
      #[codec(index = 14u8)]
      MinimumBondThresholdUpdated(Option<::polymesh_api_client::IdentityId>, Balance),
      #[doc = "When scheduling of reward payments get interrupted."]
      #[codec(index = 15u8)]
      RewardPaymentSchedulingInterrupted(AccountId, u32, sp_runtime::DispatchError),
      #[doc = "Update for whom balance get slashed."]
      #[codec(index = 16u8)]
      SlashingAllowedForChanged(pallet_staking::SlashingSwitch),
    }
    impl<Balance, AccountId> StakingEvent<Balance, AccountId> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::EraPayout(_, _, _) => "Staking.EraPayout",
          Self::Reward(_, _, _) => "Staking.Reward",
          Self::Slash(_, _) => "Staking.Slash",
          Self::OldSlashingReportDiscarded(_) => "Staking.OldSlashingReportDiscarded",
          Self::StakingElection(_) => "Staking.StakingElection",
          Self::SolutionStored(_) => "Staking.SolutionStored",
          Self::Bonded(_, _, _) => "Staking.Bonded",
          Self::Unbonded(_, _, _) => "Staking.Unbonded",
          Self::Nominated(_, _, _) => "Staking.Nominated",
          Self::Withdrawn(_, _) => "Staking.Withdrawn",
          Self::PermissionedIdentityAdded(_, _) => "Staking.PermissionedIdentityAdded",
          Self::PermissionedIdentityRemoved(_, _) => "Staking.PermissionedIdentityRemoved",
          Self::InvalidatedNominators(_, _, _) => "Staking.InvalidatedNominators",
          Self::CommissionCapUpdated(_, _, _) => "Staking.CommissionCapUpdated",
          Self::MinimumBondThresholdUpdated(_, _) => "Staking.MinimumBondThresholdUpdated",
          Self::RewardPaymentSchedulingInterrupted(_, _, _) => {
            "Staking.RewardPaymentSchedulingInterrupted"
          }
          Self::SlashingAllowedForChanged(_) => "Staking.SlashingAllowedForChanged",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<Balance, AccountId> ::polymesh_api_client::EnumInfo for StakingEvent<Balance, AccountId> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: EraPayout (_ , _ , _) => { & ["The era payout has been set; the first balance is the validator-payout; the second is" , "the remainder from the maximum amount of reward." , "\\[era_index, validator_payout, remainder\\]" ,] } , Self :: Reward (_ , _ , _) => { & ["The staker has been rewarded by this amount. \\[stash_identity, stash, amount\\]" ,] } , Self :: Slash (_ , _) => { & ["One validator (and its nominators) has been slashed by the given amount." , "\\[validator, amount\\]" ,] } , Self :: OldSlashingReportDiscarded (_) => { & ["An old slashing report from a prior era was discarded because it could" , "not be processed. \\[session_index\\]" ,] } , Self :: StakingElection (_) => { & ["A new set of stakers was elected with the given \\[compute\\]." ,] } , Self :: SolutionStored (_) => { & ["A new solution for the upcoming election has been stored. \\[compute\\]" ,] } , Self :: Bonded (_ , _ , _) => { & ["An account has bonded this amount. \\[did, stash, amount\\]" , "" , "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably," , "it will not be emitted for staking rewards when they are added to stake." ,] } , Self :: Unbonded (_ , _ , _) => { & ["An account has unbonded this amount. \\[did, stash, amount\\]" ,] } , Self :: Nominated (_ , _ , _) => { & ["User has updated their nominations" ,] } , Self :: Withdrawn (_ , _) => { & ["An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`" , "from the unlocking queue. \\[stash, amount\\]" ,] } , Self :: PermissionedIdentityAdded (_ , _) => { & ["An DID has issued a candidacy. See the transaction for who." , "GC identity , Validator's identity." ,] } , Self :: PermissionedIdentityRemoved (_ , _) => { & ["The given member was removed. See the transaction for who." , "GC identity , Validator's identity." ,] } , Self :: InvalidatedNominators (_ , _ , _) => { & ["Remove the nominators from the valid nominators when there CDD expired." , "Caller, Stash accountId of nominators" ,] } , Self :: CommissionCapUpdated (_ , _ , _) => { & ["When commission cap get updated." , "(old value, new value)" ,] } , Self :: MinimumBondThresholdUpdated (_ , _) => { & ["Min bond threshold was updated (new value)." ,] } , Self :: RewardPaymentSchedulingInterrupted (_ , _ , _) => { & ["When scheduling of reward payments get interrupted." ,] } , Self :: SlashingAllowedForChanged (_) => { & ["Update for whom balance get slashed." ,] } , _ => & [""] , }
      }
    }
    impl<Balance, AccountId> From<StakingEvent<Balance, AccountId>> for &'static str {
      fn from(v: StakingEvent<Balance, AccountId>) -> Self {
        v.as_static_str()
      }
    }
    impl<Balance, AccountId> From<&StakingEvent<Balance, AccountId>> for &'static str {
      fn from(v: &StakingEvent<Balance, AccountId>) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_balances {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct BalanceLock<Balance> {
      pub id: [u8; 8usize],
      pub amount: Balance,
      pub reasons: polymesh_common_utilities::traits::balances::Reasons,
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BalancesCall {
      #[doc = "Transfer some liquid free balance to another account."]
      #[doc = ""]
      #[doc = "`transfer` will set the `FreeBalance` of the sender and receiver."]
      #[doc = "It will decrease the total issuance of the system by the `TransferFee`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Dependent on arguments but not critical, given proper implementations for"]
      #[doc = "  input config types. See related functions below."]
      #[doc = "- It contains a limited number of reads and writes internally and no complex computation."]
      #[doc = ""]
      #[doc = "Related functions:"]
      #[doc = ""]
      #[doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."]
      #[doc = "  - Transferring balances to accounts that did not exist before will cause"]
      #[doc = "     `T::OnNewAccount::on_new_account` to be called."]
      #[doc = "---------------------------------"]
      #[doc = "- Base Weight: 73.64 s, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[codec(index = 0u8)]
      transfer {
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        #[codec(compact)]
        value: u128,
      },
      #[doc = "Transfer the native currency with the help of identifier string"]
      #[doc = "this functionality can help to differentiate the transfers."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Base Weight: 73.64 s, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[codec(index = 1u8)]
      transfer_with_memo {
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        #[codec(compact)]
        value: u128,
        memo: Option<polymesh_primitives::Memo>,
      },
      #[doc = "Move some POLYX from balance of self to balance of BRR."]
      #[codec(index = 2u8)]
      deposit_block_reward_reserve_balance {
        #[codec(compact)]
        value: u128,
      },
      #[doc = "Set the balances of a given account."]
      #[doc = ""]
      #[doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"]
      #[doc = "also decrease the total issuance of the system (`TotalIssuance`)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call is `root`."]
      #[codec(index = 3u8)]
      set_balance {
        who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        #[codec(compact)]
        new_free: u128,
        #[codec(compact)]
        new_reserved: u128,
      },
      #[doc = "Exactly as `transfer`, except the origin must be root and the source account may be"]
      #[doc = "specified."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Same as transfer, but additional read and write because the source account is"]
      #[doc = "  not assumed to be in the overlay."]
      #[doc = "# </weight>"]
      #[codec(index = 4u8)]
      force_transfer {
        source: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        #[codec(compact)]
        value: u128,
      },
      #[doc = "Burns the given amount of tokens from the caller's free, unlocked balance."]
      #[codec(index = 5u8)]
      burn_account_balance { amount: u128 },
    }
    impl BalancesCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::transfer { .. } => "Balances.transfer",
          Self::transfer_with_memo { .. } => "Balances.transfer_with_memo",
          Self::deposit_block_reward_reserve_balance { .. } => {
            "Balances.deposit_block_reward_reserve_balance"
          }
          Self::set_balance { .. } => "Balances.set_balance",
          Self::force_transfer { .. } => "Balances.force_transfer",
          Self::burn_account_balance { .. } => "Balances.burn_account_balance",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for BalancesCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: transfer { .. } => { & ["Transfer some liquid free balance to another account." , "" , "`transfer` will set the `FreeBalance` of the sender and receiver." , "It will decrease the total issuance of the system by the `TransferFee`." , "" , "The dispatch origin for this call must be `Signed` by the transactor." , "" , "# <weight>" , "- Dependent on arguments but not critical, given proper implementations for" , "  input config types. See related functions below." , "- It contains a limited number of reads and writes internally and no complex computation." , "" , "Related functions:" , "" , "  - `ensure_can_withdraw` is always called internally but has a bounded complexity." , "  - Transferring balances to accounts that did not exist before will cause" , "     `T::OnNewAccount::on_new_account` to be called." , "---------------------------------" , "- Base Weight: 73.64 s, worst case scenario (account created, account removed)" , "- DB Weight: 1 Read and 1 Write to destination account." , "- Origin account is already in memory, so no DB operations for them." , "# </weight>" ,] } , Self :: transfer_with_memo { .. } => { & ["Transfer the native currency with the help of identifier string" , "this functionality can help to differentiate the transfers." , "" , "# <weight>" , "- Base Weight: 73.64 s, worst case scenario (account created, account removed)" , "- DB Weight: 1 Read and 1 Write to destination account." , "- Origin account is already in memory, so no DB operations for them." , "# </weight>" ,] } , Self :: deposit_block_reward_reserve_balance { .. } => { & ["Move some POLYX from balance of self to balance of BRR." ,] } , Self :: set_balance { .. } => { & ["Set the balances of a given account." , "" , "This will alter `FreeBalance` and `ReservedBalance` in storage. it will" , "also decrease the total issuance of the system (`TotalIssuance`)." , "" , "The dispatch origin for this call is `root`." ,] } , Self :: force_transfer { .. } => { & ["Exactly as `transfer`, except the origin must be root and the source account may be" , "specified." , "" , "# <weight>" , "- Same as transfer, but additional read and write because the source account is" , "  not assumed to be in the overlay." , "# </weight>" ,] } , Self :: burn_account_balance { .. } => { & ["Burns the given amount of tokens from the caller's free, unlocked balance." ,] } , _ => & [""] , }
      }
    }
    impl From<BalancesCall> for &'static str {
      fn from(v: BalancesCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&BalancesCall> for &'static str {
      fn from(v: &BalancesCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum BalancesError {
      #[doc = "Account liquidity restrictions prevent withdrawal"]
      #[codec(index = 0u8)]
      LiquidityRestrictions,
      #[doc = "Got an overflow after adding"]
      #[codec(index = 1u8)]
      Overflow,
      #[doc = "Balance too low to send value"]
      #[codec(index = 2u8)]
      InsufficientBalance,
      #[doc = "Value too low to create account due to existential deposit"]
      #[codec(index = 3u8)]
      ExistentialDeposit,
      #[doc = "Receiver does not have a valid CDD"]
      #[codec(index = 4u8)]
      ReceiverCddMissing,
    }
    impl BalancesError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::LiquidityRestrictions => "Balances.LiquidityRestrictions",
          Self::Overflow => "Balances.Overflow",
          Self::InsufficientBalance => "Balances.InsufficientBalance",
          Self::ExistentialDeposit => "Balances.ExistentialDeposit",
          Self::ReceiverCddMissing => "Balances.ReceiverCddMissing",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for BalancesError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::LiquidityRestrictions => &["Account liquidity restrictions prevent withdrawal"],
          Self::Overflow => &["Got an overflow after adding"],
          Self::InsufficientBalance => &["Balance too low to send value"],
          Self::ExistentialDeposit => {
            &["Value too low to create account due to existential deposit"]
          }
          Self::ReceiverCddMissing => &["Receiver does not have a valid CDD"],
          _ => &[""],
        }
      }
    }
    impl From<BalancesError> for &'static str {
      fn from(v: BalancesError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&BalancesError> for &'static str {
      fn from(v: &BalancesError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_grandpa {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum GrandpaCall {
        #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
        #[doc = "equivocation proof and validate the given key ownership proof"]
        #[doc = "against the extracted offender. If both are valid, the offence"]
        #[doc = "will be reported."]
        #[codec(index = 0u8)]
        report_equivocation {
          equivocation_proof: ::alloc::boxed::Box<
            sp_consensus_grandpa::EquivocationProof<primitive_types::H256, u32>,
          >,
          key_owner_proof: sp_session::MembershipProof,
        },
        #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
        #[doc = "equivocation proof and validate the given key ownership proof"]
        #[doc = "against the extracted offender. If both are valid, the offence"]
        #[doc = "will be reported."]
        #[doc = ""]
        #[doc = "This extrinsic must be called unsigned and it is expected that only"]
        #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
        #[doc = "if the block author is defined it will be defined as the equivocation"]
        #[doc = "reporter."]
        #[codec(index = 1u8)]
        report_equivocation_unsigned {
          equivocation_proof: ::alloc::boxed::Box<
            sp_consensus_grandpa::EquivocationProof<primitive_types::H256, u32>,
          >,
          key_owner_proof: sp_session::MembershipProof,
        },
        #[doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."]
        #[doc = ""]
        #[doc = "This will trigger a forced authority set change at the beginning of the next session, to"]
        #[doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"]
        #[doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."]
        #[doc = "The block production rate (which may be slowed down because of finality lagging) should"]
        #[doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"]
        #[doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"]
        #[doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"]
        #[doc = "block of all validators of the new authority set."]
        #[doc = ""]
        #[doc = "Only callable by root."]
        #[codec(index = 2u8)]
        note_stalled {
          delay: u32,
          best_finalized_block_number: u32,
        },
      }
      impl GrandpaCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::report_equivocation { .. } => "Grandpa.report_equivocation",
            Self::report_equivocation_unsigned { .. } => "Grandpa.report_equivocation_unsigned",
            Self::note_stalled { .. } => "Grandpa.note_stalled",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for GrandpaCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: report_equivocation { .. } => { & ["Report voter equivocation/misbehavior. This method will verify the" , "equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence" , "will be reported." ,] } , Self :: report_equivocation_unsigned { .. } => { & ["Report voter equivocation/misbehavior. This method will verify the" , "equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence" , "will be reported." , "" , "This extrinsic must be called unsigned and it is expected that only" , "block authors will call it (validated in `ValidateUnsigned`), as such" , "if the block author is defined it will be defined as the equivocation" , "reporter." ,] } , Self :: note_stalled { .. } => { & ["Note that the current authority set of the GRANDPA finality gadget has stalled." , "" , "This will trigger a forced authority set change at the beginning of the next session, to" , "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume" , "that the block signalling the forced change will not be re-orged e.g. 1000 blocks." , "The block production rate (which may be slowed down because of finality lagging) should" , "be taken into account when choosing the `delay`. The GRANDPA voters based on the new" , "authority will start voting on top of `best_finalized_block_number` for new finalized" , "blocks. `best_finalized_block_number` should be the highest of the latest finalized" , "block of all validators of the new authority set." , "" , "Only callable by root." ,] } , _ => & [""] , }
        }
      }
      impl From<GrandpaCall> for &'static str {
        fn from(v: GrandpaCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&GrandpaCall> for &'static str {
        fn from(v: &GrandpaCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum GrandpaError {
        #[doc = "Attempt to signal GRANDPA pause when the authority set isn't live"]
        #[doc = "(either paused or already pending pause)."]
        #[codec(index = 0u8)]
        PauseFailed,
        #[doc = "Attempt to signal GRANDPA resume when the authority set isn't paused"]
        #[doc = "(either live or already pending resume)."]
        #[codec(index = 1u8)]
        ResumeFailed,
        #[doc = "Attempt to signal GRANDPA change with one already pending."]
        #[codec(index = 2u8)]
        ChangePending,
        #[doc = "Cannot signal forced change so soon after last."]
        #[codec(index = 3u8)]
        TooSoon,
        #[doc = "A key ownership proof provided as part of an equivocation report is invalid."]
        #[codec(index = 4u8)]
        InvalidKeyOwnershipProof,
        #[doc = "An equivocation proof provided as part of an equivocation report is invalid."]
        #[codec(index = 5u8)]
        InvalidEquivocationProof,
        #[doc = "A given equivocation report is valid but already previously reported."]
        #[codec(index = 6u8)]
        DuplicateOffenceReport,
      }
      impl GrandpaError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::PauseFailed => "Grandpa.PauseFailed",
            Self::ResumeFailed => "Grandpa.ResumeFailed",
            Self::ChangePending => "Grandpa.ChangePending",
            Self::TooSoon => "Grandpa.TooSoon",
            Self::InvalidKeyOwnershipProof => "Grandpa.InvalidKeyOwnershipProof",
            Self::InvalidEquivocationProof => "Grandpa.InvalidEquivocationProof",
            Self::DuplicateOffenceReport => "Grandpa.DuplicateOffenceReport",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for GrandpaError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::PauseFailed => &[
              "Attempt to signal GRANDPA pause when the authority set isn't live",
              "(either paused or already pending pause).",
            ],
            Self::ResumeFailed => &[
              "Attempt to signal GRANDPA resume when the authority set isn't paused",
              "(either live or already pending resume).",
            ],
            Self::ChangePending => &["Attempt to signal GRANDPA change with one already pending."],
            Self::TooSoon => &["Cannot signal forced change so soon after last."],
            Self::InvalidKeyOwnershipProof => {
              &["A key ownership proof provided as part of an equivocation report is invalid."]
            }
            Self::InvalidEquivocationProof => {
              &["An equivocation proof provided as part of an equivocation report is invalid."]
            }
            Self::DuplicateOffenceReport => {
              &["A given equivocation report is valid but already previously reported."]
            }
            _ => &[""],
          }
        }
      }
      impl From<GrandpaError> for &'static str {
        fn from(v: GrandpaError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&GrandpaError> for &'static str {
        fn from(v: &GrandpaError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum GrandpaEvent {
        #[doc = "New authority set has been applied."]
        #[codec(index = 0u8)]
        NewAuthorities {
          authority_set: ::alloc::vec::Vec<(sp_consensus_grandpa::app::Public, u64)>,
        },
        #[doc = "Current authority set has been paused."]
        #[codec(index = 1u8)]
        Paused,
        #[doc = "Current authority set has been resumed."]
        #[codec(index = 2u8)]
        Resumed,
      }
      impl GrandpaEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::NewAuthorities { .. } => "Grandpa.NewAuthorities",
            Self::Paused => "Grandpa.Paused",
            Self::Resumed => "Grandpa.Resumed",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for GrandpaEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::NewAuthorities { .. } => &["New authority set has been applied."],
            Self::Paused => &["Current authority set has been paused."],
            Self::Resumed => &["Current authority set has been resumed."],
            _ => &[""],
          }
        }
      }
      impl From<GrandpaEvent> for &'static str {
        fn from(v: GrandpaEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&GrandpaEvent> for &'static str {
        fn from(v: &GrandpaEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct StoredPendingChange<N> {
      pub scheduled_at: N,
      pub delay: N,
      pub next_authorities: bounded_collections::weak_bounded_vec::WeakBoundedVec<(
        sp_consensus_grandpa::app::Public,
        u64,
      )>,
      pub forced: Option<N>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StoredState<N> {
      #[codec(index = 0u8)]
      Live,
      #[codec(index = 1u8)]
      PendingPause { scheduled_at: N, delay: N },
      #[codec(index = 2u8)]
      Paused,
      #[codec(index = 3u8)]
      PendingResume { scheduled_at: N, delay: N },
    }
  }
  pub mod pallet_pips {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum SnapshotResult {
      #[codec(index = 0u8)]
      Approve,
      #[codec(index = 1u8)]
      Reject,
      #[codec(index = 2u8)]
      Skip,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PipDescription(pub ::alloc::vec::Vec<u8>);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct DepositInfo<AccountId> {
      pub owner: AccountId,
      pub amount: u128,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PipId(pub u32);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct SnapshottedPip {
      pub id: pallet_pips::PipId,
      pub weight: (bool, u128),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct SnapshotId(pub u32);
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PipsCall {
      #[doc = "Change whether completed PIPs are pruned."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `prune` specifies whether completed PIPs should be pruned."]
      #[codec(index = 0u8)]
      set_prune_historical_pips { prune: bool },
      #[doc = "Change the minimum proposal deposit amount required to start a proposal."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `deposit` the new min deposit required to start a proposal"]
      #[codec(index = 1u8)]
      set_min_proposal_deposit { deposit: u128 },
      #[doc = "Change the default enactment period."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `duration` the new default enactment period it takes for a scheduled PIP to be executed."]
      #[codec(index = 2u8)]
      set_default_enactment_period { duration: u32 },
      #[doc = "Change the amount of blocks after which a pending PIP is expired."]
      #[doc = "If `expiry` is `None` then PIPs never expire."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` the block-time it takes for a still-`Pending` PIP to expire."]
      #[codec(index = 3u8)]
      set_pending_pip_expiry {
        expiry: polymesh_common_utilities::MaybeBlock<u32>,
      },
      #[doc = "Change the maximum skip count (`max_pip_skip_count`)."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `max` skips before a PIP cannot be skipped by GC anymore."]
      #[codec(index = 4u8)]
      set_max_pip_skip_count { max: u8 },
      #[doc = "Change the maximum number of active PIPs before community members cannot propose anything."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` of concurrent active PIPs."]
      #[codec(index = 5u8)]
      set_active_pip_limit { limit: u32 },
      #[doc = "A network member creates a PIP by submitting a dispatchable which"]
      #[doc = "changes the network in someway. A minimum deposit is required to open a new proposal."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposer` is either a signing key or committee."]
      #[doc = "   Used to understand whether this is a committee proposal and verified against `origin`."]
      #[doc = "* `proposal` a dispatchable call"]
      #[doc = "* `deposit` minimum deposit value, which is ignored if `proposer` is a committee."]
      #[doc = "* `url` a link to a website for proposal discussion"]
      #[codec(index = 6u8)]
      propose {
        proposal: ::alloc::boxed::Box<runtime::RuntimeCall>,
        deposit: u128,
        url: Option<polymesh_primitives::Url>,
        description: Option<pallet_pips::PipDescription>,
      },
      #[doc = "Vote either in favor (`aye_or_nay` == true) or against a PIP with `id`."]
      #[doc = "The \"convinction\" or strength of the vote is given by `deposit`, which is reserved."]
      #[doc = ""]
      #[doc = "Note that `vote` is *not* additive."]
      #[doc = "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`"]
      #[doc = "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit."]
      #[doc = "To add atop of existing votes, you'll need `existing_deposit + addition`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`, proposal id"]
      #[doc = "* `aye_or_nay`, a bool representing for or against vote"]
      #[doc = "* `deposit`, the \"conviction\" with which the vote is made."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchProposal` if `id` doesn't reference a valid PIP."]
      #[doc = "* `NotFromCommunity` if proposal was made by a committee."]
      #[doc = "* `IncorrectProposalState` if PIP isn't pending."]
      #[doc = "* `InsufficientDeposit` if `origin` cannot reserve `deposit - old_deposit`."]
      #[codec(index = 7u8)]
      vote {
        id: pallet_pips::PipId,
        aye_or_nay: bool,
        deposit: u128,
      },
      #[doc = "Approves the pending committee PIP given by the `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal isn't pending."]
      #[doc = "* `NotByCommittee` if the proposal isn't by a committee."]
      #[codec(index = 8u8)]
      approve_committee_proposal { id: pallet_pips::PipId },
      #[doc = "Rejects the PIP given by the `id`, refunding any bonded funds,"]
      #[doc = "assuming it hasn't been cancelled or executed."]
      #[doc = "Note that proposals scheduled-for-execution can also be rejected."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal was cancelled or executed."]
      #[codec(index = 9u8)]
      reject_proposal { id: pallet_pips::PipId },
      #[doc = "Prune the PIP given by the `id`, refunding any funds not already refunded."]
      #[doc = "The PIP may not be active"]
      #[doc = ""]
      #[doc = "This function is intended for storage garbage collection purposes."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal is active."]
      #[codec(index = 10u8)]
      prune_proposal { id: pallet_pips::PipId },
      #[doc = "Updates the execution schedule of the PIP given by `id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `until` defines the future block where the enactment period will finished."]
      #[doc = "   `None` value means that enactment period is going to finish in the next block."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `RescheduleNotByReleaseCoordinator` unless triggered by release coordinator."]
      #[doc = "* `IncorrectProposalState` unless the proposal was in a scheduled state."]
      #[codec(index = 11u8)]
      reschedule_execution {
        id: pallet_pips::PipId,
        until: Option<u32>,
      },
      #[doc = "Clears the snapshot and emits the event `SnapshotCleared`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[codec(index = 12u8)]
      clear_snapshot,
      #[doc = "Takes a new snapshot of the current list of active && pending PIPs."]
      #[doc = "The PIPs are then sorted into a priority queue based on each PIP's weight."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[codec(index = 13u8)]
      snapshot,
      #[doc = "Enacts `results` for the PIPs in the snapshot queue."]
      #[doc = "The snapshot will be available for further enactments until it is cleared."]
      #[doc = ""]
      #[doc = "The `results` are encoded a list of `(id, result)` where `result` is applied to `id`."]
      #[doc = "Note that the snapshot priority queue is encoded with the *lowest priority first*."]
      #[doc = "so `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - unless a GC voting majority executes this function."]
      #[doc = "* `CannotSkipPip` - a given PIP has already been skipped too many times."]
      #[doc = "* `SnapshotResultTooLarge` - on len(results) > len(snapshot_queue)."]
      #[doc = "* `SnapshotIdMismatch` - if:"]
      #[doc = "  ```text"]
      #[doc = "    (i  0..SnapshotQueue.len())."]
      #[doc = "     results[i].0  SnapshotQueue[SnapshotQueue.len() - i].id"]
      #[doc = "  ```"]
      #[doc = "   This is protects against clearing queue while GC is voting."]
      #[codec(index = 14u8)]
      enact_snapshot_results {
        results: ::alloc::vec::Vec<(pallet_pips::PipId, pallet_pips::SnapshotResult)>,
      },
      #[doc = "Internal dispatchable that handles execution of a PIP."]
      #[codec(index = 15u8)]
      execute_scheduled_pip { id: pallet_pips::PipId },
      #[doc = "Internal dispatchable that handles expiration of a PIP."]
      #[codec(index = 16u8)]
      expire_scheduled_pip {
        did: ::polymesh_api_client::IdentityId,
        id: pallet_pips::PipId,
      },
    }
    impl PipsCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::set_prune_historical_pips { .. } => "Pips.set_prune_historical_pips",
          Self::set_min_proposal_deposit { .. } => "Pips.set_min_proposal_deposit",
          Self::set_default_enactment_period { .. } => "Pips.set_default_enactment_period",
          Self::set_pending_pip_expiry { .. } => "Pips.set_pending_pip_expiry",
          Self::set_max_pip_skip_count { .. } => "Pips.set_max_pip_skip_count",
          Self::set_active_pip_limit { .. } => "Pips.set_active_pip_limit",
          Self::propose { .. } => "Pips.propose",
          Self::vote { .. } => "Pips.vote",
          Self::approve_committee_proposal { .. } => "Pips.approve_committee_proposal",
          Self::reject_proposal { .. } => "Pips.reject_proposal",
          Self::prune_proposal { .. } => "Pips.prune_proposal",
          Self::reschedule_execution { .. } => "Pips.reschedule_execution",
          Self::clear_snapshot => "Pips.clear_snapshot",
          Self::snapshot => "Pips.snapshot",
          Self::enact_snapshot_results { .. } => "Pips.enact_snapshot_results",
          Self::execute_scheduled_pip { .. } => "Pips.execute_scheduled_pip",
          Self::expire_scheduled_pip { .. } => "Pips.expire_scheduled_pip",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PipsCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: set_prune_historical_pips { .. } => { & ["Change whether completed PIPs are pruned." , "Can only be called by root." , "" , "# Arguments" , "* `prune` specifies whether completed PIPs should be pruned." ,] } , Self :: set_min_proposal_deposit { .. } => { & ["Change the minimum proposal deposit amount required to start a proposal." , "Can only be called by root." , "" , "# Arguments" , "* `deposit` the new min deposit required to start a proposal" ,] } , Self :: set_default_enactment_period { .. } => { & ["Change the default enactment period." , "Can only be called by root." , "" , "# Arguments" , "* `duration` the new default enactment period it takes for a scheduled PIP to be executed." ,] } , Self :: set_pending_pip_expiry { .. } => { & ["Change the amount of blocks after which a pending PIP is expired." , "If `expiry` is `None` then PIPs never expire." , "Can only be called by root." , "" , "# Arguments" , "* `expiry` the block-time it takes for a still-`Pending` PIP to expire." ,] } , Self :: set_max_pip_skip_count { .. } => { & ["Change the maximum skip count (`max_pip_skip_count`)." , "Can only be called by root." , "" , "# Arguments" , "* `max` skips before a PIP cannot be skipped by GC anymore." ,] } , Self :: set_active_pip_limit { .. } => { & ["Change the maximum number of active PIPs before community members cannot propose anything." , "Can only be called by root." , "" , "# Arguments" , "* `limit` of concurrent active PIPs." ,] } , Self :: propose { .. } => { & ["A network member creates a PIP by submitting a dispatchable which" , "changes the network in someway. A minimum deposit is required to open a new proposal." , "" , "# Arguments" , "* `proposer` is either a signing key or committee." , "   Used to understand whether this is a committee proposal and verified against `origin`." , "* `proposal` a dispatchable call" , "* `deposit` minimum deposit value, which is ignored if `proposer` is a committee." , "* `url` a link to a website for proposal discussion" ,] } , Self :: vote { .. } => { & ["Vote either in favor (`aye_or_nay` == true) or against a PIP with `id`." , "The \"convinction\" or strength of the vote is given by `deposit`, which is reserved." , "" , "Note that `vote` is *not* additive." , "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`" , "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit." , "To add atop of existing votes, you'll need `existing_deposit + addition`." , "" , "# Arguments" , "* `id`, proposal id" , "* `aye_or_nay`, a bool representing for or against vote" , "* `deposit`, the \"conviction\" with which the vote is made." , "" , "# Errors" , "* `NoSuchProposal` if `id` doesn't reference a valid PIP." , "* `NotFromCommunity` if proposal was made by a committee." , "* `IncorrectProposalState` if PIP isn't pending." , "* `InsufficientDeposit` if `origin` cannot reserve `deposit - old_deposit`." ,] } , Self :: approve_committee_proposal { .. } => { & ["Approves the pending committee PIP given by the `id`." , "" , "# Errors" , "* `BadOrigin` unless a GC voting majority executes this function." , "* `NoSuchProposal` if the PIP with `id` doesn't exist." , "* `IncorrectProposalState` if the proposal isn't pending." , "* `NotByCommittee` if the proposal isn't by a committee." ,] } , Self :: reject_proposal { .. } => { & ["Rejects the PIP given by the `id`, refunding any bonded funds," , "assuming it hasn't been cancelled or executed." , "Note that proposals scheduled-for-execution can also be rejected." , "" , "# Errors" , "* `BadOrigin` unless a GC voting majority executes this function." , "* `NoSuchProposal` if the PIP with `id` doesn't exist." , "* `IncorrectProposalState` if the proposal was cancelled or executed." ,] } , Self :: prune_proposal { .. } => { & ["Prune the PIP given by the `id`, refunding any funds not already refunded." , "The PIP may not be active" , "" , "This function is intended for storage garbage collection purposes." , "" , "# Errors" , "* `BadOrigin` unless a GC voting majority executes this function." , "* `NoSuchProposal` if the PIP with `id` doesn't exist." , "* `IncorrectProposalState` if the proposal is active." ,] } , Self :: reschedule_execution { .. } => { & ["Updates the execution schedule of the PIP given by `id`." , "" , "# Arguments" , "* `until` defines the future block where the enactment period will finished." , "   `None` value means that enactment period is going to finish in the next block." , "" , "# Errors" , "* `RescheduleNotByReleaseCoordinator` unless triggered by release coordinator." , "* `IncorrectProposalState` unless the proposal was in a scheduled state." ,] } , Self :: clear_snapshot => { & ["Clears the snapshot and emits the event `SnapshotCleared`." , "" , "# Errors" , "* `NotACommitteeMember` - triggered when a non-GC-member executes the function." ,] } , Self :: snapshot => { & ["Takes a new snapshot of the current list of active && pending PIPs." , "The PIPs are then sorted into a priority queue based on each PIP's weight." , "" , "# Errors" , "* `NotACommitteeMember` - triggered when a non-GC-member executes the function." ,] } , Self :: enact_snapshot_results { .. } => { & ["Enacts `results` for the PIPs in the snapshot queue." , "The snapshot will be available for further enactments until it is cleared." , "" , "The `results` are encoded a list of `(id, result)` where `result` is applied to `id`." , "Note that the snapshot priority queue is encoded with the *lowest priority first*." , "so `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`." , "" , "# Errors" , "* `BadOrigin` - unless a GC voting majority executes this function." , "* `CannotSkipPip` - a given PIP has already been skipped too many times." , "* `SnapshotResultTooLarge` - on len(results) > len(snapshot_queue)." , "* `SnapshotIdMismatch` - if:" , "  ```text" , "    (i  0..SnapshotQueue.len())." , "     results[i].0  SnapshotQueue[SnapshotQueue.len() - i].id" , "  ```" , "   This is protects against clearing queue while GC is voting." ,] } , Self :: execute_scheduled_pip { .. } => { & ["Internal dispatchable that handles execution of a PIP." ,] } , Self :: expire_scheduled_pip { .. } => { & ["Internal dispatchable that handles expiration of a PIP." ,] } , _ => & [""] , }
      }
    }
    impl From<PipsCall> for &'static str {
      fn from(v: PipsCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PipsCall> for &'static str {
      fn from(v: &PipsCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Proposer<AccountId> {
      #[codec(index = 0u8)]
      Community(AccountId),
      #[codec(index = 1u8)]
      Committee(pallet_pips::Committee),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Committee {
      #[codec(index = 0u8)]
      Technical,
      #[codec(index = 1u8)]
      Upgrade,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PipsMetadata<BlockNumber> {
      pub id: pallet_pips::PipId,
      pub url: Option<polymesh_primitives::Url>,
      pub description: Option<pallet_pips::PipDescription>,
      pub created_at: BlockNumber,
      pub transaction_version: BlockNumber,
      pub expiry: polymesh_common_utilities::MaybeBlock<BlockNumber>,
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PipsEvent<AccountId, BlockNumber> {
      #[doc = "Pruning Historical PIPs is enabled or disabled (caller DID, old value, new value)"]
      #[codec(index = 0u8)]
      HistoricalPipsPruned(::polymesh_api_client::IdentityId, bool, bool),
      #[doc = "A PIP was made with a `Balance` stake."]
      #[doc = ""]
      #[doc = "# Parameters:"]
      #[doc = ""]
      #[doc = "Caller DID, Proposer, PIP ID, deposit, URL, description, expiry time, proposal data."]
      #[codec(index = 1u8)]
      ProposalCreated(
        ::polymesh_api_client::IdentityId,
        pallet_pips::Proposer<AccountId>,
        pallet_pips::PipId,
        u128,
        Option<polymesh_primitives::Url>,
        Option<pallet_pips::PipDescription>,
        polymesh_common_utilities::MaybeBlock<BlockNumber>,
        pallet_pips::ProposalData,
      ),
      #[doc = "Triggered each time the state of a proposal is amended"]
      #[codec(index = 2u8)]
      ProposalStateUpdated(
        ::polymesh_api_client::IdentityId,
        pallet_pips::PipId,
        pallet_pips::ProposalState,
      ),
      #[doc = "`AccountId` voted `bool` on the proposal referenced by `PipId`"]
      #[codec(index = 3u8)]
      Voted(
        ::polymesh_api_client::IdentityId,
        AccountId,
        pallet_pips::PipId,
        bool,
        u128,
      ),
      #[doc = "Pip has been closed, bool indicates whether data is pruned"]
      #[codec(index = 4u8)]
      PipClosed(::polymesh_api_client::IdentityId, pallet_pips::PipId, bool),
      #[doc = "Execution of a PIP has been scheduled at specific block."]
      #[codec(index = 5u8)]
      ExecutionScheduled(
        ::polymesh_api_client::IdentityId,
        pallet_pips::PipId,
        BlockNumber,
      ),
      #[doc = "Default enactment period (in blocks) has been changed."]
      #[doc = "(caller DID, old period, new period)"]
      #[codec(index = 6u8)]
      DefaultEnactmentPeriodChanged(::polymesh_api_client::IdentityId, BlockNumber, BlockNumber),
      #[doc = "Minimum deposit amount modified"]
      #[doc = "(caller DID, old amount, new amount)"]
      #[codec(index = 7u8)]
      MinimumProposalDepositChanged(::polymesh_api_client::IdentityId, u128, u128),
      #[doc = "Amount of blocks after which a pending PIP expires."]
      #[doc = "(caller DID, old expiry, new expiry)"]
      #[codec(index = 8u8)]
      PendingPipExpiryChanged(
        ::polymesh_api_client::IdentityId,
        polymesh_common_utilities::MaybeBlock<BlockNumber>,
        polymesh_common_utilities::MaybeBlock<BlockNumber>,
      ),
      #[doc = "The maximum times a PIP can be skipped was changed."]
      #[doc = "(caller DID, old value, new value)"]
      #[codec(index = 9u8)]
      MaxPipSkipCountChanged(::polymesh_api_client::IdentityId, u8, u8),
      #[doc = "The maximum number of active PIPs was changed."]
      #[doc = "(caller DID, old value, new value)"]
      #[codec(index = 10u8)]
      ActivePipLimitChanged(::polymesh_api_client::IdentityId, BlockNumber, BlockNumber),
      #[doc = "Refund proposal"]
      #[doc = "(id, total amount)"]
      #[codec(index = 11u8)]
      ProposalRefund(::polymesh_api_client::IdentityId, pallet_pips::PipId, u128),
      #[doc = "The snapshot was cleared."]
      #[codec(index = 12u8)]
      SnapshotCleared(::polymesh_api_client::IdentityId, pallet_pips::SnapshotId),
      #[doc = "A new snapshot was taken."]
      #[codec(index = 13u8)]
      SnapshotTaken(
        ::polymesh_api_client::IdentityId,
        pallet_pips::SnapshotId,
        ::alloc::vec::Vec<pallet_pips::SnapshottedPip>,
      ),
      #[doc = "A PIP in the snapshot queue was skipped."]
      #[doc = "(gc_did, pip_id, new_skip_count)"]
      #[codec(index = 14u8)]
      PipSkipped(::polymesh_api_client::IdentityId, pallet_pips::PipId, u8),
      #[doc = "Results (e.g., approved, rejected, and skipped), were enacted for some PIPs."]
      #[doc = "(gc_did, snapshot_id_opt, skipped_pips_with_new_count, rejected_pips, approved_pips)"]
      #[codec(index = 15u8)]
      SnapshotResultsEnacted(
        ::polymesh_api_client::IdentityId,
        Option<pallet_pips::SnapshotId>,
        ::alloc::vec::Vec<(pallet_pips::PipId, u8)>,
        ::alloc::vec::Vec<pallet_pips::PipId>,
        ::alloc::vec::Vec<pallet_pips::PipId>,
      ),
      #[doc = "Scheduling of the PIP for execution failed in the scheduler pallet."]
      #[codec(index = 16u8)]
      ExecutionSchedulingFailed(
        ::polymesh_api_client::IdentityId,
        pallet_pips::PipId,
        BlockNumber,
      ),
      #[doc = "The PIP has been scheduled for expiry."]
      #[codec(index = 17u8)]
      ExpiryScheduled(
        ::polymesh_api_client::IdentityId,
        pallet_pips::PipId,
        BlockNumber,
      ),
      #[doc = "Scheduling of the PIP for expiry failed in the scheduler pallet."]
      #[codec(index = 18u8)]
      ExpirySchedulingFailed(
        ::polymesh_api_client::IdentityId,
        pallet_pips::PipId,
        BlockNumber,
      ),
      #[doc = "Cancelling the PIP execution failed in the scheduler pallet."]
      #[codec(index = 19u8)]
      ExecutionCancellingFailed(pallet_pips::PipId),
    }
    impl<AccountId, BlockNumber> PipsEvent<AccountId, BlockNumber> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::HistoricalPipsPruned(_, _, _) => "Pips.HistoricalPipsPruned",
          Self::ProposalCreated(_, _, _, _, _, _, _, _) => "Pips.ProposalCreated",
          Self::ProposalStateUpdated(_, _, _) => "Pips.ProposalStateUpdated",
          Self::Voted(_, _, _, _, _) => "Pips.Voted",
          Self::PipClosed(_, _, _) => "Pips.PipClosed",
          Self::ExecutionScheduled(_, _, _) => "Pips.ExecutionScheduled",
          Self::DefaultEnactmentPeriodChanged(_, _, _) => "Pips.DefaultEnactmentPeriodChanged",
          Self::MinimumProposalDepositChanged(_, _, _) => "Pips.MinimumProposalDepositChanged",
          Self::PendingPipExpiryChanged(_, _, _) => "Pips.PendingPipExpiryChanged",
          Self::MaxPipSkipCountChanged(_, _, _) => "Pips.MaxPipSkipCountChanged",
          Self::ActivePipLimitChanged(_, _, _) => "Pips.ActivePipLimitChanged",
          Self::ProposalRefund(_, _, _) => "Pips.ProposalRefund",
          Self::SnapshotCleared(_, _) => "Pips.SnapshotCleared",
          Self::SnapshotTaken(_, _, _) => "Pips.SnapshotTaken",
          Self::PipSkipped(_, _, _) => "Pips.PipSkipped",
          Self::SnapshotResultsEnacted(_, _, _, _, _) => "Pips.SnapshotResultsEnacted",
          Self::ExecutionSchedulingFailed(_, _, _) => "Pips.ExecutionSchedulingFailed",
          Self::ExpiryScheduled(_, _, _) => "Pips.ExpiryScheduled",
          Self::ExpirySchedulingFailed(_, _, _) => "Pips.ExpirySchedulingFailed",
          Self::ExecutionCancellingFailed(_) => "Pips.ExecutionCancellingFailed",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<AccountId, BlockNumber> ::polymesh_api_client::EnumInfo for PipsEvent<AccountId, BlockNumber> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::HistoricalPipsPruned(_, _, _) => {
            &["Pruning Historical PIPs is enabled or disabled (caller DID, old value, new value)"]
          }
          Self::ProposalCreated(_, _, _, _, _, _, _, _) => &[
            "A PIP was made with a `Balance` stake.",
            "",
            "# Parameters:",
            "",
            "Caller DID, Proposer, PIP ID, deposit, URL, description, expiry time, proposal data.",
          ],
          Self::ProposalStateUpdated(_, _, _) => {
            &["Triggered each time the state of a proposal is amended"]
          }
          Self::Voted(_, _, _, _, _) => {
            &["`AccountId` voted `bool` on the proposal referenced by `PipId`"]
          }
          Self::PipClosed(_, _, _) => {
            &["Pip has been closed, bool indicates whether data is pruned"]
          }
          Self::ExecutionScheduled(_, _, _) => {
            &["Execution of a PIP has been scheduled at specific block."]
          }
          Self::DefaultEnactmentPeriodChanged(_, _, _) => &[
            "Default enactment period (in blocks) has been changed.",
            "(caller DID, old period, new period)",
          ],
          Self::MinimumProposalDepositChanged(_, _, _) => &[
            "Minimum deposit amount modified",
            "(caller DID, old amount, new amount)",
          ],
          Self::PendingPipExpiryChanged(_, _, _) => &[
            "Amount of blocks after which a pending PIP expires.",
            "(caller DID, old expiry, new expiry)",
          ],
          Self::MaxPipSkipCountChanged(_, _, _) => &[
            "The maximum times a PIP can be skipped was changed.",
            "(caller DID, old value, new value)",
          ],
          Self::ActivePipLimitChanged(_, _, _) => &[
            "The maximum number of active PIPs was changed.",
            "(caller DID, old value, new value)",
          ],
          Self::ProposalRefund(_, _, _) => &["Refund proposal", "(id, total amount)"],
          Self::SnapshotCleared(_, _) => &["The snapshot was cleared."],
          Self::SnapshotTaken(_, _, _) => &["A new snapshot was taken."],
          Self::PipSkipped(_, _, _) => &[
            "A PIP in the snapshot queue was skipped.",
            "(gc_did, pip_id, new_skip_count)",
          ],
          Self::SnapshotResultsEnacted(_, _, _, _, _) => &[
            "Results (e.g., approved, rejected, and skipped), were enacted for some PIPs.",
            "(gc_did, snapshot_id_opt, skipped_pips_with_new_count, rejected_pips, approved_pips)",
          ],
          Self::ExecutionSchedulingFailed(_, _, _) => {
            &["Scheduling of the PIP for execution failed in the scheduler pallet."]
          }
          Self::ExpiryScheduled(_, _, _) => &["The PIP has been scheduled for expiry."],
          Self::ExpirySchedulingFailed(_, _, _) => {
            &["Scheduling of the PIP for expiry failed in the scheduler pallet."]
          }
          Self::ExecutionCancellingFailed(_) => {
            &["Cancelling the PIP execution failed in the scheduler pallet."]
          }
          _ => &[""],
        }
      }
    }
    impl<AccountId, BlockNumber> From<PipsEvent<AccountId, BlockNumber>> for &'static str {
      fn from(v: PipsEvent<AccountId, BlockNumber>) -> Self {
        v.as_static_str()
      }
    }
    impl<AccountId, BlockNumber> From<&PipsEvent<AccountId, BlockNumber>> for &'static str {
      fn from(v: &PipsEvent<AccountId, BlockNumber>) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ProposalState {
      #[codec(index = 0u8)]
      Pending,
      #[codec(index = 1u8)]
      Rejected,
      #[codec(index = 2u8)]
      Scheduled,
      #[codec(index = 3u8)]
      Failed,
      #[codec(index = 4u8)]
      Executed,
      #[codec(index = 5u8)]
      Expired,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Pip<Proposal, AccountId> {
      pub id: pallet_pips::PipId,
      pub proposal: Proposal,
      pub proposer: pallet_pips::Proposer<AccountId>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ProposalData {
      #[codec(index = 0u8)]
      Hash(primitive_types::H256),
      #[codec(index = 1u8)]
      Proposal(::alloc::vec::Vec<u8>),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct VotingResult {
      pub ayes_count: u32,
      pub ayes_stake: u128,
      pub nays_count: u32,
      pub nays_stake: u128,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Vote(pub bool, pub u128);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct SnapshotMetadata<BlockNumber, AccountId> {
      pub created_at: BlockNumber,
      pub made_by: AccountId,
      pub id: pallet_pips::SnapshotId,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PipsError {
      #[doc = "Only the GC release coordinator is allowed to reschedule proposal execution."]
      #[codec(index = 0u8)]
      RescheduleNotByReleaseCoordinator,
      #[doc = "The given dispatchable call is not valid for this proposal."]
      #[doc = "The proposal must be from the community, but isn't."]
      #[codec(index = 1u8)]
      NotFromCommunity,
      #[doc = "The given dispatchable call is not valid for this proposal."]
      #[doc = "The proposal must be by community, but isn't."]
      #[codec(index = 2u8)]
      NotByCommittee,
      #[doc = "The current number of active (pending | scheduled) PIPs exceed the maximum"]
      #[doc = "and the proposal is not by a committee."]
      #[codec(index = 3u8)]
      TooManyActivePips,
      #[doc = "Proposer specifies an incorrect deposit"]
      #[codec(index = 4u8)]
      IncorrectDeposit,
      #[doc = "Proposer can't afford to lock minimum deposit"]
      #[codec(index = 5u8)]
      InsufficientDeposit,
      #[doc = "The proposal does not exist."]
      #[codec(index = 6u8)]
      NoSuchProposal,
      #[doc = "Not part of governance committee."]
      #[codec(index = 7u8)]
      NotACommitteeMember,
      #[doc = "When a block number is less than current block number."]
      #[codec(index = 8u8)]
      InvalidFutureBlockNumber,
      #[doc = "When number of votes overflows."]
      #[codec(index = 9u8)]
      NumberOfVotesExceeded,
      #[doc = "When stake amount of a vote overflows."]
      #[codec(index = 10u8)]
      StakeAmountOfVotesExceeded,
      #[doc = "Missing current DID"]
      #[codec(index = 11u8)]
      MissingCurrentIdentity,
      #[doc = "Proposal is not in the correct state"]
      #[codec(index = 12u8)]
      IncorrectProposalState,
      #[doc = "When enacting snapshot results, an unskippable PIP was skipped."]
      #[codec(index = 13u8)]
      CannotSkipPip,
      #[doc = "Tried to enact results for the snapshot queue overflowing its length."]
      #[codec(index = 14u8)]
      SnapshotResultTooLarge,
      #[doc = "Tried to enact result for PIP with id different from that at the position in the queue."]
      #[codec(index = 15u8)]
      SnapshotIdMismatch,
      #[doc = "Execution of a scheduled proposal failed because it is missing."]
      #[codec(index = 16u8)]
      ScheduledProposalDoesntExist,
      #[doc = "A proposal that is not in a scheduled state cannot be executed."]
      #[codec(index = 17u8)]
      ProposalNotInScheduledState,
    }
    impl PipsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::RescheduleNotByReleaseCoordinator => "Pips.RescheduleNotByReleaseCoordinator",
          Self::NotFromCommunity => "Pips.NotFromCommunity",
          Self::NotByCommittee => "Pips.NotByCommittee",
          Self::TooManyActivePips => "Pips.TooManyActivePips",
          Self::IncorrectDeposit => "Pips.IncorrectDeposit",
          Self::InsufficientDeposit => "Pips.InsufficientDeposit",
          Self::NoSuchProposal => "Pips.NoSuchProposal",
          Self::NotACommitteeMember => "Pips.NotACommitteeMember",
          Self::InvalidFutureBlockNumber => "Pips.InvalidFutureBlockNumber",
          Self::NumberOfVotesExceeded => "Pips.NumberOfVotesExceeded",
          Self::StakeAmountOfVotesExceeded => "Pips.StakeAmountOfVotesExceeded",
          Self::MissingCurrentIdentity => "Pips.MissingCurrentIdentity",
          Self::IncorrectProposalState => "Pips.IncorrectProposalState",
          Self::CannotSkipPip => "Pips.CannotSkipPip",
          Self::SnapshotResultTooLarge => "Pips.SnapshotResultTooLarge",
          Self::SnapshotIdMismatch => "Pips.SnapshotIdMismatch",
          Self::ScheduledProposalDoesntExist => "Pips.ScheduledProposalDoesntExist",
          Self::ProposalNotInScheduledState => "Pips.ProposalNotInScheduledState",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PipsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: RescheduleNotByReleaseCoordinator => { & ["Only the GC release coordinator is allowed to reschedule proposal execution." ,] } , Self :: NotFromCommunity => { & ["The given dispatchable call is not valid for this proposal." , "The proposal must be from the community, but isn't." ,] } , Self :: NotByCommittee => { & ["The given dispatchable call is not valid for this proposal." , "The proposal must be by community, but isn't." ,] } , Self :: TooManyActivePips => { & ["The current number of active (pending | scheduled) PIPs exceed the maximum" , "and the proposal is not by a committee." ,] } , Self :: IncorrectDeposit => { & ["Proposer specifies an incorrect deposit" ,] } , Self :: InsufficientDeposit => { & ["Proposer can't afford to lock minimum deposit" ,] } , Self :: NoSuchProposal => { & ["The proposal does not exist." ,] } , Self :: NotACommitteeMember => { & ["Not part of governance committee." ,] } , Self :: InvalidFutureBlockNumber => { & ["When a block number is less than current block number." ,] } , Self :: NumberOfVotesExceeded => { & ["When number of votes overflows." ,] } , Self :: StakeAmountOfVotesExceeded => { & ["When stake amount of a vote overflows." ,] } , Self :: MissingCurrentIdentity => { & ["Missing current DID" ,] } , Self :: IncorrectProposalState => { & ["Proposal is not in the correct state" ,] } , Self :: CannotSkipPip => { & ["When enacting snapshot results, an unskippable PIP was skipped." ,] } , Self :: SnapshotResultTooLarge => { & ["Tried to enact results for the snapshot queue overflowing its length." ,] } , Self :: SnapshotIdMismatch => { & ["Tried to enact result for PIP with id different from that at the position in the queue." ,] } , Self :: ScheduledProposalDoesntExist => { & ["Execution of a scheduled proposal failed because it is missing." ,] } , Self :: ProposalNotInScheduledState => { & ["A proposal that is not in a scheduled state cannot be executed." ,] } , _ => & [""] , }
      }
    }
    impl From<PipsError> for &'static str {
      fn from(v: PipsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PipsError> for &'static str {
      fn from(v: &PipsError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod primitive_types {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct H512(
      #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))] pub [u8; 64usize],
    );
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct H256(pub [u8; 32usize]);
  }
  pub mod sp_authority_discovery {
    use super::*;
    pub mod app {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Public(pub sp_core::sr25519::Public);
    }
  }
  pub mod pallet_scheduler {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SchedulerError {
        #[doc = "Failed to schedule a call"]
        #[codec(index = 0u8)]
        FailedToSchedule,
        #[doc = "Cannot find the scheduled call."]
        #[codec(index = 1u8)]
        NotFound,
        #[doc = "Given target block number is in the past."]
        #[codec(index = 2u8)]
        TargetBlockNumberInPast,
        #[doc = "Reschedule failed because it does not change scheduled time."]
        #[codec(index = 3u8)]
        RescheduleNoChange,
        #[doc = "Attempt to use a non-named function on a named task."]
        #[codec(index = 4u8)]
        Named,
      }
      impl SchedulerError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::FailedToSchedule => "Scheduler.FailedToSchedule",
            Self::NotFound => "Scheduler.NotFound",
            Self::TargetBlockNumberInPast => "Scheduler.TargetBlockNumberInPast",
            Self::RescheduleNoChange => "Scheduler.RescheduleNoChange",
            Self::Named => "Scheduler.Named",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SchedulerError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::FailedToSchedule => &["Failed to schedule a call"],
            Self::NotFound => &["Cannot find the scheduled call."],
            Self::TargetBlockNumberInPast => &["Given target block number is in the past."],
            Self::RescheduleNoChange => {
              &["Reschedule failed because it does not change scheduled time."]
            }
            Self::Named => &["Attempt to use a non-named function on a named task."],
            _ => &[""],
          }
        }
      }
      impl From<SchedulerError> for &'static str {
        fn from(v: SchedulerError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SchedulerError> for &'static str {
        fn from(v: &SchedulerError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Events type."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SchedulerEvent {
        #[doc = "Scheduled some task."]
        #[codec(index = 0u8)]
        Scheduled { when: u32, index: u32 },
        #[doc = "Canceled some task."]
        #[codec(index = 1u8)]
        Canceled { when: u32, index: u32 },
        #[doc = "Dispatched some task."]
        #[codec(index = 2u8)]
        Dispatched {
          task: (u32, u32),
          id: Option<[u8; 32usize]>,
          result: Result<(), sp_runtime::DispatchError>,
        },
        #[doc = "The call for the provided hash was not found so the task has been aborted."]
        #[codec(index = 3u8)]
        CallUnavailable {
          task: (u32, u32),
          id: Option<[u8; 32usize]>,
        },
        #[doc = "The given task was unable to be renewed since the agenda is full at that block."]
        #[codec(index = 4u8)]
        PeriodicFailed {
          task: (u32, u32),
          id: Option<[u8; 32usize]>,
        },
        #[doc = "The given task can never be executed since it is overweight."]
        #[codec(index = 5u8)]
        PermanentlyOverweight {
          task: (u32, u32),
          id: Option<[u8; 32usize]>,
        },
      }
      impl SchedulerEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Scheduled { .. } => "Scheduler.Scheduled",
            Self::Canceled { .. } => "Scheduler.Canceled",
            Self::Dispatched { .. } => "Scheduler.Dispatched",
            Self::CallUnavailable { .. } => "Scheduler.CallUnavailable",
            Self::PeriodicFailed { .. } => "Scheduler.PeriodicFailed",
            Self::PermanentlyOverweight { .. } => "Scheduler.PermanentlyOverweight",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SchedulerEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::Scheduled { .. } => &["Scheduled some task."],
            Self::Canceled { .. } => &["Canceled some task."],
            Self::Dispatched { .. } => &["Dispatched some task."],
            Self::CallUnavailable { .. } => {
              &["The call for the provided hash was not found so the task has been aborted."]
            }
            Self::PeriodicFailed { .. } => {
              &["The given task was unable to be renewed since the agenda is full at that block."]
            }
            Self::PermanentlyOverweight { .. } => {
              &["The given task can never be executed since it is overweight."]
            }
            _ => &[""],
          }
        }
      }
      impl From<SchedulerEvent> for &'static str {
        fn from(v: SchedulerEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SchedulerEvent> for &'static str {
        fn from(v: &SchedulerEvent) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SchedulerCall {
        #[doc = "Anonymously schedule a task."]
        #[codec(index = 0u8)]
        schedule {
          when: u32,
          maybe_periodic: Option<(u32, u32)>,
          priority: u8,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
        #[doc = "Cancel an anonymously scheduled task."]
        #[codec(index = 1u8)]
        cancel { when: u32, index: u32 },
        #[doc = "Schedule a named task."]
        #[codec(index = 2u8)]
        schedule_named {
          id: [u8; 32usize],
          when: u32,
          maybe_periodic: Option<(u32, u32)>,
          priority: u8,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
        #[doc = "Cancel a named scheduled task."]
        #[codec(index = 3u8)]
        cancel_named { id: [u8; 32usize] },
        #[doc = "Anonymously schedule a task after a delay."]
        #[codec(index = 4u8)]
        schedule_after {
          after: u32,
          maybe_periodic: Option<(u32, u32)>,
          priority: u8,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
        #[doc = "Schedule a named task after a delay."]
        #[codec(index = 5u8)]
        schedule_named_after {
          id: [u8; 32usize],
          after: u32,
          maybe_periodic: Option<(u32, u32)>,
          priority: u8,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
      }
      impl SchedulerCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::schedule { .. } => "Scheduler.schedule",
            Self::cancel { .. } => "Scheduler.cancel",
            Self::schedule_named { .. } => "Scheduler.schedule_named",
            Self::cancel_named { .. } => "Scheduler.cancel_named",
            Self::schedule_after { .. } => "Scheduler.schedule_after",
            Self::schedule_named_after { .. } => "Scheduler.schedule_named_after",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SchedulerCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::schedule { .. } => &["Anonymously schedule a task."],
            Self::cancel { .. } => &["Cancel an anonymously scheduled task."],
            Self::schedule_named { .. } => &["Schedule a named task."],
            Self::cancel_named { .. } => &["Cancel a named scheduled task."],
            Self::schedule_after { .. } => &["Anonymously schedule a task after a delay."],
            Self::schedule_named_after { .. } => &["Schedule a named task after a delay."],
            _ => &[""],
          }
        }
      }
      impl From<SchedulerCall> for &'static str {
        fn from(v: SchedulerCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SchedulerCall> for &'static str {
        fn from(v: &SchedulerCall) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Scheduled<Name, Call, BlockNumber, PalletsOrigin, AccountId> {
      pub maybe_id: Option<Name>,
      pub priority: u8,
      pub call: Call,
      pub maybe_periodic: Option<(BlockNumber, BlockNumber)>,
      pub origin: PalletsOrigin,
      _phantom_data: core::marker::PhantomData<AccountId>,
    }
  }
  pub mod sp_consensus_babe {
    use super::*;
    pub mod digests {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum NextConfigDescriptor {
        #[codec(index = 1u8)]
        V1 {
          c: (u64, u64),
          allowed_slots: sp_consensus_babe::AllowedSlots,
        },
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PrimaryPreDigest {
        pub authority_index: u32,
        pub slot: sp_consensus_slots::Slot,
        pub vrf_output: [u8; 32usize],
        #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
        pub vrf_proof: [u8; 64usize],
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SecondaryPlainPreDigest {
        pub authority_index: u32,
        pub slot: sp_consensus_slots::Slot,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct SecondaryVRFPreDigest {
        pub authority_index: u32,
        pub slot: sp_consensus_slots::Slot,
        pub vrf_output: [u8; 32usize],
        #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
        pub vrf_proof: [u8; 64usize],
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PreDigest {
        #[codec(index = 1u8)]
        Primary(sp_consensus_babe::digests::PrimaryPreDigest),
        #[codec(index = 2u8)]
        SecondaryPlain(sp_consensus_babe::digests::SecondaryPlainPreDigest),
        #[codec(index = 3u8)]
        SecondaryVRF(sp_consensus_babe::digests::SecondaryVRFPreDigest),
      }
    }
    pub mod app {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Public(pub sp_core::sr25519::Public);
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum AllowedSlots {
      #[codec(index = 0u8)]
      PrimarySlots,
      #[codec(index = 1u8)]
      PrimaryAndSecondaryPlainSlots,
      #[codec(index = 2u8)]
      PrimaryAndSecondaryVRFSlots,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct BabeEpochConfiguration {
      pub c: (u64, u64),
      pub allowed_slots: sp_consensus_babe::AllowedSlots,
    }
  }
  pub mod frame_system {
    use super::*;
    pub mod limits {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BlockWeights {
        pub base_block: ::polymesh_api_client::sp_weights::Weight,
        pub max_block: ::polymesh_api_client::sp_weights::Weight,
        pub per_class:
          frame_support::dispatch::PerDispatchClass<frame_system::limits::WeightsPerClass>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct WeightsPerClass {
        pub base_extrinsic: ::polymesh_api_client::sp_weights::Weight,
        pub max_extrinsic: Option<::polymesh_api_client::sp_weights::Weight>,
        pub max_total: Option<::polymesh_api_client::sp_weights::Weight>,
        pub reserved: Option<::polymesh_api_client::sp_weights::Weight>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct BlockLength {
        pub max: frame_support::dispatch::PerDispatchClass<u32>,
      }
    }
    pub mod extensions {
      use super::*;
      pub mod check_spec_version {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckSpecVersion();
      }
      pub mod check_nonce {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckNonce(#[codec(compact)] pub u32);
      }
      pub mod check_mortality {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckMortality(pub ::polymesh_api_client::Era);
      }
      pub mod check_genesis {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckGenesis();
      }
      pub mod check_weight {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckWeight();
      }
      pub mod check_tx_version {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckTxVersion();
      }
    }
    pub mod pallet {
      use super::*;
      #[doc = "Event for the System pallet."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SystemEvent {
        #[doc = "An extrinsic completed successfully."]
        #[codec(index = 0u8)]
        ExtrinsicSuccess {
          dispatch_info: frame_support::dispatch::DispatchInfo,
        },
        #[doc = "An extrinsic failed."]
        #[codec(index = 1u8)]
        ExtrinsicFailed {
          dispatch_error: sp_runtime::DispatchError,
          dispatch_info: frame_support::dispatch::DispatchInfo,
        },
        #[doc = "`:code` was updated."]
        #[codec(index = 2u8)]
        CodeUpdated,
        #[doc = "A new account was created."]
        #[codec(index = 3u8)]
        NewAccount {
          account: ::polymesh_api_client::AccountId,
        },
        #[doc = "An account was reaped."]
        #[codec(index = 4u8)]
        KilledAccount {
          account: ::polymesh_api_client::AccountId,
        },
        #[doc = "On on-chain remark happened."]
        #[codec(index = 5u8)]
        Remarked {
          sender: ::polymesh_api_client::AccountId,
          hash: primitive_types::H256,
        },
      }
      impl SystemEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::ExtrinsicSuccess { .. } => "System.ExtrinsicSuccess",
            Self::ExtrinsicFailed { .. } => "System.ExtrinsicFailed",
            Self::CodeUpdated => "System.CodeUpdated",
            Self::NewAccount { .. } => "System.NewAccount",
            Self::KilledAccount { .. } => "System.KilledAccount",
            Self::Remarked { .. } => "System.Remarked",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SystemEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::ExtrinsicSuccess { .. } => &["An extrinsic completed successfully."],
            Self::ExtrinsicFailed { .. } => &["An extrinsic failed."],
            Self::CodeUpdated => &["`:code` was updated."],
            Self::NewAccount { .. } => &["A new account was created."],
            Self::KilledAccount { .. } => &["An account was reaped."],
            Self::Remarked { .. } => &["On on-chain remark happened."],
            _ => &[""],
          }
        }
      }
      impl From<SystemEvent> for &'static str {
        fn from(v: SystemEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SystemEvent> for &'static str {
        fn from(v: &SystemEvent) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Error for the System pallet"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SystemError {
        #[doc = "The name of specification does not match between the current runtime"]
        #[doc = "and the new runtime."]
        #[codec(index = 0u8)]
        InvalidSpecName,
        #[doc = "The specification version is not allowed to decrease between the current runtime"]
        #[doc = "and the new runtime."]
        #[codec(index = 1u8)]
        SpecVersionNeedsToIncrease,
        #[doc = "Failed to extract the runtime version from the new runtime."]
        #[doc = ""]
        #[doc = "Either calling `Core_version` or decoding `RuntimeVersion` failed."]
        #[codec(index = 2u8)]
        FailedToExtractRuntimeVersion,
        #[doc = "Suicide called when the account has non-default composite data."]
        #[codec(index = 3u8)]
        NonDefaultComposite,
        #[doc = "There is a non-zero reference count preventing the account from being purged."]
        #[codec(index = 4u8)]
        NonZeroRefCount,
        #[doc = "The origin filter prevent the call to be dispatched."]
        #[codec(index = 5u8)]
        CallFiltered,
      }
      impl SystemError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidSpecName => "System.InvalidSpecName",
            Self::SpecVersionNeedsToIncrease => "System.SpecVersionNeedsToIncrease",
            Self::FailedToExtractRuntimeVersion => "System.FailedToExtractRuntimeVersion",
            Self::NonDefaultComposite => "System.NonDefaultComposite",
            Self::NonZeroRefCount => "System.NonZeroRefCount",
            Self::CallFiltered => "System.CallFiltered",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SystemError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidSpecName => &[
              "The name of specification does not match between the current runtime",
              "and the new runtime.",
            ],
            Self::SpecVersionNeedsToIncrease => &[
              "The specification version is not allowed to decrease between the current runtime",
              "and the new runtime.",
            ],
            Self::FailedToExtractRuntimeVersion => &[
              "Failed to extract the runtime version from the new runtime.",
              "",
              "Either calling `Core_version` or decoding `RuntimeVersion` failed.",
            ],
            Self::NonDefaultComposite => {
              &["Suicide called when the account has non-default composite data."]
            }
            Self::NonZeroRefCount => {
              &["There is a non-zero reference count preventing the account from being purged."]
            }
            Self::CallFiltered => &["The origin filter prevent the call to be dispatched."],
            _ => &[""],
          }
        }
      }
      impl From<SystemError> for &'static str {
        fn from(v: SystemError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SystemError> for &'static str {
        fn from(v: &SystemError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum SystemCall {
        #[doc = "Make some on-chain remark."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`"]
        #[codec(index = 0u8)]
        remark { remark: ::alloc::vec::Vec<u8> },
        #[doc = "Set the number of pages in the WebAssembly environment's heap."]
        #[codec(index = 1u8)]
        set_heap_pages { pages: u64 },
        #[doc = "Set the new runtime code."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"]
        #[codec(index = 2u8)]
        set_code { code: ::alloc::vec::Vec<u8> },
        #[doc = "Set the new runtime code without doing any checks of the given `code`."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(C)` where `C` length of `code`"]
        #[codec(index = 3u8)]
        set_code_without_checks { code: ::alloc::vec::Vec<u8> },
        #[doc = "Set some items of storage."]
        #[codec(index = 4u8)]
        set_storage {
          items: ::alloc::vec::Vec<(::alloc::vec::Vec<u8>, ::alloc::vec::Vec<u8>)>,
        },
        #[doc = "Kill some items from storage."]
        #[codec(index = 5u8)]
        kill_storage {
          keys: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
        },
        #[doc = "Kill all storage items with a key that starts with the given prefix."]
        #[doc = ""]
        #[doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"]
        #[doc = "the prefix we are removing to accurately calculate the weight of this function."]
        #[codec(index = 6u8)]
        kill_prefix {
          prefix: ::alloc::vec::Vec<u8>,
          subkeys: u32,
        },
        #[doc = "Make some on-chain remark and emit event."]
        #[codec(index = 7u8)]
        remark_with_event { remark: ::alloc::vec::Vec<u8> },
      }
      impl SystemCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::remark { .. } => "System.remark",
            Self::set_heap_pages { .. } => "System.set_heap_pages",
            Self::set_code { .. } => "System.set_code",
            Self::set_code_without_checks { .. } => "System.set_code_without_checks",
            Self::set_storage { .. } => "System.set_storage",
            Self::kill_storage { .. } => "System.kill_storage",
            Self::kill_prefix { .. } => "System.kill_prefix",
            Self::remark_with_event { .. } => "System.remark_with_event",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for SystemCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::remark { .. } => &[
              "Make some on-chain remark.",
              "",
              "## Complexity",
              "- `O(1)`",
            ],
            Self::set_heap_pages { .. } => {
              &["Set the number of pages in the WebAssembly environment's heap."]
            }
            Self::set_code { .. } => &[
              "Set the new runtime code.",
              "",
              "## Complexity",
              "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`",
            ],
            Self::set_code_without_checks { .. } => &[
              "Set the new runtime code without doing any checks of the given `code`.",
              "",
              "## Complexity",
              "- `O(C)` where `C` length of `code`",
            ],
            Self::set_storage { .. } => &["Set some items of storage."],
            Self::kill_storage { .. } => &["Kill some items from storage."],
            Self::kill_prefix { .. } => &[
              "Kill all storage items with a key that starts with the given prefix.",
              "",
              "**NOTE:** We rely on the Root origin to provide us the number of subkeys under",
              "the prefix we are removing to accurately calculate the weight of this function.",
            ],
            Self::remark_with_event { .. } => &["Make some on-chain remark and emit event."],
            _ => &[""],
          }
        }
      }
      impl From<SystemCall> for &'static str {
        fn from(v: SystemCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&SystemCall> for &'static str {
        fn from(v: &SystemCall) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct AccountInfo<Index, AccountData> {
      pub nonce: Index,
      pub consumers: Index,
      pub providers: Index,
      pub sufficients: Index,
      pub data: AccountData,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Phase {
      #[codec(index = 0u8)]
      ApplyExtrinsic(u32),
      #[codec(index = 1u8)]
      Finalization,
      #[codec(index = 2u8)]
      Initialization,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct LastRuntimeUpgradeInfo {
      #[codec(compact)]
      pub spec_version: u32,
      pub spec_name: ::alloc::string::String,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct EventRecord<E, T> {
      pub phase: frame_system::Phase,
      pub event: E,
      pub topics: ::alloc::vec::Vec<T>,
    }
  }
  pub mod sp_core {
    use super::*;
    pub mod ecdsa {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Signature(
        #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
        pub  [u8; 65usize],
      );
    }
    pub mod ed25519 {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Public(pub [u8; 32usize]);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Signature(
        #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
        pub  [u8; 64usize],
      );
    }
    pub mod offchain {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct OpaqueNetworkState {
        pub peer_id: sp_core::OpaquePeerId,
        pub external_addresses: ::alloc::vec::Vec<sp_core::offchain::OpaqueMultiaddr>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct OpaqueMultiaddr(pub ::alloc::vec::Vec<u8>);
    }
    pub mod crypto {
      use super::*;
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct AccountId32(pub [u8; 32usize]);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct KeyTypeId(pub [u8; 4usize]);
    }
    pub mod sr25519 {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Signature(
        #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
        pub  [u8; 64usize],
      );
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Public(pub [u8; 32usize]);
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Void {}
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct OpaquePeerId(pub ::alloc::vec::Vec<u8>);
  }
  pub mod pallet_sto {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct FundraiserId(pub u64);
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StoEvent<Moment> {
      #[doc = "A new fundraiser has been created."]
      #[doc = "(Agent DID, fundraiser id, fundraiser name, fundraiser details)"]
      #[codec(index = 0u8)]
      FundraiserCreated(
        ::polymesh_api_client::IdentityId,
        pallet_sto::FundraiserId,
        pallet_sto::FundraiserName,
        pallet_sto::Fundraiser<Moment>,
      ),
      #[doc = "An investor invested in the fundraiser."]
      #[doc = "(Investor, fundraiser_id, offering token, raise token, offering_token_amount, raise_token_amount)"]
      #[codec(index = 1u8)]
      Invested(
        ::polymesh_api_client::IdentityId,
        pallet_sto::FundraiserId,
        polymesh_primitives::ticker::Ticker,
        polymesh_primitives::ticker::Ticker,
        u128,
        u128,
      ),
      #[doc = "A fundraiser has been frozen."]
      #[doc = "(Agent DID, fundraiser id)"]
      #[codec(index = 2u8)]
      FundraiserFrozen(::polymesh_api_client::IdentityId, pallet_sto::FundraiserId),
      #[doc = "A fundraiser has been unfrozen."]
      #[doc = "(Agent DID, fundraiser id)"]
      #[codec(index = 3u8)]
      FundraiserUnfrozen(::polymesh_api_client::IdentityId, pallet_sto::FundraiserId),
      #[doc = "A fundraiser window has been modified."]
      #[doc = "(Agent DID, fundraiser id, old_start, old_end, new_start, new_end)"]
      #[codec(index = 4u8)]
      FundraiserWindowModified(
        polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
        pallet_sto::FundraiserId,
        Moment,
        Option<Moment>,
        Moment,
        Option<Moment>,
      ),
      #[doc = "A fundraiser has been stopped."]
      #[doc = "(Agent DID, fundraiser id)"]
      #[codec(index = 5u8)]
      FundraiserClosed(::polymesh_api_client::IdentityId, pallet_sto::FundraiserId),
    }
    impl<Moment> StoEvent<Moment> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::FundraiserCreated(_, _, _, _) => "Sto.FundraiserCreated",
          Self::Invested(_, _, _, _, _, _) => "Sto.Invested",
          Self::FundraiserFrozen(_, _) => "Sto.FundraiserFrozen",
          Self::FundraiserUnfrozen(_, _) => "Sto.FundraiserUnfrozen",
          Self::FundraiserWindowModified(_, _, _, _, _, _) => "Sto.FundraiserWindowModified",
          Self::FundraiserClosed(_, _) => "Sto.FundraiserClosed",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<Moment> ::polymesh_api_client::EnumInfo for StoEvent<Moment> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: FundraiserCreated (_ , _ , _ , _) => { & ["A new fundraiser has been created." , "(Agent DID, fundraiser id, fundraiser name, fundraiser details)" ,] } , Self :: Invested (_ , _ , _ , _ , _ , _) => { & ["An investor invested in the fundraiser." , "(Investor, fundraiser_id, offering token, raise token, offering_token_amount, raise_token_amount)" ,] } , Self :: FundraiserFrozen (_ , _) => { & ["A fundraiser has been frozen." , "(Agent DID, fundraiser id)" ,] } , Self :: FundraiserUnfrozen (_ , _) => { & ["A fundraiser has been unfrozen." , "(Agent DID, fundraiser id)" ,] } , Self :: FundraiserWindowModified (_ , _ , _ , _ , _ , _) => { & ["A fundraiser window has been modified." , "(Agent DID, fundraiser id, old_start, old_end, new_start, new_end)" ,] } , Self :: FundraiserClosed (_ , _) => { & ["A fundraiser has been stopped." , "(Agent DID, fundraiser id)" ,] } , _ => & [""] , }
      }
    }
    impl<Moment> From<StoEvent<Moment>> for &'static str {
      fn from(v: StoEvent<Moment>) -> Self {
        v.as_static_str()
      }
    }
    impl<Moment> From<&StoEvent<Moment>> for &'static str {
      fn from(v: &StoEvent<Moment>) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Errors for the Settlement module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StoError {
      #[doc = "Sender does not have required permissions."]
      #[codec(index = 0u8)]
      Unauthorized,
      #[doc = "An arithmetic operation overflowed."]
      #[codec(index = 1u8)]
      Overflow,
      #[doc = "Not enough tokens left for sale."]
      #[codec(index = 2u8)]
      InsufficientTokensRemaining,
      #[doc = "Fundraiser not found."]
      #[codec(index = 3u8)]
      FundraiserNotFound,
      #[doc = "Fundraiser is either frozen or stopped."]
      #[codec(index = 4u8)]
      FundraiserNotLive,
      #[doc = "Fundraiser has been closed/stopped already."]
      #[codec(index = 5u8)]
      FundraiserClosed,
      #[doc = "Interacting with a fundraiser past the end `Moment`."]
      #[codec(index = 6u8)]
      FundraiserExpired,
      #[doc = "An invalid venue provided."]
      #[codec(index = 7u8)]
      InvalidVenue,
      #[doc = "An individual price tier was invalid or a set of price tiers was invalid."]
      #[codec(index = 8u8)]
      InvalidPriceTiers,
      #[doc = "Window (start time, end time) has invalid parameters, e.g start time is after end time."]
      #[codec(index = 9u8)]
      InvalidOfferingWindow,
      #[doc = "Price of the investment exceeded the max price."]
      #[codec(index = 10u8)]
      MaxPriceExceeded,
      #[doc = "Investment amount is lower than minimum investment amount."]
      #[codec(index = 11u8)]
      InvestmentAmountTooLow,
    }
    impl StoError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::Unauthorized => "Sto.Unauthorized",
          Self::Overflow => "Sto.Overflow",
          Self::InsufficientTokensRemaining => "Sto.InsufficientTokensRemaining",
          Self::FundraiserNotFound => "Sto.FundraiserNotFound",
          Self::FundraiserNotLive => "Sto.FundraiserNotLive",
          Self::FundraiserClosed => "Sto.FundraiserClosed",
          Self::FundraiserExpired => "Sto.FundraiserExpired",
          Self::InvalidVenue => "Sto.InvalidVenue",
          Self::InvalidPriceTiers => "Sto.InvalidPriceTiers",
          Self::InvalidOfferingWindow => "Sto.InvalidOfferingWindow",
          Self::MaxPriceExceeded => "Sto.MaxPriceExceeded",
          Self::InvestmentAmountTooLow => "Sto.InvestmentAmountTooLow",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for StoError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: Unauthorized => { & ["Sender does not have required permissions." ,] } , Self :: Overflow => { & ["An arithmetic operation overflowed." ,] } , Self :: InsufficientTokensRemaining => { & ["Not enough tokens left for sale." ,] } , Self :: FundraiserNotFound => { & ["Fundraiser not found." ,] } , Self :: FundraiserNotLive => { & ["Fundraiser is either frozen or stopped." ,] } , Self :: FundraiserClosed => { & ["Fundraiser has been closed/stopped already." ,] } , Self :: FundraiserExpired => { & ["Interacting with a fundraiser past the end `Moment`." ,] } , Self :: InvalidVenue => { & ["An invalid venue provided." ,] } , Self :: InvalidPriceTiers => { & ["An individual price tier was invalid or a set of price tiers was invalid." ,] } , Self :: InvalidOfferingWindow => { & ["Window (start time, end time) has invalid parameters, e.g start time is after end time." ,] } , Self :: MaxPriceExceeded => { & ["Price of the investment exceeded the max price." ,] } , Self :: InvestmentAmountTooLow => { & ["Investment amount is lower than minimum investment amount." ,] } , _ => & [""] , }
      }
    }
    impl From<StoError> for &'static str {
      fn from(v: StoError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&StoError> for &'static str {
      fn from(v: &StoError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum StoCall {
      #[doc = "Create a new fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_portfolio` - Portfolio containing the `offering_asset`."]
      #[doc = "* `offering_asset` - Asset being offered."]
      #[doc = "* `raising_portfolio` - Portfolio containing the `raising_asset`."]
      #[doc = "* `raising_asset` - Asset being exchanged for `offering_asset` on investment."]
      #[doc = "* `tiers` - Price tiers to charge investors on investment."]
      #[doc = "* `venue_id` - Venue to handle settlement."]
      #[doc = "* `start` - Fundraiser start time, if `None` the fundraiser will start immediately."]
      #[doc = "* `end` - Fundraiser end time, if `None` the fundraiser will never expire."]
      #[doc = "* `minimum_investment` - Minimum amount of `raising_asset` that an investor needs to spend to invest in this raise."]
      #[doc = "* `fundraiser_name` - Fundraiser name, only used in the UIs."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[codec(index = 0u8)]
      create_fundraiser {
        offering_portfolio: polymesh_primitives::identity_id::PortfolioId,
        offering_asset: polymesh_primitives::ticker::Ticker,
        raising_portfolio: polymesh_primitives::identity_id::PortfolioId,
        raising_asset: polymesh_primitives::ticker::Ticker,
        tiers: ::alloc::vec::Vec<pallet_sto::PriceTier>,
        venue_id: polymesh_primitives::settlement::VenueId,
        start: Option<u64>,
        end: Option<u64>,
        minimum_investment: u128,
        fundraiser_name: pallet_sto::FundraiserName,
      },
      #[doc = "Invest in a fundraiser."]
      #[doc = ""]
      #[doc = "* `investment_portfolio` - Portfolio that `offering_asset` will be deposited in."]
      #[doc = "* `funding_portfolio` - Portfolio that will fund the investment."]
      #[doc = "* `offering_asset` - Asset to invest in."]
      #[doc = "* `id` - ID of the fundraiser to invest in."]
      #[doc = "* `purchase_amount` - Amount of `offering_asset` to purchase."]
      #[doc = "* `max_price` - Maximum price to pay per unit of `offering_asset`, If `None`there are no constraints on price."]
      #[doc = "* `receipt` - Off-chain receipt to use instead of on-chain balance in `funding_portfolio`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 1u8)]
      invest {
        investment_portfolio: polymesh_primitives::identity_id::PortfolioId,
        funding_portfolio: polymesh_primitives::identity_id::PortfolioId,
        offering_asset: polymesh_primitives::ticker::Ticker,
        id: pallet_sto::FundraiserId,
        purchase_amount: u128,
        max_price: Option<u128>,
        receipt: Option<
          polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            sp_runtime::MultiSignature,
          >,
        >,
      },
      #[doc = "Freeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to freeze."]
      #[doc = "* `id` - ID of the fundraiser to freeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 2u8)]
      freeze_fundraiser {
        offering_asset: polymesh_primitives::ticker::Ticker,
        id: pallet_sto::FundraiserId,
      },
      #[doc = "Unfreeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to unfreeze."]
      #[doc = "* `id` - ID of the fundraiser to unfreeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 3u8)]
      unfreeze_fundraiser {
        offering_asset: polymesh_primitives::ticker::Ticker,
        id: pallet_sto::FundraiserId,
      },
      #[doc = "Modify the time window a fundraiser is active"]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to modify."]
      #[doc = "* `id` - ID of the fundraiser to modify."]
      #[doc = "* `start` - New start of the fundraiser."]
      #[doc = "* `end` - New end of the fundraiser to modify."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 4u8)]
      modify_fundraiser_window {
        offering_asset: polymesh_primitives::ticker::Ticker,
        id: pallet_sto::FundraiserId,
        start: u64,
        end: Option<u64>,
      },
      #[doc = "Stop a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to stop."]
      #[doc = "* `id` - ID of the fundraiser to stop."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 5u8)]
      stop {
        offering_asset: polymesh_primitives::ticker::Ticker,
        id: pallet_sto::FundraiserId,
      },
    }
    impl StoCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_fundraiser { .. } => "Sto.create_fundraiser",
          Self::invest { .. } => "Sto.invest",
          Self::freeze_fundraiser { .. } => "Sto.freeze_fundraiser",
          Self::unfreeze_fundraiser { .. } => "Sto.unfreeze_fundraiser",
          Self::modify_fundraiser_window { .. } => "Sto.modify_fundraiser_window",
          Self::stop { .. } => "Sto.stop",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for StoCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: create_fundraiser { .. } => { & ["Create a new fundraiser." , "" , "* `offering_portfolio` - Portfolio containing the `offering_asset`." , "* `offering_asset` - Asset being offered." , "* `raising_portfolio` - Portfolio containing the `raising_asset`." , "* `raising_asset` - Asset being exchanged for `offering_asset` on investment." , "* `tiers` - Price tiers to charge investors on investment." , "* `venue_id` - Venue to handle settlement." , "* `start` - Fundraiser start time, if `None` the fundraiser will start immediately." , "* `end` - Fundraiser end time, if `None` the fundraiser will never expire." , "* `minimum_investment` - Minimum amount of `raising_asset` that an investor needs to spend to invest in this raise." , "* `fundraiser_name` - Fundraiser name, only used in the UIs." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: invest { .. } => { & ["Invest in a fundraiser." , "" , "* `investment_portfolio` - Portfolio that `offering_asset` will be deposited in." , "* `funding_portfolio` - Portfolio that will fund the investment." , "* `offering_asset` - Asset to invest in." , "* `id` - ID of the fundraiser to invest in." , "* `purchase_amount` - Amount of `offering_asset` to purchase." , "* `max_price` - Maximum price to pay per unit of `offering_asset`, If `None`there are no constraints on price." , "* `receipt` - Off-chain receipt to use instead of on-chain balance in `funding_portfolio`." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: freeze_fundraiser { .. } => { & ["Freeze a fundraiser." , "" , "* `offering_asset` - Asset to freeze." , "* `id` - ID of the fundraiser to freeze." , "" , "# Permissions" , "* Asset" ,] } , Self :: unfreeze_fundraiser { .. } => { & ["Unfreeze a fundraiser." , "" , "* `offering_asset` - Asset to unfreeze." , "* `id` - ID of the fundraiser to unfreeze." , "" , "# Permissions" , "* Asset" ,] } , Self :: modify_fundraiser_window { .. } => { & ["Modify the time window a fundraiser is active" , "" , "* `offering_asset` - Asset to modify." , "* `id` - ID of the fundraiser to modify." , "* `start` - New start of the fundraiser." , "* `end` - New end of the fundraiser to modify." , "" , "# Permissions" , "* Asset" ,] } , Self :: stop { .. } => { & ["Stop a fundraiser." , "" , "* `offering_asset` - Asset to stop." , "* `id` - ID of the fundraiser to stop." , "" , "# Permissions" , "* Asset" ,] } , _ => & [""] , }
      }
    }
    impl From<StoCall> for &'static str {
      fn from(v: StoCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&StoCall> for &'static str {
      fn from(v: &StoCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Fundraiser<Moment> {
      pub creator: ::polymesh_api_client::IdentityId,
      pub offering_portfolio: polymesh_primitives::identity_id::PortfolioId,
      pub offering_asset: polymesh_primitives::ticker::Ticker,
      pub raising_portfolio: polymesh_primitives::identity_id::PortfolioId,
      pub raising_asset: polymesh_primitives::ticker::Ticker,
      pub tiers: ::alloc::vec::Vec<pallet_sto::FundraiserTier>,
      pub venue_id: polymesh_primitives::settlement::VenueId,
      pub start: Moment,
      pub end: Option<Moment>,
      pub status: pallet_sto::FundraiserStatus,
      pub minimum_investment: u128,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct FundraiserName(pub ::alloc::vec::Vec<u8>);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct PriceTier {
      pub total: u128,
      pub price: u128,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum FundraiserStatus {
      #[codec(index = 0u8)]
      Live,
      #[codec(index = 1u8)]
      Frozen,
      #[codec(index = 2u8)]
      Closed,
      #[codec(index = 3u8)]
      ClosedEarly,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct FundraiserTier {
      pub total: u128,
      pub price: u128,
      pub remaining: u128,
    }
  }
  pub mod pallet_treasury {
    use super::*;
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TreasuryEvent<Balance, AccountId> {
      #[doc = "Disbursement to a target Identity."]
      #[doc = ""]
      #[doc = "(treasury identity, target identity, target primary key, amount)"]
      #[codec(index = 0u8)]
      TreasuryDisbursement(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::IdentityId,
        AccountId,
        Balance,
      ),
      #[doc = "Disbursement to a target Identity failed."]
      #[doc = ""]
      #[doc = "(treasury identity, target identity, target primary key, amount)"]
      #[codec(index = 1u8)]
      TreasuryDisbursementFailed(
        ::polymesh_api_client::IdentityId,
        ::polymesh_api_client::IdentityId,
        AccountId,
        Balance,
      ),
      #[doc = "Treasury reimbursement."]
      #[doc = ""]
      #[doc = "(source identity, amount)"]
      #[codec(index = 2u8)]
      TreasuryReimbursement(::polymesh_api_client::IdentityId, Balance),
    }
    impl<Balance, AccountId> TreasuryEvent<Balance, AccountId> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::TreasuryDisbursement(_, _, _, _) => "Treasury.TreasuryDisbursement",
          Self::TreasuryDisbursementFailed(_, _, _, _) => "Treasury.TreasuryDisbursementFailed",
          Self::TreasuryReimbursement(_, _) => "Treasury.TreasuryReimbursement",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<Balance, AccountId> ::polymesh_api_client::EnumInfo for TreasuryEvent<Balance, AccountId> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::TreasuryDisbursement(_, _, _, _) => &[
            "Disbursement to a target Identity.",
            "",
            "(treasury identity, target identity, target primary key, amount)",
          ],
          Self::TreasuryDisbursementFailed(_, _, _, _) => &[
            "Disbursement to a target Identity failed.",
            "",
            "(treasury identity, target identity, target primary key, amount)",
          ],
          Self::TreasuryReimbursement(_, _) => {
            &["Treasury reimbursement.", "", "(source identity, amount)"]
          }
          _ => &[""],
        }
      }
    }
    impl<Balance, AccountId> From<TreasuryEvent<Balance, AccountId>> for &'static str {
      fn from(v: TreasuryEvent<Balance, AccountId>) -> Self {
        v.as_static_str()
      }
    }
    impl<Balance, AccountId> From<&TreasuryEvent<Balance, AccountId>> for &'static str {
      fn from(v: &TreasuryEvent<Balance, AccountId>) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Error for the treasury module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TreasuryError {
      #[doc = "Proposer's balance is too low."]
      #[codec(index = 0u8)]
      InsufficientBalance,
      #[doc = "Invalid identity for disbursement."]
      #[codec(index = 1u8)]
      InvalidIdentity,
    }
    impl TreasuryError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::InsufficientBalance => "Treasury.InsufficientBalance",
          Self::InvalidIdentity => "Treasury.InvalidIdentity",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for TreasuryError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::InsufficientBalance => &["Proposer's balance is too low."],
          Self::InvalidIdentity => &["Invalid identity for disbursement."],
          _ => &[""],
        }
      }
    }
    impl From<TreasuryError> for &'static str {
      fn from(v: TreasuryError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&TreasuryError> for &'static str {
      fn from(v: &TreasuryError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TreasuryCall {
      #[doc = "It transfers balances from treasury to each of beneficiaries and the specific amount"]
      #[doc = "for each of them."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = "* `BadOrigin`: Only root can execute transaction."]
      #[doc = "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries."]
      #[doc = "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity."]
      #[codec(index = 0u8)]
      disbursement {
        beneficiaries: ::alloc::vec::Vec<polymesh_primitives::Beneficiary<u128>>,
      },
      #[doc = "It transfers the specific `amount` from `origin` account into treasury."]
      #[doc = ""]
      #[doc = "Only accounts which are associated to an identity can make a donation to treasury."]
      #[codec(index = 1u8)]
      reimbursement { amount: u128 },
    }
    impl TreasuryCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::disbursement { .. } => "Treasury.disbursement",
          Self::reimbursement { .. } => "Treasury.reimbursement",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for TreasuryCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: disbursement { .. } => { & ["It transfers balances from treasury to each of beneficiaries and the specific amount" , "for each of them." , "" , "# Error" , "* `BadOrigin`: Only root can execute transaction." , "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries." , "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity." ,] } , Self :: reimbursement { .. } => { & ["It transfers the specific `amount` from `origin` account into treasury." , "" , "Only accounts which are associated to an identity can make a donation to treasury." ,] } , _ => & [""] , }
      }
    }
    impl From<TreasuryCall> for &'static str {
      fn from(v: TreasuryCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&TreasuryCall> for &'static str {
      fn from(v: &TreasuryCall) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_sudo {
    use super::*;
    #[doc = "Error for the Sudo module"]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum SudoError {
      #[doc = "Sender must be the Sudo account"]
      #[codec(index = 0u8)]
      RequireSudo,
    }
    impl SudoError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::RequireSudo => "Sudo.RequireSudo",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for SudoError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::RequireSudo => &["Sender must be the Sudo account"],
          _ => &[""],
        }
      }
    }
    impl From<SudoError> for &'static str {
      fn from(v: SudoError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&SudoError> for &'static str {
      fn from(v: &SudoError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum SudoCall {
      #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- Limited storage reads."]
      #[doc = "- One DB write (event)."]
      #[doc = "- Weight of derivative `call` execution + 10,000."]
      #[doc = "# </weight>"]
      #[codec(index = 0u8)]
      sudo {
        call: ::alloc::boxed::Box<runtime::RuntimeCall>,
      },
      #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
      #[doc = "This function does not check the weight of the call, and instead allows the"]
      #[doc = "Sudo user to specify the weight of the call."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- The weight of this call is defined by the caller."]
      #[doc = "# </weight>"]
      #[codec(index = 1u8)]
      sudo_unchecked_weight {
        call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        _weight: ::polymesh_api_client::sp_weights::Weight,
      },
      #[doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- Limited storage reads."]
      #[doc = "- One DB change."]
      #[doc = "# </weight>"]
      #[codec(index = 2u8)]
      set_key {
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
      },
      #[doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"]
      #[doc = "a given account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- Limited storage reads."]
      #[doc = "- One DB write (event)."]
      #[doc = "- Weight of derivative `call` execution + 10,000."]
      #[doc = "# </weight>"]
      #[codec(index = 3u8)]
      sudo_as {
        who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        call: ::alloc::boxed::Box<runtime::RuntimeCall>,
      },
    }
    impl SudoCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::sudo { .. } => "Sudo.sudo",
          Self::sudo_unchecked_weight { .. } => "Sudo.sudo_unchecked_weight",
          Self::set_key { .. } => "Sudo.set_key",
          Self::sudo_as { .. } => "Sudo.sudo_as",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for SudoCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: sudo { .. } => { & ["Authenticates the sudo key and dispatches a function call with `Root` origin." , "" , "The dispatch origin for this call must be _Signed_." , "" , "# <weight>" , "- O(1)." , "- Limited storage reads." , "- One DB write (event)." , "- Weight of derivative `call` execution + 10,000." , "# </weight>" ,] } , Self :: sudo_unchecked_weight { .. } => { & ["Authenticates the sudo key and dispatches a function call with `Root` origin." , "This function does not check the weight of the call, and instead allows the" , "Sudo user to specify the weight of the call." , "" , "The dispatch origin for this call must be _Signed_." , "" , "# <weight>" , "- O(1)." , "- The weight of this call is defined by the caller." , "# </weight>" ,] } , Self :: set_key { .. } => { & ["Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key." , "" , "The dispatch origin for this call must be _Signed_." , "" , "# <weight>" , "- O(1)." , "- Limited storage reads." , "- One DB change." , "# </weight>" ,] } , Self :: sudo_as { .. } => { & ["Authenticates the sudo key and dispatches a function call with `Signed` origin from" , "a given account." , "" , "The dispatch origin for this call must be _Signed_." , "" , "# <weight>" , "- O(1)." , "- Limited storage reads." , "- One DB write (event)." , "- Weight of derivative `call` execution + 10,000." , "# </weight>" ,] } , _ => & [""] , }
      }
    }
    impl From<SudoCall> for &'static str {
      fn from(v: SudoCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&SudoCall> for &'static str {
      fn from(v: &SudoCall) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum SudoEvent<AccountId> {
      #[doc = "A sudo just took place. \\[result\\]"]
      #[codec(index = 0u8)]
      Sudid(Result<(), sp_runtime::DispatchError>),
      #[doc = "The \\[sudoer\\] just switched identity; the old key is supplied."]
      #[codec(index = 1u8)]
      KeyChanged(Option<AccountId>),
      #[doc = "A sudo just took place. \\[result\\]"]
      #[codec(index = 2u8)]
      SudoAsDone(Result<(), sp_runtime::DispatchError>),
    }
    impl<AccountId> SudoEvent<AccountId> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::Sudid(_) => "Sudo.Sudid",
          Self::KeyChanged(_) => "Sudo.KeyChanged",
          Self::SudoAsDone(_) => "Sudo.SudoAsDone",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<AccountId> ::polymesh_api_client::EnumInfo for SudoEvent<AccountId> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::Sudid(_) => &["A sudo just took place. \\[result\\]"],
          Self::KeyChanged(_) => {
            &["The \\[sudoer\\] just switched identity; the old key is supplied."]
          }
          Self::SudoAsDone(_) => &["A sudo just took place. \\[result\\]"],
          _ => &[""],
        }
      }
    }
    impl<AccountId> From<SudoEvent<AccountId>> for &'static str {
      fn from(v: SudoEvent<AccountId>) -> Self {
        v.as_static_str()
      }
    }
    impl<AccountId> From<&SudoEvent<AccountId>> for &'static str {
      fn from(v: &SudoEvent<AccountId>) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_im_online {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ImOnlineEvent {
        #[doc = "A new heartbeat was received from `AuthorityId`."]
        #[codec(index = 0u8)]
        HeartbeatReceived {
          authority_id: pallet_im_online::sr25519::app_sr25519::Public,
        },
        #[doc = "At the end of the session, no offence was committed."]
        #[codec(index = 1u8)]
        AllGood,
        #[doc = "At the end of the session, at least one validator was found to be offline."]
        #[codec(index = 2u8)]
        SomeOffline {
          offline: ::alloc::vec::Vec<(
            ::polymesh_api_client::AccountId,
            pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
          )>,
        },
      }
      impl ImOnlineEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::HeartbeatReceived { .. } => "ImOnline.HeartbeatReceived",
            Self::AllGood => "ImOnline.AllGood",
            Self::SomeOffline { .. } => "ImOnline.SomeOffline",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ImOnlineEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::HeartbeatReceived { .. } => &["A new heartbeat was received from `AuthorityId`."],
            Self::AllGood => &["At the end of the session, no offence was committed."],
            Self::SomeOffline { .. } => {
              &["At the end of the session, at least one validator was found to be offline."]
            }
            _ => &[""],
          }
        }
      }
      impl From<ImOnlineEvent> for &'static str {
        fn from(v: ImOnlineEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ImOnlineEvent> for &'static str {
        fn from(v: &ImOnlineEvent) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ImOnlineCall {
        #[doc = "## Complexity:"]
        #[doc = "- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of"]
        #[doc = "  `heartbeat.network_state.external_address`"]
        #[doc = "  - `O(K)`: decoding of length `K`"]
        #[doc = "  - `O(E)`: decoding/encoding of length `E`"]
        #[codec(index = 0u8)]
        heartbeat {
          heartbeat: pallet_im_online::Heartbeat<u32>,
          signature: pallet_im_online::sr25519::app_sr25519::Signature,
        },
      }
      impl ImOnlineCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::heartbeat { .. } => "ImOnline.heartbeat",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ImOnlineCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: heartbeat { .. } => { & ["## Complexity:" , "- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of" , "  `heartbeat.network_state.external_address`" , "  - `O(K)`: decoding of length `K`" , "  - `O(E)`: decoding/encoding of length `E`" ,] } , _ => & [""] , }
        }
      }
      impl From<ImOnlineCall> for &'static str {
        fn from(v: ImOnlineCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ImOnlineCall> for &'static str {
        fn from(v: &ImOnlineCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ImOnlineError {
        #[doc = "Non existent public key."]
        #[codec(index = 0u8)]
        InvalidKey,
        #[doc = "Duplicated heartbeat."]
        #[codec(index = 1u8)]
        DuplicatedHeartbeat,
      }
      impl ImOnlineError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidKey => "ImOnline.InvalidKey",
            Self::DuplicatedHeartbeat => "ImOnline.DuplicatedHeartbeat",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ImOnlineError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidKey => &["Non existent public key."],
            Self::DuplicatedHeartbeat => &["Duplicated heartbeat."],
            _ => &[""],
          }
        }
      }
      impl From<ImOnlineError> for &'static str {
        fn from(v: ImOnlineError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ImOnlineError> for &'static str {
        fn from(v: &ImOnlineError) -> Self {
          v.as_static_str()
        }
      }
    }
    pub mod sr25519 {
      use super::*;
      pub mod app_sr25519 {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Signature(pub sp_core::sr25519::Signature);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Public(pub sp_core::sr25519::Public);
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct BoundedOpaqueNetworkState {
      pub peer_id: bounded_collections::weak_bounded_vec::WeakBoundedVec<u8>,
      pub external_addresses: bounded_collections::weak_bounded_vec::WeakBoundedVec<
        bounded_collections::weak_bounded_vec::WeakBoundedVec<u8>,
      >,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Heartbeat<BlockNumber> {
      pub block_number: BlockNumber,
      pub network_state: sp_core::offchain::OpaqueNetworkState,
      pub session_index: BlockNumber,
      pub authority_index: BlockNumber,
      pub validators_len: BlockNumber,
    }
  }
  pub mod pallet_offences {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "Events type."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum OffencesEvent {
        #[doc = "There is an offence reported of the given `kind` happened at the `session_index` and"]
        #[doc = "(kind-specific) time slot. This event is not deposited for duplicate slashes."]
        #[doc = "\\[kind, timeslot\\]."]
        #[codec(index = 0u8)]
        Offence {
          kind: [u8; 16usize],
          timeslot: ::alloc::vec::Vec<u8>,
        },
      }
      impl OffencesEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Offence { .. } => "Offences.Offence",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for OffencesEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: Offence { .. } => { & ["There is an offence reported of the given `kind` happened at the `session_index` and" , "(kind-specific) time slot. This event is not deposited for duplicate slashes." , "\\[kind, timeslot\\]." ,] } , _ => & [""] , }
        }
      }
      impl From<OffencesEvent> for &'static str {
        fn from(v: OffencesEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&OffencesEvent> for &'static str {
        fn from(v: &OffencesEvent) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod pallet_identity {
    use super::*;
    pub mod types {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Claim1stKey {
        pub target: ::polymesh_api_client::IdentityId,
        pub claim_type: polymesh_primitives::identity_claim::ClaimType,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Claim2ndKey {
        pub issuer: ::polymesh_api_client::IdentityId,
        pub scope: Option<polymesh_primitives::identity_claim::Scope>,
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum IdentityCall {
      #[doc = "Register `target_account` with a new Identity."]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[codec(index = 0u8)]
      cdd_register_did {
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
      },
      #[doc = "Invalidates any claim generated by `cdd` from `disable_from` timestamps."]
      #[doc = ""]
      #[doc = "You can also define an expiration time,"]
      #[doc = "which will invalidate all claims generated by that `cdd` and remove it as CDD member group."]
      #[codec(index = 1u8)]
      invalidate_cdd_claims {
        cdd: ::polymesh_api_client::IdentityId,
        disable_from: u64,
        expiry: Option<u64>,
      },
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key"]
      #[doc = "instead of leaving it as a secondary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[codec(index = 2u8)]
      accept_primary_key {
        rotation_auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      },
      #[doc = "Set if CDD authorization is required for updating primary key of an identity."]
      #[doc = "Callable via root (governance)"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_required` CDD Authorization required or not"]
      #[codec(index = 3u8)]
      change_cdd_requirement_for_mk_rotation { auth_required: bool },
      #[doc = "Join an identity as a secondary key."]
      #[codec(index = 4u8)]
      join_identity_as_key { auth_id: u64 },
      #[doc = "Leave the secondary key's identity."]
      #[codec(index = 5u8)]
      leave_identity_as_key,
      #[doc = "Adds a new claim record or edits an existing one."]
      #[doc = ""]
      #[doc = "Only called by did_issuer's secondary key."]
      #[codec(index = 6u8)]
      add_claim {
        target: ::polymesh_api_client::IdentityId,
        claim: polymesh_primitives::identity_claim::Claim,
        expiry: Option<u64>,
      },
      #[doc = "Marks the specified claim as revoked."]
      #[codec(index = 7u8)]
      revoke_claim {
        target: ::polymesh_api_client::IdentityId,
        claim: polymesh_primitives::identity_claim::Claim,
      },
      #[doc = "It disables all secondary keys at `did` identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[codec(index = 8u8)]
      freeze_secondary_keys,
      #[doc = "Re-enables all secondary keys of the caller's identity."]
      #[codec(index = 9u8)]
      unfreeze_secondary_keys,
      #[doc = "Adds an authorization."]
      #[codec(index = 10u8)]
      add_authorization {
        target: polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        data:
          polymesh_primitives::authorization::AuthorizationData<::polymesh_api_client::AccountId>,
        expiry: Option<u64>,
      },
      #[doc = "Removes an authorization."]
      #[doc = "_auth_issuer_pays determines whether the issuer of the authorisation pays the transaction fee"]
      #[codec(index = 11u8)]
      remove_authorization {
        target: polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        auth_id: u64,
        _auth_issuer_pays: bool,
      },
      #[doc = "Assuming this is executed by the GC voting majority, adds a new cdd claim record."]
      #[codec(index = 12u8)]
      gc_add_cdd_claim {
        target: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Assuming this is executed by the GC voting majority, removes an existing cdd claim record."]
      #[codec(index = 13u8)]
      gc_revoke_cdd_claim {
        target: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`,"]
      #[doc = "`claim_type`, and `scope`."]
      #[doc = ""]
      #[doc = "Please note that `origin` must be the issuer of the target claim."]
      #[codec(index = 14u8)]
      revoke_claim_by_index {
        target: ::polymesh_api_client::IdentityId,
        claim_type: polymesh_primitives::identity_claim::ClaimType,
        scope: Option<polymesh_primitives::identity_claim::Scope>,
      },
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change, (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from accept_primary_key in that it will leave the old primary key as a secondary"]
      #[doc = "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization"]
      #[doc = "instead of unlinking the old primary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[codec(index = 15u8)]
      rotate_primary_key_to_secondary {
        auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      },
      #[doc = "Adds secondary keys to target identity `id`."]
      #[doc = ""]
      #[doc = "Keys are directly added to identity because each of them has an authorization."]
      #[doc = ""]
      #[doc = "# Arguments:"]
      #[doc = "    - `origin` which must be the primary key of the identity `id`."]
      #[doc = "    - `id` to which new secondary keys will be added."]
      #[doc = "    - `additional_keys` which includes secondary keys,"]
      #[doc = "       coupled with authorization data, to add to target identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "    - Can only called by primary key owner."]
      #[doc = "    - Keys should be able to linked to any identity."]
      #[codec(index = 16u8)]
      add_secondary_keys_with_authorization {
        additional_keys: ::alloc::vec::Vec<
          polymesh_common_utilities::traits::identity::SecondaryKeyWithAuth<
            ::polymesh_api_client::AccountId,
          >,
        >,
        expires_at: u64,
      },
      #[doc = "Sets permissions for an specific `target_key` key."]
      #[doc = ""]
      #[doc = "Only the primary key of an identity is able to set secondary key permissions."]
      #[codec(index = 17u8)]
      set_secondary_key_permissions {
        key: ::polymesh_api_client::AccountId,
        perms: polymesh_primitives::secondary_key::Permissions,
      },
      #[doc = "Removes specified secondary keys of a DID if present."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[doc = "The extrinsic can only called by primary key owner."]
      #[codec(index = 18u8)]
      remove_secondary_keys {
        keys_to_remove: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      },
      #[doc = "Register custom claim type."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists."]
      #[doc = "* `CounterOverflow` CustomClaimTypeId has overflowed."]
      #[doc = "* `TooLong` The type being registered is too lang."]
      #[codec(index = 19u8)]
      register_custom_claim_type { ty: ::alloc::vec::Vec<u8> },
      #[doc = "Register `target_account` with a new Identity and issue a CDD claim with a blank CddId"]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[codec(index = 20u8)]
      cdd_register_did_with_cdd {
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
        expiry: Option<u64>,
      },
      #[doc = "Create a child identity and make the `secondary_key` it's primary key."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `secondary_key` the secondary key that will become the primary key of the new identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity."]
      #[doc = "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[codec(index = 21u8)]
      create_child_identity {
        secondary_key: ::polymesh_api_client::AccountId,
      },
      #[doc = "Create a child identities."]
      #[doc = ""]
      #[doc = "The new primary key for each child identity will need to sign (off-chain)"]
      #[doc = "an authorization."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_keys` the keys that will become primary keys of their own child identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `AlreadyLinked` one of the keys is already linked to an identity."]
      #[doc = "- `DuplicateKey` one of the keys is included multiple times."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[codec(index = 22u8)]
      create_child_identities {
        child_keys: ::alloc::vec::Vec<
          polymesh_common_utilities::traits::identity::CreateChildIdentityWithAuth<
            ::polymesh_api_client::AccountId,
          >,
        >,
        expires_at: u64,
      },
      #[doc = "Unlink a child identity from it's parent identity."]
      #[doc = ""]
      #[doc = "Only the primary key of the parent or child identities can unlink the identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_did` the child identity to unlink from its parent identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities."]
      #[doc = "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity."]
      #[doc = "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity."]
      #[codec(index = 23u8)]
      unlink_child_identity {
        child_did: ::polymesh_api_client::IdentityId,
      },
    }
    impl IdentityCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::cdd_register_did { .. } => "Identity.cdd_register_did",
          Self::invalidate_cdd_claims { .. } => "Identity.invalidate_cdd_claims",
          Self::accept_primary_key { .. } => "Identity.accept_primary_key",
          Self::change_cdd_requirement_for_mk_rotation { .. } => {
            "Identity.change_cdd_requirement_for_mk_rotation"
          }
          Self::join_identity_as_key { .. } => "Identity.join_identity_as_key",
          Self::leave_identity_as_key => "Identity.leave_identity_as_key",
          Self::add_claim { .. } => "Identity.add_claim",
          Self::revoke_claim { .. } => "Identity.revoke_claim",
          Self::freeze_secondary_keys => "Identity.freeze_secondary_keys",
          Self::unfreeze_secondary_keys => "Identity.unfreeze_secondary_keys",
          Self::add_authorization { .. } => "Identity.add_authorization",
          Self::remove_authorization { .. } => "Identity.remove_authorization",
          Self::gc_add_cdd_claim { .. } => "Identity.gc_add_cdd_claim",
          Self::gc_revoke_cdd_claim { .. } => "Identity.gc_revoke_cdd_claim",
          Self::revoke_claim_by_index { .. } => "Identity.revoke_claim_by_index",
          Self::rotate_primary_key_to_secondary { .. } => {
            "Identity.rotate_primary_key_to_secondary"
          }
          Self::add_secondary_keys_with_authorization { .. } => {
            "Identity.add_secondary_keys_with_authorization"
          }
          Self::set_secondary_key_permissions { .. } => "Identity.set_secondary_key_permissions",
          Self::remove_secondary_keys { .. } => "Identity.remove_secondary_keys",
          Self::register_custom_claim_type { .. } => "Identity.register_custom_claim_type",
          Self::cdd_register_did_with_cdd { .. } => "Identity.cdd_register_did_with_cdd",
          Self::create_child_identity { .. } => "Identity.create_child_identity",
          Self::create_child_identities { .. } => "Identity.create_child_identities",
          Self::unlink_child_identity { .. } => "Identity.unlink_child_identity",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for IdentityCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: cdd_register_did { .. } => { & ["Register `target_account` with a new Identity." , "" , "# Failure" , "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new" , "claims." , "- `target_account` (primary key of the new Identity) can be linked to just one and only" , "one identity." , "- External secondary keys can be linked to just one identity." ,] } , Self :: invalidate_cdd_claims { .. } => { & ["Invalidates any claim generated by `cdd` from `disable_from` timestamps." , "" , "You can also define an expiration time," , "which will invalidate all claims generated by that `cdd` and remove it as CDD member group." ,] } , Self :: accept_primary_key { .. } => { & ["Call this with the new primary key. By invoking this method, caller accepts authorization" , "to become the new primary key of the issuing identity. If a CDD service provider approved" , "this change (or this is not required), primary key of the DID is updated." , "" , "The caller (new primary key) must be either a secondary key of the issuing identity, or" , "unlinked to any identity." , "" , "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key" , "instead of leaving it as a secondary key." , "" , "# Arguments" , "* `owner_auth_id` Authorization from the owner who initiated the change" , "* `cdd_auth_id` Authorization from a CDD service provider" ,] } , Self :: change_cdd_requirement_for_mk_rotation { .. } => { & ["Set if CDD authorization is required for updating primary key of an identity." , "Callable via root (governance)" , "" , "# Arguments" , "* `auth_required` CDD Authorization required or not" ,] } , Self :: join_identity_as_key { .. } => { & ["Join an identity as a secondary key." ,] } , Self :: leave_identity_as_key => { & ["Leave the secondary key's identity." ,] } , Self :: add_claim { .. } => { & ["Adds a new claim record or edits an existing one." , "" , "Only called by did_issuer's secondary key." ,] } , Self :: revoke_claim { .. } => { & ["Marks the specified claim as revoked." ,] } , Self :: freeze_secondary_keys => { & ["It disables all secondary keys at `did` identity." , "" , "# Errors" , "" ,] } , Self :: unfreeze_secondary_keys => { & ["Re-enables all secondary keys of the caller's identity." ,] } , Self :: add_authorization { .. } => { & ["Adds an authorization." ,] } , Self :: remove_authorization { .. } => { & ["Removes an authorization." , "_auth_issuer_pays determines whether the issuer of the authorisation pays the transaction fee" ,] } , Self :: gc_add_cdd_claim { .. } => { & ["Assuming this is executed by the GC voting majority, adds a new cdd claim record." ,] } , Self :: gc_revoke_cdd_claim { .. } => { & ["Assuming this is executed by the GC voting majority, removes an existing cdd claim record." ,] } , Self :: revoke_claim_by_index { .. } => { & ["Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`," , "`claim_type`, and `scope`." , "" , "Please note that `origin` must be the issuer of the target claim." ,] } , Self :: rotate_primary_key_to_secondary { .. } => { & ["Call this with the new primary key. By invoking this method, caller accepts authorization" , "to become the new primary key of the issuing identity. If a CDD service provider approved" , "this change, (or this is not required), primary key of the DID is updated." , "" , "The caller (new primary key) must be either a secondary key of the issuing identity, or" , "unlinked to any identity." , "" , "Differs from accept_primary_key in that it will leave the old primary key as a secondary" , "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization" , "instead of unlinking the old primary key." , "" , "# Arguments" , "* `owner_auth_id` Authorization from the owner who initiated the change" , "* `cdd_auth_id` Authorization from a CDD service provider" ,] } , Self :: add_secondary_keys_with_authorization { .. } => { & ["Adds secondary keys to target identity `id`." , "" , "Keys are directly added to identity because each of them has an authorization." , "" , "# Arguments:" , "    - `origin` which must be the primary key of the identity `id`." , "    - `id` to which new secondary keys will be added." , "    - `additional_keys` which includes secondary keys," , "       coupled with authorization data, to add to target identity." , "" , "# Errors" , "    - Can only called by primary key owner." , "    - Keys should be able to linked to any identity." ,] } , Self :: set_secondary_key_permissions { .. } => { & ["Sets permissions for an specific `target_key` key." , "" , "Only the primary key of an identity is able to set secondary key permissions." ,] } , Self :: remove_secondary_keys { .. } => { & ["Removes specified secondary keys of a DID if present." , "" , "# Errors" , "" , "The extrinsic can only called by primary key owner." ,] } , Self :: register_custom_claim_type { .. } => { & ["Register custom claim type." , "" , "# Errors" , "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists." , "* `CounterOverflow` CustomClaimTypeId has overflowed." , "* `TooLong` The type being registered is too lang." ,] } , Self :: cdd_register_did_with_cdd { .. } => { & ["Register `target_account` with a new Identity and issue a CDD claim with a blank CddId" , "" , "# Failure" , "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new" , "claims." , "- `target_account` (primary key of the new Identity) can be linked to just one and only" , "one identity." , "- External secondary keys can be linked to just one identity." ,] } , Self :: create_child_identity { .. } => { & ["Create a child identity and make the `secondary_key` it's primary key." , "" , "Only the primary key can create child identities." , "" , "# Arguments" , "- `secondary_key` the secondary key that will become the primary key of the new identity." , "" , "# Errors" , "- `KeyNotAllowed` only the primary key can create a new identity." , "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity." , "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity." , "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities." ,] } , Self :: create_child_identities { .. } => { & ["Create a child identities." , "" , "The new primary key for each child identity will need to sign (off-chain)" , "an authorization." , "" , "Only the primary key can create child identities." , "" , "# Arguments" , "- `child_keys` the keys that will become primary keys of their own child identity." , "" , "# Errors" , "- `KeyNotAllowed` only the primary key can create a new identity." , "- `AlreadyLinked` one of the keys is already linked to an identity." , "- `DuplicateKey` one of the keys is included multiple times." , "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities." ,] } , Self :: unlink_child_identity { .. } => { & ["Unlink a child identity from it's parent identity." , "" , "Only the primary key of the parent or child identities can unlink the identities." , "" , "# Arguments" , "- `child_did` the child identity to unlink from its parent identity." , "" , "# Errors" , "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities." , "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity." , "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity." ,] } , _ => & [""] , }
      }
    }
    impl From<IdentityCall> for &'static str {
      fn from(v: IdentityCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&IdentityCall> for &'static str {
      fn from(v: &IdentityCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum IdentityError {
      #[doc = "One secondary or primary key can only belong to one DID"]
      #[codec(index = 0u8)]
      AlreadyLinked,
      #[doc = "Missing current identity on the transaction"]
      #[codec(index = 1u8)]
      MissingCurrentIdentity,
      #[doc = "Signatory is not pre authorized by the identity"]
      #[codec(index = 2u8)]
      Unauthorized,
      #[doc = "Account Id cannot be extracted from signer"]
      #[codec(index = 3u8)]
      InvalidAccountKey,
      #[doc = "Only CDD service providers are allowed."]
      #[codec(index = 4u8)]
      UnAuthorizedCddProvider,
      #[doc = "An invalid authorization from the owner."]
      #[codec(index = 5u8)]
      InvalidAuthorizationFromOwner,
      #[doc = "An invalid authorization from the CDD provider."]
      #[codec(index = 6u8)]
      InvalidAuthorizationFromCddProvider,
      #[doc = "Attestation was not by a CDD service provider."]
      #[codec(index = 7u8)]
      NotCddProviderAttestation,
      #[doc = "Authorizations are not for the same DID."]
      #[codec(index = 8u8)]
      AuthorizationsNotForSameDids,
      #[doc = "The DID must already exist."]
      #[codec(index = 9u8)]
      DidMustAlreadyExist,
      #[doc = "The offchain authorization has expired."]
      #[codec(index = 10u8)]
      AuthorizationExpired,
      #[doc = "The target DID has no valid CDD."]
      #[codec(index = 11u8)]
      TargetHasNoCdd,
      #[doc = "Authorization has been explicitly revoked."]
      #[codec(index = 12u8)]
      AuthorizationHasBeenRevoked,
      #[doc = "An invalid authorization signature."]
      #[codec(index = 13u8)]
      InvalidAuthorizationSignature,
      #[doc = "This key is not allowed to execute a given operation."]
      #[codec(index = 14u8)]
      KeyNotAllowed,
      #[doc = "Only the primary key is allowed to revoke an Identity Signatory off-chain authorization."]
      #[codec(index = 15u8)]
      NotPrimaryKey,
      #[doc = "The DID does not exist."]
      #[codec(index = 16u8)]
      DidDoesNotExist,
      #[doc = "The DID already exists."]
      #[codec(index = 17u8)]
      DidAlreadyExists,
      #[doc = "The secondary keys contain the primary key."]
      #[codec(index = 18u8)]
      SecondaryKeysContainPrimaryKey,
      #[doc = "Couldn't charge fee for the transaction."]
      #[codec(index = 19u8)]
      FailedToChargeFee,
      #[doc = "Signer is not a secondary key of the provided identity"]
      #[codec(index = 20u8)]
      NotASigner,
      #[doc = "Cannot convert a `T::AccountId` to `AnySignature::Signer::AccountId`."]
      #[codec(index = 21u8)]
      CannotDecodeSignerAccountId,
      #[doc = "Multisig can not be unlinked from an identity while it still holds POLYX"]
      #[codec(index = 22u8)]
      MultiSigHasBalance,
      #[doc = "The account key is being used, it can't be unlinked."]
      #[codec(index = 23u8)]
      AccountKeyIsBeingUsed,
      #[doc = "A custom scope is too long."]
      #[doc = "It can at most be `32` characters long."]
      #[codec(index = 24u8)]
      CustomScopeTooLong,
      #[doc = "The custom claim type trying to be registered already exists."]
      #[codec(index = 25u8)]
      CustomClaimTypeAlreadyExists,
      #[doc = "The custom claim type does not exist."]
      #[codec(index = 26u8)]
      CustomClaimTypeDoesNotExist,
      #[doc = "Claim does not exist."]
      #[codec(index = 27u8)]
      ClaimDoesNotExist,
      #[doc = "Identity is already a child of an other identity, can't create grand-child identity."]
      #[codec(index = 28u8)]
      IsChildIdentity,
      #[doc = "The Identity doesn't have a parent identity."]
      #[codec(index = 29u8)]
      NoParentIdentity,
      #[doc = "The caller is not the parent or child identity."]
      #[codec(index = 30u8)]
      NotParentOrChildIdentity,
      #[doc = "The same key was included multiple times."]
      #[codec(index = 31u8)]
      DuplicateKey,
      #[doc = "Cannot use Except when specifying extrinsic permissions."]
      #[codec(index = 32u8)]
      ExceptNotAllowedForExtrinsics,
    }
    impl IdentityError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::AlreadyLinked => "Identity.AlreadyLinked",
          Self::MissingCurrentIdentity => "Identity.MissingCurrentIdentity",
          Self::Unauthorized => "Identity.Unauthorized",
          Self::InvalidAccountKey => "Identity.InvalidAccountKey",
          Self::UnAuthorizedCddProvider => "Identity.UnAuthorizedCddProvider",
          Self::InvalidAuthorizationFromOwner => "Identity.InvalidAuthorizationFromOwner",
          Self::InvalidAuthorizationFromCddProvider => {
            "Identity.InvalidAuthorizationFromCddProvider"
          }
          Self::NotCddProviderAttestation => "Identity.NotCddProviderAttestation",
          Self::AuthorizationsNotForSameDids => "Identity.AuthorizationsNotForSameDids",
          Self::DidMustAlreadyExist => "Identity.DidMustAlreadyExist",
          Self::AuthorizationExpired => "Identity.AuthorizationExpired",
          Self::TargetHasNoCdd => "Identity.TargetHasNoCdd",
          Self::AuthorizationHasBeenRevoked => "Identity.AuthorizationHasBeenRevoked",
          Self::InvalidAuthorizationSignature => "Identity.InvalidAuthorizationSignature",
          Self::KeyNotAllowed => "Identity.KeyNotAllowed",
          Self::NotPrimaryKey => "Identity.NotPrimaryKey",
          Self::DidDoesNotExist => "Identity.DidDoesNotExist",
          Self::DidAlreadyExists => "Identity.DidAlreadyExists",
          Self::SecondaryKeysContainPrimaryKey => "Identity.SecondaryKeysContainPrimaryKey",
          Self::FailedToChargeFee => "Identity.FailedToChargeFee",
          Self::NotASigner => "Identity.NotASigner",
          Self::CannotDecodeSignerAccountId => "Identity.CannotDecodeSignerAccountId",
          Self::MultiSigHasBalance => "Identity.MultiSigHasBalance",
          Self::AccountKeyIsBeingUsed => "Identity.AccountKeyIsBeingUsed",
          Self::CustomScopeTooLong => "Identity.CustomScopeTooLong",
          Self::CustomClaimTypeAlreadyExists => "Identity.CustomClaimTypeAlreadyExists",
          Self::CustomClaimTypeDoesNotExist => "Identity.CustomClaimTypeDoesNotExist",
          Self::ClaimDoesNotExist => "Identity.ClaimDoesNotExist",
          Self::IsChildIdentity => "Identity.IsChildIdentity",
          Self::NoParentIdentity => "Identity.NoParentIdentity",
          Self::NotParentOrChildIdentity => "Identity.NotParentOrChildIdentity",
          Self::DuplicateKey => "Identity.DuplicateKey",
          Self::ExceptNotAllowedForExtrinsics => "Identity.ExceptNotAllowedForExtrinsics",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for IdentityError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: AlreadyLinked => { & ["One secondary or primary key can only belong to one DID" ,] } , Self :: MissingCurrentIdentity => { & ["Missing current identity on the transaction" ,] } , Self :: Unauthorized => { & ["Signatory is not pre authorized by the identity" ,] } , Self :: InvalidAccountKey => { & ["Account Id cannot be extracted from signer" ,] } , Self :: UnAuthorizedCddProvider => { & ["Only CDD service providers are allowed." ,] } , Self :: InvalidAuthorizationFromOwner => { & ["An invalid authorization from the owner." ,] } , Self :: InvalidAuthorizationFromCddProvider => { & ["An invalid authorization from the CDD provider." ,] } , Self :: NotCddProviderAttestation => { & ["Attestation was not by a CDD service provider." ,] } , Self :: AuthorizationsNotForSameDids => { & ["Authorizations are not for the same DID." ,] } , Self :: DidMustAlreadyExist => { & ["The DID must already exist." ,] } , Self :: AuthorizationExpired => { & ["The offchain authorization has expired." ,] } , Self :: TargetHasNoCdd => { & ["The target DID has no valid CDD." ,] } , Self :: AuthorizationHasBeenRevoked => { & ["Authorization has been explicitly revoked." ,] } , Self :: InvalidAuthorizationSignature => { & ["An invalid authorization signature." ,] } , Self :: KeyNotAllowed => { & ["This key is not allowed to execute a given operation." ,] } , Self :: NotPrimaryKey => { & ["Only the primary key is allowed to revoke an Identity Signatory off-chain authorization." ,] } , Self :: DidDoesNotExist => { & ["The DID does not exist." ,] } , Self :: DidAlreadyExists => { & ["The DID already exists." ,] } , Self :: SecondaryKeysContainPrimaryKey => { & ["The secondary keys contain the primary key." ,] } , Self :: FailedToChargeFee => { & ["Couldn't charge fee for the transaction." ,] } , Self :: NotASigner => { & ["Signer is not a secondary key of the provided identity" ,] } , Self :: CannotDecodeSignerAccountId => { & ["Cannot convert a `T::AccountId` to `AnySignature::Signer::AccountId`." ,] } , Self :: MultiSigHasBalance => { & ["Multisig can not be unlinked from an identity while it still holds POLYX" ,] } , Self :: AccountKeyIsBeingUsed => { & ["The account key is being used, it can't be unlinked." ,] } , Self :: CustomScopeTooLong => { & ["A custom scope is too long." , "It can at most be `32` characters long." ,] } , Self :: CustomClaimTypeAlreadyExists => { & ["The custom claim type trying to be registered already exists." ,] } , Self :: CustomClaimTypeDoesNotExist => { & ["The custom claim type does not exist." ,] } , Self :: ClaimDoesNotExist => { & ["Claim does not exist." ,] } , Self :: IsChildIdentity => { & ["Identity is already a child of an other identity, can't create grand-child identity." ,] } , Self :: NoParentIdentity => { & ["The Identity doesn't have a parent identity." ,] } , Self :: NotParentOrChildIdentity => { & ["The caller is not the parent or child identity." ,] } , Self :: DuplicateKey => { & ["The same key was included multiple times." ,] } , Self :: ExceptNotAllowedForExtrinsics => { & ["Cannot use Except when specifying extrinsic permissions." ,] } , _ => & [""] , }
      }
    }
    impl From<IdentityError> for &'static str {
      fn from(v: IdentityError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&IdentityError> for &'static str {
      fn from(v: &IdentityError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_utility {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum UtilityError {
        #[doc = "Too many calls batched."]
        #[codec(index = 0u8)]
        TooManyCalls,
        #[doc = "Offchain signature is invalid"]
        #[doc = "POLYMESH error"]
        #[codec(index = 1u8)]
        InvalidSignature,
        #[doc = "Target does not have a valid CDD"]
        #[doc = "POLYMESH error"]
        #[codec(index = 2u8)]
        TargetCddMissing,
        #[doc = "Provided nonce was invalid"]
        #[doc = "If the provided nonce < current nonce, the call was already executed"]
        #[doc = "If the provided nonce > current nonce, the call(s) before the current failed to execute"]
        #[doc = "POLYMESH error"]
        #[codec(index = 3u8)]
        InvalidNonce,
      }
      impl UtilityError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::TooManyCalls => "Utility.TooManyCalls",
            Self::InvalidSignature => "Utility.InvalidSignature",
            Self::TargetCddMissing => "Utility.TargetCddMissing",
            Self::InvalidNonce => "Utility.InvalidNonce",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for UtilityError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: TooManyCalls => { & ["Too many calls batched." ,] } , Self :: InvalidSignature => { & ["Offchain signature is invalid" , "POLYMESH error" ,] } , Self :: TargetCddMissing => { & ["Target does not have a valid CDD" , "POLYMESH error" ,] } , Self :: InvalidNonce => { & ["Provided nonce was invalid" , "If the provided nonce < current nonce, the call was already executed" , "If the provided nonce > current nonce, the call(s) before the current failed to execute" , "POLYMESH error" ,] } , _ => & [""] , }
        }
      }
      impl From<UtilityError> for &'static str {
        fn from(v: UtilityError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&UtilityError> for &'static str {
        fn from(v: &UtilityError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum UtilityEvent {
        #[doc = "Batch of dispatches did not complete fully. Index of first failing dispatch given, as"]
        #[doc = "well as the error."]
        #[codec(index = 0u8)]
        BatchInterrupted {
          index: u32,
          error: sp_runtime::DispatchError,
        },
        #[doc = "Batch of dispatches completed fully with no error."]
        #[codec(index = 1u8)]
        BatchCompleted,
        #[doc = "Batch of dispatches completed but has errors."]
        #[codec(index = 2u8)]
        BatchCompletedWithErrors,
        #[doc = "A single item within a Batch of dispatches has completed with no error."]
        #[codec(index = 3u8)]
        ItemCompleted,
        #[doc = "A single item within a Batch of dispatches has completed with error."]
        #[codec(index = 4u8)]
        ItemFailed { error: sp_runtime::DispatchError },
        #[doc = "A call was dispatched."]
        #[codec(index = 5u8)]
        DispatchedAs {
          result: Result<(), sp_runtime::DispatchError>,
        },
        #[doc = "Relayed transaction."]
        #[doc = "POLYMESH: event."]
        #[codec(index = 6u8)]
        RelayedTx {
          caller_did: ::polymesh_api_client::IdentityId,
          target: ::polymesh_api_client::AccountId,
          result: Result<(), sp_runtime::DispatchError>,
        },
        #[doc = "Batch of dispatches did not complete fully."]
        #[doc = "Includes a vector of event counts for each dispatch and"]
        #[doc = "the index of the first failing dispatch as well as the error."]
        #[doc = "POLYMESH: event deprecated."]
        #[codec(index = 7u8)]
        BatchInterruptedOld(::alloc::vec::Vec<u32>, (u32, sp_runtime::DispatchError)),
        #[doc = "Batch of dispatches did not complete fully."]
        #[doc = "Includes a vector of event counts for each call and"]
        #[doc = "a vector of any failed dispatches with their indices and associated error."]
        #[doc = "POLYMESH: event deprecated."]
        #[codec(index = 8u8)]
        BatchOptimisticFailed(
          ::alloc::vec::Vec<u32>,
          ::alloc::vec::Vec<(u32, sp_runtime::DispatchError)>,
        ),
        #[doc = "Batch of dispatches completed fully with no error."]
        #[doc = "Includes a vector of event counts for each dispatch."]
        #[doc = "POLYMESH: event deprecated."]
        #[codec(index = 9u8)]
        BatchCompletedOld(::alloc::vec::Vec<u32>),
      }
      impl UtilityEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::BatchInterrupted { .. } => "Utility.BatchInterrupted",
            Self::BatchCompleted => "Utility.BatchCompleted",
            Self::BatchCompletedWithErrors => "Utility.BatchCompletedWithErrors",
            Self::ItemCompleted => "Utility.ItemCompleted",
            Self::ItemFailed { .. } => "Utility.ItemFailed",
            Self::DispatchedAs { .. } => "Utility.DispatchedAs",
            Self::RelayedTx { .. } => "Utility.RelayedTx",
            Self::BatchInterruptedOld(_, _) => "Utility.BatchInterruptedOld",
            Self::BatchOptimisticFailed(_, _) => "Utility.BatchOptimisticFailed",
            Self::BatchCompletedOld(_) => "Utility.BatchCompletedOld",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for UtilityEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: BatchInterrupted { .. } => { & ["Batch of dispatches did not complete fully. Index of first failing dispatch given, as" , "well as the error." ,] } , Self :: BatchCompleted => { & ["Batch of dispatches completed fully with no error." ,] } , Self :: BatchCompletedWithErrors => { & ["Batch of dispatches completed but has errors." ,] } , Self :: ItemCompleted => { & ["A single item within a Batch of dispatches has completed with no error." ,] } , Self :: ItemFailed { .. } => { & ["A single item within a Batch of dispatches has completed with error." ,] } , Self :: DispatchedAs { .. } => { & ["A call was dispatched." ,] } , Self :: RelayedTx { .. } => { & ["Relayed transaction." , "POLYMESH: event." ,] } , Self :: BatchInterruptedOld (_ , _) => { & ["Batch of dispatches did not complete fully." , "Includes a vector of event counts for each dispatch and" , "the index of the first failing dispatch as well as the error." , "POLYMESH: event deprecated." ,] } , Self :: BatchOptimisticFailed (_ , _) => { & ["Batch of dispatches did not complete fully." , "Includes a vector of event counts for each call and" , "a vector of any failed dispatches with their indices and associated error." , "POLYMESH: event deprecated." ,] } , Self :: BatchCompletedOld (_) => { & ["Batch of dispatches completed fully with no error." , "Includes a vector of event counts for each dispatch." , "POLYMESH: event deprecated." ,] } , _ => & [""] , }
        }
      }
      impl From<UtilityEvent> for &'static str {
        fn from(v: UtilityEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&UtilityEvent> for &'static str {
        fn from(v: &UtilityEvent) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum UtilityCall {
        #[doc = "Send a batch of dispatch calls."]
        #[doc = ""]
        #[doc = "May be called from any origin except `None`."]
        #[doc = ""]
        #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
        #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
        #[doc = ""]
        #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
        #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- O(C) where C is the number of calls to be batched."]
        #[doc = ""]
        #[doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"]
        #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
        #[doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"]
        #[doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"]
        #[doc = "event is deposited."]
        #[codec(index = 0u8)]
        batch {
          calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
        },
        #[doc = "Relay a call for a target from an origin"]
        #[doc = ""]
        #[doc = "Relaying in this context refers to the ability of origin to make a call on behalf of"]
        #[doc = "target."]
        #[doc = ""]
        #[doc = "Fees are charged to origin"]
        #[doc = ""]
        #[doc = "# Parameters"]
        #[doc = "- `target`: Account to be relayed"]
        #[doc = "- `signature`: Signature from target authorizing the relay"]
        #[doc = "- `call`: Call to be relayed on behalf of target"]
        #[doc = ""]
        #[doc = "POLYMESH: added."]
        #[codec(index = 1u8)]
        relay_tx {
          target: ::polymesh_api_client::AccountId,
          signature: sp_runtime::MultiSignature,
          call: pallet_utility::UniqueCall<runtime::RuntimeCall>,
        },
        #[doc = "Send a batch of dispatch calls and atomically execute them."]
        #[doc = "The whole transaction will rollback and fail if any of the calls failed."]
        #[doc = ""]
        #[doc = "May be called from any origin except `None`."]
        #[doc = ""]
        #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
        #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
        #[doc = ""]
        #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
        #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- O(C) where C is the number of calls to be batched."]
        #[codec(index = 2u8)]
        batch_all {
          calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
        },
        #[doc = "Dispatches a function call with a provided origin."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Root_."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- O(1)."]
        #[codec(index = 3u8)]
        dispatch_as {
          as_origin: ::alloc::boxed::Box<runtime::OriginCaller>,
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
        },
        #[doc = "Send a batch of dispatch calls."]
        #[doc = "Unlike `batch`, it allows errors and won't interrupt."]
        #[doc = ""]
        #[doc = "May be called from any origin except `None`."]
        #[doc = ""]
        #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
        #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
        #[doc = ""]
        #[doc = "If origin is root then the calls are dispatch without checking origin filter. (This"]
        #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- O(C) where C is the number of calls to be batched."]
        #[codec(index = 4u8)]
        force_batch {
          calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
        },
        #[doc = "Dispatch a function call with a specified weight."]
        #[doc = ""]
        #[doc = "This function does not check the weight of the call, and instead allows the"]
        #[doc = "Root origin to specify the weight of the call."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Root_."]
        #[codec(index = 5u8)]
        with_weight {
          call: ::alloc::boxed::Box<runtime::RuntimeCall>,
          weight: ::polymesh_api_client::sp_weights::Weight,
        },
        #[doc = "Dispatch multiple calls from the sender's origin."]
        #[doc = ""]
        #[doc = "This will execute until the first one fails and then stop."]
        #[doc = ""]
        #[doc = "May be called from root or a signed origin."]
        #[doc = ""]
        #[doc = "# Parameters"]
        #[doc = "- `calls`: The calls to be dispatched from the same origin."]
        #[doc = ""]
        #[doc = "# Weight"]
        #[doc = "- The sum of the weights of the `calls`."]
        #[doc = "- One event."]
        #[doc = ""]
        #[doc = "This will return `Ok` in all circumstances except an unsigned origin. To determine the success of the batch, an"]
        #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
        #[doc = "`BatchInterruptedOld` event is deposited, along with the number of successful calls made"]
        #[doc = "and the error of the failed call. If all were successful, then the `BatchCompletedOld`"]
        #[doc = "event is deposited."]
        #[doc = ""]
        #[doc = "POLYMESH: Renamed from `batch` and deprecated."]
        #[codec(index = 6u8)]
        batch_old {
          calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
        },
        #[doc = "Dispatch multiple calls from the sender's origin."]
        #[doc = ""]
        #[doc = "This will execute all calls, in order, stopping at the first failure,"]
        #[doc = "in which case the state changes are rolled back."]
        #[doc = "On failure, an event `BatchInterruptedOld(failure_idx, error)` is deposited."]
        #[doc = ""]
        #[doc = "May be called from root or a signed origin."]
        #[doc = ""]
        #[doc = "# Parameters"]
        #[doc = "- `calls`: The calls to be dispatched from the same origin."]
        #[doc = ""]
        #[doc = "# Weight"]
        #[doc = "- The sum of the weights of the `calls`."]
        #[doc = "- One event."]
        #[doc = ""]
        #[doc = "This will return `Ok` in all circumstances except an unsigned origin."]
        #[doc = "To determine the success of the batch, an event is deposited."]
        #[doc = "If any call failed, then `BatchInterruptedOld` is deposited."]
        #[doc = "If all were successful, then the `BatchCompletedOld` event is deposited."]
        #[doc = ""]
        #[doc = "POLYMESH: deprecated."]
        #[codec(index = 7u8)]
        batch_atomic {
          calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
        },
        #[doc = "Dispatch multiple calls from the sender's origin."]
        #[doc = ""]
        #[doc = "This will execute all calls, in order, irrespective of failures."]
        #[doc = "Any failures will be available in a `BatchOptimisticFailed` event."]
        #[doc = ""]
        #[doc = "May be called from root or a signed origin."]
        #[doc = ""]
        #[doc = "# Parameters"]
        #[doc = "- `calls`: The calls to be dispatched from the same origin."]
        #[doc = ""]
        #[doc = ""]
        #[doc = "# Weight"]
        #[doc = "- The sum of the weights of the `calls`."]
        #[doc = "- One event."]
        #[doc = ""]
        #[doc = "This will return `Ok` in all circumstances except an unsigned origin."]
        #[doc = "To determine the success of the batch, an event is deposited."]
        #[doc = "If any call failed, then `BatchOptimisticFailed` is deposited,"]
        #[doc = "with a vector of event counts for each call as well as a vector"]
        #[doc = "of errors."]
        #[doc = "If all were successful, then the `BatchCompletedOld` event is deposited."]
        #[doc = ""]
        #[doc = "POLYMESH: deprecated."]
        #[codec(index = 8u8)]
        batch_optimistic {
          calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
        },
      }
      impl UtilityCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::batch { .. } => "Utility.batch",
            Self::relay_tx { .. } => "Utility.relay_tx",
            Self::batch_all { .. } => "Utility.batch_all",
            Self::dispatch_as { .. } => "Utility.dispatch_as",
            Self::force_batch { .. } => "Utility.force_batch",
            Self::with_weight { .. } => "Utility.with_weight",
            Self::batch_old { .. } => "Utility.batch_old",
            Self::batch_atomic { .. } => "Utility.batch_atomic",
            Self::batch_optimistic { .. } => "Utility.batch_optimistic",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for UtilityCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: batch { .. } => { & ["Send a batch of dispatch calls." , "" , "May be called from any origin except `None`." , "" , "- `calls`: The calls to be dispatched from the same origin. The number of call must not" , "  exceed the constant: `batched_calls_limit` (available in constant metadata)." , "" , "If origin is root then the calls are dispatched without checking origin filter. (This" , "includes bypassing `frame_system::Config::BaseCallFilter`)." , "" , "## Complexity" , "- O(C) where C is the number of calls to be batched." , "" , "This will return `Ok` in all circumstances. To determine the success of the batch, an" , "event is deposited. If a call failed and the batch was interrupted, then the" , "`BatchInterrupted` event is deposited, along with the number of successful calls made" , "and the error of the failed call. If all were successful, then the `BatchCompleted`" , "event is deposited." ,] } , Self :: relay_tx { .. } => { & ["Relay a call for a target from an origin" , "" , "Relaying in this context refers to the ability of origin to make a call on behalf of" , "target." , "" , "Fees are charged to origin" , "" , "# Parameters" , "- `target`: Account to be relayed" , "- `signature`: Signature from target authorizing the relay" , "- `call`: Call to be relayed on behalf of target" , "" , "POLYMESH: added." ,] } , Self :: batch_all { .. } => { & ["Send a batch of dispatch calls and atomically execute them." , "The whole transaction will rollback and fail if any of the calls failed." , "" , "May be called from any origin except `None`." , "" , "- `calls`: The calls to be dispatched from the same origin. The number of call must not" , "  exceed the constant: `batched_calls_limit` (available in constant metadata)." , "" , "If origin is root then the calls are dispatched without checking origin filter. (This" , "includes bypassing `frame_system::Config::BaseCallFilter`)." , "" , "## Complexity" , "- O(C) where C is the number of calls to be batched." ,] } , Self :: dispatch_as { .. } => { & ["Dispatches a function call with a provided origin." , "" , "The dispatch origin for this call must be _Root_." , "" , "## Complexity" , "- O(1)." ,] } , Self :: force_batch { .. } => { & ["Send a batch of dispatch calls." , "Unlike `batch`, it allows errors and won't interrupt." , "" , "May be called from any origin except `None`." , "" , "- `calls`: The calls to be dispatched from the same origin. The number of call must not" , "  exceed the constant: `batched_calls_limit` (available in constant metadata)." , "" , "If origin is root then the calls are dispatch without checking origin filter. (This" , "includes bypassing `frame_system::Config::BaseCallFilter`)." , "" , "## Complexity" , "- O(C) where C is the number of calls to be batched." ,] } , Self :: with_weight { .. } => { & ["Dispatch a function call with a specified weight." , "" , "This function does not check the weight of the call, and instead allows the" , "Root origin to specify the weight of the call." , "" , "The dispatch origin for this call must be _Root_." ,] } , Self :: batch_old { .. } => { & ["Dispatch multiple calls from the sender's origin." , "" , "This will execute until the first one fails and then stop." , "" , "May be called from root or a signed origin." , "" , "# Parameters" , "- `calls`: The calls to be dispatched from the same origin." , "" , "# Weight" , "- The sum of the weights of the `calls`." , "- One event." , "" , "This will return `Ok` in all circumstances except an unsigned origin. To determine the success of the batch, an" , "event is deposited. If a call failed and the batch was interrupted, then the" , "`BatchInterruptedOld` event is deposited, along with the number of successful calls made" , "and the error of the failed call. If all were successful, then the `BatchCompletedOld`" , "event is deposited." , "" , "POLYMESH: Renamed from `batch` and deprecated." ,] } , Self :: batch_atomic { .. } => { & ["Dispatch multiple calls from the sender's origin." , "" , "This will execute all calls, in order, stopping at the first failure," , "in which case the state changes are rolled back." , "On failure, an event `BatchInterruptedOld(failure_idx, error)` is deposited." , "" , "May be called from root or a signed origin." , "" , "# Parameters" , "- `calls`: The calls to be dispatched from the same origin." , "" , "# Weight" , "- The sum of the weights of the `calls`." , "- One event." , "" , "This will return `Ok` in all circumstances except an unsigned origin." , "To determine the success of the batch, an event is deposited." , "If any call failed, then `BatchInterruptedOld` is deposited." , "If all were successful, then the `BatchCompletedOld` event is deposited." , "" , "POLYMESH: deprecated." ,] } , Self :: batch_optimistic { .. } => { & ["Dispatch multiple calls from the sender's origin." , "" , "This will execute all calls, in order, irrespective of failures." , "Any failures will be available in a `BatchOptimisticFailed` event." , "" , "May be called from root or a signed origin." , "" , "# Parameters" , "- `calls`: The calls to be dispatched from the same origin." , "" , "" , "# Weight" , "- The sum of the weights of the `calls`." , "- One event." , "" , "This will return `Ok` in all circumstances except an unsigned origin." , "To determine the success of the batch, an event is deposited." , "If any call failed, then `BatchOptimisticFailed` is deposited," , "with a vector of event counts for each call as well as a vector" , "of errors." , "If all were successful, then the `BatchCompletedOld` event is deposited." , "" , "POLYMESH: deprecated." ,] } , _ => & [""] , }
        }
      }
      impl From<UtilityCall> for &'static str {
        fn from(v: UtilityCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&UtilityCall> for &'static str {
        fn from(v: &UtilityCall) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct UniqueCall<C> {
      pub nonce: u64,
      pub call: ::alloc::boxed::Box<C>,
    }
  }
  pub mod pallet_preimage {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PreimageError {
        #[doc = "Preimage is too large to store on-chain."]
        #[codec(index = 0u8)]
        TooBig,
        #[doc = "Preimage has already been noted on-chain."]
        #[codec(index = 1u8)]
        AlreadyNoted,
        #[doc = "The user is not authorized to perform this action."]
        #[codec(index = 2u8)]
        NotAuthorized,
        #[doc = "The preimage cannot be removed since it has not yet been noted."]
        #[codec(index = 3u8)]
        NotNoted,
        #[doc = "A preimage may not be removed when there are outstanding requests."]
        #[codec(index = 4u8)]
        Requested,
        #[doc = "The preimage request cannot be removed since no outstanding requests exist."]
        #[codec(index = 5u8)]
        NotRequested,
      }
      impl PreimageError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::TooBig => "Preimage.TooBig",
            Self::AlreadyNoted => "Preimage.AlreadyNoted",
            Self::NotAuthorized => "Preimage.NotAuthorized",
            Self::NotNoted => "Preimage.NotNoted",
            Self::Requested => "Preimage.Requested",
            Self::NotRequested => "Preimage.NotRequested",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for PreimageError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::TooBig => &["Preimage is too large to store on-chain."],
            Self::AlreadyNoted => &["Preimage has already been noted on-chain."],
            Self::NotAuthorized => &["The user is not authorized to perform this action."],
            Self::NotNoted => &["The preimage cannot be removed since it has not yet been noted."],
            Self::Requested => {
              &["A preimage may not be removed when there are outstanding requests."]
            }
            Self::NotRequested => {
              &["The preimage request cannot be removed since no outstanding requests exist."]
            }
            _ => &[""],
          }
        }
      }
      impl From<PreimageError> for &'static str {
        fn from(v: PreimageError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&PreimageError> for &'static str {
        fn from(v: &PreimageError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PreimageCall {
        #[doc = "Register a preimage on-chain."]
        #[doc = ""]
        #[doc = "If the preimage was previously requested, no fees or deposits are taken for providing"]
        #[doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."]
        #[codec(index = 0u8)]
        note_preimage { bytes: ::alloc::vec::Vec<u8> },
        #[doc = "Clear an unrequested preimage from the runtime storage."]
        #[doc = ""]
        #[doc = "If `len` is provided, then it will be a much cheaper operation."]
        #[doc = ""]
        #[doc = "- `hash`: The hash of the preimage to be removed from the store."]
        #[doc = "- `len`: The length of the preimage of `hash`."]
        #[codec(index = 1u8)]
        unnote_preimage { hash: primitive_types::H256 },
        #[doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."]
        #[doc = ""]
        #[doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"]
        #[doc = "a user may have paid, and take the control of the preimage out of their hands."]
        #[codec(index = 2u8)]
        request_preimage { hash: primitive_types::H256 },
        #[doc = "Clear a previously made request for a preimage."]
        #[doc = ""]
        #[doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."]
        #[codec(index = 3u8)]
        unrequest_preimage { hash: primitive_types::H256 },
      }
      impl PreimageCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::note_preimage { .. } => "Preimage.note_preimage",
            Self::unnote_preimage { .. } => "Preimage.unnote_preimage",
            Self::request_preimage { .. } => "Preimage.request_preimage",
            Self::unrequest_preimage { .. } => "Preimage.unrequest_preimage",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for PreimageCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: note_preimage { .. } => { & ["Register a preimage on-chain." , "" , "If the preimage was previously requested, no fees or deposits are taken for providing" , "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage." ,] } , Self :: unnote_preimage { .. } => { & ["Clear an unrequested preimage from the runtime storage." , "" , "If `len` is provided, then it will be a much cheaper operation." , "" , "- `hash`: The hash of the preimage to be removed from the store." , "- `len`: The length of the preimage of `hash`." ,] } , Self :: request_preimage { .. } => { & ["Request a preimage be uploaded to the chain without paying any fees or deposits." , "" , "If the preimage requests has already been provided on-chain, we unreserve any deposit" , "a user may have paid, and take the control of the preimage out of their hands." ,] } , Self :: unrequest_preimage { .. } => { & ["Clear a previously made request for a preimage." , "" , "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`." ,] } , _ => & [""] , }
        }
      }
      impl From<PreimageCall> for &'static str {
        fn from(v: PreimageCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&PreimageCall> for &'static str {
        fn from(v: &PreimageCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum PreimageEvent {
        #[doc = "A preimage has been noted."]
        #[codec(index = 0u8)]
        Noted { hash: primitive_types::H256 },
        #[doc = "A preimage has been requested."]
        #[codec(index = 1u8)]
        Requested { hash: primitive_types::H256 },
        #[doc = "A preimage has ben cleared."]
        #[codec(index = 2u8)]
        Cleared { hash: primitive_types::H256 },
      }
      impl PreimageEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Noted { .. } => "Preimage.Noted",
            Self::Requested { .. } => "Preimage.Requested",
            Self::Cleared { .. } => "Preimage.Cleared",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for PreimageEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::Noted { .. } => &["A preimage has been noted."],
            Self::Requested { .. } => &["A preimage has been requested."],
            Self::Cleared { .. } => &["A preimage has ben cleared."],
            _ => &[""],
          }
        }
      }
      impl From<PreimageEvent> for &'static str {
        fn from(v: PreimageEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&PreimageEvent> for &'static str {
        fn from(v: &PreimageEvent) -> Self {
          v.as_static_str()
        }
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RequestStatus<AccountId, Balance> {
      #[codec(index = 0u8)]
      Unrequested {
        deposit: (AccountId, Balance),
        len: u32,
      },
      #[codec(index = 1u8)]
      Requested {
        deposit: Option<(AccountId, Balance)>,
        count: u32,
        len: Option<u32>,
      },
    }
  }
  pub mod pallet_portfolio {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PortfolioCall {
      #[doc = "Creates a portfolio with the given `name`."]
      #[codec(index = 0u8)]
      create_portfolio {
        name: polymesh_primitives::identity_id::PortfolioName,
      },
      #[doc = "Deletes a user portfolio. A portfolio can be deleted only if it has no funds."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = "* `PortfolioNotEmpty` if the portfolio still holds any asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 1u8)]
      delete_portfolio {
        num: polymesh_primitives::identity_id::PortfolioNumber,
      },
      #[doc = "Renames a non-default portfolio."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 2u8)]
      rename_portfolio {
        num: polymesh_primitives::identity_id::PortfolioNumber,
        to_name: polymesh_primitives::identity_id::PortfolioName,
      },
      #[doc = "When called by the custodian of `portfolio_id`,"]
      #[doc = "allows returning the custody of the portfolio to the portfolio owner unilaterally."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 3u8)]
      quit_portfolio_custody {
        pid: polymesh_primitives::identity_id::PortfolioId,
      },
      #[codec(index = 4u8)]
      accept_portfolio_custody { auth_id: u64 },
      #[doc = "Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same"]
      #[doc = "identity. Must be called by the custodian of the sender."]
      #[doc = "Funds from deleted portfolios can also be recovered via this method."]
      #[doc = ""]
      #[doc = "A short memo can be added to to each token amount moved."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio."]
      #[doc = "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same"]
      #[doc = "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio"]
      #[doc = "* `InsufficientPortfolioBalance` if the sender does not have enough free balance"]
      #[doc = "* `NoDuplicateAssetsAllowed` the same ticker can't be repeated in the items vector."]
      #[doc = "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own."]
      #[doc = "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 5u8)]
      move_portfolio_funds {
        from: polymesh_primitives::identity_id::PortfolioId,
        to: polymesh_primitives::identity_id::PortfolioId,
        funds: ::alloc::vec::Vec<polymesh_primitives::portfolio::Fund>,
      },
      #[doc = "Pre-approves the receivement of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `ticker` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 6u8)]
      pre_approve_portfolio {
        ticker: polymesh_primitives::ticker::Ticker,
        portfolio_id: polymesh_primitives::identity_id::PortfolioId,
      },
      #[doc = "Removes the pre approval of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `ticker` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 7u8)]
      remove_portfolio_pre_approval {
        ticker: polymesh_primitives::ticker::Ticker,
        portfolio_id: polymesh_primitives::identity_id::PortfolioId,
      },
    }
    impl PortfolioCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_portfolio { .. } => "Portfolio.create_portfolio",
          Self::delete_portfolio { .. } => "Portfolio.delete_portfolio",
          Self::rename_portfolio { .. } => "Portfolio.rename_portfolio",
          Self::quit_portfolio_custody { .. } => "Portfolio.quit_portfolio_custody",
          Self::accept_portfolio_custody { .. } => "Portfolio.accept_portfolio_custody",
          Self::move_portfolio_funds { .. } => "Portfolio.move_portfolio_funds",
          Self::pre_approve_portfolio { .. } => "Portfolio.pre_approve_portfolio",
          Self::remove_portfolio_pre_approval { .. } => "Portfolio.remove_portfolio_pre_approval",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PortfolioCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: create_portfolio { .. } => { & ["Creates a portfolio with the given `name`." ,] } , Self :: delete_portfolio { .. } => { & ["Deletes a user portfolio. A portfolio can be deleted only if it has no funds." , "" , "# Errors" , "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio." , "* `PortfolioNotEmpty` if the portfolio still holds any asset" , "" , "# Permissions" , "* Portfolio" ,] } , Self :: rename_portfolio { .. } => { & ["Renames a non-default portfolio." , "" , "# Errors" , "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: quit_portfolio_custody { .. } => { & ["When called by the custodian of `portfolio_id`," , "allows returning the custody of the portfolio to the portfolio owner unilaterally." , "" , "# Errors" , "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: accept_portfolio_custody { .. } => { & ["" ,] } , Self :: move_portfolio_funds { .. } => { & ["Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same" , "identity. Must be called by the custodian of the sender." , "Funds from deleted portfolios can also be recovered via this method." , "" , "A short memo can be added to to each token amount moved." , "" , "# Errors" , "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio." , "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same" , "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities" , "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio" , "* `InsufficientPortfolioBalance` if the sender does not have enough free balance" , "* `NoDuplicateAssetsAllowed` the same ticker can't be repeated in the items vector." , "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own." , "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: pre_approve_portfolio { .. } => { & ["Pre-approves the receivement of an asset to a portfolio." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the [`Ticker`] that will be exempt from affirmation." , "* `portfolio_id` - the [`PortfolioId`] that can receive `ticker` without affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: remove_portfolio_pre_approval { .. } => { & ["Removes the pre approval of an asset to a portfolio." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the [`Ticker`] that will be exempt from affirmation." , "* `portfolio_id` - the [`PortfolioId`] that can receive `ticker` without affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , _ => & [""] , }
      }
    }
    impl From<PortfolioCall> for &'static str {
      fn from(v: PortfolioCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PortfolioCall> for &'static str {
      fn from(v: &PortfolioCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum PortfolioError {
      #[doc = "The portfolio doesn't exist."]
      #[codec(index = 0u8)]
      PortfolioDoesNotExist,
      #[doc = "Insufficient balance for a transaction."]
      #[codec(index = 1u8)]
      InsufficientPortfolioBalance,
      #[doc = "The source and destination portfolios should be different."]
      #[codec(index = 2u8)]
      DestinationIsSamePortfolio,
      #[doc = "The portfolio couldn't be renamed because the chosen name is already in use."]
      #[codec(index = 3u8)]
      PortfolioNameAlreadyInUse,
      #[doc = "The secondary key is not authorized to access the portfolio(s)."]
      #[codec(index = 4u8)]
      SecondaryKeyNotAuthorizedForPortfolio,
      #[doc = "The porfolio's custody is with someone other than the caller."]
      #[codec(index = 5u8)]
      UnauthorizedCustodian,
      #[doc = "Can not unlock more tokens than what are locked"]
      #[codec(index = 6u8)]
      InsufficientTokensLocked,
      #[doc = "The portfolio still has some asset balance left"]
      #[codec(index = 7u8)]
      PortfolioNotEmpty,
      #[doc = "The portfolios belong to different identities"]
      #[codec(index = 8u8)]
      DifferentIdentityPortfolios,
      #[doc = "Duplicate asset among the items."]
      #[codec(index = 9u8)]
      NoDuplicateAssetsAllowed,
      #[doc = "The NFT does not exist in the portfolio."]
      #[codec(index = 10u8)]
      NFTNotFoundInPortfolio,
      #[doc = "The NFT is already locked."]
      #[codec(index = 11u8)]
      NFTAlreadyLocked,
      #[doc = "The NFT has never been locked."]
      #[codec(index = 12u8)]
      NFTNotLocked,
      #[doc = "Only owned NFTs can be moved between portfolios."]
      #[codec(index = 13u8)]
      InvalidTransferNFTNotOwned,
      #[doc = "Locked NFTs can not be moved between portfolios."]
      #[codec(index = 14u8)]
      InvalidTransferNFTIsLocked,
      #[doc = "Trying to move an amount of zero assets."]
      #[codec(index = 15u8)]
      EmptyTransfer,
    }
    impl PortfolioError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::PortfolioDoesNotExist => "Portfolio.PortfolioDoesNotExist",
          Self::InsufficientPortfolioBalance => "Portfolio.InsufficientPortfolioBalance",
          Self::DestinationIsSamePortfolio => "Portfolio.DestinationIsSamePortfolio",
          Self::PortfolioNameAlreadyInUse => "Portfolio.PortfolioNameAlreadyInUse",
          Self::SecondaryKeyNotAuthorizedForPortfolio => {
            "Portfolio.SecondaryKeyNotAuthorizedForPortfolio"
          }
          Self::UnauthorizedCustodian => "Portfolio.UnauthorizedCustodian",
          Self::InsufficientTokensLocked => "Portfolio.InsufficientTokensLocked",
          Self::PortfolioNotEmpty => "Portfolio.PortfolioNotEmpty",
          Self::DifferentIdentityPortfolios => "Portfolio.DifferentIdentityPortfolios",
          Self::NoDuplicateAssetsAllowed => "Portfolio.NoDuplicateAssetsAllowed",
          Self::NFTNotFoundInPortfolio => "Portfolio.NFTNotFoundInPortfolio",
          Self::NFTAlreadyLocked => "Portfolio.NFTAlreadyLocked",
          Self::NFTNotLocked => "Portfolio.NFTNotLocked",
          Self::InvalidTransferNFTNotOwned => "Portfolio.InvalidTransferNFTNotOwned",
          Self::InvalidTransferNFTIsLocked => "Portfolio.InvalidTransferNFTIsLocked",
          Self::EmptyTransfer => "Portfolio.EmptyTransfer",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for PortfolioError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::PortfolioDoesNotExist => &["The portfolio doesn't exist."],
          Self::InsufficientPortfolioBalance => &["Insufficient balance for a transaction."],
          Self::DestinationIsSamePortfolio => {
            &["The source and destination portfolios should be different."]
          }
          Self::PortfolioNameAlreadyInUse => {
            &["The portfolio couldn't be renamed because the chosen name is already in use."]
          }
          Self::SecondaryKeyNotAuthorizedForPortfolio => {
            &["The secondary key is not authorized to access the portfolio(s)."]
          }
          Self::UnauthorizedCustodian => {
            &["The porfolio's custody is with someone other than the caller."]
          }
          Self::InsufficientTokensLocked => &["Can not unlock more tokens than what are locked"],
          Self::PortfolioNotEmpty => &["The portfolio still has some asset balance left"],
          Self::DifferentIdentityPortfolios => &["The portfolios belong to different identities"],
          Self::NoDuplicateAssetsAllowed => &["Duplicate asset among the items."],
          Self::NFTNotFoundInPortfolio => &["The NFT does not exist in the portfolio."],
          Self::NFTAlreadyLocked => &["The NFT is already locked."],
          Self::NFTNotLocked => &["The NFT has never been locked."],
          Self::InvalidTransferNFTNotOwned => &["Only owned NFTs can be moved between portfolios."],
          Self::InvalidTransferNFTIsLocked => &["Locked NFTs can not be moved between portfolios."],
          Self::EmptyTransfer => &["Trying to move an amount of zero assets."],
          _ => &[""],
        }
      }
    }
    impl From<PortfolioError> for &'static str {
      fn from(v: PortfolioError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&PortfolioError> for &'static str {
      fn from(v: &PortfolioError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_multisig {
    use super::*;
    #[doc = "Multisig module errors."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum MultiSigError {
      #[doc = "The multisig is not attached to a CDD'd identity."]
      #[codec(index = 0u8)]
      CddMissing,
      #[doc = "The proposal does not exist."]
      #[codec(index = 1u8)]
      ProposalMissing,
      #[doc = "Multisig address."]
      #[codec(index = 2u8)]
      DecodingError,
      #[doc = "No signers."]
      #[codec(index = 3u8)]
      NoSigners,
      #[doc = "Too few or too many required signatures."]
      #[codec(index = 4u8)]
      RequiredSignaturesOutOfBounds,
      #[doc = "Not a signer."]
      #[codec(index = 5u8)]
      NotASigner,
      #[doc = "No such multisig."]
      #[codec(index = 6u8)]
      NoSuchMultisig,
      #[doc = "Not enough signers."]
      #[codec(index = 7u8)]
      NotEnoughSigners,
      #[doc = "A nonce overflow."]
      #[codec(index = 8u8)]
      NonceOverflow,
      #[doc = "Already voted."]
      #[codec(index = 9u8)]
      AlreadyVoted,
      #[doc = "Already a signer."]
      #[codec(index = 10u8)]
      AlreadyASigner,
      #[doc = "Couldn't charge fee for the transaction."]
      #[codec(index = 11u8)]
      FailedToChargeFee,
      #[doc = "Identity provided is not the multisig's creator."]
      #[codec(index = 12u8)]
      IdentityNotCreator,
      #[doc = "Changing multisig parameters not allowed since multisig is a primary key."]
      #[codec(index = 13u8)]
      ChangeNotAllowed,
      #[doc = "Signer is an account key that is already associated with a multisig."]
      #[codec(index = 14u8)]
      SignerAlreadyLinkedToMultisig,
      #[doc = "Signer is an account key that is already associated with an identity."]
      #[codec(index = 15u8)]
      SignerAlreadyLinkedToIdentity,
      #[doc = "Multisig not allowed to add itself as a signer."]
      #[codec(index = 16u8)]
      MultisigNotAllowedToLinkToItself,
      #[doc = "Current DID is missing"]
      #[codec(index = 17u8)]
      MissingCurrentIdentity,
      #[doc = "The function can only be called by the primary key of the did"]
      #[codec(index = 18u8)]
      NotPrimaryKey,
      #[doc = "Proposal was rejected earlier"]
      #[codec(index = 19u8)]
      ProposalAlreadyRejected,
      #[doc = "Proposal has expired"]
      #[codec(index = 20u8)]
      ProposalExpired,
      #[doc = "Proposal was executed earlier"]
      #[codec(index = 21u8)]
      ProposalAlreadyExecuted,
      #[doc = "Multisig is not attached to an identity"]
      #[codec(index = 22u8)]
      MultisigMissingIdentity,
      #[doc = "Scheduling of a proposal fails"]
      #[codec(index = 23u8)]
      FailedToSchedule,
      #[doc = "More signers than required."]
      #[codec(index = 24u8)]
      TooManySigners,
      #[doc = "The creator is no longer allowed to call via creator extrinsics."]
      #[codec(index = 25u8)]
      CreatorControlsHaveBeenRemoved,
    }
    impl MultiSigError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::CddMissing => "MultiSig.CddMissing",
          Self::ProposalMissing => "MultiSig.ProposalMissing",
          Self::DecodingError => "MultiSig.DecodingError",
          Self::NoSigners => "MultiSig.NoSigners",
          Self::RequiredSignaturesOutOfBounds => "MultiSig.RequiredSignaturesOutOfBounds",
          Self::NotASigner => "MultiSig.NotASigner",
          Self::NoSuchMultisig => "MultiSig.NoSuchMultisig",
          Self::NotEnoughSigners => "MultiSig.NotEnoughSigners",
          Self::NonceOverflow => "MultiSig.NonceOverflow",
          Self::AlreadyVoted => "MultiSig.AlreadyVoted",
          Self::AlreadyASigner => "MultiSig.AlreadyASigner",
          Self::FailedToChargeFee => "MultiSig.FailedToChargeFee",
          Self::IdentityNotCreator => "MultiSig.IdentityNotCreator",
          Self::ChangeNotAllowed => "MultiSig.ChangeNotAllowed",
          Self::SignerAlreadyLinkedToMultisig => "MultiSig.SignerAlreadyLinkedToMultisig",
          Self::SignerAlreadyLinkedToIdentity => "MultiSig.SignerAlreadyLinkedToIdentity",
          Self::MultisigNotAllowedToLinkToItself => "MultiSig.MultisigNotAllowedToLinkToItself",
          Self::MissingCurrentIdentity => "MultiSig.MissingCurrentIdentity",
          Self::NotPrimaryKey => "MultiSig.NotPrimaryKey",
          Self::ProposalAlreadyRejected => "MultiSig.ProposalAlreadyRejected",
          Self::ProposalExpired => "MultiSig.ProposalExpired",
          Self::ProposalAlreadyExecuted => "MultiSig.ProposalAlreadyExecuted",
          Self::MultisigMissingIdentity => "MultiSig.MultisigMissingIdentity",
          Self::FailedToSchedule => "MultiSig.FailedToSchedule",
          Self::TooManySigners => "MultiSig.TooManySigners",
          Self::CreatorControlsHaveBeenRemoved => "MultiSig.CreatorControlsHaveBeenRemoved",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for MultiSigError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::CddMissing => &["The multisig is not attached to a CDD'd identity."],
          Self::ProposalMissing => &["The proposal does not exist."],
          Self::DecodingError => &["Multisig address."],
          Self::NoSigners => &["No signers."],
          Self::RequiredSignaturesOutOfBounds => &["Too few or too many required signatures."],
          Self::NotASigner => &["Not a signer."],
          Self::NoSuchMultisig => &["No such multisig."],
          Self::NotEnoughSigners => &["Not enough signers."],
          Self::NonceOverflow => &["A nonce overflow."],
          Self::AlreadyVoted => &["Already voted."],
          Self::AlreadyASigner => &["Already a signer."],
          Self::FailedToChargeFee => &["Couldn't charge fee for the transaction."],
          Self::IdentityNotCreator => &["Identity provided is not the multisig's creator."],
          Self::ChangeNotAllowed => {
            &["Changing multisig parameters not allowed since multisig is a primary key."]
          }
          Self::SignerAlreadyLinkedToMultisig => {
            &["Signer is an account key that is already associated with a multisig."]
          }
          Self::SignerAlreadyLinkedToIdentity => {
            &["Signer is an account key that is already associated with an identity."]
          }
          Self::MultisigNotAllowedToLinkToItself => {
            &["Multisig not allowed to add itself as a signer."]
          }
          Self::MissingCurrentIdentity => &["Current DID is missing"],
          Self::NotPrimaryKey => &["The function can only be called by the primary key of the did"],
          Self::ProposalAlreadyRejected => &["Proposal was rejected earlier"],
          Self::ProposalExpired => &["Proposal has expired"],
          Self::ProposalAlreadyExecuted => &["Proposal was executed earlier"],
          Self::MultisigMissingIdentity => &["Multisig is not attached to an identity"],
          Self::FailedToSchedule => &["Scheduling of a proposal fails"],
          Self::TooManySigners => &["More signers than required."],
          Self::CreatorControlsHaveBeenRemoved => {
            &["The creator is no longer allowed to call via creator extrinsics."]
          }
          _ => &[""],
        }
      }
    }
    impl From<MultiSigError> for &'static str {
      fn from(v: MultiSigError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&MultiSigError> for &'static str {
      fn from(v: &MultiSigError) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum MultiSigCall {
      #[doc = "Creates a multisig"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)."]
      #[doc = "* `sigs_required` - Number of sigs required to process a multi-sig tx."]
      #[codec(index = 0u8)]
      create_multisig {
        signers: ::alloc::vec::Vec<
          polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        >,
        sigs_required: u64,
      },
      #[doc = "Creates a multisig proposal if it hasn't been created or approves it if it has."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[codec(index = 1u8)]
      create_or_approve_proposal_as_identity {
        multisig: ::polymesh_api_client::AccountId,
        proposal: ::alloc::boxed::Box<runtime::RuntimeCall>,
        expiry: Option<u64>,
        auto_close: bool,
      },
      #[doc = "Creates a multisig proposal if it hasn't been created or approves it if it has."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[codec(index = 2u8)]
      create_or_approve_proposal_as_key {
        multisig: ::polymesh_api_client::AccountId,
        proposal: ::alloc::boxed::Box<runtime::RuntimeCall>,
        expiry: Option<u64>,
        auto_close: bool,
      },
      #[doc = "Creates a multisig proposal"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[codec(index = 3u8)]
      create_proposal_as_identity {
        multisig: ::polymesh_api_client::AccountId,
        proposal: ::alloc::boxed::Box<runtime::RuntimeCall>,
        expiry: Option<u64>,
        auto_close: bool,
      },
      #[doc = "Creates a multisig proposal"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[codec(index = 4u8)]
      create_proposal_as_key {
        multisig: ::polymesh_api_client::AccountId,
        proposal: ::alloc::boxed::Box<runtime::RuntimeCall>,
        expiry: Option<u64>,
        auto_close: bool,
      },
      #[doc = "Approves a multisig proposal using the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to approve."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[codec(index = 5u8)]
      approve_as_identity {
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      },
      #[doc = "Approves a multisig proposal using the caller's secondary key (`AccountId`)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to approve."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[codec(index = 6u8)]
      approve_as_key {
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      },
      #[doc = "Rejects a multisig proposal using the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to reject."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[codec(index = 7u8)]
      reject_as_identity {
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      },
      #[doc = "Rejects a multisig proposal using the caller's secondary key (`AccountId`)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to reject."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[codec(index = 8u8)]
      reject_as_key {
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      },
      #[doc = "Accepts a multisig signer authorization given to signer's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_id` - Auth id of the authorization."]
      #[codec(index = 9u8)]
      accept_multisig_signer_as_identity { auth_id: u64 },
      #[doc = "Accepts a multisig signer authorization given to signer's key (AccountId)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_id` - Auth id of the authorization."]
      #[codec(index = 10u8)]
      accept_multisig_signer_as_key { auth_id: u64 },
      #[doc = "Adds a signer to the multisig. This must be called by the multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signer` - Signatory to add."]
      #[codec(index = 11u8)]
      add_multisig_signer {
        signer: polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
      },
      #[doc = "Removes a signer from the multisig. This must be called by the multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signer` - Signatory to remove."]
      #[codec(index = 12u8)]
      remove_multisig_signer {
        signer: polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
      },
      #[doc = "Adds a signer to the multisig. This must be called by the creator identity of the"]
      #[doc = "multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - Address of the multi sig"]
      #[doc = "* `signers` - Signatories to add."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`900_000_000 + 3_000_000 * signers.len()`"]
      #[codec(index = 13u8)]
      add_multisig_signers_via_creator {
        multisig: ::polymesh_api_client::AccountId,
        signers: ::alloc::vec::Vec<
          polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        >,
      },
      #[doc = "Removes a signer from the multisig."]
      #[doc = "This must be called by the creator identity of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - Address of the multisig."]
      #[doc = "* `signers` - Signatories to remove."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`900_000_000 + 3_000_000 * signers.len()`"]
      #[codec(index = 14u8)]
      remove_multisig_signers_via_creator {
        multisig: ::polymesh_api_client::AccountId,
        signers: ::alloc::vec::Vec<
          polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        >,
      },
      #[doc = "Changes the number of signatures required by a multisig. This must be called by the"]
      #[doc = "multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `sigs_required` - New number of required signatures."]
      #[codec(index = 15u8)]
      change_sigs_required { sigs_required: u64 },
      #[doc = "Adds a multisig as a secondary key of current did if the current did is the creator of the"]
      #[doc = "multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - multi sig address"]
      #[codec(index = 16u8)]
      make_multisig_secondary {
        multisig: ::polymesh_api_client::AccountId,
      },
      #[doc = "Adds a multisig as the primary key of the current did if the current DID is the creator"]
      #[doc = "of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multi_sig` - multi sig address"]
      #[codec(index = 17u8)]
      make_multisig_primary {
        multisig: ::polymesh_api_client::AccountId,
        optional_cdd_auth_id: Option<u64>,
      },
      #[doc = "Root callable extrinsic, used as an internal call for executing scheduled multisig proposal."]
      #[codec(index = 18u8)]
      execute_scheduled_proposal {
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
        multisig_did: ::polymesh_api_client::IdentityId,
        _proposal_weight: ::polymesh_api_client::sp_weights::Weight,
      },
      #[doc = "Changes the number of signatures required by a multisig. This must be called by the creator of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig_account` - The account identifier ([`AccountId`]) for the multi signature account."]
      #[doc = "* `signatures_required` - The number of required signatures."]
      #[codec(index = 19u8)]
      change_sigs_required_via_creator {
        multisig_account: ::polymesh_api_client::AccountId,
        signatures_required: u64,
      },
      #[doc = "Removes the creator ability to call `add_multisig_signers_via_creator`, `remove_multisig_signers_via_creator`"]
      #[doc = "and `change_sigs_required_via_creator`."]
      #[codec(index = 20u8)]
      remove_creator_controls {
        multisig_account: ::polymesh_api_client::AccountId,
      },
    }
    impl MultiSigCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_multisig { .. } => "MultiSig.create_multisig",
          Self::create_or_approve_proposal_as_identity { .. } => {
            "MultiSig.create_or_approve_proposal_as_identity"
          }
          Self::create_or_approve_proposal_as_key { .. } => {
            "MultiSig.create_or_approve_proposal_as_key"
          }
          Self::create_proposal_as_identity { .. } => "MultiSig.create_proposal_as_identity",
          Self::create_proposal_as_key { .. } => "MultiSig.create_proposal_as_key",
          Self::approve_as_identity { .. } => "MultiSig.approve_as_identity",
          Self::approve_as_key { .. } => "MultiSig.approve_as_key",
          Self::reject_as_identity { .. } => "MultiSig.reject_as_identity",
          Self::reject_as_key { .. } => "MultiSig.reject_as_key",
          Self::accept_multisig_signer_as_identity { .. } => {
            "MultiSig.accept_multisig_signer_as_identity"
          }
          Self::accept_multisig_signer_as_key { .. } => "MultiSig.accept_multisig_signer_as_key",
          Self::add_multisig_signer { .. } => "MultiSig.add_multisig_signer",
          Self::remove_multisig_signer { .. } => "MultiSig.remove_multisig_signer",
          Self::add_multisig_signers_via_creator { .. } => {
            "MultiSig.add_multisig_signers_via_creator"
          }
          Self::remove_multisig_signers_via_creator { .. } => {
            "MultiSig.remove_multisig_signers_via_creator"
          }
          Self::change_sigs_required { .. } => "MultiSig.change_sigs_required",
          Self::make_multisig_secondary { .. } => "MultiSig.make_multisig_secondary",
          Self::make_multisig_primary { .. } => "MultiSig.make_multisig_primary",
          Self::execute_scheduled_proposal { .. } => "MultiSig.execute_scheduled_proposal",
          Self::change_sigs_required_via_creator { .. } => {
            "MultiSig.change_sigs_required_via_creator"
          }
          Self::remove_creator_controls { .. } => "MultiSig.remove_creator_controls",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for MultiSigCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: create_multisig { .. } => { & ["Creates a multisig" , "" , "# Arguments" , "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)." , "* `sigs_required` - Number of sigs required to process a multi-sig tx." ,] } , Self :: create_or_approve_proposal_as_identity { .. } => { & ["Creates a multisig proposal if it hasn't been created or approves it if it has." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal` - Proposal to be voted on." , "* `expiry` - Optional proposal expiry time." , "* `auto_close` - Close proposal on receiving enough reject votes." , "If this is 1 out of `m` multisig, the proposal will be immediately executed." ,] } , Self :: create_or_approve_proposal_as_key { .. } => { & ["Creates a multisig proposal if it hasn't been created or approves it if it has." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal` - Proposal to be voted on." , "* `expiry` - Optional proposal expiry time." , "* `auto_close` - Close proposal on receiving enough reject votes." , "If this is 1 out of `m` multisig, the proposal will be immediately executed." ,] } , Self :: create_proposal_as_identity { .. } => { & ["Creates a multisig proposal" , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal` - Proposal to be voted on." , "* `expiry` - Optional proposal expiry time." , "* `auto_close` - Close proposal on receiving enough reject votes." , "If this is 1 out of `m` multisig, the proposal will be immediately executed." ,] } , Self :: create_proposal_as_key { .. } => { & ["Creates a multisig proposal" , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal` - Proposal to be voted on." , "* `expiry` - Optional proposal expiry time." , "* `auto_close` - Close proposal on receiving enough reject votes." , "If this is 1 out of `m` multisig, the proposal will be immediately executed." ,] } , Self :: approve_as_identity { .. } => { & ["Approves a multisig proposal using the caller's identity." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal_id` - Proposal id to approve." , "If quorum is reached, the proposal will be immediately executed." ,] } , Self :: approve_as_key { .. } => { & ["Approves a multisig proposal using the caller's secondary key (`AccountId`)." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal_id` - Proposal id to approve." , "If quorum is reached, the proposal will be immediately executed." ,] } , Self :: reject_as_identity { .. } => { & ["Rejects a multisig proposal using the caller's identity." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal_id` - Proposal id to reject." , "If quorum is reached, the proposal will be immediately executed." ,] } , Self :: reject_as_key { .. } => { & ["Rejects a multisig proposal using the caller's secondary key (`AccountId`)." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal_id` - Proposal id to reject." , "If quorum is reached, the proposal will be immediately executed." ,] } , Self :: accept_multisig_signer_as_identity { .. } => { & ["Accepts a multisig signer authorization given to signer's identity." , "" , "# Arguments" , "* `auth_id` - Auth id of the authorization." ,] } , Self :: accept_multisig_signer_as_key { .. } => { & ["Accepts a multisig signer authorization given to signer's key (AccountId)." , "" , "# Arguments" , "* `auth_id` - Auth id of the authorization." ,] } , Self :: add_multisig_signer { .. } => { & ["Adds a signer to the multisig. This must be called by the multisig itself." , "" , "# Arguments" , "* `signer` - Signatory to add." ,] } , Self :: remove_multisig_signer { .. } => { & ["Removes a signer from the multisig. This must be called by the multisig itself." , "" , "# Arguments" , "* `signer` - Signatory to remove." ,] } , Self :: add_multisig_signers_via_creator { .. } => { & ["Adds a signer to the multisig. This must be called by the creator identity of the" , "multisig." , "" , "# Arguments" , "* `multisig` - Address of the multi sig" , "* `signers` - Signatories to add." , "" , "# Weight" , "`900_000_000 + 3_000_000 * signers.len()`" ,] } , Self :: remove_multisig_signers_via_creator { .. } => { & ["Removes a signer from the multisig." , "This must be called by the creator identity of the multisig." , "" , "# Arguments" , "* `multisig` - Address of the multisig." , "* `signers` - Signatories to remove." , "" , "# Weight" , "`900_000_000 + 3_000_000 * signers.len()`" ,] } , Self :: change_sigs_required { .. } => { & ["Changes the number of signatures required by a multisig. This must be called by the" , "multisig itself." , "" , "# Arguments" , "* `sigs_required` - New number of required signatures." ,] } , Self :: make_multisig_secondary { .. } => { & ["Adds a multisig as a secondary key of current did if the current did is the creator of the" , "multisig." , "" , "# Arguments" , "* `multisig` - multi sig address" ,] } , Self :: make_multisig_primary { .. } => { & ["Adds a multisig as the primary key of the current did if the current DID is the creator" , "of the multisig." , "" , "# Arguments" , "* `multi_sig` - multi sig address" ,] } , Self :: execute_scheduled_proposal { .. } => { & ["Root callable extrinsic, used as an internal call for executing scheduled multisig proposal." ,] } , Self :: change_sigs_required_via_creator { .. } => { & ["Changes the number of signatures required by a multisig. This must be called by the creator of the multisig." , "" , "# Arguments" , "* `multisig_account` - The account identifier ([`AccountId`]) for the multi signature account." , "* `signatures_required` - The number of required signatures." ,] } , Self :: remove_creator_controls { .. } => { & ["Removes the creator ability to call `add_multisig_signers_via_creator`, `remove_multisig_signers_via_creator`" , "and `change_sigs_required_via_creator`." ,] } , _ => & [""] , }
      }
    }
    impl From<MultiSigCall> for &'static str {
      fn from(v: MultiSigCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&MultiSigCall> for &'static str {
      fn from(v: &MultiSigCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
  }
  pub mod sp_staking {
    use super::*;
    pub mod offence {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct OffenceDetails<Reporter, Offender> {
        pub offender: Offender,
        pub reporters: ::alloc::vec::Vec<Reporter>,
      }
    }
  }
  pub mod frame_support {
    use super::*;
    pub mod dispatch {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PerDispatchClass<T> {
        pub normal: T,
        pub operational: T,
        pub mandatory: T,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Pays {
        #[codec(index = 0u8)]
        Yes,
        #[codec(index = 1u8)]
        No,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DispatchInfo {
        pub weight: ::polymesh_api_client::sp_weights::Weight,
        pub class: frame_support::dispatch::DispatchClass,
        pub pays_fee: frame_support::dispatch::Pays,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum RawOrigin<AccountId> {
        #[codec(index = 0u8)]
        Root,
        #[codec(index = 1u8)]
        Signed(AccountId),
        #[codec(index = 2u8)]
        None,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum DispatchClass {
        #[codec(index = 0u8)]
        Normal,
        #[codec(index = 1u8)]
        Operational,
        #[codec(index = 2u8)]
        Mandatory,
      }
    }
    pub mod traits {
      use super::*;
      pub mod tokens {
        use super::*;
        pub mod misc {
          use super::*;
          #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
          #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
          )]
          #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
          pub enum BalanceStatus {
            #[codec(index = 0u8)]
            Free,
            #[codec(index = 1u8)]
            Reserved,
          }
        }
      }
      pub mod misc {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct WrapperOpaque<T>(#[codec(compact)] pub u32, pub T);
      }
      pub mod preimages {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
          all(feature = "std", feature = "type_info"),
          derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Bounded<T> {
          #[codec(index = 0u8)]
          Legacy {
            hash: primitive_types::H256,
          },
          #[codec(index = 1u8)]
          Inline(bounded_collections::bounded_vec::BoundedVec<u8>),
          #[codec(index = 2u8)]
          Lookup {
            hash: primitive_types::H256,
            len: u32,
          },
          PhantomDataVariant(core::marker::PhantomData<T>),
        }
      }
    }
  }
  pub mod pallet_contracts {
    use super::*;
    pub mod wasm {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum Determinism {
        #[codec(index = 0u8)]
        Deterministic,
        #[codec(index = 1u8)]
        AllowIndeterminism,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PrefabWasmModule {
        #[codec(compact)]
        pub instruction_weights_version: u32,
        #[codec(compact)]
        pub initial: u32,
        #[codec(compact)]
        pub maximum: u32,
        pub code: bounded_collections::weak_bounded_vec::WeakBoundedVec<u8>,
        pub determinism: pallet_contracts::wasm::Determinism,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct OwnerInfo {
        pub owner: ::polymesh_api_client::AccountId,
        #[codec(compact)]
        pub deposit: u128,
        #[codec(compact)]
        pub refcount: u64,
      }
    }
    pub mod storage {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DepositAccount(pub ::polymesh_api_client::AccountId);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct DeletedContract {
        pub trie_id: bounded_collections::bounded_vec::BoundedVec<u8>,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct ContractInfo {
        pub trie_id: bounded_collections::bounded_vec::BoundedVec<u8>,
        pub deposit_account: pallet_contracts::storage::DepositAccount,
        pub code_hash: primitive_types::H256,
        pub storage_bytes: u32,
        pub storage_items: u32,
        pub storage_byte_deposit: u128,
        pub storage_item_deposit: u128,
        pub storage_base_deposit: u128,
      }
    }
    pub mod schedule {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct InstructionWeights {
        pub version: u32,
        pub fallback: u32,
        pub i64const: u32,
        pub i64load: u32,
        pub i64store: u32,
        pub select: u32,
        pub r#if: u32,
        pub br: u32,
        pub br_if: u32,
        pub br_table: u32,
        pub br_table_per_entry: u32,
        pub call: u32,
        pub call_indirect: u32,
        pub call_indirect_per_param: u32,
        pub call_per_local: u32,
        pub local_get: u32,
        pub local_set: u32,
        pub local_tee: u32,
        pub global_get: u32,
        pub global_set: u32,
        pub memory_current: u32,
        pub memory_grow: u32,
        pub i64clz: u32,
        pub i64ctz: u32,
        pub i64popcnt: u32,
        pub i64eqz: u32,
        pub i64extendsi32: u32,
        pub i64extendui32: u32,
        pub i32wrapi64: u32,
        pub i64eq: u32,
        pub i64ne: u32,
        pub i64lts: u32,
        pub i64ltu: u32,
        pub i64gts: u32,
        pub i64gtu: u32,
        pub i64les: u32,
        pub i64leu: u32,
        pub i64ges: u32,
        pub i64geu: u32,
        pub i64add: u32,
        pub i64sub: u32,
        pub i64mul: u32,
        pub i64divs: u32,
        pub i64divu: u32,
        pub i64rems: u32,
        pub i64remu: u32,
        pub i64and: u32,
        pub i64or: u32,
        pub i64xor: u32,
        pub i64shl: u32,
        pub i64shrs: u32,
        pub i64shru: u32,
        pub i64rotl: u32,
        pub i64rotr: u32,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Schedule {
        pub limits: pallet_contracts::schedule::Limits,
        pub instruction_weights: pallet_contracts::schedule::InstructionWeights,
        pub host_fn_weights: pallet_contracts::schedule::HostFnWeights,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Limits {
        pub event_topics: u32,
        pub globals: u32,
        pub locals: u32,
        pub parameters: u32,
        pub memory_pages: u32,
        pub table_size: u32,
        pub br_table_size: u32,
        pub subject_len: u32,
        pub payload_len: u32,
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct HostFnWeights {
        pub caller: ::polymesh_api_client::sp_weights::Weight,
        pub is_contract: ::polymesh_api_client::sp_weights::Weight,
        pub code_hash: ::polymesh_api_client::sp_weights::Weight,
        pub own_code_hash: ::polymesh_api_client::sp_weights::Weight,
        pub caller_is_origin: ::polymesh_api_client::sp_weights::Weight,
        pub address: ::polymesh_api_client::sp_weights::Weight,
        pub gas_left: ::polymesh_api_client::sp_weights::Weight,
        pub balance: ::polymesh_api_client::sp_weights::Weight,
        pub value_transferred: ::polymesh_api_client::sp_weights::Weight,
        pub minimum_balance: ::polymesh_api_client::sp_weights::Weight,
        pub block_number: ::polymesh_api_client::sp_weights::Weight,
        pub now: ::polymesh_api_client::sp_weights::Weight,
        pub weight_to_fee: ::polymesh_api_client::sp_weights::Weight,
        pub gas: ::polymesh_api_client::sp_weights::Weight,
        pub input: ::polymesh_api_client::sp_weights::Weight,
        pub input_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub r#return: ::polymesh_api_client::sp_weights::Weight,
        pub return_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub terminate: ::polymesh_api_client::sp_weights::Weight,
        pub random: ::polymesh_api_client::sp_weights::Weight,
        pub deposit_event: ::polymesh_api_client::sp_weights::Weight,
        pub deposit_event_per_topic: ::polymesh_api_client::sp_weights::Weight,
        pub deposit_event_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub debug_message: ::polymesh_api_client::sp_weights::Weight,
        pub debug_message_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub set_storage: ::polymesh_api_client::sp_weights::Weight,
        pub set_storage_per_new_byte: ::polymesh_api_client::sp_weights::Weight,
        pub set_storage_per_old_byte: ::polymesh_api_client::sp_weights::Weight,
        pub set_code_hash: ::polymesh_api_client::sp_weights::Weight,
        pub clear_storage: ::polymesh_api_client::sp_weights::Weight,
        pub clear_storage_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub contains_storage: ::polymesh_api_client::sp_weights::Weight,
        pub contains_storage_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub get_storage: ::polymesh_api_client::sp_weights::Weight,
        pub get_storage_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub take_storage: ::polymesh_api_client::sp_weights::Weight,
        pub take_storage_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub transfer: ::polymesh_api_client::sp_weights::Weight,
        pub call: ::polymesh_api_client::sp_weights::Weight,
        pub delegate_call: ::polymesh_api_client::sp_weights::Weight,
        pub call_transfer_surcharge: ::polymesh_api_client::sp_weights::Weight,
        pub call_per_cloned_byte: ::polymesh_api_client::sp_weights::Weight,
        pub instantiate: ::polymesh_api_client::sp_weights::Weight,
        pub instantiate_transfer_surcharge: ::polymesh_api_client::sp_weights::Weight,
        pub instantiate_per_input_byte: ::polymesh_api_client::sp_weights::Weight,
        pub instantiate_per_salt_byte: ::polymesh_api_client::sp_weights::Weight,
        pub hash_sha2_256: ::polymesh_api_client::sp_weights::Weight,
        pub hash_sha2_256_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub hash_keccak_256: ::polymesh_api_client::sp_weights::Weight,
        pub hash_keccak_256_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub hash_blake2_256: ::polymesh_api_client::sp_weights::Weight,
        pub hash_blake2_256_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub hash_blake2_128: ::polymesh_api_client::sp_weights::Weight,
        pub hash_blake2_128_per_byte: ::polymesh_api_client::sp_weights::Weight,
        pub ecdsa_recover: ::polymesh_api_client::sp_weights::Weight,
        pub ecdsa_to_eth_address: ::polymesh_api_client::sp_weights::Weight,
        pub reentrance_count: ::polymesh_api_client::sp_weights::Weight,
        pub account_reentrance_count: ::polymesh_api_client::sp_weights::Weight,
        pub instantiation_nonce: ::polymesh_api_client::sp_weights::Weight,
      }
    }
    pub mod pallet {
      use super::*;
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ContractsEvent {
        #[doc = "Contract deployed by address at the specified address."]
        #[codec(index = 0u8)]
        Instantiated {
          deployer: ::polymesh_api_client::AccountId,
          contract: ::polymesh_api_client::AccountId,
        },
        #[doc = "Contract has been removed."]
        #[doc = ""]
        #[doc = "# Note"]
        #[doc = ""]
        #[doc = "The only way for a contract to be removed and emitting this event is by calling"]
        #[doc = "`seal_terminate`."]
        #[codec(index = 1u8)]
        Terminated {
          #[doc = "The contract that was terminated."]
          contract: ::polymesh_api_client::AccountId,
          #[doc = "The account that received the contracts remaining balance"]
          beneficiary: ::polymesh_api_client::AccountId,
        },
        #[doc = "Code with the specified hash has been stored."]
        #[codec(index = 2u8)]
        CodeStored { code_hash: primitive_types::H256 },
        #[doc = "A custom event emitted by the contract."]
        #[codec(index = 3u8)]
        ContractEmitted {
          #[doc = "The contract that emitted the event."]
          contract: ::polymesh_api_client::AccountId,
          #[doc = "Data supplied by the contract. Metadata generated during contract compilation"]
          #[doc = "is needed to decode it."]
          data: ::alloc::vec::Vec<u8>,
        },
        #[doc = "A code with the specified hash was removed."]
        #[codec(index = 4u8)]
        CodeRemoved { code_hash: primitive_types::H256 },
        #[doc = "A contract's code was updated."]
        #[codec(index = 5u8)]
        ContractCodeUpdated {
          #[doc = "The contract that has been updated."]
          contract: ::polymesh_api_client::AccountId,
          #[doc = "New code hash that was set for the contract."]
          new_code_hash: primitive_types::H256,
          #[doc = "Previous code hash of the contract."]
          old_code_hash: primitive_types::H256,
        },
        #[doc = "A contract was called either by a plain account or another contract."]
        #[doc = ""]
        #[doc = "# Note"]
        #[doc = ""]
        #[doc = "Please keep in mind that like all events this is only emitted for successful"]
        #[doc = "calls. This is because on failure all storage changes including events are"]
        #[doc = "rolled back."]
        #[codec(index = 6u8)]
        Called {
          #[doc = "The account that called the `contract`."]
          caller: ::polymesh_api_client::AccountId,
          #[doc = "The contract that was called."]
          contract: ::polymesh_api_client::AccountId,
        },
        #[doc = "A contract delegate called a code hash."]
        #[doc = ""]
        #[doc = "# Note"]
        #[doc = ""]
        #[doc = "Please keep in mind that like all events this is only emitted for successful"]
        #[doc = "calls. This is because on failure all storage changes including events are"]
        #[doc = "rolled back."]
        #[codec(index = 7u8)]
        DelegateCalled {
          #[doc = "The contract that performed the delegate call and hence in whose context"]
          #[doc = "the `code_hash` is executed."]
          contract: ::polymesh_api_client::AccountId,
          #[doc = "The code hash that was delegate called."]
          code_hash: primitive_types::H256,
        },
      }
      impl ContractsEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::Instantiated { .. } => "Contracts.Instantiated",
            Self::Terminated { .. } => "Contracts.Terminated",
            Self::CodeStored { .. } => "Contracts.CodeStored",
            Self::ContractEmitted { .. } => "Contracts.ContractEmitted",
            Self::CodeRemoved { .. } => "Contracts.CodeRemoved",
            Self::ContractCodeUpdated { .. } => "Contracts.ContractCodeUpdated",
            Self::Called { .. } => "Contracts.Called",
            Self::DelegateCalled { .. } => "Contracts.DelegateCalled",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ContractsEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::Instantiated { .. } => {
              &["Contract deployed by address at the specified address."]
            }
            Self::Terminated { .. } => &[
              "Contract has been removed.",
              "",
              "# Note",
              "",
              "The only way for a contract to be removed and emitting this event is by calling",
              "`seal_terminate`.",
            ],
            Self::CodeStored { .. } => &["Code with the specified hash has been stored."],
            Self::ContractEmitted { .. } => &["A custom event emitted by the contract."],
            Self::CodeRemoved { .. } => &["A code with the specified hash was removed."],
            Self::ContractCodeUpdated { .. } => &["A contract's code was updated."],
            Self::Called { .. } => &[
              "A contract was called either by a plain account or another contract.",
              "",
              "# Note",
              "",
              "Please keep in mind that like all events this is only emitted for successful",
              "calls. This is because on failure all storage changes including events are",
              "rolled back.",
            ],
            Self::DelegateCalled { .. } => &[
              "A contract delegate called a code hash.",
              "",
              "# Note",
              "",
              "Please keep in mind that like all events this is only emitted for successful",
              "calls. This is because on failure all storage changes including events are",
              "rolled back.",
            ],
            _ => &[""],
          }
        }
      }
      impl From<ContractsEvent> for &'static str {
        fn from(v: ContractsEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ContractsEvent> for &'static str {
        fn from(v: &ContractsEvent) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ContractsCall {
        #[doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."]
        #[codec(index = 0u8)]
        call_old_weight {
          dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          #[codec(compact)]
          value: u128,
          #[codec(compact)]
          gas_limit: ::polymesh_api_client::sp_weights::OldWeight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          data: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."]
        #[codec(index = 1u8)]
        instantiate_with_code_old_weight {
          #[codec(compact)]
          value: u128,
          #[codec(compact)]
          gas_limit: ::polymesh_api_client::sp_weights::OldWeight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          code: ::alloc::vec::Vec<u8>,
          data: ::alloc::vec::Vec<u8>,
          salt: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."]
        #[codec(index = 2u8)]
        instantiate_old_weight {
          #[codec(compact)]
          value: u128,
          #[codec(compact)]
          gas_limit: ::polymesh_api_client::sp_weights::OldWeight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          code_hash: primitive_types::H256,
          data: ::alloc::vec::Vec<u8>,
          salt: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Upload new `code` without instantiating a contract from it."]
        #[doc = ""]
        #[doc = "If the code does not already exist a deposit is reserved from the caller"]
        #[doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"]
        #[doc = "depends on the instrumented size of the the supplied `code`."]
        #[doc = ""]
        #[doc = "If the code already exists in storage it will still return `Ok` and upgrades"]
        #[doc = "the in storage version to the current"]
        #[doc = "[`InstructionWeights::version`](InstructionWeights)."]
        #[doc = ""]
        #[doc = "- `determinism`: If this is set to any other value but [`Determinism::Deterministic`]"]
        #[doc = "  then the only way to use this code is to delegate call into it from an offchain"]
        #[doc = "  execution. Set to [`Determinism::Deterministic`] if in doubt."]
        #[doc = ""]
        #[doc = "# Note"]
        #[doc = ""]
        #[doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."]
        #[doc = "To avoid this situation a constructor could employ access control so that it can"]
        #[doc = "only be instantiated by permissioned entities. The same is true when uploading"]
        #[doc = "through [`Self::instantiate_with_code`]."]
        #[codec(index = 3u8)]
        upload_code {
          code: ::alloc::vec::Vec<u8>,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          determinism: pallet_contracts::wasm::Determinism,
        },
        #[doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."]
        #[doc = ""]
        #[doc = "A code can only be removed by its original uploader (its owner) and only if it is"]
        #[doc = "not used by any contract."]
        #[codec(index = 4u8)]
        remove_code { code_hash: primitive_types::H256 },
        #[doc = "Privileged function that changes the code of an existing contract."]
        #[doc = ""]
        #[doc = "This takes care of updating refcounts and all other necessary operations. Returns"]
        #[doc = "an error if either the `code_hash` or `dest` do not exist."]
        #[doc = ""]
        #[doc = "# Note"]
        #[doc = ""]
        #[doc = "This does **not** change the address of the contract in question. This means"]
        #[doc = "that the contract address is no longer derived from its code hash after calling"]
        #[doc = "this dispatchable."]
        #[codec(index = 5u8)]
        set_code {
          dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          code_hash: primitive_types::H256,
        },
        #[doc = "Makes a call to an account, optionally transferring some balance."]
        #[doc = ""]
        #[doc = "# Parameters"]
        #[doc = ""]
        #[doc = "* `dest`: Address of the contract to call."]
        #[doc = "* `value`: The balance to transfer from the `origin` to `dest`."]
        #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
        #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"]
        #[doc = "  caller to pay for the storage consumed."]
        #[doc = "* `data`: The input data to pass to the contract."]
        #[doc = ""]
        #[doc = "* If the account is a smart-contract account, the associated code will be"]
        #[doc = "executed and any value will be transferred."]
        #[doc = "* If the account is a regular account, any value will be transferred."]
        #[doc = "* If no account exists and the call value is not less than `existential_deposit`,"]
        #[doc = "a regular account will be created and any value will be transferred."]
        #[codec(index = 6u8)]
        call {
          dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          #[codec(compact)]
          value: u128,
          gas_limit: ::polymesh_api_client::sp_weights::Weight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          data: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Instantiates a new contract from the supplied `code` optionally transferring"]
        #[doc = "some balance."]
        #[doc = ""]
        #[doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"]
        #[doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"]
        #[doc = "also check the documentation of [`Self::upload_code`]."]
        #[doc = ""]
        #[doc = "# Parameters"]
        #[doc = ""]
        #[doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."]
        #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
        #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"]
        #[doc = "  from the caller to pay for the storage consumed."]
        #[doc = "* `code`: The contract code to deploy in raw bytes."]
        #[doc = "* `data`: The input data to pass to the contract constructor."]
        #[doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."]
        #[doc = ""]
        #[doc = "Instantiation is executed as follows:"]
        #[doc = ""]
        #[doc = "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that"]
        #[doc = "  code."]
        #[doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."]
        #[doc = "- The destination address is computed based on the sender, code_hash and the salt."]
        #[doc = "- The smart-contract account is created at the computed address."]
        #[doc = "- The `value` is transferred to the new account."]
        #[doc = "- The `deploy` function is executed in the context of the newly-created account."]
        #[codec(index = 7u8)]
        instantiate_with_code {
          #[codec(compact)]
          value: u128,
          gas_limit: ::polymesh_api_client::sp_weights::Weight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          code: ::alloc::vec::Vec<u8>,
          data: ::alloc::vec::Vec<u8>,
          salt: ::alloc::vec::Vec<u8>,
        },
        #[doc = "Instantiates a contract from a previously deployed wasm binary."]
        #[doc = ""]
        #[doc = "This function is identical to [`Self::instantiate_with_code`] but without the"]
        #[doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"]
        #[doc = "must be supplied."]
        #[codec(index = 8u8)]
        instantiate {
          #[codec(compact)]
          value: u128,
          gas_limit: ::polymesh_api_client::sp_weights::Weight,
          storage_deposit_limit: Option<::codec::Compact<u128>>,
          code_hash: primitive_types::H256,
          data: ::alloc::vec::Vec<u8>,
          salt: ::alloc::vec::Vec<u8>,
        },
      }
      impl ContractsCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::call_old_weight { .. } => "Contracts.call_old_weight",
            Self::instantiate_with_code_old_weight { .. } => {
              "Contracts.instantiate_with_code_old_weight"
            }
            Self::instantiate_old_weight { .. } => "Contracts.instantiate_old_weight",
            Self::upload_code { .. } => "Contracts.upload_code",
            Self::remove_code { .. } => "Contracts.remove_code",
            Self::set_code { .. } => "Contracts.set_code",
            Self::call { .. } => "Contracts.call",
            Self::instantiate_with_code { .. } => "Contracts.instantiate_with_code",
            Self::instantiate { .. } => "Contracts.instantiate",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ContractsCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: call_old_weight { .. } => { & ["Deprecated version if [`Self::call`] for use in an in-storage `Call`." ,] } , Self :: instantiate_with_code_old_weight { .. } => { & ["Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`." ,] } , Self :: instantiate_old_weight { .. } => { & ["Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`." ,] } , Self :: upload_code { .. } => { & ["Upload new `code` without instantiating a contract from it." , "" , "If the code does not already exist a deposit is reserved from the caller" , "and unreserved only when [`Self::remove_code`] is called. The size of the reserve" , "depends on the instrumented size of the the supplied `code`." , "" , "If the code already exists in storage it will still return `Ok` and upgrades" , "the in storage version to the current" , "[`InstructionWeights::version`](InstructionWeights)." , "" , "- `determinism`: If this is set to any other value but [`Determinism::Deterministic`]" , "  then the only way to use this code is to delegate call into it from an offchain" , "  execution. Set to [`Determinism::Deterministic`] if in doubt." , "" , "# Note" , "" , "Anyone can instantiate a contract from any uploaded code and thus prevent its removal." , "To avoid this situation a constructor could employ access control so that it can" , "only be instantiated by permissioned entities. The same is true when uploading" , "through [`Self::instantiate_with_code`]." ,] } , Self :: remove_code { .. } => { & ["Remove the code stored under `code_hash` and refund the deposit to its owner." , "" , "A code can only be removed by its original uploader (its owner) and only if it is" , "not used by any contract." ,] } , Self :: set_code { .. } => { & ["Privileged function that changes the code of an existing contract." , "" , "This takes care of updating refcounts and all other necessary operations. Returns" , "an error if either the `code_hash` or `dest` do not exist." , "" , "# Note" , "" , "This does **not** change the address of the contract in question. This means" , "that the contract address is no longer derived from its code hash after calling" , "this dispatchable." ,] } , Self :: call { .. } => { & ["Makes a call to an account, optionally transferring some balance." , "" , "# Parameters" , "" , "* `dest`: Address of the contract to call." , "* `value`: The balance to transfer from the `origin` to `dest`." , "* `gas_limit`: The gas limit enforced when executing the constructor." , "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the" , "  caller to pay for the storage consumed." , "* `data`: The input data to pass to the contract." , "" , "* If the account is a smart-contract account, the associated code will be" , "executed and any value will be transferred." , "* If the account is a regular account, any value will be transferred." , "* If no account exists and the call value is not less than `existential_deposit`," , "a regular account will be created and any value will be transferred." ,] } , Self :: instantiate_with_code { .. } => { & ["Instantiates a new contract from the supplied `code` optionally transferring" , "some balance." , "" , "This dispatchable has the same effect as calling [`Self::upload_code`] +" , "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please" , "also check the documentation of [`Self::upload_code`]." , "" , "# Parameters" , "" , "* `value`: The balance to transfer from the `origin` to the newly created contract." , "* `gas_limit`: The gas limit enforced when executing the constructor." , "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved" , "  from the caller to pay for the storage consumed." , "* `code`: The contract code to deploy in raw bytes." , "* `data`: The input data to pass to the contract constructor." , "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]." , "" , "Instantiation is executed as follows:" , "" , "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that" , "  code." , "- If the `code_hash` already exists on the chain the underlying `code` will be shared." , "- The destination address is computed based on the sender, code_hash and the salt." , "- The smart-contract account is created at the computed address." , "- The `value` is transferred to the new account." , "- The `deploy` function is executed in the context of the newly-created account." ,] } , Self :: instantiate { .. } => { & ["Instantiates a contract from a previously deployed wasm binary." , "" , "This function is identical to [`Self::instantiate_with_code`] but without the" , "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary" , "must be supplied." ,] } , _ => & [""] , }
        }
      }
      impl From<ContractsCall> for &'static str {
        fn from(v: ContractsCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ContractsCall> for &'static str {
        fn from(v: &ContractsCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum ContractsError {
        #[doc = "A new schedule must have a greater version than the current one."]
        #[codec(index = 0u8)]
        InvalidScheduleVersion,
        #[doc = "Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`."]
        #[codec(index = 1u8)]
        InvalidCallFlags,
        #[doc = "The executed contract exhausted its gas limit."]
        #[codec(index = 2u8)]
        OutOfGas,
        #[doc = "The output buffer supplied to a contract API call was too small."]
        #[codec(index = 3u8)]
        OutputBufferTooSmall,
        #[doc = "Performing the requested transfer failed. Probably because there isn't enough"]
        #[doc = "free balance in the sender's account."]
        #[codec(index = 4u8)]
        TransferFailed,
        #[doc = "Performing a call was denied because the calling depth reached the limit"]
        #[doc = "of what is specified in the schedule."]
        #[codec(index = 5u8)]
        MaxCallDepthReached,
        #[doc = "No contract was found at the specified address."]
        #[codec(index = 6u8)]
        ContractNotFound,
        #[doc = "The code supplied to `instantiate_with_code` exceeds the limit specified in the"]
        #[doc = "current schedule."]
        #[codec(index = 7u8)]
        CodeTooLarge,
        #[doc = "No code could be found at the supplied code hash."]
        #[codec(index = 8u8)]
        CodeNotFound,
        #[doc = "A buffer outside of sandbox memory was passed to a contract API function."]
        #[codec(index = 9u8)]
        OutOfBounds,
        #[doc = "Input passed to a contract API function failed to decode as expected type."]
        #[codec(index = 10u8)]
        DecodingFailed,
        #[doc = "Contract trapped during execution."]
        #[codec(index = 11u8)]
        ContractTrapped,
        #[doc = "The size defined in `T::MaxValueSize` was exceeded."]
        #[codec(index = 12u8)]
        ValueTooLarge,
        #[doc = "Termination of a contract is not allowed while the contract is already"]
        #[doc = "on the call stack. Can be triggered by `seal_terminate`."]
        #[codec(index = 13u8)]
        TerminatedWhileReentrant,
        #[doc = "`seal_call` forwarded this contracts input. It therefore is no longer available."]
        #[codec(index = 14u8)]
        InputForwarded,
        #[doc = "The subject passed to `seal_random` exceeds the limit."]
        #[codec(index = 15u8)]
        RandomSubjectTooLong,
        #[doc = "The amount of topics passed to `seal_deposit_events` exceeds the limit."]
        #[codec(index = 16u8)]
        TooManyTopics,
        #[doc = "The chain does not provide a chain extension. Calling the chain extension results"]
        #[doc = "in this error. Note that this usually  shouldn't happen as deploying such contracts"]
        #[doc = "is rejected."]
        #[codec(index = 17u8)]
        NoChainExtension,
        #[doc = "Removal of a contract failed because the deletion queue is full."]
        #[doc = ""]
        #[doc = "This can happen when calling `seal_terminate`."]
        #[doc = "The queue is filled by deleting contracts and emptied by a fixed amount each block."]
        #[doc = "Trying again during another block is the only way to resolve this issue."]
        #[codec(index = 18u8)]
        DeletionQueueFull,
        #[doc = "A contract with the same AccountId already exists."]
        #[codec(index = 19u8)]
        DuplicateContract,
        #[doc = "A contract self destructed in its constructor."]
        #[doc = ""]
        #[doc = "This can be triggered by a call to `seal_terminate`."]
        #[codec(index = 20u8)]
        TerminatedInConstructor,
        #[doc = "A call tried to invoke a contract that is flagged as non-reentrant."]
        #[codec(index = 21u8)]
        ReentranceDenied,
        #[doc = "Origin doesn't have enough balance to pay the required storage deposits."]
        #[codec(index = 22u8)]
        StorageDepositNotEnoughFunds,
        #[doc = "More storage was created than allowed by the storage deposit limit."]
        #[codec(index = 23u8)]
        StorageDepositLimitExhausted,
        #[doc = "Code removal was denied because the code is still in use by at least one contract."]
        #[codec(index = 24u8)]
        CodeInUse,
        #[doc = "The contract ran to completion but decided to revert its storage changes."]
        #[doc = "Please note that this error is only returned from extrinsics. When called directly"]
        #[doc = "or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags"]
        #[doc = "to determine whether a reversion has taken place."]
        #[codec(index = 25u8)]
        ContractReverted,
        #[doc = "The contract's code was found to be invalid during validation or instrumentation."]
        #[doc = ""]
        #[doc = "The most likely cause of this is that an API was used which is not supported by the"]
        #[doc = "node. This hapens if an older node is used with a new version of ink!. Try updating"]
        #[doc = "your node to the newest available version."]
        #[doc = ""]
        #[doc = "A more detailed error can be found on the node console if debug messages are enabled"]
        #[doc = "by supplying `-lruntime::contracts=debug`."]
        #[codec(index = 26u8)]
        CodeRejected,
        #[doc = "An indetermistic code was used in a context where this is not permitted."]
        #[codec(index = 27u8)]
        Indeterministic,
      }
      impl ContractsError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::InvalidScheduleVersion => "Contracts.InvalidScheduleVersion",
            Self::InvalidCallFlags => "Contracts.InvalidCallFlags",
            Self::OutOfGas => "Contracts.OutOfGas",
            Self::OutputBufferTooSmall => "Contracts.OutputBufferTooSmall",
            Self::TransferFailed => "Contracts.TransferFailed",
            Self::MaxCallDepthReached => "Contracts.MaxCallDepthReached",
            Self::ContractNotFound => "Contracts.ContractNotFound",
            Self::CodeTooLarge => "Contracts.CodeTooLarge",
            Self::CodeNotFound => "Contracts.CodeNotFound",
            Self::OutOfBounds => "Contracts.OutOfBounds",
            Self::DecodingFailed => "Contracts.DecodingFailed",
            Self::ContractTrapped => "Contracts.ContractTrapped",
            Self::ValueTooLarge => "Contracts.ValueTooLarge",
            Self::TerminatedWhileReentrant => "Contracts.TerminatedWhileReentrant",
            Self::InputForwarded => "Contracts.InputForwarded",
            Self::RandomSubjectTooLong => "Contracts.RandomSubjectTooLong",
            Self::TooManyTopics => "Contracts.TooManyTopics",
            Self::NoChainExtension => "Contracts.NoChainExtension",
            Self::DeletionQueueFull => "Contracts.DeletionQueueFull",
            Self::DuplicateContract => "Contracts.DuplicateContract",
            Self::TerminatedInConstructor => "Contracts.TerminatedInConstructor",
            Self::ReentranceDenied => "Contracts.ReentranceDenied",
            Self::StorageDepositNotEnoughFunds => "Contracts.StorageDepositNotEnoughFunds",
            Self::StorageDepositLimitExhausted => "Contracts.StorageDepositLimitExhausted",
            Self::CodeInUse => "Contracts.CodeInUse",
            Self::ContractReverted => "Contracts.ContractReverted",
            Self::CodeRejected => "Contracts.CodeRejected",
            Self::Indeterministic => "Contracts.Indeterministic",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for ContractsError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: InvalidScheduleVersion => { & ["A new schedule must have a greater version than the current one." ,] } , Self :: InvalidCallFlags => { & ["Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`." ,] } , Self :: OutOfGas => { & ["The executed contract exhausted its gas limit." ,] } , Self :: OutputBufferTooSmall => { & ["The output buffer supplied to a contract API call was too small." ,] } , Self :: TransferFailed => { & ["Performing the requested transfer failed. Probably because there isn't enough" , "free balance in the sender's account." ,] } , Self :: MaxCallDepthReached => { & ["Performing a call was denied because the calling depth reached the limit" , "of what is specified in the schedule." ,] } , Self :: ContractNotFound => { & ["No contract was found at the specified address." ,] } , Self :: CodeTooLarge => { & ["The code supplied to `instantiate_with_code` exceeds the limit specified in the" , "current schedule." ,] } , Self :: CodeNotFound => { & ["No code could be found at the supplied code hash." ,] } , Self :: OutOfBounds => { & ["A buffer outside of sandbox memory was passed to a contract API function." ,] } , Self :: DecodingFailed => { & ["Input passed to a contract API function failed to decode as expected type." ,] } , Self :: ContractTrapped => { & ["Contract trapped during execution." ,] } , Self :: ValueTooLarge => { & ["The size defined in `T::MaxValueSize` was exceeded." ,] } , Self :: TerminatedWhileReentrant => { & ["Termination of a contract is not allowed while the contract is already" , "on the call stack. Can be triggered by `seal_terminate`." ,] } , Self :: InputForwarded => { & ["`seal_call` forwarded this contracts input. It therefore is no longer available." ,] } , Self :: RandomSubjectTooLong => { & ["The subject passed to `seal_random` exceeds the limit." ,] } , Self :: TooManyTopics => { & ["The amount of topics passed to `seal_deposit_events` exceeds the limit." ,] } , Self :: NoChainExtension => { & ["The chain does not provide a chain extension. Calling the chain extension results" , "in this error. Note that this usually  shouldn't happen as deploying such contracts" , "is rejected." ,] } , Self :: DeletionQueueFull => { & ["Removal of a contract failed because the deletion queue is full." , "" , "This can happen when calling `seal_terminate`." , "The queue is filled by deleting contracts and emptied by a fixed amount each block." , "Trying again during another block is the only way to resolve this issue." ,] } , Self :: DuplicateContract => { & ["A contract with the same AccountId already exists." ,] } , Self :: TerminatedInConstructor => { & ["A contract self destructed in its constructor." , "" , "This can be triggered by a call to `seal_terminate`." ,] } , Self :: ReentranceDenied => { & ["A call tried to invoke a contract that is flagged as non-reentrant." ,] } , Self :: StorageDepositNotEnoughFunds => { & ["Origin doesn't have enough balance to pay the required storage deposits." ,] } , Self :: StorageDepositLimitExhausted => { & ["More storage was created than allowed by the storage deposit limit." ,] } , Self :: CodeInUse => { & ["Code removal was denied because the code is still in use by at least one contract." ,] } , Self :: ContractReverted => { & ["The contract ran to completion but decided to revert its storage changes." , "Please note that this error is only returned from extrinsics. When called directly" , "or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags" , "to determine whether a reversion has taken place." ,] } , Self :: CodeRejected => { & ["The contract's code was found to be invalid during validation or instrumentation." , "" , "The most likely cause of this is that an API was used which is not supported by the" , "node. This hapens if an older node is used with a new version of ink!. Try updating" , "your node to the newest available version." , "" , "A more detailed error can be found on the node console if debug messages are enabled" , "by supplying `-lruntime::contracts=debug`." ,] } , Self :: Indeterministic => { & ["An indetermistic code was used in a context where this is not permitted." ,] } , _ => & [""] , }
        }
      }
      impl From<ContractsError> for &'static str {
        fn from(v: ContractsError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&ContractsError> for &'static str {
        fn from(v: &ContractsError) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod pallet_indices {
    use super::*;
    pub mod pallet {
      use super::*;
      #[doc = "\n\t\t\tThe [event](https://docs.substrate.io/main-docs/build/events-errors/) emitted\n\t\t\tby this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum IndicesEvent {
        #[doc = "A account index was assigned."]
        #[codec(index = 0u8)]
        IndexAssigned {
          who: ::polymesh_api_client::AccountId,
          index: u32,
        },
        #[doc = "A account index has been freed up (unassigned)."]
        #[codec(index = 1u8)]
        IndexFreed { index: u32 },
        #[doc = "A account index has been frozen to its current account ID."]
        #[codec(index = 2u8)]
        IndexFrozen {
          index: u32,
          who: ::polymesh_api_client::AccountId,
        },
      }
      impl IndicesEvent {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::IndexAssigned { .. } => "Indices.IndexAssigned",
            Self::IndexFreed { .. } => "Indices.IndexFreed",
            Self::IndexFrozen { .. } => "Indices.IndexFrozen",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for IndicesEvent {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::IndexAssigned { .. } => &["A account index was assigned."],
            Self::IndexFreed { .. } => &["A account index has been freed up (unassigned)."],
            Self::IndexFrozen { .. } => {
              &["A account index has been frozen to its current account ID."]
            }
            _ => &[""],
          }
        }
      }
      impl From<IndicesEvent> for &'static str {
        fn from(v: IndicesEvent) -> Self {
          v.as_static_str()
        }
      }
      impl From<&IndicesEvent> for &'static str {
        fn from(v: &IndicesEvent) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Contains one variant per dispatchable that can be called by an extrinsic."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum IndicesCall {
        #[doc = "Assign an previously unassigned index."]
        #[doc = ""]
        #[doc = "Payment: `Deposit` is reserved from the sender account."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Signed_."]
        #[doc = ""]
        #[doc = "- `index`: the index to be claimed. This must not be in use."]
        #[doc = ""]
        #[doc = "Emits `IndexAssigned` if successful."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`."]
        #[codec(index = 0u8)]
        claim { index: u32 },
        #[doc = "Assign an index already owned by the sender to another account. The balance reservation"]
        #[doc = "is effectively transferred to the new account."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Signed_."]
        #[doc = ""]
        #[doc = "- `index`: the index to be re-assigned. This must be owned by the sender."]
        #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
        #[doc = ""]
        #[doc = "Emits `IndexAssigned` if successful."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`."]
        #[codec(index = 1u8)]
        transfer {
          new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          index: u32,
        },
        #[doc = "Free up an index owned by the sender."]
        #[doc = ""]
        #[doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."]
        #[doc = ""]
        #[doc = "- `index`: the index to be freed. This must be owned by the sender."]
        #[doc = ""]
        #[doc = "Emits `IndexFreed` if successful."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`."]
        #[codec(index = 2u8)]
        free { index: u32 },
        #[doc = "Force an index to an account. This doesn't require a deposit. If the index is already"]
        #[doc = "held, then any deposit is reimbursed to its current owner."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Root_."]
        #[doc = ""]
        #[doc = "- `index`: the index to be (re-)assigned."]
        #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
        #[doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."]
        #[doc = ""]
        #[doc = "Emits `IndexAssigned` if successful."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`."]
        #[codec(index = 3u8)]
        force_transfer {
          new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
          index: u32,
          freeze: bool,
        },
        #[doc = "Freeze an index so it will always point to the sender account. This consumes the"]
        #[doc = "deposit."]
        #[doc = ""]
        #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
        #[doc = "non-frozen account `index`."]
        #[doc = ""]
        #[doc = "- `index`: the index to be frozen in place."]
        #[doc = ""]
        #[doc = "Emits `IndexFrozen` if successful."]
        #[doc = ""]
        #[doc = "## Complexity"]
        #[doc = "- `O(1)`."]
        #[codec(index = 4u8)]
        freeze { index: u32 },
      }
      impl IndicesCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::claim { .. } => "Indices.claim",
            Self::transfer { .. } => "Indices.transfer",
            Self::free { .. } => "Indices.free",
            Self::force_transfer { .. } => "Indices.force_transfer",
            Self::freeze { .. } => "Indices.freeze",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for IndicesCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: claim { .. } => { & ["Assign an previously unassigned index." , "" , "Payment: `Deposit` is reserved from the sender account." , "" , "The dispatch origin for this call must be _Signed_." , "" , "- `index`: the index to be claimed. This must not be in use." , "" , "Emits `IndexAssigned` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: transfer { .. } => { & ["Assign an index already owned by the sender to another account. The balance reservation" , "is effectively transferred to the new account." , "" , "The dispatch origin for this call must be _Signed_." , "" , "- `index`: the index to be re-assigned. This must be owned by the sender." , "- `new`: the new owner of the index. This function is a no-op if it is equal to sender." , "" , "Emits `IndexAssigned` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: free { .. } => { & ["Free up an index owned by the sender." , "" , "Payment: Any previous deposit placed for the index is unreserved in the sender account." , "" , "The dispatch origin for this call must be _Signed_ and the sender must own the index." , "" , "- `index`: the index to be freed. This must be owned by the sender." , "" , "Emits `IndexFreed` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: force_transfer { .. } => { & ["Force an index to an account. This doesn't require a deposit. If the index is already" , "held, then any deposit is reimbursed to its current owner." , "" , "The dispatch origin for this call must be _Root_." , "" , "- `index`: the index to be (re-)assigned." , "- `new`: the new owner of the index. This function is a no-op if it is equal to sender." , "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred." , "" , "Emits `IndexAssigned` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: freeze { .. } => { & ["Freeze an index so it will always point to the sender account. This consumes the" , "deposit." , "" , "The dispatch origin for this call must be _Signed_ and the signing account must have a" , "non-frozen account `index`." , "" , "- `index`: the index to be frozen in place." , "" , "Emits `IndexFrozen` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , _ => & [""] , }
        }
      }
      impl From<IndicesCall> for &'static str {
        fn from(v: IndicesCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&IndicesCall> for &'static str {
        fn from(v: &IndicesCall) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "\n\t\t\tCustom [dispatch errors](https://docs.substrate.io/main-docs/build/events-errors/)\n\t\t\tof this pallet.\n\t\t\t"]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum IndicesError {
        #[doc = "The index was not already assigned."]
        #[codec(index = 0u8)]
        NotAssigned,
        #[doc = "The index is assigned to another account."]
        #[codec(index = 1u8)]
        NotOwner,
        #[doc = "The index was not available."]
        #[codec(index = 2u8)]
        InUse,
        #[doc = "The source and destination accounts are identical."]
        #[codec(index = 3u8)]
        NotTransfer,
        #[doc = "The index is permanent and may not be freed/changed."]
        #[codec(index = 4u8)]
        Permanent,
      }
      impl IndicesError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::NotAssigned => "Indices.NotAssigned",
            Self::NotOwner => "Indices.NotOwner",
            Self::InUse => "Indices.InUse",
            Self::NotTransfer => "Indices.NotTransfer",
            Self::Permanent => "Indices.Permanent",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for IndicesError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::NotAssigned => &["The index was not already assigned."],
            Self::NotOwner => &["The index is assigned to another account."],
            Self::InUse => &["The index was not available."],
            Self::NotTransfer => &["The source and destination accounts are identical."],
            Self::Permanent => &["The index is permanent and may not be freed/changed."],
            _ => &[""],
          }
        }
      }
      impl From<IndicesError> for &'static str {
        fn from(v: IndicesError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&IndicesError> for &'static str {
        fn from(v: &IndicesError) -> Self {
          v.as_static_str()
        }
      }
    }
  }
  pub mod sp_consensus_slots {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Slot(pub u64);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct EquivocationProof<Header, Id> {
      pub offender: Id,
      pub slot: sp_consensus_slots::Slot,
      pub first_header: Header,
      pub second_header: Header,
    }
  }
  pub mod sp_arithmetic {
    use super::*;
    pub mod fixed_point {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct FixedU128(pub u128);
    }
    pub mod per_things {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Perbill(pub u32);
      #[derive(
        Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
      )]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Permill(pub u32);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Percent(pub u8);
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct PerU16(pub u16);
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ArithmeticError {
      #[codec(index = 0u8)]
      Underflow,
      #[codec(index = 1u8)]
      Overflow,
      #[codec(index = 2u8)]
      DivisionByZero,
    }
  }
  pub mod finality_grandpa {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Equivocation<Id, V, S> {
      pub round_number: u64,
      pub identity: Id,
      pub first: (V, S),
      pub second: (V, S),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Prevote<H, N> {
      pub target_hash: H,
      pub target_number: N,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Precommit<H, N> {
      pub target_hash: H,
      pub target_number: N,
    }
  }
  pub mod pallet_asset {
    use super::*;
    pub mod checkpoint {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CheckpointError {
        #[doc = "A checkpoint schedule does not exist for the asset."]
        #[codec(index = 0u8)]
        NoSuchSchedule,
        #[doc = "A checkpoint schedule is not removable as `ref_count(schedule_id) > 0`."]
        #[codec(index = 1u8)]
        ScheduleNotRemovable,
        #[doc = "The new schedule would put the ticker over the maximum complexity allowed."]
        #[codec(index = 2u8)]
        SchedulesOverMaxComplexity,
        #[doc = "Can't create an empty schedule."]
        #[codec(index = 3u8)]
        ScheduleIsEmpty,
        #[doc = "The schedule has no more checkpoints."]
        #[codec(index = 4u8)]
        ScheduleFinished,
        #[doc = "The schedule has expired checkpoints."]
        #[codec(index = 5u8)]
        ScheduleHasExpiredCheckpoints,
      }
      impl CheckpointError {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::NoSuchSchedule => "Checkpoint.NoSuchSchedule",
            Self::ScheduleNotRemovable => "Checkpoint.ScheduleNotRemovable",
            Self::SchedulesOverMaxComplexity => "Checkpoint.SchedulesOverMaxComplexity",
            Self::ScheduleIsEmpty => "Checkpoint.ScheduleIsEmpty",
            Self::ScheduleFinished => "Checkpoint.ScheduleFinished",
            Self::ScheduleHasExpiredCheckpoints => "Checkpoint.ScheduleHasExpiredCheckpoints",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CheckpointError {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          #[allow(unreachable_patterns)]
          match self {
            Self::NoSuchSchedule => &["A checkpoint schedule does not exist for the asset."],
            Self::ScheduleNotRemovable => {
              &["A checkpoint schedule is not removable as `ref_count(schedule_id) > 0`."]
            }
            Self::SchedulesOverMaxComplexity => {
              &["The new schedule would put the ticker over the maximum complexity allowed."]
            }
            Self::ScheduleIsEmpty => &["Can't create an empty schedule."],
            Self::ScheduleFinished => &["The schedule has no more checkpoints."],
            Self::ScheduleHasExpiredCheckpoints => &["The schedule has expired checkpoints."],
            _ => &[""],
          }
        }
      }
      impl From<CheckpointError> for &'static str {
        fn from(v: CheckpointError) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CheckpointError> for &'static str {
        fn from(v: &CheckpointError) -> Self {
          v.as_static_str()
        }
      }
      #[doc = "Dispatchable calls."]
      #[doc = ""]
      #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub enum CheckpointCall {
        #[doc = "Creates a single checkpoint at the current time."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as an agent of `ticker`."]
        #[doc = "- `ticker` to create the checkpoint for."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`."]
        #[doc = "- `CounterOverflow` if the total checkpoint counter would overflow."]
        #[codec(index = 0u8)]
        create_checkpoint {
          ticker: polymesh_primitives::ticker::Ticker,
        },
        #[doc = "Sets the max complexity of a schedule set for an arbitrary ticker to `max_complexity`."]
        #[doc = "The new maximum is not enforced retroactively,"]
        #[doc = "and only applies once new schedules are made."]
        #[doc = ""]
        #[doc = "Must be called as a PIP (requires \"root\")."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "- `origin` is the root origin."]
        #[doc = "- `max_complexity` allowed for an arbitrary ticker's schedule set."]
        #[codec(index = 1u8)]
        set_schedules_max_complexity { max_complexity: u64 },
        #[doc = "Creates a schedule generating checkpoints"]
        #[doc = "in the future at either a fixed time or at intervals."]
        #[doc = ""]
        #[doc = "The schedule starts out with `strong_ref_count(schedule_id) <- 0`."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as owner of `ticker`."]
        #[doc = "- `ticker` to create the schedule for."]
        #[doc = "- `schedule` that will generate checkpoints."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`."]
        #[doc = "- `InsufficientAccountBalance` if the protocol fee could not be charged."]
        #[doc = "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow."]
        #[doc = ""]
        #[doc = "# Permissions"]
        #[doc = "* Asset"]
        #[codec(index = 2u8)]
        create_schedule {
          ticker: polymesh_primitives::ticker::Ticker,
          schedule: polymesh_common_utilities::traits::checkpoint::ScheduleCheckpoints,
        },
        #[doc = "Removes the checkpoint schedule of an asset identified by `id`."]
        #[doc = ""]
        #[doc = "# Arguments"]
        #[doc = "- `origin` is a signer that has permissions to act as owner of `ticker`."]
        #[doc = "- `ticker` to remove the schedule from."]
        #[doc = "- `id` of the schedule, when it was created by `created_schedule`."]
        #[doc = ""]
        #[doc = "# Errors"]
        #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`."]
        #[doc = "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `ticker`."]
        #[doc = "- `ScheduleNotRemovable` if `id` exists but is not removable."]
        #[doc = ""]
        #[doc = "# Permissions"]
        #[doc = "* Asset"]
        #[codec(index = 3u8)]
        remove_schedule {
          ticker: polymesh_primitives::ticker::Ticker,
          id: polymesh_common_utilities::traits::checkpoint::ScheduleId,
        },
      }
      impl CheckpointCall {
        pub fn as_static_str(&self) -> &'static str {
          #[allow(unreachable_patterns)]
          match self {
            Self::create_checkpoint { .. } => "Checkpoint.create_checkpoint",
            Self::set_schedules_max_complexity { .. } => "Checkpoint.set_schedules_max_complexity",
            Self::create_schedule { .. } => "Checkpoint.create_schedule",
            Self::remove_schedule { .. } => "Checkpoint.remove_schedule",
            _ => "Unknown",
          }
        }
      }
      #[cfg(not(feature = "ink"))]
      impl ::polymesh_api_client::EnumInfo for CheckpointCall {
        fn as_name(&self) -> &'static str {
          self.as_static_str()
        }
        fn as_docs(&self) -> &'static [&'static str] {
          # [allow (unreachable_patterns)] match self { Self :: create_checkpoint { .. } => { & ["Creates a single checkpoint at the current time." , "" , "# Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ticker`." , "- `ticker` to create the checkpoint for." , "" , "# Errors" , "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`." , "- `CounterOverflow` if the total checkpoint counter would overflow." ,] } , Self :: set_schedules_max_complexity { .. } => { & ["Sets the max complexity of a schedule set for an arbitrary ticker to `max_complexity`." , "The new maximum is not enforced retroactively," , "and only applies once new schedules are made." , "" , "Must be called as a PIP (requires \"root\")." , "" , "# Arguments" , "- `origin` is the root origin." , "- `max_complexity` allowed for an arbitrary ticker's schedule set." ,] } , Self :: create_schedule { .. } => { & ["Creates a schedule generating checkpoints" , "in the future at either a fixed time or at intervals." , "" , "The schedule starts out with `strong_ref_count(schedule_id) <- 0`." , "" , "# Arguments" , "- `origin` is a signer that has permissions to act as owner of `ticker`." , "- `ticker` to create the schedule for." , "- `schedule` that will generate checkpoints." , "" , "# Errors" , "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`." , "- `InsufficientAccountBalance` if the protocol fee could not be charged." , "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_schedule { .. } => { & ["Removes the checkpoint schedule of an asset identified by `id`." , "" , "# Arguments" , "- `origin` is a signer that has permissions to act as owner of `ticker`." , "- `ticker` to remove the schedule from." , "- `id` of the schedule, when it was created by `created_schedule`." , "" , "# Errors" , "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`." , "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `ticker`." , "- `ScheduleNotRemovable` if `id` exists but is not removable." , "" , "# Permissions" , "* Asset" ,] } , _ => & [""] , }
        }
      }
      impl From<CheckpointCall> for &'static str {
        fn from(v: CheckpointCall) -> Self {
          v.as_static_str()
        }
      }
      impl From<&CheckpointCall> for &'static str {
        fn from(v: &CheckpointCall) -> Self {
          v.as_static_str()
        }
      }
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct Version(pub u8);
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct TickerRegistrationConfig<U> {
      pub max_ticker_length: u8,
      pub registration_length: Option<U>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct SecurityToken {
      pub total_supply: u128,
      pub owner_did: ::polymesh_api_client::IdentityId,
      pub divisible: bool,
      pub asset_type: polymesh_primitives::asset::AssetType,
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum AssetCall {
      #[doc = "Registers a new ticker or extends validity of an existing ticker."]
      #[doc = "NB: Ticker validity does not get carry forward when renewing ticker."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `ticker` ticker to register."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 0u8)]
      register_ticker {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Accepts a ticker transfer."]
      #[doc = ""]
      #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `auth_id` Authorization ID of ticker transfer authorization."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` is not a valid ticket transfer authorization."]
      #[doc = ""]
      #[codec(index = 1u8)]
      accept_ticker_transfer { auth_id: u64 },
      #[doc = "This function is used to accept a token ownership transfer."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `auth_id` Authorization ID of the token ownership transfer authorization."]
      #[codec(index = 2u8)]
      accept_asset_ownership_transfer { auth_id: u64 },
      #[doc = "Initializes a new security token, with the initiating account as its owner."]
      #[doc = "The total supply will initially be zero. To mint tokens, use `issue`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `name` - the name of the token."]
      #[doc = "* `ticker` - the ticker symbol of the token."]
      #[doc = "* `divisible` - a boolean to identify the divisibility status of the token."]
      #[doc = "* `asset_type` - the asset type."]
      #[doc = "* `identifiers` - a vector of asset identifiers."]
      #[doc = "* `funding_round` - name of the funding round."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `InvalidAssetIdentifier` if any of `identifiers` are invalid."]
      #[doc = "- `MaxLengthOfAssetNameExceeded` if `name`'s length exceeds `T::AssetNameMaxLength`."]
      #[doc = "- `FundingRoundNameMaxLengthExceeded` if the name of the funding round is longer that"]
      #[doc = "`T::FundingRoundNameMaxLength`."]
      #[doc = "- `AssetAlreadyCreated` if asset was already created."]
      #[doc = "- `TickerTooLong` if `ticker`'s length is greater than `config.max_ticker_length` chain"]
      #[doc = "parameter."]
      #[doc = "- `TickerNotAlphanumeric` if `ticker` is not yet registered, and contains non-alphanumeric characters or any character after first occurrence of `\\0`."]
      #[doc = ""]
      #[doc = "## Permissions"]
      #[doc = "* Portfolio"]
      #[codec(index = 3u8)]
      create_asset {
        name: polymesh_primitives::asset::AssetName,
        ticker: polymesh_primitives::ticker::Ticker,
        divisible: bool,
        asset_type: polymesh_primitives::asset::AssetType,
        identifiers: ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
        funding_round: Option<polymesh_primitives::asset::FundingRoundName>,
      },
      #[doc = "Freezes transfers and minting of a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `AlreadyFrozen` if `ticker` is already frozen."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 4u8)]
      freeze {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Unfreezes transfers and minting of a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the frozen token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `NotFrozen` if `ticker` is not frozen yet."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 5u8)]
      unfreeze {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Renames a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `name` - the new name of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `MaxLengthOfAssetNameExceeded` if length of `name` is greater than"]
      #[doc = "`T::AssetNameMaxLength`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 6u8)]
      rename_asset {
        ticker: polymesh_primitives::ticker::Ticker,
        name: polymesh_primitives::asset::AssetName,
      },
      #[doc = "Issue, or mint, new tokens to the caller, which must be an authorized external agent."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - A signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - The [`Ticker`] of the token."]
      #[doc = "* `amount` - The amount of tokens that will be issued."]
      #[doc = "* `portfolio_kind` - The [`PortfolioKind`] of the portfolio that will receive the minted tokens."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[codec(index = 7u8)]
      issue {
        ticker: polymesh_primitives::ticker::Ticker,
        amount: u128,
        portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
      },
      #[doc = "Redeems existing tokens by reducing the balance of the caller's default portfolio and the total supply of the token"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `value` Amount of tokens to redeem."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `Unauthorized` If called by someone without the appropriate external agent permissions"]
      #[doc = "- `InvalidGranularity` If the amount is not divisible by 10^6 for non-divisible tokens"]
      #[doc = "- `InsufficientPortfolioBalance` If the caller's default portfolio doesn't have enough free balance"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[codec(index = 8u8)]
      redeem {
        ticker: polymesh_primitives::ticker::Ticker,
        value: u128,
      },
      #[doc = "Makes an indivisible token divisible."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `AssetAlreadyDivisible` if `ticker` is already divisible."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 9u8)]
      make_divisible {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Add documents for a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `docs` Documents to be attached to `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 10u8)]
      add_documents {
        docs: ::alloc::vec::Vec<polymesh_primitives::document::Document>,
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Remove documents for a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `ids` Documents ids to be removed from `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 11u8)]
      remove_documents {
        ids: ::alloc::vec::Vec<polymesh_primitives::document::DocumentId>,
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Sets the name of the current funding round."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `name` - the desired name of the current funding round."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `FundingRoundNameMaxLengthExceeded` if length of `name` is greater than"]
      #[doc = "`T::FundingRoundNameMaxLength`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 12u8)]
      set_funding_round {
        ticker: polymesh_primitives::ticker::Ticker,
        name: polymesh_primitives::asset::FundingRoundName,
      },
      #[doc = "Updates the asset identifiers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `identifiers` - the asset identifiers to be updated in the form of a vector of pairs"]
      #[doc = "   of `IdentifierType` and `AssetIdentifier` value."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `InvalidAssetIdentifier` if `identifiers` contains any invalid identifier."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 13u8)]
      update_identifiers {
        ticker: polymesh_primitives::ticker::Ticker,
        identifiers: ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
      },
      #[doc = "Forces a transfer of token from `from_portfolio` to the caller's default portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` Must be an external agent with appropriate permissions for a given ticker."]
      #[doc = "* `ticker` Ticker symbol of the asset."]
      #[doc = "* `value`  Amount of tokens need to force transfer."]
      #[doc = "* `from_portfolio` From whom portfolio tokens gets transferred."]
      #[codec(index = 14u8)]
      controller_transfer {
        ticker: polymesh_primitives::ticker::Ticker,
        value: u128,
        from_portfolio: polymesh_primitives::identity_id::PortfolioId,
      },
      #[doc = "Registers a custom asset type."]
      #[doc = ""]
      #[doc = "The provided `ty` will be bound to an ID in storage."]
      #[doc = "The ID can then be used in `AssetType::Custom`."]
      #[doc = "Should the `ty` already exist in storage, no second ID is assigned to it."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` who called the extrinsic."]
      #[doc = "* `ty` contains the string representation of the asset type."]
      #[codec(index = 15u8)]
      register_custom_asset_type { ty: ::alloc::vec::Vec<u8> },
      #[doc = "Utility extrinsic to batch `create_asset` and `register_custom_asset_type`."]
      #[codec(index = 16u8)]
      create_asset_with_custom_type {
        name: polymesh_primitives::asset::AssetName,
        ticker: polymesh_primitives::ticker::Ticker,
        divisible: bool,
        custom_asset_type: ::alloc::vec::Vec<u8>,
        identifiers: ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
        funding_round: Option<polymesh_primitives::asset::FundingRoundName>,
      },
      #[doc = "Set asset metadata value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `key` Metadata key."]
      #[doc = "* `value` Metadata value."]
      #[doc = "* `details` Optional Metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` if the metadata type key doesn't exist."]
      #[doc = "* `AssetMetadataValueIsLocked` if the metadata value for `key` is locked."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` if the metadata value exceeds the maximum length."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[codec(index = 17u8)]
      set_asset_metadata {
        ticker: polymesh_primitives::ticker::Ticker,
        key: polymesh_primitives::asset_metadata::AssetMetadataKey,
        value: polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      },
      #[doc = "Set asset metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `key` Metadata key."]
      #[doc = "* `details` Metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` if the metadata type key doesn't exist."]
      #[doc = "* `AssetMetadataValueIsLocked` if the metadata value for `key` is locked."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[codec(index = 18u8)]
      set_asset_metadata_details {
        ticker: polymesh_primitives::ticker::Ticker,
        key: polymesh_primitives::asset_metadata::AssetMetadataKey,
        detail: polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
      },
      #[doc = "Registers and set local asset metadata."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `name` Metadata name."]
      #[doc = "* `spec` Metadata type definition."]
      #[doc = "* `value` Metadata value."]
      #[doc = "* `details` Optional Metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` if a local metadata type with `name` already exists for `ticker`."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` if the metadata value exceeds the maximum length."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[codec(index = 19u8)]
      register_and_set_local_asset_metadata {
        ticker: polymesh_primitives::ticker::Ticker,
        name: polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: polymesh_primitives::asset_metadata::AssetMetadataSpec,
        value: polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      },
      #[doc = "Registers asset metadata local type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `name` Metadata name."]
      #[doc = "* `spec` Metadata type definition."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` if a local metadata type with `name` already exists for `ticker`."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[codec(index = 20u8)]
      register_asset_metadata_local_type {
        ticker: polymesh_primitives::ticker::Ticker,
        name: polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: polymesh_primitives::asset_metadata::AssetMetadataSpec,
      },
      #[doc = "Registers asset metadata global type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `name` Metadata name."]
      #[doc = "* `spec` Metadata type definition."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataGlobalKeyAlreadyExists` if a globa metadata type with `name` already exists."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length."]
      #[codec(index = 21u8)]
      register_asset_metadata_global_type {
        name: polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: polymesh_primitives::asset_metadata::AssetMetadataSpec,
      },
      #[doc = "Redeems existing tokens by reducing the balance of the caller's portfolio and the total supply of the token"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `value` Amount of tokens to redeem."]
      #[doc = "* `portfolio` From whom portfolio tokens gets transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `Unauthorized` If called by someone without the appropriate external agent permissions"]
      #[doc = "- `InvalidGranularity` If the amount is not divisible by 10^6 for non-divisible tokens"]
      #[doc = "- `InsufficientPortfolioBalance` If the caller's `portfolio` doesn't have enough free balance"]
      #[doc = "- `PortfolioDoesNotExist` If the portfolio doesn't exist."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[codec(index = 22u8)]
      redeem_from_portfolio {
        ticker: polymesh_primitives::ticker::Ticker,
        value: u128,
        portfolio: polymesh_primitives::identity_id::PortfolioKind,
      },
      #[doc = "Updates the type of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `asset_type` - the new type of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `InvalidCustomAssetTypeId` if `asset_type` is of type custom and has an invalid type id."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 23u8)]
      update_asset_type {
        ticker: polymesh_primitives::ticker::Ticker,
        asset_type: polymesh_primitives::asset::AssetType,
      },
      #[doc = "Removes the asset metadata key and value of a local key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the local metadata key."]
      #[doc = "* `local_key` - the local metadata key."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = " - `SecondaryKeyNotAuthorizedForAsset` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `UnauthorizedAgent` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `AssetMetadataKeyIsMissing` - if the key doens't exist."]
      #[doc = " - `AssetMetadataValueIsLocked` - if the value of the key is locked."]
      #[doc = " - AssetMetadataKeyBelongsToNFTCollection - if the key is a mandatory key in an NFT collection."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 24u8)]
      remove_local_metadata_key {
        ticker: polymesh_primitives::ticker::Ticker,
        local_key: polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      },
      #[doc = "Removes the asset metadata value of a metadata key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the local metadata key."]
      #[doc = "* `metadata_key` - the metadata key that will have its value deleted."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = " - `SecondaryKeyNotAuthorizedForAsset` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `UnauthorizedAgent` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `AssetMetadataKeyIsMissing` - if the key doens't exist."]
      #[doc = " - `AssetMetadataValueIsLocked` - if the value of the key is locked."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 25u8)]
      remove_metadata_value {
        ticker: polymesh_primitives::ticker::Ticker,
        metadata_key: polymesh_primitives::asset_metadata::AssetMetadataKey,
      },
      #[doc = "Pre-approves the receivement of the asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Root"]
      #[codec(index = 26u8)]
      exempt_ticker_affirmation {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Removes the pre-approval of the asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Root"]
      #[codec(index = 27u8)]
      remove_ticker_affirmation_exemption {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Pre-approves the receivement of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 28u8)]
      pre_approve_ticker {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Removes the pre approval of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 29u8)]
      remove_ticker_pre_approval {
        ticker: polymesh_primitives::ticker::Ticker,
      },
    }
    impl AssetCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::register_ticker { .. } => "Asset.register_ticker",
          Self::accept_ticker_transfer { .. } => "Asset.accept_ticker_transfer",
          Self::accept_asset_ownership_transfer { .. } => "Asset.accept_asset_ownership_transfer",
          Self::create_asset { .. } => "Asset.create_asset",
          Self::freeze { .. } => "Asset.freeze",
          Self::unfreeze { .. } => "Asset.unfreeze",
          Self::rename_asset { .. } => "Asset.rename_asset",
          Self::issue { .. } => "Asset.issue",
          Self::redeem { .. } => "Asset.redeem",
          Self::make_divisible { .. } => "Asset.make_divisible",
          Self::add_documents { .. } => "Asset.add_documents",
          Self::remove_documents { .. } => "Asset.remove_documents",
          Self::set_funding_round { .. } => "Asset.set_funding_round",
          Self::update_identifiers { .. } => "Asset.update_identifiers",
          Self::controller_transfer { .. } => "Asset.controller_transfer",
          Self::register_custom_asset_type { .. } => "Asset.register_custom_asset_type",
          Self::create_asset_with_custom_type { .. } => "Asset.create_asset_with_custom_type",
          Self::set_asset_metadata { .. } => "Asset.set_asset_metadata",
          Self::set_asset_metadata_details { .. } => "Asset.set_asset_metadata_details",
          Self::register_and_set_local_asset_metadata { .. } => {
            "Asset.register_and_set_local_asset_metadata"
          }
          Self::register_asset_metadata_local_type { .. } => {
            "Asset.register_asset_metadata_local_type"
          }
          Self::register_asset_metadata_global_type { .. } => {
            "Asset.register_asset_metadata_global_type"
          }
          Self::redeem_from_portfolio { .. } => "Asset.redeem_from_portfolio",
          Self::update_asset_type { .. } => "Asset.update_asset_type",
          Self::remove_local_metadata_key { .. } => "Asset.remove_local_metadata_key",
          Self::remove_metadata_value { .. } => "Asset.remove_metadata_value",
          Self::exempt_ticker_affirmation { .. } => "Asset.exempt_ticker_affirmation",
          Self::remove_ticker_affirmation_exemption { .. } => {
            "Asset.remove_ticker_affirmation_exemption"
          }
          Self::pre_approve_ticker { .. } => "Asset.pre_approve_ticker",
          Self::remove_ticker_pre_approval { .. } => "Asset.remove_ticker_pre_approval",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for AssetCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: register_ticker { .. } => { & ["Registers a new ticker or extends validity of an existing ticker." , "NB: Ticker validity does not get carry forward when renewing ticker." , "" , "# Arguments" , "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)." , "* `ticker` ticker to register." , "" , "# Permissions" , "* Asset" ,] } , Self :: accept_ticker_transfer { .. } => { & ["Accepts a ticker transfer." , "" , "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)." , "NB: To reject the transfer, call remove auth function in identity module." , "" , "# Arguments" , "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)." , "* `auth_id` Authorization ID of ticker transfer authorization." , "" , "## Errors" , "- `AuthorizationError::BadType` if `auth_id` is not a valid ticket transfer authorization." , "" ,] } , Self :: accept_asset_ownership_transfer { .. } => { & ["This function is used to accept a token ownership transfer." , "NB: To reject the transfer, call remove auth function in identity module." , "" , "# Arguments" , "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)." , "* `auth_id` Authorization ID of the token ownership transfer authorization." ,] } , Self :: create_asset { .. } => { & ["Initializes a new security token, with the initiating account as its owner." , "The total supply will initially be zero. To mint tokens, use `issue`." , "" , "# Arguments" , "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)." , "* `name` - the name of the token." , "* `ticker` - the ticker symbol of the token." , "* `divisible` - a boolean to identify the divisibility status of the token." , "* `asset_type` - the asset type." , "* `identifiers` - a vector of asset identifiers." , "* `funding_round` - name of the funding round." , "" , "## Errors" , "- `InvalidAssetIdentifier` if any of `identifiers` are invalid." , "- `MaxLengthOfAssetNameExceeded` if `name`'s length exceeds `T::AssetNameMaxLength`." , "- `FundingRoundNameMaxLengthExceeded` if the name of the funding round is longer that" , "`T::FundingRoundNameMaxLength`." , "- `AssetAlreadyCreated` if asset was already created." , "- `TickerTooLong` if `ticker`'s length is greater than `config.max_ticker_length` chain" , "parameter." , "- `TickerNotAlphanumeric` if `ticker` is not yet registered, and contains non-alphanumeric characters or any character after first occurrence of `\\0`." , "" , "## Permissions" , "* Portfolio" ,] } , Self :: freeze { .. } => { & ["Freezes transfers and minting of a given token." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the ticker of the token." , "" , "## Errors" , "- `AlreadyFrozen` if `ticker` is already frozen." , "" , "# Permissions" , "* Asset" ,] } , Self :: unfreeze { .. } => { & ["Unfreezes transfers and minting of a given token." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the ticker of the frozen token." , "" , "## Errors" , "- `NotFrozen` if `ticker` is not frozen yet." , "" , "# Permissions" , "* Asset" ,] } , Self :: rename_asset { .. } => { & ["Renames a given token." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the ticker of the token." , "* `name` - the new name of the token." , "" , "## Errors" , "- `MaxLengthOfAssetNameExceeded` if length of `name` is greater than" , "`T::AssetNameMaxLength`." , "" , "# Permissions" , "* Asset" ,] } , Self :: issue { .. } => { & ["Issue, or mint, new tokens to the caller, which must be an authorized external agent." , "" , "# Arguments" , "* `origin` - A signer that has permissions to act as an agent of `ticker`." , "* `ticker` - The [`Ticker`] of the token." , "* `amount` - The amount of tokens that will be issued." , "* `portfolio_kind` - The [`PortfolioKind`] of the portfolio that will receive the minted tokens." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: redeem { .. } => { & ["Redeems existing tokens by reducing the balance of the caller's default portfolio and the total supply of the token" , "" , "# Arguments" , "* `origin` is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` Ticker of the token." , "* `value` Amount of tokens to redeem." , "" , "# Errors" , "- `Unauthorized` If called by someone without the appropriate external agent permissions" , "- `InvalidGranularity` If the amount is not divisible by 10^6 for non-divisible tokens" , "- `InsufficientPortfolioBalance` If the caller's default portfolio doesn't have enough free balance" , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: make_divisible { .. } => { & ["Makes an indivisible token divisible." , "" , "# Arguments" , "* `origin` is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` Ticker of the token." , "" , "## Errors" , "- `AssetAlreadyDivisible` if `ticker` is already divisible." , "" , "# Permissions" , "* Asset" ,] } , Self :: add_documents { .. } => { & ["Add documents for a given token." , "" , "# Arguments" , "* `origin` is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` Ticker of the token." , "* `docs` Documents to be attached to `ticker`." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_documents { .. } => { & ["Remove documents for a given token." , "" , "# Arguments" , "* `origin` is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` Ticker of the token." , "* `ids` Documents ids to be removed from `ticker`." , "" , "# Permissions" , "* Asset" ,] } , Self :: set_funding_round { .. } => { & ["Sets the name of the current funding round." , "" , "# Arguments" , "* `origin` - a signer that has permissions to act as an agent of `ticker`." , "* `ticker` - the ticker of the token." , "* `name` - the desired name of the current funding round." , "" , "## Errors" , "- `FundingRoundNameMaxLengthExceeded` if length of `name` is greater than" , "`T::FundingRoundNameMaxLength`." , "" , "# Permissions" , "* Asset" ,] } , Self :: update_identifiers { .. } => { & ["Updates the asset identifiers." , "" , "# Arguments" , "* `origin` - a signer that has permissions to act as an agent of `ticker`." , "* `ticker` - the ticker of the token." , "* `identifiers` - the asset identifiers to be updated in the form of a vector of pairs" , "   of `IdentifierType` and `AssetIdentifier` value." , "" , "## Errors" , "- `InvalidAssetIdentifier` if `identifiers` contains any invalid identifier." , "" , "# Permissions" , "* Asset" ,] } , Self :: controller_transfer { .. } => { & ["Forces a transfer of token from `from_portfolio` to the caller's default portfolio." , "" , "# Arguments" , "* `origin` Must be an external agent with appropriate permissions for a given ticker." , "* `ticker` Ticker symbol of the asset." , "* `value`  Amount of tokens need to force transfer." , "* `from_portfolio` From whom portfolio tokens gets transferred." ,] } , Self :: register_custom_asset_type { .. } => { & ["Registers a custom asset type." , "" , "The provided `ty` will be bound to an ID in storage." , "The ID can then be used in `AssetType::Custom`." , "Should the `ty` already exist in storage, no second ID is assigned to it." , "" , "# Arguments" , "* `origin` who called the extrinsic." , "* `ty` contains the string representation of the asset type." ,] } , Self :: create_asset_with_custom_type { .. } => { & ["Utility extrinsic to batch `create_asset` and `register_custom_asset_type`." ,] } , Self :: set_asset_metadata { .. } => { & ["Set asset metadata value." , "" , "# Arguments" , "* `origin` is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` Ticker of the token." , "* `key` Metadata key." , "* `value` Metadata value." , "* `details` Optional Metadata value details (expire, lock status)." , "" , "# Errors" , "* `AssetMetadataKeyIsMissing` if the metadata type key doesn't exist." , "* `AssetMetadataValueIsLocked` if the metadata value for `key` is locked." , "* `AssetMetadataValueMaxLengthExceeded` if the metadata value exceeds the maximum length." , "" , "# Permissions" , "* Agent" , "* Asset" ,] } , Self :: set_asset_metadata_details { .. } => { & ["Set asset metadata value details (expire, lock status)." , "" , "# Arguments" , "* `origin` is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` Ticker of the token." , "* `key` Metadata key." , "* `details` Metadata value details (expire, lock status)." , "" , "# Errors" , "* `AssetMetadataKeyIsMissing` if the metadata type key doesn't exist." , "* `AssetMetadataValueIsLocked` if the metadata value for `key` is locked." , "" , "# Permissions" , "* Agent" , "* Asset" ,] } , Self :: register_and_set_local_asset_metadata { .. } => { & ["Registers and set local asset metadata." , "" , "# Arguments" , "* `origin` is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` Ticker of the token." , "* `name` Metadata name." , "* `spec` Metadata type definition." , "* `value` Metadata value." , "* `details` Optional Metadata value details (expire, lock status)." , "" , "# Errors" , "* `AssetMetadataLocalKeyAlreadyExists` if a local metadata type with `name` already exists for `ticker`." , "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length." , "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length." , "* `AssetMetadataValueMaxLengthExceeded` if the metadata value exceeds the maximum length." , "" , "# Permissions" , "* Agent" , "* Asset" ,] } , Self :: register_asset_metadata_local_type { .. } => { & ["Registers asset metadata local type." , "" , "# Arguments" , "* `origin` is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` Ticker of the token." , "* `name` Metadata name." , "* `spec` Metadata type definition." , "" , "# Errors" , "* `AssetMetadataLocalKeyAlreadyExists` if a local metadata type with `name` already exists for `ticker`." , "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length." , "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length." , "" , "# Permissions" , "* Agent" , "* Asset" ,] } , Self :: register_asset_metadata_global_type { .. } => { & ["Registers asset metadata global type." , "" , "# Arguments" , "* `origin` is a signer that has permissions to act as an agent of `ticker`." , "* `name` Metadata name." , "* `spec` Metadata type definition." , "" , "# Errors" , "* `AssetMetadataGlobalKeyAlreadyExists` if a globa metadata type with `name` already exists." , "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length." , "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length." ,] } , Self :: redeem_from_portfolio { .. } => { & ["Redeems existing tokens by reducing the balance of the caller's portfolio and the total supply of the token" , "" , "# Arguments" , "* `origin` is a signer that has permissions to act as an agent of `ticker`." , "* `ticker` Ticker of the token." , "* `value` Amount of tokens to redeem." , "* `portfolio` From whom portfolio tokens gets transferred." , "" , "# Errors" , "- `Unauthorized` If called by someone without the appropriate external agent permissions" , "- `InvalidGranularity` If the amount is not divisible by 10^6 for non-divisible tokens" , "- `InsufficientPortfolioBalance` If the caller's `portfolio` doesn't have enough free balance" , "- `PortfolioDoesNotExist` If the portfolio doesn't exist." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: update_asset_type { .. } => { & ["Updates the type of an asset." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the ticker of the token." , "* `asset_type` - the new type of the token." , "" , "## Errors" , "- `InvalidCustomAssetTypeId` if `asset_type` is of type custom and has an invalid type id." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_local_metadata_key { .. } => { & ["Removes the asset metadata key and value of a local key." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the ticker of the local metadata key." , "* `local_key` - the local metadata key." , "" , "# Errors" , " - `SecondaryKeyNotAuthorizedForAsset` - if called by someone without the appropriate external agent permissions." , " - `UnauthorizedAgent` - if called by someone without the appropriate external agent permissions." , " - `AssetMetadataKeyIsMissing` - if the key doens't exist." , " - `AssetMetadataValueIsLocked` - if the value of the key is locked." , " - AssetMetadataKeyBelongsToNFTCollection - if the key is a mandatory key in an NFT collection." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_metadata_value { .. } => { & ["Removes the asset metadata value of a metadata key." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the ticker of the local metadata key." , "* `metadata_key` - the metadata key that will have its value deleted." , "" , "# Errors" , " - `SecondaryKeyNotAuthorizedForAsset` - if called by someone without the appropriate external agent permissions." , " - `UnauthorizedAgent` - if called by someone without the appropriate external agent permissions." , " - `AssetMetadataKeyIsMissing` - if the key doens't exist." , " - `AssetMetadataValueIsLocked` - if the value of the key is locked." , "" , "# Permissions" , "* Asset" ,] } , Self :: exempt_ticker_affirmation { .. } => { & ["Pre-approves the receivement of the asset for all identities." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the [`Ticker`] that will be exempt from affirmation." , "" , "# Permissions" , "* Root" ,] } , Self :: remove_ticker_affirmation_exemption { .. } => { & ["Removes the pre-approval of the asset for all identities." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the [`Ticker`] that will have its exemption removed." , "" , "# Permissions" , "* Root" ,] } , Self :: pre_approve_ticker { .. } => { & ["Pre-approves the receivement of an asset." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the [`Ticker`] that will be exempt from affirmation." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_ticker_pre_approval { .. } => { & ["Removes the pre approval of an asset." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `ticker` - the [`Ticker`] that will have its exemption removed." , "" , "# Permissions" , "* Asset" ,] } , _ => & [""] , }
      }
    }
    impl From<AssetCall> for &'static str {
      fn from(v: AssetCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&AssetCall> for &'static str {
      fn from(v: &AssetCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum AssetOwnershipRelation {
      #[codec(index = 0u8)]
      NotOwned,
      #[codec(index = 1u8)]
      TickerOwned,
      #[codec(index = 2u8)]
      AssetOwned,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct TickerRegistration<U> {
      pub owner: ::polymesh_api_client::IdentityId,
      pub expiry: Option<U>,
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Version(pub u8);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum AssetError {
      #[doc = "The user is not authorized."]
      #[codec(index = 0u8)]
      Unauthorized,
      #[doc = "The token has already been created."]
      #[codec(index = 1u8)]
      AssetAlreadyCreated,
      #[doc = "The ticker length is over the limit."]
      #[codec(index = 2u8)]
      TickerTooLong,
      #[doc = "The ticker has non-alphanumeric parts."]
      #[codec(index = 3u8)]
      TickerNotAlphanumeric,
      #[doc = "The ticker is already registered to someone else."]
      #[codec(index = 4u8)]
      TickerAlreadyRegistered,
      #[doc = "The total supply is above the limit."]
      #[codec(index = 5u8)]
      TotalSupplyAboveLimit,
      #[doc = "No such token."]
      #[codec(index = 6u8)]
      NoSuchAsset,
      #[doc = "The token is already frozen."]
      #[codec(index = 7u8)]
      AlreadyFrozen,
      #[doc = "Not an owner of the token on Ethereum."]
      #[codec(index = 8u8)]
      NotAnOwner,
      #[doc = "An overflow while calculating the balance."]
      #[codec(index = 9u8)]
      BalanceOverflow,
      #[doc = "An overflow while calculating the total supply."]
      #[codec(index = 10u8)]
      TotalSupplyOverflow,
      #[doc = "An invalid granularity."]
      #[codec(index = 11u8)]
      InvalidGranularity,
      #[doc = "The asset must be frozen."]
      #[codec(index = 12u8)]
      NotFrozen,
      #[doc = "Transfer validation check failed."]
      #[codec(index = 13u8)]
      InvalidTransfer,
      #[doc = "The sender balance is not sufficient."]
      #[codec(index = 14u8)]
      InsufficientBalance,
      #[doc = "The token is already divisible."]
      #[codec(index = 15u8)]
      AssetAlreadyDivisible,
      #[doc = "An invalid Ethereum `EcdsaSignature`."]
      #[codec(index = 16u8)]
      InvalidEthereumSignature,
      #[doc = "Registration of ticker has expired."]
      #[codec(index = 17u8)]
      TickerRegistrationExpired,
      #[doc = "Transfers to self are not allowed"]
      #[codec(index = 18u8)]
      SenderSameAsReceiver,
      #[doc = "The given Document does not exist."]
      #[codec(index = 19u8)]
      NoSuchDoc,
      #[doc = "Maximum length of asset name has been exceeded."]
      #[codec(index = 20u8)]
      MaxLengthOfAssetNameExceeded,
      #[doc = "Maximum length of the funding round name has been exceeded."]
      #[codec(index = 21u8)]
      FundingRoundNameMaxLengthExceeded,
      #[doc = "Some `AssetIdentifier` was invalid."]
      #[codec(index = 22u8)]
      InvalidAssetIdentifier,
      #[doc = "Investor Uniqueness claims are not allowed for this asset."]
      #[codec(index = 23u8)]
      InvestorUniquenessClaimNotAllowed,
      #[doc = "Invalid `CustomAssetTypeId`."]
      #[codec(index = 24u8)]
      InvalidCustomAssetTypeId,
      #[doc = "Maximum length of the asset metadata type name has been exceeded."]
      #[codec(index = 25u8)]
      AssetMetadataNameMaxLengthExceeded,
      #[doc = "Maximum length of the asset metadata value has been exceeded."]
      #[codec(index = 26u8)]
      AssetMetadataValueMaxLengthExceeded,
      #[doc = "Maximum length of the asset metadata type definition has been exceeded."]
      #[codec(index = 27u8)]
      AssetMetadataTypeDefMaxLengthExceeded,
      #[doc = "Asset Metadata key is missing."]
      #[codec(index = 28u8)]
      AssetMetadataKeyIsMissing,
      #[doc = "Asset Metadata value is locked."]
      #[codec(index = 29u8)]
      AssetMetadataValueIsLocked,
      #[doc = "Asset Metadata Local type already exists for asset."]
      #[codec(index = 30u8)]
      AssetMetadataLocalKeyAlreadyExists,
      #[doc = "Asset Metadata Global type already exists."]
      #[codec(index = 31u8)]
      AssetMetadataGlobalKeyAlreadyExists,
      #[doc = "Tickers should start with at least one valid byte."]
      #[codec(index = 32u8)]
      TickerFirstByteNotValid,
      #[doc = "Attempt to call an extrinsic that is only permitted for fungible tokens."]
      #[codec(index = 33u8)]
      UnexpectedNonFungibleToken,
      #[doc = "Attempt to update the type of a non fungible token to a fungible token or the other way around."]
      #[codec(index = 34u8)]
      IncompatibleAssetTypeUpdate,
      #[doc = "Attempt to delete a key that is needed for an NFT collection."]
      #[codec(index = 35u8)]
      AssetMetadataKeyBelongsToNFTCollection,
      #[doc = "Attempt to lock a metadata value that is empty."]
      #[codec(index = 36u8)]
      AssetMetadataValueIsEmpty,
    }
    impl AssetError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::Unauthorized => "Asset.Unauthorized",
          Self::AssetAlreadyCreated => "Asset.AssetAlreadyCreated",
          Self::TickerTooLong => "Asset.TickerTooLong",
          Self::TickerNotAlphanumeric => "Asset.TickerNotAlphanumeric",
          Self::TickerAlreadyRegistered => "Asset.TickerAlreadyRegistered",
          Self::TotalSupplyAboveLimit => "Asset.TotalSupplyAboveLimit",
          Self::NoSuchAsset => "Asset.NoSuchAsset",
          Self::AlreadyFrozen => "Asset.AlreadyFrozen",
          Self::NotAnOwner => "Asset.NotAnOwner",
          Self::BalanceOverflow => "Asset.BalanceOverflow",
          Self::TotalSupplyOverflow => "Asset.TotalSupplyOverflow",
          Self::InvalidGranularity => "Asset.InvalidGranularity",
          Self::NotFrozen => "Asset.NotFrozen",
          Self::InvalidTransfer => "Asset.InvalidTransfer",
          Self::InsufficientBalance => "Asset.InsufficientBalance",
          Self::AssetAlreadyDivisible => "Asset.AssetAlreadyDivisible",
          Self::InvalidEthereumSignature => "Asset.InvalidEthereumSignature",
          Self::TickerRegistrationExpired => "Asset.TickerRegistrationExpired",
          Self::SenderSameAsReceiver => "Asset.SenderSameAsReceiver",
          Self::NoSuchDoc => "Asset.NoSuchDoc",
          Self::MaxLengthOfAssetNameExceeded => "Asset.MaxLengthOfAssetNameExceeded",
          Self::FundingRoundNameMaxLengthExceeded => "Asset.FundingRoundNameMaxLengthExceeded",
          Self::InvalidAssetIdentifier => "Asset.InvalidAssetIdentifier",
          Self::InvestorUniquenessClaimNotAllowed => "Asset.InvestorUniquenessClaimNotAllowed",
          Self::InvalidCustomAssetTypeId => "Asset.InvalidCustomAssetTypeId",
          Self::AssetMetadataNameMaxLengthExceeded => "Asset.AssetMetadataNameMaxLengthExceeded",
          Self::AssetMetadataValueMaxLengthExceeded => "Asset.AssetMetadataValueMaxLengthExceeded",
          Self::AssetMetadataTypeDefMaxLengthExceeded => {
            "Asset.AssetMetadataTypeDefMaxLengthExceeded"
          }
          Self::AssetMetadataKeyIsMissing => "Asset.AssetMetadataKeyIsMissing",
          Self::AssetMetadataValueIsLocked => "Asset.AssetMetadataValueIsLocked",
          Self::AssetMetadataLocalKeyAlreadyExists => "Asset.AssetMetadataLocalKeyAlreadyExists",
          Self::AssetMetadataGlobalKeyAlreadyExists => "Asset.AssetMetadataGlobalKeyAlreadyExists",
          Self::TickerFirstByteNotValid => "Asset.TickerFirstByteNotValid",
          Self::UnexpectedNonFungibleToken => "Asset.UnexpectedNonFungibleToken",
          Self::IncompatibleAssetTypeUpdate => "Asset.IncompatibleAssetTypeUpdate",
          Self::AssetMetadataKeyBelongsToNFTCollection => {
            "Asset.AssetMetadataKeyBelongsToNFTCollection"
          }
          Self::AssetMetadataValueIsEmpty => "Asset.AssetMetadataValueIsEmpty",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for AssetError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: Unauthorized => { & ["The user is not authorized." ,] } , Self :: AssetAlreadyCreated => { & ["The token has already been created." ,] } , Self :: TickerTooLong => { & ["The ticker length is over the limit." ,] } , Self :: TickerNotAlphanumeric => { & ["The ticker has non-alphanumeric parts." ,] } , Self :: TickerAlreadyRegistered => { & ["The ticker is already registered to someone else." ,] } , Self :: TotalSupplyAboveLimit => { & ["The total supply is above the limit." ,] } , Self :: NoSuchAsset => { & ["No such token." ,] } , Self :: AlreadyFrozen => { & ["The token is already frozen." ,] } , Self :: NotAnOwner => { & ["Not an owner of the token on Ethereum." ,] } , Self :: BalanceOverflow => { & ["An overflow while calculating the balance." ,] } , Self :: TotalSupplyOverflow => { & ["An overflow while calculating the total supply." ,] } , Self :: InvalidGranularity => { & ["An invalid granularity." ,] } , Self :: NotFrozen => { & ["The asset must be frozen." ,] } , Self :: InvalidTransfer => { & ["Transfer validation check failed." ,] } , Self :: InsufficientBalance => { & ["The sender balance is not sufficient." ,] } , Self :: AssetAlreadyDivisible => { & ["The token is already divisible." ,] } , Self :: InvalidEthereumSignature => { & ["An invalid Ethereum `EcdsaSignature`." ,] } , Self :: TickerRegistrationExpired => { & ["Registration of ticker has expired." ,] } , Self :: SenderSameAsReceiver => { & ["Transfers to self are not allowed" ,] } , Self :: NoSuchDoc => { & ["The given Document does not exist." ,] } , Self :: MaxLengthOfAssetNameExceeded => { & ["Maximum length of asset name has been exceeded." ,] } , Self :: FundingRoundNameMaxLengthExceeded => { & ["Maximum length of the funding round name has been exceeded." ,] } , Self :: InvalidAssetIdentifier => { & ["Some `AssetIdentifier` was invalid." ,] } , Self :: InvestorUniquenessClaimNotAllowed => { & ["Investor Uniqueness claims are not allowed for this asset." ,] } , Self :: InvalidCustomAssetTypeId => { & ["Invalid `CustomAssetTypeId`." ,] } , Self :: AssetMetadataNameMaxLengthExceeded => { & ["Maximum length of the asset metadata type name has been exceeded." ,] } , Self :: AssetMetadataValueMaxLengthExceeded => { & ["Maximum length of the asset metadata value has been exceeded." ,] } , Self :: AssetMetadataTypeDefMaxLengthExceeded => { & ["Maximum length of the asset metadata type definition has been exceeded." ,] } , Self :: AssetMetadataKeyIsMissing => { & ["Asset Metadata key is missing." ,] } , Self :: AssetMetadataValueIsLocked => { & ["Asset Metadata value is locked." ,] } , Self :: AssetMetadataLocalKeyAlreadyExists => { & ["Asset Metadata Local type already exists for asset." ,] } , Self :: AssetMetadataGlobalKeyAlreadyExists => { & ["Asset Metadata Global type already exists." ,] } , Self :: TickerFirstByteNotValid => { & ["Tickers should start with at least one valid byte." ,] } , Self :: UnexpectedNonFungibleToken => { & ["Attempt to call an extrinsic that is only permitted for fungible tokens." ,] } , Self :: IncompatibleAssetTypeUpdate => { & ["Attempt to update the type of a non fungible token to a fungible token or the other way around." ,] } , Self :: AssetMetadataKeyBelongsToNFTCollection => { & ["Attempt to delete a key that is needed for an NFT collection." ,] } , Self :: AssetMetadataValueIsEmpty => { & ["Attempt to lock a metadata value that is empty." ,] } , _ => & [""] , }
      }
    }
    impl From<AssetError> for &'static str {
      fn from(v: AssetError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&AssetError> for &'static str {
      fn from(v: &AssetError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod runtime {
    use super::*;
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum OriginCaller {
      #[codec(index = 0u8)]
      system(frame_support::dispatch::RawOrigin<::polymesh_api_client::AccountId>),
      #[codec(index = 9u8)]
      PolymeshCommittee(
        pallet_committee::RawOrigin<::polymesh_api_client::AccountId, pallet_committee::Instance1>,
      ),
      #[codec(index = 11u8)]
      TechnicalCommittee(
        pallet_committee::RawOrigin<::polymesh_api_client::AccountId, pallet_committee::Instance3>,
      ),
      #[codec(index = 13u8)]
      UpgradeCommittee(
        pallet_committee::RawOrigin<::polymesh_api_client::AccountId, pallet_committee::Instance4>,
      ),
      #[codec(index = 4u8)]
      Void(sp_core::Void),
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct SessionKeys {
      pub grandpa: sp_consensus_grandpa::app::Public,
      pub babe: sp_consensus_babe::app::Public,
      pub im_online: pallet_im_online::sr25519::app_sr25519::Public,
      pub authority_discovery: sp_authority_discovery::app::Public,
    }
    pub mod events {
      use super::*;
      pub type SystemEvent = frame_system::pallet::SystemEvent;
      pub type IndicesEvent = pallet_indices::pallet::IndicesEvent;
      pub type BalancesEvent = polymesh_common_utilities::traits::balances::BalancesEvent<
        ::polymesh_api_client::AccountId,
      >;
      pub type TransactionPaymentEvent =
        pallet_transaction_payment::TransactionPaymentEvent<u128, ::polymesh_api_client::AccountId>;
      pub type IdentityEvent = polymesh_common_utilities::traits::identity::IdentityEvent<
        ::polymesh_api_client::AccountId,
        u64,
      >;
      pub type CddServiceProvidersEvent =
        polymesh_common_utilities::traits::group::UpgradeCommitteeMembershipEvent<
          ::polymesh_api_client::AccountId,
          runtime::RuntimeEvent,
          pallet_group::Instance2,
        >;
      pub type PolymeshCommitteeEvent = pallet_committee::UpgradeCommitteeEvent<
        primitive_types::H256,
        u32,
        pallet_committee::Instance1,
      >;
      pub type CommitteeMembershipEvent =
        polymesh_common_utilities::traits::group::UpgradeCommitteeMembershipEvent<
          ::polymesh_api_client::AccountId,
          runtime::RuntimeEvent,
          pallet_group::Instance1,
        >;
      pub type TechnicalCommitteeEvent = pallet_committee::UpgradeCommitteeEvent<
        primitive_types::H256,
        u32,
        pallet_committee::Instance3,
      >;
      pub type TechnicalCommitteeMembershipEvent =
        polymesh_common_utilities::traits::group::UpgradeCommitteeMembershipEvent<
          ::polymesh_api_client::AccountId,
          runtime::RuntimeEvent,
          pallet_group::Instance3,
        >;
      pub type UpgradeCommitteeEvent = pallet_committee::UpgradeCommitteeEvent<
        primitive_types::H256,
        u32,
        pallet_committee::Instance4,
      >;
      pub type UpgradeCommitteeMembershipEvent =
        polymesh_common_utilities::traits::group::UpgradeCommitteeMembershipEvent<
          ::polymesh_api_client::AccountId,
          runtime::RuntimeEvent,
          pallet_group::Instance4,
        >;
      pub type MultiSigEvent = polymesh_common_utilities::traits::multisig::MultiSigEvent<
        ::polymesh_api_client::AccountId,
      >;
      pub type BridgeEvent = pallet_bridge::BridgeEvent<::polymesh_api_client::AccountId, u32>;
      pub type StakingEvent = pallet_staking::StakingEvent<u128, ::polymesh_api_client::AccountId>;
      pub type OffencesEvent = pallet_offences::pallet::OffencesEvent;
      pub type SessionEvent = pallet_session::pallet::SessionEvent;
      pub type GrandpaEvent = pallet_grandpa::pallet::GrandpaEvent;
      pub type ImOnlineEvent = pallet_im_online::pallet::ImOnlineEvent;
      pub type SudoEvent = pallet_sudo::SudoEvent<::polymesh_api_client::AccountId>;
      pub type AssetEvent =
        polymesh_common_utilities::traits::asset::AssetEvent<u64, ::polymesh_api_client::AccountId>;
      pub type CapitalDistributionEvent =
        pallet_corporate_actions::distribution::CapitalDistributionEvent;
      pub type CheckpointEvent = polymesh_common_utilities::traits::checkpoint::CheckpointEvent;
      pub type ComplianceManagerEvent =
        polymesh_common_utilities::traits::compliance_manager::ComplianceManagerEvent;
      pub type CorporateActionEvent = pallet_corporate_actions::CorporateActionEvent;
      pub type CorporateBallotEvent = pallet_corporate_actions::ballot::CorporateBallotEvent;
      pub type PipsEvent = pallet_pips::PipsEvent<::polymesh_api_client::AccountId, u32>;
      pub type PortfolioEvent = polymesh_common_utilities::traits::portfolio::PortfolioEvent;
      pub type ProtocolFeeEvent =
        pallet_protocol_fee::ProtocolFeeEvent<::polymesh_api_client::AccountId>;
      pub type SchedulerEvent = pallet_scheduler::pallet::SchedulerEvent;
      pub type SettlementEvent = polymesh_common_utilities::traits::settlement::SettlementEvent<
        u64,
        u32,
        ::polymesh_api_client::AccountId,
      >;
      pub type StatisticsEvent = polymesh_common_utilities::traits::statistics::StatisticsEvent;
      pub type StoEvent = pallet_sto::StoEvent<u64>;
      pub type TreasuryEvent =
        pallet_treasury::TreasuryEvent<u128, ::polymesh_api_client::AccountId>;
      pub type UtilityEvent = pallet_utility::pallet::UtilityEvent;
      pub type BaseEvent = polymesh_common_utilities::traits::base::BaseEvent;
      pub type ExternalAgentsEvent =
        polymesh_common_utilities::traits::external_agents::ExternalAgentsEvent;
      pub type RelayerEvent =
        polymesh_common_utilities::traits::relayer::RelayerEvent<::polymesh_api_client::AccountId>;
      pub type ContractsEvent = pallet_contracts::pallet::ContractsEvent;
      pub type PolymeshContractsEvent = polymesh_contracts::PolymeshContractsEvent;
      pub type PreimageEvent = pallet_preimage::pallet::PreimageEvent;
      pub type NftEvent = polymesh_common_utilities::traits::nft::NftEvent;
      pub type TestUtilsEvent = pallet_test_utils::TestUtilsEvent<::polymesh_api_client::AccountId>;
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RuntimeEvent {
      #[codec(index = 0u8)]
      System(events::SystemEvent),
      #[codec(index = 3u8)]
      Indices(events::IndicesEvent),
      #[codec(index = 5u8)]
      Balances(events::BalancesEvent),
      #[codec(index = 6u8)]
      TransactionPayment(events::TransactionPaymentEvent),
      #[codec(index = 7u8)]
      Identity(events::IdentityEvent),
      #[codec(index = 8u8)]
      CddServiceProviders(events::CddServiceProvidersEvent),
      #[codec(index = 9u8)]
      PolymeshCommittee(events::PolymeshCommitteeEvent),
      #[codec(index = 10u8)]
      CommitteeMembership(events::CommitteeMembershipEvent),
      #[codec(index = 11u8)]
      TechnicalCommittee(events::TechnicalCommitteeEvent),
      #[codec(index = 12u8)]
      TechnicalCommitteeMembership(events::TechnicalCommitteeMembershipEvent),
      #[codec(index = 13u8)]
      UpgradeCommittee(events::UpgradeCommitteeEvent),
      #[codec(index = 14u8)]
      UpgradeCommitteeMembership(events::UpgradeCommitteeMembershipEvent),
      #[codec(index = 15u8)]
      MultiSig(events::MultiSigEvent),
      #[codec(index = 16u8)]
      Bridge(events::BridgeEvent),
      #[codec(index = 17u8)]
      Staking(events::StakingEvent),
      #[codec(index = 18u8)]
      Offences(events::OffencesEvent),
      #[codec(index = 19u8)]
      Session(events::SessionEvent),
      #[codec(index = 21u8)]
      Grandpa(events::GrandpaEvent),
      #[codec(index = 23u8)]
      ImOnline(events::ImOnlineEvent),
      #[codec(index = 25u8)]
      Sudo(events::SudoEvent),
      #[codec(index = 26u8)]
      Asset(events::AssetEvent),
      #[codec(index = 27u8)]
      CapitalDistribution(events::CapitalDistributionEvent),
      #[codec(index = 28u8)]
      Checkpoint(events::CheckpointEvent),
      #[codec(index = 29u8)]
      ComplianceManager(events::ComplianceManagerEvent),
      #[codec(index = 30u8)]
      CorporateAction(events::CorporateActionEvent),
      #[codec(index = 31u8)]
      CorporateBallot(events::CorporateBallotEvent),
      #[codec(index = 33u8)]
      Pips(events::PipsEvent),
      #[codec(index = 34u8)]
      Portfolio(events::PortfolioEvent),
      #[codec(index = 35u8)]
      ProtocolFee(events::ProtocolFeeEvent),
      #[codec(index = 36u8)]
      Scheduler(events::SchedulerEvent),
      #[codec(index = 37u8)]
      Settlement(events::SettlementEvent),
      #[codec(index = 38u8)]
      Statistics(events::StatisticsEvent),
      #[codec(index = 39u8)]
      Sto(events::StoEvent),
      #[codec(index = 40u8)]
      Treasury(events::TreasuryEvent),
      #[codec(index = 41u8)]
      Utility(events::UtilityEvent),
      #[codec(index = 42u8)]
      Base(events::BaseEvent),
      #[codec(index = 43u8)]
      ExternalAgents(events::ExternalAgentsEvent),
      #[codec(index = 44u8)]
      Relayer(events::RelayerEvent),
      #[codec(index = 46u8)]
      Contracts(events::ContractsEvent),
      #[codec(index = 47u8)]
      PolymeshContracts(events::PolymeshContractsEvent),
      #[codec(index = 48u8)]
      Preimage(events::PreimageEvent),
      #[codec(index = 49u8)]
      Nft(events::NftEvent),
      #[codec(index = 50u8)]
      TestUtils(events::TestUtilsEvent),
    }
    impl RuntimeEvent {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::System(val) => val.as_static_str(),
          Self::Indices(val) => val.as_static_str(),
          Self::Balances(val) => val.as_static_str(),
          Self::TransactionPayment(val) => val.as_static_str(),
          Self::Identity(val) => val.as_static_str(),
          Self::CddServiceProviders(val) => val.as_static_str(),
          Self::PolymeshCommittee(val) => val.as_static_str(),
          Self::CommitteeMembership(val) => val.as_static_str(),
          Self::TechnicalCommittee(val) => val.as_static_str(),
          Self::TechnicalCommitteeMembership(val) => val.as_static_str(),
          Self::UpgradeCommittee(val) => val.as_static_str(),
          Self::UpgradeCommitteeMembership(val) => val.as_static_str(),
          Self::MultiSig(val) => val.as_static_str(),
          Self::Bridge(val) => val.as_static_str(),
          Self::Staking(val) => val.as_static_str(),
          Self::Offences(val) => val.as_static_str(),
          Self::Session(val) => val.as_static_str(),
          Self::Grandpa(val) => val.as_static_str(),
          Self::ImOnline(val) => val.as_static_str(),
          Self::Sudo(val) => val.as_static_str(),
          Self::Asset(val) => val.as_static_str(),
          Self::CapitalDistribution(val) => val.as_static_str(),
          Self::Checkpoint(val) => val.as_static_str(),
          Self::ComplianceManager(val) => val.as_static_str(),
          Self::CorporateAction(val) => val.as_static_str(),
          Self::CorporateBallot(val) => val.as_static_str(),
          Self::Pips(val) => val.as_static_str(),
          Self::Portfolio(val) => val.as_static_str(),
          Self::ProtocolFee(val) => val.as_static_str(),
          Self::Scheduler(val) => val.as_static_str(),
          Self::Settlement(val) => val.as_static_str(),
          Self::Statistics(val) => val.as_static_str(),
          Self::Sto(val) => val.as_static_str(),
          Self::Treasury(val) => val.as_static_str(),
          Self::Utility(val) => val.as_static_str(),
          Self::Base(val) => val.as_static_str(),
          Self::ExternalAgents(val) => val.as_static_str(),
          Self::Relayer(val) => val.as_static_str(),
          Self::Contracts(val) => val.as_static_str(),
          Self::PolymeshContracts(val) => val.as_static_str(),
          Self::Preimage(val) => val.as_static_str(),
          Self::Nft(val) => val.as_static_str(),
          Self::TestUtils(val) => val.as_static_str(),
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for RuntimeEvent {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::System(val) => val.as_docs(),
          Self::Indices(val) => val.as_docs(),
          Self::Balances(val) => val.as_docs(),
          Self::TransactionPayment(val) => val.as_docs(),
          Self::Identity(val) => val.as_docs(),
          Self::CddServiceProviders(val) => val.as_docs(),
          Self::PolymeshCommittee(val) => val.as_docs(),
          Self::CommitteeMembership(val) => val.as_docs(),
          Self::TechnicalCommittee(val) => val.as_docs(),
          Self::TechnicalCommitteeMembership(val) => val.as_docs(),
          Self::UpgradeCommittee(val) => val.as_docs(),
          Self::UpgradeCommitteeMembership(val) => val.as_docs(),
          Self::MultiSig(val) => val.as_docs(),
          Self::Bridge(val) => val.as_docs(),
          Self::Staking(val) => val.as_docs(),
          Self::Offences(val) => val.as_docs(),
          Self::Session(val) => val.as_docs(),
          Self::Grandpa(val) => val.as_docs(),
          Self::ImOnline(val) => val.as_docs(),
          Self::Sudo(val) => val.as_docs(),
          Self::Asset(val) => val.as_docs(),
          Self::CapitalDistribution(val) => val.as_docs(),
          Self::Checkpoint(val) => val.as_docs(),
          Self::ComplianceManager(val) => val.as_docs(),
          Self::CorporateAction(val) => val.as_docs(),
          Self::CorporateBallot(val) => val.as_docs(),
          Self::Pips(val) => val.as_docs(),
          Self::Portfolio(val) => val.as_docs(),
          Self::ProtocolFee(val) => val.as_docs(),
          Self::Scheduler(val) => val.as_docs(),
          Self::Settlement(val) => val.as_docs(),
          Self::Statistics(val) => val.as_docs(),
          Self::Sto(val) => val.as_docs(),
          Self::Treasury(val) => val.as_docs(),
          Self::Utility(val) => val.as_docs(),
          Self::Base(val) => val.as_docs(),
          Self::ExternalAgents(val) => val.as_docs(),
          Self::Relayer(val) => val.as_docs(),
          Self::Contracts(val) => val.as_docs(),
          Self::PolymeshContracts(val) => val.as_docs(),
          Self::Preimage(val) => val.as_docs(),
          Self::Nft(val) => val.as_docs(),
          Self::TestUtils(val) => val.as_docs(),
          _ => &[""],
        }
      }
    }
    impl From<RuntimeEvent> for &'static str {
      fn from(v: RuntimeEvent) -> Self {
        v.as_static_str()
      }
    }
    impl From<&RuntimeEvent> for &'static str {
      fn from(v: &RuntimeEvent) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum RuntimeCall {
      #[codec(index = 0u8)]
      System(frame_system::pallet::SystemCall),
      #[codec(index = 1u8)]
      Babe(pallet_babe::pallet::BabeCall),
      #[codec(index = 2u8)]
      Timestamp(pallet_timestamp::pallet::TimestampCall),
      #[codec(index = 3u8)]
      Indices(pallet_indices::pallet::IndicesCall),
      #[codec(index = 5u8)]
      Balances(pallet_balances::BalancesCall),
      #[codec(index = 7u8)]
      Identity(pallet_identity::IdentityCall),
      #[codec(index = 8u8)]
      CddServiceProviders(pallet_group::UpgradeCommitteeMembershipCall),
      #[codec(index = 9u8)]
      PolymeshCommittee(pallet_committee::UpgradeCommitteeCall),
      #[codec(index = 10u8)]
      CommitteeMembership(pallet_group::UpgradeCommitteeMembershipCall),
      #[codec(index = 11u8)]
      TechnicalCommittee(pallet_committee::UpgradeCommitteeCall),
      #[codec(index = 12u8)]
      TechnicalCommitteeMembership(pallet_group::UpgradeCommitteeMembershipCall),
      #[codec(index = 13u8)]
      UpgradeCommittee(pallet_committee::UpgradeCommitteeCall),
      #[codec(index = 14u8)]
      UpgradeCommitteeMembership(pallet_group::UpgradeCommitteeMembershipCall),
      #[codec(index = 15u8)]
      MultiSig(pallet_multisig::MultiSigCall),
      #[codec(index = 16u8)]
      Bridge(pallet_bridge::BridgeCall),
      #[codec(index = 17u8)]
      Staking(pallet_staking::StakingCall),
      #[codec(index = 19u8)]
      Session(pallet_session::pallet::SessionCall),
      #[codec(index = 21u8)]
      Grandpa(pallet_grandpa::pallet::GrandpaCall),
      #[codec(index = 23u8)]
      ImOnline(pallet_im_online::pallet::ImOnlineCall),
      #[codec(index = 25u8)]
      Sudo(pallet_sudo::SudoCall),
      #[codec(index = 26u8)]
      Asset(pallet_asset::AssetCall),
      #[codec(index = 27u8)]
      CapitalDistribution(pallet_corporate_actions::distribution::CapitalDistributionCall),
      #[codec(index = 28u8)]
      Checkpoint(pallet_asset::checkpoint::CheckpointCall),
      #[codec(index = 29u8)]
      ComplianceManager(pallet_compliance_manager::ComplianceManagerCall),
      #[codec(index = 30u8)]
      CorporateAction(pallet_corporate_actions::CorporateActionCall),
      #[codec(index = 31u8)]
      CorporateBallot(pallet_corporate_actions::ballot::CorporateBallotCall),
      #[codec(index = 33u8)]
      Pips(pallet_pips::PipsCall),
      #[codec(index = 34u8)]
      Portfolio(pallet_portfolio::PortfolioCall),
      #[codec(index = 35u8)]
      ProtocolFee(pallet_protocol_fee::ProtocolFeeCall),
      #[codec(index = 36u8)]
      Scheduler(pallet_scheduler::pallet::SchedulerCall),
      #[codec(index = 37u8)]
      Settlement(pallet_settlement::SettlementCall),
      #[codec(index = 38u8)]
      Statistics(pallet_statistics::StatisticsCall),
      #[codec(index = 39u8)]
      Sto(pallet_sto::StoCall),
      #[codec(index = 40u8)]
      Treasury(pallet_treasury::TreasuryCall),
      #[codec(index = 41u8)]
      Utility(pallet_utility::pallet::UtilityCall),
      #[codec(index = 42u8)]
      Base(pallet_base::BaseCall),
      #[codec(index = 43u8)]
      ExternalAgents(pallet_external_agents::ExternalAgentsCall),
      #[codec(index = 44u8)]
      Relayer(pallet_relayer::RelayerCall),
      #[codec(index = 46u8)]
      Contracts(pallet_contracts::pallet::ContractsCall),
      #[codec(index = 47u8)]
      PolymeshContracts(polymesh_contracts::PolymeshContractsCall),
      #[codec(index = 48u8)]
      Preimage(pallet_preimage::pallet::PreimageCall),
      #[codec(index = 49u8)]
      Nft(pallet_nft::NftCall),
      #[codec(index = 50u8)]
      TestUtils(pallet_test_utils::TestUtilsCall),
    }
    impl RuntimeCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::System(val) => val.as_static_str(),
          Self::Babe(val) => val.as_static_str(),
          Self::Timestamp(val) => val.as_static_str(),
          Self::Indices(val) => val.as_static_str(),
          Self::Balances(val) => val.as_static_str(),
          Self::Identity(val) => val.as_static_str(),
          Self::CddServiceProviders(val) => val.as_static_str(),
          Self::PolymeshCommittee(val) => val.as_static_str(),
          Self::CommitteeMembership(val) => val.as_static_str(),
          Self::TechnicalCommittee(val) => val.as_static_str(),
          Self::TechnicalCommitteeMembership(val) => val.as_static_str(),
          Self::UpgradeCommittee(val) => val.as_static_str(),
          Self::UpgradeCommitteeMembership(val) => val.as_static_str(),
          Self::MultiSig(val) => val.as_static_str(),
          Self::Bridge(val) => val.as_static_str(),
          Self::Staking(val) => val.as_static_str(),
          Self::Session(val) => val.as_static_str(),
          Self::Grandpa(val) => val.as_static_str(),
          Self::ImOnline(val) => val.as_static_str(),
          Self::Sudo(val) => val.as_static_str(),
          Self::Asset(val) => val.as_static_str(),
          Self::CapitalDistribution(val) => val.as_static_str(),
          Self::Checkpoint(val) => val.as_static_str(),
          Self::ComplianceManager(val) => val.as_static_str(),
          Self::CorporateAction(val) => val.as_static_str(),
          Self::CorporateBallot(val) => val.as_static_str(),
          Self::Pips(val) => val.as_static_str(),
          Self::Portfolio(val) => val.as_static_str(),
          Self::ProtocolFee(val) => val.as_static_str(),
          Self::Scheduler(val) => val.as_static_str(),
          Self::Settlement(val) => val.as_static_str(),
          Self::Statistics(val) => val.as_static_str(),
          Self::Sto(val) => val.as_static_str(),
          Self::Treasury(val) => val.as_static_str(),
          Self::Utility(val) => val.as_static_str(),
          Self::Base(val) => val.as_static_str(),
          Self::ExternalAgents(val) => val.as_static_str(),
          Self::Relayer(val) => val.as_static_str(),
          Self::Contracts(val) => val.as_static_str(),
          Self::PolymeshContracts(val) => val.as_static_str(),
          Self::Preimage(val) => val.as_static_str(),
          Self::Nft(val) => val.as_static_str(),
          Self::TestUtils(val) => val.as_static_str(),
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for RuntimeCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::System(val) => val.as_docs(),
          Self::Babe(val) => val.as_docs(),
          Self::Timestamp(val) => val.as_docs(),
          Self::Indices(val) => val.as_docs(),
          Self::Balances(val) => val.as_docs(),
          Self::Identity(val) => val.as_docs(),
          Self::CddServiceProviders(val) => val.as_docs(),
          Self::PolymeshCommittee(val) => val.as_docs(),
          Self::CommitteeMembership(val) => val.as_docs(),
          Self::TechnicalCommittee(val) => val.as_docs(),
          Self::TechnicalCommitteeMembership(val) => val.as_docs(),
          Self::UpgradeCommittee(val) => val.as_docs(),
          Self::UpgradeCommitteeMembership(val) => val.as_docs(),
          Self::MultiSig(val) => val.as_docs(),
          Self::Bridge(val) => val.as_docs(),
          Self::Staking(val) => val.as_docs(),
          Self::Session(val) => val.as_docs(),
          Self::Grandpa(val) => val.as_docs(),
          Self::ImOnline(val) => val.as_docs(),
          Self::Sudo(val) => val.as_docs(),
          Self::Asset(val) => val.as_docs(),
          Self::CapitalDistribution(val) => val.as_docs(),
          Self::Checkpoint(val) => val.as_docs(),
          Self::ComplianceManager(val) => val.as_docs(),
          Self::CorporateAction(val) => val.as_docs(),
          Self::CorporateBallot(val) => val.as_docs(),
          Self::Pips(val) => val.as_docs(),
          Self::Portfolio(val) => val.as_docs(),
          Self::ProtocolFee(val) => val.as_docs(),
          Self::Scheduler(val) => val.as_docs(),
          Self::Settlement(val) => val.as_docs(),
          Self::Statistics(val) => val.as_docs(),
          Self::Sto(val) => val.as_docs(),
          Self::Treasury(val) => val.as_docs(),
          Self::Utility(val) => val.as_docs(),
          Self::Base(val) => val.as_docs(),
          Self::ExternalAgents(val) => val.as_docs(),
          Self::Relayer(val) => val.as_docs(),
          Self::Contracts(val) => val.as_docs(),
          Self::PolymeshContracts(val) => val.as_docs(),
          Self::Preimage(val) => val.as_docs(),
          Self::Nft(val) => val.as_docs(),
          Self::TestUtils(val) => val.as_docs(),
          _ => &[""],
        }
      }
    }
    impl From<RuntimeCall> for &'static str {
      fn from(v: RuntimeCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&RuntimeCall> for &'static str {
      fn from(v: &RuntimeCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct Runtime();
  }
  pub mod pallet_external_agents {
    use super::*;
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ExternalAgentsCall {
      #[doc = "Creates a custom agent group (AG) for the given `ticker`."]
      #[doc = ""]
      #[doc = "The AG will have the permissions as given by `perms`."]
      #[doc = "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`,"]
      #[doc = "which you can use as `AgentGroup::Custom(id)` when adding agents for `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` to add the custom group for."]
      #[doc = "- `perms` that the new AG will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 0u8)]
      create_group {
        ticker: polymesh_primitives::ticker::Ticker,
        perms: polymesh_primitives::subset::SubsetRestriction<
          polymesh_primitives::secondary_key::PalletPermissions,
        >,
      },
      #[doc = "Updates the permissions of the custom AG identified by `id`, for the given `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` the custom AG belongs to."]
      #[doc = "- `id` for the custom AG within `ticker`."]
      #[doc = "- `perms` to update the custom AG to."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 1u8)]
      set_group_permissions {
        ticker: polymesh_primitives::ticker::Ticker,
        id: polymesh_primitives::agent::AGId,
        perms: polymesh_primitives::subset::SubsetRestriction<
          polymesh_primitives::secondary_key::PalletPermissions,
        >,
      },
      #[doc = "Remove the given `agent` from `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` that has the `agent` to remove."]
      #[doc = "- `agent` of `ticker` to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `ticker`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` is the last full one."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 2u8)]
      remove_agent {
        ticker: polymesh_primitives::ticker::Ticker,
        agent: ::polymesh_api_client::IdentityId,
      },
      #[doc = "Abdicate agentship for `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` of which the caller is an agent."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAnAgent` if the caller is not an agent of `ticker`."]
      #[doc = "- `RemovingLastFullAgent` if the caller is the last full agent."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[codec(index = 3u8)]
      abdicate {
        ticker: polymesh_primitives::ticker::Ticker,
      },
      #[doc = "Change the agent group that `agent` belongs to in `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` that has the `agent`."]
      #[doc = "- `agent` of `ticker` to change the group for."]
      #[doc = "- `group` that `agent` will belong to in `ticker`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `ticker`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 4u8)]
      change_group {
        ticker: polymesh_primitives::ticker::Ticker,
        agent: ::polymesh_api_client::IdentityId,
        group: polymesh_primitives::agent::AgentGroup,
      },
      #[doc = "Accept an authorization by an agent \"Alice\" who issued `auth_id`"]
      #[doc = "to also become an agent of the ticker Alice specified."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` identifying the authorization to accept."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` is for an auth that has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not for a `BecomeAgent` auth type."]
      #[doc = "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth."]
      #[doc = "- `NoSuchAG` if the group referred to a custom that does not exist."]
      #[doc = "- `AlreadyAnAgent` if the caller is already an agent of the ticker."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[codec(index = 5u8)]
      accept_become_agent { auth_id: u64 },
      #[doc = "Utility extrinsic to batch `create_group` and  `add_auth`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 6u8)]
      create_group_and_add_auth {
        ticker: polymesh_primitives::ticker::Ticker,
        perms: polymesh_primitives::subset::SubsetRestriction<
          polymesh_primitives::secondary_key::PalletPermissions,
        >,
        target: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
      },
      #[doc = "Utility extrinsic to batch `create_group` and  `change_group` for custom groups only."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[codec(index = 7u8)]
      create_and_change_custom_group {
        ticker: polymesh_primitives::ticker::Ticker,
        perms: polymesh_primitives::subset::SubsetRestriction<
          polymesh_primitives::secondary_key::PalletPermissions,
        >,
        agent: ::polymesh_api_client::IdentityId,
      },
    }
    impl ExternalAgentsCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_group { .. } => "ExternalAgents.create_group",
          Self::set_group_permissions { .. } => "ExternalAgents.set_group_permissions",
          Self::remove_agent { .. } => "ExternalAgents.remove_agent",
          Self::abdicate { .. } => "ExternalAgents.abdicate",
          Self::change_group { .. } => "ExternalAgents.change_group",
          Self::accept_become_agent { .. } => "ExternalAgents.accept_become_agent",
          Self::create_group_and_add_auth { .. } => "ExternalAgents.create_group_and_add_auth",
          Self::create_and_change_custom_group { .. } => {
            "ExternalAgents.create_and_change_custom_group"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ExternalAgentsCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::create_group { .. } => &[
            "Creates a custom agent group (AG) for the given `ticker`.",
            "",
            "The AG will have the permissions as given by `perms`.",
            "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`,",
            "which you can use as `AgentGroup::Custom(id)` when adding agents for `ticker`.",
            "",
            "# Arguments",
            "- `ticker` to add the custom group for.",
            "- `perms` that the new AG will have.",
            "",
            "# Errors",
            "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this.",
            "- `TooLong` if `perms` had some string or list length that was too long.",
            "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`.",
            "",
            "# Permissions",
            "* Asset",
            "* Agent",
          ],
          Self::set_group_permissions { .. } => &[
            "Updates the permissions of the custom AG identified by `id`, for the given `ticker`.",
            "",
            "# Arguments",
            "- `ticker` the custom AG belongs to.",
            "- `id` for the custom AG within `ticker`.",
            "- `perms` to update the custom AG to.",
            "",
            "# Errors",
            "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this.",
            "- `TooLong` if `perms` had some string or list length that was too long.",
            "- `NoSuchAG` if `id` does not identify a custom AG.",
            "",
            "# Permissions",
            "* Asset",
            "* Agent",
          ],
          Self::remove_agent { .. } => &[
            "Remove the given `agent` from `ticker`.",
            "",
            "# Arguments",
            "- `ticker` that has the `agent` to remove.",
            "- `agent` of `ticker` to remove.",
            "",
            "# Errors",
            "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this.",
            "- `NotAnAgent` if `agent` is not an agent of `ticker`.",
            "- `RemovingLastFullAgent` if `agent` is the last full one.",
            "",
            "# Permissions",
            "* Asset",
            "* Agent",
          ],
          Self::abdicate { .. } => &[
            "Abdicate agentship for `ticker`.",
            "",
            "# Arguments",
            "- `ticker` of which the caller is an agent.",
            "",
            "# Errors",
            "- `NotAnAgent` if the caller is not an agent of `ticker`.",
            "- `RemovingLastFullAgent` if the caller is the last full agent.",
            "",
            "# Permissions",
            "* Asset",
          ],
          Self::change_group { .. } => &[
            "Change the agent group that `agent` belongs to in `ticker`.",
            "",
            "# Arguments",
            "- `ticker` that has the `agent`.",
            "- `agent` of `ticker` to change the group for.",
            "- `group` that `agent` will belong to in `ticker`.",
            "",
            "# Errors",
            "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this.",
            "- `NoSuchAG` if `id` does not identify a custom AG.",
            "- `NotAnAgent` if `agent` is not an agent of `ticker`.",
            "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted.",
            "",
            "# Permissions",
            "* Asset",
            "* Agent",
          ],
          Self::accept_become_agent { .. } => &[
            "Accept an authorization by an agent \"Alice\" who issued `auth_id`",
            "to also become an agent of the ticker Alice specified.",
            "",
            "# Arguments",
            "- `auth_id` identifying the authorization to accept.",
            "",
            "# Errors",
            "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller.",
            "- `AuthorizationError::Expired` if `auth_id` is for an auth that has expired.",
            "- `AuthorizationError::BadType` if `auth_id` was not for a `BecomeAgent` auth type.",
            "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth.",
            "- `NoSuchAG` if the group referred to a custom that does not exist.",
            "- `AlreadyAnAgent` if the caller is already an agent of the ticker.",
            "",
            "# Permissions",
            "* Agent",
          ],
          Self::create_group_and_add_auth { .. } => &[
            "Utility extrinsic to batch `create_group` and  `add_auth`.",
            "",
            "# Permissions",
            "* Asset",
            "* Agent",
          ],
          Self::create_and_change_custom_group { .. } => &[
            "Utility extrinsic to batch `create_group` and  `change_group` for custom groups only.",
            "",
            "# Permissions",
            "* Asset",
            "* Agent",
          ],
          _ => &[""],
        }
      }
    }
    impl From<ExternalAgentsCall> for &'static str {
      fn from(v: ExternalAgentsCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ExternalAgentsCall> for &'static str {
      fn from(v: &ExternalAgentsCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum ExternalAgentsError {
      #[doc = "An AG with the given `AGId` did not exist for the `Ticker`."]
      #[codec(index = 0u8)]
      NoSuchAG,
      #[doc = "The agent is not authorized to call the current extrinsic."]
      #[codec(index = 1u8)]
      UnauthorizedAgent,
      #[doc = "The provided `agent` is already an agent for the `Ticker`."]
      #[codec(index = 2u8)]
      AlreadyAnAgent,
      #[doc = "The provided `agent` is not an agent for the `Ticker`."]
      #[codec(index = 3u8)]
      NotAnAgent,
      #[doc = "This agent is the last full one, and it's being removed,"]
      #[doc = "making the asset orphaned."]
      #[codec(index = 4u8)]
      RemovingLastFullAgent,
      #[doc = "The caller's secondary key does not have the required asset permission."]
      #[codec(index = 5u8)]
      SecondaryKeyNotAuthorizedForAsset,
    }
    impl ExternalAgentsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::NoSuchAG => "ExternalAgents.NoSuchAG",
          Self::UnauthorizedAgent => "ExternalAgents.UnauthorizedAgent",
          Self::AlreadyAnAgent => "ExternalAgents.AlreadyAnAgent",
          Self::NotAnAgent => "ExternalAgents.NotAnAgent",
          Self::RemovingLastFullAgent => "ExternalAgents.RemovingLastFullAgent",
          Self::SecondaryKeyNotAuthorizedForAsset => {
            "ExternalAgents.SecondaryKeyNotAuthorizedForAsset"
          }
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for ExternalAgentsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::NoSuchAG => &["An AG with the given `AGId` did not exist for the `Ticker`."],
          Self::UnauthorizedAgent => {
            &["The agent is not authorized to call the current extrinsic."]
          }
          Self::AlreadyAnAgent => &["The provided `agent` is already an agent for the `Ticker`."],
          Self::NotAnAgent => &["The provided `agent` is not an agent for the `Ticker`."],
          Self::RemovingLastFullAgent => &[
            "This agent is the last full one, and it's being removed,",
            "making the asset orphaned.",
          ],
          Self::SecondaryKeyNotAuthorizedForAsset => {
            &["The caller's secondary key does not have the required asset permission."]
          }
          _ => &[""],
        }
      }
    }
    impl From<ExternalAgentsError> for &'static str {
      fn from(v: ExternalAgentsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&ExternalAgentsError> for &'static str {
      fn from(v: &ExternalAgentsError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod pallet_transaction_payment {
    use super::*;
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TransactionPaymentEvent<Balance, AccountId> {
      #[doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"]
      #[doc = "has been paid by `who`."]
      #[codec(index = 0u8)]
      TransactionFeePaid {
        who: AccountId,
        actual_fee: Balance,
        tip: Balance,
      },
    }
    impl<Balance, AccountId> TransactionPaymentEvent<Balance, AccountId> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::TransactionFeePaid { .. } => "TransactionPayment.TransactionFeePaid",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<Balance, AccountId> ::polymesh_api_client::EnumInfo
      for TransactionPaymentEvent<Balance, AccountId>
    {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: TransactionFeePaid { .. } => { & ["A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee," , "has been paid by `who`." ,] } , _ => & [""] , }
      }
    }
    impl<Balance, AccountId> From<TransactionPaymentEvent<Balance, AccountId>> for &'static str {
      fn from(v: TransactionPaymentEvent<Balance, AccountId>) -> Self {
        v.as_static_str()
      }
    }
    impl<Balance, AccountId> From<&TransactionPaymentEvent<Balance, AccountId>> for &'static str {
      fn from(v: &TransactionPaymentEvent<Balance, AccountId>) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub struct ChargeTransactionPayment(#[codec(compact)] pub u128);
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum Releases {
      #[codec(index = 0u8)]
      V1Ancient,
      #[codec(index = 1u8)]
      V2,
    }
  }
  pub mod pallet_test_utils {
    use super::*;
    #[doc = "Events for this module."]
    #[doc = ""]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TestUtilsEvent<AccountId> {
      #[doc = "Emits the `IdentityId` and the `AccountId` of the caller."]
      #[doc = "(Caller DID, Caller account)"]
      #[codec(index = 0u8)]
      DidStatus(::polymesh_api_client::IdentityId, AccountId),
      #[doc = "Shows the `DID` associated to the `AccountId`, and a flag indicates if that DID has a"]
      #[doc = "valid CDD claim."]
      #[doc = "(Target DID, Target Account, a valid CDD claim exists)"]
      #[codec(index = 1u8)]
      CddStatus(Option<::polymesh_api_client::IdentityId>, AccountId, bool),
    }
    impl<AccountId> TestUtilsEvent<AccountId> {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::DidStatus(_, _) => "TestUtils.DidStatus",
          Self::CddStatus(_, _, _) => "TestUtils.CddStatus",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl<AccountId> ::polymesh_api_client::EnumInfo for TestUtilsEvent<AccountId> {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          Self::DidStatus(_, _) => &[
            "Emits the `IdentityId` and the `AccountId` of the caller.",
            "(Caller DID, Caller account)",
          ],
          Self::CddStatus(_, _, _) => &[
            "Shows the `DID` associated to the `AccountId`, and a flag indicates if that DID has a",
            "valid CDD claim.",
            "(Target DID, Target Account, a valid CDD claim exists)",
          ],
          _ => &[""],
        }
      }
    }
    impl<AccountId> From<TestUtilsEvent<AccountId>> for &'static str {
      fn from(v: TestUtilsEvent<AccountId>) -> Self {
        v.as_static_str()
      }
    }
    impl<AccountId> From<&TestUtilsEvent<AccountId>> for &'static str {
      fn from(v: &TestUtilsEvent<AccountId>) -> Self {
        v.as_static_str()
      }
    }
    #[doc = "Dispatchable calls."]
    #[doc = ""]
    #[doc = "Each variant of this enum maps to a dispatchable function from the associated module."]
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TestUtilsCall {
      #[doc = "Generates a new `IdentityID` for the caller, and issues a self-generated CDD claim."]
      #[doc = ""]
      #[doc = "The caller account will be the primary key of that identity."]
      #[doc = "For each account of `secondary_keys`, a new `JoinIdentity` authorization is created, so"]
      #[doc = "each of them will need to accept it before become part of this new `IdentityID`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AlreadyLinked` if the caller account or if any of the given `secondary_keys` has already linked to an `IdentityID`"]
      #[doc = "- `SecondaryKeysContainPrimaryKey` if `secondary_keys` contains the caller account."]
      #[doc = "- `DidAlreadyExists` if auto-generated DID already exists."]
      #[codec(index = 0u8)]
      register_did {
        secondary_keys: ::alloc::vec::Vec<
          polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
      },
      #[doc = "Registers a new Identity for the `target_account` and issues a CDD claim to it."]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be an active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[codec(index = 1u8)]
      mock_cdd_register_did {
        target_account: ::polymesh_api_client::AccountId,
      },
      #[doc = "Emits an event with caller's identity."]
      #[codec(index = 2u8)]
      get_my_did,
      #[doc = "Emits an event with caller's identity and CDD status."]
      #[codec(index = 3u8)]
      get_cdd_of {
        of: ::polymesh_api_client::AccountId,
      },
    }
    impl TestUtilsCall {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          Self::register_did { .. } => "TestUtils.register_did",
          Self::mock_cdd_register_did { .. } => "TestUtils.mock_cdd_register_did",
          Self::get_my_did => "TestUtils.get_my_did",
          Self::get_cdd_of { .. } => "TestUtils.get_cdd_of",
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for TestUtilsCall {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        # [allow (unreachable_patterns)] match self { Self :: register_did { .. } => { & ["Generates a new `IdentityID` for the caller, and issues a self-generated CDD claim." , "" , "The caller account will be the primary key of that identity." , "For each account of `secondary_keys`, a new `JoinIdentity` authorization is created, so" , "each of them will need to accept it before become part of this new `IdentityID`." , "" , "# Errors" , "- `AlreadyLinked` if the caller account or if any of the given `secondary_keys` has already linked to an `IdentityID`" , "- `SecondaryKeysContainPrimaryKey` if `secondary_keys` contains the caller account." , "- `DidAlreadyExists` if auto-generated DID already exists." ,] } , Self :: mock_cdd_register_did { .. } => { & ["Registers a new Identity for the `target_account` and issues a CDD claim to it." , "" , "# Failure" , "- `origin` has to be an active CDD provider. Inactive CDD providers cannot add new" , "claims." , "- `target_account` (primary key of the new Identity) can be linked to just one and only" , "one identity." ,] } , Self :: get_my_did => { & ["Emits an event with caller's identity." ,] } , Self :: get_cdd_of { .. } => { & ["Emits an event with caller's identity and CDD status." ,] } , _ => & [""] , }
      }
    }
    impl From<TestUtilsCall> for &'static str {
      fn from(v: TestUtilsCall) -> Self {
        v.as_static_str()
      }
    }
    impl From<&TestUtilsCall> for &'static str {
      fn from(v: &TestUtilsCall) -> Self {
        v.as_static_str()
      }
    }
    #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
    #[cfg_attr(
      all(feature = "std", feature = "type_info"),
      derive(::scale_info::TypeInfo)
    )]
    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
    pub enum TestUtilsError {}
    impl TestUtilsError {
      pub fn as_static_str(&self) -> &'static str {
        #[allow(unreachable_patterns)]
        match self {
          _ => "Unknown",
        }
      }
    }
    #[cfg(not(feature = "ink"))]
    impl ::polymesh_api_client::EnumInfo for TestUtilsError {
      fn as_name(&self) -> &'static str {
        self.as_static_str()
      }
      fn as_docs(&self) -> &'static [&'static str] {
        #[allow(unreachable_patterns)]
        match self {
          _ => &[""],
        }
      }
    }
    impl From<TestUtilsError> for &'static str {
      fn from(v: TestUtilsError) -> Self {
        v.as_static_str()
      }
    }
    impl From<&TestUtilsError> for &'static str {
      fn from(v: &TestUtilsError) -> Self {
        v.as_static_str()
      }
    }
  }
  pub mod polymesh_extensions {
    use super::*;
    pub mod check_weight {
      use super::*;
      #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
      #[cfg_attr(
        all(feature = "std", feature = "type_info"),
        derive(::scale_info::TypeInfo)
      )]
      #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
      pub struct CheckWeight(pub frame_system::extensions::check_weight::CheckWeight);
    }
  }
}
#[allow(dead_code, unused_imports, non_camel_case_types)]
pub mod api {
  use super::types;
  use super::types::*;
  use super::WrappedCall;
  pub mod system {
    use super::*;
    #[derive(Clone)]
    pub struct SystemCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> SystemCallApi<'api> {
      #[doc = "Make some on-chain remark."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`"]
      #[cfg(not(feature = "ink"))]
      pub fn remark(
        &self,
        remark: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::remark { remark },
        ))
      }
      #[doc = "Make some on-chain remark."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`"]
      #[cfg(feature = "ink")]
      pub fn remark(&self, remark: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 0u8];
        remark.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the number of pages in the WebAssembly environment's heap."]
      #[cfg(not(feature = "ink"))]
      pub fn set_heap_pages(
        &self,
        pages: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::set_heap_pages { pages },
        ))
      }
      #[doc = "Set the number of pages in the WebAssembly environment's heap."]
      #[cfg(feature = "ink")]
      pub fn set_heap_pages(&self, pages: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 1u8];
        pages.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the new runtime code."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"]
      #[cfg(not(feature = "ink"))]
      pub fn set_code(
        &self,
        code: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::set_code { code },
        ))
      }
      #[doc = "Set the new runtime code."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`"]
      #[cfg(feature = "ink")]
      pub fn set_code(&self, code: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 2u8];
        code.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the new runtime code without doing any checks of the given `code`."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(C)` where `C` length of `code`"]
      #[cfg(not(feature = "ink"))]
      pub fn set_code_without_checks(
        &self,
        code: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::set_code_without_checks { code },
        ))
      }
      #[doc = "Set the new runtime code without doing any checks of the given `code`."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(C)` where `C` length of `code`"]
      #[cfg(feature = "ink")]
      pub fn set_code_without_checks(
        &self,
        code: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 3u8];
        code.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set some items of storage."]
      #[cfg(not(feature = "ink"))]
      pub fn set_storage(
        &self,
        items: ::alloc::vec::Vec<(::alloc::vec::Vec<u8>, ::alloc::vec::Vec<u8>)>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::set_storage { items },
        ))
      }
      #[doc = "Set some items of storage."]
      #[cfg(feature = "ink")]
      pub fn set_storage(
        &self,
        items: ::alloc::vec::Vec<(::alloc::vec::Vec<u8>, ::alloc::vec::Vec<u8>)>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 4u8];
        items.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Kill some items from storage."]
      #[cfg(not(feature = "ink"))]
      pub fn kill_storage(
        &self,
        keys: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::kill_storage { keys },
        ))
      }
      #[doc = "Kill some items from storage."]
      #[cfg(feature = "ink")]
      pub fn kill_storage(
        &self,
        keys: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 5u8];
        keys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Kill all storage items with a key that starts with the given prefix."]
      #[doc = ""]
      #[doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"]
      #[doc = "the prefix we are removing to accurately calculate the weight of this function."]
      #[cfg(not(feature = "ink"))]
      pub fn kill_prefix(
        &self,
        prefix: ::alloc::vec::Vec<u8>,
        subkeys: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::kill_prefix { prefix, subkeys },
        ))
      }
      #[doc = "Kill all storage items with a key that starts with the given prefix."]
      #[doc = ""]
      #[doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"]
      #[doc = "the prefix we are removing to accurately calculate the weight of this function."]
      #[cfg(feature = "ink")]
      pub fn kill_prefix(
        &self,
        prefix: ::alloc::vec::Vec<u8>,
        subkeys: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 6u8];
        prefix.encode_to(&mut buf);
        subkeys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Make some on-chain remark and emit event."]
      #[cfg(not(feature = "ink"))]
      pub fn remark_with_event(
        &self,
        remark: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::System(
          types::frame_system::pallet::SystemCall::remark_with_event { remark },
        ))
      }
      #[doc = "Make some on-chain remark and emit event."]
      #[cfg(feature = "ink")]
      pub fn remark_with_event(&self, remark: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![0u8, 7u8];
        remark.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for SystemCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct SystemQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> SystemQueryApi<'api> {
      #[doc = " The full account information for a particular account ID."]
      #[cfg(not(feature = "ink"))]
      pub async fn account(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        types::frame_system::AccountInfo<
          u32,
          types::polymesh_common_utilities::traits::balances::AccountData,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8, 156u8, 12u8, 243u8, 14u8,
          136u8, 134u8, 55u8, 29u8, 169u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::frame_system::AccountInfo<
            u32,
            types::polymesh_common_utilities::traits::balances::AccountData,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The full account information for a particular account ID."]
      #[cfg(feature = "ink")]
      pub fn account(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        types::frame_system::AccountInfo<
          u32,
          types::polymesh_common_utilities::traits::balances::AccountData,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8, 156u8, 12u8, 243u8, 14u8,
          136u8, 134u8, 55u8, 29u8, 169u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::frame_system::AccountInfo<
            u32,
            types::polymesh_common_utilities::traits::balances::AccountData,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Total extrinsics count for the current block."]
      #[cfg(not(feature = "ink"))]
      pub async fn extrinsic_count(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 189u8, 192u8, 189u8, 48u8, 62u8, 152u8, 85u8, 129u8, 58u8, 168u8, 163u8,
          13u8, 78u8, 252u8, 81u8, 18u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Total extrinsics count for the current block."]
      #[cfg(feature = "ink")]
      pub fn extrinsic_count(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 189u8, 192u8, 189u8, 48u8, 62u8, 152u8, 85u8, 129u8, 58u8, 168u8, 163u8,
          13u8, 78u8, 252u8, 81u8, 18u8,
        ])?;
        Ok(value)
      }
      #[doc = " The current weight for the block."]
      #[cfg(not(feature = "ink"))]
      pub async fn block_weight(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::frame_support::dispatch::PerDispatchClass<::polymesh_api_client::sp_weights::Weight>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 52u8, 171u8, 245u8, 203u8, 52u8, 214u8, 36u8, 67u8, 120u8, 205u8, 219u8,
          241u8, 142u8, 132u8, 157u8, 150u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::frame_support::dispatch::PerDispatchClass<
            ::polymesh_api_client::sp_weights::Weight,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The current weight for the block."]
      #[cfg(feature = "ink")]
      pub fn block_weight(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::frame_support::dispatch::PerDispatchClass<::polymesh_api_client::sp_weights::Weight>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 52u8, 171u8, 245u8, 203u8, 52u8, 214u8, 36u8, 67u8, 120u8, 205u8, 219u8,
          241u8, 142u8, 132u8, 157u8, 150u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::frame_support::dispatch::PerDispatchClass<
            ::polymesh_api_client::sp_weights::Weight,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Total length (in bytes) for all extrinsics put together, for the current block."]
      #[cfg(not(feature = "ink"))]
      pub async fn all_extrinsics_len(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 168u8, 109u8, 165u8, 169u8, 50u8, 104u8, 79u8, 25u8, 149u8, 57u8, 131u8,
          111u8, 203u8, 140u8, 136u8, 111u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Total length (in bytes) for all extrinsics put together, for the current block."]
      #[cfg(feature = "ink")]
      pub fn all_extrinsics_len(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 168u8, 109u8, 165u8, 169u8, 50u8, 104u8, 79u8, 25u8, 149u8, 57u8, 131u8,
          111u8, 203u8, 140u8, 136u8, 111u8,
        ])?;
        Ok(value)
      }
      #[doc = " Map of block numbers to block hashes."]
      #[cfg(not(feature = "ink"))]
      pub async fn block_hash(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<types::primitive_types::H256> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 164u8, 71u8, 4u8, 181u8, 104u8, 210u8, 22u8, 103u8, 53u8, 106u8, 90u8, 5u8,
          12u8, 17u8, 135u8, 70u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Map of block numbers to block hashes."]
      #[cfg(feature = "ink")]
      pub fn block_hash(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<types::primitive_types::H256> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 164u8, 71u8, 4u8, 181u8, 104u8, 210u8, 22u8, 103u8, 53u8, 106u8, 90u8, 5u8,
          12u8, 17u8, 135u8, 70u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."]
      #[cfg(not(feature = "ink"))]
      pub async fn extrinsic_data(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 223u8, 29u8, 174u8, 184u8, 152u8, 104u8, 55u8, 242u8, 28u8, 197u8, 209u8,
          117u8, 150u8, 187u8, 120u8, 209u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."]
      #[cfg(feature = "ink")]
      pub fn extrinsic_data(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 223u8, 29u8, 174u8, 184u8, 152u8, 104u8, 55u8, 242u8, 28u8, 197u8, 209u8,
          117u8, 150u8, 187u8, 120u8, 209u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current block number being processed. Set by `execute_block`."]
      #[cfg(not(feature = "ink"))]
      pub async fn number(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 2u8, 165u8, 193u8, 177u8, 154u8, 183u8, 160u8, 79u8, 83u8, 108u8, 81u8,
          154u8, 202u8, 73u8, 131u8, 172u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current block number being processed. Set by `execute_block`."]
      #[cfg(feature = "ink")]
      pub fn number(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 2u8, 165u8, 193u8, 177u8, 154u8, 183u8, 160u8, 79u8, 83u8, 108u8, 81u8,
          154u8, 202u8, 73u8, 131u8, 172u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Hash of the previous block."]
      #[cfg(not(feature = "ink"))]
      pub async fn parent_hash(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::primitive_types::H256> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 138u8, 66u8, 243u8, 51u8, 35u8, 203u8, 92u8, 237u8, 59u8, 68u8, 221u8,
          130u8, 95u8, 218u8, 159u8, 204u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Hash of the previous block."]
      #[cfg(feature = "ink")]
      pub fn parent_hash(&self) -> ::polymesh_api_ink::error::Result<types::primitive_types::H256> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 138u8, 66u8, 243u8, 51u8, 35u8, 203u8, 92u8, 237u8, 59u8, 68u8, 221u8,
          130u8, 95u8, 218u8, 159u8, 204u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Digest of the current block, also part of the block header."]
      #[cfg(not(feature = "ink"))]
      pub async fn digest(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::sp_runtime::generic::digest::Digest> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 153u8, 231u8, 249u8, 63u8, 198u8, 169u8, 143u8, 8u8, 116u8, 253u8, 5u8,
          127u8, 17u8, 28u8, 77u8, 45u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::sp_runtime::generic::digest::Digest>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Digest of the current block, also part of the block header."]
      #[cfg(feature = "ink")]
      pub fn digest(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::sp_runtime::generic::digest::Digest> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 153u8, 231u8, 249u8, 63u8, 198u8, 169u8, 143u8, 8u8, 116u8, 253u8, 5u8,
          127u8, 17u8, 28u8, 77u8, 45u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::sp_runtime::generic::digest::Digest>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Events deposited for the current block."]
      #[doc = ""]
      #[doc = " NOTE: The item is unbound and should therefore never be read on chain."]
      #[doc = " It could otherwise inflate the PoV size of a block."]
      #[doc = ""]
      #[doc = " Events have a large in-memory size. Box the events to not go out-of-memory"]
      #[doc = " just in case someone still reads them from within the runtime."]
      #[cfg(not(feature = "ink"))]
      pub async fn events(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 128u8, 212u8, 30u8, 94u8, 22u8, 5u8, 103u8, 101u8, 188u8, 132u8, 97u8,
          133u8, 16u8, 114u8, 201u8, 215u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        ::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Events deposited for the current block."]
      #[doc = ""]
      #[doc = " NOTE: The item is unbound and should therefore never be read on chain."]
      #[doc = " It could otherwise inflate the PoV size of a block."]
      #[doc = ""]
      #[doc = " Events have a large in-memory size. Box the events to not go out-of-memory"]
      #[doc = " just in case someone still reads them from within the runtime."]
      #[cfg(feature = "ink")]
      pub fn events(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 128u8, 212u8, 30u8, 94u8, 22u8, 5u8, 103u8, 101u8, 188u8, 132u8, 97u8,
          133u8, 16u8, 114u8, 201u8, 215u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        ::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " The number of events in the `Events<T>` list."]
      #[cfg(not(feature = "ink"))]
      pub async fn event_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 10u8, 152u8, 253u8, 190u8, 156u8, 230u8, 197u8, 88u8, 55u8, 87u8, 108u8,
          96u8, 199u8, 175u8, 56u8, 80u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The number of events in the `Events<T>` list."]
      #[cfg(feature = "ink")]
      pub fn event_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 10u8, 152u8, 253u8, 190u8, 156u8, 230u8, 197u8, 88u8, 55u8, 87u8, 108u8,
          96u8, 199u8, 175u8, 56u8, 80u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"]
      #[doc = " of events in the `<Events<T>>` list."]
      #[doc = ""]
      #[doc = " All topic vectors have deterministic storage locations depending on the topic. This"]
      #[doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"]
      #[doc = " in case of changes fetch the list of events of interest."]
      #[doc = ""]
      #[doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"]
      #[doc = " the `EventIndex` then in case if the topic has the same contents on the next block"]
      #[doc = " no notification will be triggered thus the event might be lost."]
      #[cfg(not(feature = "ink"))]
      pub async fn event_topics(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<(u32, u32)>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 187u8, 148u8, 225u8, 194u8, 26u8, 218u8, 183u8, 20u8, 152u8, 60u8, 240u8,
          102u8, 34u8, 225u8, 222u8, 118u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"]
      #[doc = " of events in the `<Events<T>>` list."]
      #[doc = ""]
      #[doc = " All topic vectors have deterministic storage locations depending on the topic. This"]
      #[doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"]
      #[doc = " in case of changes fetch the list of events of interest."]
      #[doc = ""]
      #[doc = " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just"]
      #[doc = " the `EventIndex` then in case if the topic has the same contents on the next block"]
      #[doc = " no notification will be triggered thus the event might be lost."]
      #[cfg(feature = "ink")]
      pub fn event_topics(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<(u32, u32)>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 187u8, 148u8, 225u8, 194u8, 26u8, 218u8, 183u8, 20u8, 152u8, 60u8, 240u8,
          102u8, 34u8, 225u8, 222u8, 118u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."]
      #[cfg(not(feature = "ink"))]
      pub async fn last_runtime_upgrade(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<types::frame_system::LastRuntimeUpgradeInfo>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 249u8, 204u8, 233u8, 200u8, 136u8, 70u8, 155u8, 177u8, 160u8, 220u8, 234u8,
          161u8, 41u8, 103u8, 46u8, 248u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."]
      #[cfg(feature = "ink")]
      pub fn last_runtime_upgrade(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::frame_system::LastRuntimeUpgradeInfo>>
      {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 249u8, 204u8, 233u8, 200u8, 136u8, 70u8, 155u8, 177u8, 160u8, 220u8, 234u8,
          161u8, 41u8, 103u8, 46u8, 248u8,
        ])?;
        Ok(value)
      }
      #[doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."]
      #[cfg(not(feature = "ink"))]
      pub async fn upgraded_to_u32_ref_count(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 86u8, 132u8, 160u8, 34u8, 163u8, 77u8, 216u8, 191u8, 162u8, 186u8, 175u8,
          68u8, 241u8, 114u8, 183u8, 16u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."]
      #[cfg(feature = "ink")]
      pub fn upgraded_to_u32_ref_count(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 86u8, 132u8, 160u8, 34u8, 163u8, 77u8, 216u8, 191u8, 162u8, 186u8, 175u8,
          68u8, 241u8, 114u8, 183u8, 16u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"]
      #[doc = " (default) if not."]
      #[cfg(not(feature = "ink"))]
      pub async fn upgraded_to_triple_ref_count(
        &self,
      ) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 167u8, 253u8, 108u8, 40u8, 131u8, 107u8, 154u8, 40u8, 82u8, 45u8, 201u8,
          36u8, 17u8, 12u8, 244u8, 57u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"]
      #[doc = " (default) if not."]
      #[cfg(feature = "ink")]
      pub fn upgraded_to_triple_ref_count(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 167u8, 253u8, 108u8, 40u8, 131u8, 107u8, 154u8, 40u8, 82u8, 45u8, 201u8,
          36u8, 17u8, 12u8, 244u8, 57u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The execution phase of the block."]
      #[cfg(not(feature = "ink"))]
      pub async fn execution_phase(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<types::frame_system::Phase>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 255u8, 85u8, 59u8, 90u8, 152u8, 98u8, 165u8, 22u8, 147u8, 157u8, 130u8,
          179u8, 211u8, 216u8, 102u8, 26u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The execution phase of the block."]
      #[cfg(feature = "ink")]
      pub fn execution_phase(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::frame_system::Phase>> {
        let value = self.api.read_storage(::alloc::vec![
          38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8, 149u8, 88u8,
          206u8, 247u8, 255u8, 85u8, 59u8, 90u8, 152u8, 98u8, 165u8, 22u8, 147u8, 157u8, 130u8,
          179u8, 211u8, 216u8, 102u8, 26u8,
        ])?;
        Ok(value)
      }
    }
  }
  pub mod babe {
    use super::*;
    #[derive(Clone)]
    pub struct BabeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> BabeCallApi<'api> {
      #[doc = "Report authority equivocation/misbehavior. This method will verify"]
      #[doc = "the equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence will"]
      #[doc = "be reported."]
      #[cfg(not(feature = "ink"))]
      pub fn report_equivocation(
        &self,
        equivocation_proof: types::sp_consensus_slots::EquivocationProof<
          types::sp_runtime::generic::header::Header<u32, types::sp_runtime::traits::BlakeTwo256>,
          types::sp_consensus_babe::app::Public,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Babe(
          types::pallet_babe::pallet::BabeCall::report_equivocation {
            equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
            key_owner_proof,
          },
        ))
      }
      #[doc = "Report authority equivocation/misbehavior. This method will verify"]
      #[doc = "the equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence will"]
      #[doc = "be reported."]
      #[cfg(feature = "ink")]
      pub fn report_equivocation(
        &self,
        equivocation_proof: types::sp_consensus_slots::EquivocationProof<
          types::sp_runtime::generic::header::Header<u32, types::sp_runtime::traits::BlakeTwo256>,
          types::sp_consensus_babe::app::Public,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![1u8, 0u8];
        equivocation_proof.encode_to(&mut buf);
        key_owner_proof.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Report authority equivocation/misbehavior. This method will verify"]
      #[doc = "the equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence will"]
      #[doc = "be reported."]
      #[doc = "This extrinsic must be called unsigned and it is expected that only"]
      #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
      #[doc = "if the block author is defined it will be defined as the equivocation"]
      #[doc = "reporter."]
      #[cfg(not(feature = "ink"))]
      pub fn report_equivocation_unsigned(
        &self,
        equivocation_proof: types::sp_consensus_slots::EquivocationProof<
          types::sp_runtime::generic::header::Header<u32, types::sp_runtime::traits::BlakeTwo256>,
          types::sp_consensus_babe::app::Public,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Babe(
          types::pallet_babe::pallet::BabeCall::report_equivocation_unsigned {
            equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
            key_owner_proof,
          },
        ))
      }
      #[doc = "Report authority equivocation/misbehavior. This method will verify"]
      #[doc = "the equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence will"]
      #[doc = "be reported."]
      #[doc = "This extrinsic must be called unsigned and it is expected that only"]
      #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
      #[doc = "if the block author is defined it will be defined as the equivocation"]
      #[doc = "reporter."]
      #[cfg(feature = "ink")]
      pub fn report_equivocation_unsigned(
        &self,
        equivocation_proof: types::sp_consensus_slots::EquivocationProof<
          types::sp_runtime::generic::header::Header<u32, types::sp_runtime::traits::BlakeTwo256>,
          types::sp_consensus_babe::app::Public,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![1u8, 1u8];
        equivocation_proof.encode_to(&mut buf);
        key_owner_proof.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"]
      #[doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."]
      #[doc = "Multiple calls to this method will replace any existing planned config change that had"]
      #[doc = "not been enacted yet."]
      #[cfg(not(feature = "ink"))]
      pub fn plan_config_change(
        &self,
        config: types::sp_consensus_babe::digests::NextConfigDescriptor,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Babe(
          types::pallet_babe::pallet::BabeCall::plan_config_change { config },
        ))
      }
      #[doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"]
      #[doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."]
      #[doc = "Multiple calls to this method will replace any existing planned config change that had"]
      #[doc = "not been enacted yet."]
      #[cfg(feature = "ink")]
      pub fn plan_config_change(
        &self,
        config: types::sp_consensus_babe::digests::NextConfigDescriptor,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![1u8, 2u8];
        config.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for BabeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct BabeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> BabeQueryApi<'api> {
      #[doc = " Current epoch index."]
      #[cfg(not(feature = "ink"))]
      pub async fn epoch_index(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 56u8, 49u8, 108u8, 191u8, 143u8, 160u8, 218u8, 130u8, 42u8, 32u8,
          172u8, 28u8, 85u8, 191u8, 27u8, 227u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current epoch index."]
      #[cfg(feature = "ink")]
      pub fn epoch_index(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 56u8, 49u8, 108u8, 191u8, 143u8, 160u8, 218u8, 130u8, 42u8, 32u8,
          172u8, 28u8, 85u8, 191u8, 27u8, 227u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current epoch authorities."]
      #[cfg(not(feature = "ink"))]
      pub async fn authorities(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::bounded_collections::weak_bounded_vec::WeakBoundedVec<(
          types::sp_consensus_babe::app::Public,
          u64,
        )>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 94u8, 6u8, 33u8, 196u8, 134u8, 154u8, 166u8, 12u8, 2u8, 190u8, 154u8,
          220u8, 201u8, 138u8, 13u8, 29u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::weak_bounded_vec::WeakBoundedVec<(
            types::sp_consensus_babe::app::Public,
            u64,
          )>>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Current epoch authorities."]
      #[cfg(feature = "ink")]
      pub fn authorities(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::bounded_collections::weak_bounded_vec::WeakBoundedVec<(
          types::sp_consensus_babe::app::Public,
          u64,
        )>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 94u8, 6u8, 33u8, 196u8, 134u8, 154u8, 166u8, 12u8, 2u8, 190u8, 154u8,
          220u8, 201u8, 138u8, 13u8, 29u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::weak_bounded_vec::WeakBoundedVec<(
            types::sp_consensus_babe::app::Public,
            u64,
          )>>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The slot at which the first epoch actually started. This is 0"]
      #[doc = " until the first block of the chain."]
      #[cfg(not(feature = "ink"))]
      pub async fn genesis_slot(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::sp_consensus_slots::Slot> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 103u8, 135u8, 17u8, 209u8, 94u8, 187u8, 206u8, 186u8, 92u8, 208u8,
          206u8, 161u8, 88u8, 230u8, 103u8, 90u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The slot at which the first epoch actually started. This is 0"]
      #[doc = " until the first block of the chain."]
      #[cfg(feature = "ink")]
      pub fn genesis_slot(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::sp_consensus_slots::Slot> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 103u8, 135u8, 17u8, 209u8, 94u8, 187u8, 206u8, 186u8, 92u8, 208u8,
          206u8, 161u8, 88u8, 230u8, 103u8, 90u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current slot number."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_slot(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::sp_consensus_slots::Slot> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 6u8, 21u8, 91u8, 60u8, 217u8, 168u8, 201u8, 229u8, 233u8, 162u8, 63u8,
          213u8, 220u8, 19u8, 165u8, 237u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current slot number."]
      #[cfg(feature = "ink")]
      pub fn current_slot(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::sp_consensus_slots::Slot> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 6u8, 21u8, 91u8, 60u8, 217u8, 168u8, 201u8, 229u8, 233u8, 162u8, 63u8,
          213u8, 220u8, 19u8, 165u8, 237u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The epoch randomness for the *current* epoch."]
      #[doc = ""]
      #[doc = " # Security"]
      #[doc = ""]
      #[doc = " This MUST NOT be used for gambling, as it can be influenced by a"]
      #[doc = " malicious validator in the short term. It MAY be used in many"]
      #[doc = " cryptographic protocols, however, so long as one remembers that this"]
      #[doc = " (like everything else on-chain) it is public. For example, it can be"]
      #[doc = " used where a number is needed that cannot have been chosen by an"]
      #[doc = " adversary, for purposes such as public-coin zero-knowledge proofs."]
      #[cfg(not(feature = "ink"))]
      pub async fn randomness(&self) -> ::polymesh_api_client::error::Result<[u8; 32usize]> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 122u8, 65u8, 76u8, 176u8, 8u8, 224u8, 230u8, 30u8, 70u8, 114u8, 42u8,
          166u8, 10u8, 189u8, 214u8, 114u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The epoch randomness for the *current* epoch."]
      #[doc = ""]
      #[doc = " # Security"]
      #[doc = ""]
      #[doc = " This MUST NOT be used for gambling, as it can be influenced by a"]
      #[doc = " malicious validator in the short term. It MAY be used in many"]
      #[doc = " cryptographic protocols, however, so long as one remembers that this"]
      #[doc = " (like everything else on-chain) it is public. For example, it can be"]
      #[doc = " used where a number is needed that cannot have been chosen by an"]
      #[doc = " adversary, for purposes such as public-coin zero-knowledge proofs."]
      #[cfg(feature = "ink")]
      pub fn randomness(&self) -> ::polymesh_api_ink::error::Result<[u8; 32usize]> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 122u8, 65u8, 76u8, 176u8, 8u8, 224u8, 230u8, 30u8, 70u8, 114u8, 42u8,
          166u8, 10u8, 189u8, 214u8, 114u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Pending epoch configuration change that will be applied when the next epoch is enacted."]
      #[cfg(not(feature = "ink"))]
      pub async fn pending_epoch_config_change(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::sp_consensus_babe::digests::NextConfigDescriptor>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 139u8, 67u8, 40u8, 227u8, 67u8, 195u8, 224u8, 172u8, 144u8, 248u8,
          61u8, 164u8, 134u8, 12u8, 190u8, 54u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Pending epoch configuration change that will be applied when the next epoch is enacted."]
      #[cfg(feature = "ink")]
      pub fn pending_epoch_config_change(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::sp_consensus_babe::digests::NextConfigDescriptor>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 139u8, 67u8, 40u8, 227u8, 67u8, 195u8, 224u8, 172u8, 144u8, 248u8,
          61u8, 164u8, 134u8, 12u8, 190u8, 54u8,
        ])?;
        Ok(value)
      }
      #[doc = " Next epoch randomness."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_randomness(&self) -> ::polymesh_api_client::error::Result<[u8; 32usize]> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 124u8, 230u8, 120u8, 121u8, 157u8, 62u8, 255u8, 2u8, 66u8, 83u8,
          185u8, 14u8, 132u8, 146u8, 124u8, 198u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Next epoch randomness."]
      #[cfg(feature = "ink")]
      pub fn next_randomness(&self) -> ::polymesh_api_ink::error::Result<[u8; 32usize]> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 124u8, 230u8, 120u8, 121u8, 157u8, 62u8, 255u8, 2u8, 66u8, 83u8,
          185u8, 14u8, 132u8, 146u8, 124u8, 198u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Next epoch authorities."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_authorities(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::bounded_collections::weak_bounded_vec::WeakBoundedVec<(
          types::sp_consensus_babe::app::Public,
          u64,
        )>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 170u8, 207u8, 0u8, 185u8, 180u8, 31u8, 218u8, 122u8, 146u8, 104u8,
          130u8, 28u8, 42u8, 43u8, 62u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::weak_bounded_vec::WeakBoundedVec<(
            types::sp_consensus_babe::app::Public,
            u64,
          )>>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Next epoch authorities."]
      #[cfg(feature = "ink")]
      pub fn next_authorities(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::bounded_collections::weak_bounded_vec::WeakBoundedVec<(
          types::sp_consensus_babe::app::Public,
          u64,
        )>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 170u8, 207u8, 0u8, 185u8, 180u8, 31u8, 218u8, 122u8, 146u8, 104u8,
          130u8, 28u8, 42u8, 43u8, 62u8, 76u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::weak_bounded_vec::WeakBoundedVec<(
            types::sp_consensus_babe::app::Public,
            u64,
          )>>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Randomness under construction."]
      #[doc = ""]
      #[doc = " We make a trade-off between storage accesses and list length."]
      #[doc = " We store the under-construction randomness in segments of up to"]
      #[doc = " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`."]
      #[doc = ""]
      #[doc = " Once a segment reaches this length, we begin the next one."]
      #[doc = " We reset all segments and return to `0` at the beginning of every"]
      #[doc = " epoch."]
      #[cfg(not(feature = "ink"))]
      pub async fn segment_index(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 102u8, 232u8, 240u8, 53u8, 200u8, 173u8, 190u8, 127u8, 21u8, 71u8,
          180u8, 60u8, 81u8, 230u8, 248u8, 164u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Randomness under construction."]
      #[doc = ""]
      #[doc = " We make a trade-off between storage accesses and list length."]
      #[doc = " We store the under-construction randomness in segments of up to"]
      #[doc = " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`."]
      #[doc = ""]
      #[doc = " Once a segment reaches this length, we begin the next one."]
      #[doc = " We reset all segments and return to `0` at the beginning of every"]
      #[doc = " epoch."]
      #[cfg(feature = "ink")]
      pub fn segment_index(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 102u8, 232u8, 240u8, 53u8, 200u8, 173u8, 190u8, 127u8, 21u8, 71u8,
          180u8, 60u8, 81u8, 230u8, 248u8, 164u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."]
      #[cfg(not(feature = "ink"))]
      pub async fn under_construction(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<
        types::bounded_collections::bounded_vec::BoundedVec<[u8; 32usize]>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 185u8, 9u8, 54u8, 89u8, 215u8, 168u8, 86u8, 128u8, 151u8, 87u8, 19u8,
          77u8, 43u8, 200u8, 110u8, 98u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_vec::BoundedVec<[u8; 32usize]>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."]
      #[cfg(feature = "ink")]
      pub fn under_construction(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<
        types::bounded_collections::bounded_vec::BoundedVec<[u8; 32usize]>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 185u8, 9u8, 54u8, 89u8, 215u8, 168u8, 86u8, 128u8, 151u8, 87u8, 19u8,
          77u8, 43u8, 200u8, 110u8, 98u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_vec::BoundedVec<[u8; 32usize]>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Temporary value (cleared at block finalization) which is `Some`"]
      #[doc = " if per-block initialization has already been called for current block."]
      #[cfg(not(feature = "ink"))]
      pub async fn initialized(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<Option<types::sp_consensus_babe::digests::PreDigest>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 250u8, 146u8, 222u8, 145u8, 10u8, 124u8, 226u8, 189u8, 88u8, 233u8,
          151u8, 41u8, 198u8, 151u8, 39u8, 193u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Temporary value (cleared at block finalization) which is `Some`"]
      #[doc = " if per-block initialization has already been called for current block."]
      #[cfg(feature = "ink")]
      pub fn initialized(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<Option<types::sp_consensus_babe::digests::PreDigest>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 250u8, 146u8, 222u8, 145u8, 10u8, 124u8, 226u8, 189u8, 88u8, 233u8,
          151u8, 41u8, 198u8, 151u8, 39u8, 193u8,
        ])?;
        Ok(value)
      }
      #[doc = " This field should always be populated during block processing unless"]
      #[doc = " secondary plain slots are enabled (which don't contain a VRF output)."]
      #[doc = ""]
      #[doc = " It is set in `on_finalize`, before it will contain the value from the last block."]
      #[cfg(not(feature = "ink"))]
      pub async fn author_vrf_randomness(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<[u8; 32usize]>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 208u8, 119u8, 223u8, 219u8, 138u8, 219u8, 16u8, 247u8, 143u8, 16u8,
          165u8, 223u8, 135u8, 66u8, 197u8, 69u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <Option<[u8; 32usize]>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " This field should always be populated during block processing unless"]
      #[doc = " secondary plain slots are enabled (which don't contain a VRF output)."]
      #[doc = ""]
      #[doc = " It is set in `on_finalize`, before it will contain the value from the last block."]
      #[cfg(feature = "ink")]
      pub fn author_vrf_randomness(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<[u8; 32usize]>> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 208u8, 119u8, 223u8, 219u8, 138u8, 219u8, 16u8, 247u8, 143u8, 16u8,
          165u8, 223u8, 135u8, 66u8, 197u8, 69u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <Option<[u8; 32usize]>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The block numbers when the last and current epoch have started, respectively `N-1` and"]
      #[doc = " `N`."]
      #[doc = " NOTE: We track this is in order to annotate the block number when a given pool of"]
      #[doc = " entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in"]
      #[doc = " slots, which may be skipped, the block numbers may not line up with the slot numbers."]
      #[cfg(not(feature = "ink"))]
      pub async fn epoch_start(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 233u8, 14u8, 47u8, 191u8, 45u8, 121u8, 44u8, 179u8, 36u8, 191u8,
          250u8, 148u8, 39u8, 254u8, 31u8, 14u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The block numbers when the last and current epoch have started, respectively `N-1` and"]
      #[doc = " `N`."]
      #[doc = " NOTE: We track this is in order to annotate the block number when a given pool of"]
      #[doc = " entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in"]
      #[doc = " slots, which may be skipped, the block numbers may not line up with the slot numbers."]
      #[cfg(feature = "ink")]
      pub fn epoch_start(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 233u8, 14u8, 47u8, 191u8, 45u8, 121u8, 44u8, 179u8, 36u8, 191u8,
          250u8, 148u8, 39u8, 254u8, 31u8, 14u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How late the current block is compared to its parent."]
      #[doc = ""]
      #[doc = " This entry is populated as part of block execution and is cleaned up"]
      #[doc = " on block finalization. Querying this storage entry outside of block"]
      #[doc = " execution context should always yield zero."]
      #[cfg(not(feature = "ink"))]
      pub async fn lateness(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 3u8, 35u8, 71u8, 86u8, 87u8, 224u8, 137u8, 15u8, 189u8, 191u8, 102u8,
          251u8, 36u8, 180u8, 100u8, 158u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How late the current block is compared to its parent."]
      #[doc = ""]
      #[doc = " This entry is populated as part of block execution and is cleaned up"]
      #[doc = " on block finalization. Querying this storage entry outside of block"]
      #[doc = " execution context should always yield zero."]
      #[cfg(feature = "ink")]
      pub fn lateness(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 3u8, 35u8, 71u8, 86u8, 87u8, 224u8, 137u8, 15u8, 189u8, 191u8, 102u8,
          251u8, 36u8, 180u8, 100u8, 158u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The configuration for the current epoch. Should never be `None` as it is initialized in"]
      #[doc = " genesis."]
      #[cfg(not(feature = "ink"))]
      pub async fn epoch_config(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::sp_consensus_babe::BabeEpochConfiguration>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 220u8, 107u8, 23u8, 27u8, 119u8, 48u8, 66u8, 99u8, 194u8, 146u8,
          204u8, 62u8, 165u8, 237u8, 49u8, 239u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The configuration for the current epoch. Should never be `None` as it is initialized in"]
      #[doc = " genesis."]
      #[cfg(feature = "ink")]
      pub fn epoch_config(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::sp_consensus_babe::BabeEpochConfiguration>>
      {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 220u8, 107u8, 23u8, 27u8, 119u8, 48u8, 66u8, 99u8, 194u8, 146u8,
          204u8, 62u8, 165u8, 237u8, 49u8, 239u8,
        ])?;
        Ok(value)
      }
      #[doc = " The configuration for the next epoch, `None` if the config will not change"]
      #[doc = " (you can fallback to `EpochConfig` instead in that case)."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_epoch_config(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::sp_consensus_babe::BabeEpochConfiguration>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 154u8, 171u8, 10u8, 91u8, 99u8, 179u8, 89u8, 81u8, 45u8, 238u8, 229u8,
          87u8, 201u8, 244u8, 207u8, 99u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The configuration for the next epoch, `None` if the config will not change"]
      #[doc = " (you can fallback to `EpochConfig` instead in that case)."]
      #[cfg(feature = "ink")]
      pub fn next_epoch_config(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::sp_consensus_babe::BabeEpochConfiguration>>
      {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 154u8, 171u8, 10u8, 91u8, 99u8, 179u8, 89u8, 81u8, 45u8, 238u8, 229u8,
          87u8, 201u8, 244u8, 207u8, 99u8,
        ])?;
        Ok(value)
      }
      #[doc = " A list of the last 100 skipped epochs and the corresponding session index"]
      #[doc = " when the epoch was skipped."]
      #[doc = ""]
      #[doc = " This is only used for validating equivocation proofs. An equivocation proof"]
      #[doc = " must contains a key-ownership proof for a given session, therefore we need a"]
      #[doc = " way to tie together sessions and epoch indices, i.e. we need to validate that"]
      #[doc = " a validator was the owner of a given key on a given session, and what the"]
      #[doc = " active epoch index was during that session."]
      #[cfg(not(feature = "ink"))]
      pub async fn skipped_epochs(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::bounded_collections::bounded_vec::BoundedVec<(u64, u32)>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 55u8, 184u8, 132u8, 47u8, 84u8, 199u8, 237u8, 223u8, 2u8, 181u8,
          229u8, 132u8, 170u8, 42u8, 230u8, 204u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_vec::BoundedVec<(u64, u32)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " A list of the last 100 skipped epochs and the corresponding session index"]
      #[doc = " when the epoch was skipped."]
      #[doc = ""]
      #[doc = " This is only used for validating equivocation proofs. An equivocation proof"]
      #[doc = " must contains a key-ownership proof for a given session, therefore we need a"]
      #[doc = " way to tie together sessions and epoch indices, i.e. we need to validate that"]
      #[doc = " a validator was the owner of a given key on a given session, and what the"]
      #[doc = " active epoch index was during that session."]
      #[cfg(feature = "ink")]
      pub fn skipped_epochs(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::bounded_collections::bounded_vec::BoundedVec<(u64, u32)>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8, 10u8,
          181u8, 8u8, 127u8, 55u8, 184u8, 132u8, 47u8, 84u8, 199u8, 237u8, 223u8, 2u8, 181u8,
          229u8, 132u8, 170u8, 42u8, 230u8, 204u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_vec::BoundedVec<(u64, u32)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
    }
  }
  pub mod timestamp {
    use super::*;
    #[derive(Clone)]
    pub struct TimestampCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TimestampCallApi<'api> {
      #[doc = "Set the current time."]
      #[doc = ""]
      #[doc = "This call should be invoked exactly once per block. It will panic at the finalization"]
      #[doc = "phase, if this call hasn't been invoked by that time."]
      #[doc = ""]
      #[doc = "The timestamp should be greater than the previous one by the amount specified by"]
      #[doc = "`MinimumPeriod`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be `Inherent`."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"]
      #[doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"]
      #[doc = "  `on_finalize`)"]
      #[doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn set(
        &self,
        now: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Timestamp(
          types::pallet_timestamp::pallet::TimestampCall::set { now },
        ))
      }
      #[doc = "Set the current time."]
      #[doc = ""]
      #[doc = "This call should be invoked exactly once per block. It will panic at the finalization"]
      #[doc = "phase, if this call hasn't been invoked by that time."]
      #[doc = ""]
      #[doc = "The timestamp should be greater than the previous one by the amount specified by"]
      #[doc = "`MinimumPeriod`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be `Inherent`."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"]
      #[doc = "- 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in"]
      #[doc = "  `on_finalize`)"]
      #[doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn set(&self, now: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![2u8, 0u8];
        now.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for TimestampCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TimestampQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TimestampQueryApi<'api> {
      #[doc = " Current time for the current block."]
      #[cfg(not(feature = "ink"))]
      pub async fn now(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8, 14u8, 122u8,
          65u8, 19u8, 196u8, 159u8, 31u8, 5u8, 21u8, 244u8, 98u8, 205u8, 207u8, 132u8, 224u8,
          241u8, 214u8, 4u8, 93u8, 252u8, 187u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current time for the current block."]
      #[cfg(feature = "ink")]
      pub fn now(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8, 14u8, 122u8,
          65u8, 19u8, 196u8, 159u8, 31u8, 5u8, 21u8, 244u8, 98u8, 205u8, 207u8, 132u8, 224u8,
          241u8, 214u8, 4u8, 93u8, 252u8, 187u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Did the timestamp get updated in this block?"]
      #[cfg(not(feature = "ink"))]
      pub async fn did_update(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8, 14u8, 122u8,
          65u8, 19u8, 196u8, 187u8, 209u8, 8u8, 196u8, 137u8, 153u8, 100u8, 247u8, 7u8, 253u8,
          175u8, 251u8, 130u8, 99u8, 96u8, 101u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Did the timestamp get updated in this block?"]
      #[cfg(feature = "ink")]
      pub fn did_update(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8, 14u8, 122u8,
          65u8, 19u8, 196u8, 187u8, 209u8, 8u8, 196u8, 137u8, 153u8, 100u8, 247u8, 7u8, 253u8,
          175u8, 251u8, 130u8, 99u8, 96u8, 101u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod indices {
    use super::*;
    #[derive(Clone)]
    pub struct IndicesCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> IndicesCallApi<'api> {
      #[doc = "Assign an previously unassigned index."]
      #[doc = ""]
      #[doc = "Payment: `Deposit` is reserved from the sender account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be claimed. This must not be in use."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn claim(
        &self,
        index: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Indices(
          types::pallet_indices::pallet::IndicesCall::claim { index },
        ))
      }
      #[doc = "Assign an previously unassigned index."]
      #[doc = ""]
      #[doc = "Payment: `Deposit` is reserved from the sender account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be claimed. This must not be in use."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn claim(&self, index: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![3u8, 0u8];
        index.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Assign an index already owned by the sender to another account. The balance reservation"]
      #[doc = "is effectively transferred to the new account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be re-assigned. This must be owned by the sender."]
      #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn transfer(
        &self,
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        index: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Indices(
          types::pallet_indices::pallet::IndicesCall::transfer { new, index },
        ))
      }
      #[doc = "Assign an index already owned by the sender to another account. The balance reservation"]
      #[doc = "is effectively transferred to the new account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be re-assigned. This must be owned by the sender."]
      #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn transfer(
        &self,
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        index: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![3u8, 1u8];
        new.encode_to(&mut buf);
        index.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Free up an index owned by the sender."]
      #[doc = ""]
      #[doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."]
      #[doc = ""]
      #[doc = "- `index`: the index to be freed. This must be owned by the sender."]
      #[doc = ""]
      #[doc = "Emits `IndexFreed` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn free(
        &self,
        index: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Indices(
          types::pallet_indices::pallet::IndicesCall::free { index },
        ))
      }
      #[doc = "Free up an index owned by the sender."]
      #[doc = ""]
      #[doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."]
      #[doc = ""]
      #[doc = "- `index`: the index to be freed. This must be owned by the sender."]
      #[doc = ""]
      #[doc = "Emits `IndexFreed` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn free(&self, index: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![3u8, 2u8];
        index.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Force an index to an account. This doesn't require a deposit. If the index is already"]
      #[doc = "held, then any deposit is reimbursed to its current owner."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be (re-)assigned."]
      #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
      #[doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn force_transfer(
        &self,
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        index: u32,
        freeze: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Indices(
          types::pallet_indices::pallet::IndicesCall::force_transfer { new, index, freeze },
        ))
      }
      #[doc = "Force an index to an account. This doesn't require a deposit. If the index is already"]
      #[doc = "held, then any deposit is reimbursed to its current owner."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[doc = ""]
      #[doc = "- `index`: the index to be (re-)assigned."]
      #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
      #[doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."]
      #[doc = ""]
      #[doc = "Emits `IndexAssigned` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn force_transfer(
        &self,
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        index: u32,
        freeze: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![3u8, 3u8];
        new.encode_to(&mut buf);
        index.encode_to(&mut buf);
        freeze.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Freeze an index so it will always point to the sender account. This consumes the"]
      #[doc = "deposit."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
      #[doc = "non-frozen account `index`."]
      #[doc = ""]
      #[doc = "- `index`: the index to be frozen in place."]
      #[doc = ""]
      #[doc = "Emits `IndexFrozen` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(not(feature = "ink"))]
      pub fn freeze(
        &self,
        index: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Indices(
          types::pallet_indices::pallet::IndicesCall::freeze { index },
        ))
      }
      #[doc = "Freeze an index so it will always point to the sender account. This consumes the"]
      #[doc = "deposit."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
      #[doc = "non-frozen account `index`."]
      #[doc = ""]
      #[doc = "- `index`: the index to be frozen in place."]
      #[doc = ""]
      #[doc = "Emits `IndexFrozen` if successful."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`."]
      #[cfg(feature = "ink")]
      pub fn freeze(&self, index: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![3u8, 4u8];
        index.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for IndicesCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct IndicesQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> IndicesQueryApi<'api> {
      #[doc = " The lookup from index to account."]
      #[cfg(not(feature = "ink"))]
      pub async fn accounts(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<
        Option<(::polymesh_api_client::AccountId, u128, bool)>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          26u8, 115u8, 109u8, 55u8, 80u8, 76u8, 46u8, 63u8, 183u8, 61u8, 173u8, 22u8, 12u8, 85u8,
          178u8, 145u8, 142u8, 231u8, 65u8, 138u8, 101u8, 49u8, 23u8, 61u8, 96u8, 209u8, 246u8,
          168u8, 45u8, 143u8, 77u8, 81u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The lookup from index to account."]
      #[cfg(feature = "ink")]
      pub fn accounts(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<Option<(::polymesh_api_client::AccountId, u128, bool)>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          26u8, 115u8, 109u8, 55u8, 80u8, 76u8, 46u8, 63u8, 183u8, 61u8, 173u8, 22u8, 12u8, 85u8,
          178u8, 145u8, 142u8, 231u8, 65u8, 138u8, 101u8, 49u8, 23u8, 61u8, 96u8, 209u8, 246u8,
          168u8, 45u8, 143u8, 77u8, 81u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
  }
  pub mod authorship {
    use super::*;
    #[derive(Clone)]
    pub struct AuthorshipCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> AuthorshipCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for AuthorshipCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct AuthorshipQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> AuthorshipQueryApi<'api> {
      #[doc = " Author of current block."]
      #[cfg(not(feature = "ink"))]
      pub async fn author(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          213u8, 123u8, 206u8, 84u8, 95u8, 179u8, 130u8, 195u8, 69u8, 112u8, 229u8, 223u8, 191u8,
          51u8, 143u8, 94u8, 50u8, 109u8, 33u8, 188u8, 103u8, 164u8, 179u8, 64u8, 35u8, 213u8,
          119u8, 88u8, 93u8, 114u8, 191u8, 215u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Author of current block."]
      #[cfg(feature = "ink")]
      pub fn author(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        let value = self.api.read_storage(::alloc::vec![
          213u8, 123u8, 206u8, 84u8, 95u8, 179u8, 130u8, 195u8, 69u8, 112u8, 229u8, 223u8, 191u8,
          51u8, 143u8, 94u8, 50u8, 109u8, 33u8, 188u8, 103u8, 164u8, 179u8, 64u8, 35u8, 213u8,
          119u8, 88u8, 93u8, 114u8, 191u8, 215u8,
        ])?;
        Ok(value)
      }
    }
  }
  pub mod balances {
    use super::*;
    #[derive(Clone)]
    pub struct BalancesCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> BalancesCallApi<'api> {
      #[doc = "Transfer some liquid free balance to another account."]
      #[doc = ""]
      #[doc = "`transfer` will set the `FreeBalance` of the sender and receiver."]
      #[doc = "It will decrease the total issuance of the system by the `TransferFee`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Dependent on arguments but not critical, given proper implementations for"]
      #[doc = "  input config types. See related functions below."]
      #[doc = "- It contains a limited number of reads and writes internally and no complex computation."]
      #[doc = ""]
      #[doc = "Related functions:"]
      #[doc = ""]
      #[doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."]
      #[doc = "  - Transferring balances to accounts that did not exist before will cause"]
      #[doc = "     `T::OnNewAccount::on_new_account` to be called."]
      #[doc = "---------------------------------"]
      #[doc = "- Base Weight: 73.64 s, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn transfer(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::transfer { dest, value },
        ))
      }
      #[doc = "Transfer some liquid free balance to another account."]
      #[doc = ""]
      #[doc = "`transfer` will set the `FreeBalance` of the sender and receiver."]
      #[doc = "It will decrease the total issuance of the system by the `TransferFee`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Dependent on arguments but not critical, given proper implementations for"]
      #[doc = "  input config types. See related functions below."]
      #[doc = "- It contains a limited number of reads and writes internally and no complex computation."]
      #[doc = ""]
      #[doc = "Related functions:"]
      #[doc = ""]
      #[doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."]
      #[doc = "  - Transferring balances to accounts that did not exist before will cause"]
      #[doc = "     `T::OnNewAccount::on_new_account` to be called."]
      #[doc = "---------------------------------"]
      #[doc = "- Base Weight: 73.64 s, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn transfer(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 0u8];
        dest.encode_to(&mut buf);
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Transfer the native currency with the help of identifier string"]
      #[doc = "this functionality can help to differentiate the transfers."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Base Weight: 73.64 s, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn transfer_with_memo(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        memo: Option<types::polymesh_primitives::Memo>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::transfer_with_memo { dest, value, memo },
        ))
      }
      #[doc = "Transfer the native currency with the help of identifier string"]
      #[doc = "this functionality can help to differentiate the transfers."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Base Weight: 73.64 s, worst case scenario (account created, account removed)"]
      #[doc = "- DB Weight: 1 Read and 1 Write to destination account."]
      #[doc = "- Origin account is already in memory, so no DB operations for them."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn transfer_with_memo(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        memo: Option<types::polymesh_primitives::Memo>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 1u8];
        dest.encode_to(&mut buf);
        value.encode_to(&mut buf);
        memo.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Move some POLYX from balance of self to balance of BRR."]
      #[cfg(not(feature = "ink"))]
      pub fn deposit_block_reward_reserve_balance(
        &self,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::deposit_block_reward_reserve_balance { value },
        ))
      }
      #[doc = "Move some POLYX from balance of self to balance of BRR."]
      #[cfg(feature = "ink")]
      pub fn deposit_block_reward_reserve_balance(&self, value: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 2u8];
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the balances of a given account."]
      #[doc = ""]
      #[doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"]
      #[doc = "also decrease the total issuance of the system (`TotalIssuance`)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call is `root`."]
      #[cfg(not(feature = "ink"))]
      pub fn set_balance(
        &self,
        who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        new_free: u128,
        new_reserved: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::set_balance {
            who,
            new_free,
            new_reserved,
          },
        ))
      }
      #[doc = "Set the balances of a given account."]
      #[doc = ""]
      #[doc = "This will alter `FreeBalance` and `ReservedBalance` in storage. it will"]
      #[doc = "also decrease the total issuance of the system (`TotalIssuance`)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call is `root`."]
      #[cfg(feature = "ink")]
      pub fn set_balance(
        &self,
        who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        new_free: u128,
        new_reserved: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 3u8];
        who.encode_to(&mut buf);
        new_free.encode_to(&mut buf);
        new_reserved.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Exactly as `transfer`, except the origin must be root and the source account may be"]
      #[doc = "specified."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Same as transfer, but additional read and write because the source account is"]
      #[doc = "  not assumed to be in the overlay."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn force_transfer(
        &self,
        source: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::force_transfer {
            source,
            dest,
            value,
          },
        ))
      }
      #[doc = "Exactly as `transfer`, except the origin must be root and the source account may be"]
      #[doc = "specified."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Same as transfer, but additional read and write because the source account is"]
      #[doc = "  not assumed to be in the overlay."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn force_transfer(
        &self,
        source: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 4u8];
        source.encode_to(&mut buf);
        dest.encode_to(&mut buf);
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Burns the given amount of tokens from the caller's free, unlocked balance."]
      #[cfg(not(feature = "ink"))]
      pub fn burn_account_balance(
        &self,
        amount: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Balances(
          types::pallet_balances::BalancesCall::burn_account_balance { amount },
        ))
      }
      #[doc = "Burns the given amount of tokens from the caller's free, unlocked balance."]
      #[cfg(feature = "ink")]
      pub fn burn_account_balance(&self, amount: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![5u8, 5u8];
        amount.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for BalancesCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct BalancesQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> BalancesQueryApi<'api> {
      #[doc = " The total units issued in the system."]
      #[cfg(not(feature = "ink"))]
      pub async fn total_issuance(&self) -> ::polymesh_api_client::error::Result<u128> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8, 116u8,
          177u8, 92u8, 47u8, 87u8, 200u8, 117u8, 228u8, 207u8, 247u8, 65u8, 72u8, 228u8, 98u8,
          143u8, 38u8, 75u8, 151u8, 76u8, 128u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total units issued in the system."]
      #[cfg(feature = "ink")]
      pub fn total_issuance(&self) -> ::polymesh_api_ink::error::Result<u128> {
        let value = self.api.read_storage(::alloc::vec![
          194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8, 116u8,
          177u8, 92u8, 47u8, 87u8, 200u8, 117u8, 228u8, 207u8, 247u8, 65u8, 72u8, 228u8, 98u8,
          143u8, 38u8, 75u8, 151u8, 76u8, 128u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Any liquidity locks on some account balances."]
      #[doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."]
      #[cfg(not(feature = "ink"))]
      pub async fn locks(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::pallet_balances::BalanceLock<u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8, 116u8,
          177u8, 92u8, 47u8, 33u8, 143u8, 38u8, 199u8, 58u8, 221u8, 99u8, 72u8, 151u8, 85u8, 11u8,
          64u8, 3u8, 178u8, 107u8, 198u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_balances::BalanceLock<u128>>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Any liquidity locks on some account balances."]
      #[doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."]
      #[cfg(feature = "ink")]
      pub fn locks(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::pallet_balances::BalanceLock<u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8, 116u8,
          177u8, 92u8, 47u8, 33u8, 143u8, 38u8, 199u8, 58u8, 221u8, 99u8, 72u8, 151u8, 85u8, 11u8,
          64u8, 3u8, 178u8, 107u8, 198u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_balances::BalanceLock<u128>>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
    }
  }
  pub mod transaction_payment {
    use super::*;
    #[derive(Clone)]
    pub struct TransactionPaymentCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TransactionPaymentCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for TransactionPaymentCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TransactionPaymentQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TransactionPaymentQueryApi<'api> {
      #[cfg(not(feature = "ink"))]
      pub async fn next_fee_multiplier(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::sp_arithmetic::fixed_point::FixedU128>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8, 85u8,
          226u8, 8u8, 16u8, 63u8, 46u8, 223u8, 59u8, 223u8, 56u8, 29u8, 235u8, 227u8, 49u8, 171u8,
          116u8, 70u8, 173u8, 223u8, 220u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 100u8, 167u8, 179u8, 182u8, 224u8, 13u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8,
          ];
          <types::sp_arithmetic::fixed_point::FixedU128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(feature = "ink")]
      pub fn next_fee_multiplier(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::sp_arithmetic::fixed_point::FixedU128> {
        let value = self.api.read_storage(::alloc::vec![
          63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8, 85u8,
          226u8, 8u8, 16u8, 63u8, 46u8, 223u8, 59u8, 223u8, 56u8, 29u8, 235u8, 227u8, 49u8, 171u8,
          116u8, 70u8, 173u8, 223u8, 220u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 100u8, 167u8, 179u8, 182u8, 224u8, 13u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8,
          ];
          <types::sp_arithmetic::fixed_point::FixedU128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_transaction_payment::Releases> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8, 85u8,
          226u8, 8u8, 16u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_transaction_payment::Releases>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_transaction_payment::Releases> {
        let value = self.api.read_storage(::alloc::vec![
          63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8, 85u8,
          226u8, 8u8, 16u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_transaction_payment::Releases>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod identity {
    use super::*;
    #[derive(Clone)]
    pub struct IdentityCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> IdentityCallApi<'api> {
      #[doc = "Register `target_account` with a new Identity."]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[cfg(not(feature = "ink"))]
      pub fn cdd_register_did(
        &self,
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::cdd_register_did {
            target_account,
            secondary_keys,
          },
        ))
      }
      #[doc = "Register `target_account` with a new Identity."]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[cfg(feature = "ink")]
      pub fn cdd_register_did(
        &self,
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 0u8];
        target_account.encode_to(&mut buf);
        secondary_keys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Invalidates any claim generated by `cdd` from `disable_from` timestamps."]
      #[doc = ""]
      #[doc = "You can also define an expiration time,"]
      #[doc = "which will invalidate all claims generated by that `cdd` and remove it as CDD member group."]
      #[cfg(not(feature = "ink"))]
      pub fn invalidate_cdd_claims(
        &self,
        cdd: ::polymesh_api_client::IdentityId,
        disable_from: u64,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::invalidate_cdd_claims {
            cdd,
            disable_from,
            expiry,
          },
        ))
      }
      #[doc = "Invalidates any claim generated by `cdd` from `disable_from` timestamps."]
      #[doc = ""]
      #[doc = "You can also define an expiration time,"]
      #[doc = "which will invalidate all claims generated by that `cdd` and remove it as CDD member group."]
      #[cfg(feature = "ink")]
      pub fn invalidate_cdd_claims(
        &self,
        cdd: ::polymesh_api_client::IdentityId,
        disable_from: u64,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 1u8];
        cdd.encode_to(&mut buf);
        disable_from.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key"]
      #[doc = "instead of leaving it as a secondary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[cfg(not(feature = "ink"))]
      pub fn accept_primary_key(
        &self,
        rotation_auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::accept_primary_key {
            rotation_auth_id,
            optional_cdd_auth_id,
          },
        ))
      }
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key"]
      #[doc = "instead of leaving it as a secondary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[cfg(feature = "ink")]
      pub fn accept_primary_key(
        &self,
        rotation_auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 2u8];
        rotation_auth_id.encode_to(&mut buf);
        optional_cdd_auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set if CDD authorization is required for updating primary key of an identity."]
      #[doc = "Callable via root (governance)"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_required` CDD Authorization required or not"]
      #[cfg(not(feature = "ink"))]
      pub fn change_cdd_requirement_for_mk_rotation(
        &self,
        auth_required: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::change_cdd_requirement_for_mk_rotation {
            auth_required,
          },
        ))
      }
      #[doc = "Set if CDD authorization is required for updating primary key of an identity."]
      #[doc = "Callable via root (governance)"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_required` CDD Authorization required or not"]
      #[cfg(feature = "ink")]
      pub fn change_cdd_requirement_for_mk_rotation(
        &self,
        auth_required: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 3u8];
        auth_required.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Join an identity as a secondary key."]
      #[cfg(not(feature = "ink"))]
      pub fn join_identity_as_key(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::join_identity_as_key { auth_id },
        ))
      }
      #[doc = "Join an identity as a secondary key."]
      #[cfg(feature = "ink")]
      pub fn join_identity_as_key(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 4u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Leave the secondary key's identity."]
      #[cfg(not(feature = "ink"))]
      pub fn leave_identity_as_key(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::leave_identity_as_key,
        ))
      }
      #[doc = "Leave the secondary key's identity."]
      #[cfg(feature = "ink")]
      pub fn leave_identity_as_key(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![7u8, 5u8])
      }
      #[doc = "Adds a new claim record or edits an existing one."]
      #[doc = ""]
      #[doc = "Only called by did_issuer's secondary key."]
      #[cfg(not(feature = "ink"))]
      pub fn add_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim: types::polymesh_primitives::identity_claim::Claim,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::add_claim {
            target,
            claim,
            expiry,
          },
        ))
      }
      #[doc = "Adds a new claim record or edits an existing one."]
      #[doc = ""]
      #[doc = "Only called by did_issuer's secondary key."]
      #[cfg(feature = "ink")]
      pub fn add_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim: types::polymesh_primitives::identity_claim::Claim,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 6u8];
        target.encode_to(&mut buf);
        claim.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Marks the specified claim as revoked."]
      #[cfg(not(feature = "ink"))]
      pub fn revoke_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim: types::polymesh_primitives::identity_claim::Claim,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::revoke_claim { target, claim },
        ))
      }
      #[doc = "Marks the specified claim as revoked."]
      #[cfg(feature = "ink")]
      pub fn revoke_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim: types::polymesh_primitives::identity_claim::Claim,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 7u8];
        target.encode_to(&mut buf);
        claim.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "It disables all secondary keys at `did` identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub fn freeze_secondary_keys(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::freeze_secondary_keys,
        ))
      }
      #[doc = "It disables all secondary keys at `did` identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn freeze_secondary_keys(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![7u8, 8u8])
      }
      #[doc = "Re-enables all secondary keys of the caller's identity."]
      #[cfg(not(feature = "ink"))]
      pub fn unfreeze_secondary_keys(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::unfreeze_secondary_keys,
        ))
      }
      #[doc = "Re-enables all secondary keys of the caller's identity."]
      #[cfg(feature = "ink")]
      pub fn unfreeze_secondary_keys(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![7u8, 9u8])
      }
      #[doc = "Adds an authorization."]
      #[cfg(not(feature = "ink"))]
      pub fn add_authorization(
        &self,
        target: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        data: types::polymesh_primitives::authorization::AuthorizationData<
          ::polymesh_api_client::AccountId,
        >,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::add_authorization {
            target,
            data,
            expiry,
          },
        ))
      }
      #[doc = "Adds an authorization."]
      #[cfg(feature = "ink")]
      pub fn add_authorization(
        &self,
        target: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        data: types::polymesh_primitives::authorization::AuthorizationData<
          ::polymesh_api_client::AccountId,
        >,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 10u8];
        target.encode_to(&mut buf);
        data.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes an authorization."]
      #[doc = "_auth_issuer_pays determines whether the issuer of the authorisation pays the transaction fee"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_authorization(
        &self,
        target: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        auth_id: u64,
        _auth_issuer_pays: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::remove_authorization {
            target,
            auth_id,
            _auth_issuer_pays,
          },
        ))
      }
      #[doc = "Removes an authorization."]
      #[doc = "_auth_issuer_pays determines whether the issuer of the authorisation pays the transaction fee"]
      #[cfg(feature = "ink")]
      pub fn remove_authorization(
        &self,
        target: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        auth_id: u64,
        _auth_issuer_pays: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 11u8];
        target.encode_to(&mut buf);
        auth_id.encode_to(&mut buf);
        _auth_issuer_pays.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Assuming this is executed by the GC voting majority, adds a new cdd claim record."]
      #[cfg(not(feature = "ink"))]
      pub fn gc_add_cdd_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::gc_add_cdd_claim { target },
        ))
      }
      #[doc = "Assuming this is executed by the GC voting majority, adds a new cdd claim record."]
      #[cfg(feature = "ink")]
      pub fn gc_add_cdd_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 12u8];
        target.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Assuming this is executed by the GC voting majority, removes an existing cdd claim record."]
      #[cfg(not(feature = "ink"))]
      pub fn gc_revoke_cdd_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::gc_revoke_cdd_claim { target },
        ))
      }
      #[doc = "Assuming this is executed by the GC voting majority, removes an existing cdd claim record."]
      #[cfg(feature = "ink")]
      pub fn gc_revoke_cdd_claim(
        &self,
        target: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 13u8];
        target.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`,"]
      #[doc = "`claim_type`, and `scope`."]
      #[doc = ""]
      #[doc = "Please note that `origin` must be the issuer of the target claim."]
      #[cfg(not(feature = "ink"))]
      pub fn revoke_claim_by_index(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim_type: types::polymesh_primitives::identity_claim::ClaimType,
        scope: Option<types::polymesh_primitives::identity_claim::Scope>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::revoke_claim_by_index {
            target,
            claim_type,
            scope,
          },
        ))
      }
      #[doc = "Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`,"]
      #[doc = "`claim_type`, and `scope`."]
      #[doc = ""]
      #[doc = "Please note that `origin` must be the issuer of the target claim."]
      #[cfg(feature = "ink")]
      pub fn revoke_claim_by_index(
        &self,
        target: ::polymesh_api_client::IdentityId,
        claim_type: types::polymesh_primitives::identity_claim::ClaimType,
        scope: Option<types::polymesh_primitives::identity_claim::Scope>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 14u8];
        target.encode_to(&mut buf);
        claim_type.encode_to(&mut buf);
        scope.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change, (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from accept_primary_key in that it will leave the old primary key as a secondary"]
      #[doc = "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization"]
      #[doc = "instead of unlinking the old primary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[cfg(not(feature = "ink"))]
      pub fn rotate_primary_key_to_secondary(
        &self,
        auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::rotate_primary_key_to_secondary {
            auth_id,
            optional_cdd_auth_id,
          },
        ))
      }
      #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
      #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
      #[doc = "this change, (or this is not required), primary key of the DID is updated."]
      #[doc = ""]
      #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
      #[doc = "unlinked to any identity."]
      #[doc = ""]
      #[doc = "Differs from accept_primary_key in that it will leave the old primary key as a secondary"]
      #[doc = "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization"]
      #[doc = "instead of unlinking the old primary key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
      #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
      #[cfg(feature = "ink")]
      pub fn rotate_primary_key_to_secondary(
        &self,
        auth_id: u64,
        optional_cdd_auth_id: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 15u8];
        auth_id.encode_to(&mut buf);
        optional_cdd_auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds secondary keys to target identity `id`."]
      #[doc = ""]
      #[doc = "Keys are directly added to identity because each of them has an authorization."]
      #[doc = ""]
      #[doc = "# Arguments:"]
      #[doc = "    - `origin` which must be the primary key of the identity `id`."]
      #[doc = "    - `id` to which new secondary keys will be added."]
      #[doc = "    - `additional_keys` which includes secondary keys,"]
      #[doc = "       coupled with authorization data, to add to target identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "    - Can only called by primary key owner."]
      #[doc = "    - Keys should be able to linked to any identity."]
      #[cfg(not(feature = "ink"))]
      pub fn add_secondary_keys_with_authorization(
        &self,
        additional_keys: ::alloc::vec::Vec<
          types::polymesh_common_utilities::traits::identity::SecondaryKeyWithAuth<
            ::polymesh_api_client::AccountId,
          >,
        >,
        expires_at: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::add_secondary_keys_with_authorization {
            additional_keys,
            expires_at,
          },
        ))
      }
      #[doc = "Adds secondary keys to target identity `id`."]
      #[doc = ""]
      #[doc = "Keys are directly added to identity because each of them has an authorization."]
      #[doc = ""]
      #[doc = "# Arguments:"]
      #[doc = "    - `origin` which must be the primary key of the identity `id`."]
      #[doc = "    - `id` to which new secondary keys will be added."]
      #[doc = "    - `additional_keys` which includes secondary keys,"]
      #[doc = "       coupled with authorization data, to add to target identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "    - Can only called by primary key owner."]
      #[doc = "    - Keys should be able to linked to any identity."]
      #[cfg(feature = "ink")]
      pub fn add_secondary_keys_with_authorization(
        &self,
        additional_keys: ::alloc::vec::Vec<
          types::polymesh_common_utilities::traits::identity::SecondaryKeyWithAuth<
            ::polymesh_api_client::AccountId,
          >,
        >,
        expires_at: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 16u8];
        additional_keys.encode_to(&mut buf);
        expires_at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets permissions for an specific `target_key` key."]
      #[doc = ""]
      #[doc = "Only the primary key of an identity is able to set secondary key permissions."]
      #[cfg(not(feature = "ink"))]
      pub fn set_secondary_key_permissions(
        &self,
        key: ::polymesh_api_client::AccountId,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::set_secondary_key_permissions { key, perms },
        ))
      }
      #[doc = "Sets permissions for an specific `target_key` key."]
      #[doc = ""]
      #[doc = "Only the primary key of an identity is able to set secondary key permissions."]
      #[cfg(feature = "ink")]
      pub fn set_secondary_key_permissions(
        &self,
        key: ::polymesh_api_client::AccountId,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 17u8];
        key.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes specified secondary keys of a DID if present."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[doc = "The extrinsic can only called by primary key owner."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_secondary_keys(
        &self,
        keys_to_remove: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::remove_secondary_keys { keys_to_remove },
        ))
      }
      #[doc = "Removes specified secondary keys of a DID if present."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = ""]
      #[doc = "The extrinsic can only called by primary key owner."]
      #[cfg(feature = "ink")]
      pub fn remove_secondary_keys(
        &self,
        keys_to_remove: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 18u8];
        keys_to_remove.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Register custom claim type."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists."]
      #[doc = "* `CounterOverflow` CustomClaimTypeId has overflowed."]
      #[doc = "* `TooLong` The type being registered is too lang."]
      #[cfg(not(feature = "ink"))]
      pub fn register_custom_claim_type(
        &self,
        ty: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::register_custom_claim_type { ty },
        ))
      }
      #[doc = "Register custom claim type."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists."]
      #[doc = "* `CounterOverflow` CustomClaimTypeId has overflowed."]
      #[doc = "* `TooLong` The type being registered is too lang."]
      #[cfg(feature = "ink")]
      pub fn register_custom_claim_type(
        &self,
        ty: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 19u8];
        ty.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Register `target_account` with a new Identity and issue a CDD claim with a blank CddId"]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[cfg(not(feature = "ink"))]
      pub fn cdd_register_did_with_cdd(
        &self,
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::cdd_register_did_with_cdd {
            target_account,
            secondary_keys,
            expiry,
          },
        ))
      }
      #[doc = "Register `target_account` with a new Identity and issue a CDD claim with a blank CddId"]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[doc = "- External secondary keys can be linked to just one identity."]
      #[cfg(feature = "ink")]
      pub fn cdd_register_did_with_cdd(
        &self,
        target_account: ::polymesh_api_client::AccountId,
        secondary_keys: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 20u8];
        target_account.encode_to(&mut buf);
        secondary_keys.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Create a child identity and make the `secondary_key` it's primary key."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `secondary_key` the secondary key that will become the primary key of the new identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity."]
      #[doc = "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[cfg(not(feature = "ink"))]
      pub fn create_child_identity(
        &self,
        secondary_key: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::create_child_identity { secondary_key },
        ))
      }
      #[doc = "Create a child identity and make the `secondary_key` it's primary key."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `secondary_key` the secondary key that will become the primary key of the new identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity."]
      #[doc = "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[cfg(feature = "ink")]
      pub fn create_child_identity(
        &self,
        secondary_key: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 21u8];
        secondary_key.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Create a child identities."]
      #[doc = ""]
      #[doc = "The new primary key for each child identity will need to sign (off-chain)"]
      #[doc = "an authorization."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_keys` the keys that will become primary keys of their own child identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `AlreadyLinked` one of the keys is already linked to an identity."]
      #[doc = "- `DuplicateKey` one of the keys is included multiple times."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[cfg(not(feature = "ink"))]
      pub fn create_child_identities(
        &self,
        child_keys: ::alloc::vec::Vec<
          types::polymesh_common_utilities::traits::identity::CreateChildIdentityWithAuth<
            ::polymesh_api_client::AccountId,
          >,
        >,
        expires_at: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::create_child_identities {
            child_keys,
            expires_at,
          },
        ))
      }
      #[doc = "Create a child identities."]
      #[doc = ""]
      #[doc = "The new primary key for each child identity will need to sign (off-chain)"]
      #[doc = "an authorization."]
      #[doc = ""]
      #[doc = "Only the primary key can create child identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_keys` the keys that will become primary keys of their own child identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
      #[doc = "- `AlreadyLinked` one of the keys is already linked to an identity."]
      #[doc = "- `DuplicateKey` one of the keys is included multiple times."]
      #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
      #[cfg(feature = "ink")]
      pub fn create_child_identities(
        &self,
        child_keys: ::alloc::vec::Vec<
          types::polymesh_common_utilities::traits::identity::CreateChildIdentityWithAuth<
            ::polymesh_api_client::AccountId,
          >,
        >,
        expires_at: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 22u8];
        child_keys.encode_to(&mut buf);
        expires_at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Unlink a child identity from it's parent identity."]
      #[doc = ""]
      #[doc = "Only the primary key of the parent or child identities can unlink the identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_did` the child identity to unlink from its parent identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities."]
      #[doc = "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity."]
      #[doc = "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity."]
      #[cfg(not(feature = "ink"))]
      pub fn unlink_child_identity(
        &self,
        child_did: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Identity(
          types::pallet_identity::IdentityCall::unlink_child_identity { child_did },
        ))
      }
      #[doc = "Unlink a child identity from it's parent identity."]
      #[doc = ""]
      #[doc = "Only the primary key of the parent or child identities can unlink the identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `child_did` the child identity to unlink from its parent identity."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities."]
      #[doc = "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity."]
      #[doc = "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity."]
      #[cfg(feature = "ink")]
      pub fn unlink_child_identity(
        &self,
        child_did: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![7u8, 23u8];
        child_did.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for IdentityCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct IdentityQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> IdentityQueryApi<'api> {
      #[doc = " DID -> identity info"]
      #[cfg(not(feature = "ink"))]
      pub async fn did_records(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity::DidRecord<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 116u8, 80u8, 50u8, 71u8, 155u8, 166u8, 193u8, 20u8, 243u8, 13u8, 15u8,
          187u8, 81u8, 210u8, 17u8, 101u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " DID -> identity info"]
      #[cfg(feature = "ink")]
      pub fn did_records(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity::DidRecord<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 116u8, 80u8, 50u8, 71u8, 155u8, 166u8, 193u8, 20u8, 243u8, 13u8, 15u8,
          187u8, 81u8, 210u8, 17u8, 101u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " DID -> bool that indicates if secondary keys are frozen."]
      #[cfg(not(feature = "ink"))]
      pub async fn is_did_frozen(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 88u8, 25u8, 37u8, 70u8, 145u8, 206u8, 174u8, 76u8, 55u8, 194u8, 155u8,
          126u8, 165u8, 90u8, 158u8, 251u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " DID -> bool that indicates if secondary keys are frozen."]
      #[cfg(feature = "ink")]
      pub fn is_did_frozen(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 88u8, 25u8, 37u8, 70u8, 145u8, 206u8, 174u8, 76u8, 55u8, 194u8, 155u8,
          126u8, 165u8, 90u8, 158u8, 251u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " It stores the current identity for current transaction."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_did(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 88u8, 175u8, 95u8, 211u8, 111u8, 160u8, 107u8, 83u8, 194u8, 191u8,
          249u8, 86u8, 91u8, 169u8, 181u8, 252u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " It stores the current identity for current transaction."]
      #[cfg(feature = "ink")]
      pub fn current_did(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 88u8, 175u8, 95u8, 211u8, 111u8, 160u8, 107u8, 83u8, 194u8, 191u8,
          249u8, 86u8, 91u8, 169u8, 181u8, 252u8,
        ])?;
        Ok(value)
      }
      #[doc = " It stores the current gas fee payer for the current transaction"]
      #[cfg(not(feature = "ink"))]
      pub async fn current_payer(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 223u8, 12u8, 177u8, 135u8, 158u8, 14u8, 195u8, 122u8, 19u8, 92u8,
          166u8, 91u8, 51u8, 74u8, 253u8, 115u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " It stores the current gas fee payer for the current transaction"]
      #[cfg(feature = "ink")]
      pub fn current_payer(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 223u8, 12u8, 177u8, 135u8, 158u8, 14u8, 195u8, 122u8, 19u8, 92u8,
          166u8, 91u8, 51u8, 74u8, 253u8, 115u8,
        ])?;
        Ok(value)
      }
      #[doc = " (Target ID, claim type) (issuer,scope) -> Associated claims"]
      #[cfg(not(feature = "ink"))]
      pub async fn claims(
        &self,
        key_0: types::pallet_identity::types::Claim1stKey,
        key_1: types::pallet_identity::types::Claim2ndKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity_claim::IdentityClaim>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 156u8, 93u8, 121u8, 93u8, 2u8, 151u8, 190u8, 86u8, 2u8, 122u8, 75u8,
          36u8, 100u8, 227u8, 51u8, 151u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " (Target ID, claim type) (issuer,scope) -> Associated claims"]
      #[cfg(feature = "ink")]
      pub fn claims(
        &self,
        key_0: types::pallet_identity::types::Claim1stKey,
        key_1: types::pallet_identity::types::Claim2ndKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity_claim::IdentityClaim>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 156u8, 93u8, 121u8, 93u8, 2u8, 151u8, 190u8, 86u8, 2u8, 122u8, 75u8,
          36u8, 100u8, 227u8, 51u8, 151u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " CustomClaimTypeId -> String constant"]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_claims(
        &self,
        key_0: types::polymesh_primitives::identity_claim::CustomClaimTypeId,
      ) -> ::polymesh_api_client::error::Result<Option<::alloc::vec::Vec<u8>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 191u8, 149u8, 69u8, 57u8, 187u8, 49u8, 56u8, 118u8, 117u8, 181u8,
          215u8, 96u8, 18u8, 206u8, 94u8, 232u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " CustomClaimTypeId -> String constant"]
      #[cfg(feature = "ink")]
      pub fn custom_claims(
        &self,
        key_0: types::polymesh_primitives::identity_claim::CustomClaimTypeId,
      ) -> ::polymesh_api_ink::error::Result<Option<::alloc::vec::Vec<u8>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 191u8, 149u8, 69u8, 57u8, 187u8, 49u8, 56u8, 118u8, 117u8, 181u8,
          215u8, 96u8, 18u8, 206u8, 94u8, 232u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " String constant -> CustomClaimTypeId"]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_claims_inverse(
        &self,
        key_0: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity_claim::CustomClaimTypeId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 238u8, 140u8, 175u8, 222u8, 16u8, 43u8, 89u8, 2u8, 60u8, 101u8, 161u8,
          89u8, 63u8, 155u8, 89u8, 216u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " String constant -> CustomClaimTypeId"]
      #[cfg(feature = "ink")]
      pub fn custom_claims_inverse(
        &self,
        key_0: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity_claim::CustomClaimTypeId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 238u8, 140u8, 175u8, 222u8, 16u8, 43u8, 89u8, 2u8, 60u8, 101u8, 161u8,
          89u8, 63u8, 155u8, 89u8, 216u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The next `CustomClaimTypeId`."]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_claim_id_sequence(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::identity_claim::CustomClaimTypeId,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 216u8, 67u8, 38u8, 124u8, 109u8, 145u8, 9u8, 206u8, 14u8, 87u8, 168u8,
          35u8, 237u8, 61u8, 102u8, 0u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::identity_claim::CustomClaimTypeId>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The next `CustomClaimTypeId`."]
      #[cfg(feature = "ink")]
      pub fn custom_claim_id_sequence(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::identity_claim::CustomClaimTypeId,
      > {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 216u8, 67u8, 38u8, 124u8, 109u8, 145u8, 9u8, 206u8, 14u8, 87u8, 168u8,
          35u8, 237u8, 61u8, 102u8, 0u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::identity_claim::CustomClaimTypeId>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Map from AccountId to `KeyRecord` that holds the key's identity and permissions."]
      #[cfg(not(feature = "ink"))]
      pub async fn key_records(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::polymesh_primitives::secondary_key::KeyRecord<::polymesh_api_client::AccountId>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 140u8, 4u8, 71u8, 134u8, 27u8, 11u8, 130u8, 15u8, 11u8, 176u8, 222u8,
          164u8, 7u8, 164u8, 75u8, 52u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Map from AccountId to `KeyRecord` that holds the key's identity and permissions."]
      #[cfg(feature = "ink")]
      pub fn key_records(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::polymesh_primitives::secondary_key::KeyRecord<::polymesh_api_client::AccountId>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 140u8, 4u8, 71u8, 134u8, 27u8, 11u8, 130u8, 15u8, 11u8, 176u8, 222u8,
          164u8, 7u8, 164u8, 75u8, 52u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A reverse double map to allow finding all keys for an identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn did_keys(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 48u8, 201u8, 137u8, 112u8, 80u8, 239u8, 164u8, 12u8, 73u8, 173u8,
          249u8, 240u8, 185u8, 87u8, 20u8, 244u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A reverse double map to allow finding all keys for an identity."]
      #[cfg(feature = "ink")]
      pub fn did_keys(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 48u8, 201u8, 137u8, 112u8, 80u8, 239u8, 164u8, 12u8, 73u8, 173u8,
          249u8, 240u8, 185u8, 87u8, 20u8, 244u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Nonce to ensure unique actions. starts from 1."]
      #[cfg(not(feature = "ink"))]
      pub async fn multi_purpose_nonce(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 136u8, 63u8, 194u8, 107u8, 192u8, 198u8, 19u8, 83u8, 149u8, 2u8, 100u8,
          173u8, 112u8, 208u8, 112u8, 17u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Nonce to ensure unique actions. starts from 1."]
      #[cfg(feature = "ink")]
      pub fn multi_purpose_nonce(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 136u8, 63u8, 194u8, 107u8, 192u8, 198u8, 19u8, 83u8, 149u8, 2u8, 100u8,
          173u8, 112u8, 208u8, 112u8, 17u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Authorization nonce per Identity. Initially is 0."]
      #[cfg(not(feature = "ink"))]
      pub async fn off_chain_authorization_nonce(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 180u8, 43u8, 244u8, 108u8, 4u8, 166u8, 74u8, 143u8, 8u8, 226u8, 206u8,
          196u8, 229u8, 245u8, 62u8, 152u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Authorization nonce per Identity. Initially is 0."]
      #[cfg(feature = "ink")]
      pub fn off_chain_authorization_nonce(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 180u8, 43u8, 244u8, 108u8, 4u8, 166u8, 74u8, 143u8, 8u8, 226u8, 206u8,
          196u8, 229u8, 245u8, 62u8, 152u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All authorizations that an identity/key has"]
      #[cfg(not(feature = "ink"))]
      pub async fn authorizations(
        &self,
        key_0: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        key_1: u64,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::polymesh_primitives::authorization::Authorization<
            ::polymesh_api_client::AccountId,
            u64,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 104u8, 58u8, 80u8, 244u8, 170u8, 112u8, 186u8, 34u8, 193u8, 127u8,
          221u8, 184u8, 141u8, 38u8, 73u8, 43u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All authorizations that an identity/key has"]
      #[cfg(feature = "ink")]
      pub fn authorizations(
        &self,
        key_0: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
        key_1: u64,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::polymesh_primitives::authorization::Authorization<
            ::polymesh_api_client::AccountId,
            u64,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 104u8, 58u8, 80u8, 244u8, 170u8, 112u8, 186u8, 34u8, 193u8, 127u8,
          221u8, 184u8, 141u8, 38u8, 73u8, 43u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " All authorizations that an identity has given. (Authorizer, auth_id -> authorized)"]
      #[cfg(not(feature = "ink"))]
      pub async fn authorizations_given(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: u64,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 31u8, 154u8, 92u8, 218u8, 166u8, 154u8, 225u8, 139u8, 48u8, 60u8,
          199u8, 128u8, 85u8, 224u8, 137u8, 110u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::secondary_key::Signatory<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " All authorizations that an identity has given. (Authorizer, auth_id -> authorized)"]
      #[cfg(feature = "ink")]
      pub fn authorizations_given(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: u64,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 31u8, 154u8, 92u8, 218u8, 166u8, 154u8, 225u8, 139u8, 48u8, 60u8,
          199u8, 128u8, 85u8, 224u8, 137u8, 110u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::secondary_key::Signatory<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " A config flag that, if set, instructs an authorization from a CDD provider in order to"]
      #[doc = " change the primary key of an identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn cdd_auth_for_primary_key_rotation(
        &self,
      ) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 114u8, 149u8, 136u8, 2u8, 121u8, 4u8, 72u8, 56u8, 19u8, 118u8, 139u8,
          92u8, 202u8, 32u8, 42u8, 41u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A config flag that, if set, instructs an authorization from a CDD provider in order to"]
      #[doc = " change the primary key of an identity."]
      #[cfg(feature = "ink")]
      pub fn cdd_auth_for_primary_key_rotation(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 114u8, 149u8, 136u8, 2u8, 121u8, 4u8, 72u8, 56u8, 19u8, 118u8, 139u8,
          92u8, 202u8, 32u8, 42u8, 41u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_identity::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_identity::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_identity::Version> {
        let value = self.api.read_storage(::alloc::vec![
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_identity::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many \"strong\" references to the account key."]
      #[doc = ""]
      #[doc = " Strong references will block a key from leaving it's identity."]
      #[doc = ""]
      #[doc = " Pallets using \"strong\" references to account keys:"]
      #[doc = " * Relayer: For `user_key` and `paying_key`"]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub async fn account_key_ref_count(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 231u8, 18u8, 4u8, 202u8, 201u8, 201u8, 123u8, 37u8, 198u8, 89u8, 13u8,
          191u8, 196u8, 34u8, 200u8, 154u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many \"strong\" references to the account key."]
      #[doc = ""]
      #[doc = " Strong references will block a key from leaving it's identity."]
      #[doc = ""]
      #[doc = " Pallets using \"strong\" references to account keys:"]
      #[doc = " * Relayer: For `user_key` and `paying_key`"]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn account_key_ref_count(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 231u8, 18u8, 4u8, 202u8, 201u8, 201u8, 123u8, 37u8, 198u8, 89u8, 13u8,
          191u8, 196u8, 34u8, 200u8, 154u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Parent identity if the DID is a child Identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn parent_did(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 187u8, 179u8, 70u8, 131u8, 158u8, 200u8, 210u8, 30u8, 255u8, 150u8,
          252u8, 84u8, 192u8, 67u8, 126u8, 27u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Parent identity if the DID is a child Identity."]
      #[cfg(feature = "ink")]
      pub fn parent_did(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8, 185u8,
          8u8, 64u8, 249u8, 187u8, 179u8, 70u8, 131u8, 158u8, 200u8, 210u8, 30u8, 255u8, 150u8,
          252u8, 84u8, 192u8, 67u8, 126u8, 27u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
  }
  pub mod cdd_service_providers {
    use super::*;
    #[derive(Clone)]
    pub struct CddServiceProvidersCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CddServiceProvidersCallApi<'api> {
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_members_limit(
        &self,
        limit: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::set_active_members_limit { limit },
          ))
      }
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(feature = "ink")]
      pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 0u8];
        limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(not(feature = "ink"))]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::disable_member { who, expiry, at },
          ))
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(feature = "ink")]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 1u8];
        who.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(not(feature = "ink"))]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::add_member { who },
          ))
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(feature = "ink")]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 2u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::remove_member { who },
          ))
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(feature = "ink")]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 3u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(not(feature = "ink"))]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::swap_member { remove, add },
          ))
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(feature = "ink")]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 4u8];
        remove.encode_to(&mut buf);
        add.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(not(feature = "ink"))]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::reset_members { members },
          ))
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(feature = "ink")]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![8u8, 5u8];
        members.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(not(feature = "ink"))]
      pub fn abdicate_membership(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CddServiceProviders(
            types::pallet_group::UpgradeCommitteeMembershipCall::abdicate_membership,
          ))
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(feature = "ink")]
      pub fn abdicate_membership(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![8u8, 6u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for CddServiceProvidersCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CddServiceProvidersQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CddServiceProvidersQueryApi<'api> {
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8,
          159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn active_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8,
          159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn inactive_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_common_utilities::traits::group::InactiveMember<u64>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8,
          107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        types::polymesh_common_utilities::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn inactive_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_common_utilities::traits::group::InactiveMember<u64>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8,
          107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        types::polymesh_common_utilities::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8,
          7u8, 124u8, 249u8, 110u8, 183u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(feature = "ink")]
      pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          78u8, 20u8, 113u8, 165u8, 155u8, 49u8, 65u8, 197u8, 28u8, 64u8, 231u8, 183u8, 195u8,
          158u8, 46u8, 25u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8,
          7u8, 124u8, 249u8, 110u8, 183u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod polymesh_committee {
    use super::*;
    #[derive(Clone)]
    pub struct PolymeshCommitteeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PolymeshCommitteeCallApi<'api> {
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(not(feature = "ink"))]
      pub fn set_vote_threshold(
        &self,
        n: u32,
        d: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_vote_threshold { n, d },
        ))
      }
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(feature = "ink")]
      pub fn set_vote_threshold(&self, n: u32, d: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![9u8, 0u8];
        n.encode_to(&mut buf);
        d.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(not(feature = "ink"))]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_release_coordinator { id },
        ))
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(feature = "ink")]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![9u8, 1u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(not(feature = "ink"))]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_expires_after { expiry },
        ))
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(feature = "ink")]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![9u8, 2u8];
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote_or_propose {
            approve,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![9u8, 3u8];
        approve.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote {
            proposal,
            index,
            approve,
          },
        ))
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![9u8, 4u8];
        proposal.encode_to(&mut buf);
        index.encode_to(&mut buf);
        approve.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for PolymeshCommitteeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PolymeshCommitteeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PolymeshCommitteeQueryApi<'api> {
      #[doc = " The hashes of the active proposals."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposals(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The hashes of the active proposals."]
      #[cfg(feature = "ink")]
      pub fn proposals(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(feature = "ink")]
      pub fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(not(feature = "ink"))]
      pub async fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(feature = "ink")]
      pub fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Proposals so far."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals so far."]
      #[cfg(feature = "ink")]
      pub fn proposal_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(not(feature = "ink"))]
      pub async fn members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(feature = "ink")]
      pub fn members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(not(feature = "ink"))]
      pub async fn vote_threshold(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(feature = "ink")]
      pub fn vote_threshold(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Release coordinator."]
      #[cfg(not(feature = "ink"))]
      pub async fn release_coordinator(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Release coordinator."]
      #[cfg(feature = "ink")]
      pub fn release_coordinator(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ])?;
        Ok(value)
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(not(feature = "ink"))]
      pub async fn expires_after(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(feature = "ink")]
      pub fn expires_after(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_committee::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_committee::Version> {
        let value = self.api.read_storage(::alloc::vec![
          112u8, 60u8, 205u8, 82u8, 123u8, 235u8, 235u8, 221u8, 74u8, 251u8, 195u8, 174u8, 128u8,
          103u8, 49u8, 221u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod committee_membership {
    use super::*;
    #[derive(Clone)]
    pub struct CommitteeMembershipCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CommitteeMembershipCallApi<'api> {
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_members_limit(
        &self,
        limit: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::set_active_members_limit { limit },
          ))
      }
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(feature = "ink")]
      pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 0u8];
        limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(not(feature = "ink"))]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::disable_member { who, expiry, at },
          ))
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(feature = "ink")]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 1u8];
        who.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(not(feature = "ink"))]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::add_member { who },
          ))
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(feature = "ink")]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 2u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::remove_member { who },
          ))
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(feature = "ink")]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 3u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(not(feature = "ink"))]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::swap_member { remove, add },
          ))
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(feature = "ink")]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 4u8];
        remove.encode_to(&mut buf);
        add.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(not(feature = "ink"))]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::reset_members { members },
          ))
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(feature = "ink")]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![10u8, 5u8];
        members.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(not(feature = "ink"))]
      pub fn abdicate_membership(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::abdicate_membership,
          ))
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(feature = "ink")]
      pub fn abdicate_membership(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![10u8, 6u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for CommitteeMembershipCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CommitteeMembershipQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CommitteeMembershipQueryApi<'api> {
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8,
          159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn active_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8,
          159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn inactive_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_common_utilities::traits::group::InactiveMember<u64>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8,
          107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        types::polymesh_common_utilities::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn inactive_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_common_utilities::traits::group::InactiveMember<u64>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8,
          107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        types::polymesh_common_utilities::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8,
          7u8, 124u8, 249u8, 110u8, 183u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(feature = "ink")]
      pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          2u8, 22u8, 215u8, 223u8, 142u8, 27u8, 196u8, 187u8, 21u8, 159u8, 246u8, 26u8, 186u8,
          19u8, 204u8, 99u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8,
          7u8, 124u8, 249u8, 110u8, 183u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod technical_committee {
    use super::*;
    #[derive(Clone)]
    pub struct TechnicalCommitteeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TechnicalCommitteeCallApi<'api> {
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(not(feature = "ink"))]
      pub fn set_vote_threshold(
        &self,
        n: u32,
        d: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_vote_threshold { n, d },
        ))
      }
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(feature = "ink")]
      pub fn set_vote_threshold(&self, n: u32, d: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![11u8, 0u8];
        n.encode_to(&mut buf);
        d.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(not(feature = "ink"))]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_release_coordinator { id },
        ))
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(feature = "ink")]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![11u8, 1u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(not(feature = "ink"))]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_expires_after { expiry },
        ))
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(feature = "ink")]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![11u8, 2u8];
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote_or_propose {
            approve,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![11u8, 3u8];
        approve.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote {
            proposal,
            index,
            approve,
          },
        ))
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![11u8, 4u8];
        proposal.encode_to(&mut buf);
        index.encode_to(&mut buf);
        approve.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for TechnicalCommitteeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TechnicalCommitteeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TechnicalCommitteeQueryApi<'api> {
      #[doc = " The hashes of the active proposals."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposals(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The hashes of the active proposals."]
      #[cfg(feature = "ink")]
      pub fn proposals(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(feature = "ink")]
      pub fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(not(feature = "ink"))]
      pub async fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(feature = "ink")]
      pub fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Proposals so far."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals so far."]
      #[cfg(feature = "ink")]
      pub fn proposal_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(not(feature = "ink"))]
      pub async fn members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(feature = "ink")]
      pub fn members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(not(feature = "ink"))]
      pub async fn vote_threshold(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(feature = "ink")]
      pub fn vote_threshold(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Release coordinator."]
      #[cfg(not(feature = "ink"))]
      pub async fn release_coordinator(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Release coordinator."]
      #[cfg(feature = "ink")]
      pub fn release_coordinator(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ])?;
        Ok(value)
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(not(feature = "ink"))]
      pub async fn expires_after(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(feature = "ink")]
      pub fn expires_after(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_committee::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_committee::Version> {
        let value = self.api.read_storage(::alloc::vec![
          164u8, 212u8, 121u8, 249u8, 139u8, 115u8, 252u8, 118u8, 237u8, 236u8, 191u8, 162u8, 90u8,
          39u8, 91u8, 219u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod technical_committee_membership {
    use super::*;
    #[derive(Clone)]
    pub struct TechnicalCommitteeMembershipCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TechnicalCommitteeMembershipCallApi<'api> {
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_members_limit(
        &self,
        limit: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::set_active_members_limit { limit },
          ))
      }
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(feature = "ink")]
      pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 0u8];
        limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(not(feature = "ink"))]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::disable_member { who, expiry, at },
          ))
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(feature = "ink")]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 1u8];
        who.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(not(feature = "ink"))]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::add_member { who },
          ))
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(feature = "ink")]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 2u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::remove_member { who },
          ))
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(feature = "ink")]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 3u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(not(feature = "ink"))]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::swap_member { remove, add },
          ))
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(feature = "ink")]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 4u8];
        remove.encode_to(&mut buf);
        add.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(not(feature = "ink"))]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::reset_members { members },
          ))
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(feature = "ink")]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![12u8, 5u8];
        members.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(not(feature = "ink"))]
      pub fn abdicate_membership(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::abdicate_membership,
          ))
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(feature = "ink")]
      pub fn abdicate_membership(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![12u8, 6u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for TechnicalCommitteeMembershipCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TechnicalCommitteeMembershipQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TechnicalCommitteeMembershipQueryApi<'api> {
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8, 159u8,
          240u8, 162u8, 26u8, 38u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn active_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8, 159u8,
          240u8, 162u8, 26u8, 38u8, 76u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn inactive_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_common_utilities::traits::group::InactiveMember<u64>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8, 107u8, 3u8,
          94u8, 145u8, 7u8, 20u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        types::polymesh_common_utilities::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn inactive_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_common_utilities::traits::group::InactiveMember<u64>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8, 107u8, 3u8,
          94u8, 145u8, 7u8, 20u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        types::polymesh_common_utilities::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8, 7u8,
          124u8, 249u8, 110u8, 183u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(feature = "ink")]
      pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          196u8, 55u8, 227u8, 242u8, 203u8, 166u8, 23u8, 60u8, 167u8, 45u8, 15u8, 98u8, 8u8, 213u8,
          47u8, 136u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8, 7u8,
          124u8, 249u8, 110u8, 183u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod upgrade_committee {
    use super::*;
    #[derive(Clone)]
    pub struct UpgradeCommitteeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> UpgradeCommitteeCallApi<'api> {
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(not(feature = "ink"))]
      pub fn set_vote_threshold(
        &self,
        n: u32,
        d: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_vote_threshold { n, d },
        ))
      }
      #[doc = "Change the vote threshold the determines the winning proposal."]
      #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
      #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
      #[cfg(feature = "ink")]
      pub fn set_vote_threshold(&self, n: u32, d: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![13u8, 0u8];
        n.encode_to(&mut buf);
        d.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(not(feature = "ink"))]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_release_coordinator { id },
        ))
      }
      #[doc = "Changes the release coordinator."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The DID of the new release coordinator."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
      #[cfg(feature = "ink")]
      pub fn set_release_coordinator(
        &self,
        id: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![13u8, 1u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(not(feature = "ink"))]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
          types::pallet_committee::UpgradeCommitteeCall::set_expires_after { expiry },
        ))
      }
      #[doc = "Changes the time after which a proposal expires."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` - The new expiry time."]
      #[cfg(feature = "ink")]
      pub fn set_expires_after(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![13u8, 2u8];
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote_or_propose {
            approve,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Proposes to the committee that `call` should be executed in its name."]
      #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
      #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = ""]
      #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
      #[doc = "for recording the vote itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `approve` - is this an approving vote?"]
      #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
      #[doc = "* `call` - the call to propose for execution."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote_or_propose(
        &self,
        approve: bool,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![13u8, 3u8];
        approve.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(not(feature = "ink"))]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
          types::pallet_committee::UpgradeCommitteeCall::vote {
            proposal,
            index,
            approve,
          },
        ))
      }
      #[doc = "Votes `approve`ingly (or not, if `false`)"]
      #[doc = "on an existing `proposal` given by its hash, `index`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposal` - A hash of the proposal to be voted on."]
      #[doc = "* `index` - The proposal index."]
      #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
      #[cfg(feature = "ink")]
      pub fn vote(
        &self,
        proposal: types::primitive_types::H256,
        index: u32,
        approve: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![13u8, 4u8];
        proposal.encode_to(&mut buf);
        index.encode_to(&mut buf);
        approve.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for UpgradeCommitteeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct UpgradeCommitteeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> UpgradeCommitteeQueryApi<'api> {
      #[doc = " The hashes of the active proposals."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposals(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The hashes of the active proposals."]
      #[cfg(feature = "ink")]
      pub fn proposals(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Actual proposal for a given hash."]
      #[cfg(feature = "ink")]
      pub fn proposal_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8, 121u8, 147u8, 11u8,
          195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(not(feature = "ink"))]
      pub async fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[cfg(feature = "ink")]
      pub fn voting(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_committee::PolymeshVotes<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8, 251u8, 57u8, 43u8,
          121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Proposals so far."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals so far."]
      #[cfg(feature = "ink")]
      pub fn proposal_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8, 162u8, 166u8,
          43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(not(feature = "ink"))]
      pub async fn members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current members of the committee."]
      #[cfg(feature = "ink")]
      pub fn members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8, 226u8, 162u8,
          198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(not(feature = "ink"))]
      pub async fn vote_threshold(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Vote threshold for an approval."]
      #[cfg(feature = "ink")]
      pub fn vote_threshold(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8, 113u8, 204u8, 101u8,
          23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Release coordinator."]
      #[cfg(not(feature = "ink"))]
      pub async fn release_coordinator(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Release coordinator."]
      #[cfg(feature = "ink")]
      pub fn release_coordinator(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8, 153u8, 133u8,
          116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
        ])?;
        Ok(value)
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(not(feature = "ink"))]
      pub async fn expires_after(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Time after which a proposal will expire."]
      #[cfg(feature = "ink")]
      pub fn expires_after(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8, 113u8, 75u8,
          210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_committee::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_committee::Version> {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 155u8, 254u8, 225u8, 50u8, 205u8, 88u8, 23u8, 3u8, 164u8, 149u8, 57u8, 253u8,
          227u8, 45u8, 185u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_committee::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod upgrade_committee_membership {
    use super::*;
    #[derive(Clone)]
    pub struct UpgradeCommitteeMembershipCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> UpgradeCommitteeMembershipCallApi<'api> {
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_members_limit(
        &self,
        limit: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::set_active_members_limit { limit },
          ))
      }
      #[doc = "Change this group's limit for how many concurrent active members they may be."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` - the number of active members there may be concurrently."]
      #[cfg(feature = "ink")]
      pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 0u8];
        limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(not(feature = "ink"))]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::disable_member { who, expiry, at },
          ))
      }
      #[doc = "Disables a member at specific moment."]
      #[doc = ""]
      #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
      #[doc = "time-stamp will be updated."]
      #[doc = ""]
      #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
      #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
      #[doc = "generated claim issued before `at` would be considered as a valid one."]
      #[doc = ""]
      #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `at` - Revocation time-stamp."]
      #[doc = "* `who` - Target member of the group."]
      #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
      #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
      #[cfg(feature = "ink")]
      pub fn disable_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
        at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 1u8];
        who.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(not(feature = "ink"))]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::add_member { who },
          ))
      }
      #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
      #[doc = "* `who` - IdentityId to be added to the group."]
      #[cfg(feature = "ink")]
      pub fn add_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 2u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::remove_member { who },
          ))
      }
      #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
      #[doc = ""]
      #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
      #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
      #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
      #[doc = "claims, you have to use `Self::disable_member` function"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
      #[doc = "* `who` - IdentityId to be removed from the group."]
      #[cfg(feature = "ink")]
      pub fn remove_member(
        &self,
        who: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 3u8];
        who.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(not(feature = "ink"))]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::swap_member { remove, add },
          ))
      }
      #[doc = "Swaps out one member `remove` for another member `add`."]
      #[doc = ""]
      #[doc = "May only be called from `SwapOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
      #[doc = "* `remove` - IdentityId to be removed from the group."]
      #[doc = "* `add` - IdentityId to be added in place of `remove`."]
      #[cfg(feature = "ink")]
      pub fn swap_member(
        &self,
        remove: ::polymesh_api_client::IdentityId,
        add: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 4u8];
        remove.encode_to(&mut buf);
        add.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(not(feature = "ink"))]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::reset_members { members },
          ))
      }
      #[doc = "Changes the membership to a new set, disregarding the existing membership."]
      #[doc = "May only be called from `ResetOrigin` or root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
      #[doc = "* `members` - New set of identities"]
      #[cfg(feature = "ink")]
      pub fn reset_members(
        &self,
        members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![14u8, 5u8];
        members.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(not(feature = "ink"))]
      pub fn abdicate_membership(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
            types::pallet_group::UpgradeCommitteeMembershipCall::abdicate_membership,
          ))
      }
      #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
      #[doc = "vote."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - Member of committee who wants to quit."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = ""]
      #[doc = "* Only primary key can abdicate."]
      #[doc = "* Last member of a group cannot abdicate."]
      #[cfg(feature = "ink")]
      pub fn abdicate_membership(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![14u8, 6u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for UpgradeCommitteeMembershipCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct UpgradeCommitteeMembershipQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> UpgradeCommitteeMembershipQueryApi<'api> {
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8, 159u8,
          240u8, 162u8, 26u8, 38u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"active\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn active_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::IdentityId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8, 14u8, 159u8,
          240u8, 162u8, 26u8, 38u8, 76u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(not(feature = "ink"))]
      pub async fn inactive_members(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_common_utilities::traits::group::InactiveMember<u64>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8, 107u8,
          3u8, 94u8, 145u8, 7u8, 20u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        types::polymesh_common_utilities::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
      #[cfg(feature = "ink")]
      pub fn inactive_members(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_common_utilities::traits::group::InactiveMember<u64>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8, 34u8, 107u8,
          3u8, 94u8, 145u8, 7u8, 20u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                        types::polymesh_common_utilities::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8, 7u8,
          124u8, 249u8, 110u8, 183u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Limit of how many \"active\" members there can be."]
      #[cfg(feature = "ink")]
      pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          182u8, 126u8, 252u8, 69u8, 11u8, 212u8, 60u8, 43u8, 72u8, 78u8, 70u8, 113u8, 3u8, 206u8,
          131u8, 172u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8, 92u8, 160u8, 7u8,
          124u8, 249u8, 110u8, 183u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod multi_sig {
    use super::*;
    #[derive(Clone)]
    pub struct MultiSigCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> MultiSigCallApi<'api> {
      #[doc = "Creates a multisig"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)."]
      #[doc = "* `sigs_required` - Number of sigs required to process a multi-sig tx."]
      #[cfg(not(feature = "ink"))]
      pub fn create_multisig(
        &self,
        signers: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        >,
        sigs_required: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::create_multisig {
            signers,
            sigs_required,
          },
        ))
      }
      #[doc = "Creates a multisig"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)."]
      #[doc = "* `sigs_required` - Number of sigs required to process a multi-sig tx."]
      #[cfg(feature = "ink")]
      pub fn create_multisig(
        &self,
        signers: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        >,
        sigs_required: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 0u8];
        signers.encode_to(&mut buf);
        sigs_required.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Creates a multisig proposal if it hasn't been created or approves it if it has."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn create_or_approve_proposal_as_identity(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal: runtime::RuntimeCall,
        expiry: Option<u64>,
        auto_close: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::create_or_approve_proposal_as_identity {
            multisig,
            proposal: ::alloc::boxed::Box::new(proposal),
            expiry,
            auto_close,
          },
        ))
      }
      #[doc = "Creates a multisig proposal if it hasn't been created or approves it if it has."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn create_or_approve_proposal_as_identity(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal: runtime::RuntimeCall,
        expiry: Option<u64>,
        auto_close: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 1u8];
        multisig.encode_to(&mut buf);
        proposal.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        auto_close.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Creates a multisig proposal if it hasn't been created or approves it if it has."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn create_or_approve_proposal_as_key(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal: runtime::RuntimeCall,
        expiry: Option<u64>,
        auto_close: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::create_or_approve_proposal_as_key {
            multisig,
            proposal: ::alloc::boxed::Box::new(proposal),
            expiry,
            auto_close,
          },
        ))
      }
      #[doc = "Creates a multisig proposal if it hasn't been created or approves it if it has."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn create_or_approve_proposal_as_key(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal: runtime::RuntimeCall,
        expiry: Option<u64>,
        auto_close: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 2u8];
        multisig.encode_to(&mut buf);
        proposal.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        auto_close.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Creates a multisig proposal"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn create_proposal_as_identity(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal: runtime::RuntimeCall,
        expiry: Option<u64>,
        auto_close: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::create_proposal_as_identity {
            multisig,
            proposal: ::alloc::boxed::Box::new(proposal),
            expiry,
            auto_close,
          },
        ))
      }
      #[doc = "Creates a multisig proposal"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn create_proposal_as_identity(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal: runtime::RuntimeCall,
        expiry: Option<u64>,
        auto_close: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 3u8];
        multisig.encode_to(&mut buf);
        proposal.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        auto_close.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Creates a multisig proposal"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn create_proposal_as_key(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal: runtime::RuntimeCall,
        expiry: Option<u64>,
        auto_close: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::create_proposal_as_key {
            multisig,
            proposal: ::alloc::boxed::Box::new(proposal),
            expiry,
            auto_close,
          },
        ))
      }
      #[doc = "Creates a multisig proposal"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal` - Proposal to be voted on."]
      #[doc = "* `expiry` - Optional proposal expiry time."]
      #[doc = "* `auto_close` - Close proposal on receiving enough reject votes."]
      #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn create_proposal_as_key(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal: runtime::RuntimeCall,
        expiry: Option<u64>,
        auto_close: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 4u8];
        multisig.encode_to(&mut buf);
        proposal.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        auto_close.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Approves a multisig proposal using the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to approve."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn approve_as_identity(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::approve_as_identity {
            multisig,
            proposal_id,
          },
        ))
      }
      #[doc = "Approves a multisig proposal using the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to approve."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn approve_as_identity(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 5u8];
        multisig.encode_to(&mut buf);
        proposal_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Approves a multisig proposal using the caller's secondary key (`AccountId`)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to approve."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn approve_as_key(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::approve_as_key {
            multisig,
            proposal_id,
          },
        ))
      }
      #[doc = "Approves a multisig proposal using the caller's secondary key (`AccountId`)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to approve."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn approve_as_key(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 6u8];
        multisig.encode_to(&mut buf);
        proposal_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rejects a multisig proposal using the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to reject."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn reject_as_identity(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::reject_as_identity {
            multisig,
            proposal_id,
          },
        ))
      }
      #[doc = "Rejects a multisig proposal using the caller's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to reject."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn reject_as_identity(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 7u8];
        multisig.encode_to(&mut buf);
        proposal_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rejects a multisig proposal using the caller's secondary key (`AccountId`)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to reject."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(not(feature = "ink"))]
      pub fn reject_as_key(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::reject_as_key {
            multisig,
            proposal_id,
          },
        ))
      }
      #[doc = "Rejects a multisig proposal using the caller's secondary key (`AccountId`)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - MultiSig address."]
      #[doc = "* `proposal_id` - Proposal id to reject."]
      #[doc = "If quorum is reached, the proposal will be immediately executed."]
      #[cfg(feature = "ink")]
      pub fn reject_as_key(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 8u8];
        multisig.encode_to(&mut buf);
        proposal_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accepts a multisig signer authorization given to signer's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_id` - Auth id of the authorization."]
      #[cfg(not(feature = "ink"))]
      pub fn accept_multisig_signer_as_identity(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::accept_multisig_signer_as_identity { auth_id },
        ))
      }
      #[doc = "Accepts a multisig signer authorization given to signer's identity."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_id` - Auth id of the authorization."]
      #[cfg(feature = "ink")]
      pub fn accept_multisig_signer_as_identity(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 9u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accepts a multisig signer authorization given to signer's key (AccountId)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_id` - Auth id of the authorization."]
      #[cfg(not(feature = "ink"))]
      pub fn accept_multisig_signer_as_key(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::accept_multisig_signer_as_key { auth_id },
        ))
      }
      #[doc = "Accepts a multisig signer authorization given to signer's key (AccountId)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `auth_id` - Auth id of the authorization."]
      #[cfg(feature = "ink")]
      pub fn accept_multisig_signer_as_key(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 10u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a signer to the multisig. This must be called by the multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signer` - Signatory to add."]
      #[cfg(not(feature = "ink"))]
      pub fn add_multisig_signer(
        &self,
        signer: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::add_multisig_signer { signer },
        ))
      }
      #[doc = "Adds a signer to the multisig. This must be called by the multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signer` - Signatory to add."]
      #[cfg(feature = "ink")]
      pub fn add_multisig_signer(
        &self,
        signer: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 11u8];
        signer.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a signer from the multisig. This must be called by the multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signer` - Signatory to remove."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_multisig_signer(
        &self,
        signer: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::remove_multisig_signer { signer },
        ))
      }
      #[doc = "Removes a signer from the multisig. This must be called by the multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `signer` - Signatory to remove."]
      #[cfg(feature = "ink")]
      pub fn remove_multisig_signer(
        &self,
        signer: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 12u8];
        signer.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a signer to the multisig. This must be called by the creator identity of the"]
      #[doc = "multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - Address of the multi sig"]
      #[doc = "* `signers` - Signatories to add."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`900_000_000 + 3_000_000 * signers.len()`"]
      #[cfg(not(feature = "ink"))]
      pub fn add_multisig_signers_via_creator(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        signers: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::add_multisig_signers_via_creator {
            multisig,
            signers,
          },
        ))
      }
      #[doc = "Adds a signer to the multisig. This must be called by the creator identity of the"]
      #[doc = "multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - Address of the multi sig"]
      #[doc = "* `signers` - Signatories to add."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`900_000_000 + 3_000_000 * signers.len()`"]
      #[cfg(feature = "ink")]
      pub fn add_multisig_signers_via_creator(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        signers: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 13u8];
        multisig.encode_to(&mut buf);
        signers.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a signer from the multisig."]
      #[doc = "This must be called by the creator identity of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - Address of the multisig."]
      #[doc = "* `signers` - Signatories to remove."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`900_000_000 + 3_000_000 * signers.len()`"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_multisig_signers_via_creator(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        signers: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::remove_multisig_signers_via_creator {
            multisig,
            signers,
          },
        ))
      }
      #[doc = "Removes a signer from the multisig."]
      #[doc = "This must be called by the creator identity of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - Address of the multisig."]
      #[doc = "* `signers` - Signatories to remove."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`900_000_000 + 3_000_000 * signers.len()`"]
      #[cfg(feature = "ink")]
      pub fn remove_multisig_signers_via_creator(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        signers: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 14u8];
        multisig.encode_to(&mut buf);
        signers.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the number of signatures required by a multisig. This must be called by the"]
      #[doc = "multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `sigs_required` - New number of required signatures."]
      #[cfg(not(feature = "ink"))]
      pub fn change_sigs_required(
        &self,
        sigs_required: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::change_sigs_required { sigs_required },
        ))
      }
      #[doc = "Changes the number of signatures required by a multisig. This must be called by the"]
      #[doc = "multisig itself."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `sigs_required` - New number of required signatures."]
      #[cfg(feature = "ink")]
      pub fn change_sigs_required(&self, sigs_required: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 15u8];
        sigs_required.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a multisig as a secondary key of current did if the current did is the creator of the"]
      #[doc = "multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - multi sig address"]
      #[cfg(not(feature = "ink"))]
      pub fn make_multisig_secondary(
        &self,
        multisig: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::make_multisig_secondary { multisig },
        ))
      }
      #[doc = "Adds a multisig as a secondary key of current did if the current did is the creator of the"]
      #[doc = "multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig` - multi sig address"]
      #[cfg(feature = "ink")]
      pub fn make_multisig_secondary(
        &self,
        multisig: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 16u8];
        multisig.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a multisig as the primary key of the current did if the current DID is the creator"]
      #[doc = "of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multi_sig` - multi sig address"]
      #[cfg(not(feature = "ink"))]
      pub fn make_multisig_primary(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        optional_cdd_auth_id: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::make_multisig_primary {
            multisig,
            optional_cdd_auth_id,
          },
        ))
      }
      #[doc = "Adds a multisig as the primary key of the current did if the current DID is the creator"]
      #[doc = "of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multi_sig` - multi sig address"]
      #[cfg(feature = "ink")]
      pub fn make_multisig_primary(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        optional_cdd_auth_id: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 17u8];
        multisig.encode_to(&mut buf);
        optional_cdd_auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Root callable extrinsic, used as an internal call for executing scheduled multisig proposal."]
      #[cfg(not(feature = "ink"))]
      pub fn execute_scheduled_proposal(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
        multisig_did: ::polymesh_api_client::IdentityId,
        _proposal_weight: ::polymesh_api_client::sp_weights::Weight,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::execute_scheduled_proposal {
            multisig,
            proposal_id,
            multisig_did,
            _proposal_weight,
          },
        ))
      }
      #[doc = "Root callable extrinsic, used as an internal call for executing scheduled multisig proposal."]
      #[cfg(feature = "ink")]
      pub fn execute_scheduled_proposal(
        &self,
        multisig: ::polymesh_api_client::AccountId,
        proposal_id: u64,
        multisig_did: ::polymesh_api_client::IdentityId,
        _proposal_weight: ::polymesh_api_client::sp_weights::Weight,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 18u8];
        multisig.encode_to(&mut buf);
        proposal_id.encode_to(&mut buf);
        multisig_did.encode_to(&mut buf);
        _proposal_weight.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the number of signatures required by a multisig. This must be called by the creator of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig_account` - The account identifier ([`AccountId`]) for the multi signature account."]
      #[doc = "* `signatures_required` - The number of required signatures."]
      #[cfg(not(feature = "ink"))]
      pub fn change_sigs_required_via_creator(
        &self,
        multisig_account: ::polymesh_api_client::AccountId,
        signatures_required: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::change_sigs_required_via_creator {
            multisig_account,
            signatures_required,
          },
        ))
      }
      #[doc = "Changes the number of signatures required by a multisig. This must be called by the creator of the multisig."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `multisig_account` - The account identifier ([`AccountId`]) for the multi signature account."]
      #[doc = "* `signatures_required` - The number of required signatures."]
      #[cfg(feature = "ink")]
      pub fn change_sigs_required_via_creator(
        &self,
        multisig_account: ::polymesh_api_client::AccountId,
        signatures_required: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 19u8];
        multisig_account.encode_to(&mut buf);
        signatures_required.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the creator ability to call `add_multisig_signers_via_creator`, `remove_multisig_signers_via_creator`"]
      #[doc = "and `change_sigs_required_via_creator`."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_creator_controls(
        &self,
        multisig_account: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::MultiSig(
          types::pallet_multisig::MultiSigCall::remove_creator_controls { multisig_account },
        ))
      }
      #[doc = "Removes the creator ability to call `add_multisig_signers_via_creator`, `remove_multisig_signers_via_creator`"]
      #[doc = "and `change_sigs_required_via_creator`."]
      #[cfg(feature = "ink")]
      pub fn remove_creator_controls(
        &self,
        multisig_account: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![15u8, 20u8];
        multisig_account.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for MultiSigCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct MultiSigQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> MultiSigQueryApi<'api> {
      #[doc = " Nonce to ensure unique MultiSig addresses are generated; starts from 1."]
      #[cfg(not(feature = "ink"))]
      pub async fn multi_sig_nonce(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 10u8, 14u8, 167u8, 96u8, 87u8, 167u8, 154u8, 118u8, 104u8, 172u8,
          98u8, 216u8, 200u8, 251u8, 224u8, 34u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Nonce to ensure unique MultiSig addresses are generated; starts from 1."]
      #[cfg(feature = "ink")]
      pub fn multi_sig_nonce(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 10u8, 14u8, 167u8, 96u8, 87u8, 167u8, 154u8, 118u8, 104u8, 172u8,
          98u8, 216u8, 200u8, 251u8, 224u8, 34u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Signers of a multisig. (multisig, signer) => bool."]
      #[cfg(not(feature = "ink"))]
      pub async fn multi_sig_signers(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 87u8, 55u8, 48u8, 162u8, 27u8, 187u8, 140u8, 140u8, 243u8, 200u8,
          51u8, 112u8, 105u8, 135u8, 190u8, 191u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Signers of a multisig. (multisig, signer) => bool."]
      #[cfg(feature = "ink")]
      pub fn multi_sig_signers(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: types::polymesh_primitives::secondary_key::Signatory<
          ::polymesh_api_client::AccountId,
        >,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 87u8, 55u8, 48u8, 162u8, 27u8, 187u8, 140u8, 140u8, 243u8, 200u8,
          51u8, 112u8, 105u8, 135u8, 190u8, 191u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of approved/accepted signers of a multisig."]
      #[cfg(not(feature = "ink"))]
      pub async fn number_of_signers(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 71u8, 130u8, 22u8, 60u8, 187u8, 185u8, 53u8, 64u8, 248u8, 2u8, 20u8,
          216u8, 127u8, 68u8, 253u8, 226u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of approved/accepted signers of a multisig."]
      #[cfg(feature = "ink")]
      pub fn number_of_signers(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 71u8, 130u8, 22u8, 60u8, 187u8, 185u8, 53u8, 64u8, 248u8, 2u8, 20u8,
          216u8, 127u8, 68u8, 253u8, 226u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Confirmations required before processing a multisig tx."]
      #[cfg(not(feature = "ink"))]
      pub async fn multi_sig_signs_required(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 186u8, 252u8, 143u8, 56u8, 160u8, 191u8, 27u8, 28u8, 14u8, 157u8,
          223u8, 36u8, 138u8, 28u8, 207u8, 150u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Confirmations required before processing a multisig tx."]
      #[cfg(feature = "ink")]
      pub fn multi_sig_signs_required(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 186u8, 252u8, 143u8, 56u8, 160u8, 191u8, 27u8, 28u8, 14u8, 157u8,
          223u8, 36u8, 138u8, 28u8, 207u8, 150u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of transactions proposed in a multisig. Used as tx id; starts from 0."]
      #[cfg(not(feature = "ink"))]
      pub async fn multi_sig_tx_done(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 79u8, 31u8, 81u8, 244u8, 28u8, 45u8, 127u8, 189u8, 55u8, 203u8, 110u8,
          144u8, 201u8, 64u8, 76u8, 148u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of transactions proposed in a multisig. Used as tx id; starts from 0."]
      #[cfg(feature = "ink")]
      pub fn multi_sig_tx_done(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 79u8, 31u8, 81u8, 244u8, 28u8, 45u8, 127u8, 189u8, 55u8, 203u8, 110u8,
          144u8, 201u8, 64u8, 76u8, 148u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals presented for voting to a multisig (multisig, proposal id) => Option<T::Proposal>."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposals(
        &self,
        key_0: (::polymesh_api_client::AccountId, u64),
      ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Proposals presented for voting to a multisig (multisig, proposal id) => Option<T::Proposal>."]
      #[cfg(feature = "ink")]
      pub fn proposals(
        &self,
        key_0: (::polymesh_api_client::AccountId, u64),
      ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A mapping of proposals to their IDs."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_ids(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<Option<u64>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 149u8, 230u8, 68u8, 209u8, 93u8, 43u8, 168u8, 123u8, 142u8, 97u8,
          255u8, 121u8, 47u8, 101u8, 10u8, 146u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A mapping of proposals to their IDs."]
      #[cfg(feature = "ink")]
      pub fn proposal_ids(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: runtime::RuntimeCall,
      ) -> ::polymesh_api_ink::error::Result<Option<u64>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 149u8, 230u8, 68u8, 209u8, 93u8, 43u8, 168u8, 123u8, 142u8, 97u8,
          255u8, 121u8, 47u8, 101u8, 10u8, 146u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Individual multisig signer votes. (multi sig, signer, proposal) => vote."]
      #[cfg(not(feature = "ink"))]
      pub async fn votes(
        &self,
        key_0: (
          ::polymesh_api_client::AccountId,
          types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
          u64,
        ),
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8, 230u8, 150u8,
          237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Individual multisig signer votes. (multi sig, signer, proposal) => vote."]
      #[cfg(feature = "ink")]
      pub fn votes(
        &self,
        key_0: (
          ::polymesh_api_client::AccountId,
          types::polymesh_primitives::secondary_key::Signatory<::polymesh_api_client::AccountId>,
          u64,
        ),
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8, 230u8, 150u8,
          237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps a multisig account to its identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn multi_sig_to_identity(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::IdentityId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 140u8, 115u8, 230u8, 224u8, 53u8, 243u8, 38u8, 176u8, 80u8, 75u8,
          73u8, 102u8, 20u8, 63u8, 143u8, 252u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <::polymesh_api_client::IdentityId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps a multisig account to its identity."]
      #[cfg(feature = "ink")]
      pub fn multi_sig_to_identity(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::IdentityId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 140u8, 115u8, 230u8, 224u8, 53u8, 243u8, 38u8, 176u8, 80u8, 75u8,
          73u8, 102u8, 20u8, 63u8, 143u8, 252u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <::polymesh_api_client::IdentityId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Details of a multisig proposal"]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_detail(
        &self,
        key_0: (::polymesh_api_client::AccountId, u64),
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::multisig::ProposalDetails<u64>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 31u8, 32u8, 177u8, 185u8, 65u8, 92u8, 211u8, 48u8, 162u8, 227u8,
          178u8, 217u8, 224u8, 146u8, 100u8, 61u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8,
          ];
          <types::polymesh_primitives::multisig::ProposalDetails<u64>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Details of a multisig proposal"]
      #[cfg(feature = "ink")]
      pub fn proposal_detail(
        &self,
        key_0: (::polymesh_api_client::AccountId, u64),
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::multisig::ProposalDetails<u64>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 31u8, 32u8, 177u8, 185u8, 65u8, 92u8, 211u8, 48u8, 162u8, 227u8,
          178u8, 217u8, 224u8, 146u8, 100u8, 61u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8,
          ];
          <types::polymesh_primitives::multisig::ProposalDetails<u64>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Tracks creators who are no longer allowed to call via_creator extrinsics."]
      #[cfg(not(feature = "ink"))]
      pub async fn lost_creator_privileges(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 186u8, 53u8, 242u8, 190u8, 166u8, 191u8, 243u8, 146u8, 152u8, 7u8,
          195u8, 8u8, 219u8, 243u8, 28u8, 104u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks creators who are no longer allowed to call via_creator extrinsics."]
      #[cfg(feature = "ink")]
      pub fn lost_creator_privileges(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 186u8, 53u8, 242u8, 190u8, 166u8, 191u8, 243u8, 146u8, 152u8, 7u8,
          195u8, 8u8, 219u8, 243u8, 28u8, 104u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The last transaction version, used for `on_runtime_upgrade`."]
      #[cfg(not(feature = "ink"))]
      pub async fn transaction_version(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 136u8, 215u8, 103u8, 226u8, 158u8, 158u8, 152u8, 49u8, 187u8, 71u8,
          177u8, 173u8, 103u8, 53u8, 72u8, 253u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The last transaction version, used for `on_runtime_upgrade`."]
      #[cfg(feature = "ink")]
      pub fn transaction_version(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 136u8, 215u8, 103u8, 226u8, 158u8, 158u8, 152u8, 49u8, 187u8, 71u8,
          177u8, 173u8, 103u8, 53u8, 72u8, 253u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_multisig::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_multisig::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_multisig::Version> {
        let value = self.api.read_storage(::alloc::vec![
          232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8, 186u8, 133u8,
          109u8, 50u8, 47u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_multisig::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod bridge {
    use super::*;
    #[derive(Clone)]
    pub struct BridgeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> BridgeCallApi<'api> {
      #[doc = "Changes the controller account as admin."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(not(feature = "ink"))]
      pub fn change_controller(
        &self,
        controller: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::change_controller { controller },
        ))
      }
      #[doc = "Changes the controller account as admin."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(feature = "ink")]
      pub fn change_controller(
        &self,
        controller: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 0u8];
        controller.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the bridge admin key."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(not(feature = "ink"))]
      pub fn change_admin(
        &self,
        admin: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::change_admin { admin },
        ))
      }
      #[doc = "Changes the bridge admin key."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(feature = "ink")]
      pub fn change_admin(
        &self,
        admin: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 1u8];
        admin.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the timelock period."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(not(feature = "ink"))]
      pub fn change_timelock(
        &self,
        timelock: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::change_timelock { timelock },
        ))
      }
      #[doc = "Changes the timelock period."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(feature = "ink")]
      pub fn change_timelock(&self, timelock: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 2u8];
        timelock.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Freezes transaction handling in the bridge module if it is not already frozen. When the"]
      #[doc = "bridge is frozen, attempted transactions get postponed instead of getting handled."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(not(feature = "ink"))]
      pub fn freeze(&self) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::freeze,
        ))
      }
      #[doc = "Freezes transaction handling in the bridge module if it is not already frozen. When the"]
      #[doc = "bridge is frozen, attempted transactions get postponed instead of getting handled."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(feature = "ink")]
      pub fn freeze(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![16u8, 3u8])
      }
      #[doc = "Unfreezes transaction handling in the bridge module if it is frozen."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(not(feature = "ink"))]
      pub fn unfreeze(&self) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::unfreeze,
        ))
      }
      #[doc = "Unfreezes transaction handling in the bridge module if it is frozen."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(feature = "ink")]
      pub fn unfreeze(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![16u8, 4u8])
      }
      #[doc = "Changes the bridge limits."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = "- `DivisionByZero` if `duration` is zero."]
      #[cfg(not(feature = "ink"))]
      pub fn change_bridge_limit(
        &self,
        amount: u128,
        duration: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::change_bridge_limit { amount, duration },
        ))
      }
      #[doc = "Changes the bridge limits."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = "- `DivisionByZero` if `duration` is zero."]
      #[cfg(feature = "ink")]
      pub fn change_bridge_limit(&self, amount: u128, duration: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 5u8];
        amount.encode_to(&mut buf);
        duration.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the bridge limit exempted list."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(not(feature = "ink"))]
      pub fn change_bridge_exempted(
        &self,
        exempted: ::alloc::vec::Vec<(::polymesh_api_client::IdentityId, bool)>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::change_bridge_exempted { exempted },
        ))
      }
      #[doc = "Changes the bridge limit exempted list."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(feature = "ink")]
      pub fn change_bridge_exempted(
        &self,
        exempted: ::alloc::vec::Vec<(::polymesh_api_client::IdentityId, bool)>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 6u8];
        exempted.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Forces handling a transaction by bypassing the bridge limit and timelock."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = "- `NoValidCdd` if `bridge_tx.recipient` does not have a valid CDD claim."]
      #[cfg(not(feature = "ink"))]
      pub fn force_handle_bridge_tx(
        &self,
        bridge_tx: types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::force_handle_bridge_tx { bridge_tx },
        ))
      }
      #[doc = "Forces handling a transaction by bypassing the bridge limit and timelock."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = "- `NoValidCdd` if `bridge_tx.recipient` does not have a valid CDD claim."]
      #[cfg(feature = "ink")]
      pub fn force_handle_bridge_tx(
        &self,
        bridge_tx: types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 7u8];
        bridge_tx.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Proposes a vector of bridge transactions. The vector is processed until the first"]
      #[doc = "proposal which causes an error, in which case the error is returned and the rest of"]
      #[doc = "proposals are not processed."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `ControllerNotSet` if `Controllers` was not set."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`500_000_000 + 7_000_000 * bridge_txs.len()`"]
      #[cfg(not(feature = "ink"))]
      pub fn batch_propose_bridge_tx(
        &self,
        bridge_txs: ::alloc::vec::Vec<
          types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::batch_propose_bridge_tx { bridge_txs },
        ))
      }
      #[doc = "Proposes a vector of bridge transactions. The vector is processed until the first"]
      #[doc = "proposal which causes an error, in which case the error is returned and the rest of"]
      #[doc = "proposals are not processed."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `ControllerNotSet` if `Controllers` was not set."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`500_000_000 + 7_000_000 * bridge_txs.len()`"]
      #[cfg(feature = "ink")]
      pub fn batch_propose_bridge_tx(
        &self,
        bridge_txs: ::alloc::vec::Vec<
          types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 8u8];
        bridge_txs.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Proposes a bridge transaction, which amounts to making a multisig proposal for the"]
      #[doc = "bridge transaction if the transaction is new or approving an existing proposal if the"]
      #[doc = "transaction has already been proposed."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `ControllerNotSet` if `Controllers` was not set."]
      #[cfg(not(feature = "ink"))]
      pub fn propose_bridge_tx(
        &self,
        bridge_tx: types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::propose_bridge_tx { bridge_tx },
        ))
      }
      #[doc = "Proposes a bridge transaction, which amounts to making a multisig proposal for the"]
      #[doc = "bridge transaction if the transaction is new or approving an existing proposal if the"]
      #[doc = "transaction has already been proposed."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `ControllerNotSet` if `Controllers` was not set."]
      #[cfg(feature = "ink")]
      pub fn propose_bridge_tx(
        &self,
        bridge_tx: types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 9u8];
        bridge_tx.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Handles an approved bridge transaction proposal."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadCaller` if `origin` is not `Self::controller` or  `Self::admin`."]
      #[doc = "- `TimelockedTx` if the transaction status is `Timelocked`."]
      #[doc = "- `ProposalAlreadyHandled` if the transaction status is `Handled`."]
      #[cfg(not(feature = "ink"))]
      pub fn handle_bridge_tx(
        &self,
        bridge_tx: types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::handle_bridge_tx { bridge_tx },
        ))
      }
      #[doc = "Handles an approved bridge transaction proposal."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadCaller` if `origin` is not `Self::controller` or  `Self::admin`."]
      #[doc = "- `TimelockedTx` if the transaction status is `Timelocked`."]
      #[doc = "- `ProposalAlreadyHandled` if the transaction status is `Handled`."]
      #[cfg(feature = "ink")]
      pub fn handle_bridge_tx(
        &self,
        bridge_tx: types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 10u8];
        bridge_tx.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Freezes given bridge transactions."]
      #[doc = "If any bridge txn is already handled then this function will just ignore it and process next one."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`400_000_000 + 2_000_000 * bridge_txs.len()`"]
      #[cfg(not(feature = "ink"))]
      pub fn freeze_txs(
        &self,
        bridge_txs: ::alloc::vec::Vec<
          types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::freeze_txs { bridge_txs },
        ))
      }
      #[doc = "Freezes given bridge transactions."]
      #[doc = "If any bridge txn is already handled then this function will just ignore it and process next one."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`400_000_000 + 2_000_000 * bridge_txs.len()`"]
      #[cfg(feature = "ink")]
      pub fn freeze_txs(
        &self,
        bridge_txs: ::alloc::vec::Vec<
          types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 11u8];
        bridge_txs.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Unfreezes given bridge transactions."]
      #[doc = "If any bridge txn is already handled then this function will just ignore it and process next one."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`400_000_000 + 7_000_000 * bridge_txs.len()`"]
      #[cfg(not(feature = "ink"))]
      pub fn unfreeze_txs(
        &self,
        bridge_txs: ::alloc::vec::Vec<
          types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::unfreeze_txs { bridge_txs },
        ))
      }
      #[doc = "Unfreezes given bridge transactions."]
      #[doc = "If any bridge txn is already handled then this function will just ignore it and process next one."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`400_000_000 + 7_000_000 * bridge_txs.len()`"]
      #[cfg(feature = "ink")]
      pub fn unfreeze_txs(
        &self,
        bridge_txs: ::alloc::vec::Vec<
          types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 12u8];
        bridge_txs.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Root callable extrinsic, used as an internal call to handle a scheduled timelocked bridge transaction."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `BadOrigin` if `origin` is not root."]
      #[doc = "- `ProposalAlreadyHandled` if transaction status is `Handled`."]
      #[doc = "- `FrozenTx` if transaction status is `Frozen`."]
      #[cfg(not(feature = "ink"))]
      pub fn handle_scheduled_bridge_tx(
        &self,
        bridge_tx: types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::handle_scheduled_bridge_tx { bridge_tx },
        ))
      }
      #[doc = "Root callable extrinsic, used as an internal call to handle a scheduled timelocked bridge transaction."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `BadOrigin` if `origin` is not root."]
      #[doc = "- `ProposalAlreadyHandled` if transaction status is `Handled`."]
      #[doc = "- `FrozenTx` if transaction status is `Frozen`."]
      #[cfg(feature = "ink")]
      pub fn handle_scheduled_bridge_tx(
        &self,
        bridge_tx: types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 13u8];
        bridge_tx.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Add a freeze admin."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(not(feature = "ink"))]
      pub fn add_freeze_admin(
        &self,
        freeze_admin: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::add_freeze_admin { freeze_admin },
        ))
      }
      #[doc = "Add a freeze admin."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(feature = "ink")]
      pub fn add_freeze_admin(
        &self,
        freeze_admin: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 14u8];
        freeze_admin.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove a freeze admin."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_freeze_admin(
        &self,
        freeze_admin: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::remove_freeze_admin { freeze_admin },
        ))
      }
      #[doc = "Remove a freeze admin."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[cfg(feature = "ink")]
      pub fn remove_freeze_admin(
        &self,
        freeze_admin: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 15u8];
        freeze_admin.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove given bridge transactions."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = "- `NotFrozen` if a tx in `bridge_txs` is not frozen."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_txs(
        &self,
        bridge_txs: ::alloc::vec::Vec<
          types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Bridge(
          types::pallet_bridge::BridgeCall::remove_txs { bridge_txs },
        ))
      }
      #[doc = "Remove given bridge transactions."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `BadAdmin` if `origin` is not `Self::admin()` account."]
      #[doc = "- `NotFrozen` if a tx in `bridge_txs` is not frozen."]
      #[cfg(feature = "ink")]
      pub fn remove_txs(
        &self,
        bridge_txs: ::alloc::vec::Vec<
          types::pallet_bridge::BridgeTx<::polymesh_api_client::AccountId>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![16u8, 16u8];
        bridge_txs.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for BridgeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct BridgeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> BridgeQueryApi<'api> {
      #[doc = " The multisig account of the bridge controller. The genesis signers accept their"]
      #[doc = " authorizations and are able to get their proposals delivered. The bridge creator"]
      #[doc = " transfers some POLY to their identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn controller(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 183u8, 204u8, 54u8, 145u8, 109u8, 19u8, 45u8, 59u8, 195u8, 248u8,
          242u8, 199u8, 1u8, 23u8, 109u8, 66u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The multisig account of the bridge controller. The genesis signers accept their"]
      #[doc = " authorizations and are able to get their proposals delivered. The bridge creator"]
      #[doc = " transfers some POLY to their identity."]
      #[cfg(feature = "ink")]
      pub fn controller(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 183u8, 204u8, 54u8, 145u8, 109u8, 19u8, 45u8, 59u8, 195u8, 248u8,
          242u8, 199u8, 1u8, 23u8, 109u8, 66u8,
        ])?;
        Ok(value)
      }
      #[doc = " Details of bridge transactions identified with pairs of the recipient account and the"]
      #[doc = " bridge transaction nonce."]
      #[cfg(not(feature = "ink"))]
      pub async fn bridge_tx_details(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u32,
      ) -> ::polymesh_api_client::error::Result<types::pallet_bridge::BridgeTxDetail<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 160u8, 171u8, 250u8, 46u8, 255u8, 186u8, 133u8, 70u8, 5u8, 113u8,
          106u8, 184u8, 89u8, 221u8, 9u8, 230u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8,
          ];
          <types::pallet_bridge::BridgeTxDetail<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Details of bridge transactions identified with pairs of the recipient account and the"]
      #[doc = " bridge transaction nonce."]
      #[cfg(feature = "ink")]
      pub fn bridge_tx_details(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u32,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_bridge::BridgeTxDetail<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 160u8, 171u8, 250u8, 46u8, 255u8, 186u8, 133u8, 70u8, 5u8, 113u8,
          106u8, 184u8, 89u8, 221u8, 9u8, 230u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8,
          ];
          <types::pallet_bridge::BridgeTxDetail<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The admin key."]
      #[cfg(not(feature = "ink"))]
      pub async fn admin(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 173u8, 16u8, 141u8, 89u8, 159u8, 82u8, 234u8, 243u8, 141u8, 183u8,
          130u8, 149u8, 229u8, 208u8, 119u8, 7u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The admin key."]
      #[cfg(feature = "ink")]
      pub fn admin(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 173u8, 16u8, 141u8, 89u8, 159u8, 82u8, 234u8, 243u8, 141u8, 183u8,
          130u8, 149u8, 229u8, 208u8, 119u8, 7u8,
        ])?;
        Ok(value)
      }
      #[doc = " Whether or not the bridge operation is frozen."]
      #[cfg(not(feature = "ink"))]
      pub async fn frozen(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8, 93u8, 238u8, 240u8,
          115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Whether or not the bridge operation is frozen."]
      #[cfg(feature = "ink")]
      pub fn frozen(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8, 93u8, 238u8, 240u8,
          115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Freeze bridge admins.  These accounts can only freeze the bridge."]
      #[cfg(not(feature = "ink"))]
      pub async fn freeze_admins(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 46u8, 14u8, 105u8, 223u8, 24u8, 9u8, 5u8, 55u8, 62u8, 201u8, 158u8,
          14u8, 181u8, 153u8, 155u8, 227u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Freeze bridge admins.  These accounts can only freeze the bridge."]
      #[cfg(feature = "ink")]
      pub fn freeze_admins(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 46u8, 14u8, 105u8, 223u8, 24u8, 9u8, 5u8, 55u8, 62u8, 201u8, 158u8,
          14u8, 181u8, 153u8, 155u8, 227u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The bridge transaction timelock period, in blocks, since the acceptance of the"]
      #[doc = " transaction proposal during which the admin key can freeze the transaction."]
      #[cfg(not(feature = "ink"))]
      pub async fn timelock(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 165u8, 103u8, 110u8, 43u8, 52u8, 147u8, 66u8, 159u8, 203u8, 158u8,
          136u8, 171u8, 49u8, 13u8, 97u8, 241u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The bridge transaction timelock period, in blocks, since the acceptance of the"]
      #[doc = " transaction proposal during which the admin key can freeze the transaction."]
      #[cfg(feature = "ink")]
      pub fn timelock(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 165u8, 103u8, 110u8, 43u8, 52u8, 147u8, 66u8, 159u8, 203u8, 158u8,
          136u8, 171u8, 49u8, 13u8, 97u8, 241u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum number of bridged POLYX per identity within a set interval of"]
      #[doc = " blocks. Fields: POLYX amount and the block interval duration."]
      #[cfg(not(feature = "ink"))]
      pub async fn bridge_limit(&self) -> ::polymesh_api_client::error::Result<(u128, u32)> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 132u8, 135u8, 62u8, 163u8, 160u8, 182u8, 134u8, 35u8, 36u8, 148u8,
          56u8, 64u8, 19u8, 139u8, 235u8, 155u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <(u128, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum number of bridged POLYX per identity within a set interval of"]
      #[doc = " blocks. Fields: POLYX amount and the block interval duration."]
      #[cfg(feature = "ink")]
      pub fn bridge_limit(&self) -> ::polymesh_api_ink::error::Result<(u128, u32)> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 132u8, 135u8, 62u8, 163u8, 160u8, 182u8, 134u8, 35u8, 36u8, 148u8,
          56u8, 64u8, 19u8, 139u8, 235u8, 155u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <(u128, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Amount of POLYX bridged by the identity in last block interval. Fields: the bridged"]
      #[doc = " amount and the last interval number."]
      #[cfg(not(feature = "ink"))]
      pub async fn polyx_bridged(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<(u128, u32)> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 153u8, 172u8, 54u8, 12u8, 240u8, 75u8, 42u8, 186u8, 164u8, 214u8,
          162u8, 172u8, 42u8, 252u8, 113u8, 145u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <(u128, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Amount of POLYX bridged by the identity in last block interval. Fields: the bridged"]
      #[doc = " amount and the last interval number."]
      #[cfg(feature = "ink")]
      pub fn polyx_bridged(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<(u128, u32)> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 153u8, 172u8, 54u8, 12u8, 240u8, 75u8, 42u8, 186u8, 164u8, 214u8,
          162u8, 172u8, 42u8, 252u8, 113u8, 145u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <(u128, u32)>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Identities not constrained by the bridge limit."]
      #[cfg(not(feature = "ink"))]
      pub async fn bridge_limit_exempted(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 108u8, 105u8, 144u8, 154u8, 14u8, 188u8, 102u8, 133u8, 14u8, 53u8,
          105u8, 27u8, 178u8, 56u8, 52u8, 155u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Identities not constrained by the bridge limit."]
      #[cfg(feature = "ink")]
      pub fn bridge_limit_exempted(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 108u8, 105u8, 144u8, 154u8, 14u8, 188u8, 102u8, 133u8, 14u8, 53u8,
          105u8, 27u8, 178u8, 56u8, 52u8, 155u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_bridge::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_bridge::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_bridge::Version> {
        let value = self.api.read_storage(::alloc::vec![
          107u8, 189u8, 52u8, 241u8, 88u8, 169u8, 225u8, 165u8, 229u8, 96u8, 11u8, 3u8, 173u8,
          238u8, 121u8, 50u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_bridge::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod staking {
    use super::*;
    #[derive(Clone)]
    pub struct StakingCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> StakingCallApi<'api> {
      #[doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"]
      #[doc = "be the account that controls it."]
      #[doc = ""]
      #[doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash account."]
      #[doc = ""]
      #[doc = "Emits `Bonded`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Moderate complexity."]
      #[doc = "- O(1)."]
      #[doc = "- Three extra DB entries."]
      #[doc = ""]
      #[doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"]
      #[doc = "unless the `origin` falls below _existential deposit_ and gets removed as dust."]
      #[doc = "------------------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks"]
      #[doc = "- Write: Bonded, Payee, [Origin Account], Locks, Ledger"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn bond(
        &self,
        controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::bond {
            controller,
            value,
            payee,
          },
        ))
      }
      #[doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"]
      #[doc = "be the account that controls it."]
      #[doc = ""]
      #[doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash account."]
      #[doc = ""]
      #[doc = "Emits `Bonded`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Moderate complexity."]
      #[doc = "- O(1)."]
      #[doc = "- Three extra DB entries."]
      #[doc = ""]
      #[doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"]
      #[doc = "unless the `origin` falls below _existential deposit_ and gets removed as dust."]
      #[doc = "------------------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks"]
      #[doc = "- Write: Bonded, Payee, [Origin Account], Locks, Ledger"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn bond(
        &self,
        controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 0u8];
        controller.encode_to(&mut buf);
        value.encode_to(&mut buf);
        payee.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"]
      #[doc = "for staking."]
      #[doc = ""]
      #[doc = "Use this if there are additional funds in your stash account that you wish to bond."]
      #[doc = "Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount"]
      #[doc = "that can be added."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller and"]
      #[doc = "it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "Emits `Bonded`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- O(1)."]
      #[doc = "- One DB entry."]
      #[doc = "------------"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Era Election Status, Bonded, Ledger, [Origin Account], Locks"]
      #[doc = "- Write: [Origin Account], Locks, Ledger"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn bond_extra(
        &self,
        max_additional: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::bond_extra { max_additional },
        ))
      }
      #[doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"]
      #[doc = "for staking."]
      #[doc = ""]
      #[doc = "Use this if there are additional funds in your stash account that you wish to bond."]
      #[doc = "Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount"]
      #[doc = "that can be added."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller and"]
      #[doc = "it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "Emits `Bonded`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- O(1)."]
      #[doc = "- One DB entry."]
      #[doc = "------------"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Era Election Status, Bonded, Ledger, [Origin Account], Locks"]
      #[doc = "- Write: [Origin Account], Locks, Ledger"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn bond_extra(&self, max_additional: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 1u8];
        max_additional.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"]
      #[doc = "period ends. If this leaves an amount actively bonded less than"]
      #[doc = "T::Currency::minimum_balance(), then it is increased to the full amount."]
      #[doc = ""]
      #[doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"]
      #[doc = "the funds out of management ready for transfer."]
      #[doc = ""]
      #[doc = "No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)"]
      #[doc = "can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need"]
      #[doc = "to be called first to remove some of the chunks (if possible)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "Emits `Unbonded`."]
      #[doc = ""]
      #[doc = "See also [`Call::withdraw_unbonded`]."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Limited but potentially exploitable complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Each call (requires the remainder of the bonded balance to be above `minimum_balance`)"]
      #[doc = "  will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage."]
      #[doc = "  The only way to clean the aforementioned storage item is also user-controlled via"]
      #[doc = "  `withdraw_unbonded`."]
      #[doc = "- One DB entry."]
      #[doc = "----------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: EraElectionStatus, Ledger, CurrentEra, Locks, \\[Origin Account\\]"]
      #[doc = "- Write: Locks, Ledger, \\[Origin Account\\]"]
      #[doc = "</weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn unbond(
        &self,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::unbond { value },
        ))
      }
      #[doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"]
      #[doc = "period ends. If this leaves an amount actively bonded less than"]
      #[doc = "T::Currency::minimum_balance(), then it is increased to the full amount."]
      #[doc = ""]
      #[doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"]
      #[doc = "the funds out of management ready for transfer."]
      #[doc = ""]
      #[doc = "No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)"]
      #[doc = "can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need"]
      #[doc = "to be called first to remove some of the chunks (if possible)."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "Emits `Unbonded`."]
      #[doc = ""]
      #[doc = "See also [`Call::withdraw_unbonded`]."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Limited but potentially exploitable complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Each call (requires the remainder of the bonded balance to be above `minimum_balance`)"]
      #[doc = "  will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage."]
      #[doc = "  The only way to clean the aforementioned storage item is also user-controlled via"]
      #[doc = "  `withdraw_unbonded`."]
      #[doc = "- One DB entry."]
      #[doc = "----------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: EraElectionStatus, Ledger, CurrentEra, Locks, \\[Origin Account\\]"]
      #[doc = "- Write: Locks, Ledger, \\[Origin Account\\]"]
      #[doc = "</weight>"]
      #[cfg(feature = "ink")]
      pub fn unbond(&self, value: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 2u8];
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove any unlocked chunks from the `unlocking` queue from our management."]
      #[doc = ""]
      #[doc = "This essentially frees up that balance to be used by the stash account to do"]
      #[doc = "whatever it wants."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "Emits `Withdrawn`."]
      #[doc = ""]
      #[doc = "See also [`Call::unbond`]."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Could be dependent on the `origin` argument and how much `unlocking` chunks exist."]
      #[doc = " It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is"]
      #[doc = " indirectly user-controlled. See [`unbond`] for more detail."]
      #[doc = "- Contains a limited number of reads, yet the size of which could be large based on `ledger`."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "---------------"]
      #[doc = "Complexity O(S) where S is the number of slashing spans to remove"]
      #[doc = "Update:"]
      #[doc = "- Reads: EraElectionStatus, Ledger, Current Era, Locks, [Origin Account]"]
      #[doc = "- Writes: [Origin Account], Locks, Ledger"]
      #[doc = "Kill:"]
      #[doc = "- Reads: EraElectionStatus, Ledger, Current Era, Bonded, Slashing Spans, [Origin"]
      #[doc = "  Account], Locks"]
      #[doc = "- Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators,"]
      #[doc = "  [Origin Account], Locks"]
      #[doc = "- Writes Each: SpanSlash * S"]
      #[doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn withdraw_unbonded(
        &self,
        num_slashing_spans: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::withdraw_unbonded { num_slashing_spans },
        ))
      }
      #[doc = "Remove any unlocked chunks from the `unlocking` queue from our management."]
      #[doc = ""]
      #[doc = "This essentially frees up that balance to be used by the stash account to do"]
      #[doc = "whatever it wants."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "Emits `Withdrawn`."]
      #[doc = ""]
      #[doc = "See also [`Call::unbond`]."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Could be dependent on the `origin` argument and how much `unlocking` chunks exist."]
      #[doc = " It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is"]
      #[doc = " indirectly user-controlled. See [`unbond`] for more detail."]
      #[doc = "- Contains a limited number of reads, yet the size of which could be large based on `ledger`."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "---------------"]
      #[doc = "Complexity O(S) where S is the number of slashing spans to remove"]
      #[doc = "Update:"]
      #[doc = "- Reads: EraElectionStatus, Ledger, Current Era, Locks, [Origin Account]"]
      #[doc = "- Writes: [Origin Account], Locks, Ledger"]
      #[doc = "Kill:"]
      #[doc = "- Reads: EraElectionStatus, Ledger, Current Era, Bonded, Slashing Spans, [Origin"]
      #[doc = "  Account], Locks"]
      #[doc = "- Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators,"]
      #[doc = "  [Origin Account], Locks"]
      #[doc = "- Writes Each: SpanSlash * S"]
      #[doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn withdraw_unbonded(&self, num_slashing_spans: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 3u8];
        num_slashing_spans.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Declare the desire to validate for the origin controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "-----------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Era Election Status, Ledger"]
      #[doc = "- Write: Nominators, Validators"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn validate(
        &self,
        prefs: types::pallet_staking::ValidatorPrefs,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::validate { prefs },
        ))
      }
      #[doc = "Declare the desire to validate for the origin controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "-----------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Era Election Status, Ledger"]
      #[doc = "- Write: Nominators, Validators"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn validate(
        &self,
        prefs: types::pallet_staking::ValidatorPrefs,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 4u8];
        prefs.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Declare the desire to nominate `targets` for the origin controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era. This can only be called when"]
      #[doc = "[`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- The transaction's complexity is proportional to the size of `targets` (N)"]
      #[doc = "which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS)."]
      #[doc = "- Both the reads and writes follow a similar pattern."]
      #[doc = "---------"]
      #[doc = "Weight: O(N)"]
      #[doc = "where N is the number of targets"]
      #[doc = "DB Weight:"]
      #[doc = "- Reads: Era Election Status, Ledger, Current Era"]
      #[doc = "- Writes: Validators, Nominators"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn nominate(
        &self,
        targets: ::alloc::vec::Vec<
          ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::nominate { targets },
        ))
      }
      #[doc = "Declare the desire to nominate `targets` for the origin controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era. This can only be called when"]
      #[doc = "[`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- The transaction's complexity is proportional to the size of `targets` (N)"]
      #[doc = "which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS)."]
      #[doc = "- Both the reads and writes follow a similar pattern."]
      #[doc = "---------"]
      #[doc = "Weight: O(N)"]
      #[doc = "where N is the number of targets"]
      #[doc = "DB Weight:"]
      #[doc = "- Reads: Era Election Status, Ledger, Current Era"]
      #[doc = "- Writes: Validators, Nominators"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn nominate(
        &self,
        targets: ::alloc::vec::Vec<
          ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 5u8];
        targets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Declare no desire to either validate or nominate."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains one read."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "--------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: EraElectionStatus, Ledger"]
      #[doc = "- Write: Validators, Nominators"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn chill(&self) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::chill,
        ))
      }
      #[doc = "Declare no desire to either validate or nominate."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains one read."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "--------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: EraElectionStatus, Ledger"]
      #[doc = "- Write: Validators, Nominators"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn chill(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![17u8, 6u8])
      }
      #[doc = "(Re-)set the payment target for a controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "---------"]
      #[doc = "- Weight: O(1)"]
      #[doc = "- DB Weight:"]
      #[doc = "    - Read: Ledger"]
      #[doc = "    - Write: Payee"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn set_payee(
        &self,
        payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::set_payee { payee },
        ))
      }
      #[doc = "(Re-)set the payment target for a controller."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "---------"]
      #[doc = "- Weight: O(1)"]
      #[doc = "- DB Weight:"]
      #[doc = "    - Read: Ledger"]
      #[doc = "    - Write: Payee"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn set_payee(
        &self,
        payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 7u8];
        payee.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "(Re-)set the controller of a stash."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "----------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Bonded, Ledger New Controller, Ledger Old Controller"]
      #[doc = "- Write: Bonded, Ledger New Controller, Ledger Old Controller"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn set_controller(
        &self,
        controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::set_controller { controller },
        ))
      }
      #[doc = "(Re-)set the controller of a stash."]
      #[doc = ""]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Independent of the arguments. Insignificant complexity."]
      #[doc = "- Contains a limited number of reads."]
      #[doc = "- Writes are limited to the `origin` account key."]
      #[doc = "----------"]
      #[doc = "Weight: O(1)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: Bonded, Ledger New Controller, Ledger Old Controller"]
      #[doc = "- Write: Bonded, Ledger New Controller, Ledger Old Controller"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn set_controller(
        &self,
        controller: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 8u8];
        controller.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets the ideal number of validators."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Weight: O(1)"]
      #[doc = "Write: Validator Count"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn set_validator_count(
        &self,
        new: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::set_validator_count { new },
        ))
      }
      #[doc = "Sets the ideal number of validators."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Weight: O(1)"]
      #[doc = "Write: Validator Count"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn set_validator_count(&self, new: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 9u8];
        new.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Increments the ideal number of validators."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Same as [`set_validator_count`]."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn increase_validator_count(
        &self,
        additional: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::increase_validator_count { additional },
        ))
      }
      #[doc = "Increments the ideal number of validators."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Same as [`set_validator_count`]."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn increase_validator_count(&self, additional: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 10u8];
        additional.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Scale up the ideal number of validators by a factor."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Same as [`set_validator_count`]."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn scale_validator_count(
        &self,
        factor: ::polymesh_api_client::per_things::Percent,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::scale_validator_count { factor },
        ))
      }
      #[doc = "Scale up the ideal number of validators by a factor."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Same as [`set_validator_count`]."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn scale_validator_count(
        &self,
        factor: ::polymesh_api_client::per_things::Percent,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 11u8];
        factor.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Governance committee on 2/3 rds majority can introduce a new potential identity"]
      #[doc = "to the pool of permissioned entities who can run validators. Staking module uses `PermissionedIdentity`"]
      #[doc = "to ensure validators have completed KYB compliance and considers them for validation."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin Required origin for adding a potential validator."]
      #[doc = "* identity Validator's IdentityId."]
      #[doc = "* intended_count No. of validators given identity intends to run."]
      #[cfg(not(feature = "ink"))]
      pub fn add_permissioned_validator(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        intended_count: Option<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::add_permissioned_validator {
            identity,
            intended_count,
          },
        ))
      }
      #[doc = "Governance committee on 2/3 rds majority can introduce a new potential identity"]
      #[doc = "to the pool of permissioned entities who can run validators. Staking module uses `PermissionedIdentity`"]
      #[doc = "to ensure validators have completed KYB compliance and considers them for validation."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin Required origin for adding a potential validator."]
      #[doc = "* identity Validator's IdentityId."]
      #[doc = "* intended_count No. of validators given identity intends to run."]
      #[cfg(feature = "ink")]
      pub fn add_permissioned_validator(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        intended_count: Option<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 12u8];
        identity.encode_to(&mut buf);
        intended_count.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session."]
      #[doc = "Staking module checks `PermissionedIdentity` to ensure validators have"]
      #[doc = "completed KYB compliance"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin Required origin for removing a potential validator."]
      #[doc = "* identity Validator's IdentityId."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_permissioned_validator(
        &self,
        identity: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::remove_permissioned_validator { identity },
        ))
      }
      #[doc = "Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session."]
      #[doc = "Staking module checks `PermissionedIdentity` to ensure validators have"]
      #[doc = "completed KYB compliance"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin Required origin for removing a potential validator."]
      #[doc = "* identity Validator's IdentityId."]
      #[cfg(feature = "ink")]
      pub fn remove_permissioned_validator(
        &self,
        identity: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 13u8];
        identity.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Validate the nominators CDD expiry time."]
      #[doc = ""]
      #[doc = "If an account from a given set of address is nominating then"]
      #[doc = "check the CDD expiry time of it and if it is expired"]
      #[doc = "then the account should be unbonded and removed from the nominating process."]
      #[doc = ""]
      #[doc = "#<weight>"]
      #[doc = "- Depends on passed list of AccountId."]
      #[doc = "- Depends on the no. of claim issuers an accountId has for the CDD expiry."]
      #[doc = "#</weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn validate_cdd_expiry_nominators(
        &self,
        targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::validate_cdd_expiry_nominators { targets },
        ))
      }
      #[doc = "Validate the nominators CDD expiry time."]
      #[doc = ""]
      #[doc = "If an account from a given set of address is nominating then"]
      #[doc = "check the CDD expiry time of it and if it is expired"]
      #[doc = "then the account should be unbonded and removed from the nominating process."]
      #[doc = ""]
      #[doc = "#<weight>"]
      #[doc = "- Depends on passed list of AccountId."]
      #[doc = "- Depends on the no. of claim issuers an accountId has for the CDD expiry."]
      #[doc = "#</weight>"]
      #[cfg(feature = "ink")]
      pub fn validate_cdd_expiry_nominators(
        &self,
        targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 14u8];
        targets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes commission rate which applies to all validators. Only Governance"]
      #[doc = "committee is allowed to change this value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `new_cap` the new commission cap."]
      #[cfg(not(feature = "ink"))]
      pub fn set_commission_cap(
        &self,
        new_cap: ::polymesh_api_client::per_things::Perbill,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::set_commission_cap { new_cap },
        ))
      }
      #[doc = "Changes commission rate which applies to all validators. Only Governance"]
      #[doc = "committee is allowed to change this value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `new_cap` the new commission cap."]
      #[cfg(feature = "ink")]
      pub fn set_commission_cap(
        &self,
        new_cap: ::polymesh_api_client::per_things::Perbill,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 15u8];
        new_cap.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes min bond value to be used in validate(). Only Governance"]
      #[doc = "committee is allowed to change this value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `new_value` the new minimum"]
      #[cfg(not(feature = "ink"))]
      pub fn set_min_bond_threshold(
        &self,
        new_value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::set_min_bond_threshold { new_value },
        ))
      }
      #[doc = "Changes min bond value to be used in validate(). Only Governance"]
      #[doc = "committee is allowed to change this value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `new_value` the new minimum"]
      #[cfg(feature = "ink")]
      pub fn set_min_bond_threshold(&self, new_value: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 16u8];
        new_value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Force there to be no new eras indefinitely."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- No arguments."]
      #[doc = "- Weight: O(1)"]
      #[doc = "- Write: ForceEra"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn force_no_eras(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::force_no_eras,
        ))
      }
      #[doc = "Force there to be no new eras indefinitely."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- No arguments."]
      #[doc = "- Weight: O(1)"]
      #[doc = "- Write: ForceEra"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn force_no_eras(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![17u8, 17u8])
      }
      #[doc = "Force there to be a new era at the end of the next session. After this, it will be"]
      #[doc = "reset to normal (non-forced) behaviour."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- No arguments."]
      #[doc = "- Weight: O(1)"]
      #[doc = "- Write ForceEra"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn force_new_era(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::force_new_era,
        ))
      }
      #[doc = "Force there to be a new era at the end of the next session. After this, it will be"]
      #[doc = "reset to normal (non-forced) behaviour."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- No arguments."]
      #[doc = "- Weight: O(1)"]
      #[doc = "- Write ForceEra"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn force_new_era(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![17u8, 18u8])
      }
      #[doc = "Set the validators who cannot be slashed (if any)."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(V)"]
      #[doc = "- Write: Invulnerables"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn set_invulnerables(
        &self,
        invulnerables: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::set_invulnerables { invulnerables },
        ))
      }
      #[doc = "Set the validators who cannot be slashed (if any)."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(V)"]
      #[doc = "- Write: Invulnerables"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn set_invulnerables(
        &self,
        invulnerables: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 19u8];
        invulnerables.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Force a current staker to become completely unstaked, immediately."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "O(S) where S is the number of slashing spans to be removed"]
      #[doc = "Reads: Bonded, Slashing Spans, Account, Locks"]
      #[doc = "Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks"]
      #[doc = "Writes Each: SpanSlash * S"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn force_unstake(
        &self,
        stash: ::polymesh_api_client::AccountId,
        num_slashing_spans: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::force_unstake {
            stash,
            num_slashing_spans,
          },
        ))
      }
      #[doc = "Force a current staker to become completely unstaked, immediately."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "O(S) where S is the number of slashing spans to be removed"]
      #[doc = "Reads: Bonded, Slashing Spans, Account, Locks"]
      #[doc = "Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks"]
      #[doc = "Writes Each: SpanSlash * S"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn force_unstake(
        &self,
        stash: ::polymesh_api_client::AccountId,
        num_slashing_spans: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 20u8];
        stash.encode_to(&mut buf);
        num_slashing_spans.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Force there to be a new era at the end of sessions indefinitely."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Weight: O(1)"]
      #[doc = "- Write: ForceEra"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn force_new_era_always(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::force_new_era_always,
        ))
      }
      #[doc = "Force there to be a new era at the end of sessions indefinitely."]
      #[doc = ""]
      #[doc = "The dispatch origin must be Root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Weight: O(1)"]
      #[doc = "- Write: ForceEra"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn force_new_era_always(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![17u8, 21u8])
      }
      #[doc = "Cancel enactment of a deferred slash."]
      #[doc = ""]
      #[doc = "Can be called by the `T::SlashCancelOrigin`."]
      #[doc = ""]
      #[doc = "Parameters: era and indices of the slashes for that era to kill."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Complexity: O(U + S)"]
      #[doc = "with U unapplied slashes weighted with U=1000"]
      #[doc = "and S is the number of slash indices to be canceled."]
      #[doc = "- Read: Unapplied Slashes"]
      #[doc = "- Write: Unapplied Slashes"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn cancel_deferred_slash(
        &self,
        era: u32,
        slash_indices: ::alloc::vec::Vec<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::cancel_deferred_slash { era, slash_indices },
        ))
      }
      #[doc = "Cancel enactment of a deferred slash."]
      #[doc = ""]
      #[doc = "Can be called by the `T::SlashCancelOrigin`."]
      #[doc = ""]
      #[doc = "Parameters: era and indices of the slashes for that era to kill."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Complexity: O(U + S)"]
      #[doc = "with U unapplied slashes weighted with U=1000"]
      #[doc = "and S is the number of slash indices to be canceled."]
      #[doc = "- Read: Unapplied Slashes"]
      #[doc = "- Write: Unapplied Slashes"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn cancel_deferred_slash(
        &self,
        era: u32,
        slash_indices: ::alloc::vec::Vec<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 22u8];
        era.encode_to(&mut buf);
        slash_indices.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Pay out all the stakers behind a single validator for a single era."]
      #[doc = ""]
      #[doc = "- `validator_stash` is the stash account of the validator. Their nominators, up to"]
      #[doc = "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards."]
      #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
      #[doc = ""]
      #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
      #[doc = "it is not one of the stakers."]
      #[doc = ""]
      #[doc = "This can only be called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Time complexity: at most O(MaxNominatorRewardedPerValidator)."]
      #[doc = "- Contains a limited number of reads and writes."]
      #[doc = "-----------"]
      #[doc = "N is the Number of payouts for the validator (including the validator)"]
      #[doc = "Weight:"]
      #[doc = "- Reward Destination Staked: O(N)"]
      #[doc = "- Reward Destination Controller (Creating): O(N)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: EraElectionStatus, CurrentEra, HistoryDepth, ErasValidatorReward,"]
      #[doc = "        ErasStakersClipped, ErasRewardPoints, ErasValidatorPrefs (8 items)"]
      #[doc = "- Read Each: Bonded, Ledger, Payee, Locks, System Account (5 items)"]
      #[doc = "- Write Each: System Account, Locks, Ledger (3 items)"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn payout_stakers(
        &self,
        validator_stash: ::polymesh_api_client::AccountId,
        era: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::payout_stakers {
            validator_stash,
            era,
          },
        ))
      }
      #[doc = "Pay out all the stakers behind a single validator for a single era."]
      #[doc = ""]
      #[doc = "- `validator_stash` is the stash account of the validator. Their nominators, up to"]
      #[doc = "  `T::MaxNominatorRewardedPerValidator`, will also receive their rewards."]
      #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
      #[doc = ""]
      #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
      #[doc = "it is not one of the stakers."]
      #[doc = ""]
      #[doc = "This can only be called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Time complexity: at most O(MaxNominatorRewardedPerValidator)."]
      #[doc = "- Contains a limited number of reads and writes."]
      #[doc = "-----------"]
      #[doc = "N is the Number of payouts for the validator (including the validator)"]
      #[doc = "Weight:"]
      #[doc = "- Reward Destination Staked: O(N)"]
      #[doc = "- Reward Destination Controller (Creating): O(N)"]
      #[doc = "DB Weight:"]
      #[doc = "- Read: EraElectionStatus, CurrentEra, HistoryDepth, ErasValidatorReward,"]
      #[doc = "        ErasStakersClipped, ErasRewardPoints, ErasValidatorPrefs (8 items)"]
      #[doc = "- Read Each: Bonded, Ledger, Payee, Locks, System Account (5 items)"]
      #[doc = "- Write Each: System Account, Locks, Ledger (3 items)"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn payout_stakers(
        &self,
        validator_stash: ::polymesh_api_client::AccountId,
        era: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 23u8];
        validator_stash.encode_to(&mut buf);
        era.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rebond a portion of the stash scheduled to be unlocked."]
      #[doc = ""]
      #[doc = "The dispatch origin must be signed by the controller, and it can be only called when"]
      #[doc = "[`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Time complexity: O(L), where L is unlocking chunks"]
      #[doc = "- Bounded by `MAX_UNLOCKING_CHUNKS`."]
      #[doc = "- Storage changes: Can't increase storage, only decrease it."]
      #[doc = "---------------"]
      #[doc = "- DB Weight:"]
      #[doc = "    - Reads: EraElectionStatus, Ledger, Locks, [Origin Account]"]
      #[doc = "    - Writes: [Origin Account], Locks, Ledger"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn rebond(
        &self,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::rebond { value },
        ))
      }
      #[doc = "Rebond a portion of the stash scheduled to be unlocked."]
      #[doc = ""]
      #[doc = "The dispatch origin must be signed by the controller, and it can be only called when"]
      #[doc = "[`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- Time complexity: O(L), where L is unlocking chunks"]
      #[doc = "- Bounded by `MAX_UNLOCKING_CHUNKS`."]
      #[doc = "- Storage changes: Can't increase storage, only decrease it."]
      #[doc = "---------------"]
      #[doc = "- DB Weight:"]
      #[doc = "    - Reads: EraElectionStatus, Ledger, Locks, [Origin Account]"]
      #[doc = "    - Writes: [Origin Account], Locks, Ledger"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn rebond(&self, value: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 24u8];
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set `HistoryDepth` value. This function will delete any history information"]
      #[doc = "when `HistoryDepth` is reduced."]
      #[doc = ""]
      #[doc = "Parameters:"]
      #[doc = "- `new_history_depth`: The new history depth you would like to set."]
      #[doc = "- `era_items_deleted`: The number of items that will be deleted by this dispatch."]
      #[doc = "   This should report all the storage items that will be deleted by clearing old"]
      #[doc = "   era history. Needed to report an accurate weight for the dispatch. Trusted by"]
      #[doc = "   `Root` to report an accurate number."]
      #[doc = ""]
      #[doc = "Origin must be root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- E: Number of history depths removed, i.e. 10 -> 7 = 3"]
      #[doc = "- Weight: O(E)"]
      #[doc = "- DB Weight:"]
      #[doc = "    - Reads: Current Era, History Depth"]
      #[doc = "    - Writes: History Depth"]
      #[doc = "    - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs"]
      #[doc = "    - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn set_history_depth(
        &self,
        new_history_depth: u32,
        _era_items_deleted: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::set_history_depth {
            new_history_depth,
            _era_items_deleted,
          },
        ))
      }
      #[doc = "Set `HistoryDepth` value. This function will delete any history information"]
      #[doc = "when `HistoryDepth` is reduced."]
      #[doc = ""]
      #[doc = "Parameters:"]
      #[doc = "- `new_history_depth`: The new history depth you would like to set."]
      #[doc = "- `era_items_deleted`: The number of items that will be deleted by this dispatch."]
      #[doc = "   This should report all the storage items that will be deleted by clearing old"]
      #[doc = "   era history. Needed to report an accurate weight for the dispatch. Trusted by"]
      #[doc = "   `Root` to report an accurate number."]
      #[doc = ""]
      #[doc = "Origin must be root."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- E: Number of history depths removed, i.e. 10 -> 7 = 3"]
      #[doc = "- Weight: O(E)"]
      #[doc = "- DB Weight:"]
      #[doc = "    - Reads: Current Era, History Depth"]
      #[doc = "    - Writes: History Depth"]
      #[doc = "    - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs"]
      #[doc = "    - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn set_history_depth(
        &self,
        new_history_depth: u32,
        _era_items_deleted: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 25u8];
        new_history_depth.encode_to(&mut buf);
        _era_items_deleted.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove all data structure concerning a staker/stash once its balance is at the minimum."]
      #[doc = "This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone"]
      #[doc = "and the target `stash` must have no funds left beyond the ED."]
      #[doc = ""]
      #[doc = "This can be called from any origin."]
      #[doc = ""]
      #[doc = "- `stash`: The stash account to reap. Its balance must be zero."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Complexity: O(S) where S is the number of slashing spans on the account."]
      #[doc = "DB Weight:"]
      #[doc = "- Reads: Stash Account, Bonded, Slashing Spans, Locks"]
      #[doc = "- Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks"]
      #[doc = "- Writes Each: SpanSlash * S"]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn reap_stash(
        &self,
        stash: ::polymesh_api_client::AccountId,
        num_slashing_spans: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::reap_stash {
            stash,
            num_slashing_spans,
          },
        ))
      }
      #[doc = "Remove all data structure concerning a staker/stash once its balance is at the minimum."]
      #[doc = "This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone"]
      #[doc = "and the target `stash` must have no funds left beyond the ED."]
      #[doc = ""]
      #[doc = "This can be called from any origin."]
      #[doc = ""]
      #[doc = "- `stash`: The stash account to reap. Its balance must be zero."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "Complexity: O(S) where S is the number of slashing spans on the account."]
      #[doc = "DB Weight:"]
      #[doc = "- Reads: Stash Account, Bonded, Slashing Spans, Locks"]
      #[doc = "- Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks"]
      #[doc = "- Writes Each: SpanSlash * S"]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn reap_stash(
        &self,
        stash: ::polymesh_api_client::AccountId,
        num_slashing_spans: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 26u8];
        stash.encode_to(&mut buf);
        num_slashing_spans.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Submit an election result to the chain. If the solution:"]
      #[doc = ""]
      #[doc = "1. is valid."]
      #[doc = "2. has a better score than a potentially existing solution on chain."]
      #[doc = ""]
      #[doc = "then, it will be _put_ on chain."]
      #[doc = ""]
      #[doc = "A solution consists of two pieces of data:"]
      #[doc = ""]
      #[doc = "1. `winners`: a flat vector of all the winners of the round."]
      #[doc = "2. `assignments`: the compact version of an assignment vector that encodes the edge"]
      #[doc = "   weights."]
      #[doc = ""]
      #[doc = "Both of which may be computed using _phragmen_, or any other algorithm."]
      #[doc = ""]
      #[doc = "Additionally, the submitter must provide:"]
      #[doc = ""]
      #[doc = "- The `score` that they claim their solution has."]
      #[doc = ""]
      #[doc = "Both validators and nominators will be represented by indices in the solution. The"]
      #[doc = "indices should respect the corresponding types ([`ValidatorIndex`] and"]
      #[doc = "[`NominatorIndex`]). Moreover, they should be valid when used to index into"]
      #[doc = "[`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the"]
      #[doc = "solution to be rejected. These two storage items are set during the election window and"]
      #[doc = "may be used to determine the indices."]
      #[doc = ""]
      #[doc = "A solution is valid if:"]
      #[doc = ""]
      #[doc = "0. It is submitted when [`EraElectionStatus`] is `Open`."]
      #[doc = "1. Its claimed score is equal to the score computed on-chain."]
      #[doc = "2. Presents the correct number of winners."]
      #[doc = "3. All indexes must be value according to the snapshot vectors. All edge values must"]
      #[doc = "   also be correct and should not overflow the granularity of the ratio type (i.e. 256"]
      #[doc = "   or billion)."]
      #[doc = "4. For each edge, all targets are actually nominated by the voter."]
      #[doc = "5. Has correct self-votes."]
      #[doc = ""]
      #[doc = "A solutions score is consisted of 3 parameters:"]
      #[doc = ""]
      #[doc = "1. `min { support.total }` for each support of a winner. This value should be maximized."]
      #[doc = "2. `sum { support.total }` for each support of a winner. This value should be minimized."]
      #[doc = "3. `sum { support.total^2 }` for each support of a winner. This value should be"]
      #[doc = "   minimized (to ensure less variance)"]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "The transaction is assumed to be the longest path, a better solution."]
      #[doc = "  - Initial solution is almost the same."]
      #[doc = "  - Worse solution is retraced in pre-dispatch-checks which sets its own weight."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn submit_election_solution(
        &self,
        winners: ::alloc::vec::Vec<u16>,
        compact: types::pallet_staking::CompactAssignments,
        score: types::sp_npos_elections::ElectionScore,
        era: u32,
        size: types::pallet_staking::ElectionSize,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::submit_election_solution {
            winners,
            compact,
            score,
            era,
            size,
          },
        ))
      }
      #[doc = "Submit an election result to the chain. If the solution:"]
      #[doc = ""]
      #[doc = "1. is valid."]
      #[doc = "2. has a better score than a potentially existing solution on chain."]
      #[doc = ""]
      #[doc = "then, it will be _put_ on chain."]
      #[doc = ""]
      #[doc = "A solution consists of two pieces of data:"]
      #[doc = ""]
      #[doc = "1. `winners`: a flat vector of all the winners of the round."]
      #[doc = "2. `assignments`: the compact version of an assignment vector that encodes the edge"]
      #[doc = "   weights."]
      #[doc = ""]
      #[doc = "Both of which may be computed using _phragmen_, or any other algorithm."]
      #[doc = ""]
      #[doc = "Additionally, the submitter must provide:"]
      #[doc = ""]
      #[doc = "- The `score` that they claim their solution has."]
      #[doc = ""]
      #[doc = "Both validators and nominators will be represented by indices in the solution. The"]
      #[doc = "indices should respect the corresponding types ([`ValidatorIndex`] and"]
      #[doc = "[`NominatorIndex`]). Moreover, they should be valid when used to index into"]
      #[doc = "[`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the"]
      #[doc = "solution to be rejected. These two storage items are set during the election window and"]
      #[doc = "may be used to determine the indices."]
      #[doc = ""]
      #[doc = "A solution is valid if:"]
      #[doc = ""]
      #[doc = "0. It is submitted when [`EraElectionStatus`] is `Open`."]
      #[doc = "1. Its claimed score is equal to the score computed on-chain."]
      #[doc = "2. Presents the correct number of winners."]
      #[doc = "3. All indexes must be value according to the snapshot vectors. All edge values must"]
      #[doc = "   also be correct and should not overflow the granularity of the ratio type (i.e. 256"]
      #[doc = "   or billion)."]
      #[doc = "4. For each edge, all targets are actually nominated by the voter."]
      #[doc = "5. Has correct self-votes."]
      #[doc = ""]
      #[doc = "A solutions score is consisted of 3 parameters:"]
      #[doc = ""]
      #[doc = "1. `min { support.total }` for each support of a winner. This value should be maximized."]
      #[doc = "2. `sum { support.total }` for each support of a winner. This value should be minimized."]
      #[doc = "3. `sum { support.total^2 }` for each support of a winner. This value should be"]
      #[doc = "   minimized (to ensure less variance)"]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "The transaction is assumed to be the longest path, a better solution."]
      #[doc = "  - Initial solution is almost the same."]
      #[doc = "  - Worse solution is retraced in pre-dispatch-checks which sets its own weight."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn submit_election_solution(
        &self,
        winners: ::alloc::vec::Vec<u16>,
        compact: types::pallet_staking::CompactAssignments,
        score: types::sp_npos_elections::ElectionScore,
        era: u32,
        size: types::pallet_staking::ElectionSize,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 27u8];
        winners.encode_to(&mut buf);
        compact.encode_to(&mut buf);
        score.encode_to(&mut buf);
        era.encode_to(&mut buf);
        size.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Unsigned version of `submit_election_solution`."]
      #[doc = ""]
      #[doc = "Note that this must pass the [`ValidateUnsigned`] check which only allows transactions"]
      #[doc = "from the local node to be included. In other words, only the block author can include a"]
      #[doc = "transaction in the block."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "See [`submit_election_solution`]."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn submit_election_solution_unsigned(
        &self,
        winners: ::alloc::vec::Vec<u16>,
        compact: types::pallet_staking::CompactAssignments,
        score: types::sp_npos_elections::ElectionScore,
        era: u32,
        size: types::pallet_staking::ElectionSize,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::submit_election_solution_unsigned {
            winners,
            compact,
            score,
            era,
            size,
          },
        ))
      }
      #[doc = "Unsigned version of `submit_election_solution`."]
      #[doc = ""]
      #[doc = "Note that this must pass the [`ValidateUnsigned`] check which only allows transactions"]
      #[doc = "from the local node to be included. In other words, only the block author can include a"]
      #[doc = "transaction in the block."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "See [`submit_election_solution`]."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn submit_election_solution_unsigned(
        &self,
        winners: ::alloc::vec::Vec<u16>,
        compact: types::pallet_staking::CompactAssignments,
        score: types::sp_npos_elections::ElectionScore,
        era: u32,
        size: types::pallet_staking::ElectionSize,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 28u8];
        winners.encode_to(&mut buf);
        compact.encode_to(&mut buf);
        score.encode_to(&mut buf);
        era.encode_to(&mut buf);
        size.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "System version of `payout_stakers()`. Only be called by the root origin."]
      #[cfg(not(feature = "ink"))]
      pub fn payout_stakers_by_system(
        &self,
        validator_stash: ::polymesh_api_client::AccountId,
        era: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::payout_stakers_by_system {
            validator_stash,
            era,
          },
        ))
      }
      #[doc = "System version of `payout_stakers()`. Only be called by the root origin."]
      #[cfg(feature = "ink")]
      pub fn payout_stakers_by_system(
        &self,
        validator_stash: ::polymesh_api_client::AccountId,
        era: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 29u8];
        validator_stash.encode_to(&mut buf);
        era.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Switch slashing status on the basis of given `SlashingSwitch`. Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - AccountId of root."]
      #[doc = "* slashing_switch - Switch used to set the targets for slashing."]
      #[cfg(not(feature = "ink"))]
      pub fn change_slashing_allowed_for(
        &self,
        slashing_switch: types::pallet_staking::SlashingSwitch,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::change_slashing_allowed_for { slashing_switch },
        ))
      }
      #[doc = "Switch slashing status on the basis of given `SlashingSwitch`. Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - AccountId of root."]
      #[doc = "* slashing_switch - Switch used to set the targets for slashing."]
      #[cfg(feature = "ink")]
      pub fn change_slashing_allowed_for(
        &self,
        slashing_switch: types::pallet_staking::SlashingSwitch,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 30u8];
        slashing_switch.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Update the intended validator count for a given DID."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin which must be the required origin for adding a potential validator."]
      #[doc = "* identity to add as a validator."]
      #[doc = "* new_intended_count New value of intended count."]
      #[cfg(not(feature = "ink"))]
      pub fn update_permissioned_validator_intended_count(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        new_intended_count: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::update_permissioned_validator_intended_count {
            identity,
            new_intended_count,
          },
        ))
      }
      #[doc = "Update the intended validator count for a given DID."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin which must be the required origin for adding a potential validator."]
      #[doc = "* identity to add as a validator."]
      #[doc = "* new_intended_count New value of intended count."]
      #[cfg(feature = "ink")]
      pub fn update_permissioned_validator_intended_count(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        new_intended_count: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 31u8];
        identity.encode_to(&mut buf);
        new_intended_count.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "GC forcefully chills a validator."]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin which must be a GC."]
      #[doc = "* identity must be permissioned to run operator/validator nodes."]
      #[doc = "* stash_keys contains the secondary keys of the permissioned identity"]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` The origin was not a GC member."]
      #[doc = "* `CallNotAllowed` The call is not allowed at the given time due to restrictions of election period."]
      #[doc = "* `NotExists` Permissioned validator doesn't exist."]
      #[doc = "* `NotStash` Not a stash account for the permissioned identity."]
      #[cfg(not(feature = "ink"))]
      pub fn chill_from_governance(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        stash_keys: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Staking(
          types::pallet_staking::StakingCall::chill_from_governance {
            identity,
            stash_keys,
          },
        ))
      }
      #[doc = "GC forcefully chills a validator."]
      #[doc = "Effects will be felt at the beginning of the next era."]
      #[doc = "And, it can be only called when [`EraElectionStatus`] is `Closed`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin which must be a GC."]
      #[doc = "* identity must be permissioned to run operator/validator nodes."]
      #[doc = "* stash_keys contains the secondary keys of the permissioned identity"]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` The origin was not a GC member."]
      #[doc = "* `CallNotAllowed` The call is not allowed at the given time due to restrictions of election period."]
      #[doc = "* `NotExists` Permissioned validator doesn't exist."]
      #[doc = "* `NotStash` Not a stash account for the permissioned identity."]
      #[cfg(feature = "ink")]
      pub fn chill_from_governance(
        &self,
        identity: ::polymesh_api_client::IdentityId,
        stash_keys: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![17u8, 32u8];
        identity.encode_to(&mut buf);
        stash_keys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for StakingCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct StakingQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> StakingQueryApi<'api> {
      #[doc = " Number of eras to keep in history."]
      #[doc = ""]
      #[doc = " Information is kept for eras in `[current_era - history_depth; current_era]`."]
      #[doc = ""]
      #[doc = " Must be more than the number of eras delayed by session otherwise. I.e. active era must"]
      #[doc = " always be in history. I.e. `active_era > current_era - history_depth` must be"]
      #[doc = " guaranteed."]
      #[cfg(not(feature = "ink"))]
      pub async fn history_depth(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 172u8, 10u8, 44u8, 191u8, 142u8, 53u8, 95u8, 94u8, 166u8, 203u8, 45u8,
          232u8, 114u8, 123u8, 251u8, 12u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[84u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of eras to keep in history."]
      #[doc = ""]
      #[doc = " Information is kept for eras in `[current_era - history_depth; current_era]`."]
      #[doc = ""]
      #[doc = " Must be more than the number of eras delayed by session otherwise. I.e. active era must"]
      #[doc = " always be in history. I.e. `active_era > current_era - history_depth` must be"]
      #[doc = " guaranteed."]
      #[cfg(feature = "ink")]
      pub fn history_depth(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 172u8, 10u8, 44u8, 191u8, 142u8, 53u8, 95u8, 94u8, 166u8, 203u8, 45u8,
          232u8, 114u8, 123u8, 251u8, 12u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[84u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The ideal number of staking participants."]
      #[cfg(not(feature = "ink"))]
      pub async fn validator_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 19u8, 142u8, 113u8, 97u8, 36u8, 145u8, 25u8, 45u8, 104u8, 222u8, 171u8,
          126u8, 111u8, 86u8, 63u8, 225u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The ideal number of staking participants."]
      #[cfg(feature = "ink")]
      pub fn validator_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 19u8, 142u8, 113u8, 97u8, 36u8, 145u8, 25u8, 45u8, 104u8, 222u8, 171u8,
          126u8, 111u8, 86u8, 63u8, 225u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Minimum number of staking participants before emergency conditions are imposed."]
      #[cfg(not(feature = "ink"))]
      pub async fn minimum_validator_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 180u8, 154u8, 39u8, 56u8, 238u8, 179u8, 8u8, 150u8, 170u8, 203u8, 139u8,
          63u8, 180u8, 100u8, 113u8, 189u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Minimum number of staking participants before emergency conditions are imposed."]
      #[cfg(feature = "ink")]
      pub fn minimum_validator_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 180u8, 154u8, 39u8, 56u8, 238u8, 179u8, 8u8, 150u8, 170u8, 203u8, 139u8,
          63u8, 180u8, 100u8, 113u8, 189u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're"]
      #[doc = " easy to initialize and the performance hit is minimal (we expect no more than four"]
      #[doc = " invulnerables) and restricted to testnets."]
      #[cfg(not(feature = "ink"))]
      pub async fn invulnerables(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::AccountId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 85u8, 121u8, 41u8, 127u8, 77u8, 251u8, 150u8, 9u8, 231u8, 228u8, 194u8,
          235u8, 171u8, 156u8, 228u8, 10u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're"]
      #[doc = " easy to initialize and the performance hit is minimal (we expect no more than four"]
      #[doc = " invulnerables) and restricted to testnets."]
      #[cfg(feature = "ink")]
      pub fn invulnerables(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::AccountId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 85u8, 121u8, 41u8, 127u8, 77u8, 251u8, 150u8, 9u8, 231u8, 228u8, 194u8,
          235u8, 171u8, 156u8, 228u8, 10u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Map from all locked \"stash\" accounts to the controller account."]
      #[cfg(not(feature = "ink"))]
      pub async fn bonded(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 62u8, 209u8, 75u8, 69u8, 237u8, 32u8, 208u8, 84u8, 240u8, 94u8, 55u8,
          226u8, 84u8, 44u8, 254u8, 112u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Map from all locked \"stash\" accounts to the controller account."]
      #[cfg(feature = "ink")]
      pub fn bonded(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 62u8, 209u8, 75u8, 69u8, 237u8, 32u8, 208u8, 84u8, 240u8, 94u8, 55u8,
          226u8, 84u8, 44u8, 254u8, 112u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."]
      #[cfg(not(feature = "ink"))]
      pub async fn ledger(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_staking::StakingLedger<::polymesh_api_client::AccountId, u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 66u8, 42u8, 219u8, 87u8, 159u8, 29u8, 191u8, 79u8, 56u8, 134u8, 197u8,
          207u8, 163u8, 187u8, 140u8, 196u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."]
      #[cfg(feature = "ink")]
      pub fn ledger(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_staking::StakingLedger<::polymesh_api_client::AccountId, u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 66u8, 42u8, 219u8, 87u8, 159u8, 29u8, 191u8, 79u8, 56u8, 134u8, 197u8,
          207u8, 163u8, 187u8, 140u8, 196u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Where the reward payment should be made. Keyed by stash."]
      #[cfg(not(feature = "ink"))]
      pub async fn payee(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 146u8, 32u8, 225u8, 114u8, 190u8, 211u8, 22u8, 96u8, 95u8, 115u8, 241u8,
          255u8, 123u8, 74u8, 222u8, 152u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Where the reward payment should be made. Keyed by stash."]
      #[cfg(feature = "ink")]
      pub fn payee(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 146u8, 32u8, 225u8, 114u8, 190u8, 211u8, 22u8, 96u8, 95u8, 115u8, 241u8,
          255u8, 123u8, 74u8, 222u8, 152u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The map from (wannabe) validator stash key to the preferences of that validator."]
      #[cfg(not(feature = "ink"))]
      pub async fn validators(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::ValidatorPrefs> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
          252u8, 214u8, 225u8, 105u8, 3u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The map from (wannabe) validator stash key to the preferences of that validator."]
      #[cfg(feature = "ink")]
      pub fn validators(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::ValidatorPrefs> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
          252u8, 214u8, 225u8, 105u8, 3u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The map from nominator stash key to the set of stash keys of all validators to nominate."]
      #[cfg(not(feature = "ink"))]
      pub async fn nominators(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_staking::Nominations<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 156u8, 106u8, 99u8, 127u8, 98u8, 174u8, 42u8, 241u8, 199u8, 227u8, 30u8,
          237u8, 126u8, 150u8, 190u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The map from nominator stash key to the set of stash keys of all validators to nominate."]
      #[cfg(feature = "ink")]
      pub fn nominators(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_staking::Nominations<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 156u8, 106u8, 99u8, 127u8, 98u8, 174u8, 42u8, 241u8, 199u8, 227u8, 30u8,
          237u8, 126u8, 150u8, 190u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The current era index."]
      #[doc = ""]
      #[doc = " This is the latest planned era, depending on how the Session pallet queues the validator"]
      #[doc = " set, it might be active or not."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_era(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 11u8, 106u8, 69u8, 50u8, 30u8, 250u8, 233u8, 42u8, 234u8, 21u8, 224u8,
          116u8, 14u8, 199u8, 175u8, 231u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The current era index."]
      #[doc = ""]
      #[doc = " This is the latest planned era, depending on how the Session pallet queues the validator"]
      #[doc = " set, it might be active or not."]
      #[cfg(feature = "ink")]
      pub fn current_era(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 11u8, 106u8, 69u8, 50u8, 30u8, 250u8, 233u8, 42u8, 234u8, 21u8, 224u8,
          116u8, 14u8, 199u8, 175u8, 231u8,
        ])?;
        Ok(value)
      }
      #[doc = " The active era information, it holds index and start."]
      #[doc = ""]
      #[doc = " The active era is the era being currently rewarded. Validator set of this era must be"]
      #[doc = " equal to [`SessionInterface::validators`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_era(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_staking::ActiveEraInfo>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 72u8, 125u8, 244u8, 100u8, 228u8, 74u8, 83u8, 75u8, 166u8, 176u8, 203u8,
          179u8, 36u8, 7u8, 181u8, 135u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The active era information, it holds index and start."]
      #[doc = ""]
      #[doc = " The active era is the era being currently rewarded. Validator set of this era must be"]
      #[doc = " equal to [`SessionInterface::validators`]."]
      #[cfg(feature = "ink")]
      pub fn active_era(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_staking::ActiveEraInfo>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 72u8, 125u8, 244u8, 100u8, 228u8, 74u8, 83u8, 75u8, 166u8, 176u8, 203u8,
          179u8, 36u8, 7u8, 181u8, 135u8,
        ])?;
        Ok(value)
      }
      #[doc = " The session index at which the era start for the last `HISTORY_DEPTH` eras."]
      #[doc = ""]
      #[doc = " Note: This tracks the starting session (i.e. session index when era start being active)"]
      #[doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_start_session_index(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 173u8, 129u8, 28u8, 214u8, 90u8, 71u8, 13u8, 220u8, 95u8, 29u8, 98u8,
          143u8, 240u8, 85u8, 9u8, 130u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The session index at which the era start for the last `HISTORY_DEPTH` eras."]
      #[doc = ""]
      #[doc = " Note: This tracks the starting session (i.e. session index when era start being active)"]
      #[doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."]
      #[cfg(feature = "ink")]
      pub fn eras_start_session_index(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 173u8, 129u8, 28u8, 214u8, 90u8, 71u8, 13u8, 220u8, 95u8, 29u8, 98u8,
          143u8, 240u8, 85u8, 9u8, 130u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Exposure of validator at era."]
      #[doc = ""]
      #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_stakers(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 139u8, 222u8, 10u8, 14u8, 168u8, 134u8, 70u8, 5u8, 227u8, 182u8, 142u8,
          217u8, 203u8, 45u8, 160u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
          <types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Exposure of validator at era."]
      #[doc = ""]
      #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
      #[cfg(feature = "ink")]
      pub fn eras_stakers(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 139u8, 222u8, 10u8, 14u8, 168u8, 134u8, 70u8, 5u8, 227u8, 182u8, 142u8,
          217u8, 203u8, 45u8, 160u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
          <types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Clipped Exposure of validator at era."]
      #[doc = ""]
      #[doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"]
      #[doc = " `T::MaxNominatorRewardedPerValidator` biggest stakers."]
      #[doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."]
      #[doc = " This is used to limit the i/o cost for the nominator payout."]
      #[doc = ""]
      #[doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_stakers_clipped(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 66u8, 152u8, 43u8, 157u8, 108u8, 122u8, 204u8, 153u8, 250u8, 169u8, 9u8,
          76u8, 145u8, 35u8, 114u8, 194u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
          <types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Clipped Exposure of validator at era."]
      #[doc = ""]
      #[doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"]
      #[doc = " `T::MaxNominatorRewardedPerValidator` biggest stakers."]
      #[doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."]
      #[doc = " This is used to limit the i/o cost for the nominator payout."]
      #[doc = ""]
      #[doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
      #[cfg(feature = "ink")]
      pub fn eras_stakers_clipped(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 66u8, 152u8, 43u8, 157u8, 108u8, 122u8, 204u8, 153u8, 250u8, 169u8, 9u8,
          76u8, 145u8, 35u8, 114u8, 194u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
          <types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Similar to `ErasStakers`, this holds the preferences of validators."]
      #[doc = ""]
      #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_validator_prefs(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::ValidatorPrefs> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 104u8, 45u8, 185u8, 45u8, 222u8, 32u8, 161u8, 13u8, 150u8, 208u8, 15u8,
          240u8, 233u8, 226u8, 33u8, 192u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Similar to `ErasStakers`, this holds the preferences of validators."]
      #[doc = ""]
      #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
      #[doc = ""]
      #[doc = " Is it removed after `HISTORY_DEPTH` eras."]
      #[cfg(feature = "ink")]
      pub fn eras_validator_prefs(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::ValidatorPrefs> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 104u8, 45u8, 185u8, 45u8, 222u8, 32u8, 161u8, 13u8, 150u8, 208u8, 15u8,
          240u8, 233u8, 226u8, 33u8, 192u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total validator era payout for the last `HISTORY_DEPTH` eras."]
      #[doc = ""]
      #[doc = " Eras that haven't finished yet or has been removed doesn't have reward."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_validator_reward(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<Option<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 126u8, 110u8, 210u8, 238u8, 80u8, 124u8, 123u8, 68u8, 65u8, 213u8, 158u8,
          77u8, 237u8, 68u8, 184u8, 162u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The total validator era payout for the last `HISTORY_DEPTH` eras."]
      #[doc = ""]
      #[doc = " Eras that haven't finished yet or has been removed doesn't have reward."]
      #[cfg(feature = "ink")]
      pub fn eras_validator_reward(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<Option<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 126u8, 110u8, 210u8, 238u8, 80u8, 124u8, 123u8, 68u8, 65u8, 213u8, 158u8,
          77u8, 237u8, 68u8, 184u8, 162u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Rewards for the last `HISTORY_DEPTH` eras."]
      #[doc = " If reward hasn't been set or has been removed then 0 reward is returned."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_reward_points(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 128u8, 204u8, 101u8, 116u8, 40u8, 22u8, 113u8, 178u8, 153u8, 193u8, 114u8,
          125u8, 122u8, 198u8, 140u8, 171u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8];
          <types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Rewards for the last `HISTORY_DEPTH` eras."]
      #[doc = " If reward hasn't been set or has been removed then 0 reward is returned."]
      #[cfg(feature = "ink")]
      pub fn eras_reward_points(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<
        types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 128u8, 204u8, 101u8, 116u8, 40u8, 22u8, 113u8, 178u8, 153u8, 193u8, 114u8,
          125u8, 122u8, 198u8, 140u8, 171u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8];
          <types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The total amount staked for the last `HISTORY_DEPTH` eras."]
      #[doc = " If total hasn't been set or has been removed then 0 stake is returned."]
      #[cfg(not(feature = "ink"))]
      pub async fn eras_total_stake(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 161u8, 65u8, 196u8, 254u8, 103u8, 194u8, 209u8, 31u8, 74u8, 16u8, 198u8,
          172u8, 167u8, 167u8, 154u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total amount staked for the last `HISTORY_DEPTH` eras."]
      #[doc = " If total hasn't been set or has been removed then 0 stake is returned."]
      #[cfg(feature = "ink")]
      pub fn eras_total_stake(&self, key_0: u32) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 161u8, 65u8, 196u8, 254u8, 103u8, 194u8, 209u8, 31u8, 74u8, 16u8, 198u8,
          172u8, 167u8, 167u8, 154u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Mode of era forcing."]
      #[cfg(not(feature = "ink"))]
      pub async fn force_era(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::Forcing> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 247u8, 218u8, 208u8, 49u8, 115u8, 36u8, 174u8, 202u8, 232u8, 116u8, 75u8,
          135u8, 252u8, 149u8, 242u8, 243u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::Forcing>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Mode of era forcing."]
      #[cfg(feature = "ink")]
      pub fn force_era(&self) -> ::polymesh_api_ink::error::Result<types::pallet_staking::Forcing> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 247u8, 218u8, 208u8, 49u8, 115u8, 36u8, 174u8, 202u8, 232u8, 116u8, 75u8,
          135u8, 252u8, 149u8, 242u8, 243u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::Forcing>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The percentage of the slash that is distributed to reporters."]
      #[doc = ""]
      #[doc = " The rest of the slashed value is handled by the `Slash`."]
      #[cfg(not(feature = "ink"))]
      pub async fn slash_reward_fraction(
        &self,
      ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Perbill> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 194u8, 154u8, 3u8, 16u8, 225u8, 187u8, 69u8, 210u8, 12u8, 172u8, 231u8,
          124u8, 203u8, 98u8, 201u8, 125u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The percentage of the slash that is distributed to reporters."]
      #[doc = ""]
      #[doc = " The rest of the slashed value is handled by the `Slash`."]
      #[cfg(feature = "ink")]
      pub fn slash_reward_fraction(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Perbill> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 194u8, 154u8, 3u8, 16u8, 225u8, 187u8, 69u8, 210u8, 12u8, 172u8, 231u8,
          124u8, 203u8, 98u8, 201u8, 125u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The amount of currency given to reporters of a slash event which was"]
      #[doc = " canceled by extraordinary circumstances (e.g. governance)."]
      #[cfg(not(feature = "ink"))]
      pub async fn canceled_slash_payout(&self) -> ::polymesh_api_client::error::Result<u128> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 40u8, 220u8, 203u8, 85u8, 155u8, 149u8, 196u8, 1u8, 104u8, 161u8, 178u8,
          105u8, 101u8, 129u8, 181u8, 167u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The amount of currency given to reporters of a slash event which was"]
      #[doc = " canceled by extraordinary circumstances (e.g. governance)."]
      #[cfg(feature = "ink")]
      pub fn canceled_slash_payout(&self) -> ::polymesh_api_ink::error::Result<u128> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 40u8, 220u8, 203u8, 85u8, 155u8, 149u8, 196u8, 1u8, 104u8, 161u8, 178u8,
          105u8, 101u8, 129u8, 181u8, 167u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All unapplied slashes that are queued for later."]
      #[cfg(not(feature = "ink"))]
      pub async fn unapplied_slashes(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<
          types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 4u8, 40u8, 36u8, 23u8, 10u8, 93u8, 180u8, 56u8, 31u8, 227u8, 57u8, 80u8,
          57u8, 202u8, 189u8, 36u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
            types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " All unapplied slashes that are queued for later."]
      #[cfg(feature = "ink")]
      pub fn unapplied_slashes(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<
          types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 4u8, 40u8, 36u8, 23u8, 10u8, 93u8, 180u8, 56u8, 31u8, 227u8, 57u8, 80u8,
          57u8, 202u8, 189u8, 36u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
            types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " A mapping from still-bonded eras to the first session index of that era."]
      #[doc = ""]
      #[doc = " Must contains information for eras for the range:"]
      #[doc = " `[active_era - bounding_duration; active_era]`"]
      #[cfg(not(feature = "ink"))]
      pub async fn bonded_eras(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<(u32, u32)>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 234u8, 7u8, 222u8, 43u8, 143u8, 1u8, 5u8, 22u8, 220u8, 163u8, 247u8, 239u8,
          82u8, 247u8, 172u8, 90u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A mapping from still-bonded eras to the first session index of that era."]
      #[doc = ""]
      #[doc = " Must contains information for eras for the range:"]
      #[doc = " `[active_era - bounding_duration; active_era]`"]
      #[cfg(feature = "ink")]
      pub fn bonded_eras(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<(u32, u32)>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 234u8, 7u8, 222u8, 43u8, 143u8, 1u8, 5u8, 22u8, 220u8, 163u8, 247u8, 239u8,
          82u8, 247u8, 172u8, 90u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All slashing events on validators, mapped by era to the highest slash proportion"]
      #[doc = " and slash value of the era."]
      #[cfg(not(feature = "ink"))]
      pub async fn validator_slash_in_era(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<(::polymesh_api_client::per_things::Perbill, u128)>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 173u8, 110u8, 21u8, 238u8, 123u8, 253u8, 93u8, 85u8, 235u8, 161u8, 1u8,
          36u8, 135u8, 211u8, 175u8, 84u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All slashing events on validators, mapped by era to the highest slash proportion"]
      #[doc = " and slash value of the era."]
      #[cfg(feature = "ink")]
      pub fn validator_slash_in_era(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<(::polymesh_api_client::per_things::Perbill, u128)>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 173u8, 110u8, 21u8, 238u8, 123u8, 253u8, 93u8, 85u8, 235u8, 161u8, 1u8,
          36u8, 135u8, 211u8, 175u8, 84u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."]
      #[cfg(not(feature = "ink"))]
      pub async fn nominator_slash_in_era(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 129u8, 80u8, 8u8, 232u8, 33u8, 11u8, 109u8, 108u8, 247u8, 1u8, 226u8, 46u8,
          91u8, 242u8, 113u8, 65u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."]
      #[cfg(feature = "ink")]
      pub fn nominator_slash_in_era(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 129u8, 80u8, 8u8, 232u8, 33u8, 11u8, 109u8, 108u8, 247u8, 1u8, 226u8, 46u8,
          91u8, 242u8, 113u8, 65u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Slashing spans for stash accounts."]
      #[cfg(not(feature = "ink"))]
      pub async fn slashing_spans(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_staking::slashing::SlashingSpans>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 171u8, 106u8, 33u8, 43u8, 192u8, 138u8, 86u8, 3u8, 130u8, 143u8, 51u8,
          249u8, 14u8, 196u8, 161u8, 57u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Slashing spans for stash accounts."]
      #[cfg(feature = "ink")]
      pub fn slashing_spans(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_staking::slashing::SlashingSpans>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 171u8, 106u8, 33u8, 43u8, 192u8, 138u8, 86u8, 3u8, 130u8, 143u8, 51u8,
          249u8, 14u8, 196u8, 161u8, 57u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Records information about the maximum slash of a stash within a slashing span,"]
      #[doc = " as well as how much reward has been paid out."]
      #[cfg(not(feature = "ink"))]
      pub async fn span_slash(
        &self,
        key_0: (::polymesh_api_client::AccountId, u32),
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::slashing::SpanRecord<u128>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 230u8, 47u8, 111u8, 121u8, 126u8, 190u8, 145u8, 56u8, 223u8, 206u8, 217u8,
          66u8, 151u8, 127u8, 234u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::pallet_staking::slashing::SpanRecord<u128>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Records information about the maximum slash of a stash within a slashing span,"]
      #[doc = " as well as how much reward has been paid out."]
      #[cfg(feature = "ink")]
      pub fn span_slash(
        &self,
        key_0: (::polymesh_api_client::AccountId, u32),
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::slashing::SpanRecord<u128>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 230u8, 47u8, 111u8, 121u8, 126u8, 190u8, 145u8, 56u8, 223u8, 206u8, 217u8,
          66u8, 151u8, 127u8, 234u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::pallet_staking::slashing::SpanRecord<u128>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The earliest era for which we have a pending, unapplied slash."]
      #[cfg(not(feature = "ink"))]
      pub async fn earliest_unapplied_slash(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 96u8, 91u8, 44u8, 4u8, 107u8, 85u8, 9u8, 3u8, 127u8, 63u8, 21u8, 139u8,
          151u8, 65u8, 208u8, 55u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The earliest era for which we have a pending, unapplied slash."]
      #[cfg(feature = "ink")]
      pub fn earliest_unapplied_slash(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 96u8, 91u8, 44u8, 4u8, 107u8, 85u8, 9u8, 3u8, 127u8, 63u8, 21u8, 139u8,
          151u8, 65u8, 208u8, 55u8,
        ])?;
        Ok(value)
      }
      #[doc = " Indices of validators that have offended in the active era and whether they are currently"]
      #[doc = " disabled."]
      #[doc = ""]
      #[doc = " This value should be a superset of disabled validators since not all offences lead to the"]
      #[doc = " validator being disabled (if there was no slash). This is needed to track the percentage of"]
      #[doc = " validators that have offended in the current era, ensuring a new era is forced if"]
      #[doc = " `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find"]
      #[doc = " whether a given validator has previously offended using binary search. It gets cleared when"]
      #[doc = " the era ends."]
      #[cfg(not(feature = "ink"))]
      pub async fn offending_validators(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<(u32, bool)>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 162u8, 114u8, 27u8, 95u8, 220u8, 1u8, 159u8, 242u8, 72u8, 47u8, 145u8,
          114u8, 171u8, 136u8, 42u8, 120u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, bool)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Indices of validators that have offended in the active era and whether they are currently"]
      #[doc = " disabled."]
      #[doc = ""]
      #[doc = " This value should be a superset of disabled validators since not all offences lead to the"]
      #[doc = " validator being disabled (if there was no slash). This is needed to track the percentage of"]
      #[doc = " validators that have offended in the current era, ensuring a new era is forced if"]
      #[doc = " `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find"]
      #[doc = " whether a given validator has previously offended using binary search. It gets cleared when"]
      #[doc = " the era ends."]
      #[cfg(feature = "ink")]
      pub fn offending_validators(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<(u32, bool)>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 162u8, 114u8, 27u8, 95u8, 220u8, 1u8, 159u8, 242u8, 72u8, 47u8, 145u8,
          114u8, 171u8, 136u8, 42u8, 120u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(u32, bool)>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Snapshot of validators at the beginning of the current election window. This should only"]
      #[doc = " have a value when [`EraElectionStatus`] == `ElectionStatus::Open(_)`."]
      #[cfg(not(feature = "ink"))]
      pub async fn snapshot_validators(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<::alloc::vec::Vec<::polymesh_api_client::AccountId>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 126u8, 0u8, 108u8, 38u8, 214u8, 156u8, 76u8, 151u8, 246u8, 86u8, 72u8,
          171u8, 129u8, 90u8, 39u8, 68u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Snapshot of validators at the beginning of the current election window. This should only"]
      #[doc = " have a value when [`EraElectionStatus`] == `ElectionStatus::Open(_)`."]
      #[cfg(feature = "ink")]
      pub fn snapshot_validators(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<::alloc::vec::Vec<::polymesh_api_client::AccountId>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 126u8, 0u8, 108u8, 38u8, 214u8, 156u8, 76u8, 151u8, 246u8, 86u8, 72u8,
          171u8, 129u8, 90u8, 39u8, 68u8,
        ])?;
        Ok(value)
      }
      #[doc = " Snapshot of nominators at the beginning of the current election window. This should only"]
      #[doc = " have a value when [`EraElectionStatus`] == `ElectionStatus::Open(_)`."]
      #[cfg(not(feature = "ink"))]
      pub async fn snapshot_nominators(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<::alloc::vec::Vec<::polymesh_api_client::AccountId>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 247u8, 226u8, 87u8, 201u8, 67u8, 111u8, 230u8, 126u8, 44u8, 77u8, 157u8,
          76u8, 237u8, 125u8, 69u8, 76u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Snapshot of nominators at the beginning of the current election window. This should only"]
      #[doc = " have a value when [`EraElectionStatus`] == `ElectionStatus::Open(_)`."]
      #[cfg(feature = "ink")]
      pub fn snapshot_nominators(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<::alloc::vec::Vec<::polymesh_api_client::AccountId>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 247u8, 226u8, 87u8, 201u8, 67u8, 111u8, 230u8, 126u8, 44u8, 77u8, 157u8,
          76u8, 237u8, 125u8, 69u8, 76u8,
        ])?;
        Ok(value)
      }
      #[doc = " The next validator set. At the end of an era, if this is available (potentially from the"]
      #[doc = " result of an offchain worker), it is immediately used. Otherwise, the on-chain election"]
      #[doc = " is executed."]
      #[cfg(not(feature = "ink"))]
      pub async fn queued_elected(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_staking::ElectionResult<::polymesh_api_client::AccountId, u128>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 80u8, 109u8, 34u8, 179u8, 53u8, 5u8, 182u8, 127u8, 82u8, 93u8, 129u8,
          189u8, 0u8, 91u8, 22u8, 135u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The next validator set. At the end of an era, if this is available (potentially from the"]
      #[doc = " result of an offchain worker), it is immediately used. Otherwise, the on-chain election"]
      #[doc = " is executed."]
      #[cfg(feature = "ink")]
      pub fn queued_elected(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_staking::ElectionResult<::polymesh_api_client::AccountId, u128>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 80u8, 109u8, 34u8, 179u8, 53u8, 5u8, 182u8, 127u8, 82u8, 93u8, 129u8,
          189u8, 0u8, 91u8, 22u8, 135u8,
        ])?;
        Ok(value)
      }
      #[doc = " The score of the current [`QueuedElected`]."]
      #[cfg(not(feature = "ink"))]
      pub async fn queued_score(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<types::sp_npos_elections::ElectionScore>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 179u8, 182u8, 147u8, 10u8, 243u8, 119u8, 186u8, 116u8, 247u8, 232u8, 55u8,
          158u8, 68u8, 178u8, 199u8, 127u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The score of the current [`QueuedElected`]."]
      #[cfg(feature = "ink")]
      pub fn queued_score(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::sp_npos_elections::ElectionScore>>
      {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 179u8, 182u8, 147u8, 10u8, 243u8, 119u8, 186u8, 116u8, 247u8, 232u8, 55u8,
          158u8, 68u8, 178u8, 199u8, 127u8,
        ])?;
        Ok(value)
      }
      #[doc = " Flag to control the execution of the offchain election. When `Open(_)`, we accept"]
      #[doc = " solutions to be submitted."]
      #[cfg(not(feature = "ink"))]
      pub async fn era_election_status(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::ElectionStatus<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 225u8, 121u8, 21u8, 119u8, 228u8, 239u8, 203u8, 8u8, 63u8, 220u8, 60u8,
          178u8, 30u8, 133u8, 178u8, 228u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::ElectionStatus<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Flag to control the execution of the offchain election. When `Open(_)`, we accept"]
      #[doc = " solutions to be submitted."]
      #[cfg(feature = "ink")]
      pub fn era_election_status(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::ElectionStatus<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 225u8, 121u8, 21u8, 119u8, 228u8, 239u8, 203u8, 8u8, 63u8, 220u8, 60u8,
          178u8, 30u8, 133u8, 178u8, 228u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::ElectionStatus<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if the current **planned** session is final. Note that this does not take era"]
      #[doc = " forcing into account."]
      #[cfg(not(feature = "ink"))]
      pub async fn is_current_session_final(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 163u8, 246u8, 221u8, 41u8, 154u8, 211u8, 175u8, 166u8, 133u8, 128u8, 162u8,
          90u8, 115u8, 246u8, 234u8, 191u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if the current **planned** session is final. Note that this does not take era"]
      #[doc = " forcing into account."]
      #[cfg(feature = "ink")]
      pub fn is_current_session_final(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 163u8, 246u8, 221u8, 41u8, 154u8, 211u8, 175u8, 166u8, 133u8, 128u8, 162u8,
          90u8, 115u8, 246u8, 234u8, 191u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Entities that are allowed to run operator/validator nodes."]
      #[cfg(not(feature = "ink"))]
      pub async fn permissioned_identity(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_staking::PermissionedIdentityPrefs>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 43u8, 183u8, 3u8, 134u8, 104u8, 250u8, 251u8, 247u8, 56u8, 149u8, 104u8,
          159u8, 128u8, 103u8, 131u8, 19u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Entities that are allowed to run operator/validator nodes."]
      #[cfg(feature = "ink")]
      pub fn permissioned_identity(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_staking::PermissionedIdentityPrefs>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 43u8, 183u8, 3u8, 134u8, 104u8, 250u8, 251u8, 247u8, 56u8, 149u8, 104u8,
          159u8, 128u8, 103u8, 131u8, 19u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Every validator has commission that should be in the range [0, Cap]."]
      #[cfg(not(feature = "ink"))]
      pub async fn validator_commission_cap(
        &self,
      ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Perbill> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 153u8, 11u8, 115u8, 89u8, 10u8, 47u8, 61u8, 123u8, 111u8, 250u8, 62u8, 6u8,
          47u8, 110u8, 11u8, 162u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Every validator has commission that should be in the range [0, Cap]."]
      #[cfg(feature = "ink")]
      pub fn validator_commission_cap(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Perbill> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 153u8, 11u8, 115u8, 89u8, 10u8, 47u8, 61u8, 123u8, 111u8, 250u8, 62u8, 6u8,
          47u8, 110u8, 11u8, 162u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum amount with which a validator can bond."]
      #[cfg(not(feature = "ink"))]
      pub async fn minimum_bond_threshold(&self) -> ::polymesh_api_client::error::Result<u128> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 241u8, 1u8, 231u8, 252u8, 155u8, 88u8, 8u8, 104u8, 205u8, 239u8, 247u8,
          179u8, 33u8, 130u8, 44u8, 147u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum amount with which a validator can bond."]
      #[cfg(feature = "ink")]
      pub fn minimum_bond_threshold(&self) -> ::polymesh_api_ink::error::Result<u128> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 241u8, 1u8, 231u8, 252u8, 155u8, 88u8, 8u8, 104u8, 205u8, 239u8, 247u8,
          179u8, 33u8, 130u8, 44u8, 147u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(not(feature = "ink"))]
      pub async fn slashing_allowed_for(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::SlashingSwitch> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 231u8, 118u8, 103u8, 194u8, 236u8, 24u8, 122u8, 5u8, 185u8, 143u8, 2u8,
          137u8, 239u8, 72u8, 161u8, 77u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[2u8];
          <types::pallet_staking::SlashingSwitch>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(feature = "ink")]
      pub fn slashing_allowed_for(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::SlashingSwitch> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 231u8, 118u8, 103u8, 194u8, 236u8, 24u8, 122u8, 5u8, 185u8, 143u8, 2u8,
          137u8, 239u8, 72u8, 161u8, 77u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[2u8];
          <types::pallet_staking::SlashingSwitch>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if network has been upgraded to this version."]
      #[doc = " Storage version of the pallet."]
      #[doc = ""]
      #[doc = " This is set to v6.0.1 for new networks."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::Releases> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8, 169u8,
          77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[6u8];
          <types::pallet_staking::Releases>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if network has been upgraded to this version."]
      #[doc = " Storage version of the pallet."]
      #[doc = ""]
      #[doc = " This is set to v6.0.1 for new networks."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::Releases> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8, 169u8,
          77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[6u8];
          <types::pallet_staking::Releases>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Polymesh Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn polymesh_storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_staking::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 229u8, 160u8, 23u8, 132u8, 8u8, 29u8, 246u8, 130u8, 198u8, 250u8, 110u8,
          217u8, 188u8, 5u8, 228u8, 207u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Polymesh Storage version."]
      #[cfg(feature = "ink")]
      pub fn polymesh_storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::Version> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8, 236u8, 236u8,
          237u8, 202u8, 229u8, 160u8, 23u8, 132u8, 8u8, 29u8, 246u8, 130u8, 198u8, 250u8, 110u8,
          217u8, 188u8, 5u8, 228u8, 207u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_staking::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod offences {
    use super::*;
    #[derive(Clone)]
    pub struct OffencesCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> OffencesCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for OffencesCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct OffencesQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> OffencesQueryApi<'api> {
      #[doc = " The primary structure that holds all offence records keyed by report identifiers."]
      #[cfg(not(feature = "ink"))]
      pub async fn reports(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::sp_staking::offence::OffenceDetails<
            ::polymesh_api_client::AccountId,
            (
              ::polymesh_api_client::AccountId,
              types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
            ),
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 178u8, 98u8, 233u8, 35u8, 143u8, 164u8, 2u8, 84u8, 12u8, 37u8, 11u8,
          195u8, 245u8, 214u8, 24u8, 141u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The primary structure that holds all offence records keyed by report identifiers."]
      #[cfg(feature = "ink")]
      pub fn reports(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::sp_staking::offence::OffenceDetails<
            ::polymesh_api_client::AccountId,
            (
              ::polymesh_api_client::AccountId,
              types::pallet_staking::Exposure<::polymesh_api_client::AccountId, u128>,
            ),
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 178u8, 98u8, 233u8, 35u8, 143u8, 164u8, 2u8, 84u8, 12u8, 37u8, 11u8,
          195u8, 245u8, 214u8, 24u8, 141u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A vector of reports of the same kind that happened at the same time slot."]
      #[cfg(not(feature = "ink"))]
      pub async fn concurrent_reports_index(
        &self,
        key_0: [u8; 16usize],
        key_1: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 96u8, 220u8, 142u8, 240u8, 0u8, 205u8, 189u8, 200u8, 89u8, 221u8,
          53u8, 34u8, 41u8, 206u8, 22u8, 251u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A vector of reports of the same kind that happened at the same time slot."]
      #[cfg(feature = "ink")]
      pub fn concurrent_reports_index(
        &self,
        key_0: [u8; 16usize],
        key_1: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 96u8, 220u8, 142u8, 240u8, 0u8, 205u8, 189u8, 200u8, 89u8, 221u8,
          53u8, 34u8, 41u8, 206u8, 22u8, 251u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Enumerates all reports of a kind along with the time they happened."]
      #[doc = ""]
      #[doc = " All reports are sorted by the time of offence."]
      #[doc = ""]
      #[doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"]
      #[doc = " different types are not supported at the moment so we are doing the manual serialization."]
      #[cfg(not(feature = "ink"))]
      pub async fn reports_by_kind_index(
        &self,
        key_0: [u8; 16usize],
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 53u8, 137u8, 192u8, 218u8, 197u8, 13u8, 166u8, 251u8, 58u8, 54u8,
          17u8, 235u8, 50u8, 188u8, 210u8, 126u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Enumerates all reports of a kind along with the time they happened."]
      #[doc = ""]
      #[doc = " All reports are sorted by the time of offence."]
      #[doc = ""]
      #[doc = " Note that the actual type of this mapping is `Vec<u8>`, this is because values of"]
      #[doc = " different types are not supported at the moment so we are doing the manual serialization."]
      #[cfg(feature = "ink")]
      pub fn reports_by_kind_index(
        &self,
        key_0: [u8; 16usize],
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8, 67u8,
          36u8, 242u8, 165u8, 53u8, 137u8, 192u8, 218u8, 197u8, 13u8, 166u8, 251u8, 58u8, 54u8,
          17u8, 235u8, 50u8, 188u8, 210u8, 126u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod session {
    use super::*;
    #[derive(Clone)]
    pub struct SessionCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> SessionCallApi<'api> {
      #[doc = "Sets the session key(s) of the function caller to `keys`."]
      #[doc = "Allows an account to set its session key prior to becoming a validator."]
      #[doc = "This doesn't take effect until the next session."]
      #[doc = ""]
      #[doc = "The dispatch origin of this function must be signed."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"]
      #[doc = "  fixed."]
      #[cfg(not(feature = "ink"))]
      pub fn set_keys(
        &self,
        keys: runtime::SessionKeys,
        proof: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Session(
          types::pallet_session::pallet::SessionCall::set_keys { keys, proof },
        ))
      }
      #[doc = "Sets the session key(s) of the function caller to `keys`."]
      #[doc = "Allows an account to set its session key prior to becoming a validator."]
      #[doc = "This doesn't take effect until the next session."]
      #[doc = ""]
      #[doc = "The dispatch origin of this function must be signed."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"]
      #[doc = "  fixed."]
      #[cfg(feature = "ink")]
      pub fn set_keys(
        &self,
        keys: runtime::SessionKeys,
        proof: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![19u8, 0u8];
        keys.encode_to(&mut buf);
        proof.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes any session key(s) of the function caller."]
      #[doc = ""]
      #[doc = "This doesn't take effect until the next session."]
      #[doc = ""]
      #[doc = "The dispatch origin of this function must be Signed and the account must be either be"]
      #[doc = "convertible to a validator ID using the chain's typical addressing system (this usually"]
      #[doc = "means being a controller account) or directly convertible into a validator ID (which"]
      #[doc = "usually means being a stash account)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"]
      #[doc = "  `T::Keys::key_ids()` which is fixed."]
      #[cfg(not(feature = "ink"))]
      pub fn purge_keys(&self) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Session(
          types::pallet_session::pallet::SessionCall::purge_keys,
        ))
      }
      #[doc = "Removes any session key(s) of the function caller."]
      #[doc = ""]
      #[doc = "This doesn't take effect until the next session."]
      #[doc = ""]
      #[doc = "The dispatch origin of this function must be Signed and the account must be either be"]
      #[doc = "convertible to a validator ID using the chain's typical addressing system (this usually"]
      #[doc = "means being a controller account) or directly convertible into a validator ID (which"]
      #[doc = "usually means being a stash account)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"]
      #[doc = "  `T::Keys::key_ids()` which is fixed."]
      #[cfg(feature = "ink")]
      pub fn purge_keys(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![19u8, 1u8])
      }
    }
    impl<'api> From<&'api super::super::Api> for SessionCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct SessionQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> SessionQueryApi<'api> {
      #[doc = " The current set of validators."]
      #[cfg(not(feature = "ink"))]
      pub async fn validators(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<::polymesh_api_client::AccountId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8,
          250u8, 252u8, 214u8, 225u8, 105u8, 3u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current set of validators."]
      #[cfg(feature = "ink")]
      pub fn validators(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<::polymesh_api_client::AccountId>>
      {
        let value = self.api.read_storage(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8,
          250u8, 252u8, 214u8, 225u8, 105u8, 3u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current index of the session."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_index(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 114u8, 118u8, 56u8, 0u8, 163u8, 106u8, 153u8, 253u8, 252u8, 124u8,
          16u8, 246u8, 65u8, 95u8, 110u8, 230u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Current index of the session."]
      #[cfg(feature = "ink")]
      pub fn current_index(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 114u8, 118u8, 56u8, 0u8, 163u8, 106u8, 153u8, 253u8, 252u8, 124u8,
          16u8, 246u8, 65u8, 95u8, 110u8, 230u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if the underlying economic identities or weighting behind the validators"]
      #[doc = " has changed in the queued validator set."]
      #[cfg(not(feature = "ink"))]
      pub async fn queued_changed(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 148u8, 80u8, 191u8, 164u8, 185u8, 106u8, 63u8, 167u8, 163u8, 200u8,
          244u8, 13u8, 166u8, 191u8, 50u8, 225u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " True if the underlying economic identities or weighting behind the validators"]
      #[doc = " has changed in the queued validator set."]
      #[cfg(feature = "ink")]
      pub fn queued_changed(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 148u8, 80u8, 191u8, 164u8, 185u8, 106u8, 63u8, 167u8, 163u8, 200u8,
          244u8, 13u8, 166u8, 191u8, 50u8, 225u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The queued keys for the next session. When the next session begins, these keys"]
      #[doc = " will be used to determine the validator's session keys."]
      #[cfg(not(feature = "ink"))]
      pub async fn queued_keys(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<(::polymesh_api_client::AccountId, runtime::SessionKeys)>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 224u8, 205u8, 208u8, 98u8, 230u8, 234u8, 242u8, 66u8, 149u8, 173u8,
          76u8, 207u8, 196u8, 29u8, 70u8, 9u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(::polymesh_api_client::AccountId, runtime::SessionKeys)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The queued keys for the next session. When the next session begins, these keys"]
      #[doc = " will be used to determine the validator's session keys."]
      #[cfg(feature = "ink")]
      pub fn queued_keys(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<(::polymesh_api_client::AccountId, runtime::SessionKeys)>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 224u8, 205u8, 208u8, 98u8, 230u8, 234u8, 242u8, 66u8, 149u8, 173u8,
          76u8, 207u8, 196u8, 29u8, 70u8, 9u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(::polymesh_api_client::AccountId, runtime::SessionKeys)>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Indices of disabled validators."]
      #[doc = ""]
      #[doc = " The vec is always kept sorted so that we can find whether a given validator is"]
      #[doc = " disabled using binary search. It gets cleared when `on_session_ending` returns"]
      #[doc = " a new set of identities."]
      #[cfg(not(feature = "ink"))]
      pub async fn disabled_validators(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 90u8, 154u8, 116u8, 190u8, 74u8, 90u8, 125u8, 246u8, 11u8, 1u8,
          166u8, 192u8, 50u8, 108u8, 94u8, 32u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Indices of disabled validators."]
      #[doc = ""]
      #[doc = " The vec is always kept sorted so that we can find whether a given validator is"]
      #[doc = " disabled using binary search. It gets cleared when `on_session_ending` returns"]
      #[doc = " a new set of identities."]
      #[cfg(feature = "ink")]
      pub fn disabled_validators(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 90u8, 154u8, 116u8, 190u8, 74u8, 90u8, 125u8, 246u8, 11u8, 1u8,
          166u8, 192u8, 50u8, 108u8, 94u8, 32u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next session keys for a validator."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_keys(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<runtime::SessionKeys>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 76u8, 1u8, 78u8, 107u8, 248u8, 184u8, 194u8, 192u8, 17u8, 231u8,
          41u8, 11u8, 133u8, 105u8, 107u8, 179u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The next session keys for a validator."]
      #[cfg(feature = "ink")]
      pub fn next_keys(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<runtime::SessionKeys>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 76u8, 1u8, 78u8, 107u8, 248u8, 184u8, 194u8, 192u8, 17u8, 231u8,
          41u8, 11u8, 133u8, 105u8, 107u8, 179u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."]
      #[cfg(not(feature = "ink"))]
      pub async fn key_owner(
        &self,
        key_0: (types::sp_core::crypto::KeyTypeId, ::alloc::vec::Vec<u8>),
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 114u8, 99u8, 128u8, 64u8, 70u8, 131u8, 252u8, 137u8, 232u8, 35u8,
          52u8, 80u8, 200u8, 170u8, 25u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."]
      #[cfg(feature = "ink")]
      pub fn key_owner(
        &self,
        key_0: (types::sp_core::crypto::KeyTypeId, ::alloc::vec::Vec<u8>),
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8, 127u8,
          201u8, 107u8, 160u8, 114u8, 99u8, 128u8, 64u8, 70u8, 131u8, 252u8, 137u8, 232u8, 35u8,
          52u8, 80u8, 200u8, 170u8, 25u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
  }
  pub mod authority_discovery {
    use super::*;
    #[derive(Clone)]
    pub struct AuthorityDiscoveryCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> AuthorityDiscoveryCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for AuthorityDiscoveryCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct AuthorityDiscoveryQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> AuthorityDiscoveryQueryApi<'api> {}
  }
  pub mod grandpa {
    use super::*;
    #[derive(Clone)]
    pub struct GrandpaCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> GrandpaCallApi<'api> {
      #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
      #[doc = "equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence"]
      #[doc = "will be reported."]
      #[cfg(not(feature = "ink"))]
      pub fn report_equivocation(
        &self,
        equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
          types::primitive_types::H256,
          u32,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Grandpa(
          types::pallet_grandpa::pallet::GrandpaCall::report_equivocation {
            equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
            key_owner_proof,
          },
        ))
      }
      #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
      #[doc = "equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence"]
      #[doc = "will be reported."]
      #[cfg(feature = "ink")]
      pub fn report_equivocation(
        &self,
        equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
          types::primitive_types::H256,
          u32,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![21u8, 0u8];
        equivocation_proof.encode_to(&mut buf);
        key_owner_proof.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
      #[doc = "equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence"]
      #[doc = "will be reported."]
      #[doc = ""]
      #[doc = "This extrinsic must be called unsigned and it is expected that only"]
      #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
      #[doc = "if the block author is defined it will be defined as the equivocation"]
      #[doc = "reporter."]
      #[cfg(not(feature = "ink"))]
      pub fn report_equivocation_unsigned(
        &self,
        equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
          types::primitive_types::H256,
          u32,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Grandpa(
          types::pallet_grandpa::pallet::GrandpaCall::report_equivocation_unsigned {
            equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
            key_owner_proof,
          },
        ))
      }
      #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
      #[doc = "equivocation proof and validate the given key ownership proof"]
      #[doc = "against the extracted offender. If both are valid, the offence"]
      #[doc = "will be reported."]
      #[doc = ""]
      #[doc = "This extrinsic must be called unsigned and it is expected that only"]
      #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
      #[doc = "if the block author is defined it will be defined as the equivocation"]
      #[doc = "reporter."]
      #[cfg(feature = "ink")]
      pub fn report_equivocation_unsigned(
        &self,
        equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
          types::primitive_types::H256,
          u32,
        >,
        key_owner_proof: types::sp_session::MembershipProof,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![21u8, 1u8];
        equivocation_proof.encode_to(&mut buf);
        key_owner_proof.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."]
      #[doc = ""]
      #[doc = "This will trigger a forced authority set change at the beginning of the next session, to"]
      #[doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"]
      #[doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."]
      #[doc = "The block production rate (which may be slowed down because of finality lagging) should"]
      #[doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"]
      #[doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"]
      #[doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"]
      #[doc = "block of all validators of the new authority set."]
      #[doc = ""]
      #[doc = "Only callable by root."]
      #[cfg(not(feature = "ink"))]
      pub fn note_stalled(
        &self,
        delay: u32,
        best_finalized_block_number: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Grandpa(
          types::pallet_grandpa::pallet::GrandpaCall::note_stalled {
            delay,
            best_finalized_block_number,
          },
        ))
      }
      #[doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."]
      #[doc = ""]
      #[doc = "This will trigger a forced authority set change at the beginning of the next session, to"]
      #[doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"]
      #[doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."]
      #[doc = "The block production rate (which may be slowed down because of finality lagging) should"]
      #[doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"]
      #[doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"]
      #[doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"]
      #[doc = "block of all validators of the new authority set."]
      #[doc = ""]
      #[doc = "Only callable by root."]
      #[cfg(feature = "ink")]
      pub fn note_stalled(
        &self,
        delay: u32,
        best_finalized_block_number: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![21u8, 2u8];
        delay.encode_to(&mut buf);
        best_finalized_block_number.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for GrandpaCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct GrandpaQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> GrandpaQueryApi<'api> {
      #[doc = " State of the current authority set."]
      #[cfg(not(feature = "ink"))]
      pub async fn state(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_grandpa::StoredState<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 243u8, 154u8, 16u8, 127u8, 45u8, 141u8, 56u8, 84u8, 201u8, 171u8,
          169u8, 176u8, 33u8, 244u8, 61u8, 156u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_grandpa::StoredState<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " State of the current authority set."]
      #[cfg(feature = "ink")]
      pub fn state(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_grandpa::StoredState<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 243u8, 154u8, 16u8, 127u8, 45u8, 141u8, 56u8, 84u8, 201u8, 171u8,
          169u8, 176u8, 33u8, 244u8, 61u8, 156u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_grandpa::StoredState<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Pending change: (signaled at, scheduled change)."]
      #[cfg(not(feature = "ink"))]
      pub async fn pending_change(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_grandpa::StoredPendingChange<u32>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 47u8, 246u8, 89u8, 145u8, 177u8, 201u8, 21u8, 221u8, 108u8, 200u8,
          212u8, 130u8, 94u8, 172u8, 252u8, 180u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Pending change: (signaled at, scheduled change)."]
      #[cfg(feature = "ink")]
      pub fn pending_change(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_grandpa::StoredPendingChange<u32>>>
      {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 47u8, 246u8, 89u8, 145u8, 177u8, 201u8, 21u8, 221u8, 108u8, 200u8,
          212u8, 130u8, 94u8, 172u8, 252u8, 180u8,
        ])?;
        Ok(value)
      }
      #[doc = " next block number where we can force a change."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_forced(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 1u8, 215u8, 129u8, 129u8, 38u8, 189u8, 155u8, 48u8, 116u8, 128u8,
          62u8, 145u8, 244u8, 201u8, 27u8, 89u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " next block number where we can force a change."]
      #[cfg(feature = "ink")]
      pub fn next_forced(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 1u8, 215u8, 129u8, 129u8, 38u8, 189u8, 155u8, 48u8, 116u8, 128u8,
          62u8, 145u8, 244u8, 201u8, 27u8, 89u8,
        ])?;
        Ok(value)
      }
      #[doc = " `true` if we are currently stalled."]
      #[cfg(not(feature = "ink"))]
      pub async fn stalled(&self) -> ::polymesh_api_client::error::Result<Option<(u32, u32)>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 125u8, 221u8, 1u8, 52u8, 97u8, 183u8, 44u8, 48u8, 4u8, 249u8, 192u8,
          202u8, 63u8, 175u8, 158u8, 190u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " `true` if we are currently stalled."]
      #[cfg(feature = "ink")]
      pub fn stalled(&self) -> ::polymesh_api_ink::error::Result<Option<(u32, u32)>> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 125u8, 221u8, 1u8, 52u8, 97u8, 183u8, 44u8, 48u8, 4u8, 249u8, 192u8,
          202u8, 63u8, 175u8, 158u8, 190u8,
        ])?;
        Ok(value)
      }
      #[doc = " The number of changes (both in terms of keys and underlying economic responsibilities)"]
      #[doc = " in the \"set\" of Grandpa validators from genesis."]
      #[cfg(not(feature = "ink"))]
      pub async fn current_set_id(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 138u8, 45u8, 9u8, 70u8, 62u8, 255u8, 204u8, 120u8, 162u8, 45u8,
          117u8, 185u8, 203u8, 135u8, 223u8, 252u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The number of changes (both in terms of keys and underlying economic responsibilities)"]
      #[doc = " in the \"set\" of Grandpa validators from genesis."]
      #[cfg(feature = "ink")]
      pub fn current_set_id(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 138u8, 45u8, 9u8, 70u8, 62u8, 255u8, 204u8, 120u8, 162u8, 45u8,
          117u8, 185u8, 203u8, 135u8, 223u8, 252u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"]
      #[doc = " members were responsible."]
      #[doc = ""]
      #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
      #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
      #[doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"]
      #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
      #[doc = " during that session."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: `SetId` is not under user control."]
      #[cfg(not(feature = "ink"))]
      pub async fn set_id_session(
        &self,
        key_0: u64,
      ) -> ::polymesh_api_client::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8, 67u8, 221u8, 251u8,
          54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"]
      #[doc = " members were responsible."]
      #[doc = ""]
      #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
      #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
      #[doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"]
      #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
      #[doc = " during that session."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: `SetId` is not under user control."]
      #[cfg(feature = "ink")]
      pub fn set_id_session(&self, key_0: u64) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8, 9u8,
          150u8, 120u8, 220u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8, 67u8, 221u8, 251u8,
          54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
  }
  pub mod historical {
    use super::*;
    #[derive(Clone)]
    pub struct HistoricalCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> HistoricalCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for HistoricalCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct HistoricalQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> HistoricalQueryApi<'api> {}
  }
  pub mod im_online {
    use super::*;
    #[derive(Clone)]
    pub struct ImOnlineCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ImOnlineCallApi<'api> {
      #[doc = "## Complexity:"]
      #[doc = "- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of"]
      #[doc = "  `heartbeat.network_state.external_address`"]
      #[doc = "  - `O(K)`: decoding of length `K`"]
      #[doc = "  - `O(E)`: decoding/encoding of length `E`"]
      #[cfg(not(feature = "ink"))]
      pub fn heartbeat(
        &self,
        heartbeat: types::pallet_im_online::Heartbeat<u32>,
        signature: types::pallet_im_online::sr25519::app_sr25519::Signature,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ImOnline(
          types::pallet_im_online::pallet::ImOnlineCall::heartbeat {
            heartbeat,
            signature,
          },
        ))
      }
      #[doc = "## Complexity:"]
      #[doc = "- `O(K + E)` where K is length of `Keys` (heartbeat.validators_len) and E is length of"]
      #[doc = "  `heartbeat.network_state.external_address`"]
      #[doc = "  - `O(K)`: decoding of length `K`"]
      #[doc = "  - `O(E)`: decoding/encoding of length `E`"]
      #[cfg(feature = "ink")]
      pub fn heartbeat(
        &self,
        heartbeat: types::pallet_im_online::Heartbeat<u32>,
        signature: types::pallet_im_online::sr25519::app_sr25519::Signature,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![23u8, 0u8];
        heartbeat.encode_to(&mut buf);
        signature.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ImOnlineCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ImOnlineQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ImOnlineQueryApi<'api> {
      #[doc = " The block number after which it's ok to send heartbeats in the current"]
      #[doc = " session."]
      #[doc = ""]
      #[doc = " At the beginning of each session we set this to a value that should fall"]
      #[doc = " roughly in the middle of the session duration. The idea is to first wait for"]
      #[doc = " the validators to produce a block in the current session, so that the"]
      #[doc = " heartbeat later on will not be necessary."]
      #[doc = ""]
      #[doc = " This value will only be used as a fallback if we fail to get a proper session"]
      #[doc = " progress estimate from `NextSessionRotation`, as those estimates should be"]
      #[doc = " more accurate then the value we calculate for `HeartbeatAfter`."]
      #[cfg(not(feature = "ink"))]
      pub async fn heartbeat_after(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 138u8, 161u8, 242u8, 201u8, 132u8, 79u8, 17u8, 2u8, 76u8, 29u8,
          32u8, 78u8, 112u8, 90u8, 98u8, 23u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The block number after which it's ok to send heartbeats in the current"]
      #[doc = " session."]
      #[doc = ""]
      #[doc = " At the beginning of each session we set this to a value that should fall"]
      #[doc = " roughly in the middle of the session duration. The idea is to first wait for"]
      #[doc = " the validators to produce a block in the current session, so that the"]
      #[doc = " heartbeat later on will not be necessary."]
      #[doc = ""]
      #[doc = " This value will only be used as a fallback if we fail to get a proper session"]
      #[doc = " progress estimate from `NextSessionRotation`, as those estimates should be"]
      #[doc = " more accurate then the value we calculate for `HeartbeatAfter`."]
      #[cfg(feature = "ink")]
      pub fn heartbeat_after(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 138u8, 161u8, 242u8, 201u8, 132u8, 79u8, 17u8, 2u8, 76u8, 29u8,
          32u8, 78u8, 112u8, 90u8, 98u8, 23u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The current set of keys that may issue a heartbeat."]
      #[cfg(not(feature = "ink"))]
      pub async fn keys(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
          types::pallet_im_online::sr25519::app_sr25519::Public,
        >,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 159u8, 153u8, 162u8, 206u8, 113u8, 31u8, 58u8, 49u8, 178u8, 252u8,
          5u8, 96u8, 76u8, 147u8, 241u8, 121u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
            types::pallet_im_online::sr25519::app_sr25519::Public,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The current set of keys that may issue a heartbeat."]
      #[cfg(feature = "ink")]
      pub fn keys(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
          types::pallet_im_online::sr25519::app_sr25519::Public,
        >,
      > {
        let value = self.api.read_storage(::alloc::vec![
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 159u8, 153u8, 162u8, 206u8, 113u8, 31u8, 58u8, 49u8, 178u8, 252u8,
          5u8, 96u8, 76u8, 147u8, 241u8, 121u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
            types::pallet_im_online::sr25519::app_sr25519::Public,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to"]
      #[doc = " `WrapperOpaque<BoundedOpaqueNetworkState>`."]
      #[cfg(not(feature = "ink"))]
      pub async fn received_heartbeats(
        &self,
        key_0: u32,
        key_1: u32,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::frame_support::traits::misc::WrapperOpaque<
            types::pallet_im_online::BoundedOpaqueNetworkState,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 204u8, 90u8, 26u8, 166u8, 227u8, 113u8, 99u8, 114u8, 243u8, 110u8,
          241u8, 3u8, 183u8, 227u8, 174u8, 103u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to"]
      #[doc = " `WrapperOpaque<BoundedOpaqueNetworkState>`."]
      #[cfg(feature = "ink")]
      pub fn received_heartbeats(
        &self,
        key_0: u32,
        key_1: u32,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::frame_support::traits::misc::WrapperOpaque<
            types::pallet_im_online::BoundedOpaqueNetworkState,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 204u8, 90u8, 26u8, 166u8, 227u8, 113u8, 99u8, 114u8, 243u8, 110u8,
          241u8, 3u8, 183u8, 227u8, 174u8, 103u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"]
      #[doc = " number of blocks authored by the given authority."]
      #[cfg(not(feature = "ink"))]
      pub async fn authored_blocks(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 177u8, 195u8, 113u8, 222u8, 217u8, 233u8, 197u8, 101u8, 232u8,
          155u8, 167u8, 131u8, 196u8, 213u8, 245u8, 249u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"]
      #[doc = " number of blocks authored by the given authority."]
      #[cfg(feature = "ink")]
      pub fn authored_blocks(
        &self,
        key_0: u32,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8, 141u8,
          221u8, 155u8, 148u8, 177u8, 195u8, 113u8, 222u8, 217u8, 233u8, 197u8, 101u8, 232u8,
          155u8, 167u8, 131u8, 196u8, 213u8, 245u8, 249u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod randomness_collective_flip {
    use super::*;
    #[derive(Clone)]
    pub struct RandomnessCollectiveFlipCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> RandomnessCollectiveFlipCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for RandomnessCollectiveFlipCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct RandomnessCollectiveFlipQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> RandomnessCollectiveFlipQueryApi<'api> {
      #[doc = " Series of block headers from the last 81 blocks that acts as random seed material. This"]
      #[doc = " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of"]
      #[doc = " the oldest hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn random_material(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::bounded_collections::bounded_vec::BoundedVec<types::primitive_types::H256>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          189u8, 42u8, 82u8, 147u8, 121u8, 71u8, 80u8, 136u8, 211u8, 226u8, 154u8, 145u8, 140u8,
          212u8, 120u8, 114u8, 26u8, 57u8, 236u8, 118u8, 123u8, 213u8, 38u8, 145u8, 17u8, 230u8,
          73u8, 42u8, 22u8, 117u8, 112u8, 42u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_vec::BoundedVec<
                        types::primitive_types::H256,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Series of block headers from the last 81 blocks that acts as random seed material. This"]
      #[doc = " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of"]
      #[doc = " the oldest hash."]
      #[cfg(feature = "ink")]
      pub fn random_material(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::bounded_collections::bounded_vec::BoundedVec<types::primitive_types::H256>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          189u8, 42u8, 82u8, 147u8, 121u8, 71u8, 80u8, 136u8, 211u8, 226u8, 154u8, 145u8, 140u8,
          212u8, 120u8, 114u8, 26u8, 57u8, 236u8, 118u8, 123u8, 213u8, 38u8, 145u8, 17u8, 230u8,
          73u8, 42u8, 22u8, 117u8, 112u8, 42u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_vec::BoundedVec<
                        types::primitive_types::H256,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
    }
  }
  pub mod sudo {
    use super::*;
    #[derive(Clone)]
    pub struct SudoCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> SudoCallApi<'api> {
      #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- Limited storage reads."]
      #[doc = "- One DB write (event)."]
      #[doc = "- Weight of derivative `call` execution + 10,000."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn sudo(
        &self,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sudo(
          types::pallet_sudo::SudoCall::sudo {
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- Limited storage reads."]
      #[doc = "- One DB write (event)."]
      #[doc = "- Weight of derivative `call` execution + 10,000."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn sudo(&self, call: runtime::RuntimeCall) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![25u8, 0u8];
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
      #[doc = "This function does not check the weight of the call, and instead allows the"]
      #[doc = "Sudo user to specify the weight of the call."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- The weight of this call is defined by the caller."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn sudo_unchecked_weight(
        &self,
        call: runtime::RuntimeCall,
        _weight: ::polymesh_api_client::sp_weights::Weight,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sudo(
          types::pallet_sudo::SudoCall::sudo_unchecked_weight {
            call: ::alloc::boxed::Box::new(call),
            _weight,
          },
        ))
      }
      #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
      #[doc = "This function does not check the weight of the call, and instead allows the"]
      #[doc = "Sudo user to specify the weight of the call."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- The weight of this call is defined by the caller."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn sudo_unchecked_weight(
        &self,
        call: runtime::RuntimeCall,
        _weight: ::polymesh_api_client::sp_weights::Weight,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![25u8, 1u8];
        call.encode_to(&mut buf);
        _weight.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- Limited storage reads."]
      #[doc = "- One DB change."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn set_key(
        &self,
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sudo(
          types::pallet_sudo::SudoCall::set_key { new },
        ))
      }
      #[doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- Limited storage reads."]
      #[doc = "- One DB change."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn set_key(
        &self,
        new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![25u8, 2u8];
        new.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"]
      #[doc = "a given account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- Limited storage reads."]
      #[doc = "- One DB write (event)."]
      #[doc = "- Weight of derivative `call` execution + 10,000."]
      #[doc = "# </weight>"]
      #[cfg(not(feature = "ink"))]
      pub fn sudo_as(
        &self,
        who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sudo(
          types::pallet_sudo::SudoCall::sudo_as {
            who,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"]
      #[doc = "a given account."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Signed_."]
      #[doc = ""]
      #[doc = "# <weight>"]
      #[doc = "- O(1)."]
      #[doc = "- Limited storage reads."]
      #[doc = "- One DB write (event)."]
      #[doc = "- Weight of derivative `call` execution + 10,000."]
      #[doc = "# </weight>"]
      #[cfg(feature = "ink")]
      pub fn sudo_as(
        &self,
        who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![25u8, 3u8];
        who.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for SudoCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct SudoQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> SudoQueryApi<'api> {
      #[doc = " The `AccountId` of the sudo key."]
      #[cfg(not(feature = "ink"))]
      pub async fn key(
        &self,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          92u8, 13u8, 17u8, 118u8, 165u8, 104u8, 193u8, 249u8, 41u8, 68u8, 52u8, 13u8, 191u8,
          237u8, 158u8, 156u8, 83u8, 14u8, 188u8, 167u8, 3u8, 200u8, 89u8, 16u8, 231u8, 22u8, 76u8,
          183u8, 209u8, 201u8, 228u8, 123u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The `AccountId` of the sudo key."]
      #[cfg(feature = "ink")]
      pub fn key(
        &self,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>> {
        let value = self.api.read_storage(::alloc::vec![
          92u8, 13u8, 17u8, 118u8, 165u8, 104u8, 193u8, 249u8, 41u8, 68u8, 52u8, 13u8, 191u8,
          237u8, 158u8, 156u8, 83u8, 14u8, 188u8, 167u8, 3u8, 200u8, 89u8, 16u8, 231u8, 22u8, 76u8,
          183u8, 209u8, 201u8, 228u8, 123u8,
        ])?;
        Ok(value)
      }
    }
  }
  pub mod asset {
    use super::*;
    #[derive(Clone)]
    pub struct AssetCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> AssetCallApi<'api> {
      #[doc = "Registers a new ticker or extends validity of an existing ticker."]
      #[doc = "NB: Ticker validity does not get carry forward when renewing ticker."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `ticker` ticker to register."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn register_ticker(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::register_ticker { ticker },
        ))
      }
      #[doc = "Registers a new ticker or extends validity of an existing ticker."]
      #[doc = "NB: Ticker validity does not get carry forward when renewing ticker."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `ticker` ticker to register."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn register_ticker(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 0u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accepts a ticker transfer."]
      #[doc = ""]
      #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `auth_id` Authorization ID of ticker transfer authorization."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` is not a valid ticket transfer authorization."]
      #[doc = ""]
      #[cfg(not(feature = "ink"))]
      pub fn accept_ticker_transfer(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::accept_ticker_transfer { auth_id },
        ))
      }
      #[doc = "Accepts a ticker transfer."]
      #[doc = ""]
      #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `auth_id` Authorization ID of ticker transfer authorization."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` is not a valid ticket transfer authorization."]
      #[doc = ""]
      #[cfg(feature = "ink")]
      pub fn accept_ticker_transfer(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 1u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "This function is used to accept a token ownership transfer."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `auth_id` Authorization ID of the token ownership transfer authorization."]
      #[cfg(not(feature = "ink"))]
      pub fn accept_asset_ownership_transfer(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::accept_asset_ownership_transfer { auth_id },
        ))
      }
      #[doc = "This function is used to accept a token ownership transfer."]
      #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` It contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `auth_id` Authorization ID of the token ownership transfer authorization."]
      #[cfg(feature = "ink")]
      pub fn accept_asset_ownership_transfer(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 2u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Initializes a new security token, with the initiating account as its owner."]
      #[doc = "The total supply will initially be zero. To mint tokens, use `issue`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `name` - the name of the token."]
      #[doc = "* `ticker` - the ticker symbol of the token."]
      #[doc = "* `divisible` - a boolean to identify the divisibility status of the token."]
      #[doc = "* `asset_type` - the asset type."]
      #[doc = "* `identifiers` - a vector of asset identifiers."]
      #[doc = "* `funding_round` - name of the funding round."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `InvalidAssetIdentifier` if any of `identifiers` are invalid."]
      #[doc = "- `MaxLengthOfAssetNameExceeded` if `name`'s length exceeds `T::AssetNameMaxLength`."]
      #[doc = "- `FundingRoundNameMaxLengthExceeded` if the name of the funding round is longer that"]
      #[doc = "`T::FundingRoundNameMaxLength`."]
      #[doc = "- `AssetAlreadyCreated` if asset was already created."]
      #[doc = "- `TickerTooLong` if `ticker`'s length is greater than `config.max_ticker_length` chain"]
      #[doc = "parameter."]
      #[doc = "- `TickerNotAlphanumeric` if `ticker` is not yet registered, and contains non-alphanumeric characters or any character after first occurrence of `\\0`."]
      #[doc = ""]
      #[doc = "## Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn create_asset(
        &self,
        name: types::polymesh_primitives::asset::AssetName,
        ticker: types::polymesh_primitives::ticker::Ticker,
        divisible: bool,
        asset_type: types::polymesh_primitives::asset::AssetType,
        identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
        funding_round: Option<types::polymesh_primitives::asset::FundingRoundName>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::create_asset {
            name,
            ticker,
            divisible,
            asset_type,
            identifiers,
            funding_round,
          },
        ))
      }
      #[doc = "Initializes a new security token, with the initiating account as its owner."]
      #[doc = "The total supply will initially be zero. To mint tokens, use `issue`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `name` - the name of the token."]
      #[doc = "* `ticker` - the ticker symbol of the token."]
      #[doc = "* `divisible` - a boolean to identify the divisibility status of the token."]
      #[doc = "* `asset_type` - the asset type."]
      #[doc = "* `identifiers` - a vector of asset identifiers."]
      #[doc = "* `funding_round` - name of the funding round."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `InvalidAssetIdentifier` if any of `identifiers` are invalid."]
      #[doc = "- `MaxLengthOfAssetNameExceeded` if `name`'s length exceeds `T::AssetNameMaxLength`."]
      #[doc = "- `FundingRoundNameMaxLengthExceeded` if the name of the funding round is longer that"]
      #[doc = "`T::FundingRoundNameMaxLength`."]
      #[doc = "- `AssetAlreadyCreated` if asset was already created."]
      #[doc = "- `TickerTooLong` if `ticker`'s length is greater than `config.max_ticker_length` chain"]
      #[doc = "parameter."]
      #[doc = "- `TickerNotAlphanumeric` if `ticker` is not yet registered, and contains non-alphanumeric characters or any character after first occurrence of `\\0`."]
      #[doc = ""]
      #[doc = "## Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn create_asset(
        &self,
        name: types::polymesh_primitives::asset::AssetName,
        ticker: types::polymesh_primitives::ticker::Ticker,
        divisible: bool,
        asset_type: types::polymesh_primitives::asset::AssetType,
        identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
        funding_round: Option<types::polymesh_primitives::asset::FundingRoundName>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 3u8];
        name.encode_to(&mut buf);
        ticker.encode_to(&mut buf);
        divisible.encode_to(&mut buf);
        asset_type.encode_to(&mut buf);
        identifiers.encode_to(&mut buf);
        funding_round.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Freezes transfers and minting of a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `AlreadyFrozen` if `ticker` is already frozen."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn freeze(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::freeze { ticker },
        ))
      }
      #[doc = "Freezes transfers and minting of a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `AlreadyFrozen` if `ticker` is already frozen."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn freeze(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 4u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Unfreezes transfers and minting of a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the frozen token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `NotFrozen` if `ticker` is not frozen yet."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn unfreeze(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::unfreeze { ticker },
        ))
      }
      #[doc = "Unfreezes transfers and minting of a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the frozen token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `NotFrozen` if `ticker` is not frozen yet."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn unfreeze(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 5u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Renames a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `name` - the new name of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `MaxLengthOfAssetNameExceeded` if length of `name` is greater than"]
      #[doc = "`T::AssetNameMaxLength`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn rename_asset(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        name: types::polymesh_primitives::asset::AssetName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::rename_asset { ticker, name },
        ))
      }
      #[doc = "Renames a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `name` - the new name of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `MaxLengthOfAssetNameExceeded` if length of `name` is greater than"]
      #[doc = "`T::AssetNameMaxLength`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn rename_asset(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        name: types::polymesh_primitives::asset::AssetName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 6u8];
        ticker.encode_to(&mut buf);
        name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Issue, or mint, new tokens to the caller, which must be an authorized external agent."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - A signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - The [`Ticker`] of the token."]
      #[doc = "* `amount` - The amount of tokens that will be issued."]
      #[doc = "* `portfolio_kind` - The [`PortfolioKind`] of the portfolio that will receive the minted tokens."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn issue(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        amount: u128,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::issue {
            ticker,
            amount,
            portfolio_kind,
          },
        ))
      }
      #[doc = "Issue, or mint, new tokens to the caller, which must be an authorized external agent."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - A signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - The [`Ticker`] of the token."]
      #[doc = "* `amount` - The amount of tokens that will be issued."]
      #[doc = "* `portfolio_kind` - The [`PortfolioKind`] of the portfolio that will receive the minted tokens."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn issue(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        amount: u128,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 7u8];
        ticker.encode_to(&mut buf);
        amount.encode_to(&mut buf);
        portfolio_kind.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Redeems existing tokens by reducing the balance of the caller's default portfolio and the total supply of the token"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `value` Amount of tokens to redeem."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `Unauthorized` If called by someone without the appropriate external agent permissions"]
      #[doc = "- `InvalidGranularity` If the amount is not divisible by 10^6 for non-divisible tokens"]
      #[doc = "- `InsufficientPortfolioBalance` If the caller's default portfolio doesn't have enough free balance"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn redeem(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        value: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::redeem { ticker, value },
        ))
      }
      #[doc = "Redeems existing tokens by reducing the balance of the caller's default portfolio and the total supply of the token"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `value` Amount of tokens to redeem."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `Unauthorized` If called by someone without the appropriate external agent permissions"]
      #[doc = "- `InvalidGranularity` If the amount is not divisible by 10^6 for non-divisible tokens"]
      #[doc = "- `InsufficientPortfolioBalance` If the caller's default portfolio doesn't have enough free balance"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn redeem(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        value: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 8u8];
        ticker.encode_to(&mut buf);
        value.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Makes an indivisible token divisible."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `AssetAlreadyDivisible` if `ticker` is already divisible."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn make_divisible(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::make_divisible { ticker },
        ))
      }
      #[doc = "Makes an indivisible token divisible."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `AssetAlreadyDivisible` if `ticker` is already divisible."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn make_divisible(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 9u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Add documents for a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `docs` Documents to be attached to `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn add_documents(
        &self,
        docs: ::alloc::vec::Vec<types::polymesh_primitives::document::Document>,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::add_documents { docs, ticker },
        ))
      }
      #[doc = "Add documents for a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `docs` Documents to be attached to `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn add_documents(
        &self,
        docs: ::alloc::vec::Vec<types::polymesh_primitives::document::Document>,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 10u8];
        docs.encode_to(&mut buf);
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove documents for a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `ids` Documents ids to be removed from `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_documents(
        &self,
        ids: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_documents { ids, ticker },
        ))
      }
      #[doc = "Remove documents for a given token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `ids` Documents ids to be removed from `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_documents(
        &self,
        ids: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 11u8];
        ids.encode_to(&mut buf);
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets the name of the current funding round."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `name` - the desired name of the current funding round."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `FundingRoundNameMaxLengthExceeded` if length of `name` is greater than"]
      #[doc = "`T::FundingRoundNameMaxLength`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_funding_round(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        name: types::polymesh_primitives::asset::FundingRoundName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::set_funding_round { ticker, name },
        ))
      }
      #[doc = "Sets the name of the current funding round."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `name` - the desired name of the current funding round."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `FundingRoundNameMaxLengthExceeded` if length of `name` is greater than"]
      #[doc = "`T::FundingRoundNameMaxLength`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_funding_round(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        name: types::polymesh_primitives::asset::FundingRoundName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 12u8];
        ticker.encode_to(&mut buf);
        name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the asset identifiers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `identifiers` - the asset identifiers to be updated in the form of a vector of pairs"]
      #[doc = "   of `IdentifierType` and `AssetIdentifier` value."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `InvalidAssetIdentifier` if `identifiers` contains any invalid identifier."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn update_identifiers(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::update_identifiers {
            ticker,
            identifiers,
          },
        ))
      }
      #[doc = "Updates the asset identifiers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `identifiers` - the asset identifiers to be updated in the form of a vector of pairs"]
      #[doc = "   of `IdentifierType` and `AssetIdentifier` value."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `InvalidAssetIdentifier` if `identifiers` contains any invalid identifier."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn update_identifiers(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 13u8];
        ticker.encode_to(&mut buf);
        identifiers.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Forces a transfer of token from `from_portfolio` to the caller's default portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` Must be an external agent with appropriate permissions for a given ticker."]
      #[doc = "* `ticker` Ticker symbol of the asset."]
      #[doc = "* `value`  Amount of tokens need to force transfer."]
      #[doc = "* `from_portfolio` From whom portfolio tokens gets transferred."]
      #[cfg(not(feature = "ink"))]
      pub fn controller_transfer(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        value: u128,
        from_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::controller_transfer {
            ticker,
            value,
            from_portfolio,
          },
        ))
      }
      #[doc = "Forces a transfer of token from `from_portfolio` to the caller's default portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` Must be an external agent with appropriate permissions for a given ticker."]
      #[doc = "* `ticker` Ticker symbol of the asset."]
      #[doc = "* `value`  Amount of tokens need to force transfer."]
      #[doc = "* `from_portfolio` From whom portfolio tokens gets transferred."]
      #[cfg(feature = "ink")]
      pub fn controller_transfer(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        value: u128,
        from_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 14u8];
        ticker.encode_to(&mut buf);
        value.encode_to(&mut buf);
        from_portfolio.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Registers a custom asset type."]
      #[doc = ""]
      #[doc = "The provided `ty` will be bound to an ID in storage."]
      #[doc = "The ID can then be used in `AssetType::Custom`."]
      #[doc = "Should the `ty` already exist in storage, no second ID is assigned to it."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` who called the extrinsic."]
      #[doc = "* `ty` contains the string representation of the asset type."]
      #[cfg(not(feature = "ink"))]
      pub fn register_custom_asset_type(
        &self,
        ty: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::register_custom_asset_type { ty },
        ))
      }
      #[doc = "Registers a custom asset type."]
      #[doc = ""]
      #[doc = "The provided `ty` will be bound to an ID in storage."]
      #[doc = "The ID can then be used in `AssetType::Custom`."]
      #[doc = "Should the `ty` already exist in storage, no second ID is assigned to it."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` who called the extrinsic."]
      #[doc = "* `ty` contains the string representation of the asset type."]
      #[cfg(feature = "ink")]
      pub fn register_custom_asset_type(
        &self,
        ty: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 15u8];
        ty.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Utility extrinsic to batch `create_asset` and `register_custom_asset_type`."]
      #[cfg(not(feature = "ink"))]
      pub fn create_asset_with_custom_type(
        &self,
        name: types::polymesh_primitives::asset::AssetName,
        ticker: types::polymesh_primitives::ticker::Ticker,
        divisible: bool,
        custom_asset_type: ::alloc::vec::Vec<u8>,
        identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
        funding_round: Option<types::polymesh_primitives::asset::FundingRoundName>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::create_asset_with_custom_type {
            name,
            ticker,
            divisible,
            custom_asset_type,
            identifiers,
            funding_round,
          },
        ))
      }
      #[doc = "Utility extrinsic to batch `create_asset` and `register_custom_asset_type`."]
      #[cfg(feature = "ink")]
      pub fn create_asset_with_custom_type(
        &self,
        name: types::polymesh_primitives::asset::AssetName,
        ticker: types::polymesh_primitives::ticker::Ticker,
        divisible: bool,
        custom_asset_type: ::alloc::vec::Vec<u8>,
        identifiers: ::alloc::vec::Vec<
          types::polymesh_primitives::asset_identifier::AssetIdentifier,
        >,
        funding_round: Option<types::polymesh_primitives::asset::FundingRoundName>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 16u8];
        name.encode_to(&mut buf);
        ticker.encode_to(&mut buf);
        divisible.encode_to(&mut buf);
        custom_asset_type.encode_to(&mut buf);
        identifiers.encode_to(&mut buf);
        funding_round.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set asset metadata value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `key` Metadata key."]
      #[doc = "* `value` Metadata value."]
      #[doc = "* `details` Optional Metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` if the metadata type key doesn't exist."]
      #[doc = "* `AssetMetadataValueIsLocked` if the metadata value for `key` is locked."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` if the metadata value exceeds the maximum length."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_asset_metadata(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::set_asset_metadata {
            ticker,
            key,
            value,
            detail,
          },
        ))
      }
      #[doc = "Set asset metadata value."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `key` Metadata key."]
      #[doc = "* `value` Metadata value."]
      #[doc = "* `details` Optional Metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` if the metadata type key doesn't exist."]
      #[doc = "* `AssetMetadataValueIsLocked` if the metadata value for `key` is locked."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` if the metadata value exceeds the maximum length."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_asset_metadata(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 17u8];
        ticker.encode_to(&mut buf);
        key.encode_to(&mut buf);
        value.encode_to(&mut buf);
        detail.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set asset metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `key` Metadata key."]
      #[doc = "* `details` Metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` if the metadata type key doesn't exist."]
      #[doc = "* `AssetMetadataValueIsLocked` if the metadata value for `key` is locked."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_asset_metadata_details(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        detail: types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::set_asset_metadata_details {
            ticker,
            key,
            detail,
          },
        ))
      }
      #[doc = "Set asset metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `key` Metadata key."]
      #[doc = "* `details` Metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataKeyIsMissing` if the metadata type key doesn't exist."]
      #[doc = "* `AssetMetadataValueIsLocked` if the metadata value for `key` is locked."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_asset_metadata_details(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        detail: types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 18u8];
        ticker.encode_to(&mut buf);
        key.encode_to(&mut buf);
        detail.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Registers and set local asset metadata."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `name` Metadata name."]
      #[doc = "* `spec` Metadata type definition."]
      #[doc = "* `value` Metadata value."]
      #[doc = "* `details` Optional Metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` if a local metadata type with `name` already exists for `ticker`."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` if the metadata value exceeds the maximum length."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn register_and_set_local_asset_metadata(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
        value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::register_and_set_local_asset_metadata {
            ticker,
            name,
            spec,
            value,
            detail,
          },
        ))
      }
      #[doc = "Registers and set local asset metadata."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `name` Metadata name."]
      #[doc = "* `spec` Metadata type definition."]
      #[doc = "* `value` Metadata value."]
      #[doc = "* `details` Optional Metadata value details (expire, lock status)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` if a local metadata type with `name` already exists for `ticker`."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length."]
      #[doc = "* `AssetMetadataValueMaxLengthExceeded` if the metadata value exceeds the maximum length."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn register_and_set_local_asset_metadata(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
        value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
        detail: Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 19u8];
        ticker.encode_to(&mut buf);
        name.encode_to(&mut buf);
        spec.encode_to(&mut buf);
        value.encode_to(&mut buf);
        detail.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Registers asset metadata local type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `name` Metadata name."]
      #[doc = "* `spec` Metadata type definition."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` if a local metadata type with `name` already exists for `ticker`."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn register_asset_metadata_local_type(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::register_asset_metadata_local_type { ticker, name, spec },
        ))
      }
      #[doc = "Registers asset metadata local type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `name` Metadata name."]
      #[doc = "* `spec` Metadata type definition."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataLocalKeyAlreadyExists` if a local metadata type with `name` already exists for `ticker`."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn register_asset_metadata_local_type(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 20u8];
        ticker.encode_to(&mut buf);
        name.encode_to(&mut buf);
        spec.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Registers asset metadata global type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `name` Metadata name."]
      #[doc = "* `spec` Metadata type definition."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataGlobalKeyAlreadyExists` if a globa metadata type with `name` already exists."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length."]
      #[cfg(not(feature = "ink"))]
      pub fn register_asset_metadata_global_type(
        &self,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::register_asset_metadata_global_type { name, spec },
        ))
      }
      #[doc = "Registers asset metadata global type."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `name` Metadata name."]
      #[doc = "* `spec` Metadata type definition."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `AssetMetadataGlobalKeyAlreadyExists` if a globa metadata type with `name` already exists."]
      #[doc = "* `AssetMetadataNameMaxLengthExceeded` if the metadata `name` exceeds the maximum length."]
      #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` if the metadata `spec` type definition exceeds the maximum length."]
      #[cfg(feature = "ink")]
      pub fn register_asset_metadata_global_type(
        &self,
        name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
        spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 21u8];
        name.encode_to(&mut buf);
        spec.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Redeems existing tokens by reducing the balance of the caller's portfolio and the total supply of the token"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `value` Amount of tokens to redeem."]
      #[doc = "* `portfolio` From whom portfolio tokens gets transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `Unauthorized` If called by someone without the appropriate external agent permissions"]
      #[doc = "- `InvalidGranularity` If the amount is not divisible by 10^6 for non-divisible tokens"]
      #[doc = "- `InsufficientPortfolioBalance` If the caller's `portfolio` doesn't have enough free balance"]
      #[doc = "- `PortfolioDoesNotExist` If the portfolio doesn't exist."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn redeem_from_portfolio(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        value: u128,
        portfolio: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::redeem_from_portfolio {
            ticker,
            value,
            portfolio,
          },
        ))
      }
      #[doc = "Redeems existing tokens by reducing the balance of the caller's portfolio and the total supply of the token"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` Ticker of the token."]
      #[doc = "* `value` Amount of tokens to redeem."]
      #[doc = "* `portfolio` From whom portfolio tokens gets transferred."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `Unauthorized` If called by someone without the appropriate external agent permissions"]
      #[doc = "- `InvalidGranularity` If the amount is not divisible by 10^6 for non-divisible tokens"]
      #[doc = "- `InsufficientPortfolioBalance` If the caller's `portfolio` doesn't have enough free balance"]
      #[doc = "- `PortfolioDoesNotExist` If the portfolio doesn't exist."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn redeem_from_portfolio(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        value: u128,
        portfolio: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 22u8];
        ticker.encode_to(&mut buf);
        value.encode_to(&mut buf);
        portfolio.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the type of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `asset_type` - the new type of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `InvalidCustomAssetTypeId` if `asset_type` is of type custom and has an invalid type id."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn update_asset_type(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        asset_type: types::polymesh_primitives::asset::AssetType,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::update_asset_type { ticker, asset_type },
        ))
      }
      #[doc = "Updates the type of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the token."]
      #[doc = "* `asset_type` - the new type of the token."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `InvalidCustomAssetTypeId` if `asset_type` is of type custom and has an invalid type id."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn update_asset_type(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        asset_type: types::polymesh_primitives::asset::AssetType,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 23u8];
        ticker.encode_to(&mut buf);
        asset_type.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the asset metadata key and value of a local key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the local metadata key."]
      #[doc = "* `local_key` - the local metadata key."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = " - `SecondaryKeyNotAuthorizedForAsset` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `UnauthorizedAgent` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `AssetMetadataKeyIsMissing` - if the key doens't exist."]
      #[doc = " - `AssetMetadataValueIsLocked` - if the value of the key is locked."]
      #[doc = " - AssetMetadataKeyBelongsToNFTCollection - if the key is a mandatory key in an NFT collection."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_local_metadata_key(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        local_key: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_local_metadata_key { ticker, local_key },
        ))
      }
      #[doc = "Removes the asset metadata key and value of a local key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the local metadata key."]
      #[doc = "* `local_key` - the local metadata key."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = " - `SecondaryKeyNotAuthorizedForAsset` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `UnauthorizedAgent` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `AssetMetadataKeyIsMissing` - if the key doens't exist."]
      #[doc = " - `AssetMetadataValueIsLocked` - if the value of the key is locked."]
      #[doc = " - AssetMetadataKeyBelongsToNFTCollection - if the key is a mandatory key in an NFT collection."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_local_metadata_key(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        local_key: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 24u8];
        ticker.encode_to(&mut buf);
        local_key.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the asset metadata value of a metadata key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the local metadata key."]
      #[doc = "* `metadata_key` - the metadata key that will have its value deleted."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = " - `SecondaryKeyNotAuthorizedForAsset` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `UnauthorizedAgent` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `AssetMetadataKeyIsMissing` - if the key doens't exist."]
      #[doc = " - `AssetMetadataValueIsLocked` - if the value of the key is locked."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_metadata_value(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        metadata_key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_metadata_value {
            ticker,
            metadata_key,
          },
        ))
      }
      #[doc = "Removes the asset metadata value of a metadata key."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the ticker of the local metadata key."]
      #[doc = "* `metadata_key` - the metadata key that will have its value deleted."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = " - `SecondaryKeyNotAuthorizedForAsset` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `UnauthorizedAgent` - if called by someone without the appropriate external agent permissions."]
      #[doc = " - `AssetMetadataKeyIsMissing` - if the key doens't exist."]
      #[doc = " - `AssetMetadataValueIsLocked` - if the value of the key is locked."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_metadata_value(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        metadata_key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 25u8];
        ticker.encode_to(&mut buf);
        metadata_key.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Pre-approves the receivement of the asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Root"]
      #[cfg(not(feature = "ink"))]
      pub fn exempt_ticker_affirmation(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::exempt_ticker_affirmation { ticker },
        ))
      }
      #[doc = "Pre-approves the receivement of the asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Root"]
      #[cfg(feature = "ink")]
      pub fn exempt_ticker_affirmation(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 26u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the pre-approval of the asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Root"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_ticker_affirmation_exemption(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_ticker_affirmation_exemption { ticker },
        ))
      }
      #[doc = "Removes the pre-approval of the asset for all identities."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Root"]
      #[cfg(feature = "ink")]
      pub fn remove_ticker_affirmation_exemption(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 27u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Pre-approves the receivement of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn pre_approve_ticker(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::pre_approve_ticker { ticker },
        ))
      }
      #[doc = "Pre-approves the receivement of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn pre_approve_ticker(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 28u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the pre approval of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_ticker_pre_approval(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Asset(
          types::pallet_asset::AssetCall::remove_ticker_pre_approval { ticker },
        ))
      }
      #[doc = "Removes the pre approval of an asset."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will have its exemption removed."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_ticker_pre_approval(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![26u8, 29u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for AssetCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct AssetQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> AssetQueryApi<'api> {
      #[doc = " Ticker registration details."]
      #[doc = " (ticker) -> TickerRegistration"]
      #[cfg(not(feature = "ink"))]
      pub async fn tickers(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_asset::TickerRegistration<u64>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 79u8, 99u8, 172u8, 50u8, 155u8, 165u8, 225u8, 25u8, 154u8, 107u8,
          42u8, 66u8, 52u8, 112u8, 140u8, 188u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Ticker registration details."]
      #[doc = " (ticker) -> TickerRegistration"]
      #[cfg(feature = "ink")]
      pub fn tickers(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_asset::TickerRegistration<u64>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 79u8, 99u8, 172u8, 50u8, 155u8, 165u8, 225u8, 25u8, 154u8, 107u8,
          42u8, 66u8, 52u8, 112u8, 140u8, 188u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Ticker registration config."]
      #[doc = " (ticker) -> TickerRegistrationConfig"]
      #[cfg(not(feature = "ink"))]
      pub async fn ticker_config(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_asset::TickerRegistrationConfig<u64>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 185u8, 113u8, 30u8, 121u8, 127u8, 46u8, 243u8, 186u8, 159u8, 108u8,
          75u8, 247u8, 236u8, 154u8, 169u8, 176u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_asset::TickerRegistrationConfig<u64>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Ticker registration config."]
      #[doc = " (ticker) -> TickerRegistrationConfig"]
      #[cfg(feature = "ink")]
      pub fn ticker_config(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_asset::TickerRegistrationConfig<u64>>
      {
        let value = self.api.read_storage(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 185u8, 113u8, 30u8, 121u8, 127u8, 46u8, 243u8, 186u8, 159u8, 108u8,
          75u8, 247u8, 236u8, 154u8, 169u8, 176u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::pallet_asset::TickerRegistrationConfig<u64>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Details of the token corresponding to the token ticker."]
      #[doc = " (ticker) -> SecurityToken details [returns SecurityToken struct]"]
      #[cfg(not(feature = "ink"))]
      pub async fn tokens(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_asset::SecurityToken>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 153u8, 151u8, 27u8, 87u8, 73u8, 172u8, 67u8, 224u8, 35u8, 94u8, 65u8,
          176u8, 211u8, 120u8, 105u8, 24u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Details of the token corresponding to the token ticker."]
      #[doc = " (ticker) -> SecurityToken details [returns SecurityToken struct]"]
      #[cfg(feature = "ink")]
      pub fn tokens(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_asset::SecurityToken>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 153u8, 151u8, 27u8, 87u8, 73u8, 172u8, 67u8, 224u8, 35u8, 94u8, 65u8,
          176u8, 211u8, 120u8, 105u8, 24u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset name of the token corresponding to the token ticker."]
      #[doc = " (ticker) -> `AssetName`"]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_names(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::asset::AssetName>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 123u8, 195u8, 250u8, 203u8, 235u8, 133u8, 90u8, 23u8, 143u8, 10u8,
          8u8, 53u8, 96u8, 109u8, 5u8, 206u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset name of the token corresponding to the token ticker."]
      #[doc = " (ticker) -> `AssetName`"]
      #[cfg(feature = "ink")]
      pub fn asset_names(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::asset::AssetName>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 123u8, 195u8, 250u8, 203u8, 235u8, 133u8, 90u8, 23u8, 143u8, 10u8,
          8u8, 53u8, 96u8, 109u8, 5u8, 206u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The total asset ticker balance per identity."]
      #[doc = " (ticker, DID) -> Balance"]
      #[cfg(not(feature = "ink"))]
      pub async fn balance_of(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 106u8, 75u8, 187u8, 251u8, 206u8, 1u8, 124u8, 102u8, 14u8, 227u8,
          176u8, 68u8, 23u8, 115u8, 19u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total asset ticker balance per identity."]
      #[doc = " (ticker, DID) -> Balance"]
      #[cfg(feature = "ink")]
      pub fn balance_of(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 106u8, 75u8, 187u8, 251u8, 206u8, 1u8, 124u8, 102u8, 14u8, 227u8,
          176u8, 68u8, 23u8, 115u8, 19u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A map of a ticker name and asset identifiers."]
      #[cfg(not(feature = "ink"))]
      pub async fn identifiers(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset_identifier::AssetIdentifier>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 249u8, 164u8, 131u8, 240u8, 209u8, 227u8, 62u8, 56u8, 212u8, 69u8,
          56u8, 130u8, 119u8, 235u8, 13u8, 237u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                            types::polymesh_primitives::asset_identifier::AssetIdentifier,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
        }))
      }
      #[doc = " A map of a ticker name and asset identifiers."]
      #[cfg(feature = "ink")]
      pub fn identifiers(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset_identifier::AssetIdentifier>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 249u8, 164u8, 131u8, 240u8, 209u8, 227u8, 62u8, 56u8, 212u8, 69u8,
          56u8, 130u8, 119u8, 235u8, 13u8, 237u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<
                            types::polymesh_primitives::asset_identifier::AssetIdentifier,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
        }))
      }
      #[doc = " The next `AssetType::Custom` ID in the sequence."]
      #[doc = ""]
      #[doc = " Numbers in the sequence start from 1 rather than 0."]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_type_id_sequence(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::asset::CustomAssetTypeId>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 16u8, 121u8, 19u8, 48u8, 14u8, 106u8, 39u8, 83u8, 29u8, 145u8, 209u8,
          187u8, 190u8, 66u8, 165u8, 176u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset::CustomAssetTypeId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next `AssetType::Custom` ID in the sequence."]
      #[doc = ""]
      #[doc = " Numbers in the sequence start from 1 rather than 0."]
      #[cfg(feature = "ink")]
      pub fn custom_type_id_sequence(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::asset::CustomAssetTypeId>
      {
        let value = self.api.read_storage(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 16u8, 121u8, 19u8, 48u8, 14u8, 106u8, 39u8, 83u8, 29u8, 145u8, 209u8,
          187u8, 190u8, 66u8, 165u8, 176u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset::CustomAssetTypeId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps custom asset type ids to the registered string contents."]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_types(
        &self,
        key_0: types::polymesh_primitives::asset::CustomAssetTypeId,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 214u8, 35u8, 90u8, 254u8, 57u8, 243u8, 210u8, 34u8, 193u8, 0u8, 96u8,
          131u8, 116u8, 109u8, 49u8, 166u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps custom asset type ids to the registered string contents."]
      #[cfg(feature = "ink")]
      pub fn custom_types(
        &self,
        key_0: types::polymesh_primitives::asset::CustomAssetTypeId,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u8>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 214u8, 35u8, 90u8, 254u8, 57u8, 243u8, 210u8, 34u8, 193u8, 0u8, 96u8,
          131u8, 116u8, 109u8, 49u8, 166u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Inverse map of `CustomTypes`, from registered string contents to custom asset type ids."]
      #[cfg(not(feature = "ink"))]
      pub async fn custom_types_inverse(
        &self,
        key_0: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset::CustomAssetTypeId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 2u8, 147u8, 168u8, 237u8, 90u8, 35u8, 218u8, 237u8, 169u8, 231u8,
          223u8, 32u8, 46u8, 15u8, 228u8, 85u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Inverse map of `CustomTypes`, from registered string contents to custom asset type ids."]
      #[cfg(feature = "ink")]
      pub fn custom_types_inverse(
        &self,
        key_0: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset::CustomAssetTypeId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 2u8, 147u8, 168u8, 237u8, 90u8, 35u8, 218u8, 237u8, 169u8, 231u8,
          223u8, 32u8, 46u8, 15u8, 228u8, 85u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " The name of the current funding round."]
      #[doc = " ticker -> funding round"]
      #[cfg(not(feature = "ink"))]
      pub async fn funding_round(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::asset::FundingRoundName>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 93u8, 34u8, 9u8, 253u8, 168u8, 224u8, 203u8, 196u8, 69u8, 133u8, 25u8,
          204u8, 124u8, 207u8, 104u8, 5u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::asset::FundingRoundName>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The name of the current funding round."]
      #[doc = " ticker -> funding round"]
      #[cfg(feature = "ink")]
      pub fn funding_round(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::asset::FundingRoundName>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 93u8, 34u8, 9u8, 253u8, 168u8, 224u8, 203u8, 196u8, 69u8, 133u8, 25u8,
          204u8, 124u8, 207u8, 104u8, 5u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::asset::FundingRoundName>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total balances of tokens issued in all recorded funding rounds."]
      #[doc = " (ticker, funding round) -> balance"]
      #[cfg(not(feature = "ink"))]
      pub async fn issued_in_funding_round(
        &self,
        key_0: (
          types::polymesh_primitives::ticker::Ticker,
          types::polymesh_primitives::asset::FundingRoundName,
        ),
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 215u8, 137u8, 60u8, 134u8, 127u8, 54u8, 56u8, 208u8, 215u8, 148u8,
          185u8, 185u8, 12u8, 48u8, 135u8, 44u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total balances of tokens issued in all recorded funding rounds."]
      #[doc = " (ticker, funding round) -> balance"]
      #[cfg(feature = "ink")]
      pub fn issued_in_funding_round(
        &self,
        key_0: (
          types::polymesh_primitives::ticker::Ticker,
          types::polymesh_primitives::asset::FundingRoundName,
        ),
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 215u8, 137u8, 60u8, 134u8, 127u8, 54u8, 56u8, 208u8, 215u8, 148u8,
          185u8, 185u8, 12u8, 48u8, 135u8, 44u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The set of frozen assets implemented as a membership map."]
      #[doc = " ticker -> bool"]
      #[cfg(not(feature = "ink"))]
      pub async fn frozen(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8, 93u8, 238u8, 240u8,
          115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The set of frozen assets implemented as a membership map."]
      #[doc = " ticker -> bool"]
      #[cfg(feature = "ink")]
      pub fn frozen(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8, 93u8, 238u8, 240u8,
          115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tickers and token owned by a user"]
      #[doc = " (user, ticker) -> AssetOwnership"]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_ownership_relations(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<types::pallet_asset::AssetOwnershipRelation> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 120u8, 175u8, 65u8, 84u8, 91u8, 225u8, 83u8, 120u8, 92u8, 157u8, 17u8,
          119u8, 178u8, 122u8, 105u8, 103u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_asset::AssetOwnershipRelation>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tickers and token owned by a user"]
      #[doc = " (user, ticker) -> AssetOwnership"]
      #[cfg(feature = "ink")]
      pub fn asset_ownership_relations(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_asset::AssetOwnershipRelation> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 120u8, 175u8, 65u8, 84u8, 91u8, 225u8, 83u8, 120u8, 92u8, 157u8, 17u8,
          119u8, 178u8, 122u8, 105u8, 103u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_asset::AssetOwnershipRelation>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Documents attached to an Asset"]
      #[doc = " (ticker, doc_id) -> document"]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_documents(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::document::DocumentId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::document::Document>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 166u8, 167u8, 74u8, 143u8, 116u8, 237u8, 66u8, 137u8, 149u8, 40u8,
          102u8, 20u8, 236u8, 96u8, 52u8, 9u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Documents attached to an Asset"]
      #[doc = " (ticker, doc_id) -> document"]
      #[cfg(feature = "ink")]
      pub fn asset_documents(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::document::DocumentId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::document::Document>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 166u8, 167u8, 74u8, 143u8, 116u8, 237u8, 66u8, 137u8, 149u8, 40u8,
          102u8, 20u8, 236u8, 96u8, 52u8, 9u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Per-ticker document ID counter."]
      #[doc = " (ticker) -> doc_id"]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_documents_id_sequence(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::document::DocumentId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 201u8, 198u8, 40u8, 95u8, 195u8, 158u8, 100u8, 69u8, 247u8, 3u8, 87u8,
          5u8, 57u8, 71u8, 8u8, 63u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::document::DocumentId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Per-ticker document ID counter."]
      #[doc = " (ticker) -> doc_id"]
      #[cfg(feature = "ink")]
      pub fn asset_documents_id_sequence(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::document::DocumentId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 201u8, 198u8, 40u8, 95u8, 195u8, 158u8, 100u8, 69u8, 247u8, 3u8, 87u8,
          5u8, 57u8, 71u8, 8u8, 63u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::document::DocumentId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Metatdata values for an asset."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_values(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataValue>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 12u8, 236u8, 10u8, 112u8, 182u8, 190u8, 51u8, 243u8, 171u8, 240u8,
          46u8, 214u8, 255u8, 55u8, 188u8, 48u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Metatdata values for an asset."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_values(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataValue>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 12u8, 236u8, 10u8, 112u8, 182u8, 190u8, 51u8, 243u8, 171u8, 240u8,
          46u8, 214u8, 255u8, 55u8, 188u8, 48u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Details for an asset's Metadata values."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_value_details(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 177u8, 107u8, 241u8, 225u8, 188u8, 86u8, 141u8, 84u8, 219u8, 116u8,
          115u8, 57u8, 230u8, 243u8, 42u8, 93u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Details for an asset's Metadata values."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_value_details(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 177u8, 107u8, 241u8, 225u8, 188u8, 86u8, 141u8, 84u8, 219u8, 116u8,
          115u8, 57u8, 230u8, 243u8, 42u8, 93u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Name -> Key."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_local_name_to_key(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataName,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 132u8, 79u8, 149u8, 0u8, 75u8, 89u8, 31u8, 241u8, 75u8, 208u8, 41u8,
          159u8, 32u8, 36u8, 73u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Name -> Key."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_local_name_to_key(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataName,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 132u8, 79u8, 149u8, 0u8, 75u8, 89u8, 31u8, 241u8, 75u8, 208u8, 41u8,
          159u8, 32u8, 36u8, 73u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Name -> Key."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_global_name_to_key(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataName,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 27u8, 55u8, 255u8, 139u8, 76u8, 15u8, 234u8, 246u8, 25u8, 194u8,
          110u8, 238u8, 121u8, 209u8, 31u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Name -> Key."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_global_name_to_key(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataName,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 27u8, 55u8, 255u8, 139u8, 76u8, 15u8, 234u8, 246u8, 25u8, 194u8,
          110u8, 238u8, 121u8, 209u8, 31u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Key -> Name."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_local_key_to_name(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 15u8, 104u8, 156u8, 10u8, 116u8, 95u8, 149u8, 200u8, 0u8, 202u8,
          149u8, 7u8, 13u8, 176u8, 112u8, 120u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Key -> Name."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_local_key_to_name(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 15u8, 104u8, 156u8, 10u8, 116u8, 95u8, 149u8, 200u8, 0u8, 202u8,
          149u8, 7u8, 13u8, 176u8, 112u8, 120u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Key -> Name."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_global_key_to_name(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 34u8, 54u8, 201u8, 61u8, 167u8, 233u8, 191u8, 146u8, 116u8, 241u8,
          41u8, 22u8, 57u8, 221u8, 39u8, 238u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Key -> Name."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_global_key_to_name(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 34u8, 54u8, 201u8, 61u8, 167u8, 233u8, 191u8, 146u8, 116u8, 241u8,
          41u8, 22u8, 57u8, 221u8, 39u8, 238u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Key specs."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_local_specs(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 142u8, 233u8, 192u8, 135u8, 176u8, 130u8, 140u8, 179u8, 147u8, 154u8,
          225u8, 87u8, 146u8, 146u8, 58u8, 218u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Local Key specs."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_local_specs(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 142u8, 233u8, 192u8, 135u8, 176u8, 130u8, 140u8, 179u8, 147u8, 154u8,
          225u8, 87u8, 146u8, 146u8, 58u8, 218u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Key specs."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_global_specs(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 68u8, 154u8, 137u8, 212u8, 2u8, 194u8, 202u8, 170u8, 149u8, 44u8,
          16u8, 103u8, 57u8, 78u8, 188u8, 125u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Asset Metadata Global Key specs."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_global_specs(
        &self,
        key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 68u8, 154u8, 137u8, 212u8, 2u8, 194u8, 202u8, 170u8, 149u8, 44u8,
          16u8, 103u8, 57u8, 78u8, 188u8, 125u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Next Asset Metadata Local Key."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_next_local_key(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 227u8, 167u8, 30u8, 21u8, 95u8, 214u8, 84u8, 40u8, 18u8, 4u8, 97u8,
          135u8, 56u8, 213u8, 243u8, 59u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Next Asset Metadata Local Key."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_next_local_key(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 227u8, 167u8, 30u8, 21u8, 95u8, 214u8, 84u8, 40u8, 18u8, 4u8, 97u8,
          135u8, 56u8, 213u8, 243u8, 59u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Next Asset Metadata Global Key."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_metadata_next_global_key(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 65u8, 13u8, 61u8, 170u8, 126u8, 198u8, 120u8, 78u8, 47u8, 160u8,
          108u8, 155u8, 20u8, 24u8, 193u8, 5u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Next Asset Metadata Global Key."]
      #[cfg(feature = "ink")]
      pub fn asset_metadata_next_global_key(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
      > {
        let value = self.api.read_storage(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 65u8, 13u8, 61u8, 170u8, 126u8, 198u8, 120u8, 78u8, 47u8, 160u8,
          108u8, 155u8, 20u8, 24u8, 193u8, 5u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " A list of tickers that exempt all users from affirming the receivement of the asset."]
      #[cfg(not(feature = "ink"))]
      pub async fn tickers_exempt_from_affirmation(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 55u8, 4u8, 238u8, 16u8, 247u8, 17u8, 129u8, 59u8, 18u8, 131u8, 201u8,
          128u8, 246u8, 242u8, 93u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " A list of tickers that exempt all users from affirming the receivement of the asset."]
      #[cfg(feature = "ink")]
      pub fn tickers_exempt_from_affirmation(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 55u8, 4u8, 238u8, 16u8, 247u8, 17u8, 129u8, 59u8, 18u8, 131u8, 201u8,
          128u8, 246u8, 242u8, 93u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All tickers that don't need an affirmation to be received by an identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn pre_approved_ticker(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 241u8, 185u8, 246u8, 160u8, 203u8, 243u8, 143u8, 231u8, 140u8, 216u8,
          131u8, 238u8, 223u8, 172u8, 84u8, 237u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All tickers that don't need an affirmation to be received by an identity."]
      #[cfg(feature = "ink")]
      pub fn pre_approved_ticker(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 241u8, 185u8, 246u8, 160u8, 203u8, 243u8, 143u8, 231u8, 140u8, 216u8,
          131u8, 238u8, 223u8, 172u8, 84u8, 237u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_asset::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_asset::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_asset::Version> {
        let value = self.api.read_storage(::alloc::vec![
          211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8, 149u8, 83u8,
          69u8, 123u8, 46u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_asset::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod capital_distribution {
    use super::*;
    #[derive(Clone)]
    pub struct CapitalDistributionCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CapitalDistributionCallApi<'api> {
      #[doc = "Start and attach a capital distribution, to the CA identified by `ca_id`,"]
      #[doc = "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID."]
      #[doc = ""]
      #[doc = "The distribution will commence at `payment_at` and expire at `expires_at`,"]
      #[doc = "if provided, or if `None`, then there's no expiry."]
      #[doc = ""]
      #[doc = "The funds will be locked in `portfolio` from when `distribute` is called."]
      #[doc = "When there's no expiry, some funds may be locked indefinitely in `portfolio`,"]
      #[doc = "due to claimants not withdrawing or no benefits being pushed to them."]
      #[doc = "For indivisible currencies, unlocked amounts, of less than one whole unit,"]
      #[doc = "will not be transferable from `portfolio`."]
      #[doc = "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units,"]
      #[doc = "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`,"]
      #[doc = "which is now transferrable."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
      #[doc = "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from."]
      #[doc = "- `currency` to withdraw and distribute from the `portfolio`."]
      #[doc = "- `per_share` amount of `currency` to withdraw and distribute."]
      #[doc = "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token."]
      #[doc = "- `amount` of `currency` to withdraw and distribute at most."]
      #[doc = "- `payment_at` specifies when benefits may first be pushed or claimed."]
      #[doc = "- `expires_at` specifies, if provided, when remaining benefits are forfeit"]
      #[doc = "   and may be reclaimed by `origin`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NoRecordDate` if CA has no record date."]
      #[doc = "- `RecordDateAfterStart` if CA's record date > payment_at."]
      #[doc = "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`."]
      #[doc = "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`."]
      #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
      #[doc = "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit"]
      #[doc = "- `DistributionAmountIsZero` if the `amount` is zero."]
      #[doc = "- `DistributionPerShareIsZero` if the `per_share` is zero."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn distribute(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
        currency: types::polymesh_primitives::ticker::Ticker,
        per_share: u128,
        amount: u128,
        payment_at: u64,
        expires_at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CapitalDistribution(
            types::pallet_corporate_actions::distribution::CapitalDistributionCall::distribute {
              ca_id,
              portfolio,
              currency,
              per_share,
              amount,
              payment_at,
              expires_at,
            },
          ))
      }
      #[doc = "Start and attach a capital distribution, to the CA identified by `ca_id`,"]
      #[doc = "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID."]
      #[doc = ""]
      #[doc = "The distribution will commence at `payment_at` and expire at `expires_at`,"]
      #[doc = "if provided, or if `None`, then there's no expiry."]
      #[doc = ""]
      #[doc = "The funds will be locked in `portfolio` from when `distribute` is called."]
      #[doc = "When there's no expiry, some funds may be locked indefinitely in `portfolio`,"]
      #[doc = "due to claimants not withdrawing or no benefits being pushed to them."]
      #[doc = "For indivisible currencies, unlocked amounts, of less than one whole unit,"]
      #[doc = "will not be transferable from `portfolio`."]
      #[doc = "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units,"]
      #[doc = "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`,"]
      #[doc = "which is now transferrable."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
      #[doc = "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from."]
      #[doc = "- `currency` to withdraw and distribute from the `portfolio`."]
      #[doc = "- `per_share` amount of `currency` to withdraw and distribute."]
      #[doc = "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token."]
      #[doc = "- `amount` of `currency` to withdraw and distribute at most."]
      #[doc = "- `payment_at` specifies when benefits may first be pushed or claimed."]
      #[doc = "- `expires_at` specifies, if provided, when remaining benefits are forfeit"]
      #[doc = "   and may be reclaimed by `origin`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NoRecordDate` if CA has no record date."]
      #[doc = "- `RecordDateAfterStart` if CA's record date > payment_at."]
      #[doc = "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`."]
      #[doc = "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`."]
      #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
      #[doc = "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit"]
      #[doc = "- `DistributionAmountIsZero` if the `amount` is zero."]
      #[doc = "- `DistributionPerShareIsZero` if the `per_share` is zero."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn distribute(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
        currency: types::polymesh_primitives::ticker::Ticker,
        per_share: u128,
        amount: u128,
        payment_at: u64,
        expires_at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![27u8, 0u8];
        ca_id.encode_to(&mut buf);
        portfolio.encode_to(&mut buf);
        currency.encode_to(&mut buf);
        per_share.encode_to(&mut buf);
        amount.encode_to(&mut buf);
        payment_at.encode_to(&mut buf);
        expires_at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Claim a benefit of the capital distribution attached to `ca_id`."]
      #[doc = ""]
      #[doc = "Taxes are withheld as specified by the CA."]
      #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
      #[doc = ""]
      #[doc = "All benefits are rounded by truncation, down to first integer below."]
      #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
      #[doc = "they are rounded down to a whole unit."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be a holder of the asset and eligible for the distribution."]
      #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
      #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
      #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
      #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
      #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
      #[cfg(not(feature = "ink"))]
      pub fn claim(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CapitalDistribution(
            types::pallet_corporate_actions::distribution::CapitalDistributionCall::claim { ca_id },
          ))
      }
      #[doc = "Claim a benefit of the capital distribution attached to `ca_id`."]
      #[doc = ""]
      #[doc = "Taxes are withheld as specified by the CA."]
      #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
      #[doc = ""]
      #[doc = "All benefits are rounded by truncation, down to first integer below."]
      #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
      #[doc = "they are rounded down to a whole unit."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be a holder of the asset and eligible for the distribution."]
      #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
      #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
      #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
      #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
      #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
      #[cfg(feature = "ink")]
      pub fn claim(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![27u8, 1u8];
        ca_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Push benefit of an ongoing distribution to the given `holder`."]
      #[doc = ""]
      #[doc = "Taxes are withheld as specified by the CA."]
      #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
      #[doc = ""]
      #[doc = "All benefits are rounded by truncation, down to first integer below."]
      #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
      #[doc = "they are rounded down to a whole unit."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the CA with a capital distributions to push benefits for."]
      #[doc = "- `holder` to push benefits to."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
      #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `holder`."]
      #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
      #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
      #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
      #[cfg(not(feature = "ink"))]
      pub fn push_benefit(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        holder: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CapitalDistribution(
            types::pallet_corporate_actions::distribution::CapitalDistributionCall::push_benefit {
              ca_id,
              holder,
            },
          ))
      }
      #[doc = "Push benefit of an ongoing distribution to the given `holder`."]
      #[doc = ""]
      #[doc = "Taxes are withheld as specified by the CA."]
      #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
      #[doc = ""]
      #[doc = "All benefits are rounded by truncation, down to first integer below."]
      #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
      #[doc = "they are rounded down to a whole unit."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the CA with a capital distributions to push benefits for."]
      #[doc = "- `holder` to push benefits to."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
      #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `holder`."]
      #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
      #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
      #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
      #[cfg(feature = "ink")]
      pub fn push_benefit(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        holder: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![27u8, 2u8];
        ca_id.encode_to(&mut buf);
        holder.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Assuming a distribution has expired,"]
      #[doc = "unlock the remaining amount in the distributor portfolio."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be the creator of the capital distribution tied to `ca_id`."]
      #[doc = "- `ca_id` identifies the CA with a capital distribution to reclaim for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `AlreadyReclaimed` if this function has already been called successfully."]
      #[doc = "- `NotExpired` if `now < expiry`."]
      #[cfg(not(feature = "ink"))]
      pub fn reclaim(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self
          .api
          .wrap_call(runtime::RuntimeCall::CapitalDistribution(
            types::pallet_corporate_actions::distribution::CapitalDistributionCall::reclaim {
              ca_id,
            },
          ))
      }
      #[doc = "Assuming a distribution has expired,"]
      #[doc = "unlock the remaining amount in the distributor portfolio."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be the creator of the capital distribution tied to `ca_id`."]
      #[doc = "- `ca_id` identifies the CA with a capital distribution to reclaim for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `AlreadyReclaimed` if this function has already been called successfully."]
      #[doc = "- `NotExpired` if `now < expiry`."]
      #[cfg(feature = "ink")]
      pub fn reclaim(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![27u8, 3u8];
        ca_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a distribution that hasn't started yet,"]
      #[doc = "unlocking the full amount in the distributor portfolio."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `DistributionStarted` if `payment_at <= now`."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_distribution(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: CapitalDistribution (types :: pallet_corporate_actions :: distribution :: CapitalDistributionCall :: remove_distribution { ca_id , }))
      }
      #[doc = "Removes a distribution that hasn't started yet,"]
      #[doc = "unlocking the full amount in the distributor portfolio."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
      #[doc = "- `DistributionStarted` if `payment_at <= now`."]
      #[cfg(feature = "ink")]
      pub fn remove_distribution(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![27u8, 4u8];
        ca_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for CapitalDistributionCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CapitalDistributionQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CapitalDistributionQueryApi<'api> {
      #[doc = " All capital distributions, tied to their respective corporate actions (CAs)."]
      #[doc = ""]
      #[doc = " (CAId) => Distribution"]
      #[cfg(not(feature = "ink"))]
      pub async fn distributions(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_corporate_actions::distribution::Distribution>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 106u8, 209u8, 103u8, 105u8, 114u8, 107u8, 158u8, 5u8, 125u8, 150u8,
          235u8, 86u8, 125u8, 11u8, 175u8, 145u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All capital distributions, tied to their respective corporate actions (CAs)."]
      #[doc = ""]
      #[doc = " (CAId) => Distribution"]
      #[cfg(feature = "ink")]
      pub fn distributions(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_corporate_actions::distribution::Distribution>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 106u8, 209u8, 103u8, 105u8, 114u8, 107u8, 158u8, 5u8, 125u8, 150u8,
          235u8, 86u8, 125u8, 11u8, 175u8, 145u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Has an asset holder been paid yet?"]
      #[doc = ""]
      #[doc = " (CAId, DID) -> Was DID paid in the CAId?"]
      #[cfg(not(feature = "ink"))]
      pub async fn holder_paid(
        &self,
        key_0: (
          types::pallet_corporate_actions::CAId,
          ::polymesh_api_client::IdentityId,
        ),
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 55u8, 215u8, 43u8, 172u8, 158u8, 205u8, 29u8, 130u8, 146u8, 125u8,
          52u8, 215u8, 183u8, 138u8, 60u8, 26u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Has an asset holder been paid yet?"]
      #[doc = ""]
      #[doc = " (CAId, DID) -> Was DID paid in the CAId?"]
      #[cfg(feature = "ink")]
      pub fn holder_paid(
        &self,
        key_0: (
          types::pallet_corporate_actions::CAId,
          ::polymesh_api_client::IdentityId,
        ),
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 55u8, 215u8, 43u8, 172u8, 158u8, 205u8, 29u8, 130u8, 146u8, 125u8,
          52u8, 215u8, 183u8, 138u8, 60u8, 26u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::pallet_corporate_actions::distribution::Version,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::distribution::Version>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::distribution::Version>
      {
        let value = self.api.read_storage(::alloc::vec![
          81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8, 52u8,
          39u8, 59u8, 17u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::distribution::Version>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
    }
  }
  pub mod checkpoint {
    use super::*;
    #[derive(Clone)]
    pub struct CheckpointCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CheckpointCallApi<'api> {
      #[doc = "Creates a single checkpoint at the current time."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "- `ticker` to create the checkpoint for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`."]
      #[doc = "- `CounterOverflow` if the total checkpoint counter would overflow."]
      #[cfg(not(feature = "ink"))]
      pub fn create_checkpoint(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
          types::pallet_asset::checkpoint::CheckpointCall::create_checkpoint { ticker },
        ))
      }
      #[doc = "Creates a single checkpoint at the current time."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "- `ticker` to create the checkpoint for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`."]
      #[doc = "- `CounterOverflow` if the total checkpoint counter would overflow."]
      #[cfg(feature = "ink")]
      pub fn create_checkpoint(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![28u8, 0u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Sets the max complexity of a schedule set for an arbitrary ticker to `max_complexity`."]
      #[doc = "The new maximum is not enforced retroactively,"]
      #[doc = "and only applies once new schedules are made."]
      #[doc = ""]
      #[doc = "Must be called as a PIP (requires \"root\")."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is the root origin."]
      #[doc = "- `max_complexity` allowed for an arbitrary ticker's schedule set."]
      #[cfg(not(feature = "ink"))]
      pub fn set_schedules_max_complexity(
        &self,
        max_complexity: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
          types::pallet_asset::checkpoint::CheckpointCall::set_schedules_max_complexity {
            max_complexity,
          },
        ))
      }
      #[doc = "Sets the max complexity of a schedule set for an arbitrary ticker to `max_complexity`."]
      #[doc = "The new maximum is not enforced retroactively,"]
      #[doc = "and only applies once new schedules are made."]
      #[doc = ""]
      #[doc = "Must be called as a PIP (requires \"root\")."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is the root origin."]
      #[doc = "- `max_complexity` allowed for an arbitrary ticker's schedule set."]
      #[cfg(feature = "ink")]
      pub fn set_schedules_max_complexity(&self, max_complexity: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![28u8, 1u8];
        max_complexity.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Creates a schedule generating checkpoints"]
      #[doc = "in the future at either a fixed time or at intervals."]
      #[doc = ""]
      #[doc = "The schedule starts out with `strong_ref_count(schedule_id) <- 0`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as owner of `ticker`."]
      #[doc = "- `ticker` to create the schedule for."]
      #[doc = "- `schedule` that will generate checkpoints."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`."]
      #[doc = "- `InsufficientAccountBalance` if the protocol fee could not be charged."]
      #[doc = "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn create_schedule(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        schedule: types::polymesh_common_utilities::traits::checkpoint::ScheduleCheckpoints,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
          types::pallet_asset::checkpoint::CheckpointCall::create_schedule { ticker, schedule },
        ))
      }
      #[doc = "Creates a schedule generating checkpoints"]
      #[doc = "in the future at either a fixed time or at intervals."]
      #[doc = ""]
      #[doc = "The schedule starts out with `strong_ref_count(schedule_id) <- 0`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as owner of `ticker`."]
      #[doc = "- `ticker` to create the schedule for."]
      #[doc = "- `schedule` that will generate checkpoints."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`."]
      #[doc = "- `InsufficientAccountBalance` if the protocol fee could not be charged."]
      #[doc = "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn create_schedule(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        schedule: types::polymesh_common_utilities::traits::checkpoint::ScheduleCheckpoints,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![28u8, 2u8];
        ticker.encode_to(&mut buf);
        schedule.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the checkpoint schedule of an asset identified by `id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as owner of `ticker`."]
      #[doc = "- `ticker` to remove the schedule from."]
      #[doc = "- `id` of the schedule, when it was created by `created_schedule`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`."]
      #[doc = "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `ticker`."]
      #[doc = "- `ScheduleNotRemovable` if `id` exists but is not removable."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_schedule(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        id: types::polymesh_common_utilities::traits::checkpoint::ScheduleId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
          types::pallet_asset::checkpoint::CheckpointCall::remove_schedule { ticker, id },
        ))
      }
      #[doc = "Removes the checkpoint schedule of an asset identified by `id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as owner of `ticker`."]
      #[doc = "- `ticker` to remove the schedule from."]
      #[doc = "- `id` of the schedule, when it was created by `created_schedule`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `ticker`."]
      #[doc = "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `ticker`."]
      #[doc = "- `ScheduleNotRemovable` if `id` exists but is not removable."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_schedule(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        id: types::polymesh_common_utilities::traits::checkpoint::ScheduleId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![28u8, 3u8];
        ticker.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for CheckpointCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CheckpointQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CheckpointQueryApi<'api> {
      #[doc = " Total supply of the token at the checkpoint."]
      #[doc = ""]
      #[doc = " (ticker, checkpointId) -> total supply at given checkpoint"]
      #[cfg(not(feature = "ink"))]
      pub async fn total_supply(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset::CheckpointId,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 89u8, 148u8, 207u8, 218u8, 20u8, 205u8, 103u8, 225u8, 88u8, 102u8,
          71u8, 212u8, 0u8, 8u8, 171u8, 170u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Total supply of the token at the checkpoint."]
      #[doc = ""]
      #[doc = " (ticker, checkpointId) -> total supply at given checkpoint"]
      #[cfg(feature = "ink")]
      pub fn total_supply(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset::CheckpointId,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 89u8, 148u8, 207u8, 218u8, 20u8, 205u8, 103u8, 225u8, 88u8, 102u8,
          71u8, 212u8, 0u8, 8u8, 171u8, 170u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Balance of a DID at a checkpoint."]
      #[doc = ""]
      #[doc = " (ticker, did, checkpoint ID) -> Balance of a DID at a checkpoint"]
      #[cfg(not(feature = "ink"))]
      pub async fn balance(
        &self,
        key_0: (
          types::polymesh_primitives::ticker::Ticker,
          types::polymesh_primitives::asset::CheckpointId,
        ),
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 78u8, 168u8, 234u8, 12u8, 1u8, 250u8, 164u8, 43u8, 110u8, 179u8,
          68u8, 168u8, 92u8, 71u8, 179u8, 135u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Balance of a DID at a checkpoint."]
      #[doc = ""]
      #[doc = " (ticker, did, checkpoint ID) -> Balance of a DID at a checkpoint"]
      #[cfg(feature = "ink")]
      pub fn balance(
        &self,
        key_0: (
          types::polymesh_primitives::ticker::Ticker,
          types::polymesh_primitives::asset::CheckpointId,
        ),
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 78u8, 168u8, 234u8, 12u8, 1u8, 250u8, 164u8, 43u8, 110u8, 179u8,
          68u8, 168u8, 92u8, 71u8, 179u8, 135u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoints ID generator sequence."]
      #[doc = " ID of first checkpoint is 1 instead of 0."]
      #[doc = ""]
      #[doc = " (ticker) -> no. of checkpoints"]
      #[cfg(not(feature = "ink"))]
      pub async fn checkpoint_id_sequence(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::asset::CheckpointId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 125u8, 12u8, 59u8, 36u8, 10u8, 236u8, 235u8, 137u8, 107u8, 225u8,
          196u8, 253u8, 46u8, 38u8, 239u8, 219u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset::CheckpointId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoints ID generator sequence."]
      #[doc = " ID of first checkpoint is 1 instead of 0."]
      #[doc = ""]
      #[doc = " (ticker) -> no. of checkpoints"]
      #[cfg(feature = "ink")]
      pub fn checkpoint_id_sequence(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::asset::CheckpointId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 125u8, 12u8, 59u8, 36u8, 10u8, 236u8, 235u8, 137u8, 107u8, 225u8,
          196u8, 253u8, 46u8, 38u8, 239u8, 219u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::asset::CheckpointId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoints where a DID's balance was updated."]
      #[doc = " (ticker, did) -> [checkpoint ID where user balance changed]"]
      #[cfg(not(feature = "ink"))]
      pub async fn balance_updates(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 143u8, 217u8, 170u8, 216u8, 91u8, 210u8, 121u8, 231u8, 28u8, 142u8,
          98u8, 99u8, 214u8, 201u8, 229u8, 250u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Checkpoints where a DID's balance was updated."]
      #[doc = " (ticker, did) -> [checkpoint ID where user balance changed]"]
      #[cfg(feature = "ink")]
      pub fn balance_updates(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 143u8, 217u8, 170u8, 216u8, 91u8, 210u8, 121u8, 231u8, 28u8, 142u8,
          98u8, 99u8, 214u8, 201u8, 229u8, 250u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Checkpoint timestamps."]
      #[doc = ""]
      #[doc = " Every schedule-originated checkpoint maps its ID to its due time."]
      #[doc = " Every checkpoint manually created maps its ID to the time of recording."]
      #[doc = ""]
      #[doc = " (ticker) -> (checkpoint ID) -> checkpoint timestamp"]
      #[cfg(not(feature = "ink"))]
      pub async fn timestamps(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset::CheckpointId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 212u8, 135u8, 3u8, 189u8, 214u8, 233u8, 162u8, 207u8, 215u8, 14u8,
          169u8, 158u8, 121u8, 254u8, 114u8, 232u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoint timestamps."]
      #[doc = ""]
      #[doc = " Every schedule-originated checkpoint maps its ID to its due time."]
      #[doc = " Every checkpoint manually created maps its ID to the time of recording."]
      #[doc = ""]
      #[doc = " (ticker) -> (checkpoint ID) -> checkpoint timestamp"]
      #[cfg(feature = "ink")]
      pub fn timestamps(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::asset::CheckpointId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 212u8, 135u8, 3u8, 189u8, 214u8, 233u8, 162u8, 207u8, 215u8, 14u8,
          169u8, 158u8, 121u8, 254u8, 114u8, 232u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum complexity allowed for a ticker's schedules."]
      #[cfg(not(feature = "ink"))]
      pub async fn schedules_max_complexity(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 157u8, 164u8, 151u8, 8u8, 64u8, 141u8, 200u8, 122u8, 167u8, 39u8,
          230u8, 249u8, 114u8, 60u8, 67u8, 180u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum complexity allowed for a ticker's schedules."]
      #[cfg(feature = "ink")]
      pub fn schedules_max_complexity(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 157u8, 164u8, 151u8, 8u8, 64u8, 141u8, 200u8, 122u8, 167u8, 39u8,
          230u8, 249u8, 114u8, 60u8, 67u8, 180u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Checkpoint schedule ID sequence for tickers."]
      #[doc = ""]
      #[doc = " (ticker) -> schedule ID"]
      #[cfg(not(feature = "ink"))]
      pub async fn schedule_id_sequence(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_common_utilities::traits::checkpoint::ScheduleId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 105u8, 127u8, 108u8, 151u8, 163u8, 248u8, 224u8, 135u8, 154u8, 147u8,
          248u8, 192u8, 179u8, 162u8, 41u8, 13u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_common_utilities::traits::checkpoint::ScheduleId>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Checkpoint schedule ID sequence for tickers."]
      #[doc = ""]
      #[doc = " (ticker) -> schedule ID"]
      #[cfg(feature = "ink")]
      pub fn schedule_id_sequence(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_common_utilities::traits::checkpoint::ScheduleId,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 105u8, 127u8, 108u8, 151u8, 163u8, 248u8, 224u8, 135u8, 154u8, 147u8,
          248u8, 192u8, 179u8, 162u8, 41u8, 13u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_common_utilities::traits::checkpoint::ScheduleId>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Cached next checkpoint for each schedule."]
      #[doc = ""]
      #[doc = " This is used to quickly find the next checkpoint from a ticker's schedules."]
      #[doc = ""]
      #[doc = " (ticker) -> next checkpoints"]
      #[cfg(not(feature = "ink"))]
      pub async fn cached_next_checkpoints(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_common_utilities::traits::checkpoint::NextCheckpoints>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 80u8, 107u8, 22u8, 3u8, 194u8, 86u8, 107u8, 33u8, 70u8, 40u8, 22u8,
          166u8, 84u8, 108u8, 245u8, 73u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Cached next checkpoint for each schedule."]
      #[doc = ""]
      #[doc = " This is used to quickly find the next checkpoint from a ticker's schedules."]
      #[doc = ""]
      #[doc = " (ticker) -> next checkpoints"]
      #[cfg(feature = "ink")]
      pub fn cached_next_checkpoints(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_common_utilities::traits::checkpoint::NextCheckpoints>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 80u8, 107u8, 22u8, 3u8, 194u8, 86u8, 107u8, 33u8, 70u8, 40u8, 22u8,
          166u8, 84u8, 108u8, 245u8, 73u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Scheduled checkpoints."]
      #[doc = ""]
      #[doc = " (ticker, schedule ID) -> schedule checkpoints"]
      #[cfg(not(feature = "ink"))]
      pub async fn scheduled_checkpoints(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_common_utilities::traits::checkpoint::ScheduleId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_common_utilities::traits::checkpoint::ScheduleCheckpoints>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 73u8, 231u8, 184u8, 207u8, 197u8, 218u8, 76u8, 26u8, 125u8, 44u8,
          6u8, 132u8, 44u8, 4u8, 76u8, 237u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Scheduled checkpoints."]
      #[doc = ""]
      #[doc = " (ticker, schedule ID) -> schedule checkpoints"]
      #[cfg(feature = "ink")]
      pub fn scheduled_checkpoints(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_common_utilities::traits::checkpoint::ScheduleId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_common_utilities::traits::checkpoint::ScheduleCheckpoints>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 73u8, 231u8, 184u8, 207u8, 197u8, 218u8, 76u8, 26u8, 125u8, 44u8,
          6u8, 132u8, 44u8, 4u8, 76u8, 237u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " How many \"strong\" references are there to a given `ScheduleId`?"]
      #[doc = ""]
      #[doc = " The presence of a \"strong\" reference, in the sense of `Rc<T>`,"]
      #[doc = " entails that the referenced schedule cannot be removed."]
      #[doc = " Thus, as long as `strong_ref_count(schedule_id) > 0`,"]
      #[doc = " `remove_schedule(schedule_id)` will error."]
      #[doc = ""]
      #[doc = " (ticker, schedule ID) -> strong ref count"]
      #[cfg(not(feature = "ink"))]
      pub async fn schedule_ref_count(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_common_utilities::traits::checkpoint::ScheduleId,
      ) -> ::polymesh_api_client::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 237u8, 119u8, 84u8, 159u8, 230u8, 166u8, 65u8, 61u8, 186u8, 244u8,
          172u8, 93u8, 185u8, 128u8, 39u8, 122u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many \"strong\" references are there to a given `ScheduleId`?"]
      #[doc = ""]
      #[doc = " The presence of a \"strong\" reference, in the sense of `Rc<T>`,"]
      #[doc = " entails that the referenced schedule cannot be removed."]
      #[doc = " Thus, as long as `strong_ref_count(schedule_id) > 0`,"]
      #[doc = " `remove_schedule(schedule_id)` will error."]
      #[doc = ""]
      #[doc = " (ticker, schedule ID) -> strong ref count"]
      #[cfg(feature = "ink")]
      pub fn schedule_ref_count(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_common_utilities::traits::checkpoint::ScheduleId,
      ) -> ::polymesh_api_ink::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 237u8, 119u8, 84u8, 159u8, 230u8, 166u8, 65u8, 61u8, 186u8, 244u8,
          172u8, 93u8, 185u8, 128u8, 39u8, 122u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All the checkpoints a given schedule originated."]
      #[doc = ""]
      #[doc = " (ticker, schedule ID) -> [checkpoint ID]"]
      #[cfg(not(feature = "ink"))]
      pub async fn schedule_points(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_common_utilities::traits::checkpoint::ScheduleId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 169u8, 253u8, 229u8, 218u8, 162u8, 17u8, 213u8, 206u8, 52u8, 53u8,
          24u8, 44u8, 3u8, 149u8, 70u8, 134u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " All the checkpoints a given schedule originated."]
      #[doc = ""]
      #[doc = " (ticker, schedule ID) -> [checkpoint ID]"]
      #[cfg(feature = "ink")]
      pub fn schedule_points(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_common_utilities::traits::checkpoint::ScheduleId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 169u8, 253u8, 229u8, 218u8, 162u8, 17u8, 213u8, 206u8, 52u8, 53u8,
          24u8, 44u8, 3u8, 149u8, 70u8, 134u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_asset::checkpoint::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_asset::checkpoint::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_asset::checkpoint::Version> {
        let value = self.api.read_storage(::alloc::vec![
          195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8, 187u8, 151u8,
          103u8, 187u8, 14u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_asset::checkpoint::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod compliance_manager {
    use super::*;
    #[derive(Clone)]
    pub struct ComplianceManagerCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ComplianceManagerCallApi<'api> {
      #[doc = "Adds a compliance requirement to an asset's compliance by ticker."]
      #[doc = "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = "* sender_conditions - Sender transfer conditions."]
      #[doc = "* receiver_conditions - Receiver transfer conditions."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn add_compliance_requirement(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        sender_conditions: ::alloc::vec::Vec<types::polymesh_primitives::condition::Condition>,
        receiver_conditions: ::alloc::vec::Vec<types::polymesh_primitives::condition::Condition>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::add_compliance_requirement {
            ticker,
            sender_conditions,
            receiver_conditions,
          },
        ))
      }
      #[doc = "Adds a compliance requirement to an asset's compliance by ticker."]
      #[doc = "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = "* sender_conditions - Sender transfer conditions."]
      #[doc = "* receiver_conditions - Receiver transfer conditions."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn add_compliance_requirement(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        sender_conditions: ::alloc::vec::Vec<types::polymesh_primitives::condition::Condition>,
        receiver_conditions: ::alloc::vec::Vec<types::polymesh_primitives::condition::Condition>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 0u8];
        ticker.encode_to(&mut buf);
        sender_conditions.encode_to(&mut buf);
        receiver_conditions.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes a compliance requirement from an asset's compliance."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = "* id - Compliance requirement id which is need to be removed"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_compliance_requirement(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        id: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::remove_compliance_requirement {
            ticker,
            id,
          },
        ))
      }
      #[doc = "Removes a compliance requirement from an asset's compliance."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = "* id - Compliance requirement id which is need to be removed"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_compliance_requirement(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        id: u32,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 1u8];
        ticker.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Replaces an asset's compliance by ticker with a new compliance."]
      #[doc = ""]
      #[doc = "Compliance requirements will be sorted (ascending by id) before"]
      #[doc = "replacing the current requirements."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `ticker` - the asset ticker,"]
      #[doc = "* `asset_compliance - the new asset compliance."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `Unauthorized` if `origin` is not the owner of the ticker."]
      #[doc = "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn replace_asset_compliance(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        asset_compliance: ::alloc::vec::Vec<
          types::polymesh_primitives::compliance_manager::ComplianceRequirement,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::replace_asset_compliance {
            ticker,
            asset_compliance,
          },
        ))
      }
      #[doc = "Replaces an asset's compliance by ticker with a new compliance."]
      #[doc = ""]
      #[doc = "Compliance requirements will be sorted (ascending by id) before"]
      #[doc = "replacing the current requirements."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `ticker` - the asset ticker,"]
      #[doc = "* `asset_compliance - the new asset compliance."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `Unauthorized` if `origin` is not the owner of the ticker."]
      #[doc = "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn replace_asset_compliance(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        asset_compliance: ::alloc::vec::Vec<
          types::polymesh_primitives::compliance_manager::ComplianceRequirement,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 2u8];
        ticker.encode_to(&mut buf);
        asset_compliance.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes an asset's compliance"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn reset_asset_compliance(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::reset_asset_compliance {
            ticker,
          },
        ))
      }
      #[doc = "Removes an asset's compliance"]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn reset_asset_compliance(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 3u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Pauses the verification of conditions for `ticker` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn pause_asset_compliance(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::pause_asset_compliance {
            ticker,
          },
        ))
      }
      #[doc = "Pauses the verification of conditions for `ticker` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn pause_asset_compliance(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 4u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Resumes the verification of conditions for `ticker` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn resume_asset_compliance(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::resume_asset_compliance {
            ticker,
          },
        ))
      }
      #[doc = "Resumes the verification of conditions for `ticker` during transfers."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker"]
      #[doc = "* ticker - Symbol of the asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn resume_asset_compliance(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 5u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds another default trusted claim issuer at the ticker level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker."]
      #[doc = "* ticker - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn add_default_trusted_claim_issuer(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        issuer: types::polymesh_primitives::condition::TrustedIssuer,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: ComplianceManagerCall :: add_default_trusted_claim_issuer { ticker , issuer , }))
      }
      #[doc = "Adds another default trusted claim issuer at the ticker level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker."]
      #[doc = "* ticker - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn add_default_trusted_claim_issuer(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        issuer: types::polymesh_primitives::condition::TrustedIssuer,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 6u8];
        ticker.encode_to(&mut buf);
        issuer.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the given `issuer` from the set of default trusted claim issuers at the ticker level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker."]
      #[doc = "* ticker - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_default_trusted_claim_issuer(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        issuer: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: ComplianceManagerCall :: remove_default_trusted_claim_issuer { ticker , issuer , }))
      }
      #[doc = "Removes the given `issuer` from the set of default trusted claim issuers at the ticker level."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker."]
      #[doc = "* ticker - Symbol of the asset."]
      #[doc = "* issuer - IdentityId of the trusted claim issuer."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_default_trusted_claim_issuer(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        issuer: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 7u8];
        ticker.encode_to(&mut buf);
        issuer.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Modify an existing compliance requirement of a given ticker."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker."]
      #[doc = "* ticker - Symbol of the asset."]
      #[doc = "* new_req - Compliance requirement."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn change_compliance_requirement(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        new_req: types::polymesh_primitives::compliance_manager::ComplianceRequirement,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ComplianceManager(
          types::pallet_compliance_manager::ComplianceManagerCall::change_compliance_requirement {
            ticker,
            new_req,
          },
        ))
      }
      #[doc = "Modify an existing compliance requirement of a given ticker."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* origin - Signer of the dispatchable. It should be the owner of the ticker."]
      #[doc = "* ticker - Symbol of the asset."]
      #[doc = "* new_req - Compliance requirement."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn change_compliance_requirement(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        new_req: types::polymesh_primitives::compliance_manager::ComplianceRequirement,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![29u8, 8u8];
        ticker.encode_to(&mut buf);
        new_req.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ComplianceManagerCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ComplianceManagerQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ComplianceManagerQueryApi<'api> {
      #[doc = " Asset compliance for a ticker (Ticker -> AssetCompliance)"]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_compliances(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::compliance_manager::AssetCompliance,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 174u8, 4u8, 188u8, 209u8, 112u8, 119u8, 72u8, 235u8, 75u8, 159u8, 89u8,
          9u8, 248u8, 244u8, 242u8, 195u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::polymesh_primitives::compliance_manager::AssetCompliance>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Asset compliance for a ticker (Ticker -> AssetCompliance)"]
      #[cfg(feature = "ink")]
      pub fn asset_compliances(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::compliance_manager::AssetCompliance,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 174u8, 4u8, 188u8, 209u8, 112u8, 119u8, 72u8, 235u8, 75u8, 159u8, 89u8,
          9u8, 248u8, 244u8, 242u8, 195u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::polymesh_primitives::compliance_manager::AssetCompliance>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " List of trusted claim issuer Ticker -> Issuer Identity"]
      #[cfg(not(feature = "ink"))]
      pub async fn trusted_claim_issuer(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 7u8, 112u8, 219u8, 149u8, 59u8, 221u8, 90u8, 127u8, 146u8, 167u8, 42u8,
          117u8, 122u8, 15u8, 129u8, 253u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " List of trusted claim issuer Ticker -> Issuer Identity"]
      #[cfg(feature = "ink")]
      pub fn trusted_claim_issuer(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 7u8, 112u8, 219u8, 149u8, 59u8, 221u8, 90u8, 127u8, 146u8, 167u8, 42u8,
          117u8, 122u8, 15u8, 129u8, 253u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_compliance_manager::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_compliance_manager::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_compliance_manager::Version> {
        let value = self.api.read_storage(::alloc::vec![
          255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8, 53u8, 193u8,
          10u8, 8u8, 220u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_compliance_manager::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod corporate_action {
    use super::*;
    #[derive(Clone)]
    pub struct CorporateActionCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CorporateActionCallApi<'api> {
      #[doc = "Set the max `length` of `details` in terms of bytes."]
      #[doc = "May only be called via a PIP."]
      #[cfg(not(feature = "ink"))]
      pub fn set_max_details_length(
        &self,
        length: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::set_max_details_length { length },
        ))
      }
      #[doc = "Set the max `length` of `details` in terms of bytes."]
      #[doc = "May only be called via a PIP."]
      #[cfg(feature = "ink")]
      pub fn set_max_details_length(&self, length: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 0u8];
        length.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the default CA `TargetIdentities` to `targets`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` for which the default identities are changing."]
      #[doc = "- `targets` the default target identities for a CA."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_default_targets(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        targets: types::pallet_corporate_actions::TargetIdentities,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::set_default_targets {
            ticker,
            targets,
          },
        ))
      }
      #[doc = "Set the default CA `TargetIdentities` to `targets`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` for which the default identities are changing."]
      #[doc = "- `targets` the default target identities for a CA."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_default_targets(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        targets: types::pallet_corporate_actions::TargetIdentities,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 1u8];
        ticker.encode_to(&mut buf);
        targets.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the default withholding tax for all DIDs and CAs relevant to this `ticker`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` that the withholding tax will apply to."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_default_withholding_tax(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        tax: ::polymesh_api_client::per_things::Permill,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::set_default_withholding_tax {
            ticker,
            tax,
          },
        ))
      }
      #[doc = "Set the default withholding tax for all DIDs and CAs relevant to this `ticker`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` that the withholding tax will apply to."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_default_withholding_tax(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        tax: ::polymesh_api_client::per_things::Permill,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 2u8];
        ticker.encode_to(&mut buf);
        tax.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set the withholding tax of `ticker` for `taxed_did` to `tax`."]
      #[doc = "If `Some(tax)`, this overrides the default withholding tax of `ticker` to `tax` for `taxed_did`."]
      #[doc = "Otherwise, if `None`, the default withholding tax will be used."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` that the withholding tax will apply to."]
      #[doc = "- `taxed_did` that will have its withholding tax updated."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_did_withholding_tax(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        taxed_did: ::polymesh_api_client::IdentityId,
        tax: Option<::polymesh_api_client::per_things::Permill>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::set_did_withholding_tax {
            ticker,
            taxed_did,
            tax,
          },
        ))
      }
      #[doc = "Set the withholding tax of `ticker` for `taxed_did` to `tax`."]
      #[doc = "If `Some(tax)`, this overrides the default withholding tax of `ticker` to `tax` for `taxed_did`."]
      #[doc = "Otherwise, if `None`, the default withholding tax will be used."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` that the withholding tax will apply to."]
      #[doc = "- `taxed_did` that will have its withholding tax updated."]
      #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_did_withholding_tax(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        taxed_did: ::polymesh_api_client::IdentityId,
        tax: Option<::polymesh_api_client::per_things::Permill>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 3u8];
        ticker.encode_to(&mut buf);
        taxed_did.encode_to(&mut buf);
        tax.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Initiates a CA for `ticker` of `kind` with `details` and other provided arguments."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` that the CA is made for."]
      #[doc = "- `kind` of CA being initiated."]
      #[doc = "- `decl_date` of CA bring initialized."]
      #[doc = "- `record_date`, if any, to calculate the impact of this CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = "- `details` of the CA in free-text form, up to a certain number of bytes in length."]
      #[doc = "- `targets`, if any, which this CA is relevant/irrelevant to."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_targets`)."]
      #[doc = "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)."]
      #[doc = "- `withholding_tax`, if any, provides per-DID withholding tax overrides."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `CounterOverflow` in the unlikely event that so many CAs were created for this `ticker`,"]
      #[doc = "  that integer overflow would have occured if instead allowed."]
      #[doc = "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`."]
      #[doc = "- `DuplicateDidTax` if a DID is included more than once in `wt`."]
      #[doc = "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`."]
      #[doc = "- `DeclDateInFuture` if the declaration date is not in the past."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn initiate_corporate_action(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        kind: types::pallet_corporate_actions::CAKind,
        decl_date: u64,
        record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
        details: types::pallet_corporate_actions::CADetails,
        targets: Option<types::pallet_corporate_actions::TargetIdentities>,
        default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
        withholding_tax: Option<
          ::alloc::vec::Vec<(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::per_things::Permill,
          )>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::initiate_corporate_action {
            ticker,
            kind,
            decl_date,
            record_date,
            details,
            targets,
            default_withholding_tax,
            withholding_tax,
          },
        ))
      }
      #[doc = "Initiates a CA for `ticker` of `kind` with `details` and other provided arguments."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ticker` with relevant permissions."]
      #[doc = "- `ticker` that the CA is made for."]
      #[doc = "- `kind` of CA being initiated."]
      #[doc = "- `decl_date` of CA bring initialized."]
      #[doc = "- `record_date`, if any, to calculate the impact of this CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = "- `details` of the CA in free-text form, up to a certain number of bytes in length."]
      #[doc = "- `targets`, if any, which this CA is relevant/irrelevant to."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_targets`)."]
      #[doc = "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)."]
      #[doc = "- `withholding_tax`, if any, provides per-DID withholding tax overrides."]
      #[doc = "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `CounterOverflow` in the unlikely event that so many CAs were created for this `ticker`,"]
      #[doc = "  that integer overflow would have occured if instead allowed."]
      #[doc = "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`."]
      #[doc = "- `DuplicateDidTax` if a DID is included more than once in `wt`."]
      #[doc = "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`."]
      #[doc = "- `DeclDateInFuture` if the declaration date is not in the past."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn initiate_corporate_action(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        kind: types::pallet_corporate_actions::CAKind,
        decl_date: u64,
        record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
        details: types::pallet_corporate_actions::CADetails,
        targets: Option<types::pallet_corporate_actions::TargetIdentities>,
        default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
        withholding_tax: Option<
          ::alloc::vec::Vec<(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::per_things::Permill,
          )>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 4u8];
        ticker.encode_to(&mut buf);
        kind.encode_to(&mut buf);
        decl_date.encode_to(&mut buf);
        record_date.encode_to(&mut buf);
        details.encode_to(&mut buf);
        targets.encode_to(&mut buf);
        default_withholding_tax.encode_to(&mut buf);
        withholding_tax.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Link the given CA `id` to the given `docs`."]
      #[doc = "Any previous links for the CA are removed in favor of `docs`."]
      #[doc = ""]
      #[doc = "The workflow here is to add the documents and initiating the CA in any order desired."]
      #[doc = "Once both exist, they can now be linked together."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `id.ticker` with relevant permissions."]
      #[doc = "- `id` of the CA to associate with `docs`."]
      #[doc = "- `docs` to associate with the CA with `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- `NoSuchDoc` if any of `docs` does not identify an existing document."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn link_ca_doc(
        &self,
        id: types::pallet_corporate_actions::CAId,
        docs: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::link_ca_doc { id, docs },
        ))
      }
      #[doc = "Link the given CA `id` to the given `docs`."]
      #[doc = "Any previous links for the CA are removed in favor of `docs`."]
      #[doc = ""]
      #[doc = "The workflow here is to add the documents and initiating the CA in any order desired."]
      #[doc = "Once both exist, they can now be linked together."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `id.ticker` with relevant permissions."]
      #[doc = "- `id` of the CA to associate with `docs`."]
      #[doc = "- `docs` to associate with the CA with `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- `NoSuchDoc` if any of `docs` does not identify an existing document."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn link_ca_doc(
        &self,
        id: types::pallet_corporate_actions::CAId,
        docs: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 5u8];
        id.encode_to(&mut buf);
        docs.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "Associated data, such as document links, ballots,"]
      #[doc = "and capital distributions are also removed."]
      #[doc = ""]
      #[doc = "Any schedule associated with the record date will see"]
      #[doc = "`strong_ref_count(schedule_id)` decremented."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.ticker` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_ca(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::remove_ca { ca_id },
        ))
      }
      #[doc = "Removes the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "Associated data, such as document links, ballots,"]
      #[doc = "and capital distributions are also removed."]
      #[doc = ""]
      #[doc = "Any schedule associated with the record date will see"]
      #[doc = "`strong_ref_count(schedule_id)` decremented."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.ticker` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn remove_ca(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 6u8];
        ca_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the record date of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.ticker` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to alter."]
      #[doc = "- `record_date`, if any, to calculate the impact of the CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn change_record_date(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
          types::pallet_corporate_actions::CorporateActionCall::change_record_date {
            ca_id,
            record_date,
          },
        ))
      }
      #[doc = "Changes the record date of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be an external agent of `ca_id.ticker` with relevant permissions."]
      #[doc = "- `ca_id` of the CA to alter."]
      #[doc = "- `record_date`, if any, to calculate the impact of the CA."]
      #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
      #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn change_record_date(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 7u8];
        ca_id.encode_to(&mut buf);
        record_date.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Utility extrinsic to batch `initiate_corporate_action` and `distribute`"]
      #[cfg(not(feature = "ink"))]
      pub fn initiate_corporate_action_and_distribute(
        &self,
        ca_args: types::pallet_corporate_actions::InitiateCorporateActionArgs,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
        currency: types::polymesh_primitives::ticker::Ticker,
        per_share: u128,
        amount: u128,
        payment_at: u64,
        expires_at: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self . api . wrap_call (runtime :: RuntimeCall :: CorporateAction (types :: pallet_corporate_actions :: CorporateActionCall :: initiate_corporate_action_and_distribute { ca_args , portfolio , currency , per_share , amount , payment_at , expires_at , }))
      }
      #[doc = "Utility extrinsic to batch `initiate_corporate_action` and `distribute`"]
      #[cfg(feature = "ink")]
      pub fn initiate_corporate_action_and_distribute(
        &self,
        ca_args: types::pallet_corporate_actions::InitiateCorporateActionArgs,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
        currency: types::polymesh_primitives::ticker::Ticker,
        per_share: u128,
        amount: u128,
        payment_at: u64,
        expires_at: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![30u8, 8u8];
        ca_args.encode_to(&mut buf);
        portfolio.encode_to(&mut buf);
        currency.encode_to(&mut buf);
        per_share.encode_to(&mut buf);
        amount.encode_to(&mut buf);
        payment_at.encode_to(&mut buf);
        expires_at.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for CorporateActionCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CorporateActionQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CorporateActionQueryApi<'api> {
      #[doc = " Determines the maximum number of bytes that the free-form `details` of a CA can store."]
      #[doc = ""]
      #[doc = " Note that this is not the number of `char`s or the number of [graphemes]."]
      #[doc = " While this may be unnatural in terms of human understanding of a text's length,"]
      #[doc = " it more closely reflects actual storage costs (`'a'` is cheaper to store than an emoji)."]
      #[doc = ""]
      #[doc = " [graphemes]: https://en.wikipedia.org/wiki/Grapheme"]
      #[cfg(not(feature = "ink"))]
      pub async fn max_details_length(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 35u8, 28u8, 123u8, 214u8, 108u8, 218u8, 59u8, 20u8, 118u8, 8u8, 139u8,
          67u8, 69u8, 136u8, 180u8, 5u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Determines the maximum number of bytes that the free-form `details` of a CA can store."]
      #[doc = ""]
      #[doc = " Note that this is not the number of `char`s or the number of [graphemes]."]
      #[doc = " While this may be unnatural in terms of human understanding of a text's length,"]
      #[doc = " it more closely reflects actual storage costs (`'a'` is cheaper to store than an emoji)."]
      #[doc = ""]
      #[doc = " [graphemes]: https://en.wikipedia.org/wiki/Grapheme"]
      #[cfg(feature = "ink")]
      pub fn max_details_length(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 35u8, 28u8, 123u8, 214u8, 108u8, 218u8, 59u8, 20u8, 118u8, 8u8, 139u8,
          67u8, 69u8, 136u8, 180u8, 5u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The identities targeted by default for CAs for this ticker,"]
      #[doc = " either to be excluded or included."]
      #[doc = ""]
      #[doc = " (ticker => target identities)"]
      #[cfg(not(feature = "ink"))]
      pub async fn default_target_identities(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::TargetIdentities>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 77u8, 99u8, 45u8, 196u8, 84u8, 74u8, 106u8, 171u8, 172u8, 166u8,
          213u8, 51u8, 51u8, 209u8, 34u8, 188u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 1u8];
          <types::pallet_corporate_actions::TargetIdentities>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The identities targeted by default for CAs for this ticker,"]
      #[doc = " either to be excluded or included."]
      #[doc = ""]
      #[doc = " (ticker => target identities)"]
      #[cfg(feature = "ink")]
      pub fn default_target_identities(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::TargetIdentities>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 77u8, 99u8, 45u8, 196u8, 84u8, 74u8, 106u8, 171u8, 172u8, 166u8,
          213u8, 51u8, 51u8, 209u8, 34u8, 188u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 1u8];
          <types::pallet_corporate_actions::TargetIdentities>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The default amount of tax to withhold (\"withholding tax\", WT) for this ticker when distributing dividends."]
      #[doc = ""]
      #[doc = " To understand withholding tax, e.g., let's assume that you hold ACME shares."]
      #[doc = " ACME now decides to distribute 100 SEK to Alice."]
      #[doc = " Alice lives in Sweden, so Skatteverket (the Swedish tax authority) wants 30% of that."]
      #[doc = " Then those 100 * 30% are withheld from Alice, and ACME will send them to Skatteverket."]
      #[doc = ""]
      #[doc = " (ticker => % to withhold)"]
      #[cfg(not(feature = "ink"))]
      pub async fn default_withholding_tax(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Permill> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 170u8, 50u8, 103u8, 81u8, 229u8, 40u8, 244u8, 16u8, 164u8, 129u8,
          103u8, 210u8, 52u8, 41u8, 13u8, 197u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Permill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The default amount of tax to withhold (\"withholding tax\", WT) for this ticker when distributing dividends."]
      #[doc = ""]
      #[doc = " To understand withholding tax, e.g., let's assume that you hold ACME shares."]
      #[doc = " ACME now decides to distribute 100 SEK to Alice."]
      #[doc = " Alice lives in Sweden, so Skatteverket (the Swedish tax authority) wants 30% of that."]
      #[doc = " Then those 100 * 30% are withheld from Alice, and ACME will send them to Skatteverket."]
      #[doc = ""]
      #[doc = " (ticker => % to withhold)"]
      #[cfg(feature = "ink")]
      pub fn default_withholding_tax(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Permill> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 170u8, 50u8, 103u8, 81u8, 229u8, 40u8, 244u8, 16u8, 164u8, 129u8,
          103u8, 210u8, 52u8, 41u8, 13u8, 197u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <::polymesh_api_client::per_things::Permill>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The amount of tax to withhold (\"withholding tax\", WT) for a certain ticker x DID."]
      #[doc = " If an entry exists for a certain DID, it overrides the default in `DefaultWithholdingTax`."]
      #[doc = ""]
      #[doc = " (ticker => [(did, % to withhold)]"]
      #[cfg(not(feature = "ink"))]
      pub async fn did_withholding_tax(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::per_things::Permill,
        )>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 224u8, 222u8, 223u8, 202u8, 239u8, 39u8, 125u8, 98u8, 152u8, 237u8,
          195u8, 114u8, 134u8, 40u8, 221u8, 13u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::per_things::Permill,
          )>>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The amount of tax to withhold (\"withholding tax\", WT) for a certain ticker x DID."]
      #[doc = " If an entry exists for a certain DID, it overrides the default in `DefaultWithholdingTax`."]
      #[doc = ""]
      #[doc = " (ticker => [(did, % to withhold)]"]
      #[cfg(feature = "ink")]
      pub fn did_withholding_tax(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<(
          ::polymesh_api_client::IdentityId,
          ::polymesh_api_client::per_things::Permill,
        )>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 224u8, 222u8, 223u8, 202u8, 239u8, 39u8, 125u8, 98u8, 152u8, 237u8,
          195u8, 114u8, 134u8, 40u8, 221u8, 13u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<(
            ::polymesh_api_client::IdentityId,
            ::polymesh_api_client::per_things::Permill,
          )>>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The next per-`Ticker` CA ID in the sequence."]
      #[doc = " The full ID is defined as a combination of `Ticker` and a number in this sequence."]
      #[cfg(not(feature = "ink"))]
      pub async fn ca_id_sequence(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::LocalCAId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 82u8, 91u8, 86u8, 204u8, 80u8, 123u8, 119u8, 166u8, 116u8, 44u8,
          136u8, 13u8, 78u8, 115u8, 129u8, 34u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_corporate_actions::LocalCAId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next per-`Ticker` CA ID in the sequence."]
      #[doc = " The full ID is defined as a combination of `Ticker` and a number in this sequence."]
      #[cfg(feature = "ink")]
      pub fn ca_id_sequence(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::LocalCAId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 82u8, 91u8, 86u8, 204u8, 80u8, 123u8, 119u8, 166u8, 116u8, 44u8,
          136u8, 13u8, 78u8, 115u8, 129u8, 34u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_corporate_actions::LocalCAId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All recorded CAs thus far."]
      #[doc = " Only generic information is stored here."]
      #[doc = " Specific `CAKind`s, e.g., benefits and corporate ballots, may use additional on-chain storage."]
      #[doc = ""]
      #[doc = " (ticker => local ID => the corporate action)"]
      #[cfg(not(feature = "ink"))]
      pub async fn corporate_actions(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::pallet_corporate_actions::LocalCAId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_corporate_actions::CorporateAction>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 14u8, 36u8, 40u8, 25u8, 103u8, 79u8, 185u8, 193u8, 131u8, 31u8, 153u8,
          37u8, 135u8, 74u8, 8u8, 159u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All recorded CAs thus far."]
      #[doc = " Only generic information is stored here."]
      #[doc = " Specific `CAKind`s, e.g., benefits and corporate ballots, may use additional on-chain storage."]
      #[doc = ""]
      #[doc = " (ticker => local ID => the corporate action)"]
      #[cfg(feature = "ink")]
      pub fn corporate_actions(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::pallet_corporate_actions::LocalCAId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_corporate_actions::CorporateAction>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 14u8, 36u8, 40u8, 25u8, 103u8, 79u8, 185u8, 193u8, 131u8, 31u8, 153u8,
          37u8, 135u8, 74u8, 8u8, 159u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Associations from CAs to `Document`s via their IDs."]
      #[doc = " (CAId => [DocumentId])"]
      #[doc = ""]
      #[doc = " The `CorporateActions` map stores `Ticker => LocalId => The CA`,"]
      #[doc = " so we can infer `Ticker => CAId`. Therefore, we don't need a double map."]
      #[cfg(not(feature = "ink"))]
      pub async fn ca_doc_link(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 120u8, 114u8, 125u8, 160u8, 162u8, 78u8, 111u8, 100u8, 74u8, 192u8,
          8u8, 173u8, 45u8, 35u8, 163u8, 153u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Associations from CAs to `Document`s via their IDs."]
      #[doc = " (CAId => [DocumentId])"]
      #[doc = ""]
      #[doc = " The `CorporateActions` map stores `Ticker => LocalId => The CA`,"]
      #[doc = " so we can infer `Ticker => CAId`. Therefore, we don't need a double map."]
      #[cfg(feature = "ink")]
      pub fn ca_doc_link(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 120u8, 114u8, 125u8, 160u8, 162u8, 78u8, 111u8, 100u8, 74u8, 192u8,
          8u8, 173u8, 45u8, 35u8, 163u8, 153u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Associates details in free-form text with a CA by its ID."]
      #[doc = " (CAId => CADetails)"]
      #[cfg(not(feature = "ink"))]
      pub async fn details(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::CADetails> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8, 198u8, 220u8,
          28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::CADetails>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Associates details in free-form text with a CA by its ID."]
      #[doc = " (CAId => CADetails)"]
      #[cfg(feature = "ink")]
      pub fn details(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::CADetails> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8, 198u8, 220u8,
          28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::CADetails>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::Version> {
        let value = self.api.read_storage(::alloc::vec![
          220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8, 217u8,
          32u8, 99u8, 238u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_corporate_actions::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod corporate_ballot {
    use super::*;
    #[derive(Clone)]
    pub struct CorporateBallotCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> CorporateBallotCallApi<'api> {
      #[doc = "Attach a corporate ballot to the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "The ballot will admit votes within `range`."]
      #[doc = "The ballot's metadata is provided by `meta`,"]
      #[doc = "which includes the ballot title, the motions, their choices, etc."]
      #[doc = "See the `BallotMeta` for more."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the CA to attach the ballot to."]
      #[doc = "- `range` specifies when voting starts and ends."]
      #[doc = "- `meta` specifies the ballot's metadata as aforementioned."]
      #[doc = "- `rcv` specifies whether RCV is enabled for this ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `CANotNotice` if the CA is not of the `IssuerNotice` kind."]
      #[doc = "- `StartAfterEnd` if `range.start > range.end`."]
      #[doc = "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp."]
      #[doc = "- `NoRecordDate` if CA has no record date."]
      #[doc = "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date."]
      #[doc = "- `AlreadyExists` if there's a ballot already."]
      #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
      #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
      #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
      #[cfg(not(feature = "ink"))]
      pub fn attach_ballot(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        range: types::pallet_corporate_actions::ballot::BallotTimeRange,
        meta: types::pallet_corporate_actions::ballot::BallotMeta,
        rcv: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::attach_ballot {
            ca_id,
            range,
            meta,
            rcv,
          },
        ))
      }
      #[doc = "Attach a corporate ballot to the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "The ballot will admit votes within `range`."]
      #[doc = "The ballot's metadata is provided by `meta`,"]
      #[doc = "which includes the ballot title, the motions, their choices, etc."]
      #[doc = "See the `BallotMeta` for more."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the CA to attach the ballot to."]
      #[doc = "- `range` specifies when voting starts and ends."]
      #[doc = "- `meta` specifies the ballot's metadata as aforementioned."]
      #[doc = "- `rcv` specifies whether RCV is enabled for this ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `CANotNotice` if the CA is not of the `IssuerNotice` kind."]
      #[doc = "- `StartAfterEnd` if `range.start > range.end`."]
      #[doc = "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp."]
      #[doc = "- `NoRecordDate` if CA has no record date."]
      #[doc = "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date."]
      #[doc = "- `AlreadyExists` if there's a ballot already."]
      #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
      #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
      #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
      #[cfg(feature = "ink")]
      pub fn attach_ballot(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        range: types::pallet_corporate_actions::ballot::BallotTimeRange,
        meta: types::pallet_corporate_actions::ballot::BallotMeta,
        rcv: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 0u8];
        ca_id.encode_to(&mut buf);
        range.encode_to(&mut buf);
        meta.encode_to(&mut buf);
        rcv.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Cast `votes` in the ballot attached to the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be a permissioned signer targeted by the CA."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `votes` specifies the balances to assign to each choice in the ballot."]
      #[doc = "   The full voting power of `origin`'s DID may be used for each motion in the ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingNotStarted` if the voting period hasn't commenced yet."]
      #[doc = "- `VotingAlreadyEnded` if the voting period has ended."]
      #[doc = "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
      #[doc = "- `InsufficientVotes` if the voting power used for any motion in `votes`"]
      #[doc = "   exceeds `origin`'s DID's voting power."]
      #[cfg(not(feature = "ink"))]
      pub fn vote(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        votes: ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::vote { ca_id, votes },
        ))
      }
      #[doc = "Cast `votes` in the ballot attached to the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` which must be a permissioned signer targeted by the CA."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `votes` specifies the balances to assign to each choice in the ballot."]
      #[doc = "   The full voting power of `origin`'s DID may be used for each motion in the ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingNotStarted` if the voting period hasn't commenced yet."]
      #[doc = "- `VotingAlreadyEnded` if the voting period has ended."]
      #[doc = "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`."]
      #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
      #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
      #[doc = "- `InsufficientVotes` if the voting power used for any motion in `votes`"]
      #[doc = "   exceeds `origin`'s DID's voting power."]
      #[cfg(feature = "ink")]
      pub fn vote(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        votes: ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 1u8];
        ca_id.encode_to(&mut buf);
        votes.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Amend the end date of the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `end` specifies the new end date of the ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[doc = "- `StartAfterEnd` if `start > end`."]
      #[cfg(not(feature = "ink"))]
      pub fn change_end(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        end: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::change_end { ca_id, end },
        ))
      }
      #[doc = "Amend the end date of the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `end` specifies the new end date of the ballot."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[doc = "- `StartAfterEnd` if `start > end`."]
      #[cfg(feature = "ink")]
      pub fn change_end(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        end: u64,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 2u8];
        ca_id.encode_to(&mut buf);
        end.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `meta` specifies the new metadata."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
      #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
      #[cfg(not(feature = "ink"))]
      pub fn change_meta(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        meta: types::pallet_corporate_actions::ballot::BallotMeta,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::change_meta { ca_id, meta },
        ))
      }
      #[doc = "Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `meta` specifies the new metadata."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
      #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
      #[cfg(feature = "ink")]
      pub fn change_meta(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        meta: types::pallet_corporate_actions::ballot::BallotMeta,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 3u8];
        ca_id.encode_to(&mut buf);
        meta.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Amend RCV support for the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `rcv` specifies if RCV is to be supported or not."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[cfg(not(feature = "ink"))]
      pub fn change_rcv(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        rcv: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::change_rcv { ca_id, rcv },
        ))
      }
      #[doc = "Amend RCV support for the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = "- `rcv` specifies if RCV is to be supported or not."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[cfg(feature = "ink")]
      pub fn change_rcv(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
        rcv: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 4u8];
        ca_id.encode_to(&mut buf);
        rcv.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_ballot(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
          types::pallet_corporate_actions::ballot::CorporateBallotCall::remove_ballot { ca_id },
        ))
      }
      #[doc = "Remove the ballot of the CA identified by `ca_id`."]
      #[doc = ""]
      #[doc = "## Arguments"]
      #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.ticker`."]
      #[doc = "- `ca_id` identifies the attached ballot's CA."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `ticker`."]
      #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
      #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
      #[cfg(feature = "ink")]
      pub fn remove_ballot(
        &self,
        ca_id: types::pallet_corporate_actions::CAId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![31u8, 5u8];
        ca_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for CorporateBallotCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct CorporateBallotQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> CorporateBallotQueryApi<'api> {
      #[doc = " Metadata of a corporate ballot."]
      #[doc = ""]
      #[doc = " (CAId) => BallotMeta"]
      #[cfg(not(feature = "ink"))]
      pub async fn metas(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_corporate_actions::ballot::BallotMeta>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 156u8, 233u8, 150u8, 83u8, 80u8, 111u8, 149u8, 210u8, 238u8, 76u8,
          158u8, 22u8, 106u8, 202u8, 6u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Metadata of a corporate ballot."]
      #[doc = ""]
      #[doc = " (CAId) => BallotMeta"]
      #[cfg(feature = "ink")]
      pub fn metas(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_corporate_actions::ballot::BallotMeta>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 156u8, 233u8, 150u8, 83u8, 80u8, 111u8, 149u8, 210u8, 238u8, 76u8,
          158u8, 22u8, 106u8, 202u8, 6u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Time details of a corporate ballot associated with a CA."]
      #[doc = " The timestamps denote when voting starts and stops."]
      #[doc = ""]
      #[doc = " (CAId) => BallotTimeRange"]
      #[cfg(not(feature = "ink"))]
      pub async fn time_ranges(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_corporate_actions::ballot::BallotTimeRange>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 224u8, 44u8, 93u8, 167u8, 153u8, 243u8, 193u8, 143u8, 81u8, 133u8,
          254u8, 177u8, 13u8, 204u8, 115u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Time details of a corporate ballot associated with a CA."]
      #[doc = " The timestamps denote when voting starts and stops."]
      #[doc = ""]
      #[doc = " (CAId) => BallotTimeRange"]
      #[cfg(feature = "ink")]
      pub fn time_ranges(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_corporate_actions::ballot::BallotTimeRange>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 224u8, 44u8, 93u8, 167u8, 153u8, 243u8, 193u8, 143u8, 81u8, 133u8,
          254u8, 177u8, 13u8, 204u8, 115u8, 80u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Stores how many choices there are in each motion."]
      #[doc = ""]
      #[doc = " At all times, the invariant holds that `motion_choices[idx]` is equal to"]
      #[doc = " `metas.unwrap().motions[idx].choices.len()`. That is, this is just a cache,"]
      #[doc = " used to avoid fetching all the motions with their associated texts."]
      #[doc = ""]
      #[doc = " `u16` choices should be more than enough to fit real use cases."]
      #[doc = ""]
      #[doc = " (CAId) => Number of choices in each motion."]
      #[cfg(not(feature = "ink"))]
      pub async fn motion_num_choices(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u16>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 128u8, 121u8, 46u8, 246u8, 146u8, 237u8, 189u8, 150u8, 253u8, 219u8,
          95u8, 102u8, 195u8, 212u8, 151u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u16>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores how many choices there are in each motion."]
      #[doc = ""]
      #[doc = " At all times, the invariant holds that `motion_choices[idx]` is equal to"]
      #[doc = " `metas.unwrap().motions[idx].choices.len()`. That is, this is just a cache,"]
      #[doc = " used to avoid fetching all the motions with their associated texts."]
      #[doc = ""]
      #[doc = " `u16` choices should be more than enough to fit real use cases."]
      #[doc = ""]
      #[doc = " (CAId) => Number of choices in each motion."]
      #[cfg(feature = "ink")]
      pub fn motion_num_choices(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u16>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 128u8, 121u8, 46u8, 246u8, 146u8, 237u8, 189u8, 150u8, 253u8, 219u8,
          95u8, 102u8, 195u8, 212u8, 151u8, 27u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u16>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Is ranked choice voting (RCV) enabled for this ballot?"]
      #[doc = " For an understanding of how RCV is handled, see note on `BallotVote`'s `fallback` field."]
      #[doc = ""]
      #[doc = " (CAId) => bool"]
      #[cfg(not(feature = "ink"))]
      pub async fn rcv(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 255u8, 206u8, 156u8, 27u8, 141u8, 170u8, 167u8, 14u8, 136u8, 113u8,
          191u8, 30u8, 171u8, 45u8, 90u8, 96u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Is ranked choice voting (RCV) enabled for this ballot?"]
      #[doc = " For an understanding of how RCV is handled, see note on `BallotVote`'s `fallback` field."]
      #[doc = ""]
      #[doc = " (CAId) => bool"]
      #[cfg(feature = "ink")]
      pub fn rcv(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 255u8, 206u8, 156u8, 27u8, 141u8, 170u8, 167u8, 14u8, 136u8, 113u8,
          191u8, 30u8, 171u8, 45u8, 90u8, 96u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores the total vote tally on each choice."]
      #[doc = ""]
      #[doc = " RCV is not accounted for,"]
      #[doc = " as there are too many wants to interpret the graph,"]
      #[doc = " and because it would not be efficient."]
      #[doc = ""]
      #[doc = " (CAId) => [current vote weights]"]
      #[cfg(not(feature = "ink"))]
      pub async fn results(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 2u8, 53u8, 15u8, 184u8, 68u8, 197u8, 167u8, 101u8, 105u8, 101u8,
          134u8, 40u8, 189u8, 68u8, 197u8, 62u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u128>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores the total vote tally on each choice."]
      #[doc = ""]
      #[doc = " RCV is not accounted for,"]
      #[doc = " as there are too many wants to interpret the graph,"]
      #[doc = " and because it would not be efficient."]
      #[doc = ""]
      #[doc = " (CAId) => [current vote weights]"]
      #[cfg(feature = "ink")]
      pub fn results(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u128>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 2u8, 53u8, 15u8, 184u8, 68u8, 197u8, 167u8, 101u8, 105u8, 101u8,
          134u8, 40u8, 189u8, 68u8, 197u8, 62u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<u128>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Stores each DID's votes in a given ballot."]
      #[doc = " See the documentation of `BallotVote` for notes on semantics."]
      #[doc = ""]
      #[doc = " (CAId) => (DID) => [vote weight]"]
      #[doc = ""]
      #[doc = " User must enter 0 vote weight if they don't want to vote for a choice."]
      #[cfg(not(feature = "ink"))]
      pub async fn votes(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8, 230u8, 150u8,
          237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Stores each DID's votes in a given ballot."]
      #[doc = " See the documentation of `BallotVote` for notes on semantics."]
      #[doc = ""]
      #[doc = " (CAId) => (DID) => [vote weight]"]
      #[doc = ""]
      #[doc = " User must enter 0 vote weight if they don't want to vote for a choice."]
      #[cfg(feature = "ink")]
      pub fn votes(
        &self,
        key_0: types::pallet_corporate_actions::CAId,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8, 7u8,
          48u8, 134u8, 127u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8, 230u8, 150u8,
          237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
    }
  }
  pub mod permissions {
    use super::*;
    #[derive(Clone)]
    pub struct PermissionsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PermissionsCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for PermissionsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PermissionsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PermissionsQueryApi<'api> {}
  }
  pub mod pips {
    use super::*;
    #[derive(Clone)]
    pub struct PipsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PipsCallApi<'api> {
      #[doc = "Change whether completed PIPs are pruned."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `prune` specifies whether completed PIPs should be pruned."]
      #[cfg(not(feature = "ink"))]
      pub fn set_prune_historical_pips(
        &self,
        prune: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_prune_historical_pips { prune },
        ))
      }
      #[doc = "Change whether completed PIPs are pruned."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `prune` specifies whether completed PIPs should be pruned."]
      #[cfg(feature = "ink")]
      pub fn set_prune_historical_pips(&self, prune: bool) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 0u8];
        prune.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the minimum proposal deposit amount required to start a proposal."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `deposit` the new min deposit required to start a proposal"]
      #[cfg(not(feature = "ink"))]
      pub fn set_min_proposal_deposit(
        &self,
        deposit: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_min_proposal_deposit { deposit },
        ))
      }
      #[doc = "Change the minimum proposal deposit amount required to start a proposal."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `deposit` the new min deposit required to start a proposal"]
      #[cfg(feature = "ink")]
      pub fn set_min_proposal_deposit(&self, deposit: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 1u8];
        deposit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the default enactment period."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `duration` the new default enactment period it takes for a scheduled PIP to be executed."]
      #[cfg(not(feature = "ink"))]
      pub fn set_default_enactment_period(
        &self,
        duration: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_default_enactment_period { duration },
        ))
      }
      #[doc = "Change the default enactment period."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `duration` the new default enactment period it takes for a scheduled PIP to be executed."]
      #[cfg(feature = "ink")]
      pub fn set_default_enactment_period(&self, duration: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 2u8];
        duration.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the amount of blocks after which a pending PIP is expired."]
      #[doc = "If `expiry` is `None` then PIPs never expire."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` the block-time it takes for a still-`Pending` PIP to expire."]
      #[cfg(not(feature = "ink"))]
      pub fn set_pending_pip_expiry(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_pending_pip_expiry { expiry },
        ))
      }
      #[doc = "Change the amount of blocks after which a pending PIP is expired."]
      #[doc = "If `expiry` is `None` then PIPs never expire."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `expiry` the block-time it takes for a still-`Pending` PIP to expire."]
      #[cfg(feature = "ink")]
      pub fn set_pending_pip_expiry(
        &self,
        expiry: types::polymesh_common_utilities::MaybeBlock<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 3u8];
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the maximum skip count (`max_pip_skip_count`)."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `max` skips before a PIP cannot be skipped by GC anymore."]
      #[cfg(not(feature = "ink"))]
      pub fn set_max_pip_skip_count(
        &self,
        max: u8,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_max_pip_skip_count { max },
        ))
      }
      #[doc = "Change the maximum skip count (`max_pip_skip_count`)."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `max` skips before a PIP cannot be skipped by GC anymore."]
      #[cfg(feature = "ink")]
      pub fn set_max_pip_skip_count(&self, max: u8) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 4u8];
        max.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the maximum number of active PIPs before community members cannot propose anything."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` of concurrent active PIPs."]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_pip_limit(
        &self,
        limit: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::set_active_pip_limit { limit },
        ))
      }
      #[doc = "Change the maximum number of active PIPs before community members cannot propose anything."]
      #[doc = "Can only be called by root."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `limit` of concurrent active PIPs."]
      #[cfg(feature = "ink")]
      pub fn set_active_pip_limit(&self, limit: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 5u8];
        limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "A network member creates a PIP by submitting a dispatchable which"]
      #[doc = "changes the network in someway. A minimum deposit is required to open a new proposal."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposer` is either a signing key or committee."]
      #[doc = "   Used to understand whether this is a committee proposal and verified against `origin`."]
      #[doc = "* `proposal` a dispatchable call"]
      #[doc = "* `deposit` minimum deposit value, which is ignored if `proposer` is a committee."]
      #[doc = "* `url` a link to a website for proposal discussion"]
      #[cfg(not(feature = "ink"))]
      pub fn propose(
        &self,
        proposal: runtime::RuntimeCall,
        deposit: u128,
        url: Option<types::polymesh_primitives::Url>,
        description: Option<types::pallet_pips::PipDescription>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::propose {
            proposal: ::alloc::boxed::Box::new(proposal),
            deposit,
            url,
            description,
          },
        ))
      }
      #[doc = "A network member creates a PIP by submitting a dispatchable which"]
      #[doc = "changes the network in someway. A minimum deposit is required to open a new proposal."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `proposer` is either a signing key or committee."]
      #[doc = "   Used to understand whether this is a committee proposal and verified against `origin`."]
      #[doc = "* `proposal` a dispatchable call"]
      #[doc = "* `deposit` minimum deposit value, which is ignored if `proposer` is a committee."]
      #[doc = "* `url` a link to a website for proposal discussion"]
      #[cfg(feature = "ink")]
      pub fn propose(
        &self,
        proposal: runtime::RuntimeCall,
        deposit: u128,
        url: Option<types::polymesh_primitives::Url>,
        description: Option<types::pallet_pips::PipDescription>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 6u8];
        proposal.encode_to(&mut buf);
        deposit.encode_to(&mut buf);
        url.encode_to(&mut buf);
        description.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Vote either in favor (`aye_or_nay` == true) or against a PIP with `id`."]
      #[doc = "The \"convinction\" or strength of the vote is given by `deposit`, which is reserved."]
      #[doc = ""]
      #[doc = "Note that `vote` is *not* additive."]
      #[doc = "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`"]
      #[doc = "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit."]
      #[doc = "To add atop of existing votes, you'll need `existing_deposit + addition`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`, proposal id"]
      #[doc = "* `aye_or_nay`, a bool representing for or against vote"]
      #[doc = "* `deposit`, the \"conviction\" with which the vote is made."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchProposal` if `id` doesn't reference a valid PIP."]
      #[doc = "* `NotFromCommunity` if proposal was made by a committee."]
      #[doc = "* `IncorrectProposalState` if PIP isn't pending."]
      #[doc = "* `InsufficientDeposit` if `origin` cannot reserve `deposit - old_deposit`."]
      #[cfg(not(feature = "ink"))]
      pub fn vote(
        &self,
        id: types::pallet_pips::PipId,
        aye_or_nay: bool,
        deposit: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::vote {
            id,
            aye_or_nay,
            deposit,
          },
        ))
      }
      #[doc = "Vote either in favor (`aye_or_nay` == true) or against a PIP with `id`."]
      #[doc = "The \"convinction\" or strength of the vote is given by `deposit`, which is reserved."]
      #[doc = ""]
      #[doc = "Note that `vote` is *not* additive."]
      #[doc = "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`"]
      #[doc = "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit."]
      #[doc = "To add atop of existing votes, you'll need `existing_deposit + addition`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`, proposal id"]
      #[doc = "* `aye_or_nay`, a bool representing for or against vote"]
      #[doc = "* `deposit`, the \"conviction\" with which the vote is made."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NoSuchProposal` if `id` doesn't reference a valid PIP."]
      #[doc = "* `NotFromCommunity` if proposal was made by a committee."]
      #[doc = "* `IncorrectProposalState` if PIP isn't pending."]
      #[doc = "* `InsufficientDeposit` if `origin` cannot reserve `deposit - old_deposit`."]
      #[cfg(feature = "ink")]
      pub fn vote(
        &self,
        id: types::pallet_pips::PipId,
        aye_or_nay: bool,
        deposit: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 7u8];
        id.encode_to(&mut buf);
        aye_or_nay.encode_to(&mut buf);
        deposit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Approves the pending committee PIP given by the `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal isn't pending."]
      #[doc = "* `NotByCommittee` if the proposal isn't by a committee."]
      #[cfg(not(feature = "ink"))]
      pub fn approve_committee_proposal(
        &self,
        id: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::approve_committee_proposal { id },
        ))
      }
      #[doc = "Approves the pending committee PIP given by the `id`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal isn't pending."]
      #[doc = "* `NotByCommittee` if the proposal isn't by a committee."]
      #[cfg(feature = "ink")]
      pub fn approve_committee_proposal(
        &self,
        id: types::pallet_pips::PipId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 8u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rejects the PIP given by the `id`, refunding any bonded funds,"]
      #[doc = "assuming it hasn't been cancelled or executed."]
      #[doc = "Note that proposals scheduled-for-execution can also be rejected."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal was cancelled or executed."]
      #[cfg(not(feature = "ink"))]
      pub fn reject_proposal(
        &self,
        id: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::reject_proposal { id },
        ))
      }
      #[doc = "Rejects the PIP given by the `id`, refunding any bonded funds,"]
      #[doc = "assuming it hasn't been cancelled or executed."]
      #[doc = "Note that proposals scheduled-for-execution can also be rejected."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal was cancelled or executed."]
      #[cfg(feature = "ink")]
      pub fn reject_proposal(&self, id: types::pallet_pips::PipId) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 9u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Prune the PIP given by the `id`, refunding any funds not already refunded."]
      #[doc = "The PIP may not be active"]
      #[doc = ""]
      #[doc = "This function is intended for storage garbage collection purposes."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal is active."]
      #[cfg(not(feature = "ink"))]
      pub fn prune_proposal(
        &self,
        id: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::prune_proposal { id },
        ))
      }
      #[doc = "Prune the PIP given by the `id`, refunding any funds not already refunded."]
      #[doc = "The PIP may not be active"]
      #[doc = ""]
      #[doc = "This function is intended for storage garbage collection purposes."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` unless a GC voting majority executes this function."]
      #[doc = "* `NoSuchProposal` if the PIP with `id` doesn't exist."]
      #[doc = "* `IncorrectProposalState` if the proposal is active."]
      #[cfg(feature = "ink")]
      pub fn prune_proposal(&self, id: types::pallet_pips::PipId) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 10u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the execution schedule of the PIP given by `id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `until` defines the future block where the enactment period will finished."]
      #[doc = "   `None` value means that enactment period is going to finish in the next block."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `RescheduleNotByReleaseCoordinator` unless triggered by release coordinator."]
      #[doc = "* `IncorrectProposalState` unless the proposal was in a scheduled state."]
      #[cfg(not(feature = "ink"))]
      pub fn reschedule_execution(
        &self,
        id: types::pallet_pips::PipId,
        until: Option<u32>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::reschedule_execution { id, until },
        ))
      }
      #[doc = "Updates the execution schedule of the PIP given by `id`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `until` defines the future block where the enactment period will finished."]
      #[doc = "   `None` value means that enactment period is going to finish in the next block."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `RescheduleNotByReleaseCoordinator` unless triggered by release coordinator."]
      #[doc = "* `IncorrectProposalState` unless the proposal was in a scheduled state."]
      #[cfg(feature = "ink")]
      pub fn reschedule_execution(
        &self,
        id: types::pallet_pips::PipId,
        until: Option<u32>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 11u8];
        id.encode_to(&mut buf);
        until.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Clears the snapshot and emits the event `SnapshotCleared`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[cfg(not(feature = "ink"))]
      pub fn clear_snapshot(
        &self,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::clear_snapshot,
        ))
      }
      #[doc = "Clears the snapshot and emits the event `SnapshotCleared`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[cfg(feature = "ink")]
      pub fn clear_snapshot(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![33u8, 12u8])
      }
      #[doc = "Takes a new snapshot of the current list of active && pending PIPs."]
      #[doc = "The PIPs are then sorted into a priority queue based on each PIP's weight."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[cfg(not(feature = "ink"))]
      pub fn snapshot(&self) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::snapshot,
        ))
      }
      #[doc = "Takes a new snapshot of the current list of active && pending PIPs."]
      #[doc = "The PIPs are then sorted into a priority queue based on each PIP's weight."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `NotACommitteeMember` - triggered when a non-GC-member executes the function."]
      #[cfg(feature = "ink")]
      pub fn snapshot(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![33u8, 13u8])
      }
      #[doc = "Enacts `results` for the PIPs in the snapshot queue."]
      #[doc = "The snapshot will be available for further enactments until it is cleared."]
      #[doc = ""]
      #[doc = "The `results` are encoded a list of `(id, result)` where `result` is applied to `id`."]
      #[doc = "Note that the snapshot priority queue is encoded with the *lowest priority first*."]
      #[doc = "so `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - unless a GC voting majority executes this function."]
      #[doc = "* `CannotSkipPip` - a given PIP has already been skipped too many times."]
      #[doc = "* `SnapshotResultTooLarge` - on len(results) > len(snapshot_queue)."]
      #[doc = "* `SnapshotIdMismatch` - if:"]
      #[doc = "  ```text"]
      #[doc = "    (i  0..SnapshotQueue.len())."]
      #[doc = "     results[i].0  SnapshotQueue[SnapshotQueue.len() - i].id"]
      #[doc = "  ```"]
      #[doc = "   This is protects against clearing queue while GC is voting."]
      #[cfg(not(feature = "ink"))]
      pub fn enact_snapshot_results(
        &self,
        results: ::alloc::vec::Vec<(
          types::pallet_pips::PipId,
          types::pallet_pips::SnapshotResult,
        )>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::enact_snapshot_results { results },
        ))
      }
      #[doc = "Enacts `results` for the PIPs in the snapshot queue."]
      #[doc = "The snapshot will be available for further enactments until it is cleared."]
      #[doc = ""]
      #[doc = "The `results` are encoded a list of `(id, result)` where `result` is applied to `id`."]
      #[doc = "Note that the snapshot priority queue is encoded with the *lowest priority first*."]
      #[doc = "so `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - unless a GC voting majority executes this function."]
      #[doc = "* `CannotSkipPip` - a given PIP has already been skipped too many times."]
      #[doc = "* `SnapshotResultTooLarge` - on len(results) > len(snapshot_queue)."]
      #[doc = "* `SnapshotIdMismatch` - if:"]
      #[doc = "  ```text"]
      #[doc = "    (i  0..SnapshotQueue.len())."]
      #[doc = "     results[i].0  SnapshotQueue[SnapshotQueue.len() - i].id"]
      #[doc = "  ```"]
      #[doc = "   This is protects against clearing queue while GC is voting."]
      #[cfg(feature = "ink")]
      pub fn enact_snapshot_results(
        &self,
        results: ::alloc::vec::Vec<(
          types::pallet_pips::PipId,
          types::pallet_pips::SnapshotResult,
        )>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 14u8];
        results.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Internal dispatchable that handles execution of a PIP."]
      #[cfg(not(feature = "ink"))]
      pub fn execute_scheduled_pip(
        &self,
        id: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::execute_scheduled_pip { id },
        ))
      }
      #[doc = "Internal dispatchable that handles execution of a PIP."]
      #[cfg(feature = "ink")]
      pub fn execute_scheduled_pip(
        &self,
        id: types::pallet_pips::PipId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 15u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Internal dispatchable that handles expiration of a PIP."]
      #[cfg(not(feature = "ink"))]
      pub fn expire_scheduled_pip(
        &self,
        did: ::polymesh_api_client::IdentityId,
        id: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Pips(
          types::pallet_pips::PipsCall::expire_scheduled_pip { did, id },
        ))
      }
      #[doc = "Internal dispatchable that handles expiration of a PIP."]
      #[cfg(feature = "ink")]
      pub fn expire_scheduled_pip(
        &self,
        did: ::polymesh_api_client::IdentityId,
        id: types::pallet_pips::PipId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![33u8, 16u8];
        did.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for PipsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PipsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PipsQueryApi<'api> {
      #[doc = " Determines whether historical PIP data is persisted or removed"]
      #[cfg(not(feature = "ink"))]
      pub async fn prune_historical_pips(&self) -> ::polymesh_api_client::error::Result<bool> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 189u8, 16u8, 192u8, 60u8, 149u8, 36u8, 81u8, 199u8, 53u8, 30u8,
          52u8, 222u8, 47u8, 68u8, 166u8, 44u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Determines whether historical PIP data is persisted or removed"]
      #[cfg(feature = "ink")]
      pub fn prune_historical_pips(&self) -> ::polymesh_api_ink::error::Result<bool> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 189u8, 16u8, 192u8, 60u8, 149u8, 36u8, 81u8, 199u8, 53u8, 30u8,
          52u8, 222u8, 47u8, 68u8, 166u8, 44u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum amount to be used as a deposit for community PIP creation."]
      #[cfg(not(feature = "ink"))]
      pub async fn minimum_proposal_deposit(&self) -> ::polymesh_api_client::error::Result<u128> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 142u8, 186u8, 24u8, 71u8, 175u8, 165u8, 243u8, 64u8, 139u8, 26u8,
          206u8, 10u8, 193u8, 132u8, 103u8, 2u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The minimum amount to be used as a deposit for community PIP creation."]
      #[cfg(feature = "ink")]
      pub fn minimum_proposal_deposit(&self) -> ::polymesh_api_ink::error::Result<u128> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 142u8, 186u8, 24u8, 71u8, 175u8, 165u8, 243u8, 64u8, 139u8, 26u8,
          206u8, 10u8, 193u8, 132u8, 103u8, 2u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Default enactment period that will be use after a proposal is accepted by GC."]
      #[cfg(not(feature = "ink"))]
      pub async fn default_enactment_period(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 51u8, 170u8, 252u8, 74u8, 212u8, 72u8, 38u8, 0u8, 53u8, 50u8, 101u8,
          120u8, 239u8, 111u8, 130u8, 18u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Default enactment period that will be use after a proposal is accepted by GC."]
      #[cfg(feature = "ink")]
      pub fn default_enactment_period(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 51u8, 170u8, 252u8, 74u8, 212u8, 72u8, 38u8, 0u8, 53u8, 50u8, 101u8,
          120u8, 239u8, 111u8, 130u8, 18u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many blocks will it take, after a `Pending` PIP expires,"]
      #[doc = " assuming it has not transitioned to another `ProposalState`?"]
      #[cfg(not(feature = "ink"))]
      pub async fn pending_pip_expiry(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 58u8, 147u8, 255u8, 239u8, 101u8, 133u8, 6u8, 145u8, 79u8, 53u8,
          65u8, 205u8, 53u8, 56u8, 227u8, 209u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many blocks will it take, after a `Pending` PIP expires,"]
      #[doc = " assuming it has not transitioned to another `ProposalState`?"]
      #[cfg(feature = "ink")]
      pub fn pending_pip_expiry(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_common_utilities::MaybeBlock<u32>>
      {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 58u8, 147u8, 255u8, 239u8, 101u8, 133u8, 6u8, 145u8, 79u8, 53u8,
          65u8, 205u8, 53u8, 56u8, 227u8, 209u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8];
          <types::polymesh_common_utilities::MaybeBlock<u32>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maximum times a PIP can be skipped before triggering `CannotSkipPip` in `enact_snapshot_results`."]
      #[cfg(not(feature = "ink"))]
      pub async fn max_pip_skip_count(&self) -> ::polymesh_api_client::error::Result<u8> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 220u8, 153u8, 145u8, 58u8, 218u8, 242u8, 187u8, 63u8, 0u8, 101u8,
          235u8, 95u8, 125u8, 163u8, 103u8, 164u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <u8>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maximum times a PIP can be skipped before triggering `CannotSkipPip` in `enact_snapshot_results`."]
      #[cfg(feature = "ink")]
      pub fn max_pip_skip_count(&self) -> ::polymesh_api_ink::error::Result<u8> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 220u8, 153u8, 145u8, 58u8, 218u8, 242u8, 187u8, 63u8, 0u8, 101u8,
          235u8, 95u8, 125u8, 163u8, 103u8, 164u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <u8>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum allowed number for `ActivePipCount`."]
      #[doc = " Once reached, new PIPs cannot be proposed by community members."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_pip_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 142u8, 176u8, 200u8, 221u8, 213u8, 71u8, 139u8, 145u8, 46u8, 82u8,
          219u8, 155u8, 155u8, 174u8, 243u8, 103u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The maximum allowed number for `ActivePipCount`."]
      #[doc = " Once reached, new PIPs cannot be proposed by community members."]
      #[cfg(feature = "ink")]
      pub fn active_pip_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 142u8, 176u8, 200u8, 221u8, 213u8, 71u8, 139u8, 145u8, 46u8, 82u8,
          219u8, 155u8, 155u8, 174u8, 243u8, 103u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals so far. id can be used to keep track of PIPs off-chain."]
      #[cfg(not(feature = "ink"))]
      pub async fn pip_id_sequence(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_pips::PipId> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 89u8, 187u8, 247u8, 248u8, 106u8, 18u8, 26u8, 188u8, 148u8, 170u8,
          211u8, 21u8, 5u8, 34u8, 135u8, 100u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_pips::PipId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposals so far. id can be used to keep track of PIPs off-chain."]
      #[cfg(feature = "ink")]
      pub fn pip_id_sequence(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::PipId> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 89u8, 187u8, 247u8, 248u8, 106u8, 18u8, 26u8, 188u8, 148u8, 170u8,
          211u8, 21u8, 5u8, 34u8, 135u8, 100u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_pips::PipId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Snapshots so far. id can be used to keep track of snapshots off-chain."]
      #[cfg(not(feature = "ink"))]
      pub async fn snapshot_id_sequence(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_pips::SnapshotId> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 6u8, 175u8, 149u8, 151u8, 152u8, 112u8, 164u8, 18u8, 129u8, 2u8,
          178u8, 5u8, 64u8, 255u8, 210u8, 228u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_pips::SnapshotId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Snapshots so far. id can be used to keep track of snapshots off-chain."]
      #[cfg(feature = "ink")]
      pub fn snapshot_id_sequence(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::SnapshotId> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 6u8, 175u8, 149u8, 151u8, 152u8, 112u8, 164u8, 18u8, 129u8, 2u8,
          178u8, 5u8, 64u8, 255u8, 210u8, 228u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::pallet_pips::SnapshotId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Total count of current pending or scheduled PIPs."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_pip_count(&self) -> ::polymesh_api_client::error::Result<u32> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 160u8, 15u8, 19u8, 210u8, 89u8, 80u8, 103u8, 48u8, 205u8, 26u8,
          95u8, 188u8, 201u8, 27u8, 117u8, 206u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Total count of current pending or scheduled PIPs."]
      #[cfg(feature = "ink")]
      pub fn active_pip_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 160u8, 15u8, 19u8, 210u8, 89u8, 80u8, 103u8, 48u8, 205u8, 26u8,
          95u8, 188u8, 201u8, 27u8, 117u8, 206u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The metadata of the active proposals."]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_metadata(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_pips::PipsMetadata<u32>>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 84u8, 36u8, 238u8, 140u8, 56u8, 250u8, 92u8, 7u8, 255u8, 42u8,
          121u8, 197u8, 145u8, 184u8, 96u8, 30u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The metadata of the active proposals."]
      #[cfg(feature = "ink")]
      pub fn proposal_metadata(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_pips::PipsMetadata<u32>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 84u8, 36u8, 238u8, 140u8, 56u8, 250u8, 92u8, 7u8, 255u8, 42u8,
          121u8, 197u8, 145u8, 184u8, 96u8, 30u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Those who have locked a deposit."]
      #[doc = " proposal (id, proposer) -> deposit"]
      #[cfg(not(feature = "ink"))]
      pub async fn deposits(
        &self,
        key_0: types::pallet_pips::PipId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_pips::DepositInfo<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 116u8, 166u8, 20u8, 219u8, 128u8, 33u8, 198u8, 189u8, 10u8, 2u8,
          138u8, 175u8, 223u8, 41u8, 221u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Those who have locked a deposit."]
      #[doc = " proposal (id, proposer) -> deposit"]
      #[cfg(feature = "ink")]
      pub fn deposits(
        &self,
        key_0: types::pallet_pips::PipId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_pips::DepositInfo<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 116u8, 166u8, 20u8, 219u8, 128u8, 33u8, 198u8, 189u8, 10u8, 2u8,
          138u8, 175u8, 223u8, 41u8, 221u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Actual proposal for a given id, if it's current."]
      #[doc = " proposal id -> proposal"]
      #[cfg(not(feature = "ink"))]
      pub async fn proposals(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_pips::Pip<runtime::RuntimeCall, ::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Actual proposal for a given id, if it's current."]
      #[doc = " proposal id -> proposal"]
      #[cfg(feature = "ink")]
      pub fn proposals(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_pips::Pip<runtime::RuntimeCall, ::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8, 29u8, 255u8, 174u8,
          47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[doc = " proposal id -> vote count"]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_result(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<types::pallet_pips::VotingResult> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 239u8, 64u8, 138u8, 67u8, 171u8, 101u8, 203u8, 26u8, 180u8, 173u8,
          95u8, 36u8, 142u8, 58u8, 33u8, 239u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::pallet_pips::VotingResult>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
      #[doc = " proposal id -> vote count"]
      #[cfg(feature = "ink")]
      pub fn proposal_result(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::VotingResult> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 239u8, 64u8, 138u8, 67u8, 171u8, 101u8, 203u8, 26u8, 180u8, 173u8,
          95u8, 36u8, 142u8, 58u8, 33u8, 239u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <types::pallet_pips::VotingResult>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Votes per Proposal and account. Used to avoid double vote issue."]
      #[doc = " (proposal id, account) -> Vote"]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_votes(
        &self,
        key_0: types::pallet_pips::PipId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_pips::Vote>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 38u8, 65u8, 14u8, 13u8, 124u8, 179u8, 198u8, 250u8, 215u8, 127u8,
          63u8, 42u8, 53u8, 72u8, 177u8, 49u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Votes per Proposal and account. Used to avoid double vote issue."]
      #[doc = " (proposal id, account) -> Vote"]
      #[cfg(feature = "ink")]
      pub fn proposal_votes(
        &self,
        key_0: types::pallet_pips::PipId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_pips::Vote>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 38u8, 65u8, 14u8, 13u8, 124u8, 179u8, 198u8, 250u8, 215u8, 127u8,
          63u8, 42u8, 53u8, 72u8, 177u8, 49u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Maps PIPs to the block at which they will be executed, if any."]
      #[cfg(not(feature = "ink"))]
      pub async fn pip_to_schedule(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 235u8, 79u8, 164u8, 184u8, 26u8, 18u8, 180u8, 116u8, 221u8, 96u8,
          50u8, 249u8, 124u8, 39u8, 211u8, 186u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Maps PIPs to the block at which they will be executed, if any."]
      #[cfg(feature = "ink")]
      pub fn pip_to_schedule(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 235u8, 79u8, 164u8, 184u8, 26u8, 18u8, 180u8, 116u8, 221u8, 96u8,
          50u8, 249u8, 124u8, 39u8, 211u8, 186u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A live priority queue (lowest priority at index 0)"]
      #[doc = " of pending PIPs up to the active limit."]
      #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
      #[doc = ""]
      #[doc = " Unlike `SnapshotQueue`, this queue is live, getting updated with each vote cast."]
      #[doc = " The snapshot is therefore essentially a point-in-time clone of this queue."]
      #[cfg(not(feature = "ink"))]
      pub async fn live_queue(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 199u8, 191u8, 241u8, 183u8, 34u8, 25u8, 14u8, 165u8, 58u8, 69u8,
          114u8, 15u8, 85u8, 83u8, 223u8, 90u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " A live priority queue (lowest priority at index 0)"]
      #[doc = " of pending PIPs up to the active limit."]
      #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
      #[doc = ""]
      #[doc = " Unlike `SnapshotQueue`, this queue is live, getting updated with each vote cast."]
      #[doc = " The snapshot is therefore essentially a point-in-time clone of this queue."]
      #[cfg(feature = "ink")]
      pub fn live_queue(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>
      {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 199u8, 191u8, 241u8, 183u8, 34u8, 25u8, 14u8, 165u8, 58u8, 69u8,
          114u8, 15u8, 85u8, 83u8, 223u8, 90u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The priority queue (lowest priority at index 0) of PIPs at the point of snapshotting."]
      #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
      #[doc = ""]
      #[doc = " A queued PIP can be skipped. Doing so bumps the `pip_skip_count`."]
      #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
      #[cfg(not(feature = "ink"))]
      pub async fn snapshot_queue(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 71u8, 8u8, 47u8, 250u8, 214u8, 91u8, 162u8, 233u8, 118u8, 69u8,
          120u8, 55u8, 47u8, 38u8, 190u8, 247u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The priority queue (lowest priority at index 0) of PIPs at the point of snapshotting."]
      #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
      #[doc = ""]
      #[doc = " A queued PIP can be skipped. Doing so bumps the `pip_skip_count`."]
      #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
      #[cfg(feature = "ink")]
      pub fn snapshot_queue(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>
      {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 71u8, 8u8, 47u8, 250u8, 214u8, 91u8, 162u8, 233u8, 118u8, 69u8,
          120u8, 55u8, 47u8, 38u8, 190u8, 247u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::SnapshottedPip>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The metadata of the snapshot, if there is one."]
      #[cfg(not(feature = "ink"))]
      pub async fn snapshot_meta(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_pips::SnapshotMetadata<u32, ::polymesh_api_client::AccountId>>,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 90u8, 74u8, 35u8, 0u8, 255u8, 31u8, 130u8, 141u8, 244u8, 34u8,
          103u8, 253u8, 93u8, 30u8, 199u8, 83u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The metadata of the snapshot, if there is one."]
      #[cfg(feature = "ink")]
      pub fn snapshot_meta(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_pips::SnapshotMetadata<u32, ::polymesh_api_client::AccountId>>,
      > {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 90u8, 74u8, 35u8, 0u8, 255u8, 31u8, 130u8, 141u8, 244u8, 34u8,
          103u8, 253u8, 93u8, 30u8, 199u8, 83u8,
        ])?;
        Ok(value)
      }
      #[doc = " The number of times a certain PIP has been skipped."]
      #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
      #[cfg(not(feature = "ink"))]
      pub async fn pip_skip_count(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<u8> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 225u8, 98u8, 238u8, 82u8, 4u8, 74u8, 74u8, 120u8, 78u8, 232u8,
          200u8, 123u8, 191u8, 156u8, 108u8, 85u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <u8>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The number of times a certain PIP has been skipped."]
      #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
      #[cfg(feature = "ink")]
      pub fn pip_skip_count(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<u8> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 225u8, 98u8, 238u8, 82u8, 4u8, 74u8, 74u8, 120u8, 78u8, 232u8,
          200u8, 123u8, 191u8, 156u8, 108u8, 85u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <u8>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All existing PIPs where the proposer is a committee."]
      #[doc = " This list is a cache of all ids in `Proposals` with `Proposer::Committee(_)`."]
      #[cfg(not(feature = "ink"))]
      pub async fn committee_pips(
        &self,
      ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::pallet_pips::PipId>>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 189u8, 121u8, 13u8, 219u8, 47u8, 171u8, 170u8, 240u8, 102u8, 140u8,
          146u8, 163u8, 22u8, 76u8, 210u8, 186u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::PipId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All existing PIPs where the proposer is a committee."]
      #[doc = " This list is a cache of all ids in `Proposals` with `Proposer::Committee(_)`."]
      #[cfg(feature = "ink")]
      pub fn committee_pips(
        &self,
      ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::pallet_pips::PipId>> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 189u8, 121u8, 13u8, 219u8, 47u8, 171u8, 170u8, 240u8, 102u8, 140u8,
          146u8, 163u8, 22u8, 76u8, 210u8, 186u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::vec::Vec<types::pallet_pips::PipId>>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Proposal state for a given id."]
      #[doc = " proposal id -> proposalState"]
      #[cfg(not(feature = "ink"))]
      pub async fn proposal_states(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_pips::ProposalState>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8, 102u8, 151u8, 171u8, 71u8,
          106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Proposal state for a given id."]
      #[doc = " proposal id -> proposalState"]
      #[cfg(feature = "ink")]
      pub fn proposal_states(
        &self,
        key_0: types::pallet_pips::PipId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_pips::ProposalState>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8, 102u8, 151u8, 171u8, 71u8,
          106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_pips::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_pips::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::Version> {
        let value = self.api.read_storage(::alloc::vec![
          55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8, 115u8, 13u8,
          254u8, 103u8, 198u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_pips::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod portfolio {
    use super::*;
    #[derive(Clone)]
    pub struct PortfolioCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PortfolioCallApi<'api> {
      #[doc = "Creates a portfolio with the given `name`."]
      #[cfg(not(feature = "ink"))]
      pub fn create_portfolio(
        &self,
        name: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::create_portfolio { name },
        ))
      }
      #[doc = "Creates a portfolio with the given `name`."]
      #[cfg(feature = "ink")]
      pub fn create_portfolio(
        &self,
        name: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 0u8];
        name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Deletes a user portfolio. A portfolio can be deleted only if it has no funds."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = "* `PortfolioNotEmpty` if the portfolio still holds any asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn delete_portfolio(
        &self,
        num: types::polymesh_primitives::identity_id::PortfolioNumber,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::delete_portfolio { num },
        ))
      }
      #[doc = "Deletes a user portfolio. A portfolio can be deleted only if it has no funds."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = "* `PortfolioNotEmpty` if the portfolio still holds any asset"]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn delete_portfolio(
        &self,
        num: types::polymesh_primitives::identity_id::PortfolioNumber,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 1u8];
        num.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Renames a non-default portfolio."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn rename_portfolio(
        &self,
        num: types::polymesh_primitives::identity_id::PortfolioNumber,
        to_name: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::rename_portfolio { num, to_name },
        ))
      }
      #[doc = "Renames a non-default portfolio."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn rename_portfolio(
        &self,
        num: types::polymesh_primitives::identity_id::PortfolioNumber,
        to_name: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 2u8];
        num.encode_to(&mut buf);
        to_name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "When called by the custodian of `portfolio_id`,"]
      #[doc = "allows returning the custody of the portfolio to the portfolio owner unilaterally."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn quit_portfolio_custody(
        &self,
        pid: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::quit_portfolio_custody { pid },
        ))
      }
      #[doc = "When called by the custodian of `portfolio_id`,"]
      #[doc = "allows returning the custody of the portfolio to the portfolio owner unilaterally."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn quit_portfolio_custody(
        &self,
        pid: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 3u8];
        pid.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[cfg(not(feature = "ink"))]
      pub fn accept_portfolio_custody(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::accept_portfolio_custody { auth_id },
        ))
      }
      #[cfg(feature = "ink")]
      pub fn accept_portfolio_custody(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 4u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same"]
      #[doc = "identity. Must be called by the custodian of the sender."]
      #[doc = "Funds from deleted portfolios can also be recovered via this method."]
      #[doc = ""]
      #[doc = "A short memo can be added to to each token amount moved."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio."]
      #[doc = "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same"]
      #[doc = "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio"]
      #[doc = "* `InsufficientPortfolioBalance` if the sender does not have enough free balance"]
      #[doc = "* `NoDuplicateAssetsAllowed` the same ticker can't be repeated in the items vector."]
      #[doc = "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own."]
      #[doc = "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn move_portfolio_funds(
        &self,
        from: types::polymesh_primitives::identity_id::PortfolioId,
        to: types::polymesh_primitives::identity_id::PortfolioId,
        funds: ::alloc::vec::Vec<types::polymesh_primitives::portfolio::Fund>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::move_portfolio_funds { from, to, funds },
        ))
      }
      #[doc = "Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same"]
      #[doc = "identity. Must be called by the custodian of the sender."]
      #[doc = "Funds from deleted portfolios can also be recovered via this method."]
      #[doc = ""]
      #[doc = "A short memo can be added to to each token amount moved."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio."]
      #[doc = "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same"]
      #[doc = "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities"]
      #[doc = "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio"]
      #[doc = "* `InsufficientPortfolioBalance` if the sender does not have enough free balance"]
      #[doc = "* `NoDuplicateAssetsAllowed` the same ticker can't be repeated in the items vector."]
      #[doc = "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own."]
      #[doc = "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn move_portfolio_funds(
        &self,
        from: types::polymesh_primitives::identity_id::PortfolioId,
        to: types::polymesh_primitives::identity_id::PortfolioId,
        funds: ::alloc::vec::Vec<types::polymesh_primitives::portfolio::Fund>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 5u8];
        from.encode_to(&mut buf);
        to.encode_to(&mut buf);
        funds.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Pre-approves the receivement of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `ticker` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn pre_approve_portfolio(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::pre_approve_portfolio {
            ticker,
            portfolio_id,
          },
        ))
      }
      #[doc = "Pre-approves the receivement of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `ticker` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn pre_approve_portfolio(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 6u8];
        ticker.encode_to(&mut buf);
        portfolio_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the pre approval of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `ticker` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_portfolio_pre_approval(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Portfolio(
          types::pallet_portfolio::PortfolioCall::remove_portfolio_pre_approval {
            ticker,
            portfolio_id,
          },
        ))
      }
      #[doc = "Removes the pre approval of an asset to a portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - the secondary key of the sender."]
      #[doc = "* `ticker` - the [`Ticker`] that will be exempt from affirmation."]
      #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `ticker` without affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn remove_portfolio_pre_approval(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![34u8, 7u8];
        ticker.encode_to(&mut buf);
        portfolio_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for PortfolioCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PortfolioQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PortfolioQueryApi<'api> {
      #[doc = " The next portfolio sequence number of an identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_portfolio_number(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::identity_id::PortfolioNumber,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 172u8, 83u8, 250u8, 216u8, 150u8, 217u8, 192u8, 44u8, 226u8, 108u8, 214u8,
          101u8, 230u8, 169u8, 16u8, 146u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::identity_id::PortfolioNumber>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The next portfolio sequence number of an identity."]
      #[cfg(feature = "ink")]
      pub fn next_portfolio_number(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::identity_id::PortfolioNumber>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 172u8, 83u8, 250u8, 216u8, 150u8, 217u8, 192u8, 44u8, 226u8, 108u8, 214u8,
          101u8, 230u8, 169u8, 16u8, 146u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::identity_id::PortfolioNumber>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " The set of existing portfolios with their names. If a certain pair of a DID and"]
      #[doc = " portfolio number maps to `None` then such a portfolio doesn't exist. Conversely, if a"]
      #[doc = " pair maps to `Some(name)` then such a portfolio exists and is called `name`."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolios(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioNumber,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity_id::PortfolioName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 216u8, 45u8, 233u8, 131u8, 28u8, 44u8, 102u8, 233u8, 160u8, 8u8, 50u8,
          33u8, 79u8, 22u8, 134u8, 96u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The set of existing portfolios with their names. If a certain pair of a DID and"]
      #[doc = " portfolio number maps to `None` then such a portfolio doesn't exist. Conversely, if a"]
      #[doc = " pair maps to `Some(name)` then such a portfolio exists and is called `name`."]
      #[cfg(feature = "ink")]
      pub fn portfolios(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioNumber,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity_id::PortfolioName>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 216u8, 45u8, 233u8, 131u8, 28u8, 44u8, 102u8, 233u8, 160u8, 8u8, 50u8,
          33u8, 79u8, 22u8, 134u8, 96u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Inverse map of `Portfolios` used to ensure bijectivitiy,"]
      #[doc = " and uniqueness of names in `Portfolios`."]
      #[cfg(not(feature = "ink"))]
      pub async fn name_to_number(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 201u8, 73u8, 93u8, 142u8, 176u8, 225u8, 64u8, 248u8, 75u8, 153u8, 21u8,
          11u8, 147u8, 73u8, 1u8, 128u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Inverse map of `Portfolios` used to ensure bijectivitiy,"]
      #[doc = " and uniqueness of names in `Portfolios`."]
      #[cfg(feature = "ink")]
      pub fn name_to_number(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioName,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 201u8, 73u8, 93u8, 142u8, 176u8, 225u8, 64u8, 248u8, 75u8, 153u8, 21u8,
          11u8, 147u8, 73u8, 1u8, 128u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " How many assets with non-zero balance this portfolio contains."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_asset_count(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 134u8, 1u8, 141u8, 242u8, 36u8, 217u8, 225u8, 140u8, 57u8, 102u8, 61u8,
          167u8, 241u8, 14u8, 193u8, 102u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " How many assets with non-zero balance this portfolio contains."]
      #[cfg(feature = "ink")]
      pub fn portfolio_asset_count(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 134u8, 1u8, 141u8, 242u8, 36u8, 217u8, 225u8, 140u8, 57u8, 102u8, 61u8,
          167u8, 241u8, 14u8, 193u8, 102u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The asset balances of portfolios."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_asset_balances(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 187u8, 126u8, 217u8, 17u8, 104u8, 223u8, 249u8, 141u8, 179u8, 194u8, 128u8,
          143u8, 216u8, 237u8, 226u8, 9u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The asset balances of portfolios."]
      #[cfg(feature = "ink")]
      pub fn portfolio_asset_balances(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 187u8, 126u8, 217u8, 17u8, 104u8, 223u8, 249u8, 141u8, 179u8, 194u8, 128u8,
          143u8, 216u8, 237u8, 226u8, 9u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Amount of assets locked in a portfolio."]
      #[doc = " These assets show up in portfolio balance but can not be transferred away."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_locked_assets(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 116u8, 19u8, 199u8, 203u8, 198u8, 5u8, 145u8, 166u8, 100u8, 250u8, 216u8,
          43u8, 219u8, 255u8, 196u8, 204u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Amount of assets locked in a portfolio."]
      #[doc = " These assets show up in portfolio balance but can not be transferred away."]
      #[cfg(feature = "ink")]
      pub fn portfolio_locked_assets(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 116u8, 19u8, 199u8, 203u8, 198u8, 5u8, 145u8, 166u8, 100u8, 250u8, 216u8,
          43u8, 219u8, 255u8, 196u8, 204u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The custodian of a particular portfolio. None implies that the identity owner is the custodian."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_custodian(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 10u8, 6u8, 59u8, 83u8, 137u8, 54u8, 238u8, 218u8, 141u8, 253u8, 27u8,
          117u8, 25u8, 62u8, 192u8, 180u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The custodian of a particular portfolio. None implies that the identity owner is the custodian."]
      #[cfg(feature = "ink")]
      pub fn portfolio_custodian(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 10u8, 6u8, 59u8, 83u8, 137u8, 54u8, 238u8, 218u8, 141u8, 253u8, 27u8,
          117u8, 25u8, 62u8, 192u8, 180u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Tracks all the portfolios in custody of a particular identity. Only used by the UIs."]
      #[doc = " When `true` is stored as the value for a given `(did, pid)`, it means that `pid` is in custody of `did`."]
      #[doc = " `false` values are never explicitly stored in the map, and are instead inferred by the absence of a key."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolios_in_custody(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 151u8, 1u8, 246u8, 111u8, 5u8, 25u8, 23u8, 126u8, 54u8, 90u8, 86u8, 176u8,
          77u8, 30u8, 44u8, 29u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks all the portfolios in custody of a particular identity. Only used by the UIs."]
      #[doc = " When `true` is stored as the value for a given `(did, pid)`, it means that `pid` is in custody of `did`."]
      #[doc = " `false` values are never explicitly stored in the map, and are instead inferred by the absence of a key."]
      #[cfg(feature = "ink")]
      pub fn portfolios_in_custody(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 151u8, 1u8, 246u8, 111u8, 5u8, 25u8, 23u8, 126u8, 54u8, 90u8, 86u8, 176u8,
          77u8, 30u8, 44u8, 29u8,
        ]);
        buf.extend(key_0.encode());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The nft associated to the portfolio."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_nft(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: (
          types::polymesh_primitives::ticker::Ticker,
          types::polymesh_primitives::nft::NFTId,
        ),
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 173u8, 97u8, 37u8, 11u8, 3u8, 3u8, 23u8, 150u8, 237u8, 156u8, 213u8, 12u8,
          232u8, 116u8, 250u8, 5u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The nft associated to the portfolio."]
      #[cfg(feature = "ink")]
      pub fn portfolio_nft(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: (
          types::polymesh_primitives::ticker::Ticker,
          types::polymesh_primitives::nft::NFTId,
        ),
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 173u8, 97u8, 37u8, 11u8, 3u8, 3u8, 23u8, 150u8, 237u8, 156u8, 213u8, 12u8,
          232u8, 116u8, 250u8, 5u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All locked nft for a given portfolio."]
      #[cfg(not(feature = "ink"))]
      pub async fn portfolio_locked_nft(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: (
          types::polymesh_primitives::ticker::Ticker,
          types::polymesh_primitives::nft::NFTId,
        ),
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 184u8, 241u8, 132u8, 127u8, 220u8, 26u8, 219u8, 97u8, 120u8, 220u8, 63u8,
          134u8, 171u8, 252u8, 234u8, 18u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All locked nft for a given portfolio."]
      #[cfg(feature = "ink")]
      pub fn portfolio_locked_nft(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: (
          types::polymesh_primitives::ticker::Ticker,
          types::polymesh_primitives::nft::NFTId,
        ),
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 184u8, 241u8, 132u8, 127u8, 220u8, 26u8, 219u8, 97u8, 120u8, 220u8, 63u8,
          134u8, 171u8, 252u8, 234u8, 18u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All portfolios that don't need to affirm the receivement of a given ticker."]
      #[cfg(not(feature = "ink"))]
      pub async fn pre_approved_portfolios(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 237u8, 212u8, 229u8, 184u8, 97u8, 233u8, 51u8, 24u8, 206u8, 114u8, 208u8,
          215u8, 112u8, 111u8, 171u8, 170u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All portfolios that don't need to affirm the receivement of a given ticker."]
      #[cfg(feature = "ink")]
      pub fn pre_approved_portfolios(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 237u8, 212u8, 229u8, 184u8, 97u8, 233u8, 51u8, 24u8, 206u8, 114u8, 208u8,
          215u8, 112u8, 111u8, 171u8, 170u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_portfolio::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8, 169u8,
          77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_portfolio::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_portfolio::Version> {
        let value = self.api.read_storage(::alloc::vec![
          36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8, 101u8, 254u8,
          169u8, 230u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8, 169u8,
          77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_portfolio::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod protocol_fee {
    use super::*;
    #[derive(Clone)]
    pub struct ProtocolFeeCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ProtocolFeeCallApi<'api> {
      #[doc = "Changes the fee coefficient for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[cfg(not(feature = "ink"))]
      pub fn change_coefficient(
        &self,
        coefficient: types::polymesh_primitives::PosRatio,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ProtocolFee(
          types::pallet_protocol_fee::ProtocolFeeCall::change_coefficient { coefficient },
        ))
      }
      #[doc = "Changes the fee coefficient for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[cfg(feature = "ink")]
      pub fn change_coefficient(
        &self,
        coefficient: types::polymesh_primitives::PosRatio,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![35u8, 0u8];
        coefficient.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Changes the a base fee for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[cfg(not(feature = "ink"))]
      pub fn change_base_fee(
        &self,
        op: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
        base_fee: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ProtocolFee(
          types::pallet_protocol_fee::ProtocolFeeCall::change_base_fee { op, base_fee },
        ))
      }
      #[doc = "Changes the a base fee for the root origin."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "* `BadOrigin` - Only root allowed."]
      #[cfg(feature = "ink")]
      pub fn change_base_fee(
        &self,
        op: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
        base_fee: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![35u8, 1u8];
        op.encode_to(&mut buf);
        base_fee.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ProtocolFeeCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ProtocolFeeQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ProtocolFeeQueryApi<'api> {
      #[doc = " The mapping of operation names to the base fees of those operations."]
      #[cfg(not(feature = "ink"))]
      pub async fn base_fees(
        &self,
        key_0: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8, 3u8, 169u8,
          228u8, 161u8, 54u8, 217u8, 243u8, 154u8, 193u8, 14u8, 44u8, 253u8, 114u8, 99u8, 70u8,
          43u8, 154u8, 102u8, 138u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The mapping of operation names to the base fees of those operations."]
      #[cfg(feature = "ink")]
      pub fn base_fees(
        &self,
        key_0: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8, 3u8, 169u8,
          228u8, 161u8, 54u8, 217u8, 243u8, 154u8, 193u8, 14u8, 44u8, 253u8, 114u8, 99u8, 70u8,
          43u8, 154u8, 102u8, 138u8, 8u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The fee coefficient as a positive rational (numerator, denominator)."]
      #[cfg(not(feature = "ink"))]
      pub async fn coefficient(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::PosRatio> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8, 3u8, 169u8,
          228u8, 161u8, 155u8, 182u8, 208u8, 38u8, 251u8, 72u8, 4u8, 189u8, 110u8, 17u8, 231u8,
          0u8, 23u8, 52u8, 26u8, 97u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::PosRatio>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The fee coefficient as a positive rational (numerator, denominator)."]
      #[cfg(feature = "ink")]
      pub fn coefficient(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::PosRatio> {
        let value = self.api.read_storage(::alloc::vec![
          184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8, 3u8, 169u8,
          228u8, 161u8, 155u8, 182u8, 208u8, 38u8, 251u8, 72u8, 4u8, 189u8, 110u8, 17u8, 231u8,
          0u8, 23u8, 52u8, 26u8, 97u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::PosRatio>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod scheduler {
    use super::*;
    #[derive(Clone)]
    pub struct SchedulerCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> SchedulerCallApi<'api> {
      #[doc = "Anonymously schedule a task."]
      #[cfg(not(feature = "ink"))]
      pub fn schedule(
        &self,
        when: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::schedule {
            when,
            maybe_periodic,
            priority,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Anonymously schedule a task."]
      #[cfg(feature = "ink")]
      pub fn schedule(
        &self,
        when: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 0u8];
        when.encode_to(&mut buf);
        maybe_periodic.encode_to(&mut buf);
        priority.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Cancel an anonymously scheduled task."]
      #[cfg(not(feature = "ink"))]
      pub fn cancel(
        &self,
        when: u32,
        index: u32,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::cancel { when, index },
        ))
      }
      #[doc = "Cancel an anonymously scheduled task."]
      #[cfg(feature = "ink")]
      pub fn cancel(&self, when: u32, index: u32) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 1u8];
        when.encode_to(&mut buf);
        index.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Schedule a named task."]
      #[cfg(not(feature = "ink"))]
      pub fn schedule_named(
        &self,
        id: [u8; 32usize],
        when: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::schedule_named {
            id,
            when,
            maybe_periodic,
            priority,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Schedule a named task."]
      #[cfg(feature = "ink")]
      pub fn schedule_named(
        &self,
        id: [u8; 32usize],
        when: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 2u8];
        id.encode_to(&mut buf);
        when.encode_to(&mut buf);
        maybe_periodic.encode_to(&mut buf);
        priority.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Cancel a named scheduled task."]
      #[cfg(not(feature = "ink"))]
      pub fn cancel_named(
        &self,
        id: [u8; 32usize],
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::cancel_named { id },
        ))
      }
      #[doc = "Cancel a named scheduled task."]
      #[cfg(feature = "ink")]
      pub fn cancel_named(&self, id: [u8; 32usize]) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 3u8];
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Anonymously schedule a task after a delay."]
      #[cfg(not(feature = "ink"))]
      pub fn schedule_after(
        &self,
        after: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::schedule_after {
            after,
            maybe_periodic,
            priority,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Anonymously schedule a task after a delay."]
      #[cfg(feature = "ink")]
      pub fn schedule_after(
        &self,
        after: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 4u8];
        after.encode_to(&mut buf);
        maybe_periodic.encode_to(&mut buf);
        priority.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Schedule a named task after a delay."]
      #[cfg(not(feature = "ink"))]
      pub fn schedule_named_after(
        &self,
        id: [u8; 32usize],
        after: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Scheduler(
          types::pallet_scheduler::pallet::SchedulerCall::schedule_named_after {
            id,
            after,
            maybe_periodic,
            priority,
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Schedule a named task after a delay."]
      #[cfg(feature = "ink")]
      pub fn schedule_named_after(
        &self,
        id: [u8; 32usize],
        after: u32,
        maybe_periodic: Option<(u32, u32)>,
        priority: u8,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![36u8, 5u8];
        id.encode_to(&mut buf);
        after.encode_to(&mut buf);
        maybe_periodic.encode_to(&mut buf);
        priority.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for SchedulerCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct SchedulerQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> SchedulerQueryApi<'api> {
      #[cfg(not(feature = "ink"))]
      pub async fn incomplete_since(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 247u8, 190u8, 155u8, 11u8, 241u8, 111u8, 132u8, 229u8, 89u8, 165u8,
          129u8, 1u8, 200u8, 145u8, 213u8, 35u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[cfg(feature = "ink")]
      pub fn incomplete_since(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
        let value = self.api.read_storage(::alloc::vec![
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 247u8, 190u8, 155u8, 11u8, 241u8, 111u8, 132u8, 229u8, 89u8, 165u8,
          129u8, 1u8, 200u8, 145u8, 213u8, 35u8,
        ])?;
        Ok(value)
      }
      #[doc = " Items to be executed, indexed by the block number that they should be executed on."]
      #[cfg(not(feature = "ink"))]
      pub async fn agenda(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_client::error::Result<
        types::bounded_collections::bounded_vec::BoundedVec<
          Option<
            types::pallet_scheduler::Scheduled<
              [u8; 32usize],
              types::frame_support::traits::preimages::Bounded<runtime::RuntimeCall>,
              u32,
              runtime::OriginCaller,
              ::polymesh_api_client::AccountId,
            >,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 22u8, 67u8, 245u8, 65u8, 151u8, 24u8, 33u8, 156u8, 149u8, 103u8,
          157u8, 221u8, 45u8, 130u8, 85u8, 116u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_vec::BoundedVec<
            Option<
              types::pallet_scheduler::Scheduled<
                [u8; 32usize],
                types::frame_support::traits::preimages::Bounded<runtime::RuntimeCall>,
                u32,
                runtime::OriginCaller,
                ::polymesh_api_client::AccountId,
              >,
            >,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Items to be executed, indexed by the block number that they should be executed on."]
      #[cfg(feature = "ink")]
      pub fn agenda(
        &self,
        key_0: u32,
      ) -> ::polymesh_api_ink::error::Result<
        types::bounded_collections::bounded_vec::BoundedVec<
          Option<
            types::pallet_scheduler::Scheduled<
              [u8; 32usize],
              types::frame_support::traits::preimages::Bounded<runtime::RuntimeCall>,
              u32,
              runtime::OriginCaller,
              ::polymesh_api_client::AccountId,
            >,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 22u8, 67u8, 245u8, 65u8, 151u8, 24u8, 33u8, 156u8, 149u8, 103u8,
          157u8, 221u8, 45u8, 130u8, 85u8, 116u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_vec::BoundedVec<
            Option<
              types::pallet_scheduler::Scheduled<
                [u8; 32usize],
                types::frame_support::traits::preimages::Bounded<runtime::RuntimeCall>,
                u32,
                runtime::OriginCaller,
                ::polymesh_api_client::AccountId,
              >,
            >,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Lookup from a name to the block number and index of the task."]
      #[doc = ""]
      #[doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"]
      #[doc = " identities."]
      #[cfg(not(feature = "ink"))]
      pub async fn lookup(
        &self,
        key_0: [u8; 32usize],
      ) -> ::polymesh_api_client::error::Result<Option<(u32, u32)>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 137u8, 26u8, 212u8, 87u8, 191u8, 77u8, 165u8, 73u8, 144u8, 250u8,
          132u8, 162u8, 172u8, 177u8, 72u8, 162u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Lookup from a name to the block number and index of the task."]
      #[doc = ""]
      #[doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"]
      #[doc = " identities."]
      #[cfg(feature = "ink")]
      pub fn lookup(
        &self,
        key_0: [u8; 32usize],
      ) -> ::polymesh_api_ink::error::Result<Option<(u32, u32)>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8, 108u8, 20u8,
          169u8, 157u8, 249u8, 137u8, 26u8, 212u8, 87u8, 191u8, 77u8, 165u8, 73u8, 144u8, 250u8,
          132u8, 162u8, 172u8, 177u8, 72u8, 162u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
  }
  pub mod settlement {
    use super::*;
    #[derive(Clone)]
    pub struct SettlementCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> SettlementCallApi<'api> {
      #[doc = "Registers a new venue."]
      #[doc = ""]
      #[doc = "* `details` - Extra details about a venue"]
      #[doc = "* `signers` - Array of signers that are allowed to sign receipts for this venue"]
      #[doc = "* `typ` - Type of venue being created"]
      #[cfg(not(feature = "ink"))]
      pub fn create_venue(
        &self,
        details: types::polymesh_primitives::settlement::VenueDetails,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        typ: types::polymesh_primitives::settlement::VenueType,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::create_venue {
            details,
            signers,
            typ,
          },
        ))
      }
      #[doc = "Registers a new venue."]
      #[doc = ""]
      #[doc = "* `details` - Extra details about a venue"]
      #[doc = "* `signers` - Array of signers that are allowed to sign receipts for this venue"]
      #[doc = "* `typ` - Type of venue being created"]
      #[cfg(feature = "ink")]
      pub fn create_venue(
        &self,
        details: types::polymesh_primitives::settlement::VenueDetails,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        typ: types::polymesh_primitives::settlement::VenueType,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 0u8];
        details.encode_to(&mut buf);
        signers.encode_to(&mut buf);
        typ.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Edit a venue's details."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `details` specifies the updated venue details."]
      #[cfg(not(feature = "ink"))]
      pub fn update_venue_details(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        details: types::polymesh_primitives::settlement::VenueDetails,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::update_venue_details { id, details },
        ))
      }
      #[doc = "Edit a venue's details."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `details` specifies the updated venue details."]
      #[cfg(feature = "ink")]
      pub fn update_venue_details(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        details: types::polymesh_primitives::settlement::VenueDetails,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 1u8];
        id.encode_to(&mut buf);
        details.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Edit a venue's type."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `type` specifies the new type of the venue."]
      #[cfg(not(feature = "ink"))]
      pub fn update_venue_type(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        typ: types::polymesh_primitives::settlement::VenueType,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::update_venue_type { id, typ },
        ))
      }
      #[doc = "Edit a venue's type."]
      #[doc = ""]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `type` specifies the new type of the venue."]
      #[cfg(feature = "ink")]
      pub fn update_venue_type(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        typ: types::polymesh_primitives::settlement::VenueType,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 2u8];
        id.encode_to(&mut buf);
        typ.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accepts an instruction and claims a signed receipt."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - Target instruction id."]
      #[doc = "* `leg_id` - Target leg id for the receipt"]
      #[doc = "* `receipt_uid` - Receipt ID generated by the signer."]
      #[doc = "* `signer` - Signer of the receipt."]
      #[doc = "* `signed_data` - Signed receipt."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to accept this instruction with."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn affirm_with_receipts(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        receipt_details: ::alloc::vec::Vec<
          types::polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            types::sp_runtime::MultiSignature,
          >,
        >,
        portfolios: ::alloc::vec::Vec<types::polymesh_primitives::identity_id::PortfolioId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::affirm_with_receipts {
            id,
            receipt_details,
            portfolios,
          },
        ))
      }
      #[doc = "Accepts an instruction and claims a signed receipt."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - Target instruction id."]
      #[doc = "* `leg_id` - Target leg id for the receipt"]
      #[doc = "* `receipt_uid` - Receipt ID generated by the signer."]
      #[doc = "* `signer` - Signer of the receipt."]
      #[doc = "* `signed_data` - Signed receipt."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to accept this instruction with."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn affirm_with_receipts(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        receipt_details: ::alloc::vec::Vec<
          types::polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            types::sp_runtime::MultiSignature,
          >,
        >,
        portfolios: ::alloc::vec::Vec<types::polymesh_primitives::identity_id::PortfolioId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 3u8];
        id.encode_to(&mut buf);
        receipt_details.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Enables or disabled venue filtering for a token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `ticker` - Ticker of the token in question."]
      #[doc = "* `enabled` - Boolean that decides if the filtering should be enabled."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_venue_filtering(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        enabled: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::set_venue_filtering { ticker, enabled },
        ))
      }
      #[doc = "Enables or disabled venue filtering for a token."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `ticker` - Ticker of the token in question."]
      #[doc = "* `enabled` - Boolean that decides if the filtering should be enabled."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn set_venue_filtering(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        enabled: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 4u8];
        ticker.encode_to(&mut buf);
        enabled.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allows additional venues to create instructions involving an asset."]
      #[doc = ""]
      #[doc = "* `ticker` - Ticker of the token in question."]
      #[doc = "* `venues` - Array of venues that are allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn allow_venues(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::allow_venues { ticker, venues },
        ))
      }
      #[doc = "Allows additional venues to create instructions involving an asset."]
      #[doc = ""]
      #[doc = "* `ticker` - Ticker of the token in question."]
      #[doc = "* `venues` - Array of venues that are allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn allow_venues(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 5u8];
        ticker.encode_to(&mut buf);
        venues.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Revokes permission given to venues for creating instructions involving a particular asset."]
      #[doc = ""]
      #[doc = "* `ticker` - Ticker of the token in question."]
      #[doc = "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn disallow_venues(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::disallow_venues { ticker, venues },
        ))
      }
      #[doc = "Revokes permission given to venues for creating instructions involving a particular asset."]
      #[doc = ""]
      #[doc = "* `ticker` - Ticker of the token in question."]
      #[doc = "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn disallow_venues(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 6u8];
        ticker.encode_to(&mut buf);
        venues.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Edit a venue's signers."]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `signers` specifies the signers to add/remove."]
      #[doc = "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false."]
      #[cfg(not(feature = "ink"))]
      pub fn update_venue_signers(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        add_signers: bool,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::update_venue_signers {
            id,
            signers,
            add_signers,
          },
        ))
      }
      #[doc = "Edit a venue's signers."]
      #[doc = "* `id` specifies the ID of the venue to edit."]
      #[doc = "* `signers` specifies the signers to add/remove."]
      #[doc = "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false."]
      #[cfg(feature = "ink")]
      pub fn update_venue_signers(
        &self,
        id: types::polymesh_primitives::settlement::VenueId,
        signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
        add_signers: bool,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 7u8];
        id.encode_to(&mut buf);
        signers.encode_to(&mut buf);
        add_signers.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Manually executes an instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`: The [`InstructionId`] of the instruction to be executed."]
      #[doc = "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction."]
      #[doc = "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]."]
      #[doc = "* `fungible_transfers`: The number of fungible legs in the instruction."]
      #[doc = "* `nfts_transfers`: The number of nfts being transferred in the instruction."]
      #[doc = "* `offchain_transfers`: The number of offchain legs in the instruction."]
      #[doc = "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction."]
      #[doc = "If the `weight_limit` is less than the required amount, the instruction will fail execution."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters."]
      #[cfg(not(feature = "ink"))]
      pub fn execute_manual_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioId>,
        fungible_transfers: u32,
        nfts_transfers: u32,
        offchain_transfers: u32,
        weight_limit: Option<::polymesh_api_client::sp_weights::Weight>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::execute_manual_instruction {
            id,
            portfolio,
            fungible_transfers,
            nfts_transfers,
            offchain_transfers,
            weight_limit,
          },
        ))
      }
      #[doc = "Manually executes an instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id`: The [`InstructionId`] of the instruction to be executed."]
      #[doc = "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction."]
      #[doc = "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]."]
      #[doc = "* `fungible_transfers`: The number of fungible legs in the instruction."]
      #[doc = "* `nfts_transfers`: The number of nfts being transferred in the instruction."]
      #[doc = "* `offchain_transfers`: The number of offchain legs in the instruction."]
      #[doc = "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction."]
      #[doc = "If the `weight_limit` is less than the required amount, the instruction will fail execution."]
      #[doc = ""]
      #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters."]
      #[cfg(feature = "ink")]
      pub fn execute_manual_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolio: Option<types::polymesh_primitives::identity_id::PortfolioId>,
        fungible_transfers: u32,
        nfts_transfers: u32,
        offchain_transfers: u32,
        weight_limit: Option<::polymesh_api_client::sp_weights::Weight>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 8u8];
        id.encode_to(&mut buf);
        portfolio.encode_to(&mut buf);
        fungible_transfers.encode_to(&mut buf);
        nfts_transfers.encode_to(&mut buf);
        offchain_transfers.encode_to(&mut buf);
        weight_limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id` - ID of the venue this instruction belongs to."]
      #[doc = "* `settlement_type` - Defines if the instruction should be settled in the next block, after receiving all affirmations"]
      #[doc = "or waiting till a specific block."]
      #[doc = "* `trade_date` - Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date` - Optional date after which the instruction should be settled (not enforced)"]
      #[doc = "* `legs` - Legs included in this instruction."]
      #[doc = "* `memo` - Memo field for this instruction."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`950_000_000 + 1_000_000 * legs.len()`"]
      #[cfg(not(feature = "ink"))]
      pub fn add_instruction(
        &self,
        venue_id: types::polymesh_primitives::settlement::VenueId,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::add_instruction {
            venue_id,
            settlement_type,
            trade_date,
            value_date,
            legs,
            instruction_memo,
          },
        ))
      }
      #[doc = "Adds a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id` - ID of the venue this instruction belongs to."]
      #[doc = "* `settlement_type` - Defines if the instruction should be settled in the next block, after receiving all affirmations"]
      #[doc = "or waiting till a specific block."]
      #[doc = "* `trade_date` - Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date` - Optional date after which the instruction should be settled (not enforced)"]
      #[doc = "* `legs` - Legs included in this instruction."]
      #[doc = "* `memo` - Memo field for this instruction."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "`950_000_000 + 1_000_000 * legs.len()`"]
      #[cfg(feature = "ink")]
      pub fn add_instruction(
        &self,
        venue_id: types::polymesh_primitives::settlement::VenueId,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 9u8];
        venue_id.encode_to(&mut buf);
        settlement_type.encode_to(&mut buf);
        trade_date.encode_to(&mut buf);
        value_date.encode_to(&mut buf);
        legs.encode_to(&mut buf);
        instruction_memo.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Adds and affirms a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id` - ID of the venue this instruction belongs to."]
      #[doc = "* `settlement_type` - Defines if the instruction should be settled in the next block, after receiving all affirmations"]
      #[doc = "or waiting till a specific block."]
      #[doc = "* `trade_date` - Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date` - Optional date after which the instruction should be settled (not enforced)"]
      #[doc = "* `legs` - Legs included in this instruction."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to use in this affirmations."]
      #[doc = "* `instruction_memo` - Memo field for this instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn add_and_affirm_instruction(
        &self,
        venue_id: types::polymesh_primitives::settlement::VenueId,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        portfolios: ::alloc::vec::Vec<types::polymesh_primitives::identity_id::PortfolioId>,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::add_and_affirm_instruction {
            venue_id,
            settlement_type,
            trade_date,
            value_date,
            legs,
            portfolios,
            instruction_memo,
          },
        ))
      }
      #[doc = "Adds and affirms a new instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `venue_id` - ID of the venue this instruction belongs to."]
      #[doc = "* `settlement_type` - Defines if the instruction should be settled in the next block, after receiving all affirmations"]
      #[doc = "or waiting till a specific block."]
      #[doc = "* `trade_date` - Optional date from which people can interact with this instruction."]
      #[doc = "* `value_date` - Optional date after which the instruction should be settled (not enforced)"]
      #[doc = "* `legs` - Legs included in this instruction."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to use in this affirmations."]
      #[doc = "* `instruction_memo` - Memo field for this instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn add_and_affirm_instruction(
        &self,
        venue_id: types::polymesh_primitives::settlement::VenueId,
        settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
        trade_date: Option<u64>,
        value_date: Option<u64>,
        legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
        portfolios: ::alloc::vec::Vec<types::polymesh_primitives::identity_id::PortfolioId>,
        instruction_memo: Option<types::polymesh_primitives::Memo>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 10u8];
        venue_id.encode_to(&mut buf);
        settlement_type.encode_to(&mut buf);
        trade_date.encode_to(&mut buf);
        value_date.encode_to(&mut buf);
        legs.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        instruction_memo.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Provide affirmation to an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The `InstructionId` of the instruction to be affirmed."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to affirm this instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn affirm_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::vec::Vec<types::polymesh_primitives::identity_id::PortfolioId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::affirm_instruction { id, portfolios },
        ))
      }
      #[doc = "Provide affirmation to an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - The `InstructionId` of the instruction to be affirmed."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to affirm this instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn affirm_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::vec::Vec<types::polymesh_primitives::identity_id::PortfolioId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 11u8];
        id.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Withdraw an affirmation for a given instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - Instruction id for that affirmation get withdrawn."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to withdraw affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn withdraw_affirmation(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::vec::Vec<types::polymesh_primitives::identity_id::PortfolioId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::withdraw_affirmation { id, portfolios },
        ))
      }
      #[doc = "Withdraw an affirmation for a given instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - Instruction id for that affirmation get withdrawn."]
      #[doc = "* `portfolios` - Portfolios that the sender controls and wants to withdraw affirmation."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn withdraw_affirmation(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolios: ::alloc::vec::Vec<types::polymesh_primitives::identity_id::PortfolioId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 12u8];
        id.encode_to(&mut buf);
        portfolios.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Rejects an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - Instruction id to reject."]
      #[doc = "* `portfolio` - Portfolio to reject the instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn reject_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolio: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::reject_instruction { id, portfolio },
        ))
      }
      #[doc = "Rejects an existing instruction."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `id` - Instruction id to reject."]
      #[doc = "* `portfolio` - Portfolio to reject the instruction."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn reject_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        portfolio: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 13u8];
        id.encode_to(&mut buf);
        portfolio.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction."]
      #[cfg(not(feature = "ink"))]
      pub fn execute_scheduled_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        weight_limit: ::polymesh_api_client::sp_weights::Weight,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Settlement(
          types::pallet_settlement::SettlementCall::execute_scheduled_instruction {
            id,
            weight_limit,
          },
        ))
      }
      #[doc = "Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction."]
      #[cfg(feature = "ink")]
      pub fn execute_scheduled_instruction(
        &self,
        id: types::polymesh_primitives::settlement::InstructionId,
        weight_limit: ::polymesh_api_client::sp_weights::Weight,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![37u8, 14u8];
        id.encode_to(&mut buf);
        weight_limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for SettlementCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct SettlementQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> SettlementQueryApi<'api> {
      #[doc = " Info about a venue. venue_id -> venue"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_info(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::settlement::Venue>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 37u8, 149u8, 35u8, 221u8, 234u8, 221u8, 43u8, 130u8, 235u8, 131u8,
          158u8, 182u8, 118u8, 158u8, 16u8, 163u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Info about a venue. venue_id -> venue"]
      #[cfg(feature = "ink")]
      pub fn venue_info(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::settlement::Venue>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 37u8, 149u8, 35u8, 221u8, 234u8, 221u8, 43u8, 130u8, 235u8, 131u8,
          158u8, 182u8, 118u8, 158u8, 16u8, 163u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Free-form text about a venue. venue_id -> `VenueDetails`"]
      #[doc = " Only needed for the UI."]
      #[cfg(not(feature = "ink"))]
      pub async fn details(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::settlement::VenueDetails>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8, 198u8, 220u8,
          28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::VenueDetails>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Free-form text about a venue. venue_id -> `VenueDetails`"]
      #[doc = " Only needed for the UI."]
      #[cfg(feature = "ink")]
      pub fn details(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::settlement::VenueDetails>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8, 198u8, 220u8,
          28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::VenueDetails>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Instructions under a venue."]
      #[doc = " Only needed for the UI."]
      #[doc = ""]
      #[doc = " venue_id -> instruction_id -> ()"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_instructions(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
        key_1: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 194u8, 12u8, 53u8, 241u8, 21u8, 245u8, 35u8, 172u8, 170u8, 85u8, 47u8,
          113u8, 49u8, 126u8, 98u8, 7u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Instructions under a venue."]
      #[doc = " Only needed for the UI."]
      #[doc = ""]
      #[doc = " venue_id -> instruction_id -> ()"]
      #[cfg(feature = "ink")]
      pub fn venue_instructions(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
        key_1: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 194u8, 12u8, 53u8, 241u8, 21u8, 245u8, 35u8, 172u8, 170u8, 85u8, 47u8,
          113u8, 49u8, 126u8, 98u8, 7u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Signers allowed by the venue. (venue_id, signer) -> bool"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_signers(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 182u8, 5u8, 81u8, 237u8, 11u8, 31u8, 45u8, 224u8, 46u8, 226u8, 44u8,
          156u8, 78u8, 11u8, 160u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Signers allowed by the venue. (venue_id, signer) -> bool"]
      #[cfg(feature = "ink")]
      pub fn venue_signers(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
        key_1: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 182u8, 5u8, 81u8, 237u8, 11u8, 31u8, 45u8, 224u8, 46u8, 226u8, 44u8,
          156u8, 78u8, 11u8, 160u8, 64u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Array of venues created by an identity. Only needed for the UI. IdentityId -> Vec<venue_id>"]
      #[doc = " Venues create by an identity."]
      #[doc = " Only needed for the UI."]
      #[doc = ""]
      #[doc = " identity -> venue_id ()"]
      #[cfg(not(feature = "ink"))]
      pub async fn user_venues(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 210u8, 109u8, 136u8, 8u8, 7u8, 235u8, 230u8, 119u8, 137u8, 87u8,
          141u8, 192u8, 40u8, 218u8, 115u8, 74u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Array of venues created by an identity. Only needed for the UI. IdentityId -> Vec<venue_id>"]
      #[doc = " Venues create by an identity."]
      #[doc = " Only needed for the UI."]
      #[doc = ""]
      #[doc = " identity -> venue_id ()"]
      #[cfg(feature = "ink")]
      pub fn user_venues(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_ink::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 210u8, 109u8, 136u8, 8u8, 7u8, 235u8, 230u8, 119u8, 137u8, 87u8,
          141u8, 192u8, 40u8, 218u8, 115u8, 74u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Details about an instruction. instruction_id -> instruction_details"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_details(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::Instruction<u64, u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 139u8, 174u8, 75u8, 191u8, 82u8, 90u8, 68u8, 48u8, 145u8, 19u8, 222u8,
          238u8, 96u8, 255u8, 129u8, 178u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::settlement::Instruction<u64, u32>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Details about an instruction. instruction_id -> instruction_details"]
      #[cfg(feature = "ink")]
      pub fn instruction_details(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::Instruction<u64, u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 139u8, 174u8, 75u8, 191u8, 82u8, 90u8, 68u8, 48u8, 145u8, 19u8, 222u8,
          238u8, 96u8, 255u8, 129u8, 178u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::settlement::Instruction<u64, u32>>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Status of a leg under an instruction. (instruction_id, leg_id) -> LegStatus"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_leg_status(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::LegStatus<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 241u8, 210u8, 62u8, 209u8, 210u8, 216u8, 97u8, 163u8, 74u8, 117u8,
          189u8, 72u8, 12u8, 109u8, 191u8, 35u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::LegStatus<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Status of a leg under an instruction. (instruction_id, leg_id) -> LegStatus"]
      #[cfg(feature = "ink")]
      pub fn instruction_leg_status(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::LegStatus<::polymesh_api_client::AccountId>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 241u8, 210u8, 62u8, 209u8, 210u8, 216u8, 97u8, 163u8, 74u8, 117u8,
          189u8, 72u8, 12u8, 109u8, 191u8, 35u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::LegStatus<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
        }))
      }
      #[doc = " Number of affirmations pending before instruction is executed. instruction_id -> affirm_pending"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_affirms_pending(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 84u8, 168u8, 38u8, 237u8, 42u8, 215u8, 233u8, 246u8, 173u8, 70u8, 3u8,
          122u8, 135u8, 90u8, 149u8, 95u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of affirmations pending before instruction is executed. instruction_id -> affirm_pending"]
      #[cfg(feature = "ink")]
      pub fn instruction_affirms_pending(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 84u8, 168u8, 38u8, 237u8, 42u8, 215u8, 233u8, 246u8, 173u8, 70u8, 3u8,
          122u8, 135u8, 90u8, 149u8, 95u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks affirmations received for an instruction. (instruction_id, counter_party) -> AffirmationStatus"]
      #[cfg(not(feature = "ink"))]
      pub async fn affirms_received(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 196u8, 164u8, 249u8, 77u8, 192u8, 14u8, 231u8, 77u8, 10u8, 20u8, 57u8,
          61u8, 241u8, 216u8, 34u8, 202u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Tracks affirmations received for an instruction. (instruction_id, counter_party) -> AffirmationStatus"]
      #[cfg(feature = "ink")]
      pub fn affirms_received(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::identity_id::PortfolioId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 196u8, 164u8, 249u8, 77u8, 192u8, 14u8, 231u8, 77u8, 10u8, 20u8, 57u8,
          61u8, 241u8, 216u8, 34u8, 202u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Helps a user track their pending instructions and affirmations (only needed for UI)."]
      #[doc = " (counter_party, instruction_id) -> AffirmationStatus"]
      #[cfg(not(feature = "ink"))]
      pub async fn user_affirmations(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 34u8, 4u8, 158u8, 52u8, 236u8, 109u8, 105u8, 33u8, 29u8, 40u8, 146u8,
          57u8, 70u8, 48u8, 102u8, 159u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Helps a user track their pending instructions and affirmations (only needed for UI)."]
      #[doc = " (counter_party, instruction_id) -> AffirmationStatus"]
      #[cfg(feature = "ink")]
      pub fn user_affirmations(
        &self,
        key_0: types::polymesh_primitives::identity_id::PortfolioId,
        key_1: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 34u8, 4u8, 158u8, 52u8, 236u8, 109u8, 105u8, 33u8, 29u8, 40u8, 146u8,
          57u8, 70u8, 48u8, 102u8, 159u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Tracks redemption of receipts. (signer, receipt_uid) -> receipt_used"]
      #[cfg(not(feature = "ink"))]
      pub async fn receipts_used(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 127u8, 126u8, 234u8, 226u8, 61u8, 64u8, 167u8, 253u8, 218u8, 94u8,
          162u8, 111u8, 120u8, 56u8, 116u8, 157u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks redemption of receipts. (signer, receipt_uid) -> receipt_used"]
      #[cfg(feature = "ink")]
      pub fn receipts_used(
        &self,
        key_0: ::polymesh_api_client::AccountId,
        key_1: u64,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 127u8, 126u8, 234u8, 226u8, 61u8, 64u8, 167u8, 253u8, 218u8, 94u8,
          162u8, 111u8, 120u8, 56u8, 116u8, 157u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks if a token has enabled filtering venues that can create instructions involving their token. Ticker -> filtering_enabled"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_filtering(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 242u8, 42u8, 22u8, 99u8, 179u8, 59u8, 93u8, 97u8, 223u8, 90u8, 186u8,
          160u8, 76u8, 19u8, 198u8, 73u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks if a token has enabled filtering venues that can create instructions involving their token. Ticker -> filtering_enabled"]
      #[cfg(feature = "ink")]
      pub fn venue_filtering(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 242u8, 42u8, 22u8, 99u8, 179u8, 59u8, 93u8, 97u8, 223u8, 90u8, 186u8,
          160u8, 76u8, 19u8, 198u8, 73u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Venues that are allowed to create instructions involving a particular ticker. Only used if filtering is enabled."]
      #[doc = " (ticker, venue_id) -> allowed"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_allow_list(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 113u8, 120u8, 81u8, 211u8, 168u8, 229u8, 128u8, 215u8, 96u8, 177u8,
          241u8, 151u8, 120u8, 224u8, 185u8, 22u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Venues that are allowed to create instructions involving a particular ticker. Only used if filtering is enabled."]
      #[doc = " (ticker, venue_id) -> allowed"]
      #[cfg(feature = "ink")]
      pub fn venue_allow_list(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 113u8, 120u8, 81u8, 211u8, 168u8, 229u8, 128u8, 215u8, 96u8, 177u8,
          241u8, 151u8, 120u8, 224u8, 185u8, 22u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of venues in the system (It's one more than the actual number)"]
      #[cfg(not(feature = "ink"))]
      pub async fn venue_counter(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::settlement::VenueId>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 117u8, 30u8, 157u8, 0u8, 240u8, 121u8, 103u8, 207u8, 127u8, 87u8,
          212u8, 100u8, 178u8, 100u8, 6u8, 108u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::settlement::VenueId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of venues in the system (It's one more than the actual number)"]
      #[cfg(feature = "ink")]
      pub fn venue_counter(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::settlement::VenueId>
      {
        let value = self.api.read_storage(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 117u8, 30u8, 157u8, 0u8, 240u8, 121u8, 103u8, 207u8, 127u8, 87u8,
          212u8, 100u8, 178u8, 100u8, 6u8, 108u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::settlement::VenueId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Number of instructions in the system (It's one more than the actual number)"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_counter(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::settlement::InstructionId>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 186u8, 56u8, 151u8, 67u8, 78u8, 201u8, 90u8, 108u8, 36u8, 245u8,
          147u8, 242u8, 23u8, 13u8, 233u8, 58u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::settlement::InstructionId>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Number of instructions in the system (It's one more than the actual number)"]
      #[cfg(feature = "ink")]
      pub fn instruction_counter(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::settlement::InstructionId>
      {
        let value = self.api.read_storage(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 186u8, 56u8, 151u8, 67u8, 78u8, 201u8, 90u8, 108u8, 36u8, 245u8,
          147u8, 242u8, 23u8, 13u8, 233u8, 58u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::settlement::InstructionId>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_settlement::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_settlement::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_settlement::Version> {
        let value = self.api.read_storage(::alloc::vec![
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_settlement::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Instruction memo"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_memos(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::Memo>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 91u8, 46u8, 219u8, 158u8, 9u8, 52u8, 231u8, 25u8, 76u8, 164u8, 67u8,
          166u8, 153u8, 53u8, 138u8, 48u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Instruction memo"]
      #[cfg(feature = "ink")]
      pub fn instruction_memos(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::Memo>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 91u8, 46u8, 219u8, 158u8, 9u8, 52u8, 231u8, 25u8, 76u8, 164u8, 67u8,
          166u8, 153u8, 53u8, 138u8, 48u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Instruction statuses. instruction_id -> InstructionStatus"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_statuses(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::InstructionStatus<u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 129u8, 220u8, 107u8, 190u8, 175u8, 117u8, 37u8, 159u8, 155u8, 144u8,
          126u8, 158u8, 40u8, 0u8, 88u8, 54u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::InstructionStatus<u32>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Instruction statuses. instruction_id -> InstructionStatus"]
      #[cfg(feature = "ink")]
      pub fn instruction_statuses(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::InstructionStatus<u32>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 129u8, 220u8, 107u8, 190u8, 175u8, 117u8, 37u8, 159u8, 155u8, 144u8,
          126u8, 158u8, 40u8, 0u8, 88u8, 54u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::InstructionStatus<u32>>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Legs under an instruction. (instruction_id, leg_id) -> Leg"]
      #[cfg(not(feature = "ink"))]
      pub async fn instruction_legs(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::settlement::Leg>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 17u8, 1u8, 179u8, 157u8, 113u8, 141u8, 101u8, 250u8, 213u8, 115u8,
          20u8, 61u8, 204u8, 53u8, 74u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Legs under an instruction. (instruction_id, leg_id) -> Leg"]
      #[cfg(feature = "ink")]
      pub fn instruction_legs(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::settlement::Leg>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 17u8, 1u8, 179u8, 157u8, 113u8, 141u8, 101u8, 250u8, 213u8, 115u8,
          20u8, 61u8, 204u8, 53u8, 74u8, 4u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Tracks the affirmation status for offchain legs in a instruction. [`(InstructionId, LegId)`] -> [`AffirmationStatus`]"]
      #[cfg(not(feature = "ink"))]
      pub async fn off_chain_affirmations(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 83u8, 128u8, 215u8, 35u8, 66u8, 131u8, 241u8, 146u8, 213u8, 20u8,
          216u8, 29u8, 178u8, 153u8, 36u8, 132u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Tracks the affirmation status for offchain legs in a instruction. [`(InstructionId, LegId)`] -> [`AffirmationStatus`]"]
      #[cfg(feature = "ink")]
      pub fn off_chain_affirmations(
        &self,
        key_0: types::polymesh_primitives::settlement::InstructionId,
        key_1: types::polymesh_primitives::settlement::LegId,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::settlement::AffirmationStatus,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 83u8, 128u8, 215u8, 35u8, 66u8, 131u8, 241u8, 146u8, 213u8, 20u8,
          216u8, 29u8, 178u8, 153u8, 36u8, 132u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::settlement::AffirmationStatus>::decode(&mut &DEFAULT[..])
            .unwrap()
        }))
      }
      #[doc = " Tracks the number of signers each venue has."]
      #[cfg(not(feature = "ink"))]
      pub async fn number_of_venue_signers(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_client::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 65u8, 49u8, 135u8, 25u8, 96u8, 14u8, 112u8, 10u8, 188u8, 29u8, 148u8,
          244u8, 217u8, 121u8, 111u8, 6u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Tracks the number of signers each venue has."]
      #[cfg(feature = "ink")]
      pub fn number_of_venue_signers(
        &self,
        key_0: types::polymesh_primitives::settlement::VenueId,
      ) -> ::polymesh_api_ink::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8, 244u8, 45u8,
          74u8, 131u8, 57u8, 65u8, 49u8, 135u8, 25u8, 96u8, 14u8, 112u8, 10u8, 188u8, 29u8, 148u8,
          244u8, 217u8, 121u8, 111u8, 6u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod statistics {
    use super::*;
    #[derive(Clone)]
    pub struct StatisticsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> StatisticsCallApi<'api> {
      #[doc = "Set the active asset stat_types."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset`."]
      #[doc = "- `asset` - the asset to change the active stats on."]
      #[doc = "- `stat_types` - the new stat types to replace any existing types."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeLimitReached` - too many stat types enabled for the `asset`."]
      #[doc = "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_active_asset_stats(
        &self,
        asset: types::polymesh_primitives::statistics::AssetScope,
        stat_types: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::statistics::StatType,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Statistics(
          types::pallet_statistics::StatisticsCall::set_active_asset_stats { asset, stat_types },
        ))
      }
      #[doc = "Set the active asset stat_types."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset`."]
      #[doc = "- `asset` - the asset to change the active stats on."]
      #[doc = "- `stat_types` - the new stat types to replace any existing types."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeLimitReached` - too many stat types enabled for the `asset`."]
      #[doc = "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(feature = "ink")]
      pub fn set_active_asset_stats(
        &self,
        asset: types::polymesh_primitives::statistics::AssetScope,
        stat_types: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::statistics::StatType,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![38u8, 0u8];
        asset.encode_to(&mut buf);
        stat_types.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Allow a trusted issuer to init/resync ticker/company stats."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset`."]
      #[doc = "- `asset` - the asset to change the active stats on."]
      #[doc = "- `stat_type` - stat type to update."]
      #[doc = "- `values` - Updated values for `stat_type`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeMissing` - `stat_type` is not enabled for the `asset`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn batch_update_asset_stats(
        &self,
        asset: types::polymesh_primitives::statistics::AssetScope,
        stat_type: types::polymesh_primitives::statistics::StatType,
        values: ::alloc::collections::BTreeSet<types::polymesh_primitives::statistics::StatUpdate>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Statistics(
          types::pallet_statistics::StatisticsCall::batch_update_asset_stats {
            asset,
            stat_type,
            values,
          },
        ))
      }
      #[doc = "Allow a trusted issuer to init/resync ticker/company stats."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset`."]
      #[doc = "- `asset` - the asset to change the active stats on."]
      #[doc = "- `stat_type` - stat type to update."]
      #[doc = "- `values` - Updated values for `stat_type`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `StatTypeMissing` - `stat_type` is not enabled for the `asset`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(feature = "ink")]
      pub fn batch_update_asset_stats(
        &self,
        asset: types::polymesh_primitives::statistics::AssetScope,
        stat_type: types::polymesh_primitives::statistics::StatType,
        values: ::alloc::collections::BTreeSet<types::polymesh_primitives::statistics::StatUpdate>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![38u8, 1u8];
        asset.encode_to(&mut buf);
        stat_type.encode_to(&mut buf);
        values.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set asset transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset`."]
      #[doc = "- `asset` - the asset to change the active stats on."]
      #[doc = "- `transfer_conditions` - the new transfer condition to replace any existing conditions."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset`."]
      #[doc = "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_asset_transfer_compliance(
        &self,
        asset: types::polymesh_primitives::statistics::AssetScope,
        transfer_conditions: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::transfer_compliance::TransferCondition,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Statistics(
          types::pallet_statistics::StatisticsCall::set_asset_transfer_compliance {
            asset,
            transfer_conditions,
          },
        ))
      }
      #[doc = "Set asset transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset`."]
      #[doc = "- `asset` - the asset to change the active stats on."]
      #[doc = "- `transfer_conditions` - the new transfer condition to replace any existing conditions."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset`."]
      #[doc = "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset`."]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(feature = "ink")]
      pub fn set_asset_transfer_compliance(
        &self,
        asset: types::polymesh_primitives::statistics::AssetScope,
        transfer_conditions: ::alloc::collections::BTreeSet<
          types::polymesh_primitives::transfer_compliance::TransferCondition,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![38u8, 2u8];
        asset.encode_to(&mut buf);
        transfer_conditions.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Set/unset entities exempt from an asset's transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`."]
      #[doc = "- `is_exempt` - enable/disable exemption for `entities`."]
      #[doc = "- `exempt_key` - the asset and stat type to exempt the `entities` from."]
      #[doc = "- `entities` - the entities to set/unset the exemption for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn set_entities_exempt(
        &self,
        is_exempt: bool,
        exempt_key: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
        entities: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Statistics(
          types::pallet_statistics::StatisticsCall::set_entities_exempt {
            is_exempt,
            exempt_key,
            entities,
          },
        ))
      }
      #[doc = "Set/unset entities exempt from an asset's transfer compliance rules."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`."]
      #[doc = "- `is_exempt` - enable/disable exemption for `entities`."]
      #[doc = "- `exempt_key` - the asset and stat type to exempt the `entities` from."]
      #[doc = "- `entities` - the entities to set/unset the exemption for."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "- Agent"]
      #[doc = "- Asset"]
      #[cfg(feature = "ink")]
      pub fn set_entities_exempt(
        &self,
        is_exempt: bool,
        exempt_key: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
        entities: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![38u8, 3u8];
        is_exempt.encode_to(&mut buf);
        exempt_key.encode_to(&mut buf);
        entities.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for StatisticsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct StatisticsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> StatisticsQueryApi<'api> {
      #[doc = " Active stats for a ticker/company.  There should be a max limit on the number of active stats for a ticker/company."]
      #[cfg(not(feature = "ink"))]
      pub async fn active_asset_stats(
        &self,
        key_0: types::polymesh_primitives::statistics::AssetScope,
      ) -> ::polymesh_api_client::error::Result<
        types::bounded_collections::bounded_btree_set::BoundedBTreeSet<
          types::polymesh_primitives::statistics::StatType,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 239u8, 22u8, 59u8, 174u8, 32u8, 48u8, 119u8, 218u8, 227u8, 43u8,
          193u8, 151u8, 65u8, 213u8, 147u8, 30u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_btree_set::BoundedBTreeSet<
            types::polymesh_primitives::statistics::StatType,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Active stats for a ticker/company.  There should be a max limit on the number of active stats for a ticker/company."]
      #[cfg(feature = "ink")]
      pub fn active_asset_stats(
        &self,
        key_0: types::polymesh_primitives::statistics::AssetScope,
      ) -> ::polymesh_api_ink::error::Result<
        types::bounded_collections::bounded_btree_set::BoundedBTreeSet<
          types::polymesh_primitives::statistics::StatType,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 239u8, 22u8, 59u8, 174u8, 32u8, 48u8, 119u8, 218u8, 227u8, 43u8,
          193u8, 151u8, 65u8, 213u8, 147u8, 30u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_btree_set::BoundedBTreeSet<
            types::polymesh_primitives::statistics::StatType,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Asset stats."]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_stats(
        &self,
        key_0: types::polymesh_primitives::statistics::Stat1stKey,
        key_1: types::polymesh_primitives::statistics::Stat2ndKey,
      ) -> ::polymesh_api_client::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 13u8, 224u8, 187u8, 176u8, 120u8, 186u8, 103u8, 210u8, 250u8, 246u8,
          251u8, 70u8, 123u8, 141u8, 62u8, 51u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Asset stats."]
      #[cfg(feature = "ink")]
      pub fn asset_stats(
        &self,
        key_0: types::polymesh_primitives::statistics::Stat1stKey,
        key_1: types::polymesh_primitives::statistics::Stat2ndKey,
      ) -> ::polymesh_api_ink::error::Result<u128> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 13u8, 224u8, 187u8, 176u8, 120u8, 186u8, 103u8, 210u8, 250u8, 246u8,
          251u8, 70u8, 123u8, 141u8, 62u8, 51u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
          ];
          <u128>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Asset transfer compliance for a ticker (AssetScope -> AssetTransferCompliance)"]
      #[cfg(not(feature = "ink"))]
      pub async fn asset_transfer_compliances(
        &self,
        key_0: types::polymesh_primitives::statistics::AssetScope,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::transfer_compliance::AssetTransferCompliance,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 86u8, 51u8, 252u8, 244u8, 127u8, 54u8, 208u8, 97u8, 49u8, 83u8, 224u8,
          203u8, 24u8, 190u8, 105u8, 124u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::polymesh_primitives::transfer_compliance::AssetTransferCompliance>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Asset transfer compliance for a ticker (AssetScope -> AssetTransferCompliance)"]
      #[cfg(feature = "ink")]
      pub fn asset_transfer_compliances(
        &self,
        key_0: types::polymesh_primitives::statistics::AssetScope,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::transfer_compliance::AssetTransferCompliance,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 86u8, 51u8, 252u8, 244u8, 127u8, 54u8, 208u8, 97u8, 49u8, 83u8, 224u8,
          203u8, 24u8, 190u8, 105u8, 124u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8];
          <types::polymesh_primitives::transfer_compliance::AssetTransferCompliance>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " Entities exempt from a Transfer Compliance rule."]
      #[cfg(not(feature = "ink"))]
      pub async fn transfer_condition_exempt_entities(
        &self,
        key_0: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 26u8, 48u8, 88u8, 202u8, 218u8, 234u8, 155u8, 104u8, 25u8, 241u8,
          119u8, 22u8, 42u8, 149u8, 27u8, 223u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Entities exempt from a Transfer Compliance rule."]
      #[cfg(feature = "ink")]
      pub fn transfer_condition_exempt_entities(
        &self,
        key_0: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 26u8, 48u8, 88u8, 202u8, 218u8, 234u8, 155u8, 104u8, 25u8, 241u8,
          119u8, 22u8, 42u8, 149u8, 27u8, 223u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage migration version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::pallet_statistics::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_statistics::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage migration version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_statistics::Version> {
        let value = self.api.read_storage(::alloc::vec![
          122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8, 92u8,
          191u8, 151u8, 8u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::pallet_statistics::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod sto {
    use super::*;
    #[derive(Clone)]
    pub struct StoCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> StoCallApi<'api> {
      #[doc = "Create a new fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_portfolio` - Portfolio containing the `offering_asset`."]
      #[doc = "* `offering_asset` - Asset being offered."]
      #[doc = "* `raising_portfolio` - Portfolio containing the `raising_asset`."]
      #[doc = "* `raising_asset` - Asset being exchanged for `offering_asset` on investment."]
      #[doc = "* `tiers` - Price tiers to charge investors on investment."]
      #[doc = "* `venue_id` - Venue to handle settlement."]
      #[doc = "* `start` - Fundraiser start time, if `None` the fundraiser will start immediately."]
      #[doc = "* `end` - Fundraiser end time, if `None` the fundraiser will never expire."]
      #[doc = "* `minimum_investment` - Minimum amount of `raising_asset` that an investor needs to spend to invest in this raise."]
      #[doc = "* `fundraiser_name` - Fundraiser name, only used in the UIs."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn create_fundraiser(
        &self,
        offering_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        raising_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        raising_asset: types::polymesh_primitives::ticker::Ticker,
        tiers: ::alloc::vec::Vec<types::pallet_sto::PriceTier>,
        venue_id: types::polymesh_primitives::settlement::VenueId,
        start: Option<u64>,
        end: Option<u64>,
        minimum_investment: u128,
        fundraiser_name: types::pallet_sto::FundraiserName,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::create_fundraiser {
            offering_portfolio,
            offering_asset,
            raising_portfolio,
            raising_asset,
            tiers,
            venue_id,
            start,
            end,
            minimum_investment,
            fundraiser_name,
          },
        ))
      }
      #[doc = "Create a new fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_portfolio` - Portfolio containing the `offering_asset`."]
      #[doc = "* `offering_asset` - Asset being offered."]
      #[doc = "* `raising_portfolio` - Portfolio containing the `raising_asset`."]
      #[doc = "* `raising_asset` - Asset being exchanged for `offering_asset` on investment."]
      #[doc = "* `tiers` - Price tiers to charge investors on investment."]
      #[doc = "* `venue_id` - Venue to handle settlement."]
      #[doc = "* `start` - Fundraiser start time, if `None` the fundraiser will start immediately."]
      #[doc = "* `end` - Fundraiser end time, if `None` the fundraiser will never expire."]
      #[doc = "* `minimum_investment` - Minimum amount of `raising_asset` that an investor needs to spend to invest in this raise."]
      #[doc = "* `fundraiser_name` - Fundraiser name, only used in the UIs."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn create_fundraiser(
        &self,
        offering_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        raising_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        raising_asset: types::polymesh_primitives::ticker::Ticker,
        tiers: ::alloc::vec::Vec<types::pallet_sto::PriceTier>,
        venue_id: types::polymesh_primitives::settlement::VenueId,
        start: Option<u64>,
        end: Option<u64>,
        minimum_investment: u128,
        fundraiser_name: types::pallet_sto::FundraiserName,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 0u8];
        offering_portfolio.encode_to(&mut buf);
        offering_asset.encode_to(&mut buf);
        raising_portfolio.encode_to(&mut buf);
        raising_asset.encode_to(&mut buf);
        tiers.encode_to(&mut buf);
        venue_id.encode_to(&mut buf);
        start.encode_to(&mut buf);
        end.encode_to(&mut buf);
        minimum_investment.encode_to(&mut buf);
        fundraiser_name.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Invest in a fundraiser."]
      #[doc = ""]
      #[doc = "* `investment_portfolio` - Portfolio that `offering_asset` will be deposited in."]
      #[doc = "* `funding_portfolio` - Portfolio that will fund the investment."]
      #[doc = "* `offering_asset` - Asset to invest in."]
      #[doc = "* `id` - ID of the fundraiser to invest in."]
      #[doc = "* `purchase_amount` - Amount of `offering_asset` to purchase."]
      #[doc = "* `max_price` - Maximum price to pay per unit of `offering_asset`, If `None`there are no constraints on price."]
      #[doc = "* `receipt` - Off-chain receipt to use instead of on-chain balance in `funding_portfolio`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn invest(
        &self,
        investment_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        funding_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        id: types::pallet_sto::FundraiserId,
        purchase_amount: u128,
        max_price: Option<u128>,
        receipt: Option<
          types::polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            types::sp_runtime::MultiSignature,
          >,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::invest {
            investment_portfolio,
            funding_portfolio,
            offering_asset,
            id,
            purchase_amount,
            max_price,
            receipt,
          },
        ))
      }
      #[doc = "Invest in a fundraiser."]
      #[doc = ""]
      #[doc = "* `investment_portfolio` - Portfolio that `offering_asset` will be deposited in."]
      #[doc = "* `funding_portfolio` - Portfolio that will fund the investment."]
      #[doc = "* `offering_asset` - Asset to invest in."]
      #[doc = "* `id` - ID of the fundraiser to invest in."]
      #[doc = "* `purchase_amount` - Amount of `offering_asset` to purchase."]
      #[doc = "* `max_price` - Maximum price to pay per unit of `offering_asset`, If `None`there are no constraints on price."]
      #[doc = "* `receipt` - Off-chain receipt to use instead of on-chain balance in `funding_portfolio`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn invest(
        &self,
        investment_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        funding_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        id: types::pallet_sto::FundraiserId,
        purchase_amount: u128,
        max_price: Option<u128>,
        receipt: Option<
          types::polymesh_primitives::settlement::ReceiptDetails<
            ::polymesh_api_client::AccountId,
            types::sp_runtime::MultiSignature,
          >,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 1u8];
        investment_portfolio.encode_to(&mut buf);
        funding_portfolio.encode_to(&mut buf);
        offering_asset.encode_to(&mut buf);
        id.encode_to(&mut buf);
        purchase_amount.encode_to(&mut buf);
        max_price.encode_to(&mut buf);
        receipt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Freeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to freeze."]
      #[doc = "* `id` - ID of the fundraiser to freeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn freeze_fundraiser(
        &self,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        id: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::freeze_fundraiser { offering_asset, id },
        ))
      }
      #[doc = "Freeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to freeze."]
      #[doc = "* `id` - ID of the fundraiser to freeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn freeze_fundraiser(
        &self,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        id: types::pallet_sto::FundraiserId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 2u8];
        offering_asset.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Unfreeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to unfreeze."]
      #[doc = "* `id` - ID of the fundraiser to unfreeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn unfreeze_fundraiser(
        &self,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        id: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::unfreeze_fundraiser { offering_asset, id },
        ))
      }
      #[doc = "Unfreeze a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to unfreeze."]
      #[doc = "* `id` - ID of the fundraiser to unfreeze."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn unfreeze_fundraiser(
        &self,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        id: types::pallet_sto::FundraiserId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 3u8];
        offering_asset.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Modify the time window a fundraiser is active"]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to modify."]
      #[doc = "* `id` - ID of the fundraiser to modify."]
      #[doc = "* `start` - New start of the fundraiser."]
      #[doc = "* `end` - New end of the fundraiser to modify."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn modify_fundraiser_window(
        &self,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        id: types::pallet_sto::FundraiserId,
        start: u64,
        end: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::modify_fundraiser_window {
            offering_asset,
            id,
            start,
            end,
          },
        ))
      }
      #[doc = "Modify the time window a fundraiser is active"]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to modify."]
      #[doc = "* `id` - ID of the fundraiser to modify."]
      #[doc = "* `start` - New start of the fundraiser."]
      #[doc = "* `end` - New end of the fundraiser to modify."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn modify_fundraiser_window(
        &self,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        id: types::pallet_sto::FundraiserId,
        start: u64,
        end: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 4u8];
        offering_asset.encode_to(&mut buf);
        id.encode_to(&mut buf);
        start.encode_to(&mut buf);
        end.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Stop a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to stop."]
      #[doc = "* `id` - ID of the fundraiser to stop."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn stop(
        &self,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        id: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Sto(
          types::pallet_sto::StoCall::stop { offering_asset, id },
        ))
      }
      #[doc = "Stop a fundraiser."]
      #[doc = ""]
      #[doc = "* `offering_asset` - Asset to stop."]
      #[doc = "* `id` - ID of the fundraiser to stop."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn stop(
        &self,
        offering_asset: types::polymesh_primitives::ticker::Ticker,
        id: types::pallet_sto::FundraiserId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![39u8, 5u8];
        offering_asset.encode_to(&mut buf);
        id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for StoCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct StoQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> StoQueryApi<'api> {
      #[doc = " All fundraisers that are currently running."]
      #[doc = " (ticker, fundraiser_id) -> Fundraiser"]
      #[cfg(not(feature = "ink"))]
      pub async fn fundraisers(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_sto::Fundraiser<u64>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 200u8, 242u8, 149u8, 77u8, 218u8, 243u8, 200u8, 19u8, 142u8, 65u8,
          23u8, 184u8, 97u8, 230u8, 68u8, 109u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " All fundraisers that are currently running."]
      #[doc = " (ticker, fundraiser_id) -> Fundraiser"]
      #[cfg(feature = "ink")]
      pub fn fundraisers(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_sto::Fundraiser<u64>>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 200u8, 242u8, 149u8, 77u8, 218u8, 243u8, 200u8, 19u8, 142u8, 65u8,
          23u8, 184u8, 97u8, 230u8, 68u8, 109u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Total fundraisers created for a token."]
      #[cfg(not(feature = "ink"))]
      pub async fn fundraiser_count(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<types::pallet_sto::FundraiserId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 220u8, 57u8, 49u8, 4u8, 64u8, 150u8, 65u8, 208u8, 189u8, 149u8, 72u8,
          244u8, 76u8, 90u8, 115u8, 235u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::pallet_sto::FundraiserId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Total fundraisers created for a token."]
      #[cfg(feature = "ink")]
      pub fn fundraiser_count(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<types::pallet_sto::FundraiserId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 220u8, 57u8, 49u8, 4u8, 64u8, 150u8, 65u8, 208u8, 189u8, 149u8, 72u8,
          244u8, 76u8, 90u8, 115u8, 235u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::pallet_sto::FundraiserId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Name for the Fundraiser. Only used offchain."]
      #[doc = " (ticker, fundraiser_id) -> Fundraiser name"]
      #[cfg(not(feature = "ink"))]
      pub async fn fundraiser_names(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_sto::FundraiserName>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 70u8, 206u8, 185u8, 249u8, 61u8, 181u8, 239u8, 65u8, 114u8, 228u8,
          101u8, 54u8, 80u8, 98u8, 238u8, 252u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Name for the Fundraiser. Only used offchain."]
      #[doc = " (ticker, fundraiser_id) -> Fundraiser name"]
      #[cfg(feature = "ink")]
      pub fn fundraiser_names(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::pallet_sto::FundraiserId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_sto::FundraiserName>> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8, 235u8,
          242u8, 167u8, 54u8, 70u8, 206u8, 185u8, 249u8, 61u8, 181u8, 239u8, 65u8, 114u8, 228u8,
          101u8, 54u8, 80u8, 98u8, 238u8, 252u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
  }
  pub mod treasury {
    use super::*;
    #[derive(Clone)]
    pub struct TreasuryCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TreasuryCallApi<'api> {
      #[doc = "It transfers balances from treasury to each of beneficiaries and the specific amount"]
      #[doc = "for each of them."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = "* `BadOrigin`: Only root can execute transaction."]
      #[doc = "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries."]
      #[doc = "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity."]
      #[cfg(not(feature = "ink"))]
      pub fn disbursement(
        &self,
        beneficiaries: ::alloc::vec::Vec<types::polymesh_primitives::Beneficiary<u128>>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Treasury(
          types::pallet_treasury::TreasuryCall::disbursement { beneficiaries },
        ))
      }
      #[doc = "It transfers balances from treasury to each of beneficiaries and the specific amount"]
      #[doc = "for each of them."]
      #[doc = ""]
      #[doc = "# Error"]
      #[doc = "* `BadOrigin`: Only root can execute transaction."]
      #[doc = "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries."]
      #[doc = "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity."]
      #[cfg(feature = "ink")]
      pub fn disbursement(
        &self,
        beneficiaries: ::alloc::vec::Vec<types::polymesh_primitives::Beneficiary<u128>>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![40u8, 0u8];
        beneficiaries.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "It transfers the specific `amount` from `origin` account into treasury."]
      #[doc = ""]
      #[doc = "Only accounts which are associated to an identity can make a donation to treasury."]
      #[cfg(not(feature = "ink"))]
      pub fn reimbursement(
        &self,
        amount: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Treasury(
          types::pallet_treasury::TreasuryCall::reimbursement { amount },
        ))
      }
      #[doc = "It transfers the specific `amount` from `origin` account into treasury."]
      #[doc = ""]
      #[doc = "Only accounts which are associated to an identity can make a donation to treasury."]
      #[cfg(feature = "ink")]
      pub fn reimbursement(&self, amount: u128) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![40u8, 1u8];
        amount.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for TreasuryCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TreasuryQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TreasuryQueryApi<'api> {}
  }
  pub mod utility {
    use super::*;
    #[derive(Clone)]
    pub struct UtilityCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> UtilityCallApi<'api> {
      #[doc = "Send a batch of dispatch calls."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[doc = ""]
      #[doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"]
      #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
      #[doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"]
      #[doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"]
      #[doc = "event is deposited."]
      #[cfg(not(feature = "ink"))]
      pub fn batch(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::batch { calls },
        ))
      }
      #[doc = "Send a batch of dispatch calls."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[doc = ""]
      #[doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"]
      #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
      #[doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"]
      #[doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"]
      #[doc = "event is deposited."]
      #[cfg(feature = "ink")]
      pub fn batch(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 0u8];
        calls.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Relay a call for a target from an origin"]
      #[doc = ""]
      #[doc = "Relaying in this context refers to the ability of origin to make a call on behalf of"]
      #[doc = "target."]
      #[doc = ""]
      #[doc = "Fees are charged to origin"]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = "- `target`: Account to be relayed"]
      #[doc = "- `signature`: Signature from target authorizing the relay"]
      #[doc = "- `call`: Call to be relayed on behalf of target"]
      #[doc = ""]
      #[doc = "POLYMESH: added."]
      #[cfg(not(feature = "ink"))]
      pub fn relay_tx(
        &self,
        target: ::polymesh_api_client::AccountId,
        signature: types::sp_runtime::MultiSignature,
        call: types::pallet_utility::UniqueCall<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::relay_tx {
            target,
            signature,
            call,
          },
        ))
      }
      #[doc = "Relay a call for a target from an origin"]
      #[doc = ""]
      #[doc = "Relaying in this context refers to the ability of origin to make a call on behalf of"]
      #[doc = "target."]
      #[doc = ""]
      #[doc = "Fees are charged to origin"]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = "- `target`: Account to be relayed"]
      #[doc = "- `signature`: Signature from target authorizing the relay"]
      #[doc = "- `call`: Call to be relayed on behalf of target"]
      #[doc = ""]
      #[doc = "POLYMESH: added."]
      #[cfg(feature = "ink")]
      pub fn relay_tx(
        &self,
        target: ::polymesh_api_client::AccountId,
        signature: types::sp_runtime::MultiSignature,
        call: types::pallet_utility::UniqueCall<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 1u8];
        target.encode_to(&mut buf);
        signature.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Send a batch of dispatch calls and atomically execute them."]
      #[doc = "The whole transaction will rollback and fail if any of the calls failed."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[cfg(not(feature = "ink"))]
      pub fn batch_all(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::batch_all { calls },
        ))
      }
      #[doc = "Send a batch of dispatch calls and atomically execute them."]
      #[doc = "The whole transaction will rollback and fail if any of the calls failed."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[cfg(feature = "ink")]
      pub fn batch_all(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 2u8];
        calls.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Dispatches a function call with a provided origin."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(1)."]
      #[cfg(not(feature = "ink"))]
      pub fn dispatch_as(
        &self,
        as_origin: runtime::OriginCaller,
        call: runtime::RuntimeCall,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::dispatch_as {
            as_origin: ::alloc::boxed::Box::new(as_origin),
            call: ::alloc::boxed::Box::new(call),
          },
        ))
      }
      #[doc = "Dispatches a function call with a provided origin."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(1)."]
      #[cfg(feature = "ink")]
      pub fn dispatch_as(
        &self,
        as_origin: runtime::OriginCaller,
        call: runtime::RuntimeCall,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 3u8];
        as_origin.encode_to(&mut buf);
        call.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Send a batch of dispatch calls."]
      #[doc = "Unlike `batch`, it allows errors and won't interrupt."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatch without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[cfg(not(feature = "ink"))]
      pub fn force_batch(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::force_batch { calls },
        ))
      }
      #[doc = "Send a batch of dispatch calls."]
      #[doc = "Unlike `batch`, it allows errors and won't interrupt."]
      #[doc = ""]
      #[doc = "May be called from any origin except `None`."]
      #[doc = ""]
      #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
      #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
      #[doc = ""]
      #[doc = "If origin is root then the calls are dispatch without checking origin filter. (This"]
      #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
      #[doc = ""]
      #[doc = "## Complexity"]
      #[doc = "- O(C) where C is the number of calls to be batched."]
      #[cfg(feature = "ink")]
      pub fn force_batch(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 4u8];
        calls.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Dispatch a function call with a specified weight."]
      #[doc = ""]
      #[doc = "This function does not check the weight of the call, and instead allows the"]
      #[doc = "Root origin to specify the weight of the call."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[cfg(not(feature = "ink"))]
      pub fn with_weight(
        &self,
        call: runtime::RuntimeCall,
        weight: ::polymesh_api_client::sp_weights::Weight,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::with_weight {
            call: ::alloc::boxed::Box::new(call),
            weight,
          },
        ))
      }
      #[doc = "Dispatch a function call with a specified weight."]
      #[doc = ""]
      #[doc = "This function does not check the weight of the call, and instead allows the"]
      #[doc = "Root origin to specify the weight of the call."]
      #[doc = ""]
      #[doc = "The dispatch origin for this call must be _Root_."]
      #[cfg(feature = "ink")]
      pub fn with_weight(
        &self,
        call: runtime::RuntimeCall,
        weight: ::polymesh_api_client::sp_weights::Weight,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 5u8];
        call.encode_to(&mut buf);
        weight.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Dispatch multiple calls from the sender's origin."]
      #[doc = ""]
      #[doc = "This will execute until the first one fails and then stop."]
      #[doc = ""]
      #[doc = "May be called from root or a signed origin."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = "- `calls`: The calls to be dispatched from the same origin."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "- The sum of the weights of the `calls`."]
      #[doc = "- One event."]
      #[doc = ""]
      #[doc = "This will return `Ok` in all circumstances except an unsigned origin. To determine the success of the batch, an"]
      #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
      #[doc = "`BatchInterruptedOld` event is deposited, along with the number of successful calls made"]
      #[doc = "and the error of the failed call. If all were successful, then the `BatchCompletedOld`"]
      #[doc = "event is deposited."]
      #[doc = ""]
      #[doc = "POLYMESH: Renamed from `batch` and deprecated."]
      #[cfg(not(feature = "ink"))]
      pub fn batch_old(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::batch_old { calls },
        ))
      }
      #[doc = "Dispatch multiple calls from the sender's origin."]
      #[doc = ""]
      #[doc = "This will execute until the first one fails and then stop."]
      #[doc = ""]
      #[doc = "May be called from root or a signed origin."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = "- `calls`: The calls to be dispatched from the same origin."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "- The sum of the weights of the `calls`."]
      #[doc = "- One event."]
      #[doc = ""]
      #[doc = "This will return `Ok` in all circumstances except an unsigned origin. To determine the success of the batch, an"]
      #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
      #[doc = "`BatchInterruptedOld` event is deposited, along with the number of successful calls made"]
      #[doc = "and the error of the failed call. If all were successful, then the `BatchCompletedOld`"]
      #[doc = "event is deposited."]
      #[doc = ""]
      #[doc = "POLYMESH: Renamed from `batch` and deprecated."]
      #[cfg(feature = "ink")]
      pub fn batch_old(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 6u8];
        calls.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Dispatch multiple calls from the sender's origin."]
      #[doc = ""]
      #[doc = "This will execute all calls, in order, stopping at the first failure,"]
      #[doc = "in which case the state changes are rolled back."]
      #[doc = "On failure, an event `BatchInterruptedOld(failure_idx, error)` is deposited."]
      #[doc = ""]
      #[doc = "May be called from root or a signed origin."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = "- `calls`: The calls to be dispatched from the same origin."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "- The sum of the weights of the `calls`."]
      #[doc = "- One event."]
      #[doc = ""]
      #[doc = "This will return `Ok` in all circumstances except an unsigned origin."]
      #[doc = "To determine the success of the batch, an event is deposited."]
      #[doc = "If any call failed, then `BatchInterruptedOld` is deposited."]
      #[doc = "If all were successful, then the `BatchCompletedOld` event is deposited."]
      #[doc = ""]
      #[doc = "POLYMESH: deprecated."]
      #[cfg(not(feature = "ink"))]
      pub fn batch_atomic(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::batch_atomic { calls },
        ))
      }
      #[doc = "Dispatch multiple calls from the sender's origin."]
      #[doc = ""]
      #[doc = "This will execute all calls, in order, stopping at the first failure,"]
      #[doc = "in which case the state changes are rolled back."]
      #[doc = "On failure, an event `BatchInterruptedOld(failure_idx, error)` is deposited."]
      #[doc = ""]
      #[doc = "May be called from root or a signed origin."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = "- `calls`: The calls to be dispatched from the same origin."]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "- The sum of the weights of the `calls`."]
      #[doc = "- One event."]
      #[doc = ""]
      #[doc = "This will return `Ok` in all circumstances except an unsigned origin."]
      #[doc = "To determine the success of the batch, an event is deposited."]
      #[doc = "If any call failed, then `BatchInterruptedOld` is deposited."]
      #[doc = "If all were successful, then the `BatchCompletedOld` event is deposited."]
      #[doc = ""]
      #[doc = "POLYMESH: deprecated."]
      #[cfg(feature = "ink")]
      pub fn batch_atomic(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 7u8];
        calls.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Dispatch multiple calls from the sender's origin."]
      #[doc = ""]
      #[doc = "This will execute all calls, in order, irrespective of failures."]
      #[doc = "Any failures will be available in a `BatchOptimisticFailed` event."]
      #[doc = ""]
      #[doc = "May be called from root or a signed origin."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = "- `calls`: The calls to be dispatched from the same origin."]
      #[doc = ""]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "- The sum of the weights of the `calls`."]
      #[doc = "- One event."]
      #[doc = ""]
      #[doc = "This will return `Ok` in all circumstances except an unsigned origin."]
      #[doc = "To determine the success of the batch, an event is deposited."]
      #[doc = "If any call failed, then `BatchOptimisticFailed` is deposited,"]
      #[doc = "with a vector of event counts for each call as well as a vector"]
      #[doc = "of errors."]
      #[doc = "If all were successful, then the `BatchCompletedOld` event is deposited."]
      #[doc = ""]
      #[doc = "POLYMESH: deprecated."]
      #[cfg(not(feature = "ink"))]
      pub fn batch_optimistic(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Utility(
          types::pallet_utility::pallet::UtilityCall::batch_optimistic { calls },
        ))
      }
      #[doc = "Dispatch multiple calls from the sender's origin."]
      #[doc = ""]
      #[doc = "This will execute all calls, in order, irrespective of failures."]
      #[doc = "Any failures will be available in a `BatchOptimisticFailed` event."]
      #[doc = ""]
      #[doc = "May be called from root or a signed origin."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = "- `calls`: The calls to be dispatched from the same origin."]
      #[doc = ""]
      #[doc = ""]
      #[doc = "# Weight"]
      #[doc = "- The sum of the weights of the `calls`."]
      #[doc = "- One event."]
      #[doc = ""]
      #[doc = "This will return `Ok` in all circumstances except an unsigned origin."]
      #[doc = "To determine the success of the batch, an event is deposited."]
      #[doc = "If any call failed, then `BatchOptimisticFailed` is deposited,"]
      #[doc = "with a vector of event counts for each call as well as a vector"]
      #[doc = "of errors."]
      #[doc = "If all were successful, then the `BatchCompletedOld` event is deposited."]
      #[doc = ""]
      #[doc = "POLYMESH: deprecated."]
      #[cfg(feature = "ink")]
      pub fn batch_optimistic(
        &self,
        calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![41u8, 8u8];
        calls.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for UtilityCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct UtilityQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> UtilityQueryApi<'api> {
      #[doc = " Nonce for `relay_tx`."]
      #[doc = " POLYMESH: added."]
      #[cfg(not(feature = "ink"))]
      pub async fn nonces(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 225u8, 162u8, 250u8, 22u8, 115u8, 44u8, 230u8, 144u8, 97u8, 137u8, 67u8, 140u8,
          10u8, 130u8, 198u8, 194u8, 10u8, 83u8, 78u8, 161u8, 40u8, 231u8, 69u8, 69u8, 109u8,
          162u8, 52u8, 205u8, 165u8, 229u8, 109u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Nonce for `relay_tx`."]
      #[doc = " POLYMESH: added."]
      #[cfg(feature = "ink")]
      pub fn nonces(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          213u8, 225u8, 162u8, 250u8, 22u8, 115u8, 44u8, 230u8, 144u8, 97u8, 137u8, 67u8, 140u8,
          10u8, 130u8, 198u8, 194u8, 10u8, 83u8, 78u8, 161u8, 40u8, 231u8, 69u8, 69u8, 109u8,
          162u8, 52u8, 205u8, 165u8, 229u8, 109u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod base {
    use super::*;
    #[derive(Clone)]
    pub struct BaseCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> BaseCallApi<'api> {}
    impl<'api> From<&'api super::super::Api> for BaseCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct BaseQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> BaseQueryApi<'api> {}
  }
  pub mod external_agents {
    use super::*;
    #[derive(Clone)]
    pub struct ExternalAgentsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ExternalAgentsCallApi<'api> {
      #[doc = "Creates a custom agent group (AG) for the given `ticker`."]
      #[doc = ""]
      #[doc = "The AG will have the permissions as given by `perms`."]
      #[doc = "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`,"]
      #[doc = "which you can use as `AgentGroup::Custom(id)` when adding agents for `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` to add the custom group for."]
      #[doc = "- `perms` that the new AG will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn create_group(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        perms: types::polymesh_primitives::subset::SubsetRestriction<
          types::polymesh_primitives::secondary_key::PalletPermissions,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::create_group { ticker, perms },
        ))
      }
      #[doc = "Creates a custom agent group (AG) for the given `ticker`."]
      #[doc = ""]
      #[doc = "The AG will have the permissions as given by `perms`."]
      #[doc = "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`,"]
      #[doc = "which you can use as `AgentGroup::Custom(id)` when adding agents for `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` to add the custom group for."]
      #[doc = "- `perms` that the new AG will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn create_group(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        perms: types::polymesh_primitives::subset::SubsetRestriction<
          types::polymesh_primitives::secondary_key::PalletPermissions,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 0u8];
        ticker.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the permissions of the custom AG identified by `id`, for the given `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` the custom AG belongs to."]
      #[doc = "- `id` for the custom AG within `ticker`."]
      #[doc = "- `perms` to update the custom AG to."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn set_group_permissions(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        id: types::polymesh_primitives::agent::AGId,
        perms: types::polymesh_primitives::subset::SubsetRestriction<
          types::polymesh_primitives::secondary_key::PalletPermissions,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::set_group_permissions {
            ticker,
            id,
            perms,
          },
        ))
      }
      #[doc = "Updates the permissions of the custom AG identified by `id`, for the given `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` the custom AG belongs to."]
      #[doc = "- `id` for the custom AG within `ticker`."]
      #[doc = "- `perms` to update the custom AG to."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn set_group_permissions(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        id: types::polymesh_primitives::agent::AGId,
        perms: types::polymesh_primitives::subset::SubsetRestriction<
          types::polymesh_primitives::secondary_key::PalletPermissions,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 1u8];
        ticker.encode_to(&mut buf);
        id.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove the given `agent` from `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` that has the `agent` to remove."]
      #[doc = "- `agent` of `ticker` to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `ticker`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` is the last full one."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn remove_agent(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        agent: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::remove_agent { ticker, agent },
        ))
      }
      #[doc = "Remove the given `agent` from `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` that has the `agent` to remove."]
      #[doc = "- `agent` of `ticker` to remove."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `ticker`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` is the last full one."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn remove_agent(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        agent: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 2u8];
        ticker.encode_to(&mut buf);
        agent.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Abdicate agentship for `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` of which the caller is an agent."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAnAgent` if the caller is not an agent of `ticker`."]
      #[doc = "- `RemovingLastFullAgent` if the caller is the last full agent."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn abdicate(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::abdicate { ticker },
        ))
      }
      #[doc = "Abdicate agentship for `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` of which the caller is an agent."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAnAgent` if the caller is not an agent of `ticker`."]
      #[doc = "- `RemovingLastFullAgent` if the caller is the last full agent."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn abdicate(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 3u8];
        ticker.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Change the agent group that `agent` belongs to in `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` that has the `agent`."]
      #[doc = "- `agent` of `ticker` to change the group for."]
      #[doc = "- `group` that `agent` will belong to in `ticker`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `ticker`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn change_group(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        agent: ::polymesh_api_client::IdentityId,
        group: types::polymesh_primitives::agent::AgentGroup,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::change_group {
            ticker,
            agent,
            group,
          },
        ))
      }
      #[doc = "Change the agent group that `agent` belongs to in `ticker`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `ticker` that has the `agent`."]
      #[doc = "- `agent` of `ticker` to change the group for."]
      #[doc = "- `group` that `agent` will belong to in `ticker`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
      #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
      #[doc = "- `NotAnAgent` if `agent` is not an agent of `ticker`."]
      #[doc = "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn change_group(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        agent: ::polymesh_api_client::IdentityId,
        group: types::polymesh_primitives::agent::AgentGroup,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 4u8];
        ticker.encode_to(&mut buf);
        agent.encode_to(&mut buf);
        group.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accept an authorization by an agent \"Alice\" who issued `auth_id`"]
      #[doc = "to also become an agent of the ticker Alice specified."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` identifying the authorization to accept."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` is for an auth that has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not for a `BecomeAgent` auth type."]
      #[doc = "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth."]
      #[doc = "- `NoSuchAG` if the group referred to a custom that does not exist."]
      #[doc = "- `AlreadyAnAgent` if the caller is already an agent of the ticker."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn accept_become_agent(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::accept_become_agent { auth_id },
        ))
      }
      #[doc = "Accept an authorization by an agent \"Alice\" who issued `auth_id`"]
      #[doc = "to also become an agent of the ticker Alice specified."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` identifying the authorization to accept."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` is for an auth that has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not for a `BecomeAgent` auth type."]
      #[doc = "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth."]
      #[doc = "- `NoSuchAG` if the group referred to a custom that does not exist."]
      #[doc = "- `AlreadyAnAgent` if the caller is already an agent of the ticker."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn accept_become_agent(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 5u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Utility extrinsic to batch `create_group` and  `add_auth`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn create_group_and_add_auth(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        perms: types::polymesh_primitives::subset::SubsetRestriction<
          types::polymesh_primitives::secondary_key::PalletPermissions,
        >,
        target: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::create_group_and_add_auth {
            ticker,
            perms,
            target,
            expiry,
          },
        ))
      }
      #[doc = "Utility extrinsic to batch `create_group` and  `add_auth`."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn create_group_and_add_auth(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        perms: types::polymesh_primitives::subset::SubsetRestriction<
          types::polymesh_primitives::secondary_key::PalletPermissions,
        >,
        target: ::polymesh_api_client::IdentityId,
        expiry: Option<u64>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 6u8];
        ticker.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        target.encode_to(&mut buf);
        expiry.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Utility extrinsic to batch `create_group` and  `change_group` for custom groups only."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(not(feature = "ink"))]
      pub fn create_and_change_custom_group(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        perms: types::polymesh_primitives::subset::SubsetRestriction<
          types::polymesh_primitives::secondary_key::PalletPermissions,
        >,
        agent: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
          types::pallet_external_agents::ExternalAgentsCall::create_and_change_custom_group {
            ticker,
            perms,
            agent,
          },
        ))
      }
      #[doc = "Utility extrinsic to batch `create_group` and  `change_group` for custom groups only."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Agent"]
      #[cfg(feature = "ink")]
      pub fn create_and_change_custom_group(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        perms: types::polymesh_primitives::subset::SubsetRestriction<
          types::polymesh_primitives::secondary_key::PalletPermissions,
        >,
        agent: ::polymesh_api_client::IdentityId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![43u8, 7u8];
        ticker.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        agent.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ExternalAgentsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ExternalAgentsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ExternalAgentsQueryApi<'api> {
      #[doc = " The next per-`Ticker` AG ID in the sequence."]
      #[doc = ""]
      #[doc = " The full ID is defined as a combination of `Ticker` and a number in this sequence,"]
      #[doc = " which starts from 1, rather than 0."]
      #[cfg(not(feature = "ink"))]
      pub async fn ag_id_sequence(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::agent::AGId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 12u8, 233u8, 200u8, 225u8, 173u8, 92u8, 11u8, 5u8, 96u8, 24u8,
          174u8, 23u8, 140u8, 103u8, 130u8, 219u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::agent::AGId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next per-`Ticker` AG ID in the sequence."]
      #[doc = ""]
      #[doc = " The full ID is defined as a combination of `Ticker` and a number in this sequence,"]
      #[doc = " which starts from 1, rather than 0."]
      #[cfg(feature = "ink")]
      pub fn ag_id_sequence(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::agent::AGId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 12u8, 233u8, 200u8, 225u8, 173u8, 92u8, 11u8, 5u8, 96u8, 24u8,
          174u8, 23u8, 140u8, 103u8, 130u8, 219u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::agent::AGId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps an agent (`IdentityId`) to all all `Ticker`s they belong to, if any."]
      #[cfg(not(feature = "ink"))]
      pub async fn agent_of(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 53u8, 162u8, 207u8, 202u8, 92u8, 195u8, 4u8, 152u8, 44u8, 119u8,
          99u8, 8u8, 91u8, 94u8, 104u8, 181u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps an agent (`IdentityId`) to all all `Ticker`s they belong to, if any."]
      #[cfg(feature = "ink")]
      pub fn agent_of(
        &self,
        key_0: ::polymesh_api_client::IdentityId,
        key_1: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<()> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 53u8, 162u8, 207u8, 202u8, 92u8, 195u8, 4u8, 152u8, 44u8, 119u8,
          99u8, 8u8, 91u8, 94u8, 104u8, 181u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[];
          <()>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps agents (`IdentityId`) for a `Ticker` to what AG they belong to, if any."]
      #[cfg(not(feature = "ink"))]
      pub async fn group_of_agent(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::agent::AgentGroup>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 242u8, 55u8, 209u8, 95u8, 72u8, 97u8, 175u8, 60u8, 82u8, 212u8,
          93u8, 134u8, 226u8, 228u8, 249u8, 241u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " Maps agents (`IdentityId`) for a `Ticker` to what AG they belong to, if any."]
      #[cfg(feature = "ink")]
      pub fn group_of_agent(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::agent::AgentGroup>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 242u8, 55u8, 209u8, 95u8, 72u8, 97u8, 175u8, 60u8, 82u8, 212u8,
          93u8, 134u8, 226u8, 228u8, 249u8, 241u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Maps a `Ticker` to the number of `Full` agents for it."]
      #[cfg(not(feature = "ink"))]
      pub async fn num_full_agents(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 73u8, 199u8, 126u8, 22u8, 129u8, 58u8, 64u8, 117u8, 2u8, 182u8,
          198u8, 217u8, 175u8, 14u8, 213u8, 191u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Maps a `Ticker` to the number of `Full` agents for it."]
      #[cfg(feature = "ink")]
      pub fn num_full_agents(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<u32> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 73u8, 199u8, 126u8, 22u8, 129u8, 58u8, 64u8, 117u8, 2u8, 182u8,
          198u8, 217u8, 175u8, 14u8, 213u8, 191u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
          <u32>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " For custom AGs of a `Ticker`, maps to what permissions an agent in that AG would have."]
      #[cfg(not(feature = "ink"))]
      pub async fn group_permissions(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::agent::AGId,
      ) -> ::polymesh_api_client::error::Result<
        Option<
          types::polymesh_primitives::subset::SubsetRestriction<
            types::polymesh_primitives::secondary_key::PalletPermissions,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 228u8, 175u8, 240u8, 58u8, 197u8, 94u8, 151u8, 139u8, 185u8, 101u8,
          37u8, 225u8, 222u8, 165u8, 102u8, 172u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " For custom AGs of a `Ticker`, maps to what permissions an agent in that AG would have."]
      #[cfg(feature = "ink")]
      pub fn group_permissions(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: types::polymesh_primitives::agent::AGId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<
          types::polymesh_primitives::subset::SubsetRestriction<
            types::polymesh_primitives::secondary_key::PalletPermissions,
          >,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8, 84u8,
          235u8, 102u8, 212u8, 228u8, 175u8, 240u8, 58u8, 197u8, 94u8, 151u8, 139u8, 185u8, 101u8,
          37u8, 225u8, 222u8, 165u8, 102u8, 172u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
  }
  pub mod relayer {
    use super::*;
    #[derive(Clone)]
    pub struct RelayerCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> RelayerCallApi<'api> {
      #[doc = "Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to subsidise."]
      #[doc = "- `polyx_limit` the initial POLYX limit for this subsidy."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(not(feature = "ink"))]
      pub fn set_paying_key(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::set_paying_key {
            user_key,
            polyx_limit,
          },
        ))
      }
      #[doc = "Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to subsidise."]
      #[doc = "- `polyx_limit` the initial POLYX limit for this subsidy."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(feature = "ink")]
      pub fn set_paying_key(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 0u8];
        user_key.encode_to(&mut buf);
        polyx_limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Accepts a `paying_key` authorization."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` the authorization id to accept a `paying_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` the authorization has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not a `AddRelayerPayingKey` authorization."]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`."]
      #[doc = "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity."]
      #[doc = "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity."]
      #[doc = "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(not(feature = "ink"))]
      pub fn accept_paying_key(
        &self,
        auth_id: u64,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::accept_paying_key { auth_id },
        ))
      }
      #[doc = "Accepts a `paying_key` authorization."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `auth_id` the authorization id to accept a `paying_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AuthorizationError::Invalid` if `auth_id` does not exist for the given caller."]
      #[doc = "- `AuthorizationError::Expired` if `auth_id` the authorization has expired."]
      #[doc = "- `AuthorizationError::BadType` if `auth_id` was not a `AddRelayerPayingKey` authorization."]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`."]
      #[doc = "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity."]
      #[doc = "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity."]
      #[doc = "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(feature = "ink")]
      pub fn accept_paying_key(&self, auth_id: u64) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 1u8];
        auth_id.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Removes the `paying_key` from a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to remove the subsidy from."]
      #[doc = "- `paying_key` the paying key that was subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`."]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_paying_key(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        paying_key: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::remove_paying_key {
            user_key,
            paying_key,
          },
        ))
      }
      #[doc = "Removes the `paying_key` from a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key to remove the subsidy from."]
      #[doc = "- `paying_key` the paying key that was subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`."]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(feature = "ink")]
      pub fn remove_paying_key(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        paying_key: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 2u8];
        user_key.encode_to(&mut buf);
        paying_key.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Updates the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(not(feature = "ink"))]
      pub fn update_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::update_polyx_limit {
            user_key,
            polyx_limit,
          },
        ))
      }
      #[doc = "Updates the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[cfg(feature = "ink")]
      pub fn update_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        polyx_limit: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 3u8];
        user_key.encode_to(&mut buf);
        polyx_limit.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Increase the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to add to the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`."]
      #[cfg(not(feature = "ink"))]
      pub fn increase_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::increase_polyx_limit { user_key, amount },
        ))
      }
      #[doc = "Increase the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to add to the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`."]
      #[cfg(feature = "ink")]
      pub fn increase_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 4u8];
        user_key.encode_to(&mut buf);
        amount.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Decrease the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to remove from the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy has less then `amount` POLYX remaining."]
      #[cfg(not(feature = "ink"))]
      pub fn decrease_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Relayer(
          types::pallet_relayer::RelayerCall::decrease_polyx_limit { user_key, amount },
        ))
      }
      #[doc = "Decrease the available POLYX for a `user_key`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
      #[doc = "- `amount` the amount of POLYX to remove from the subsidy of `user_key`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
      #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
      #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
      #[doc = "- `Overlow` if the subsidy has less then `amount` POLYX remaining."]
      #[cfg(feature = "ink")]
      pub fn decrease_polyx_limit(
        &self,
        user_key: ::polymesh_api_client::AccountId,
        amount: u128,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![44u8, 5u8];
        user_key.encode_to(&mut buf);
        amount.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for RelayerCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct RelayerQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> RelayerQueryApi<'api> {
      #[doc = " The subsidy for a `user_key` if they are being subsidised,"]
      #[doc = " as a map `user_key` => `Subsidy`."]
      #[doc = ""]
      #[doc = " A key can only have one subsidy at a time.  To change subsidisers"]
      #[doc = " a key needs to call `remove_paying_key` to remove the current subsidy,"]
      #[doc = " before they can accept a new subsidiser."]
      #[cfg(not(feature = "ink"))]
      pub async fn subsidies(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_relayer::Subsidy<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          5u8, 71u8, 187u8, 31u8, 121u8, 115u8, 160u8, 127u8, 217u8, 78u8, 1u8, 160u8, 208u8,
          220u8, 209u8, 106u8, 75u8, 74u8, 110u8, 95u8, 140u8, 115u8, 246u8, 81u8, 202u8, 177u8,
          63u8, 253u8, 143u8, 76u8, 227u8, 53u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The subsidy for a `user_key` if they are being subsidised,"]
      #[doc = " as a map `user_key` => `Subsidy`."]
      #[doc = ""]
      #[doc = " A key can only have one subsidy at a time.  To change subsidisers"]
      #[doc = " a key needs to call `remove_paying_key` to remove the current subsidy,"]
      #[doc = " before they can accept a new subsidiser."]
      #[cfg(feature = "ink")]
      pub fn subsidies(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_relayer::Subsidy<::polymesh_api_client::AccountId>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          5u8, 71u8, 187u8, 31u8, 121u8, 115u8, 160u8, 127u8, 217u8, 78u8, 1u8, 160u8, 208u8,
          220u8, 209u8, 106u8, 75u8, 74u8, 110u8, 95u8, 140u8, 115u8, 246u8, 81u8, 202u8, 177u8,
          63u8, 253u8, 143u8, 76u8, 227u8, 53u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
  }
  pub mod contracts {
    use super::*;
    #[derive(Clone)]
    pub struct ContractsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> ContractsCallApi<'api> {
      #[doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."]
      #[cfg(not(feature = "ink"))]
      pub fn call_old_weight(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        data: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::call_old_weight {
            dest,
            value,
            gas_limit,
            storage_deposit_limit,
            data,
          },
        ))
      }
      #[doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."]
      #[cfg(feature = "ink")]
      pub fn call_old_weight(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        data: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 0u8];
        dest.encode_to(&mut buf);
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        data.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_with_code_old_weight(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::instantiate_with_code_old_weight {
            value,
            gas_limit,
            storage_deposit_limit,
            code,
            data,
            salt,
          },
        ))
      }
      #[doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."]
      #[cfg(feature = "ink")]
      pub fn instantiate_with_code_old_weight(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 1u8];
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_old_weight(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::instantiate_old_weight {
            value,
            gas_limit,
            storage_deposit_limit,
            code_hash,
            data,
            salt,
          },
        ))
      }
      #[doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."]
      #[cfg(feature = "ink")]
      pub fn instantiate_old_weight(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::OldWeight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 2u8];
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code_hash.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Upload new `code` without instantiating a contract from it."]
      #[doc = ""]
      #[doc = "If the code does not already exist a deposit is reserved from the caller"]
      #[doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"]
      #[doc = "depends on the instrumented size of the the supplied `code`."]
      #[doc = ""]
      #[doc = "If the code already exists in storage it will still return `Ok` and upgrades"]
      #[doc = "the in storage version to the current"]
      #[doc = "[`InstructionWeights::version`](InstructionWeights)."]
      #[doc = ""]
      #[doc = "- `determinism`: If this is set to any other value but [`Determinism::Deterministic`]"]
      #[doc = "  then the only way to use this code is to delegate call into it from an offchain"]
      #[doc = "  execution. Set to [`Determinism::Deterministic`] if in doubt."]
      #[doc = ""]
      #[doc = "# Note"]
      #[doc = ""]
      #[doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."]
      #[doc = "To avoid this situation a constructor could employ access control so that it can"]
      #[doc = "only be instantiated by permissioned entities. The same is true when uploading"]
      #[doc = "through [`Self::instantiate_with_code`]."]
      #[cfg(not(feature = "ink"))]
      pub fn upload_code(
        &self,
        code: ::alloc::vec::Vec<u8>,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        determinism: types::pallet_contracts::wasm::Determinism,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::upload_code {
            code,
            storage_deposit_limit,
            determinism,
          },
        ))
      }
      #[doc = "Upload new `code` without instantiating a contract from it."]
      #[doc = ""]
      #[doc = "If the code does not already exist a deposit is reserved from the caller"]
      #[doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"]
      #[doc = "depends on the instrumented size of the the supplied `code`."]
      #[doc = ""]
      #[doc = "If the code already exists in storage it will still return `Ok` and upgrades"]
      #[doc = "the in storage version to the current"]
      #[doc = "[`InstructionWeights::version`](InstructionWeights)."]
      #[doc = ""]
      #[doc = "- `determinism`: If this is set to any other value but [`Determinism::Deterministic`]"]
      #[doc = "  then the only way to use this code is to delegate call into it from an offchain"]
      #[doc = "  execution. Set to [`Determinism::Deterministic`] if in doubt."]
      #[doc = ""]
      #[doc = "# Note"]
      #[doc = ""]
      #[doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."]
      #[doc = "To avoid this situation a constructor could employ access control so that it can"]
      #[doc = "only be instantiated by permissioned entities. The same is true when uploading"]
      #[doc = "through [`Self::instantiate_with_code`]."]
      #[cfg(feature = "ink")]
      pub fn upload_code(
        &self,
        code: ::alloc::vec::Vec<u8>,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        determinism: types::pallet_contracts::wasm::Determinism,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 3u8];
        code.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        determinism.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."]
      #[doc = ""]
      #[doc = "A code can only be removed by its original uploader (its owner) and only if it is"]
      #[doc = "not used by any contract."]
      #[cfg(not(feature = "ink"))]
      pub fn remove_code(
        &self,
        code_hash: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::remove_code { code_hash },
        ))
      }
      #[doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."]
      #[doc = ""]
      #[doc = "A code can only be removed by its original uploader (its owner) and only if it is"]
      #[doc = "not used by any contract."]
      #[cfg(feature = "ink")]
      pub fn remove_code(
        &self,
        code_hash: types::primitive_types::H256,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 4u8];
        code_hash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Privileged function that changes the code of an existing contract."]
      #[doc = ""]
      #[doc = "This takes care of updating refcounts and all other necessary operations. Returns"]
      #[doc = "an error if either the `code_hash` or `dest` do not exist."]
      #[doc = ""]
      #[doc = "# Note"]
      #[doc = ""]
      #[doc = "This does **not** change the address of the contract in question. This means"]
      #[doc = "that the contract address is no longer derived from its code hash after calling"]
      #[doc = "this dispatchable."]
      #[cfg(not(feature = "ink"))]
      pub fn set_code(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        code_hash: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::set_code { dest, code_hash },
        ))
      }
      #[doc = "Privileged function that changes the code of an existing contract."]
      #[doc = ""]
      #[doc = "This takes care of updating refcounts and all other necessary operations. Returns"]
      #[doc = "an error if either the `code_hash` or `dest` do not exist."]
      #[doc = ""]
      #[doc = "# Note"]
      #[doc = ""]
      #[doc = "This does **not** change the address of the contract in question. This means"]
      #[doc = "that the contract address is no longer derived from its code hash after calling"]
      #[doc = "this dispatchable."]
      #[cfg(feature = "ink")]
      pub fn set_code(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        code_hash: types::primitive_types::H256,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 5u8];
        dest.encode_to(&mut buf);
        code_hash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Makes a call to an account, optionally transferring some balance."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = ""]
      #[doc = "* `dest`: Address of the contract to call."]
      #[doc = "* `value`: The balance to transfer from the `origin` to `dest`."]
      #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
      #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"]
      #[doc = "  caller to pay for the storage consumed."]
      #[doc = "* `data`: The input data to pass to the contract."]
      #[doc = ""]
      #[doc = "* If the account is a smart-contract account, the associated code will be"]
      #[doc = "executed and any value will be transferred."]
      #[doc = "* If the account is a regular account, any value will be transferred."]
      #[doc = "* If no account exists and the call value is not less than `existential_deposit`,"]
      #[doc = "a regular account will be created and any value will be transferred."]
      #[cfg(not(feature = "ink"))]
      pub fn call(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        data: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::call {
            dest,
            value,
            gas_limit,
            storage_deposit_limit,
            data,
          },
        ))
      }
      #[doc = "Makes a call to an account, optionally transferring some balance."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = ""]
      #[doc = "* `dest`: Address of the contract to call."]
      #[doc = "* `value`: The balance to transfer from the `origin` to `dest`."]
      #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
      #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"]
      #[doc = "  caller to pay for the storage consumed."]
      #[doc = "* `data`: The input data to pass to the contract."]
      #[doc = ""]
      #[doc = "* If the account is a smart-contract account, the associated code will be"]
      #[doc = "executed and any value will be transferred."]
      #[doc = "* If the account is a regular account, any value will be transferred."]
      #[doc = "* If no account exists and the call value is not less than `existential_deposit`,"]
      #[doc = "a regular account will be created and any value will be transferred."]
      #[cfg(feature = "ink")]
      pub fn call(
        &self,
        dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        data: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 6u8];
        dest.encode_to(&mut buf);
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        data.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Instantiates a new contract from the supplied `code` optionally transferring"]
      #[doc = "some balance."]
      #[doc = ""]
      #[doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"]
      #[doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"]
      #[doc = "also check the documentation of [`Self::upload_code`]."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = ""]
      #[doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."]
      #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
      #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "* `code`: The contract code to deploy in raw bytes."]
      #[doc = "* `data`: The input data to pass to the contract constructor."]
      #[doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."]
      #[doc = ""]
      #[doc = "Instantiation is executed as follows:"]
      #[doc = ""]
      #[doc = "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that"]
      #[doc = "  code."]
      #[doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."]
      #[doc = "- The destination address is computed based on the sender, code_hash and the salt."]
      #[doc = "- The smart-contract account is created at the computed address."]
      #[doc = "- The `value` is transferred to the new account."]
      #[doc = "- The `deploy` function is executed in the context of the newly-created account."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_with_code(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::instantiate_with_code {
            value,
            gas_limit,
            storage_deposit_limit,
            code,
            data,
            salt,
          },
        ))
      }
      #[doc = "Instantiates a new contract from the supplied `code` optionally transferring"]
      #[doc = "some balance."]
      #[doc = ""]
      #[doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"]
      #[doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"]
      #[doc = "also check the documentation of [`Self::upload_code`]."]
      #[doc = ""]
      #[doc = "# Parameters"]
      #[doc = ""]
      #[doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."]
      #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
      #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "* `code`: The contract code to deploy in raw bytes."]
      #[doc = "* `data`: The input data to pass to the contract constructor."]
      #[doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."]
      #[doc = ""]
      #[doc = "Instantiation is executed as follows:"]
      #[doc = ""]
      #[doc = "- The supplied `code` is instrumented, deployed, and a `code_hash` is created for that"]
      #[doc = "  code."]
      #[doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."]
      #[doc = "- The destination address is computed based on the sender, code_hash and the salt."]
      #[doc = "- The smart-contract account is created at the computed address."]
      #[doc = "- The `value` is transferred to the new account."]
      #[doc = "- The `deploy` function is executed in the context of the newly-created account."]
      #[cfg(feature = "ink")]
      pub fn instantiate_with_code(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 7u8];
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Instantiates a contract from a previously deployed wasm binary."]
      #[doc = ""]
      #[doc = "This function is identical to [`Self::instantiate_with_code`] but without the"]
      #[doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"]
      #[doc = "must be supplied."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Contracts(
          types::pallet_contracts::pallet::ContractsCall::instantiate {
            value,
            gas_limit,
            storage_deposit_limit,
            code_hash,
            data,
            salt,
          },
        ))
      }
      #[doc = "Instantiates a contract from a previously deployed wasm binary."]
      #[doc = ""]
      #[doc = "This function is identical to [`Self::instantiate_with_code`] but without the"]
      #[doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"]
      #[doc = "must be supplied."]
      #[cfg(feature = "ink")]
      pub fn instantiate(
        &self,
        value: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<::codec::Compact<u128>>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![46u8, 8u8];
        value.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code_hash.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for ContractsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct ContractsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> ContractsQueryApi<'api> {
      #[doc = " A mapping from an original code hash to the original code, untouched by instrumentation."]
      #[cfg(not(feature = "ink"))]
      pub async fn pristine_code(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::bounded_collections::bounded_vec::BoundedVec<u8>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 77u8, 108u8, 43u8, 3u8, 185u8, 0u8, 40u8, 243u8, 191u8, 64u8, 126u8,
          180u8, 51u8, 233u8, 99u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A mapping from an original code hash to the original code, untouched by instrumentation."]
      #[cfg(feature = "ink")]
      pub fn pristine_code(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::bounded_collections::bounded_vec::BoundedVec<u8>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 77u8, 108u8, 43u8, 3u8, 185u8, 0u8, 40u8, 243u8, 191u8, 64u8, 126u8,
          180u8, 51u8, 233u8, 99u8, 137u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A mapping between an original code hash and instrumented wasm code, ready for execution."]
      #[cfg(not(feature = "ink"))]
      pub async fn code_storage(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_contracts::wasm::PrefabWasmModule>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 34u8, 252u8, 169u8, 6u8, 17u8, 186u8, 139u8, 121u8, 66u8, 248u8,
          189u8, 179u8, 185u8, 127u8, 101u8, 128u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A mapping between an original code hash and instrumented wasm code, ready for execution."]
      #[cfg(feature = "ink")]
      pub fn code_storage(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_contracts::wasm::PrefabWasmModule>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 34u8, 252u8, 169u8, 6u8, 17u8, 186u8, 139u8, 121u8, 66u8, 248u8,
          189u8, 179u8, 185u8, 127u8, 101u8, 128u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " A mapping between an original code hash and its owner information."]
      #[cfg(not(feature = "ink"))]
      pub async fn owner_info_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<Option<types::pallet_contracts::wasm::OwnerInfo>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 83u8, 241u8, 63u8, 211u8, 25u8, 160u8, 60u8, 33u8, 19u8, 55u8, 199u8,
          110u8, 15u8, 231u8, 118u8, 223u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " A mapping between an original code hash and its owner information."]
      #[cfg(feature = "ink")]
      pub fn owner_info_of(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_contracts::wasm::OwnerInfo>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 83u8, 241u8, 63u8, 211u8, 25u8, 160u8, 60u8, 33u8, 19u8, 55u8, 199u8,
          110u8, 15u8, 231u8, 118u8, 223u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " This is a **monotonic** counter incremented on contract instantiation."]
      #[doc = ""]
      #[doc = " This is used in order to generate unique trie ids for contracts."]
      #[doc = " The trie id of a new contract is calculated from hash(account_id, nonce)."]
      #[doc = " The nonce is required because otherwise the following sequence would lead to"]
      #[doc = " a possible collision of storage:"]
      #[doc = ""]
      #[doc = " 1. Create a new contract."]
      #[doc = " 2. Terminate the contract."]
      #[doc = " 3. Immediately recreate the contract with the same account_id."]
      #[doc = ""]
      #[doc = " This is bad because the contents of a trie are deleted lazily and there might be"]
      #[doc = " storage of the old instantiation still in it when the new contract is created. Please"]
      #[doc = " note that we can't replace the counter by the block number because the sequence above"]
      #[doc = " can happen in the same block. We also can't keep the account counter in memory only"]
      #[doc = " because storage is the only way to communicate across different extrinsics in the"]
      #[doc = " same block."]
      #[doc = ""]
      #[doc = " # Note"]
      #[doc = ""]
      #[doc = " Do not use it to determine the number of contracts. It won't be decremented if"]
      #[doc = " a contract is destroyed."]
      #[cfg(not(feature = "ink"))]
      pub async fn nonce(&self) -> ::polymesh_api_client::error::Result<u64> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 113u8, 131u8, 104u8, 160u8, 172u8, 227u8, 110u8, 43u8, 27u8, 139u8,
          109u8, 189u8, 127u8, 128u8, 147u8, 192u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " This is a **monotonic** counter incremented on contract instantiation."]
      #[doc = ""]
      #[doc = " This is used in order to generate unique trie ids for contracts."]
      #[doc = " The trie id of a new contract is calculated from hash(account_id, nonce)."]
      #[doc = " The nonce is required because otherwise the following sequence would lead to"]
      #[doc = " a possible collision of storage:"]
      #[doc = ""]
      #[doc = " 1. Create a new contract."]
      #[doc = " 2. Terminate the contract."]
      #[doc = " 3. Immediately recreate the contract with the same account_id."]
      #[doc = ""]
      #[doc = " This is bad because the contents of a trie are deleted lazily and there might be"]
      #[doc = " storage of the old instantiation still in it when the new contract is created. Please"]
      #[doc = " note that we can't replace the counter by the block number because the sequence above"]
      #[doc = " can happen in the same block. We also can't keep the account counter in memory only"]
      #[doc = " because storage is the only way to communicate across different extrinsics in the"]
      #[doc = " same block."]
      #[doc = ""]
      #[doc = " # Note"]
      #[doc = ""]
      #[doc = " Do not use it to determine the number of contracts. It won't be decremented if"]
      #[doc = " a contract is destroyed."]
      #[cfg(feature = "ink")]
      pub fn nonce(&self) -> ::polymesh_api_ink::error::Result<u64> {
        let value = self.api.read_storage(::alloc::vec![
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 113u8, 131u8, 104u8, 160u8, 172u8, 227u8, 110u8, 43u8, 27u8, 139u8,
          109u8, 189u8, 127u8, 128u8, 147u8, 192u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The code associated with a given account."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn contract_info_of(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_contracts::storage::ContractInfo>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 6u8, 14u8, 153u8, 229u8, 55u8, 142u8, 86u8, 37u8, 55u8, 207u8, 59u8,
          201u8, 131u8, 225u8, 123u8, 145u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The code associated with a given account."]
      #[doc = ""]
      #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
      #[cfg(feature = "ink")]
      pub fn contract_info_of(
        &self,
        key_0: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_contracts::storage::ContractInfo>>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 6u8, 14u8, 153u8, 229u8, 55u8, 142u8, 86u8, 37u8, 55u8, 207u8, 59u8,
          201u8, 131u8, 225u8, 123u8, 145u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::twox_64(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[doc = " Evicted contracts that await child trie deletion."]
      #[doc = ""]
      #[doc = " Child trie deletion is a heavy operation depending on the amount of storage items"]
      #[doc = " stored in said trie. Therefore this operation is performed lazily in `on_initialize`."]
      #[cfg(not(feature = "ink"))]
      pub async fn deletion_queue(
        &self,
      ) -> ::polymesh_api_client::error::Result<
        types::bounded_collections::bounded_vec::BoundedVec<
          types::pallet_contracts::storage::DeletedContract,
        >,
      > {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 41u8, 22u8, 33u8, 17u8, 173u8, 25u8, 239u8, 20u8, 81u8, 85u8, 238u8,
          85u8, 42u8, 239u8, 45u8, 17u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_vec::BoundedVec<
            types::pallet_contracts::storage::DeletedContract,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " Evicted contracts that await child trie deletion."]
      #[doc = ""]
      #[doc = " Child trie deletion is a heavy operation depending on the amount of storage items"]
      #[doc = " stored in said trie. Therefore this operation is performed lazily in `on_initialize`."]
      #[cfg(feature = "ink")]
      pub fn deletion_queue(
        &self,
      ) -> ::polymesh_api_ink::error::Result<
        types::bounded_collections::bounded_vec::BoundedVec<
          types::pallet_contracts::storage::DeletedContract,
        >,
      > {
        let value = self.api.read_storage(::alloc::vec![
          67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8, 208u8,
          220u8, 85u8, 48u8, 41u8, 22u8, 33u8, 17u8, 173u8, 25u8, 239u8, 20u8, 81u8, 85u8, 238u8,
          85u8, 42u8, 239u8, 45u8, 17u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::bounded_collections::bounded_vec::BoundedVec<
            types::pallet_contracts::storage::DeletedContract,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
    }
  }
  pub mod polymesh_contracts {
    use super::*;
    #[derive(Clone)]
    pub struct PolymeshContractsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PolymeshContractsCallApi<'api> {
      #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code` with the WASM binary defining the smart contract."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_with_code_perms(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshContracts(
          types::polymesh_contracts::PolymeshContractsCall::instantiate_with_code_perms {
            endowment,
            gas_limit,
            storage_deposit_limit,
            code,
            data,
            salt,
            perms,
          },
        ))
      }
      #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code` with the WASM binary defining the smart contract."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[cfg(feature = "ink")]
      pub fn instantiate_with_code_perms(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code: ::alloc::vec::Vec<u8>,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![47u8, 0u8];
        endowment.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
      #[doc = ""]
      #[doc = "Unlike `instantiate_with_code`,"]
      #[doc = "this assumes that at least one contract with the same WASM code has already been uploaded."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code_hash` of an already uploaded WASM binary."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[cfg(not(feature = "ink"))]
      pub fn instantiate_with_hash_perms(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshContracts(
          types::polymesh_contracts::PolymeshContractsCall::instantiate_with_hash_perms {
            endowment,
            gas_limit,
            storage_deposit_limit,
            code_hash,
            data,
            salt,
            perms,
          },
        ))
      }
      #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
      #[doc = ""]
      #[doc = "Unlike `instantiate_with_code`,"]
      #[doc = "this assumes that at least one contract with the same WASM code has already been uploaded."]
      #[doc = ""]
      #[doc = "The contract will be attached as a secondary key,"]
      #[doc = "with `perms` as its permissions, to `origin`'s identity."]
      #[doc = ""]
      #[doc = "The contract is transferred `endowment` amount of POLYX."]
      #[doc = "This is distinct from the `gas_limit`,"]
      #[doc = "which controls how much gas the deployment code may at most consume."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
      #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
      #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
      #[doc = "  from the caller to pay for the storage consumed."]
      #[doc = "- `code_hash` of an already uploaded WASM binary."]
      #[doc = "- `data` The input data to pass to the contract constructor."]
      #[doc = "- `salt` used for contract address derivation."]
      #[doc = "   By varying this, the same `code` can be used under the same identity."]
      #[doc = "- `perms` that the new secondary key will have."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- All the errors in `pallet_contracts::Call::instantiate` can also happen here."]
      #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
      #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
      #[cfg(feature = "ink")]
      pub fn instantiate_with_hash_perms(
        &self,
        endowment: u128,
        gas_limit: ::polymesh_api_client::sp_weights::Weight,
        storage_deposit_limit: Option<u128>,
        code_hash: types::primitive_types::H256,
        data: ::alloc::vec::Vec<u8>,
        salt: ::alloc::vec::Vec<u8>,
        perms: types::polymesh_primitives::secondary_key::Permissions,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![47u8, 1u8];
        endowment.encode_to(&mut buf);
        gas_limit.encode_to(&mut buf);
        storage_deposit_limit.encode_to(&mut buf);
        code_hash.encode_to(&mut buf);
        data.encode_to(&mut buf);
        salt.encode_to(&mut buf);
        perms.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Update CallRuntime whitelist."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = ""]
      #[doc = "# Errors"]
      #[cfg(not(feature = "ink"))]
      pub fn update_call_runtime_whitelist(
        &self,
        updates: ::alloc::vec::Vec<(
          types::polymesh_contracts::chain_extension::ExtrinsicId,
          bool,
        )>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::PolymeshContracts(
          types::polymesh_contracts::PolymeshContractsCall::update_call_runtime_whitelist {
            updates,
          },
        ))
      }
      #[doc = "Update CallRuntime whitelist."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = ""]
      #[doc = "# Errors"]
      #[cfg(feature = "ink")]
      pub fn update_call_runtime_whitelist(
        &self,
        updates: ::alloc::vec::Vec<(
          types::polymesh_contracts::chain_extension::ExtrinsicId,
          bool,
        )>,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![47u8, 2u8];
        updates.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for PolymeshContractsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PolymeshContractsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PolymeshContractsQueryApi<'api> {
      #[doc = " Whitelist of extrinsics allowed to be called from contracts."]
      #[cfg(not(feature = "ink"))]
      pub async fn call_runtime_whitelist(
        &self,
        key_0: types::polymesh_contracts::chain_extension::ExtrinsicId,
      ) -> ::polymesh_api_client::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 18u8, 86u8, 78u8, 236u8, 93u8, 99u8, 65u8, 206u8, 211u8, 34u8, 76u8,
          171u8, 105u8, 214u8, 137u8, 42u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Whitelist of extrinsics allowed to be called from contracts."]
      #[cfg(feature = "ink")]
      pub fn call_runtime_whitelist(
        &self,
        key_0: types::polymesh_contracts::chain_extension::ExtrinsicId,
      ) -> ::polymesh_api_ink::error::Result<bool> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 18u8, 86u8, 78u8, 236u8, 93u8, 99u8, 65u8, 206u8, 211u8, 34u8, 76u8,
          171u8, 105u8, 214u8, 137u8, 42u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <bool>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(not(feature = "ink"))]
      pub async fn storage_version(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_contracts::Version> {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_contracts::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " Storage version."]
      #[cfg(feature = "ink")]
      pub fn storage_version(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_contracts::Version> {
        let value = self.api.read_storage(::alloc::vec![
          2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8, 214u8,
          209u8, 166u8, 2u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8, 130u8, 248u8,
          169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_contracts::Version>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod preimage {
    use super::*;
    #[derive(Clone)]
    pub struct PreimageCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> PreimageCallApi<'api> {
      #[doc = "Register a preimage on-chain."]
      #[doc = ""]
      #[doc = "If the preimage was previously requested, no fees or deposits are taken for providing"]
      #[doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."]
      #[cfg(not(feature = "ink"))]
      pub fn note_preimage(
        &self,
        bytes: ::alloc::vec::Vec<u8>,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Preimage(
          types::pallet_preimage::pallet::PreimageCall::note_preimage { bytes },
        ))
      }
      #[doc = "Register a preimage on-chain."]
      #[doc = ""]
      #[doc = "If the preimage was previously requested, no fees or deposits are taken for providing"]
      #[doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."]
      #[cfg(feature = "ink")]
      pub fn note_preimage(&self, bytes: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![48u8, 0u8];
        bytes.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Clear an unrequested preimage from the runtime storage."]
      #[doc = ""]
      #[doc = "If `len` is provided, then it will be a much cheaper operation."]
      #[doc = ""]
      #[doc = "- `hash`: The hash of the preimage to be removed from the store."]
      #[doc = "- `len`: The length of the preimage of `hash`."]
      #[cfg(not(feature = "ink"))]
      pub fn unnote_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Preimage(
          types::pallet_preimage::pallet::PreimageCall::unnote_preimage { hash },
        ))
      }
      #[doc = "Clear an unrequested preimage from the runtime storage."]
      #[doc = ""]
      #[doc = "If `len` is provided, then it will be a much cheaper operation."]
      #[doc = ""]
      #[doc = "- `hash`: The hash of the preimage to be removed from the store."]
      #[doc = "- `len`: The length of the preimage of `hash`."]
      #[cfg(feature = "ink")]
      pub fn unnote_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![48u8, 1u8];
        hash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."]
      #[doc = ""]
      #[doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"]
      #[doc = "a user may have paid, and take the control of the preimage out of their hands."]
      #[cfg(not(feature = "ink"))]
      pub fn request_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Preimage(
          types::pallet_preimage::pallet::PreimageCall::request_preimage { hash },
        ))
      }
      #[doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."]
      #[doc = ""]
      #[doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"]
      #[doc = "a user may have paid, and take the control of the preimage out of their hands."]
      #[cfg(feature = "ink")]
      pub fn request_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![48u8, 2u8];
        hash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Clear a previously made request for a preimage."]
      #[doc = ""]
      #[doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."]
      #[cfg(not(feature = "ink"))]
      pub fn unrequest_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Preimage(
          types::pallet_preimage::pallet::PreimageCall::unrequest_preimage { hash },
        ))
      }
      #[doc = "Clear a previously made request for a preimage."]
      #[doc = ""]
      #[doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."]
      #[cfg(feature = "ink")]
      pub fn unrequest_preimage(
        &self,
        hash: types::primitive_types::H256,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![48u8, 3u8];
        hash.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for PreimageCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct PreimageQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> PreimageQueryApi<'api> {
      #[doc = " The request status of a given hash."]
      #[cfg(not(feature = "ink"))]
      pub async fn status_for(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_client::error::Result<
        Option<types::pallet_preimage::RequestStatus<::polymesh_api_client::AccountId, u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8, 70u8, 86u8,
          164u8, 72u8, 37u8, 85u8, 177u8, 174u8, 142u8, 206u8, 213u8, 82u8, 47u8, 60u8, 64u8, 73u8,
          188u8, 132u8, 237u8, 164u8, 168u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[doc = " The request status of a given hash."]
      #[cfg(feature = "ink")]
      pub fn status_for(
        &self,
        key_0: types::primitive_types::H256,
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::pallet_preimage::RequestStatus<::polymesh_api_client::AccountId, u128>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8, 70u8, 86u8,
          164u8, 72u8, 37u8, 85u8, 177u8, 174u8, 142u8, 206u8, 213u8, 82u8, 47u8, 60u8, 64u8, 73u8,
          188u8, 132u8, 237u8, 164u8, 168u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
      #[cfg(not(feature = "ink"))]
      pub async fn preimage_for(
        &self,
        key_0: (types::primitive_types::H256, u32),
      ) -> ::polymesh_api_client::error::Result<
        Option<types::bounded_collections::bounded_vec::BoundedVec<u8>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8, 70u8, 86u8,
          164u8, 72u8, 37u8, 124u8, 125u8, 218u8, 133u8, 201u8, 194u8, 151u8, 153u8, 159u8, 208u8,
          34u8, 21u8, 232u8, 200u8, 249u8, 222u8,
        ]);
        buf.extend(key_0.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value)
      }
      #[cfg(feature = "ink")]
      pub fn preimage_for(
        &self,
        key_0: (types::primitive_types::H256, u32),
      ) -> ::polymesh_api_ink::error::Result<
        Option<types::bounded_collections::bounded_vec::BoundedVec<u8>>,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8, 70u8, 86u8,
          164u8, 72u8, 37u8, 124u8, 125u8, 218u8, 133u8, 201u8, 194u8, 151u8, 153u8, 159u8, 208u8,
          34u8, 21u8, 232u8, 200u8, 249u8, 222u8,
        ]);
        buf.extend(key_0.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value)
      }
    }
  }
  pub mod nft {
    use super::*;
    #[derive(Clone)]
    pub struct NftCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> NftCallApi<'api> {
      #[doc = "Cretes a new `NFTCollection`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `ticker` - the ticker associated to the new collection."]
      #[doc = "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type."]
      #[doc = "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionAlredyRegistered` - if the ticker is already associated to an NFT collection."]
      #[doc = "- `InvalidAssetType` - if the associated asset is not of type NFT."]
      #[doc = "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed."]
      #[doc = "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(not(feature = "ink"))]
      pub fn create_nft_collection(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        nft_type: Option<types::polymesh_primitives::asset::NonFungibleType>,
        collection_keys: types::polymesh_primitives::nft::NFTCollectionKeys,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Nft(
          types::pallet_nft::NftCall::create_nft_collection {
            ticker,
            nft_type,
            collection_keys,
          },
        ))
      }
      #[doc = "Cretes a new `NFTCollection`."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
      #[doc = "* `ticker` - the ticker associated to the new collection."]
      #[doc = "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type."]
      #[doc = "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionAlredyRegistered` - if the ticker is already associated to an NFT collection."]
      #[doc = "- `InvalidAssetType` - if the associated asset is not of type NFT."]
      #[doc = "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed."]
      #[doc = "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[cfg(feature = "ink")]
      pub fn create_nft_collection(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        nft_type: Option<types::polymesh_primitives::asset::NonFungibleType>,
        collection_keys: types::polymesh_primitives::nft::NFTCollectionKeys,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![49u8, 0u8];
        ticker.encode_to(&mut buf);
        nft_type.encode_to(&mut buf);
        collection_keys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Issues an NFT to the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the NFT collection."]
      #[doc = "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT."]
      #[doc = "- `portfolio_kind` - the portfolio that will receive the minted nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given ticker has not been created."]
      #[doc = "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn issue_nft(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        nft_metadata_attributes: ::alloc::vec::Vec<
          types::polymesh_primitives::nft::NFTMetadataAttribute,
        >,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Nft(
          types::pallet_nft::NftCall::issue_nft {
            ticker,
            nft_metadata_attributes,
            portfolio_kind,
          },
        ))
      }
      #[doc = "Issues an NFT to the caller."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the NFT collection."]
      #[doc = "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT."]
      #[doc = "- `portfolio_kind` - the portfolio that will receive the minted nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given ticker has not been created."]
      #[doc = "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection."]
      #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
      #[doc = ""]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn issue_nft(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        nft_metadata_attributes: ::alloc::vec::Vec<
          types::polymesh_primitives::nft::NFTMetadataAttribute,
        >,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![49u8, 1u8];
        ticker.encode_to(&mut buf);
        nft_metadata_attributes.encode_to(&mut buf);
        portfolio_kind.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Redeems the given NFT from the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the NFT collection."]
      #[doc = "* `nft_id` - the id of the NFT to be burned."]
      #[doc = "* `portfolio_kind` - the portfolio that contains the nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given ticker has not been created."]
      #[doc = "- `NFTNotFound` - if the given NFT does not exist in the portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(not(feature = "ink"))]
      pub fn redeem_nft(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        nft_id: types::polymesh_primitives::nft::NFTId,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::Nft(
          types::pallet_nft::NftCall::redeem_nft {
            ticker,
            nft_id,
            portfolio_kind,
          },
        ))
      }
      #[doc = "Redeems the given NFT from the caller's portfolio."]
      #[doc = ""]
      #[doc = "# Arguments"]
      #[doc = "* `origin` - is a signer that has permissions to act as an agent of `ticker`."]
      #[doc = "* `ticker` - the ticker of the NFT collection."]
      #[doc = "* `nft_id` - the id of the NFT to be burned."]
      #[doc = "* `portfolio_kind` - the portfolio that contains the nft."]
      #[doc = ""]
      #[doc = "## Errors"]
      #[doc = "- `CollectionNotFound` - if the collection associated to the given ticker has not been created."]
      #[doc = "- `NFTNotFound` - if the given NFT does not exist in the portfolio."]
      #[doc = ""]
      #[doc = "# Permissions"]
      #[doc = "* Asset"]
      #[doc = "* Portfolio"]
      #[cfg(feature = "ink")]
      pub fn redeem_nft(
        &self,
        ticker: types::polymesh_primitives::ticker::Ticker,
        nft_id: types::polymesh_primitives::nft::NFTId,
        portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![49u8, 2u8];
        ticker.encode_to(&mut buf);
        nft_id.encode_to(&mut buf);
        portfolio_kind.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for NftCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct NftQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> NftQueryApi<'api> {
      #[doc = " The total number of NFTs per identity."]
      #[cfg(not(feature = "ink"))]
      pub async fn number_of_nf_ts(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_client::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 170u8, 210u8, 252u8, 218u8, 7u8, 81u8, 234u8, 12u8, 131u8, 54u8,
          33u8, 16u8, 193u8, 164u8, 16u8, 164u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The total number of NFTs per identity."]
      #[cfg(feature = "ink")]
      pub fn number_of_nf_ts(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
        key_1: ::polymesh_api_client::IdentityId,
      ) -> ::polymesh_api_ink::error::Result<u64> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 170u8, 210u8, 252u8, 218u8, 7u8, 81u8, 234u8, 12u8, 131u8, 54u8,
          33u8, 16u8, 193u8, 164u8, 16u8, 164u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        buf.extend(key_1.encode());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <u64>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The collection id corresponding to each ticker."]
      #[cfg(not(feature = "ink"))]
      pub async fn collection_ticker(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::nft::NFTCollectionId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 131u8, 57u8, 210u8, 55u8, 119u8, 235u8, 205u8, 25u8, 26u8, 151u8,
          89u8, 120u8, 28u8, 190u8, 120u8, 183u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::nft::NFTCollectionId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The collection id corresponding to each ticker."]
      #[cfg(feature = "ink")]
      pub fn collection_ticker(
        &self,
        key_0: types::polymesh_primitives::ticker::Ticker,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::nft::NFTCollectionId>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 131u8, 57u8, 210u8, 55u8, 119u8, 235u8, 205u8, 25u8, 26u8, 151u8,
          89u8, 120u8, 28u8, 190u8, 120u8, 183u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::nft::NFTCollectionId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All collection details for a given collection id."]
      #[cfg(not(feature = "ink"))]
      pub async fn collection(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::nft::NFTCollection>
      {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 55u8, 92u8, 77u8, 37u8, 190u8, 245u8, 30u8, 47u8, 50u8, 254u8,
          233u8, 252u8, 85u8, 123u8, 24u8, 32u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::nft::NFTCollection>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All collection details for a given collection id."]
      #[cfg(feature = "ink")]
      pub fn collection(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::nft::NFTCollection> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 55u8, 92u8, 77u8, 37u8, 190u8, 245u8, 30u8, 47u8, 50u8, 254u8,
          233u8, 252u8, 85u8, 123u8, 24u8, 32u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8,
          ];
          <types::polymesh_primitives::nft::NFTCollection>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " All mandatory metadata keys for a given collection."]
      #[cfg(not(feature = "ink"))]
      pub async fn collection_keys(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_client::error::Result<
        ::alloc::collections::BTreeSet<
          types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 240u8, 0u8, 218u8, 102u8, 211u8, 19u8, 174u8, 223u8, 42u8, 70u8,
          29u8, 80u8, 78u8, 220u8, 122u8, 141u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::collections::BTreeSet<
            types::polymesh_primitives::asset_metadata::AssetMetadataKey,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " All mandatory metadata keys for a given collection."]
      #[cfg(feature = "ink")]
      pub fn collection_keys(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_ink::error::Result<
        ::alloc::collections::BTreeSet<
          types::polymesh_primitives::asset_metadata::AssetMetadataKey,
        >,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 240u8, 0u8, 218u8, 102u8, 211u8, 19u8, 174u8, 223u8, 42u8, 70u8,
          29u8, 80u8, 78u8, 220u8, 122u8, 141u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <::alloc::collections::BTreeSet<
            types::polymesh_primitives::asset_metadata::AssetMetadataKey,
          >>::decode(&mut &DEFAULT[..])
          .unwrap()
        }))
      }
      #[doc = " The metadata value of an nft given its collection id, token id and metadata key."]
      #[cfg(not(feature = "ink"))]
      pub async fn metadata_value(
        &self,
        key_0: (
          types::polymesh_primitives::nft::NFTCollectionId,
          types::polymesh_primitives::nft::NFTId,
        ),
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_client::error::Result<
        types::polymesh_primitives::asset_metadata::AssetMetadataValue,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 60u8, 250u8, 177u8, 34u8, 185u8, 246u8, 58u8, 62u8, 106u8, 129u8,
          169u8, 121u8, 18u8, 218u8, 95u8, 196u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::asset_metadata::AssetMetadataValue>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The metadata value of an nft given its collection id, token id and metadata key."]
      #[cfg(feature = "ink")]
      pub fn metadata_value(
        &self,
        key_0: (
          types::polymesh_primitives::nft::NFTCollectionId,
          types::polymesh_primitives::nft::NFTId,
        ),
        key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
      ) -> ::polymesh_api_ink::error::Result<
        types::polymesh_primitives::asset_metadata::AssetMetadataValue,
      > {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 60u8, 250u8, 177u8, 34u8, 185u8, 246u8, 58u8, 62u8, 106u8, 129u8,
          169u8, 121u8, 18u8, 218u8, 95u8, 196u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = key_1.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8];
          <types::polymesh_primitives::asset_metadata::AssetMetadataValue>::decode(
            &mut &DEFAULT[..],
          )
          .unwrap()
        }))
      }
      #[doc = " The next available id for an NFT collection."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_collection_id(
        &self,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::nft::NFTCollectionId>
      {
        let key = ::polymesh_api_client::StorageKey(::alloc::vec![
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 149u8, 172u8, 138u8, 234u8, 62u8, 93u8, 118u8, 128u8, 201u8, 1u8,
          27u8, 158u8, 32u8, 227u8, 72u8, 228u8,
        ]);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::nft::NFTCollectionId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next available id for an NFT collection."]
      #[cfg(feature = "ink")]
      pub fn next_collection_id(
        &self,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::nft::NFTCollectionId>
      {
        let value = self.api.read_storage(::alloc::vec![
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 149u8, 172u8, 138u8, 234u8, 62u8, 93u8, 118u8, 128u8, 201u8, 1u8,
          27u8, 158u8, 32u8, 227u8, 72u8, 228u8,
        ])?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::nft::NFTCollectionId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next available id for an NFT within a collection."]
      #[cfg(not(feature = "ink"))]
      pub async fn next_nft_id(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::nft::NFTId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 51u8, 137u8, 245u8, 130u8, 181u8, 39u8, 234u8, 26u8, 231u8, 83u8,
          241u8, 203u8, 201u8, 141u8, 69u8, 153u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let key = ::polymesh_api_client::StorageKey(buf);
        let value = self.api.client.get_storage_by_key(key, self.at).await?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::nft::NFTId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
      #[doc = " The next available id for an NFT within a collection."]
      #[cfg(feature = "ink")]
      pub fn next_nft_id(
        &self,
        key_0: types::polymesh_primitives::nft::NFTCollectionId,
      ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::nft::NFTId> {
        use ::codec::Encode;
        let mut buf = ::alloc::vec::Vec::with_capacity(512);
        buf.extend([
          138u8, 16u8, 110u8, 54u8, 232u8, 186u8, 99u8, 223u8, 18u8, 145u8, 157u8, 128u8, 58u8,
          111u8, 214u8, 118u8, 51u8, 137u8, 245u8, 130u8, 181u8, 39u8, 234u8, 26u8, 231u8, 83u8,
          241u8, 203u8, 201u8, 141u8, 69u8, 153u8,
        ]);
        let key = key_0.encode();
        buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
        buf.extend(key.into_iter());
        let value = self.api.read_storage(buf)?;
        Ok(value.unwrap_or_else(|| {
          use ::codec::Decode;
          const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
          <types::polymesh_primitives::nft::NFTId>::decode(&mut &DEFAULT[..]).unwrap()
        }))
      }
    }
  }
  pub mod test_utils {
    use super::*;
    #[derive(Clone)]
    pub struct TestUtilsCallApi<'api> {
      api: &'api super::super::Api,
    }
    impl<'api> TestUtilsCallApi<'api> {
      #[doc = "Generates a new `IdentityID` for the caller, and issues a self-generated CDD claim."]
      #[doc = ""]
      #[doc = "The caller account will be the primary key of that identity."]
      #[doc = "For each account of `secondary_keys`, a new `JoinIdentity` authorization is created, so"]
      #[doc = "each of them will need to accept it before become part of this new `IdentityID`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AlreadyLinked` if the caller account or if any of the given `secondary_keys` has already linked to an `IdentityID`"]
      #[doc = "- `SecondaryKeysContainPrimaryKey` if `secondary_keys` contains the caller account."]
      #[doc = "- `DidAlreadyExists` if auto-generated DID already exists."]
      #[cfg(not(feature = "ink"))]
      pub fn register_did(
        &self,
        secondary_keys: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TestUtils(
          types::pallet_test_utils::TestUtilsCall::register_did { secondary_keys },
        ))
      }
      #[doc = "Generates a new `IdentityID` for the caller, and issues a self-generated CDD claim."]
      #[doc = ""]
      #[doc = "The caller account will be the primary key of that identity."]
      #[doc = "For each account of `secondary_keys`, a new `JoinIdentity` authorization is created, so"]
      #[doc = "each of them will need to accept it before become part of this new `IdentityID`."]
      #[doc = ""]
      #[doc = "# Errors"]
      #[doc = "- `AlreadyLinked` if the caller account or if any of the given `secondary_keys` has already linked to an `IdentityID`"]
      #[doc = "- `SecondaryKeysContainPrimaryKey` if `secondary_keys` contains the caller account."]
      #[doc = "- `DidAlreadyExists` if auto-generated DID already exists."]
      #[cfg(feature = "ink")]
      pub fn register_did(
        &self,
        secondary_keys: ::alloc::vec::Vec<
          types::polymesh_primitives::secondary_key::SecondaryKey<::polymesh_api_client::AccountId>,
        >,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![50u8, 0u8];
        secondary_keys.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Registers a new Identity for the `target_account` and issues a CDD claim to it."]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be an active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[cfg(not(feature = "ink"))]
      pub fn mock_cdd_register_did(
        &self,
        target_account: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TestUtils(
          types::pallet_test_utils::TestUtilsCall::mock_cdd_register_did { target_account },
        ))
      }
      #[doc = "Registers a new Identity for the `target_account` and issues a CDD claim to it."]
      #[doc = ""]
      #[doc = "# Failure"]
      #[doc = "- `origin` has to be an active CDD provider. Inactive CDD providers cannot add new"]
      #[doc = "claims."]
      #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
      #[doc = "one identity."]
      #[cfg(feature = "ink")]
      pub fn mock_cdd_register_did(
        &self,
        target_account: ::polymesh_api_client::AccountId,
      ) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![50u8, 1u8];
        target_account.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
      #[doc = "Emits an event with caller's identity."]
      #[cfg(not(feature = "ink"))]
      pub fn get_my_did(&self) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TestUtils(
          types::pallet_test_utils::TestUtilsCall::get_my_did,
        ))
      }
      #[doc = "Emits an event with caller's identity."]
      #[cfg(feature = "ink")]
      pub fn get_my_did(&self) -> super::super::WrappedCall {
        self.api.wrap_call(::alloc::vec![50u8, 2u8])
      }
      #[doc = "Emits an event with caller's identity and CDD status."]
      #[cfg(not(feature = "ink"))]
      pub fn get_cdd_of(
        &self,
        of: ::polymesh_api_client::AccountId,
      ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
        self.api.wrap_call(runtime::RuntimeCall::TestUtils(
          types::pallet_test_utils::TestUtilsCall::get_cdd_of { of },
        ))
      }
      #[doc = "Emits an event with caller's identity and CDD status."]
      #[cfg(feature = "ink")]
      pub fn get_cdd_of(&self, of: ::polymesh_api_client::AccountId) -> super::super::WrappedCall {
        use ::codec::Encode;
        let mut buf = ::alloc::vec![50u8, 3u8];
        of.encode_to(&mut buf);
        self.api.wrap_call(buf)
      }
    }
    impl<'api> From<&'api super::super::Api> for TestUtilsCallApi<'api> {
      fn from(api: &'api super::super::Api) -> Self {
        Self { api }
      }
    }
    #[derive(Clone)]
    pub struct TestUtilsQueryApi<'api> {
      pub(crate) api: &'api super::super::Api,
      #[cfg(not(feature = "ink"))]
      pub(crate) at: Option<::polymesh_api_client::BlockHash>,
    }
    impl<'api> TestUtilsQueryApi<'api> {}
  }
}
#[derive(Clone)]
pub struct Api {
  #[cfg(not(feature = "ink"))]
  client: ::polymesh_api_client::Client,
}
impl Api {
  #[cfg(feature = "ink")]
  pub fn new() -> Self {
    Self {}
  }
  #[cfg(feature = "ink")]
  pub fn runtime(&self) -> ::polymesh_api_ink::extension::PolymeshRuntimeInstance {
    ::polymesh_api_ink::extension::new_instance()
  }
  #[cfg(feature = "ink")]
  pub fn read_storage<T: ::codec::Decode>(
    &self,
    key: ::alloc::vec::Vec<u8>,
  ) -> ::polymesh_api_ink::error::Result<Option<T>> {
    let runtime = self.runtime();
    let value = runtime
      .read_storage(key.into())?
      .map(|data| T::decode(&mut data.as_slice()))
      .transpose()?;
    Ok(value)
  }
  #[cfg(not(feature = "ink"))]
  pub async fn new(url: &str) -> ::polymesh_api_client::error::Result<Self> {
    Ok(Self {
      client: ::polymesh_api_client::Client::new(url).await?,
    })
  }
  pub fn call(&self) -> CallApi {
    CallApi { api: self }
  }
  #[cfg(not(feature = "ink"))]
  pub fn query(&self) -> QueryApi {
    QueryApi {
      api: self,
      at: None,
    }
  }
  #[cfg(feature = "ink")]
  pub fn query(&self) -> QueryApi {
    QueryApi { api: self }
  }
  #[cfg(not(feature = "ink"))]
  pub fn query_at(&self, block: ::polymesh_api_client::BlockHash) -> QueryApi {
    QueryApi {
      api: self,
      at: Some(block),
    }
  }
  #[cfg(not(feature = "ink"))]
  pub fn wrap_call(
    &self,
    call: types::runtime::RuntimeCall,
  ) -> ::polymesh_api_client::Result<WrappedCall> {
    Ok(WrappedCall::new(self, call))
  }
  #[cfg(feature = "ink")]
  pub fn wrap_call(&self, call: ::alloc::vec::Vec<u8>) -> WrappedCall {
    WrappedCall::new(call)
  }
}
#[cfg(not(feature = "ink"))]
use alloc::boxed::Box;
#[async_trait::async_trait]
#[cfg(not(feature = "ink"))]
impl ::polymesh_api_client::ChainApi for Api {
  type RuntimeCall = types::runtime::RuntimeCall;
  type RuntimeEvent = types::runtime::RuntimeEvent;
  type DispatchInfo = types::frame_support::dispatch::DispatchInfo;
  type DispatchError = types::sp_runtime::DispatchError;
  async fn get_nonce(
    &self,
    account: ::polymesh_api_client::AccountId,
  ) -> ::polymesh_api_client::Result<u32> {
    let info = self.query().system().account(account).await?;
    Ok(info.nonce)
  }
  async fn block_events(
    &self,
    block: Option<::polymesh_api_client::BlockHash>,
  ) -> ::polymesh_api_client::Result<
    ::alloc::vec::Vec<::polymesh_api_client::EventRecord<Self::RuntimeEvent>>,
  > {
    let system = match block {
      Some(block) => self.query_at(block).system(),
      None => self.query().system(),
    };
    Ok(system.events().await?)
  }
  fn event_to_extrinsic_result(
    event: &::polymesh_api_client::EventRecord<Self::RuntimeEvent>,
  ) -> Option<::polymesh_api_client::ExtrinsicResult<Self>> {
    match &event.event {
      types::runtime::RuntimeEvent::System(
        types::frame_system::pallet::SystemEvent::ExtrinsicSuccess { dispatch_info },
      ) => Some(::polymesh_api_client::ExtrinsicResult::Success(
        dispatch_info.clone(),
      )),
      types::runtime::RuntimeEvent::System(
        types::frame_system::pallet::SystemEvent::ExtrinsicFailed {
          dispatch_info,
          dispatch_error,
        },
      ) => Some(::polymesh_api_client::ExtrinsicResult::Failed(
        dispatch_info.clone(),
        dispatch_error.clone(),
      )),
      _ => None,
    }
  }
  fn client(&self) -> &::polymesh_api_client::Client {
    &self.client
  }
}
#[derive(Clone)]
pub struct CallApi<'api> {
  api: &'api Api,
}
impl<'api> CallApi<'api> {
  pub fn system(&self) -> api::system::SystemCallApi<'api> {
    api::system::SystemCallApi::from(self.api)
  }
  pub fn babe(&self) -> api::babe::BabeCallApi<'api> {
    api::babe::BabeCallApi::from(self.api)
  }
  pub fn timestamp(&self) -> api::timestamp::TimestampCallApi<'api> {
    api::timestamp::TimestampCallApi::from(self.api)
  }
  pub fn indices(&self) -> api::indices::IndicesCallApi<'api> {
    api::indices::IndicesCallApi::from(self.api)
  }
  pub fn authorship(&self) -> api::authorship::AuthorshipCallApi<'api> {
    api::authorship::AuthorshipCallApi::from(self.api)
  }
  pub fn balances(&self) -> api::balances::BalancesCallApi<'api> {
    api::balances::BalancesCallApi::from(self.api)
  }
  pub fn transaction_payment(&self) -> api::transaction_payment::TransactionPaymentCallApi<'api> {
    api::transaction_payment::TransactionPaymentCallApi::from(self.api)
  }
  pub fn identity(&self) -> api::identity::IdentityCallApi<'api> {
    api::identity::IdentityCallApi::from(self.api)
  }
  pub fn cdd_service_providers(
    &self,
  ) -> api::cdd_service_providers::CddServiceProvidersCallApi<'api> {
    api::cdd_service_providers::CddServiceProvidersCallApi::from(self.api)
  }
  pub fn polymesh_committee(&self) -> api::polymesh_committee::PolymeshCommitteeCallApi<'api> {
    api::polymesh_committee::PolymeshCommitteeCallApi::from(self.api)
  }
  pub fn committee_membership(
    &self,
  ) -> api::committee_membership::CommitteeMembershipCallApi<'api> {
    api::committee_membership::CommitteeMembershipCallApi::from(self.api)
  }
  pub fn technical_committee(&self) -> api::technical_committee::TechnicalCommitteeCallApi<'api> {
    api::technical_committee::TechnicalCommitteeCallApi::from(self.api)
  }
  pub fn technical_committee_membership(
    &self,
  ) -> api::technical_committee_membership::TechnicalCommitteeMembershipCallApi<'api> {
    api::technical_committee_membership::TechnicalCommitteeMembershipCallApi::from(self.api)
  }
  pub fn upgrade_committee(&self) -> api::upgrade_committee::UpgradeCommitteeCallApi<'api> {
    api::upgrade_committee::UpgradeCommitteeCallApi::from(self.api)
  }
  pub fn upgrade_committee_membership(
    &self,
  ) -> api::upgrade_committee_membership::UpgradeCommitteeMembershipCallApi<'api> {
    api::upgrade_committee_membership::UpgradeCommitteeMembershipCallApi::from(self.api)
  }
  pub fn multi_sig(&self) -> api::multi_sig::MultiSigCallApi<'api> {
    api::multi_sig::MultiSigCallApi::from(self.api)
  }
  pub fn bridge(&self) -> api::bridge::BridgeCallApi<'api> {
    api::bridge::BridgeCallApi::from(self.api)
  }
  pub fn staking(&self) -> api::staking::StakingCallApi<'api> {
    api::staking::StakingCallApi::from(self.api)
  }
  pub fn offences(&self) -> api::offences::OffencesCallApi<'api> {
    api::offences::OffencesCallApi::from(self.api)
  }
  pub fn session(&self) -> api::session::SessionCallApi<'api> {
    api::session::SessionCallApi::from(self.api)
  }
  pub fn authority_discovery(&self) -> api::authority_discovery::AuthorityDiscoveryCallApi<'api> {
    api::authority_discovery::AuthorityDiscoveryCallApi::from(self.api)
  }
  pub fn grandpa(&self) -> api::grandpa::GrandpaCallApi<'api> {
    api::grandpa::GrandpaCallApi::from(self.api)
  }
  pub fn historical(&self) -> api::historical::HistoricalCallApi<'api> {
    api::historical::HistoricalCallApi::from(self.api)
  }
  pub fn im_online(&self) -> api::im_online::ImOnlineCallApi<'api> {
    api::im_online::ImOnlineCallApi::from(self.api)
  }
  pub fn randomness_collective_flip(
    &self,
  ) -> api::randomness_collective_flip::RandomnessCollectiveFlipCallApi<'api> {
    api::randomness_collective_flip::RandomnessCollectiveFlipCallApi::from(self.api)
  }
  pub fn sudo(&self) -> api::sudo::SudoCallApi<'api> {
    api::sudo::SudoCallApi::from(self.api)
  }
  pub fn asset(&self) -> api::asset::AssetCallApi<'api> {
    api::asset::AssetCallApi::from(self.api)
  }
  pub fn capital_distribution(
    &self,
  ) -> api::capital_distribution::CapitalDistributionCallApi<'api> {
    api::capital_distribution::CapitalDistributionCallApi::from(self.api)
  }
  pub fn checkpoint(&self) -> api::checkpoint::CheckpointCallApi<'api> {
    api::checkpoint::CheckpointCallApi::from(self.api)
  }
  pub fn compliance_manager(&self) -> api::compliance_manager::ComplianceManagerCallApi<'api> {
    api::compliance_manager::ComplianceManagerCallApi::from(self.api)
  }
  pub fn corporate_action(&self) -> api::corporate_action::CorporateActionCallApi<'api> {
    api::corporate_action::CorporateActionCallApi::from(self.api)
  }
  pub fn corporate_ballot(&self) -> api::corporate_ballot::CorporateBallotCallApi<'api> {
    api::corporate_ballot::CorporateBallotCallApi::from(self.api)
  }
  pub fn permissions(&self) -> api::permissions::PermissionsCallApi<'api> {
    api::permissions::PermissionsCallApi::from(self.api)
  }
  pub fn pips(&self) -> api::pips::PipsCallApi<'api> {
    api::pips::PipsCallApi::from(self.api)
  }
  pub fn portfolio(&self) -> api::portfolio::PortfolioCallApi<'api> {
    api::portfolio::PortfolioCallApi::from(self.api)
  }
  pub fn protocol_fee(&self) -> api::protocol_fee::ProtocolFeeCallApi<'api> {
    api::protocol_fee::ProtocolFeeCallApi::from(self.api)
  }
  pub fn scheduler(&self) -> api::scheduler::SchedulerCallApi<'api> {
    api::scheduler::SchedulerCallApi::from(self.api)
  }
  pub fn settlement(&self) -> api::settlement::SettlementCallApi<'api> {
    api::settlement::SettlementCallApi::from(self.api)
  }
  pub fn statistics(&self) -> api::statistics::StatisticsCallApi<'api> {
    api::statistics::StatisticsCallApi::from(self.api)
  }
  pub fn sto(&self) -> api::sto::StoCallApi<'api> {
    api::sto::StoCallApi::from(self.api)
  }
  pub fn treasury(&self) -> api::treasury::TreasuryCallApi<'api> {
    api::treasury::TreasuryCallApi::from(self.api)
  }
  pub fn utility(&self) -> api::utility::UtilityCallApi<'api> {
    api::utility::UtilityCallApi::from(self.api)
  }
  pub fn base(&self) -> api::base::BaseCallApi<'api> {
    api::base::BaseCallApi::from(self.api)
  }
  pub fn external_agents(&self) -> api::external_agents::ExternalAgentsCallApi<'api> {
    api::external_agents::ExternalAgentsCallApi::from(self.api)
  }
  pub fn relayer(&self) -> api::relayer::RelayerCallApi<'api> {
    api::relayer::RelayerCallApi::from(self.api)
  }
  pub fn contracts(&self) -> api::contracts::ContractsCallApi<'api> {
    api::contracts::ContractsCallApi::from(self.api)
  }
  pub fn polymesh_contracts(&self) -> api::polymesh_contracts::PolymeshContractsCallApi<'api> {
    api::polymesh_contracts::PolymeshContractsCallApi::from(self.api)
  }
  pub fn preimage(&self) -> api::preimage::PreimageCallApi<'api> {
    api::preimage::PreimageCallApi::from(self.api)
  }
  pub fn nft(&self) -> api::nft::NftCallApi<'api> {
    api::nft::NftCallApi::from(self.api)
  }
  pub fn test_utils(&self) -> api::test_utils::TestUtilsCallApi<'api> {
    api::test_utils::TestUtilsCallApi::from(self.api)
  }
}
#[cfg(not(feature = "ink"))]
pub type WrappedCall = ::polymesh_api_client::Call<Api>;
#[cfg(not(feature = "ink"))]
pub type TransactionResults = ::polymesh_api_client::TransactionResults<Api>;
#[cfg(feature = "ink")]
pub type WrappedCall = ::polymesh_api_ink::Call;
#[cfg(not(feature = "ink"))]
impl From<WrappedCall> for types::runtime::RuntimeCall {
  fn from(wrapped: WrappedCall) -> Self {
    wrapped.into_runtime_call()
  }
}
#[cfg(not(feature = "ink"))]
impl From<&WrappedCall> for types::runtime::RuntimeCall {
  fn from(wrapped: &WrappedCall) -> Self {
    wrapped.runtime_call().clone()
  }
}
#[derive(Clone)]
pub struct QueryApi<'api> {
  api: &'api Api,
  #[cfg(not(feature = "ink"))]
  at: Option<::polymesh_api_client::BlockHash>,
}
impl<'api> QueryApi<'api> {
  pub fn system(&self) -> api::system::SystemQueryApi<'api> {
    api::system::SystemQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn babe(&self) -> api::babe::BabeQueryApi<'api> {
    api::babe::BabeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn timestamp(&self) -> api::timestamp::TimestampQueryApi<'api> {
    api::timestamp::TimestampQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn indices(&self) -> api::indices::IndicesQueryApi<'api> {
    api::indices::IndicesQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn authorship(&self) -> api::authorship::AuthorshipQueryApi<'api> {
    api::authorship::AuthorshipQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn balances(&self) -> api::balances::BalancesQueryApi<'api> {
    api::balances::BalancesQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn transaction_payment(&self) -> api::transaction_payment::TransactionPaymentQueryApi<'api> {
    api::transaction_payment::TransactionPaymentQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn identity(&self) -> api::identity::IdentityQueryApi<'api> {
    api::identity::IdentityQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn cdd_service_providers(
    &self,
  ) -> api::cdd_service_providers::CddServiceProvidersQueryApi<'api> {
    api::cdd_service_providers::CddServiceProvidersQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn polymesh_committee(&self) -> api::polymesh_committee::PolymeshCommitteeQueryApi<'api> {
    api::polymesh_committee::PolymeshCommitteeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn committee_membership(
    &self,
  ) -> api::committee_membership::CommitteeMembershipQueryApi<'api> {
    api::committee_membership::CommitteeMembershipQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn technical_committee(&self) -> api::technical_committee::TechnicalCommitteeQueryApi<'api> {
    api::technical_committee::TechnicalCommitteeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn technical_committee_membership(
    &self,
  ) -> api::technical_committee_membership::TechnicalCommitteeMembershipQueryApi<'api> {
    api::technical_committee_membership::TechnicalCommitteeMembershipQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn upgrade_committee(&self) -> api::upgrade_committee::UpgradeCommitteeQueryApi<'api> {
    api::upgrade_committee::UpgradeCommitteeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn upgrade_committee_membership(
    &self,
  ) -> api::upgrade_committee_membership::UpgradeCommitteeMembershipQueryApi<'api> {
    api::upgrade_committee_membership::UpgradeCommitteeMembershipQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn multi_sig(&self) -> api::multi_sig::MultiSigQueryApi<'api> {
    api::multi_sig::MultiSigQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn bridge(&self) -> api::bridge::BridgeQueryApi<'api> {
    api::bridge::BridgeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn staking(&self) -> api::staking::StakingQueryApi<'api> {
    api::staking::StakingQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn offences(&self) -> api::offences::OffencesQueryApi<'api> {
    api::offences::OffencesQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn session(&self) -> api::session::SessionQueryApi<'api> {
    api::session::SessionQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn authority_discovery(&self) -> api::authority_discovery::AuthorityDiscoveryQueryApi<'api> {
    api::authority_discovery::AuthorityDiscoveryQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn grandpa(&self) -> api::grandpa::GrandpaQueryApi<'api> {
    api::grandpa::GrandpaQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn historical(&self) -> api::historical::HistoricalQueryApi<'api> {
    api::historical::HistoricalQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn im_online(&self) -> api::im_online::ImOnlineQueryApi<'api> {
    api::im_online::ImOnlineQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn randomness_collective_flip(
    &self,
  ) -> api::randomness_collective_flip::RandomnessCollectiveFlipQueryApi<'api> {
    api::randomness_collective_flip::RandomnessCollectiveFlipQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn sudo(&self) -> api::sudo::SudoQueryApi<'api> {
    api::sudo::SudoQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn asset(&self) -> api::asset::AssetQueryApi<'api> {
    api::asset::AssetQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn capital_distribution(
    &self,
  ) -> api::capital_distribution::CapitalDistributionQueryApi<'api> {
    api::capital_distribution::CapitalDistributionQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn checkpoint(&self) -> api::checkpoint::CheckpointQueryApi<'api> {
    api::checkpoint::CheckpointQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn compliance_manager(&self) -> api::compliance_manager::ComplianceManagerQueryApi<'api> {
    api::compliance_manager::ComplianceManagerQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn corporate_action(&self) -> api::corporate_action::CorporateActionQueryApi<'api> {
    api::corporate_action::CorporateActionQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn corporate_ballot(&self) -> api::corporate_ballot::CorporateBallotQueryApi<'api> {
    api::corporate_ballot::CorporateBallotQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn permissions(&self) -> api::permissions::PermissionsQueryApi<'api> {
    api::permissions::PermissionsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn pips(&self) -> api::pips::PipsQueryApi<'api> {
    api::pips::PipsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn portfolio(&self) -> api::portfolio::PortfolioQueryApi<'api> {
    api::portfolio::PortfolioQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn protocol_fee(&self) -> api::protocol_fee::ProtocolFeeQueryApi<'api> {
    api::protocol_fee::ProtocolFeeQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn scheduler(&self) -> api::scheduler::SchedulerQueryApi<'api> {
    api::scheduler::SchedulerQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn settlement(&self) -> api::settlement::SettlementQueryApi<'api> {
    api::settlement::SettlementQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn statistics(&self) -> api::statistics::StatisticsQueryApi<'api> {
    api::statistics::StatisticsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn sto(&self) -> api::sto::StoQueryApi<'api> {
    api::sto::StoQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn treasury(&self) -> api::treasury::TreasuryQueryApi<'api> {
    api::treasury::TreasuryQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn utility(&self) -> api::utility::UtilityQueryApi<'api> {
    api::utility::UtilityQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn base(&self) -> api::base::BaseQueryApi<'api> {
    api::base::BaseQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn external_agents(&self) -> api::external_agents::ExternalAgentsQueryApi<'api> {
    api::external_agents::ExternalAgentsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn relayer(&self) -> api::relayer::RelayerQueryApi<'api> {
    api::relayer::RelayerQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn contracts(&self) -> api::contracts::ContractsQueryApi<'api> {
    api::contracts::ContractsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn polymesh_contracts(&self) -> api::polymesh_contracts::PolymeshContractsQueryApi<'api> {
    api::polymesh_contracts::PolymeshContractsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn preimage(&self) -> api::preimage::PreimageQueryApi<'api> {
    api::preimage::PreimageQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn nft(&self) -> api::nft::NftQueryApi<'api> {
    api::nft::NftQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
  pub fn test_utils(&self) -> api::test_utils::TestUtilsQueryApi<'api> {
    api::test_utils::TestUtilsQueryApi {
      api: self.api,
      #[cfg(not(feature = "ink"))]
      at: self.at,
    }
  }
}
