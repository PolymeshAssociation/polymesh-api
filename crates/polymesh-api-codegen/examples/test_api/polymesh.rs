#[allow(dead_code, unused_imports, non_camel_case_types)]
pub mod types {
    use super::WrappedCall;
    pub mod finality_grandpa {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Equivocation<Id, V, S> {
            pub round_number: u64,
            pub identity: Id,
            pub first: (V, S),
            pub second: (V, S),
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Precommit<H, N> {
            pub target_hash: H,
            pub target_number: N,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Prevote<H, N> {
            pub target_hash: H,
            pub target_number: N,
        }
    }
    pub mod frame_election_provider_support {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct BoundedSupport<AccountId> {
            pub total: u128,
            pub voters: ::alloc::vec::Vec<(AccountId, u128)>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct BoundedSupports<AccountId>(
            pub  ::alloc::vec::Vec<(
                AccountId,
                frame_election_provider_support::BoundedSupport<AccountId>,
            )>,
        );
    }
    pub mod frame_metadata_hash_extension {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CheckMetadataHash {
            pub mode: frame_metadata_hash_extension::Mode,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Mode {
            #[codec(index = 0u8)]
            Disabled,
            #[codec(index = 1u8)]
            Enabled,
        }
    }
    pub mod frame_support {
        use super::*;
        pub mod dispatch {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum DispatchClass {
                #[codec(index = 0u8)]
                Normal,
                #[codec(index = 1u8)]
                Operational,
                #[codec(index = 2u8)]
                Mandatory,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum Pays {
                #[codec(index = 0u8)]
                Yes,
                #[codec(index = 1u8)]
                No,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PerDispatchClass<T> {
                pub normal: T,
                pub operational: T,
                pub mandatory: T,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum RawOrigin<AccountId> {
                #[codec(index = 0u8)]
                Root,
                #[codec(index = 1u8)]
                Signed(AccountId),
                #[codec(index = 2u8)]
                None,
                #[codec(index = 3u8)]
                Authorized,
            }
        }
        pub mod traits {
            use super::*;
            pub mod preimages {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum Bounded<T, H> {
                    #[codec(index = 0u8)]
                    Legacy {
                        hash: primitive_types::H256,
                    },
                    #[codec(index = 1u8)]
                    Inline(::alloc::vec::Vec<u8>),
                    #[codec(index = 2u8)]
                    Lookup {
                        hash: primitive_types::H256,
                        len: u32,
                    },
                    PhantomDataVariant(core::marker::PhantomData<(T, H)>),
                }
            }
            pub mod tokens {
                use super::*;
                pub mod fungible {
                    use super::*;
                    #[derive(
                        Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode,
                    )]
                    #[cfg_attr(
                        all(feature = "std", feature = "type_info"),
                        derive(::scale_info::TypeInfo)
                    )]
                    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                    pub struct HoldConsideration(pub u128);
                }
                pub mod misc {
                    use super::*;
                    #[derive(
                        Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode,
                    )]
                    #[cfg_attr(
                        all(feature = "std", feature = "type_info"),
                        derive(::scale_info::TypeInfo)
                    )]
                    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                    pub enum BalanceStatus {
                        #[codec(index = 0u8)]
                        Free,
                        #[codec(index = 1u8)]
                        Reserved,
                    }
                    #[derive(
                        Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode,
                    )]
                    #[cfg_attr(
                        all(feature = "std", feature = "type_info"),
                        derive(::scale_info::TypeInfo)
                    )]
                    #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                    pub struct IdAmount<Id, Balance> {
                        pub id: Id,
                        pub amount: Balance,
                    }
                }
            }
        }
    }
    pub mod frame_system {
        use super::*;
        pub mod extensions {
            use super::*;
            pub mod authorize_call {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct AuthorizeCall();
            }
            pub mod check_genesis {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct CheckGenesis();
            }
            pub mod check_mortality {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct CheckMortality(pub ::polymesh_api_client::Era);
            }
            pub mod check_non_zero_sender {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct CheckNonZeroSender();
            }
            pub mod check_nonce {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct CheckNonce(#[codec(compact)] pub u32);
            }
            pub mod check_spec_version {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct CheckSpecVersion();
            }
            pub mod check_tx_version {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct CheckTxVersion();
            }
            pub mod check_weight {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct CheckWeight();
            }
            pub mod weight_reclaim {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct WeightReclaim();
            }
        }
        pub mod limits {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct BlockLength {
                pub max: frame_support::dispatch::PerDispatchClass<u32>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct BlockWeights {
                pub base_block: ::polymesh_api_client::sp_weights::Weight,
                pub max_block: ::polymesh_api_client::sp_weights::Weight,
                pub per_class: frame_support::dispatch::PerDispatchClass<
                    frame_system::limits::WeightsPerClass,
                >,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct WeightsPerClass {
                pub base_extrinsic: ::polymesh_api_client::sp_weights::Weight,
                pub max_extrinsic: Option<::polymesh_api_client::sp_weights::Weight>,
                pub max_total: Option<::polymesh_api_client::sp_weights::Weight>,
                pub reserved: Option<::polymesh_api_client::sp_weights::Weight>,
            }
        }
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SystemCall {
                #[doc = "Make some on-chain remark."]
                #[doc = ""]
                #[doc = "Can be executed by every `origin`."]
                #[codec(index = 0u8)]
                remark { remark: ::alloc::vec::Vec<u8> },
                #[doc = "Set the number of pages in the WebAssembly environment's heap."]
                #[codec(index = 1u8)]
                set_heap_pages { pages: u64 },
                #[doc = "Set the new runtime code."]
                #[codec(index = 2u8)]
                set_code { code: ::alloc::vec::Vec<u8> },
                #[doc = "Set the new runtime code without doing any checks of the given `code`."]
                #[doc = ""]
                #[doc = "Note that runtime upgrades will not run if this is called with a not-increasing spec"]
                #[doc = "version!"]
                #[codec(index = 3u8)]
                set_code_without_checks { code: ::alloc::vec::Vec<u8> },
                #[doc = "Set some items of storage."]
                #[codec(index = 4u8)]
                set_storage {
                    items: ::alloc::vec::Vec<(::alloc::vec::Vec<u8>, ::alloc::vec::Vec<u8>)>,
                },
                #[doc = "Kill some items from storage."]
                #[codec(index = 5u8)]
                kill_storage {
                    keys: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
                },
                #[doc = "Kill all storage items with a key that starts with the given prefix."]
                #[doc = ""]
                #[doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"]
                #[doc = "the prefix we are removing to accurately calculate the weight of this function."]
                #[codec(index = 6u8)]
                kill_prefix {
                    prefix: ::alloc::vec::Vec<u8>,
                    subkeys: u32,
                },
                #[doc = "Make some on-chain remark and emit event."]
                #[codec(index = 7u8)]
                remark_with_event { remark: ::alloc::vec::Vec<u8> },
                #[doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"]
                #[doc = "later."]
                #[doc = ""]
                #[doc = "This call requires Root origin."]
                #[codec(index = 9u8)]
                authorize_upgrade { code_hash: primitive_types::H256 },
                #[doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"]
                #[doc = "later."]
                #[doc = ""]
                #[doc = "WARNING: This authorizes an upgrade that will take place without any safety checks, for"]
                #[doc = "example that the spec name remains the same and that the version number increases. Not"]
                #[doc = "recommended for normal use. Use `authorize_upgrade` instead."]
                #[doc = ""]
                #[doc = "This call requires Root origin."]
                #[codec(index = 10u8)]
                authorize_upgrade_without_checks { code_hash: primitive_types::H256 },
                #[doc = "Provide the preimage (runtime binary) `code` for an upgrade that has been authorized."]
                #[doc = ""]
                #[doc = "If the authorization required a version check, this call will ensure the spec name"]
                #[doc = "remains unchanged and that the spec version has increased."]
                #[doc = ""]
                #[doc = "Depending on the runtime's `OnSetCode` configuration, this function may directly apply"]
                #[doc = "the new `code` in the same block or attempt to schedule the upgrade."]
                #[doc = ""]
                #[doc = "All origins are allowed."]
                #[codec(index = 11u8)]
                apply_authorized_upgrade { code: ::alloc::vec::Vec<u8> },
            }
            impl SystemCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::remark { .. } => "System.remark",
                        Self::set_heap_pages { .. } => "System.set_heap_pages",
                        Self::set_code { .. } => "System.set_code",
                        Self::set_code_without_checks { .. } => "System.set_code_without_checks",
                        Self::set_storage { .. } => "System.set_storage",
                        Self::kill_storage { .. } => "System.kill_storage",
                        Self::kill_prefix { .. } => "System.kill_prefix",
                        Self::remark_with_event { .. } => "System.remark_with_event",
                        Self::authorize_upgrade { .. } => "System.authorize_upgrade",
                        Self::authorize_upgrade_without_checks { .. } => {
                            "System.authorize_upgrade_without_checks"
                        }
                        Self::apply_authorized_upgrade { .. } => "System.apply_authorized_upgrade",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SystemCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: remark { .. } => { & ["Make some on-chain remark." , "" , "Can be executed by every `origin`." ,] } , Self :: set_heap_pages { .. } => { & ["Set the number of pages in the WebAssembly environment's heap." ,] } , Self :: set_code { .. } => { & ["Set the new runtime code." ,] } , Self :: set_code_without_checks { .. } => { & ["Set the new runtime code without doing any checks of the given `code`." , "" , "Note that runtime upgrades will not run if this is called with a not-increasing spec" , "version!" ,] } , Self :: set_storage { .. } => { & ["Set some items of storage." ,] } , Self :: kill_storage { .. } => { & ["Kill some items from storage." ,] } , Self :: kill_prefix { .. } => { & ["Kill all storage items with a key that starts with the given prefix." , "" , "**NOTE:** We rely on the Root origin to provide us the number of subkeys under" , "the prefix we are removing to accurately calculate the weight of this function." ,] } , Self :: remark_with_event { .. } => { & ["Make some on-chain remark and emit event." ,] } , Self :: authorize_upgrade { .. } => { & ["Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied" , "later." , "" , "This call requires Root origin." ,] } , Self :: authorize_upgrade_without_checks { .. } => { & ["Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied" , "later." , "" , "WARNING: This authorizes an upgrade that will take place without any safety checks, for" , "example that the spec name remains the same and that the version number increases. Not" , "recommended for normal use. Use `authorize_upgrade` instead." , "" , "This call requires Root origin." ,] } , Self :: apply_authorized_upgrade { .. } => { & ["Provide the preimage (runtime binary) `code` for an upgrade that has been authorized." , "" , "If the authorization required a version check, this call will ensure the spec name" , "remains unchanged and that the spec version has increased." , "" , "Depending on the runtime's `OnSetCode` configuration, this function may directly apply" , "the new `code` in the same block or attempt to schedule the upgrade." , "" , "All origins are allowed." ,] } , _ => & [""] , }
                }
            }
            impl From<SystemCall> for &'static str {
                fn from(v: SystemCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SystemCall> for &'static str {
                fn from(v: &SystemCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "Error for the System pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SystemError {
                #[doc = "The name of specification does not match between the current runtime"]
                #[doc = "and the new runtime."]
                #[codec(index = 0u8)]
                InvalidSpecName,
                #[doc = "The specification version is not allowed to decrease between the current runtime"]
                #[doc = "and the new runtime."]
                #[codec(index = 1u8)]
                SpecVersionNeedsToIncrease,
                #[doc = "Failed to extract the runtime version from the new runtime."]
                #[doc = ""]
                #[doc = "Either calling `Core_version` or decoding `RuntimeVersion` failed."]
                #[codec(index = 2u8)]
                FailedToExtractRuntimeVersion,
                #[doc = "Suicide called when the account has non-default composite data."]
                #[codec(index = 3u8)]
                NonDefaultComposite,
                #[doc = "There is a non-zero reference count preventing the account from being purged."]
                #[codec(index = 4u8)]
                NonZeroRefCount,
                #[doc = "The origin filter prevent the call to be dispatched."]
                #[codec(index = 5u8)]
                CallFiltered,
                #[doc = "A multi-block migration is ongoing and prevents the current code from being replaced."]
                #[codec(index = 6u8)]
                MultiBlockMigrationsOngoing,
                #[doc = "No upgrade authorized."]
                #[codec(index = 7u8)]
                NothingAuthorized,
                #[doc = "The submitted code is not authorized."]
                #[codec(index = 8u8)]
                Unauthorized,
            }
            impl SystemError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InvalidSpecName => "System.InvalidSpecName",
                        Self::SpecVersionNeedsToIncrease => "System.SpecVersionNeedsToIncrease",
                        Self::FailedToExtractRuntimeVersion => {
                            "System.FailedToExtractRuntimeVersion"
                        }
                        Self::NonDefaultComposite => "System.NonDefaultComposite",
                        Self::NonZeroRefCount => "System.NonZeroRefCount",
                        Self::CallFiltered => "System.CallFiltered",
                        Self::MultiBlockMigrationsOngoing => "System.MultiBlockMigrationsOngoing",
                        Self::NothingAuthorized => "System.NothingAuthorized",
                        Self::Unauthorized => "System.Unauthorized",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SystemError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: InvalidSpecName => { & ["The name of specification does not match between the current runtime" , "and the new runtime." ,] } , Self :: SpecVersionNeedsToIncrease => { & ["The specification version is not allowed to decrease between the current runtime" , "and the new runtime." ,] } , Self :: FailedToExtractRuntimeVersion => { & ["Failed to extract the runtime version from the new runtime." , "" , "Either calling `Core_version` or decoding `RuntimeVersion` failed." ,] } , Self :: NonDefaultComposite => { & ["Suicide called when the account has non-default composite data." ,] } , Self :: NonZeroRefCount => { & ["There is a non-zero reference count preventing the account from being purged." ,] } , Self :: CallFiltered => { & ["The origin filter prevent the call to be dispatched." ,] } , Self :: MultiBlockMigrationsOngoing => { & ["A multi-block migration is ongoing and prevents the current code from being replaced." ,] } , Self :: NothingAuthorized => { & ["No upgrade authorized." ,] } , Self :: Unauthorized => { & ["The submitted code is not authorized." ,] } , _ => & [""] , }
                }
            }
            impl From<SystemError> for &'static str {
                fn from(v: SystemError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SystemError> for &'static str {
                fn from(v: &SystemError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "Event for the System pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SystemEvent {
                #[doc = "An extrinsic completed successfully."]
                #[codec(index = 0u8)]
                ExtrinsicSuccess {
                    dispatch_info: frame_system::DispatchEventInfo,
                },
                #[doc = "An extrinsic failed."]
                #[codec(index = 1u8)]
                ExtrinsicFailed {
                    dispatch_error: sp_runtime::DispatchError,
                    dispatch_info: frame_system::DispatchEventInfo,
                },
                #[doc = "`:code` was updated."]
                #[codec(index = 2u8)]
                CodeUpdated,
                #[doc = "A new account was created."]
                #[codec(index = 3u8)]
                NewAccount {
                    account: ::polymesh_api_client::AccountId,
                },
                #[doc = "An account was reaped."]
                #[codec(index = 4u8)]
                KilledAccount {
                    account: ::polymesh_api_client::AccountId,
                },
                #[doc = "On on-chain remark happened."]
                #[codec(index = 5u8)]
                Remarked {
                    sender: ::polymesh_api_client::AccountId,
                    hash: primitive_types::H256,
                },
                #[doc = "An upgrade was authorized."]
                #[codec(index = 6u8)]
                UpgradeAuthorized {
                    code_hash: primitive_types::H256,
                    check_version: bool,
                },
                #[doc = "An invalid authorized upgrade was rejected while trying to apply it."]
                #[codec(index = 7u8)]
                RejectedInvalidAuthorizedUpgrade {
                    code_hash: primitive_types::H256,
                    error: sp_runtime::DispatchError,
                },
            }
            impl SystemEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::ExtrinsicSuccess { .. } => "System.ExtrinsicSuccess",
                        Self::ExtrinsicFailed { .. } => "System.ExtrinsicFailed",
                        Self::CodeUpdated => "System.CodeUpdated",
                        Self::NewAccount { .. } => "System.NewAccount",
                        Self::KilledAccount { .. } => "System.KilledAccount",
                        Self::Remarked { .. } => "System.Remarked",
                        Self::UpgradeAuthorized { .. } => "System.UpgradeAuthorized",
                        Self::RejectedInvalidAuthorizedUpgrade { .. } => {
                            "System.RejectedInvalidAuthorizedUpgrade"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SystemEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::ExtrinsicSuccess { .. } => &["An extrinsic completed successfully."],
                        Self::ExtrinsicFailed { .. } => &["An extrinsic failed."],
                        Self::CodeUpdated => &["`:code` was updated."],
                        Self::NewAccount { .. } => &["A new account was created."],
                        Self::KilledAccount { .. } => &["An account was reaped."],
                        Self::Remarked { .. } => &["On on-chain remark happened."],
                        Self::UpgradeAuthorized { .. } => &["An upgrade was authorized."],
                        Self::RejectedInvalidAuthorizedUpgrade { .. } => &[
                            "An invalid authorized upgrade was rejected while trying to apply it.",
                        ],
                        _ => &[""],
                    }
                }
            }
            impl From<SystemEvent> for &'static str {
                fn from(v: SystemEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SystemEvent> for &'static str {
                fn from(v: &SystemEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct AccountInfo<Nonce, AccountData> {
            pub nonce: Nonce,
            pub consumers: Nonce,
            pub providers: Nonce,
            pub sufficients: Nonce,
            pub data: AccountData,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CodeUpgradeAuthorization {
            pub code_hash: primitive_types::H256,
            pub check_version: bool,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct DispatchEventInfo {
            pub weight: ::polymesh_api_client::sp_weights::Weight,
            pub class: frame_support::dispatch::DispatchClass,
            pub pays_fee: frame_support::dispatch::Pays,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct EventRecord<E, T> {
            pub phase: frame_system::Phase,
            pub event: E,
            pub topics: ::alloc::vec::Vec<T>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct LastRuntimeUpgradeInfo {
            #[codec(compact)]
            pub spec_version: u32,
            pub spec_name: ::alloc::borrow::Cow<'static, ::alloc::string::String>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Phase {
            #[codec(index = 0u8)]
            ApplyExtrinsic(u32),
            #[codec(index = 1u8)]
            Finalization,
            #[codec(index = 2u8)]
            Initialization,
        }
    }
    pub mod pallet_asset {
        use super::*;
        pub mod checkpoint {
            use super::*;
            pub mod pallet {
                use super::*;
                #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum CheckpointCall {
                    #[doc = "Creates a single checkpoint at the current time."]
                    #[doc = ""]
                    #[doc = "# Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as an agent of `asset_id`."]
                    #[doc = "- `asset_id` to create the checkpoint for."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
                    #[doc = "- `CounterOverflow` if the total checkpoint counter would overflow."]
                    #[codec(index = 0u8)]
                    create_checkpoint {
                        asset_id: ::polymesh_api_client::AssetId,
                    },
                    #[doc = "Sets the max complexity of a schedule set for an arbitrary asset_id to `max_complexity`."]
                    #[doc = "The new maximum is not enforced retroactively,"]
                    #[doc = "and only applies once new schedules are made."]
                    #[doc = ""]
                    #[doc = "Must be called as a PIP (requires \"root\")."]
                    #[doc = ""]
                    #[doc = "# Arguments"]
                    #[doc = "- `origin` is the root origin."]
                    #[doc = "- `max_complexity` allowed for an arbitrary asset's schedule set."]
                    #[codec(index = 1u8)]
                    set_schedules_max_complexity { max_complexity: u64 },
                    #[doc = "Creates a schedule generating checkpoints"]
                    #[doc = "in the future at either a fixed time or at intervals."]
                    #[doc = ""]
                    #[doc = "The schedule starts out with `strong_ref_count(schedule_id) <- 0`."]
                    #[doc = ""]
                    #[doc = "# Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
                    #[doc = "- `asset_id` to create the schedule for."]
                    #[doc = "- `schedule` that will generate checkpoints."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
                    #[doc = "- `InsufficientAccountBalance` if the protocol fee could not be charged."]
                    #[doc = "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow."]
                    #[doc = ""]
                    #[doc = "# Permissions"]
                    #[doc = "* Asset"]
                    #[codec(index = 2u8)]
                    create_schedule {
                        asset_id: ::polymesh_api_client::AssetId,
                        schedule: polymesh_primitives::checkpoint::ScheduleCheckpoints,
                    },
                    #[doc = "Removes the checkpoint schedule of an asset identified by `id`."]
                    #[doc = ""]
                    #[doc = "# Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
                    #[doc = "- `asset_id` to remove the schedule from."]
                    #[doc = "- `id` of the schedule, when it was created by `created_schedule`."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
                    #[doc = "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `asset_id`."]
                    #[doc = "- `ScheduleNotRemovable` if `id` exists but is not removable."]
                    #[doc = ""]
                    #[doc = "# Permissions"]
                    #[doc = "* Asset"]
                    #[codec(index = 3u8)]
                    remove_schedule {
                        asset_id: ::polymesh_api_client::AssetId,
                        id: polymesh_primitives::checkpoint::ScheduleId,
                    },
                }
                impl CheckpointCall {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::create_checkpoint { .. } => "Checkpoint.create_checkpoint",
                            Self::set_schedules_max_complexity { .. } => {
                                "Checkpoint.set_schedules_max_complexity"
                            }
                            Self::create_schedule { .. } => "Checkpoint.create_schedule",
                            Self::remove_schedule { .. } => "Checkpoint.remove_schedule",
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for CheckpointCall {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: create_checkpoint { .. } => { & ["Creates a single checkpoint at the current time." , "" , "# Arguments" , "- `origin` is a signer that has permissions to act as an agent of `asset_id`." , "- `asset_id` to create the checkpoint for." , "" , "# Errors" , "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`." , "- `CounterOverflow` if the total checkpoint counter would overflow." ,] } , Self :: set_schedules_max_complexity { .. } => { & ["Sets the max complexity of a schedule set for an arbitrary asset_id to `max_complexity`." , "The new maximum is not enforced retroactively," , "and only applies once new schedules are made." , "" , "Must be called as a PIP (requires \"root\")." , "" , "# Arguments" , "- `origin` is the root origin." , "- `max_complexity` allowed for an arbitrary asset's schedule set." ,] } , Self :: create_schedule { .. } => { & ["Creates a schedule generating checkpoints" , "in the future at either a fixed time or at intervals." , "" , "The schedule starts out with `strong_ref_count(schedule_id) <- 0`." , "" , "# Arguments" , "- `origin` is a signer that has permissions to act as owner of `asset_id`." , "- `asset_id` to create the schedule for." , "- `schedule` that will generate checkpoints." , "" , "# Errors" , "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`." , "- `InsufficientAccountBalance` if the protocol fee could not be charged." , "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_schedule { .. } => { & ["Removes the checkpoint schedule of an asset identified by `id`." , "" , "# Arguments" , "- `origin` is a signer that has permissions to act as owner of `asset_id`." , "- `asset_id` to remove the schedule from." , "- `id` of the schedule, when it was created by `created_schedule`." , "" , "# Errors" , "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`." , "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `asset_id`." , "- `ScheduleNotRemovable` if `id` exists but is not removable." , "" , "# Permissions" , "* Asset" ,] } , _ => & [""] , }
                    }
                }
                impl From<CheckpointCall> for &'static str {
                    fn from(v: CheckpointCall) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&CheckpointCall> for &'static str {
                    fn from(v: &CheckpointCall) -> Self {
                        v.as_static_str()
                    }
                }
                #[doc = "The `Error` enum of this pallet."]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum CheckpointError {
                    #[doc = "A checkpoint schedule does not exist for the asset."]
                    #[codec(index = 0u8)]
                    NoSuchSchedule,
                    #[doc = "A checkpoint schedule is not removable as `ref_count(schedule_id) > 0`."]
                    #[codec(index = 1u8)]
                    ScheduleNotRemovable,
                    #[doc = "The new schedule would put the asset over the maximum complexity allowed."]
                    #[codec(index = 2u8)]
                    SchedulesOverMaxComplexity,
                    #[doc = "Can't create an empty schedule."]
                    #[codec(index = 3u8)]
                    ScheduleIsEmpty,
                    #[doc = "The schedule has no more checkpoints."]
                    #[codec(index = 4u8)]
                    ScheduleFinished,
                    #[doc = "The schedule has expired checkpoints."]
                    #[codec(index = 5u8)]
                    ScheduleHasExpiredCheckpoints,
                }
                impl CheckpointError {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::NoSuchSchedule => "Checkpoint.NoSuchSchedule",
                            Self::ScheduleNotRemovable => "Checkpoint.ScheduleNotRemovable",
                            Self::SchedulesOverMaxComplexity => {
                                "Checkpoint.SchedulesOverMaxComplexity"
                            }
                            Self::ScheduleIsEmpty => "Checkpoint.ScheduleIsEmpty",
                            Self::ScheduleFinished => "Checkpoint.ScheduleFinished",
                            Self::ScheduleHasExpiredCheckpoints => {
                                "Checkpoint.ScheduleHasExpiredCheckpoints"
                            }
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for CheckpointError {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: NoSuchSchedule => { & ["A checkpoint schedule does not exist for the asset." ,] } , Self :: ScheduleNotRemovable => { & ["A checkpoint schedule is not removable as `ref_count(schedule_id) > 0`." ,] } , Self :: SchedulesOverMaxComplexity => { & ["The new schedule would put the asset over the maximum complexity allowed." ,] } , Self :: ScheduleIsEmpty => { & ["Can't create an empty schedule." ,] } , Self :: ScheduleFinished => { & ["The schedule has no more checkpoints." ,] } , Self :: ScheduleHasExpiredCheckpoints => { & ["The schedule has expired checkpoints." ,] } , _ => & [""] , }
                    }
                }
                impl From<CheckpointError> for &'static str {
                    fn from(v: CheckpointError) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&CheckpointError> for &'static str {
                    fn from(v: &CheckpointError) -> Self {
                        v.as_static_str()
                    }
                }
                #[doc = "The `Event` enum of this pallet"]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum CheckpointEvent {
                    #[doc = "A checkpoint was created."]
                    #[doc = ""]
                    #[doc = "(caller DID, AssetId, checkpoint ID, total supply, checkpoint timestamp)"]
                    #[codec(index = 0u8)]
                    CheckpointCreated(
                        Option<::polymesh_api_client::IdentityId>,
                        ::polymesh_api_client::AssetId,
                        polymesh_primitives::asset::CheckpointId,
                        u128,
                        u64,
                    ),
                    #[doc = "The maximum complexity for an arbitrary asset's schedule set was changed."]
                    #[doc = ""]
                    #[doc = "(GC DID, the new maximum)"]
                    #[codec(index = 1u8)]
                    MaximumSchedulesComplexityChanged(::polymesh_api_client::IdentityId, u64),
                    #[doc = "A checkpoint schedule was created."]
                    #[doc = ""]
                    #[doc = "(caller DID, AssetId, schedule id, schedule)"]
                    #[codec(index = 2u8)]
                    ScheduleCreated(
                        ::polymesh_api_client::IdentityId,
                        ::polymesh_api_client::AssetId,
                        polymesh_primitives::checkpoint::ScheduleId,
                        polymesh_primitives::checkpoint::ScheduleCheckpoints,
                    ),
                    #[doc = "A checkpoint schedule was removed."]
                    #[doc = ""]
                    #[doc = "(caller DID, AssetId, schedule id, schedule)"]
                    #[codec(index = 3u8)]
                    ScheduleRemoved(
                        ::polymesh_api_client::IdentityId,
                        ::polymesh_api_client::AssetId,
                        polymesh_primitives::checkpoint::ScheduleId,
                        polymesh_primitives::checkpoint::ScheduleCheckpoints,
                    ),
                }
                impl CheckpointEvent {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::CheckpointCreated(_, _, _, _, _) => {
                                "Checkpoint.CheckpointCreated"
                            }
                            Self::MaximumSchedulesComplexityChanged(_, _) => {
                                "Checkpoint.MaximumSchedulesComplexityChanged"
                            }
                            Self::ScheduleCreated(_, _, _, _) => "Checkpoint.ScheduleCreated",
                            Self::ScheduleRemoved(_, _, _, _) => "Checkpoint.ScheduleRemoved",
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for CheckpointEvent {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: CheckpointCreated (_ , _ , _ , _ , _) => { & ["A checkpoint was created." , "" , "(caller DID, AssetId, checkpoint ID, total supply, checkpoint timestamp)" ,] } , Self :: MaximumSchedulesComplexityChanged (_ , _) => { & ["The maximum complexity for an arbitrary asset's schedule set was changed." , "" , "(GC DID, the new maximum)" ,] } , Self :: ScheduleCreated (_ , _ , _ , _) => { & ["A checkpoint schedule was created." , "" , "(caller DID, AssetId, schedule id, schedule)" ,] } , Self :: ScheduleRemoved (_ , _ , _ , _) => { & ["A checkpoint schedule was removed." , "" , "(caller DID, AssetId, schedule id, schedule)" ,] } , _ => & [""] , }
                    }
                }
                impl From<CheckpointEvent> for &'static str {
                    fn from(v: CheckpointEvent) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&CheckpointEvent> for &'static str {
                    fn from(v: &CheckpointEvent) -> Self {
                        v.as_static_str()
                    }
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Version(pub u8);
        }
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AssetCall {
                #[doc = "Registers a unique ticker or extends the validity of an existing ticker."]
                #[doc = ""]
                #[doc = "This function allows the caller to register a new ticker or extend the registration"]
                #[doc = "of an existing ticker. The ticker validity does not carry forward when renewing."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `ticker` - The ticker to register."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `TickerRegistered` - When a ticker is successfully registered."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `TickerAlreadyRegistered` - If the ticker is already registered."]
                #[doc = "* `TickerTooLong` - If the ticker length exceeds the maximum allowed length."]
                #[doc = "* `InvalidTickerCharacter` - If the ticker contains invalid characters."]
                #[codec(index = 0u8)]
                register_unique_ticker {
                    ticker: polymesh_primitives::ticker::Ticker,
                },
                #[doc = "Accepts a ticker transfer."]
                #[doc = ""]
                #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
                #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `auth_id` - Authorization ID of ticker transfer authorization."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `TickerTransferred` - When a ticker is successfully transferred."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
                #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
                #[codec(index = 1u8)]
                accept_ticker_transfer { auth_id: u64 },
                #[doc = "Accepts an asset ownership transfer."]
                #[doc = ""]
                #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
                #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `auth_id` - Authorization ID of the asset ownership transfer authorization."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetOwnershipTransferred` - When a asset ownership is successfully transferred."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
                #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
                #[codec(index = 2u8)]
                accept_asset_ownership_transfer { auth_id: u64 },
                #[doc = "Creates a new asset."]
                #[doc = ""]
                #[doc = "The total supply will initially be zero. To mint tokens, use [`Pallet::issue`]."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
                #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
                #[doc = "* `asset_type` - The [`AssetType`] of the new asset."]
                #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
                #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetCreated` - When a new asset is successfully created."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
                #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
                #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
                #[codec(index = 3u8)]
                create_asset {
                    asset_name: polymesh_primitives::asset::AssetName,
                    divisible: bool,
                    asset_type: polymesh_primitives::asset::AssetType,
                    asset_identifiers:
                        ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
                    funding_round_name: Option<polymesh_primitives::asset::FundingRoundName>,
                },
                #[doc = "Freezes transfers of a given asset."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to freeze transfers of a given asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The asset to freeze."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetFrozen` - When an asset is successfully frozen."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `NoSuchAsset` - If the asset does not exist."]
                #[doc = "* `AlreadyFrozen` - If the asset is already frozen."]
                #[codec(index = 4u8)]
                freeze {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Unfreezes transfers of a given asset."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to unfreeze transfers of a given asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The asset to unfreeze."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetUnfrozen` - When an asset is successfully unfrozen."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `NoSuchAsset` - If the asset does not exist."]
                #[doc = "* `NotFrozen` - If the asset is not frozen."]
                #[codec(index = 5u8)]
                unfreeze {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Updates the [`AssetName`] associated to an asset."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to update the name of an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `asset_name` - The new [`AssetName`] that will be associated to the asset."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetRenamed` - When an asset is successfully renamed."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
                #[doc = "* `NoSuchAsset` - If the asset does not exist."]
                #[codec(index = 6u8)]
                rename_asset {
                    asset_id: ::polymesh_api_client::AssetId,
                    asset_name: polymesh_primitives::asset::AssetName,
                },
                #[doc = "Issue (i.e mint) new tokens to the caller, which must be an authorized external agent."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to mint new tokens for a given asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin`: A signer that has permissions to act as an agent of `ticker`."]
                #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
                #[doc = "* `amount`: The amount of tokens that will be issued."]
                #[doc = "* `portfolio_kind`: The [`PortfolioKind`] of the portfolio that will receive the minted tokens."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Portfolio"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
                #[doc = "* `InvalidGranularity` - If the amount to issue does not meet the granularity requirements."]
                #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
                #[codec(index = 7u8)]
                issue {
                    asset_id: ::polymesh_api_client::AssetId,
                    amount: u128,
                    portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
                },
                #[doc = "Redeems (i.e burns) existing tokens by reducing the balance of the caller's portfolio and the total supply of the asset."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to redeem tokens from a given asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin`: is a signer that has permissions to act as an agent of `asset_id`."]
                #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
                #[doc = "* `value`: amount of tokens to redeem."]
                #[doc = "* `portfolio_kind`: the [`PortfolioKind`] that will have its balance reduced."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Portfolio"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
                #[doc = "* `InvalidGranularity` - If the value to redeem does not meet the granularity requirements."]
                #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
                #[codec(index = 8u8)]
                redeem {
                    asset_id: ::polymesh_api_client::AssetId,
                    value: u128,
                    portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
                },
                #[doc = "If the asset associated to `asset_id` is indivisible, sets [`AssetDetails::divisible`] to true."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to make an indivisible asset divisible."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `DivisibilityChanged` - When the divisibility of an asset is successfully changed."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `NoSuchAsset` - If the asset does not exist."]
                #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
                #[doc = "* `AssetAlreadyDivisible` - If the asset is already divisible."]
                #[codec(index = 9u8)]
                make_divisible {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Add documents for a given asset."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to add documents to an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `docs` - Documents to be attached to the asset."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `DocumentAdded` - When a document is successfully added to an asset."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `CounterOverflow` - If the document ID counter overflows."]
                #[codec(index = 10u8)]
                add_documents {
                    docs: ::alloc::vec::Vec<polymesh_primitives::document::Document>,
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Remove documents for a given asset."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to remove documents from an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `docs_id` - A vector of all [`DocumentId`] that will be removed from the asset."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `DocumentRemoved` - When a document is successfully removed from an asset."]
                #[codec(index = 11u8)]
                remove_documents {
                    docs_id: ::alloc::vec::Vec<polymesh_primitives::document::DocumentId>,
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Sets the name of the current funding round."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to set the name of the current funding round for an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `funding_round_name` - The [`FundingRoundName`] of the current funding round."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `FundingRoundSet` - When the funding round name is successfully set."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `FundingRoundNameMaxLengthExceeded` - If the funding round name length exceeds the maximum allowed length."]
                #[codec(index = 12u8)]
                set_funding_round {
                    asset_id: ::polymesh_api_client::AssetId,
                    funding_round_name: polymesh_primitives::asset::FundingRoundName,
                },
                #[doc = "Updates the asset identifiers associated to the asset."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to update the asset identifiers for an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`] that will be associated to the asset."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `IdentifiersUpdated` - When the asset identifiers are successfully updated."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
                #[codec(index = 13u8)]
                update_identifiers {
                    asset_id: ::polymesh_api_client::AssetId,
                    asset_identifiers:
                        ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
                },
                #[doc = "Forces a transfer of tokens from `from_portfolio` to the caller's default portfolio."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to force a transfer of tokens from one portfolio to another."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `value` - The [`Balance`] of tokens that will be transferred."]
                #[doc = "* `from_portfolio` - The [`PortfolioId`] that will have its balance reduced."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Portfolio"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `ControllerTransfer` - When tokens are successfully transferred."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
                #[doc = "* `InvalidGranularity` - If the amount to transfer does not meet the granularity requirements."]
                #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
                #[codec(index = 14u8)]
                controller_transfer {
                    asset_id: ::polymesh_api_client::AssetId,
                    value: u128,
                    from_portfolio: polymesh_primitives::identity_id::PortfolioId,
                },
                #[doc = "Registers a custom asset type."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `ty` - Contains the string representation of the asset type."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
                #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
                #[codec(index = 15u8)]
                register_custom_asset_type { ty: ::alloc::vec::Vec<u8> },
                #[doc = "Creates a new asset with a new custom asset type."]
                #[doc = ""]
                #[doc = "The total supply will initially be zero. To mint tokens, use [`Pallet::issue`]."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
                #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
                #[doc = "* `custom_asset_type` - The custom asset type of the asset."]
                #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
                #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetCreated` - When a new asset is successfully created."]
                #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
                #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
                #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
                #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
                #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
                #[codec(index = 16u8)]
                create_asset_with_custom_type {
                    asset_name: polymesh_primitives::asset::AssetName,
                    divisible: bool,
                    custom_asset_type: ::alloc::vec::Vec<u8>,
                    asset_identifiers:
                        ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
                    funding_round_name: Option<polymesh_primitives::asset::FundingRoundName>,
                },
                #[doc = "Set asset metadata value."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to set metadata for an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
                #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
                #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
                #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
                #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
                #[codec(index = 17u8)]
                set_asset_metadata {
                    asset_id: ::polymesh_api_client::AssetId,
                    key: polymesh_primitives::asset_metadata::AssetMetadataKey,
                    value: polymesh_primitives::asset_metadata::AssetMetadataValue,
                    detail:
                        Option<polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
                },
                #[doc = "Set asset metadata value details (expire, lock status)."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to set metadata details for an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
                #[doc = "* `details` - The [`AssetMetadataValueDetail`] (expire, lock status) that will be associated to the asset."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `SetAssetMetadataValueDetails` - When the asset metadata value details are successfully set."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
                #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
                #[doc = "* `AssetMetadataValueIsEmpty` - If the metadata value is empty."]
                #[codec(index = 18u8)]
                set_asset_metadata_details {
                    asset_id: ::polymesh_api_client::AssetId,
                    key: polymesh_primitives::asset_metadata::AssetMetadataKey,
                    detail: polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
                },
                #[doc = "Registers and set local asset metadata."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to register and set local metadata for an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `name` - The [`AssetMetadataName`]."]
                #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
                #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
                #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
                #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
                #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
                #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
                #[codec(index = 19u8)]
                register_and_set_local_asset_metadata {
                    asset_id: ::polymesh_api_client::AssetId,
                    name: polymesh_primitives::asset_metadata::AssetMetadataName,
                    spec: polymesh_primitives::asset_metadata::AssetMetadataSpec,
                    value: polymesh_primitives::asset_metadata::AssetMetadataValue,
                    detail:
                        Option<polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
                },
                #[doc = "Registers asset metadata local type."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to register a local metadata type for an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `name` - The [`AssetMetadataName`]."]
                #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
                #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
                #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
                #[codec(index = 20u8)]
                register_asset_metadata_local_type {
                    asset_id: ::polymesh_api_client::AssetId,
                    name: polymesh_primitives::asset_metadata::AssetMetadataName,
                    spec: polymesh_primitives::asset_metadata::AssetMetadataSpec,
                },
                #[doc = "Registers asset metadata global type."]
                #[doc = ""]
                #[doc = "This function allows the root origin to register a global metadata type."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The root origin."]
                #[doc = "* `name` - The [`AssetMetadataName`]."]
                #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `RegisterAssetMetadataGlobalType` - When the global asset metadata type is successfully registered."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `AssetMetadataGlobalKeyAlreadyExists` - If the global metadata key already exists."]
                #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
                #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
                #[codec(index = 21u8)]
                register_asset_metadata_global_type {
                    name: polymesh_primitives::asset_metadata::AssetMetadataName,
                    spec: polymesh_primitives::asset_metadata::AssetMetadataSpec,
                },
                #[doc = "Updates the type of an asset."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to update the type of an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
                #[doc = "* `asset_type` - The new [`AssetType`] of the asset."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetTypeChanged` - When the asset type is successfully changed."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `NoSuchAsset` - If the asset does not exist."]
                #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
                #[doc = "* `IncompatibleAssetTypeUpdate` - If the new asset type is incompatible with the existing asset type."]
                #[codec(index = 22u8)]
                update_asset_type {
                    asset_id: ::polymesh_api_client::AssetId,
                    asset_type: polymesh_primitives::asset::AssetType,
                },
                #[doc = "Removes the asset metadata key and value of a local key."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to remove a local metadata key and its value for an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the local metadata key."]
                #[doc = "* `local_key` - The [`AssetMetadataLocalKey`] that will be removed."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `LocalMetadataKeyDeleted` - When the local metadata key is successfully deleted."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `AssetMetadataKeyIsMissing` - If the local metadata key is missing."]
                #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
                #[doc = "* `AssetMetadataKeyBelongsToNFTCollection` - If the metadata key belongs to an NFT collection."]
                #[codec(index = 23u8)]
                remove_local_metadata_key {
                    asset_id: ::polymesh_api_client::AssetId,
                    local_key: polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
                },
                #[doc = "Removes the asset metadata value of a metadata key."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to remove a metadata value for an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] associated to the metadata key."]
                #[doc = "* `metadata_key` - The [`AssetMetadataKey`] that will have its value deleted."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `MetadataValueDeleted` - When the metadata value is successfully deleted."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
                #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
                #[codec(index = 24u8)]
                remove_metadata_value {
                    asset_id: ::polymesh_api_client::AssetId,
                    metadata_key: polymesh_primitives::asset_metadata::AssetMetadataKey,
                },
                #[doc = "Pre-approves the receivement of the asset for all identities."]
                #[doc = ""]
                #[doc = "This function allows the root origin to pre-approve the receivement of an asset for all identities."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The root origin."]
                #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetAffirmationExemption` - When the asset is successfully exempted from affirmation."]
                #[codec(index = 25u8)]
                exempt_asset_affirmation {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Removes the pre-approval of the asset for all identities."]
                #[doc = ""]
                #[doc = "This function allows the root origin to remove the pre-approval of an asset for all identities."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The root origin."]
                #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `RemoveAssetAffirmationExemption` - When the asset's affirmation exemption is successfully removed."]
                #[codec(index = 26u8)]
                remove_asset_affirmation_exemption {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Pre-approves the receivement of an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `PreApprovedAsset` - When the asset is successfully pre-approved for receivement."]
                #[codec(index = 27u8)]
                pre_approve_asset {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Removes the pre-approval of an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `RemovePreApprovedAsset` - When the asset's pre-approval is successfully removed."]
                #[codec(index = 28u8)]
                remove_asset_pre_approval {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Sets all identities in the `mediators` set as mandatory mediators for any instruction transferring `asset_id`."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to add mandatory mediators for an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] of the asset that will require the mediators."]
                #[doc = "* `mediators` - A set of [`IdentityId`] of all the mandatory mediators for the given ticker."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetMediatorsAdded` - When the mandatory mediators are successfully added."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `NumberOfAssetMediatorsExceeded` - If the number of mandatory mediators exceeds the maximum allowed limit."]
                #[codec(index = 29u8)]
                add_mandatory_mediators {
                    asset_id: ::polymesh_api_client::AssetId,
                    mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
                },
                #[doc = "Removes all identities in the `mediators` set from the mandatory mediators list for the given `asset_id`."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to remove mandatory mediators for an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_id` - The [`AssetId`] of the asset that will have mediators removed."]
                #[doc = "* `mediators` - A set of [`IdentityId`] of all the mediators that will be removed from the mandatory mediators list."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `AssetMediatorsRemoved` - When the mandatory mediators are successfully removed."]
                #[codec(index = 30u8)]
                remove_mandatory_mediators {
                    asset_id: ::polymesh_api_client::AssetId,
                    mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
                },
                #[doc = "Establishes a connection between a ticker and an AssetId."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to link a ticker to an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `ticker` - The [`Ticker`] that will be linked to the given `asset_id`."]
                #[doc = "* `asset_id` - The [`AssetId`] that will be connected to `ticker`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `TickerLinkedToAsset` - When the ticker is successfully linked to the asset."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
                #[doc = "* `TickerRegistrationExpired` - If the ticker registration has expired."]
                #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
                #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
                #[doc = "* `AssetIsAlreadyLinkedToATicker` - If the asset is already linked to a ticker."]
                #[codec(index = 31u8)]
                link_ticker_to_asset_id {
                    ticker: polymesh_primitives::ticker::Ticker,
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Removes the link between a ticker and an asset."]
                #[doc = ""]
                #[doc = "This function allows the asset issuer or an external agent to unlink a ticker from an asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `ticker` - The [`Ticker`] that will be unlinked from the given `asset_id`."]
                #[doc = "* `asset_id` - The [`AssetId`] that will be unlinked from `ticker`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `TickerUnlinkedFromAsset` - When the ticker is successfully unlinked from the asset."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
                #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
                #[doc = "* `TickerIsNotLinkedToTheAsset` - If the ticker is not linked to the asset."]
                #[codec(index = 32u8)]
                unlink_ticker_from_asset_id {
                    ticker: polymesh_primitives::ticker::Ticker,
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Updates the global metadata specification."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
                #[doc = "* `asset_metadata_name` - The [`AssetMetadataName`] associated with the global metadata."]
                #[doc = "* `asset_metadata_spec` - The new [`AssetMetadataSpec`] that will be associated with the global metadata."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `GlobalMetadataSpecUpdated` - When the global metadata specification is successfully updated."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the origin is not authorized."]
                #[doc = "* `TooLong` - If the metadata url or description length exceeds the maximum allowed length."]
                #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
                #[codec(index = 33u8)]
                update_global_metadata_spec {
                    asset_metadata_name: polymesh_primitives::asset_metadata::AssetMetadataName,
                    asset_metadata_spec: polymesh_primitives::asset_metadata::AssetMetadataSpec,
                },
            }
            impl AssetCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::register_unique_ticker { .. } => "Asset.register_unique_ticker",
                        Self::accept_ticker_transfer { .. } => "Asset.accept_ticker_transfer",
                        Self::accept_asset_ownership_transfer { .. } => {
                            "Asset.accept_asset_ownership_transfer"
                        }
                        Self::create_asset { .. } => "Asset.create_asset",
                        Self::freeze { .. } => "Asset.freeze",
                        Self::unfreeze { .. } => "Asset.unfreeze",
                        Self::rename_asset { .. } => "Asset.rename_asset",
                        Self::issue { .. } => "Asset.issue",
                        Self::redeem { .. } => "Asset.redeem",
                        Self::make_divisible { .. } => "Asset.make_divisible",
                        Self::add_documents { .. } => "Asset.add_documents",
                        Self::remove_documents { .. } => "Asset.remove_documents",
                        Self::set_funding_round { .. } => "Asset.set_funding_round",
                        Self::update_identifiers { .. } => "Asset.update_identifiers",
                        Self::controller_transfer { .. } => "Asset.controller_transfer",
                        Self::register_custom_asset_type { .. } => {
                            "Asset.register_custom_asset_type"
                        }
                        Self::create_asset_with_custom_type { .. } => {
                            "Asset.create_asset_with_custom_type"
                        }
                        Self::set_asset_metadata { .. } => "Asset.set_asset_metadata",
                        Self::set_asset_metadata_details { .. } => {
                            "Asset.set_asset_metadata_details"
                        }
                        Self::register_and_set_local_asset_metadata { .. } => {
                            "Asset.register_and_set_local_asset_metadata"
                        }
                        Self::register_asset_metadata_local_type { .. } => {
                            "Asset.register_asset_metadata_local_type"
                        }
                        Self::register_asset_metadata_global_type { .. } => {
                            "Asset.register_asset_metadata_global_type"
                        }
                        Self::update_asset_type { .. } => "Asset.update_asset_type",
                        Self::remove_local_metadata_key { .. } => "Asset.remove_local_metadata_key",
                        Self::remove_metadata_value { .. } => "Asset.remove_metadata_value",
                        Self::exempt_asset_affirmation { .. } => "Asset.exempt_asset_affirmation",
                        Self::remove_asset_affirmation_exemption { .. } => {
                            "Asset.remove_asset_affirmation_exemption"
                        }
                        Self::pre_approve_asset { .. } => "Asset.pre_approve_asset",
                        Self::remove_asset_pre_approval { .. } => "Asset.remove_asset_pre_approval",
                        Self::add_mandatory_mediators { .. } => "Asset.add_mandatory_mediators",
                        Self::remove_mandatory_mediators { .. } => {
                            "Asset.remove_mandatory_mediators"
                        }
                        Self::link_ticker_to_asset_id { .. } => "Asset.link_ticker_to_asset_id",
                        Self::unlink_ticker_from_asset_id { .. } => {
                            "Asset.unlink_ticker_from_asset_id"
                        }
                        Self::update_global_metadata_spec { .. } => {
                            "Asset.update_global_metadata_spec"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for AssetCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: register_unique_ticker { .. } => { & ["Registers a unique ticker or extends the validity of an existing ticker." , "" , "This function allows the caller to register a new ticker or extend the registration" , "of an existing ticker. The ticker validity does not carry forward when renewing." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `ticker` - The ticker to register." , "" , "# Events" , "* `TickerRegistered` - When a ticker is successfully registered." , "" , "# Errors" , "* `TickerAlreadyRegistered` - If the ticker is already registered." , "* `TickerTooLong` - If the ticker length exceeds the maximum allowed length." , "* `InvalidTickerCharacter` - If the ticker contains invalid characters." ,] } , Self :: accept_ticker_transfer { .. } => { & ["Accepts a ticker transfer." , "" , "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)." , "NB: To reject the transfer, call remove auth function in identity module." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `auth_id` - Authorization ID of ticker transfer authorization." , "" , "# Events" , "* `TickerTransferred` - When a ticker is successfully transferred." , "" , "# Errors" , "* `TickerRegistrationNotFound` - If the ticker registration is not found." , "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset." ,] } , Self :: accept_asset_ownership_transfer { .. } => { & ["Accepts an asset ownership transfer." , "" , "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)." , "NB: To reject the transfer, call remove auth function in identity module." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `auth_id` - Authorization ID of the asset ownership transfer authorization." , "" , "# Events" , "* `AssetOwnershipTransferred` - When a asset ownership is successfully transferred." , "" , "# Errors" , "* `TickerRegistrationNotFound` - If the ticker registration is not found." , "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset." ,] } , Self :: create_asset { .. } => { & ["Creates a new asset." , "" , "The total supply will initially be zero. To mint tokens, use [`Pallet::issue`]." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_name` - The [`AssetName`] of the new asset." , "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible." , "* `asset_type` - The [`AssetType`] of the new asset." , "* `asset_identifiers` - A vector of [`AssetIdentifier`]." , "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])." , "" , "# Events" , "* `AssetCreated` - When a new asset is successfully created." , "" , "# Errors" , "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length." , "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid." , "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid." ,] } , Self :: freeze { .. } => { & ["Freezes transfers of a given asset." , "" , "This function allows the asset issuer or an external agent to freeze transfers of a given asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The asset to freeze." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetFrozen` - When an asset is successfully frozen." , "" , "# Errors" , "* `NoSuchAsset` - If the asset does not exist." , "* `AlreadyFrozen` - If the asset is already frozen." ,] } , Self :: unfreeze { .. } => { & ["Unfreezes transfers of a given asset." , "" , "This function allows the asset issuer or an external agent to unfreeze transfers of a given asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The asset to unfreeze." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetUnfrozen` - When an asset is successfully unfrozen." , "" , "# Errors" , "* `NoSuchAsset` - If the asset does not exist." , "* `NotFrozen` - If the asset is not frozen." ,] } , Self :: rename_asset { .. } => { & ["Updates the [`AssetName`] associated to an asset." , "" , "This function allows the asset issuer or an external agent to update the name of an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `asset_name` - The new [`AssetName`] that will be associated to the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetRenamed` - When an asset is successfully renamed." , "" , "# Errors" , "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length." , "* `NoSuchAsset` - If the asset does not exist." ,] } , Self :: issue { .. } => { & ["Issue (i.e mint) new tokens to the caller, which must be an authorized external agent." , "" , "This function allows the asset issuer or an external agent to mint new tokens for a given asset." , "" , "# Arguments" , "* `origin`: A signer that has permissions to act as an agent of `ticker`." , "* `asset_id`: the [`AssetId`] associated to the asset." , "* `amount`: The amount of tokens that will be issued." , "* `portfolio_kind`: The [`PortfolioKind`] of the portfolio that will receive the minted tokens." , "" , "# Permissions" , "* Asset" , "* Portfolio" , "" , "# Events" , "* `AssetBalanceUpdated` - When the asset balance is successfully updated." , "" , "# Errors" , "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token." , "* `InvalidGranularity` - If the amount to issue does not meet the granularity requirements." , "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit." ,] } , Self :: redeem { .. } => { & ["Redeems (i.e burns) existing tokens by reducing the balance of the caller's portfolio and the total supply of the asset." , "" , "This function allows the asset issuer or an external agent to redeem tokens from a given asset." , "" , "# Arguments" , "* `origin`: is a signer that has permissions to act as an agent of `asset_id`." , "* `asset_id`: the [`AssetId`] associated to the asset." , "* `value`: amount of tokens to redeem." , "* `portfolio_kind`: the [`PortfolioKind`] that will have its balance reduced." , "" , "# Permissions" , "* Asset" , "* Portfolio" , "" , "# Events" , "* `AssetBalanceUpdated` - When the asset balance is successfully updated." , "" , "# Errors" , "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token." , "* `InvalidGranularity` - If the value to redeem does not meet the granularity requirements." , "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit." ,] } , Self :: make_divisible { .. } => { & ["If the asset associated to `asset_id` is indivisible, sets [`AssetDetails::divisible`] to true." , "" , "This function allows the asset issuer or an external agent to make an indivisible asset divisible." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `DivisibilityChanged` - When the divisibility of an asset is successfully changed." , "" , "# Errors" , "* `NoSuchAsset` - If the asset does not exist." , "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token." , "* `AssetAlreadyDivisible` - If the asset is already divisible." ,] } , Self :: add_documents { .. } => { & ["Add documents for a given asset." , "" , "This function allows the asset issuer or an external agent to add documents to an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `docs` - Documents to be attached to the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `DocumentAdded` - When a document is successfully added to an asset." , "" , "# Errors" , "* `CounterOverflow` - If the document ID counter overflows." ,] } , Self :: remove_documents { .. } => { & ["Remove documents for a given asset." , "" , "This function allows the asset issuer or an external agent to remove documents from an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `docs_id` - A vector of all [`DocumentId`] that will be removed from the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `DocumentRemoved` - When a document is successfully removed from an asset." ,] } , Self :: set_funding_round { .. } => { & ["Sets the name of the current funding round." , "" , "This function allows the asset issuer or an external agent to set the name of the current funding round for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `funding_round_name` - The [`FundingRoundName`] of the current funding round." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `FundingRoundSet` - When the funding round name is successfully set." , "" , "# Errors" , "* `FundingRoundNameMaxLengthExceeded` - If the funding round name length exceeds the maximum allowed length." ,] } , Self :: update_identifiers { .. } => { & ["Updates the asset identifiers associated to the asset." , "" , "This function allows the asset issuer or an external agent to update the asset identifiers for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `asset_identifiers` - A vector of [`AssetIdentifier`] that will be associated to the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `IdentifiersUpdated` - When the asset identifiers are successfully updated." , "" , "# Errors" , "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid." ,] } , Self :: controller_transfer { .. } => { & ["Forces a transfer of tokens from `from_portfolio` to the caller's default portfolio." , "" , "This function allows the asset issuer or an external agent to force a transfer of tokens from one portfolio to another." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `value` - The [`Balance`] of tokens that will be transferred." , "* `from_portfolio` - The [`PortfolioId`] that will have its balance reduced." , "" , "# Permissions" , "* Asset" , "* Portfolio" , "" , "# Events" , "* `ControllerTransfer` - When tokens are successfully transferred." , "" , "# Errors" , "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token." , "* `InvalidGranularity` - If the amount to transfer does not meet the granularity requirements." , "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit." ,] } , Self :: register_custom_asset_type { .. } => { & ["Registers a custom asset type." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `ty` - Contains the string representation of the asset type." , "" , "# Events" , "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered." , "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered." , "" , "# Errors" , "* `TooLong` - If the custom asset type length exceeds the maximum allowed length." ,] } , Self :: create_asset_with_custom_type { .. } => { & ["Creates a new asset with a new custom asset type." , "" , "The total supply will initially be zero. To mint tokens, use [`Pallet::issue`]." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_name` - The [`AssetName`] of the new asset." , "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible." , "* `custom_asset_type` - The custom asset type of the asset." , "* `asset_identifiers` - A vector of [`AssetIdentifier`]." , "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])." , "" , "# Events" , "* `AssetCreated` - When a new asset is successfully created." , "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered." , "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered." , "" , "# Errors" , "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length." , "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid." , "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid." , "* `TooLong` - If the custom asset type length exceeds the maximum allowed length." ,] } , Self :: set_asset_metadata { .. } => { & ["Set asset metadata value." , "" , "This function allows the asset issuer or an external agent to set metadata for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `key` - The [`AssetMetadataKey`] associated to the asset." , "* `value` - The [`AssetMetadataValue`] of the given metadata key." , "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `SetAssetMetadataValue` - When the asset metadata value is successfully set." , "" , "# Errors" , "* `AssetMetadataKeyIsMissing` - If the metadata key is missing." , "* `AssetMetadataValueIsLocked` - If the metadata value is locked." , "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length." ,] } , Self :: set_asset_metadata_details { .. } => { & ["Set asset metadata value details (expire, lock status)." , "" , "This function allows the asset issuer or an external agent to set metadata details for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `key` - The [`AssetMetadataKey`] associated to the asset." , "* `details` - The [`AssetMetadataValueDetail`] (expire, lock status) that will be associated to the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `SetAssetMetadataValueDetails` - When the asset metadata value details are successfully set." , "" , "# Errors" , "* `AssetMetadataKeyIsMissing` - If the metadata key is missing." , "* `AssetMetadataValueIsLocked` - If the metadata value is locked." , "* `AssetMetadataValueIsEmpty` - If the metadata value is empty." ,] } , Self :: register_and_set_local_asset_metadata { .. } => { & ["Registers and set local asset metadata." , "" , "This function allows the asset issuer or an external agent to register and set local metadata for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `name` - The [`AssetMetadataName`]." , "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])." , "* `value` - The [`AssetMetadataValue`] of the given metadata key." , "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered." , "* `SetAssetMetadataValue` - When the asset metadata value is successfully set." , "" , "# Errors" , "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists." , "* `AssetMetadataValueIsLocked` - If the metadata value is locked." , "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length." ,] } , Self :: register_asset_metadata_local_type { .. } => { & ["Registers asset metadata local type." , "" , "This function allows the asset issuer or an external agent to register a local metadata type for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `name` - The [`AssetMetadataName`]." , "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered." , "" , "# Errors" , "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists." , "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length." , "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length." ,] } , Self :: register_asset_metadata_global_type { .. } => { & ["Registers asset metadata global type." , "" , "This function allows the root origin to register a global metadata type." , "" , "# Arguments" , "* `origin` - The root origin." , "* `name` - The [`AssetMetadataName`]." , "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])." , "" , "# Events" , "* `RegisterAssetMetadataGlobalType` - When the global asset metadata type is successfully registered." , "" , "# Errors" , "* `AssetMetadataGlobalKeyAlreadyExists` - If the global metadata key already exists." , "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length." , "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length." ,] } , Self :: update_asset_type { .. } => { & ["Updates the type of an asset." , "" , "This function allows the asset issuer or an external agent to update the type of an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the asset." , "* `asset_type` - The new [`AssetType`] of the asset." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetTypeChanged` - When the asset type is successfully changed." , "" , "# Errors" , "* `NoSuchAsset` - If the asset does not exist." , "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid." , "* `IncompatibleAssetTypeUpdate` - If the new asset type is incompatible with the existing asset type." ,] } , Self :: remove_local_metadata_key { .. } => { & ["Removes the asset metadata key and value of a local key." , "" , "This function allows the asset issuer or an external agent to remove a local metadata key and its value for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the local metadata key." , "* `local_key` - The [`AssetMetadataLocalKey`] that will be removed." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `LocalMetadataKeyDeleted` - When the local metadata key is successfully deleted." , "" , "# Errors" , "* `AssetMetadataKeyIsMissing` - If the local metadata key is missing." , "* `AssetMetadataValueIsLocked` - If the metadata value is locked." , "* `AssetMetadataKeyBelongsToNFTCollection` - If the metadata key belongs to an NFT collection." ,] } , Self :: remove_metadata_value { .. } => { & ["Removes the asset metadata value of a metadata key." , "" , "This function allows the asset issuer or an external agent to remove a metadata value for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] associated to the metadata key." , "* `metadata_key` - The [`AssetMetadataKey`] that will have its value deleted." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `MetadataValueDeleted` - When the metadata value is successfully deleted." , "" , "# Errors" , "* `AssetMetadataKeyIsMissing` - If the metadata key is missing." , "* `AssetMetadataValueIsLocked` - If the metadata value is locked." ,] } , Self :: exempt_asset_affirmation { .. } => { & ["Pre-approves the receivement of the asset for all identities." , "" , "This function allows the root origin to pre-approve the receivement of an asset for all identities." , "" , "# Arguments" , "* `origin` - The root origin." , "* `asset_id` - The [`AssetId`] that will be exempt from affirmation." , "" , "# Events" , "* `AssetAffirmationExemption` - When the asset is successfully exempted from affirmation." ,] } , Self :: remove_asset_affirmation_exemption { .. } => { & ["Removes the pre-approval of the asset for all identities." , "" , "This function allows the root origin to remove the pre-approval of an asset for all identities." , "" , "# Arguments" , "* `origin` - The root origin." , "* `asset_id` - The [`AssetId`] that will have its exemption removed." , "" , "# Events" , "* `RemoveAssetAffirmationExemption` - When the asset's affirmation exemption is successfully removed." ,] } , Self :: pre_approve_asset { .. } => { & ["Pre-approves the receivement of an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] that will be exempt from affirmation." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `PreApprovedAsset` - When the asset is successfully pre-approved for receivement." ,] } , Self :: remove_asset_pre_approval { .. } => { & ["Removes the pre-approval of an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] that will have its exemption removed." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `RemovePreApprovedAsset` - When the asset's pre-approval is successfully removed." ,] } , Self :: add_mandatory_mediators { .. } => { & ["Sets all identities in the `mediators` set as mandatory mediators for any instruction transferring `asset_id`." , "" , "This function allows the asset issuer or an external agent to add mandatory mediators for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] of the asset that will require the mediators." , "* `mediators` - A set of [`IdentityId`] of all the mandatory mediators for the given ticker." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetMediatorsAdded` - When the mandatory mediators are successfully added." , "" , "# Errors" , "* `NumberOfAssetMediatorsExceeded` - If the number of mandatory mediators exceeds the maximum allowed limit." ,] } , Self :: remove_mandatory_mediators { .. } => { & ["Removes all identities in the `mediators` set from the mandatory mediators list for the given `asset_id`." , "" , "This function allows the asset issuer or an external agent to remove mandatory mediators for an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_id` - The [`AssetId`] of the asset that will have mediators removed." , "* `mediators` - A set of [`IdentityId`] of all the mediators that will be removed from the mandatory mediators list." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `AssetMediatorsRemoved` - When the mandatory mediators are successfully removed." ,] } , Self :: link_ticker_to_asset_id { .. } => { & ["Establishes a connection between a ticker and an AssetId." , "" , "This function allows the asset issuer or an external agent to link a ticker to an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `ticker` - The [`Ticker`] that will be linked to the given `asset_id`." , "* `asset_id` - The [`AssetId`] that will be connected to `ticker`." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `TickerLinkedToAsset` - When the ticker is successfully linked to the asset." , "" , "# Errors" , "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller." , "* `TickerRegistrationExpired` - If the ticker registration has expired." , "* `TickerRegistrationNotFound` - If the ticker registration is not found." , "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset." , "* `AssetIsAlreadyLinkedToATicker` - If the asset is already linked to a ticker." ,] } , Self :: unlink_ticker_from_asset_id { .. } => { & ["Removes the link between a ticker and an asset." , "" , "This function allows the asset issuer or an external agent to unlink a ticker from an asset." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `ticker` - The [`Ticker`] that will be unlinked from the given `asset_id`." , "* `asset_id` - The [`AssetId`] that will be unlinked from `ticker`." , "" , "# Permissions" , "* Asset" , "" , "# Events" , "* `TickerUnlinkedFromAsset` - When the ticker is successfully unlinked from the asset." , "" , "# Errors" , "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller." , "* `TickerRegistrationNotFound` - If the ticker registration is not found." , "* `TickerIsNotLinkedToTheAsset` - If the ticker is not linked to the asset." ,] } , Self :: update_global_metadata_spec { .. } => { & ["Updates the global metadata specification." , "" , "# Arguments" , "* `origin` - The origin of the call, which can be the primary or secondary key of an identity." , "* `asset_metadata_name` - The [`AssetMetadataName`] associated with the global metadata." , "* `asset_metadata_spec` - The new [`AssetMetadataSpec`] that will be associated with the global metadata." , "" , "# Events" , "* `GlobalMetadataSpecUpdated` - When the global metadata specification is successfully updated." , "" , "# Errors" , "* `BadOrigin` - If the origin is not authorized." , "* `TooLong` - If the metadata url or description length exceeds the maximum allowed length." , "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length." ,] } , _ => & [""] , }
                }
            }
            impl From<AssetCall> for &'static str {
                fn from(v: AssetCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&AssetCall> for &'static str {
                fn from(v: &AssetCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AssetError {
                #[doc = "The user is not authorized."]
                #[codec(index = 0u8)]
                Unauthorized,
                #[doc = "The token has already been created."]
                #[codec(index = 1u8)]
                AssetAlreadyCreated,
                #[doc = "The ticker length is over the limit."]
                #[codec(index = 2u8)]
                TickerTooLong,
                #[doc = "The ticker has non-alphanumeric parts."]
                #[codec(index = 3u8)]
                TickerNotAlphanumeric,
                #[doc = "The ticker is already registered to someone else."]
                #[codec(index = 4u8)]
                TickerAlreadyRegistered,
                #[doc = "The total supply is above the limit."]
                #[codec(index = 5u8)]
                TotalSupplyAboveLimit,
                #[doc = "No token associated to the given asset ID."]
                #[codec(index = 6u8)]
                NoSuchAsset,
                #[doc = "The token is already frozen."]
                #[codec(index = 7u8)]
                AlreadyFrozen,
                #[doc = "Not an owner of the token on Ethereum."]
                #[codec(index = 8u8)]
                NotAnOwner,
                #[doc = "An overflow while calculating the balance."]
                #[codec(index = 9u8)]
                BalanceOverflow,
                #[doc = "An overflow while calculating the total supply."]
                #[codec(index = 10u8)]
                TotalSupplyOverflow,
                #[doc = "An invalid granularity."]
                #[codec(index = 11u8)]
                InvalidGranularity,
                #[doc = "The asset must be frozen."]
                #[codec(index = 12u8)]
                NotFrozen,
                #[doc = "Transfer validation check failed."]
                #[codec(index = 13u8)]
                InvalidTransfer,
                #[doc = "The sender balance is not sufficient."]
                #[codec(index = 14u8)]
                InsufficientBalance,
                #[doc = "The token is already divisible."]
                #[codec(index = 15u8)]
                AssetAlreadyDivisible,
                #[doc = "An invalid Ethereum `EcdsaSignature`."]
                #[codec(index = 16u8)]
                InvalidEthereumSignature,
                #[doc = "Registration of ticker has expired."]
                #[codec(index = 17u8)]
                TickerRegistrationExpired,
                #[doc = "Transfers to self are not allowed"]
                #[codec(index = 18u8)]
                SenderSameAsReceiver,
                #[doc = "The given Document does not exist."]
                #[codec(index = 19u8)]
                NoSuchDoc,
                #[doc = "Maximum length of asset name has been exceeded."]
                #[codec(index = 20u8)]
                MaxLengthOfAssetNameExceeded,
                #[doc = "Maximum length of the funding round name has been exceeded."]
                #[codec(index = 21u8)]
                FundingRoundNameMaxLengthExceeded,
                #[doc = "Some `AssetIdentifier` was invalid."]
                #[codec(index = 22u8)]
                InvalidAssetIdentifier,
                #[doc = "Investor Uniqueness claims are not allowed for this asset."]
                #[codec(index = 23u8)]
                InvestorUniquenessClaimNotAllowed,
                #[doc = "Invalid `CustomAssetTypeId`."]
                #[codec(index = 24u8)]
                InvalidCustomAssetTypeId,
                #[doc = "Maximum length of the asset metadata type name has been exceeded."]
                #[codec(index = 25u8)]
                AssetMetadataNameMaxLengthExceeded,
                #[doc = "Maximum length of the asset metadata value has been exceeded."]
                #[codec(index = 26u8)]
                AssetMetadataValueMaxLengthExceeded,
                #[doc = "Maximum length of the asset metadata type definition has been exceeded."]
                #[codec(index = 27u8)]
                AssetMetadataTypeDefMaxLengthExceeded,
                #[doc = "Asset Metadata key is missing."]
                #[codec(index = 28u8)]
                AssetMetadataKeyIsMissing,
                #[doc = "Asset Metadata value is locked."]
                #[codec(index = 29u8)]
                AssetMetadataValueIsLocked,
                #[doc = "Asset Metadata Local type already exists for asset."]
                #[codec(index = 30u8)]
                AssetMetadataLocalKeyAlreadyExists,
                #[doc = "Asset Metadata Global type already exists."]
                #[codec(index = 31u8)]
                AssetMetadataGlobalKeyAlreadyExists,
                #[doc = "Tickers should start with at least one valid byte."]
                #[codec(index = 32u8)]
                TickerFirstByteNotValid,
                #[doc = "Attempt to call an extrinsic that is only permitted for fungible tokens."]
                #[codec(index = 33u8)]
                UnexpectedNonFungibleToken,
                #[doc = "Attempt to update the type of a non fungible token to a fungible token or the other way around."]
                #[codec(index = 34u8)]
                IncompatibleAssetTypeUpdate,
                #[doc = "Attempt to delete a key that is needed for an NFT collection."]
                #[codec(index = 35u8)]
                AssetMetadataKeyBelongsToNFTCollection,
                #[doc = "Attempt to lock a metadata value that is empty."]
                #[codec(index = 36u8)]
                AssetMetadataValueIsEmpty,
                #[doc = "Number of asset mediators would exceed the maximum allowed."]
                #[codec(index = 37u8)]
                NumberOfAssetMediatorsExceeded,
                #[doc = "Invalid ticker character - valid set: A`..`Z` `0`..`9` `_` `-` `.` `/`."]
                #[codec(index = 38u8)]
                InvalidTickerCharacter,
                #[doc = "Failed to transfer the asset - asset is frozen."]
                #[codec(index = 39u8)]
                InvalidTransferFrozenAsset,
                #[doc = "Failed to transfer an NFT - compliance failed."]
                #[codec(index = 40u8)]
                InvalidTransferComplianceFailure,
                #[doc = "Failed to transfer the asset - receiver cdd is not valid."]
                #[codec(index = 41u8)]
                InvalidTransferInvalidReceiverCDD,
                #[doc = "Failed to transfer the asset - sender cdd is not valid."]
                #[codec(index = 42u8)]
                InvalidTransferInvalidSenderCDD,
                #[doc = "The ticker registration associated to the ticker was not found."]
                #[codec(index = 43u8)]
                TickerRegistrationNotFound,
                #[doc = "The given ticker is already linked to an asset."]
                #[codec(index = 44u8)]
                TickerIsAlreadyLinkedToAnAsset,
                #[doc = "An unexpected error when generating a new asset ID."]
                #[codec(index = 45u8)]
                AssetIdGenerationError,
                #[doc = "The ticker doesn't belong to the caller."]
                #[codec(index = 46u8)]
                TickerNotRegisteredToCaller,
                #[doc = "The given asset is already linked to a ticker."]
                #[codec(index = 47u8)]
                AssetIsAlreadyLinkedToATicker,
                #[doc = "The given ticker is not linked to the given asset."]
                #[codec(index = 48u8)]
                TickerIsNotLinkedToTheAsset,
                #[doc = "The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is."]
                #[codec(index = 49u8)]
                BadAuthorizationType,
            }
            impl AssetError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Unauthorized => "Asset.Unauthorized",
                        Self::AssetAlreadyCreated => "Asset.AssetAlreadyCreated",
                        Self::TickerTooLong => "Asset.TickerTooLong",
                        Self::TickerNotAlphanumeric => "Asset.TickerNotAlphanumeric",
                        Self::TickerAlreadyRegistered => "Asset.TickerAlreadyRegistered",
                        Self::TotalSupplyAboveLimit => "Asset.TotalSupplyAboveLimit",
                        Self::NoSuchAsset => "Asset.NoSuchAsset",
                        Self::AlreadyFrozen => "Asset.AlreadyFrozen",
                        Self::NotAnOwner => "Asset.NotAnOwner",
                        Self::BalanceOverflow => "Asset.BalanceOverflow",
                        Self::TotalSupplyOverflow => "Asset.TotalSupplyOverflow",
                        Self::InvalidGranularity => "Asset.InvalidGranularity",
                        Self::NotFrozen => "Asset.NotFrozen",
                        Self::InvalidTransfer => "Asset.InvalidTransfer",
                        Self::InsufficientBalance => "Asset.InsufficientBalance",
                        Self::AssetAlreadyDivisible => "Asset.AssetAlreadyDivisible",
                        Self::InvalidEthereumSignature => "Asset.InvalidEthereumSignature",
                        Self::TickerRegistrationExpired => "Asset.TickerRegistrationExpired",
                        Self::SenderSameAsReceiver => "Asset.SenderSameAsReceiver",
                        Self::NoSuchDoc => "Asset.NoSuchDoc",
                        Self::MaxLengthOfAssetNameExceeded => "Asset.MaxLengthOfAssetNameExceeded",
                        Self::FundingRoundNameMaxLengthExceeded => {
                            "Asset.FundingRoundNameMaxLengthExceeded"
                        }
                        Self::InvalidAssetIdentifier => "Asset.InvalidAssetIdentifier",
                        Self::InvestorUniquenessClaimNotAllowed => {
                            "Asset.InvestorUniquenessClaimNotAllowed"
                        }
                        Self::InvalidCustomAssetTypeId => "Asset.InvalidCustomAssetTypeId",
                        Self::AssetMetadataNameMaxLengthExceeded => {
                            "Asset.AssetMetadataNameMaxLengthExceeded"
                        }
                        Self::AssetMetadataValueMaxLengthExceeded => {
                            "Asset.AssetMetadataValueMaxLengthExceeded"
                        }
                        Self::AssetMetadataTypeDefMaxLengthExceeded => {
                            "Asset.AssetMetadataTypeDefMaxLengthExceeded"
                        }
                        Self::AssetMetadataKeyIsMissing => "Asset.AssetMetadataKeyIsMissing",
                        Self::AssetMetadataValueIsLocked => "Asset.AssetMetadataValueIsLocked",
                        Self::AssetMetadataLocalKeyAlreadyExists => {
                            "Asset.AssetMetadataLocalKeyAlreadyExists"
                        }
                        Self::AssetMetadataGlobalKeyAlreadyExists => {
                            "Asset.AssetMetadataGlobalKeyAlreadyExists"
                        }
                        Self::TickerFirstByteNotValid => "Asset.TickerFirstByteNotValid",
                        Self::UnexpectedNonFungibleToken => "Asset.UnexpectedNonFungibleToken",
                        Self::IncompatibleAssetTypeUpdate => "Asset.IncompatibleAssetTypeUpdate",
                        Self::AssetMetadataKeyBelongsToNFTCollection => {
                            "Asset.AssetMetadataKeyBelongsToNFTCollection"
                        }
                        Self::AssetMetadataValueIsEmpty => "Asset.AssetMetadataValueIsEmpty",
                        Self::NumberOfAssetMediatorsExceeded => {
                            "Asset.NumberOfAssetMediatorsExceeded"
                        }
                        Self::InvalidTickerCharacter => "Asset.InvalidTickerCharacter",
                        Self::InvalidTransferFrozenAsset => "Asset.InvalidTransferFrozenAsset",
                        Self::InvalidTransferComplianceFailure => {
                            "Asset.InvalidTransferComplianceFailure"
                        }
                        Self::InvalidTransferInvalidReceiverCDD => {
                            "Asset.InvalidTransferInvalidReceiverCDD"
                        }
                        Self::InvalidTransferInvalidSenderCDD => {
                            "Asset.InvalidTransferInvalidSenderCDD"
                        }
                        Self::TickerRegistrationNotFound => "Asset.TickerRegistrationNotFound",
                        Self::TickerIsAlreadyLinkedToAnAsset => {
                            "Asset.TickerIsAlreadyLinkedToAnAsset"
                        }
                        Self::AssetIdGenerationError => "Asset.AssetIdGenerationError",
                        Self::TickerNotRegisteredToCaller => "Asset.TickerNotRegisteredToCaller",
                        Self::AssetIsAlreadyLinkedToATicker => {
                            "Asset.AssetIsAlreadyLinkedToATicker"
                        }
                        Self::TickerIsNotLinkedToTheAsset => "Asset.TickerIsNotLinkedToTheAsset",
                        Self::BadAuthorizationType => "Asset.BadAuthorizationType",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for AssetError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: Unauthorized => { & ["The user is not authorized." ,] } , Self :: AssetAlreadyCreated => { & ["The token has already been created." ,] } , Self :: TickerTooLong => { & ["The ticker length is over the limit." ,] } , Self :: TickerNotAlphanumeric => { & ["The ticker has non-alphanumeric parts." ,] } , Self :: TickerAlreadyRegistered => { & ["The ticker is already registered to someone else." ,] } , Self :: TotalSupplyAboveLimit => { & ["The total supply is above the limit." ,] } , Self :: NoSuchAsset => { & ["No token associated to the given asset ID." ,] } , Self :: AlreadyFrozen => { & ["The token is already frozen." ,] } , Self :: NotAnOwner => { & ["Not an owner of the token on Ethereum." ,] } , Self :: BalanceOverflow => { & ["An overflow while calculating the balance." ,] } , Self :: TotalSupplyOverflow => { & ["An overflow while calculating the total supply." ,] } , Self :: InvalidGranularity => { & ["An invalid granularity." ,] } , Self :: NotFrozen => { & ["The asset must be frozen." ,] } , Self :: InvalidTransfer => { & ["Transfer validation check failed." ,] } , Self :: InsufficientBalance => { & ["The sender balance is not sufficient." ,] } , Self :: AssetAlreadyDivisible => { & ["The token is already divisible." ,] } , Self :: InvalidEthereumSignature => { & ["An invalid Ethereum `EcdsaSignature`." ,] } , Self :: TickerRegistrationExpired => { & ["Registration of ticker has expired." ,] } , Self :: SenderSameAsReceiver => { & ["Transfers to self are not allowed" ,] } , Self :: NoSuchDoc => { & ["The given Document does not exist." ,] } , Self :: MaxLengthOfAssetNameExceeded => { & ["Maximum length of asset name has been exceeded." ,] } , Self :: FundingRoundNameMaxLengthExceeded => { & ["Maximum length of the funding round name has been exceeded." ,] } , Self :: InvalidAssetIdentifier => { & ["Some `AssetIdentifier` was invalid." ,] } , Self :: InvestorUniquenessClaimNotAllowed => { & ["Investor Uniqueness claims are not allowed for this asset." ,] } , Self :: InvalidCustomAssetTypeId => { & ["Invalid `CustomAssetTypeId`." ,] } , Self :: AssetMetadataNameMaxLengthExceeded => { & ["Maximum length of the asset metadata type name has been exceeded." ,] } , Self :: AssetMetadataValueMaxLengthExceeded => { & ["Maximum length of the asset metadata value has been exceeded." ,] } , Self :: AssetMetadataTypeDefMaxLengthExceeded => { & ["Maximum length of the asset metadata type definition has been exceeded." ,] } , Self :: AssetMetadataKeyIsMissing => { & ["Asset Metadata key is missing." ,] } , Self :: AssetMetadataValueIsLocked => { & ["Asset Metadata value is locked." ,] } , Self :: AssetMetadataLocalKeyAlreadyExists => { & ["Asset Metadata Local type already exists for asset." ,] } , Self :: AssetMetadataGlobalKeyAlreadyExists => { & ["Asset Metadata Global type already exists." ,] } , Self :: TickerFirstByteNotValid => { & ["Tickers should start with at least one valid byte." ,] } , Self :: UnexpectedNonFungibleToken => { & ["Attempt to call an extrinsic that is only permitted for fungible tokens." ,] } , Self :: IncompatibleAssetTypeUpdate => { & ["Attempt to update the type of a non fungible token to a fungible token or the other way around." ,] } , Self :: AssetMetadataKeyBelongsToNFTCollection => { & ["Attempt to delete a key that is needed for an NFT collection." ,] } , Self :: AssetMetadataValueIsEmpty => { & ["Attempt to lock a metadata value that is empty." ,] } , Self :: NumberOfAssetMediatorsExceeded => { & ["Number of asset mediators would exceed the maximum allowed." ,] } , Self :: InvalidTickerCharacter => { & ["Invalid ticker character - valid set: A`..`Z` `0`..`9` `_` `-` `.` `/`." ,] } , Self :: InvalidTransferFrozenAsset => { & ["Failed to transfer the asset - asset is frozen." ,] } , Self :: InvalidTransferComplianceFailure => { & ["Failed to transfer an NFT - compliance failed." ,] } , Self :: InvalidTransferInvalidReceiverCDD => { & ["Failed to transfer the asset - receiver cdd is not valid." ,] } , Self :: InvalidTransferInvalidSenderCDD => { & ["Failed to transfer the asset - sender cdd is not valid." ,] } , Self :: TickerRegistrationNotFound => { & ["The ticker registration associated to the ticker was not found." ,] } , Self :: TickerIsAlreadyLinkedToAnAsset => { & ["The given ticker is already linked to an asset." ,] } , Self :: AssetIdGenerationError => { & ["An unexpected error when generating a new asset ID." ,] } , Self :: TickerNotRegisteredToCaller => { & ["The ticker doesn't belong to the caller." ,] } , Self :: AssetIsAlreadyLinkedToATicker => { & ["The given asset is already linked to a ticker." ,] } , Self :: TickerIsNotLinkedToTheAsset => { & ["The given ticker is not linked to the given asset." ,] } , Self :: BadAuthorizationType => { & ["The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is." ,] } , _ => & [""] , }
                }
            }
            impl From<AssetError> for &'static str {
                fn from(v: AssetError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&AssetError> for &'static str {
                fn from(v: &AssetError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AssetEvent {
                #[doc = "Event for creation of the asset."]
                #[doc = "caller DID/ owner DID, AssetId, divisibility, asset type, beneficiary DID, asset name, identifiers, funding round"]
                #[codec(index = 0u8)]
                AssetCreated(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    bool,
                    polymesh_primitives::asset::AssetType,
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::asset::AssetName,
                    ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
                    Option<polymesh_primitives::asset::FundingRoundName>,
                ),
                #[doc = "Event emitted when any token identifiers are updated."]
                #[doc = "caller DID, AssetId, a vector of (identifier type, identifier value)"]
                #[codec(index = 1u8)]
                IdentifiersUpdated(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::alloc::vec::Vec<polymesh_primitives::asset_identifier::AssetIdentifier>,
                ),
                #[doc = "Event for change in divisibility."]
                #[doc = "caller DID, AssetId, divisibility"]
                #[codec(index = 2u8)]
                DivisibilityChanged(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    bool,
                ),
                #[doc = "Emit when ticker is registered."]
                #[doc = "caller DID / ticker owner did, ticker, ticker owner, expiry"]
                #[codec(index = 3u8)]
                TickerRegistered(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::ticker::Ticker,
                    Option<u64>,
                ),
                #[doc = "Emit when ticker is transferred."]
                #[doc = "caller DID / ticker transferred to DID, ticker, from"]
                #[codec(index = 4u8)]
                TickerTransferred(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::ticker::Ticker,
                    ::polymesh_api_client::IdentityId,
                ),
                #[doc = "Emit when token ownership is transferred."]
                #[doc = "caller DID / token ownership transferred to DID, AssetId, from"]
                #[codec(index = 5u8)]
                AssetOwnershipTransferred(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::polymesh_api_client::IdentityId,
                ),
                #[doc = "An event emitted when an asset is frozen."]
                #[doc = "Parameter: caller DID, AssetId."]
                #[codec(index = 6u8)]
                AssetFrozen(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "An event emitted when an asset is unfrozen."]
                #[doc = "Parameter: caller DID, AssetId."]
                #[codec(index = 7u8)]
                AssetUnfrozen(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "An event emitted when a token is renamed."]
                #[doc = "Parameters: caller DID, AssetId, new token name."]
                #[codec(index = 8u8)]
                AssetRenamed(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::asset::AssetName,
                ),
                #[doc = "An event carrying the name of the current funding round of an asset."]
                #[doc = "Parameters: caller DID, AssetId, funding round name."]
                #[codec(index = 9u8)]
                FundingRoundSet(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::asset::FundingRoundName,
                ),
                #[doc = "A new document attached to an asset"]
                #[codec(index = 10u8)]
                DocumentAdded(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::document::DocumentId,
                    polymesh_primitives::document::Document,
                ),
                #[doc = "A document removed from an asset"]
                #[codec(index = 11u8)]
                DocumentRemoved(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::document::DocumentId,
                ),
                #[doc = "Event for when a forced transfer takes place."]
                #[doc = "caller DID/ controller DID, ExtensionRemoved, Portfolio of token holder, value."]
                #[codec(index = 12u8)]
                ControllerTransfer(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::identity_id::PortfolioId,
                    u128,
                ),
                #[doc = "A custom asset type already exists on-chain."]
                #[doc = "caller DID, the ID of the custom asset type, the string contents registered."]
                #[codec(index = 13u8)]
                CustomAssetTypeExists(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::asset::CustomAssetTypeId,
                    ::alloc::vec::Vec<u8>,
                ),
                #[doc = "A custom asset type was registered on-chain."]
                #[doc = "caller DID, the ID of the custom asset type, the string contents registered."]
                #[codec(index = 14u8)]
                CustomAssetTypeRegistered(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::asset::CustomAssetTypeId,
                    ::alloc::vec::Vec<u8>,
                ),
                #[doc = "Set asset metadata value."]
                #[doc = "(Caller DID, AssetId, metadata value, optional value details)"]
                #[codec(index = 15u8)]
                SetAssetMetadataValue(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::asset_metadata::AssetMetadataValue,
                    Option<polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
                ),
                #[doc = "Set asset metadata value details (expire, lock status)."]
                #[doc = "(Caller DID, AssetId, value details)"]
                #[codec(index = 16u8)]
                SetAssetMetadataValueDetails(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
                ),
                #[doc = "Register asset metadata local type."]
                #[doc = "(Caller DID, AssetId, Local type name, Local type key, type specs)"]
                #[codec(index = 17u8)]
                RegisterAssetMetadataLocalType(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::asset_metadata::AssetMetadataName,
                    polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
                    polymesh_primitives::asset_metadata::AssetMetadataSpec,
                ),
                #[doc = "Register asset metadata global type."]
                #[doc = "(Global type name, Global type key, type specs)"]
                #[codec(index = 18u8)]
                RegisterAssetMetadataGlobalType(
                    polymesh_primitives::asset_metadata::AssetMetadataName,
                    polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
                    polymesh_primitives::asset_metadata::AssetMetadataSpec,
                ),
                #[doc = "An event emitted when the type of an asset changed."]
                #[doc = "Parameters: caller DID, AssetId, new token type."]
                #[codec(index = 19u8)]
                AssetTypeChanged(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::asset::AssetType,
                ),
                #[doc = "An event emitted when a local metadata key has been removed."]
                #[doc = "Parameters: caller AssetId, Local type name"]
                #[codec(index = 20u8)]
                LocalMetadataKeyDeleted(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
                ),
                #[doc = "An event emitted when a local metadata value has been removed."]
                #[doc = "Parameters: caller AssetId, Local type name"]
                #[codec(index = 21u8)]
                MetadataValueDeleted(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::asset_metadata::AssetMetadataKey,
                ),
                #[doc = "Emitted when Tokens were issued, redeemed or transferred."]
                #[doc = "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`AssetId`] for the token, the balance that was issued/transferred/redeemed,"]
                #[doc = "the [`PortfolioId`] of the source, the [`PortfolioId`] of the destination and the [`PortfolioUpdateReason`]."]
                #[codec(index = 22u8)]
                AssetBalanceUpdated(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    u128,
                    Option<polymesh_primitives::identity_id::PortfolioId>,
                    Option<polymesh_primitives::identity_id::PortfolioId>,
                    polymesh_primitives::portfolio::PortfolioUpdateReason,
                ),
                #[doc = "An asset has been added to the list of pre aprroved receivement (valid for all identities)."]
                #[doc = "Parameters: [`AssetId`] of the pre approved asset."]
                #[codec(index = 23u8)]
                AssetAffirmationExemption(::polymesh_api_client::AssetId),
                #[doc = "An asset has been removed from the list of pre aprroved receivement (valid for all identities)."]
                #[doc = "Parameters: [`AssetId`] of the asset."]
                #[codec(index = 24u8)]
                RemoveAssetAffirmationExemption(::polymesh_api_client::AssetId),
                #[doc = "An identity has added an asset to the list of pre aprroved receivement."]
                #[doc = "Parameters: [`IdentityId`] of caller, [`AssetId`] of the pre approved asset."]
                #[codec(index = 25u8)]
                PreApprovedAsset(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "An identity has removed an asset to the list of pre aprroved receivement."]
                #[doc = "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset."]
                #[codec(index = 26u8)]
                RemovePreApprovedAsset(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "An identity has added mandatory mediators to an asset."]
                #[doc = "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset, the identity of all mediators added."]
                #[codec(index = 27u8)]
                AssetMediatorsAdded(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
                ),
                #[doc = "An identity has removed mediators from an asset."]
                #[doc = "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset, the identity of all mediators removed."]
                #[codec(index = 28u8)]
                AssetMediatorsRemoved(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
                ),
                #[doc = "An identity has linked a ticker to an asset."]
                #[doc = "Parameters: [`IdentityId`] of caller, [`Ticker`] of the asset, the asset identifier [`AssetId`]."]
                #[codec(index = 29u8)]
                TickerLinkedToAsset(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::ticker::Ticker,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "An identity has unlinked a ticker from an asset."]
                #[doc = "Parameters: [`IdentityId`] of caller, unlinked [`Ticker`], the asset identifier [`AssetId`]."]
                #[codec(index = 30u8)]
                TickerUnlinkedFromAsset(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::ticker::Ticker,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "Asset Global Metadata Spec has been Updated."]
                #[doc = "Parameters: [`AssetMetadataName`] of the metadata, [`AssetMetadataSpec`] of the metadata."]
                #[codec(index = 31u8)]
                GlobalMetadataSpecUpdated(
                    polymesh_primitives::asset_metadata::AssetMetadataName,
                    polymesh_primitives::asset_metadata::AssetMetadataSpec,
                ),
            }
            impl AssetEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::AssetCreated(_, _, _, _, _, _, _, _) => "Asset.AssetCreated",
                        Self::IdentifiersUpdated(_, _, _) => "Asset.IdentifiersUpdated",
                        Self::DivisibilityChanged(_, _, _) => "Asset.DivisibilityChanged",
                        Self::TickerRegistered(_, _, _) => "Asset.TickerRegistered",
                        Self::TickerTransferred(_, _, _) => "Asset.TickerTransferred",
                        Self::AssetOwnershipTransferred(_, _, _) => {
                            "Asset.AssetOwnershipTransferred"
                        }
                        Self::AssetFrozen(_, _) => "Asset.AssetFrozen",
                        Self::AssetUnfrozen(_, _) => "Asset.AssetUnfrozen",
                        Self::AssetRenamed(_, _, _) => "Asset.AssetRenamed",
                        Self::FundingRoundSet(_, _, _) => "Asset.FundingRoundSet",
                        Self::DocumentAdded(_, _, _, _) => "Asset.DocumentAdded",
                        Self::DocumentRemoved(_, _, _) => "Asset.DocumentRemoved",
                        Self::ControllerTransfer(_, _, _, _) => "Asset.ControllerTransfer",
                        Self::CustomAssetTypeExists(_, _, _) => "Asset.CustomAssetTypeExists",
                        Self::CustomAssetTypeRegistered(_, _, _) => {
                            "Asset.CustomAssetTypeRegistered"
                        }
                        Self::SetAssetMetadataValue(_, _, _, _) => "Asset.SetAssetMetadataValue",
                        Self::SetAssetMetadataValueDetails(_, _, _) => {
                            "Asset.SetAssetMetadataValueDetails"
                        }
                        Self::RegisterAssetMetadataLocalType(_, _, _, _, _) => {
                            "Asset.RegisterAssetMetadataLocalType"
                        }
                        Self::RegisterAssetMetadataGlobalType(_, _, _) => {
                            "Asset.RegisterAssetMetadataGlobalType"
                        }
                        Self::AssetTypeChanged(_, _, _) => "Asset.AssetTypeChanged",
                        Self::LocalMetadataKeyDeleted(_, _, _) => "Asset.LocalMetadataKeyDeleted",
                        Self::MetadataValueDeleted(_, _, _) => "Asset.MetadataValueDeleted",
                        Self::AssetBalanceUpdated(_, _, _, _, _, _) => "Asset.AssetBalanceUpdated",
                        Self::AssetAffirmationExemption(_) => "Asset.AssetAffirmationExemption",
                        Self::RemoveAssetAffirmationExemption(_) => {
                            "Asset.RemoveAssetAffirmationExemption"
                        }
                        Self::PreApprovedAsset(_, _) => "Asset.PreApprovedAsset",
                        Self::RemovePreApprovedAsset(_, _) => "Asset.RemovePreApprovedAsset",
                        Self::AssetMediatorsAdded(_, _, _) => "Asset.AssetMediatorsAdded",
                        Self::AssetMediatorsRemoved(_, _, _) => "Asset.AssetMediatorsRemoved",
                        Self::TickerLinkedToAsset(_, _, _) => "Asset.TickerLinkedToAsset",
                        Self::TickerUnlinkedFromAsset(_, _, _) => "Asset.TickerUnlinkedFromAsset",
                        Self::GlobalMetadataSpecUpdated(_, _) => "Asset.GlobalMetadataSpecUpdated",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for AssetEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: AssetCreated (_ , _ , _ , _ , _ , _ , _ , _) => { & ["Event for creation of the asset." , "caller DID/ owner DID, AssetId, divisibility, asset type, beneficiary DID, asset name, identifiers, funding round" ,] } , Self :: IdentifiersUpdated (_ , _ , _) => { & ["Event emitted when any token identifiers are updated." , "caller DID, AssetId, a vector of (identifier type, identifier value)" ,] } , Self :: DivisibilityChanged (_ , _ , _) => { & ["Event for change in divisibility." , "caller DID, AssetId, divisibility" ,] } , Self :: TickerRegistered (_ , _ , _) => { & ["Emit when ticker is registered." , "caller DID / ticker owner did, ticker, ticker owner, expiry" ,] } , Self :: TickerTransferred (_ , _ , _) => { & ["Emit when ticker is transferred." , "caller DID / ticker transferred to DID, ticker, from" ,] } , Self :: AssetOwnershipTransferred (_ , _ , _) => { & ["Emit when token ownership is transferred." , "caller DID / token ownership transferred to DID, AssetId, from" ,] } , Self :: AssetFrozen (_ , _) => { & ["An event emitted when an asset is frozen." , "Parameter: caller DID, AssetId." ,] } , Self :: AssetUnfrozen (_ , _) => { & ["An event emitted when an asset is unfrozen." , "Parameter: caller DID, AssetId." ,] } , Self :: AssetRenamed (_ , _ , _) => { & ["An event emitted when a token is renamed." , "Parameters: caller DID, AssetId, new token name." ,] } , Self :: FundingRoundSet (_ , _ , _) => { & ["An event carrying the name of the current funding round of an asset." , "Parameters: caller DID, AssetId, funding round name." ,] } , Self :: DocumentAdded (_ , _ , _ , _) => { & ["A new document attached to an asset" ,] } , Self :: DocumentRemoved (_ , _ , _) => { & ["A document removed from an asset" ,] } , Self :: ControllerTransfer (_ , _ , _ , _) => { & ["Event for when a forced transfer takes place." , "caller DID/ controller DID, ExtensionRemoved, Portfolio of token holder, value." ,] } , Self :: CustomAssetTypeExists (_ , _ , _) => { & ["A custom asset type already exists on-chain." , "caller DID, the ID of the custom asset type, the string contents registered." ,] } , Self :: CustomAssetTypeRegistered (_ , _ , _) => { & ["A custom asset type was registered on-chain." , "caller DID, the ID of the custom asset type, the string contents registered." ,] } , Self :: SetAssetMetadataValue (_ , _ , _ , _) => { & ["Set asset metadata value." , "(Caller DID, AssetId, metadata value, optional value details)" ,] } , Self :: SetAssetMetadataValueDetails (_ , _ , _) => { & ["Set asset metadata value details (expire, lock status)." , "(Caller DID, AssetId, value details)" ,] } , Self :: RegisterAssetMetadataLocalType (_ , _ , _ , _ , _) => { & ["Register asset metadata local type." , "(Caller DID, AssetId, Local type name, Local type key, type specs)" ,] } , Self :: RegisterAssetMetadataGlobalType (_ , _ , _) => { & ["Register asset metadata global type." , "(Global type name, Global type key, type specs)" ,] } , Self :: AssetTypeChanged (_ , _ , _) => { & ["An event emitted when the type of an asset changed." , "Parameters: caller DID, AssetId, new token type." ,] } , Self :: LocalMetadataKeyDeleted (_ , _ , _) => { & ["An event emitted when a local metadata key has been removed." , "Parameters: caller AssetId, Local type name" ,] } , Self :: MetadataValueDeleted (_ , _ , _) => { & ["An event emitted when a local metadata value has been removed." , "Parameters: caller AssetId, Local type name" ,] } , Self :: AssetBalanceUpdated (_ , _ , _ , _ , _ , _) => { & ["Emitted when Tokens were issued, redeemed or transferred." , "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`AssetId`] for the token, the balance that was issued/transferred/redeemed," , "the [`PortfolioId`] of the source, the [`PortfolioId`] of the destination and the [`PortfolioUpdateReason`]." ,] } , Self :: AssetAffirmationExemption (_) => { & ["An asset has been added to the list of pre aprroved receivement (valid for all identities)." , "Parameters: [`AssetId`] of the pre approved asset." ,] } , Self :: RemoveAssetAffirmationExemption (_) => { & ["An asset has been removed from the list of pre aprroved receivement (valid for all identities)." , "Parameters: [`AssetId`] of the asset." ,] } , Self :: PreApprovedAsset (_ , _) => { & ["An identity has added an asset to the list of pre aprroved receivement." , "Parameters: [`IdentityId`] of caller, [`AssetId`] of the pre approved asset." ,] } , Self :: RemovePreApprovedAsset (_ , _) => { & ["An identity has removed an asset to the list of pre aprroved receivement." , "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset." ,] } , Self :: AssetMediatorsAdded (_ , _ , _) => { & ["An identity has added mandatory mediators to an asset." , "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset, the identity of all mediators added." ,] } , Self :: AssetMediatorsRemoved (_ , _ , _) => { & ["An identity has removed mediators from an asset." , "Parameters: [`IdentityId`] of caller, [`AssetId`] of the asset, the identity of all mediators removed." ,] } , Self :: TickerLinkedToAsset (_ , _ , _) => { & ["An identity has linked a ticker to an asset." , "Parameters: [`IdentityId`] of caller, [`Ticker`] of the asset, the asset identifier [`AssetId`]." ,] } , Self :: TickerUnlinkedFromAsset (_ , _ , _) => { & ["An identity has unlinked a ticker from an asset." , "Parameters: [`IdentityId`] of caller, unlinked [`Ticker`], the asset identifier [`AssetId`]." ,] } , Self :: GlobalMetadataSpecUpdated (_ , _) => { & ["Asset Global Metadata Spec has been Updated." , "Parameters: [`AssetMetadataName`] of the metadata, [`AssetMetadataSpec`] of the metadata." ,] } , _ => & [""] , }
                }
            }
            impl From<AssetEvent> for &'static str {
                fn from(v: AssetEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&AssetEvent> for &'static str {
                fn from(v: &AssetEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        pub mod types {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetDetails {
                pub total_supply: u128,
                pub owner_did: ::polymesh_api_client::IdentityId,
                pub divisible: bool,
                pub asset_type: polymesh_primitives::asset::AssetType,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct TickerRegistration<T> {
                pub owner: ::polymesh_api_client::IdentityId,
                pub expiry: Option<T>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct TickerRegistrationConfig<T> {
                pub max_ticker_length: u8,
                pub registration_length: Option<T>,
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Version(pub u8);
    }
    pub mod pallet_babe {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum BabeCall {
                #[doc = "Report authority equivocation/misbehavior. This method will verify"]
                #[doc = "the equivocation proof and validate the given key ownership proof"]
                #[doc = "against the extracted offender. If both are valid, the offence will"]
                #[doc = "be reported."]
                #[codec(index = 0u8)]
                report_equivocation {
                    equivocation_proof: ::alloc::boxed::Box<
                        sp_consensus_slots::EquivocationProof<
                            sp_runtime::generic::header::Header<u32>,
                            sp_consensus_babe::app::Public,
                        >,
                    >,
                    key_owner_proof: sp_session::MembershipProof,
                },
                #[doc = "Report authority equivocation/misbehavior. This method will verify"]
                #[doc = "the equivocation proof and validate the given key ownership proof"]
                #[doc = "against the extracted offender. If both are valid, the offence will"]
                #[doc = "be reported."]
                #[doc = "This extrinsic must be called unsigned and it is expected that only"]
                #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
                #[doc = "if the block author is defined it will be defined as the equivocation"]
                #[doc = "reporter."]
                #[codec(index = 1u8)]
                report_equivocation_unsigned {
                    equivocation_proof: ::alloc::boxed::Box<
                        sp_consensus_slots::EquivocationProof<
                            sp_runtime::generic::header::Header<u32>,
                            sp_consensus_babe::app::Public,
                        >,
                    >,
                    key_owner_proof: sp_session::MembershipProof,
                },
                #[doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"]
                #[doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."]
                #[doc = "Multiple calls to this method will replace any existing planned config change that had"]
                #[doc = "not been enacted yet."]
                #[codec(index = 2u8)]
                plan_config_change {
                    config: sp_consensus_babe::digests::NextConfigDescriptor,
                },
            }
            impl BabeCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::report_equivocation { .. } => "Babe.report_equivocation",
                        Self::report_equivocation_unsigned { .. } => {
                            "Babe.report_equivocation_unsigned"
                        }
                        Self::plan_config_change { .. } => "Babe.plan_config_change",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for BabeCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: report_equivocation { .. } => { & ["Report authority equivocation/misbehavior. This method will verify" , "the equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence will" , "be reported." ,] } , Self :: report_equivocation_unsigned { .. } => { & ["Report authority equivocation/misbehavior. This method will verify" , "the equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence will" , "be reported." , "This extrinsic must be called unsigned and it is expected that only" , "block authors will call it (validated in `ValidateUnsigned`), as such" , "if the block author is defined it will be defined as the equivocation" , "reporter." ,] } , Self :: plan_config_change { .. } => { & ["Plan an epoch config change. The epoch config change is recorded and will be enacted on" , "the next call to `enact_epoch_change`. The config will be activated one epoch after." , "Multiple calls to this method will replace any existing planned config change that had" , "not been enacted yet." ,] } , _ => & [""] , }
                }
            }
            impl From<BabeCall> for &'static str {
                fn from(v: BabeCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&BabeCall> for &'static str {
                fn from(v: &BabeCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum BabeError {
                #[doc = "An equivocation proof provided as part of an equivocation report is invalid."]
                #[codec(index = 0u8)]
                InvalidEquivocationProof,
                #[doc = "A key ownership proof provided as part of an equivocation report is invalid."]
                #[codec(index = 1u8)]
                InvalidKeyOwnershipProof,
                #[doc = "A given equivocation report is valid but already previously reported."]
                #[codec(index = 2u8)]
                DuplicateOffenceReport,
                #[doc = "Submitted configuration is invalid."]
                #[codec(index = 3u8)]
                InvalidConfiguration,
            }
            impl BabeError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InvalidEquivocationProof => "Babe.InvalidEquivocationProof",
                        Self::InvalidKeyOwnershipProof => "Babe.InvalidKeyOwnershipProof",
                        Self::DuplicateOffenceReport => "Babe.DuplicateOffenceReport",
                        Self::InvalidConfiguration => "Babe.InvalidConfiguration",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for BabeError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: InvalidEquivocationProof => { & ["An equivocation proof provided as part of an equivocation report is invalid." ,] } , Self :: InvalidKeyOwnershipProof => { & ["A key ownership proof provided as part of an equivocation report is invalid." ,] } , Self :: DuplicateOffenceReport => { & ["A given equivocation report is valid but already previously reported." ,] } , Self :: InvalidConfiguration => { & ["Submitted configuration is invalid." ,] } , _ => & [""] , }
                }
            }
            impl From<BabeError> for &'static str {
                fn from(v: BabeError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&BabeError> for &'static str {
                fn from(v: &BabeError) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_balances {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum BalancesCall {
                #[doc = "Transfer some liquid free balance to another account."]
                #[doc = ""]
                #[doc = "`transfer_allow_death` will set the `FreeBalance` of the sender and receiver."]
                #[doc = "If the sender's account is below the existential deposit as a result"]
                #[doc = "of the transfer, the account will be reaped."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
                #[codec(index = 0u8)]
                transfer_allow_death {
                    dest:
                        ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    #[codec(compact)]
                    value: u128,
                },
                #[doc = "Exactly as `transfer_allow_death`, except the origin must be root and the source account"]
                #[doc = "may be specified."]
                #[codec(index = 2u8)]
                force_transfer {
                    source:
                        ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    dest:
                        ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    #[codec(compact)]
                    value: u128,
                },
                #[doc = "Same as the [`transfer_allow_death`] call, but with a check that the transfer will not"]
                #[doc = "kill the origin account."]
                #[doc = ""]
                #[doc = "99% of the time you want [`transfer_allow_death`] instead."]
                #[doc = ""]
                #[doc = "[`transfer_allow_death`]: struct.Pallet.html#method.transfer"]
                #[codec(index = 3u8)]
                transfer_keep_alive {
                    dest:
                        ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    #[codec(compact)]
                    value: u128,
                },
                #[doc = "Transfer the entire transferable balance from the caller account."]
                #[doc = ""]
                #[doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"]
                #[doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"]
                #[doc = "transferred by this function. To ensure that this function results in a killed account,"]
                #[doc = "you might need to prepare the account by removing any reference counters, storage"]
                #[doc = "deposits, etc..."]
                #[doc = ""]
                #[doc = "The dispatch origin of this call must be Signed."]
                #[doc = ""]
                #[doc = "- `dest`: The recipient of the transfer."]
                #[doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"]
                #[doc = "  of the funds the account has, causing the sender account to be killed (false), or"]
                #[doc = "  transfer everything except at least the existential deposit, which will guarantee to"]
                #[doc = "  keep the sender account alive (true)."]
                #[codec(index = 4u8)]
                transfer_all {
                    dest:
                        ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    keep_alive: bool,
                },
                #[doc = "Unreserve some balance from a user by force."]
                #[doc = ""]
                #[doc = "Can only be called by ROOT."]
                #[codec(index = 5u8)]
                force_unreserve {
                    who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    amount: u128,
                },
                #[doc = "Upgrade a specified account."]
                #[doc = ""]
                #[doc = "- `origin`: Must be `Signed`."]
                #[doc = "- `who`: The account to be upgraded."]
                #[doc = ""]
                #[doc = "This will waive the transaction fee if at least all but 10% of the accounts needed to"]
                #[doc = "be upgraded. (We let some not have to be upgraded just in order to allow for the"]
                #[doc = "possibility of churn)."]
                #[codec(index = 6u8)]
                upgrade_accounts {
                    who: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "Set the regular balance of a given account."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call is `root`."]
                #[codec(index = 8u8)]
                force_set_balance {
                    who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    #[codec(compact)]
                    new_free: u128,
                },
                #[doc = "Adjust the total issuance in a saturating way."]
                #[doc = ""]
                #[doc = "Can only be called by root and always needs a positive `delta`."]
                #[doc = ""]
                #[doc = "# Example"]
                #[codec(index = 9u8)]
                force_adjust_total_issuance {
                    direction: pallet_balances::types::AdjustmentDirection,
                    #[codec(compact)]
                    delta: u128,
                },
                #[doc = "Burn the specified liquid free balance from the origin account."]
                #[doc = ""]
                #[doc = "If the origin's account ends up below the existential deposit as a result"]
                #[doc = "of the burn and `keep_alive` is false, the account will be reaped."]
                #[doc = ""]
                #[doc = "Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,"]
                #[doc = "this `burn` operation will reduce total issuance by the amount _burned_."]
                #[codec(index = 10u8)]
                burn {
                    #[codec(compact)]
                    value: u128,
                    keep_alive: bool,
                },
                #[doc = "Transfer some liquid free balance to another account."]
                #[doc = ""]
                #[doc = "`transfer` will set the `FreeBalance` of the sender and receiver."]
                #[doc = "If the sender's account is below the existential deposit as a result"]
                #[doc = "of the transfer, the account will be reaped."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- Dependent on arguments but not critical, given proper implementations for input config"]
                #[doc = "  types. See related functions below."]
                #[doc = "- It contains a limited number of reads and writes internally and no complex"]
                #[doc = "  computation."]
                #[doc = ""]
                #[doc = "Related functions:"]
                #[doc = ""]
                #[doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."]
                #[doc = "  - Transferring balances to accounts that did not exist before will cause"]
                #[doc = "    `T::OnNewAccount::on_new_account` to be called."]
                #[doc = "  - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`."]
                #[doc = "  - `transfer_keep_alive` works the same way as `transfer`, but has an additional check"]
                #[doc = "    that the transfer will not kill the origin account."]
                #[codec(index = 40u8)]
                transfer_with_memo {
                    dest:
                        ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    #[codec(compact)]
                    value: u128,
                    memo: Option<polymesh_primitives::Memo>,
                },
            }
            impl BalancesCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::transfer_allow_death { .. } => "Balances.transfer_allow_death",
                        Self::force_transfer { .. } => "Balances.force_transfer",
                        Self::transfer_keep_alive { .. } => "Balances.transfer_keep_alive",
                        Self::transfer_all { .. } => "Balances.transfer_all",
                        Self::force_unreserve { .. } => "Balances.force_unreserve",
                        Self::upgrade_accounts { .. } => "Balances.upgrade_accounts",
                        Self::force_set_balance { .. } => "Balances.force_set_balance",
                        Self::force_adjust_total_issuance { .. } => {
                            "Balances.force_adjust_total_issuance"
                        }
                        Self::burn { .. } => "Balances.burn",
                        Self::transfer_with_memo { .. } => "Balances.transfer_with_memo",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for BalancesCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: transfer_allow_death { .. } => { & ["Transfer some liquid free balance to another account." , "" , "`transfer_allow_death` will set the `FreeBalance` of the sender and receiver." , "If the sender's account is below the existential deposit as a result" , "of the transfer, the account will be reaped." , "" , "The dispatch origin for this call must be `Signed` by the transactor." ,] } , Self :: force_transfer { .. } => { & ["Exactly as `transfer_allow_death`, except the origin must be root and the source account" , "may be specified." ,] } , Self :: transfer_keep_alive { .. } => { & ["Same as the [`transfer_allow_death`] call, but with a check that the transfer will not" , "kill the origin account." , "" , "99% of the time you want [`transfer_allow_death`] instead." , "" , "[`transfer_allow_death`]: struct.Pallet.html#method.transfer" ,] } , Self :: transfer_all { .. } => { & ["Transfer the entire transferable balance from the caller account." , "" , "NOTE: This function only attempts to transfer _transferable_ balances. This means that" , "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be" , "transferred by this function. To ensure that this function results in a killed account," , "you might need to prepare the account by removing any reference counters, storage" , "deposits, etc..." , "" , "The dispatch origin of this call must be Signed." , "" , "- `dest`: The recipient of the transfer." , "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all" , "  of the funds the account has, causing the sender account to be killed (false), or" , "  transfer everything except at least the existential deposit, which will guarantee to" , "  keep the sender account alive (true)." ,] } , Self :: force_unreserve { .. } => { & ["Unreserve some balance from a user by force." , "" , "Can only be called by ROOT." ,] } , Self :: upgrade_accounts { .. } => { & ["Upgrade a specified account." , "" , "- `origin`: Must be `Signed`." , "- `who`: The account to be upgraded." , "" , "This will waive the transaction fee if at least all but 10% of the accounts needed to" , "be upgraded. (We let some not have to be upgraded just in order to allow for the" , "possibility of churn)." ,] } , Self :: force_set_balance { .. } => { & ["Set the regular balance of a given account." , "" , "The dispatch origin for this call is `root`." ,] } , Self :: force_adjust_total_issuance { .. } => { & ["Adjust the total issuance in a saturating way." , "" , "Can only be called by root and always needs a positive `delta`." , "" , "# Example" ,] } , Self :: burn { .. } => { & ["Burn the specified liquid free balance from the origin account." , "" , "If the origin's account ends up below the existential deposit as a result" , "of the burn and `keep_alive` is false, the account will be reaped." , "" , "Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible," , "this `burn` operation will reduce total issuance by the amount _burned_." ,] } , Self :: transfer_with_memo { .. } => { & ["Transfer some liquid free balance to another account." , "" , "`transfer` will set the `FreeBalance` of the sender and receiver." , "If the sender's account is below the existential deposit as a result" , "of the transfer, the account will be reaped." , "" , "The dispatch origin for this call must be `Signed` by the transactor." , "" , "## Complexity" , "- Dependent on arguments but not critical, given proper implementations for input config" , "  types. See related functions below." , "- It contains a limited number of reads and writes internally and no complex" , "  computation." , "" , "Related functions:" , "" , "  - `ensure_can_withdraw` is always called internally but has a bounded complexity." , "  - Transferring balances to accounts that did not exist before will cause" , "    `T::OnNewAccount::on_new_account` to be called." , "  - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`." , "  - `transfer_keep_alive` works the same way as `transfer`, but has an additional check" , "    that the transfer will not kill the origin account." ,] } , _ => & [""] , }
                }
            }
            impl From<BalancesCall> for &'static str {
                fn from(v: BalancesCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&BalancesCall> for &'static str {
                fn from(v: &BalancesCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum BalancesError {
                #[doc = "Vesting balance too high to send value."]
                #[codec(index = 0u8)]
                VestingBalance,
                #[doc = "Account liquidity restrictions prevent withdrawal."]
                #[codec(index = 1u8)]
                LiquidityRestrictions,
                #[doc = "Balance too low to send value."]
                #[codec(index = 2u8)]
                InsufficientBalance,
                #[doc = "Value too low to create account due to existential deposit."]
                #[codec(index = 3u8)]
                ExistentialDeposit,
                #[doc = "Transfer/payment would kill account."]
                #[codec(index = 4u8)]
                Expendability,
                #[doc = "A vesting schedule already exists for this account."]
                #[codec(index = 5u8)]
                ExistingVestingSchedule,
                #[doc = "Beneficiary account must pre-exist."]
                #[codec(index = 6u8)]
                DeadAccount,
                #[doc = "Number of named reserves exceed `MaxReserves`."]
                #[codec(index = 7u8)]
                TooManyReserves,
                #[doc = "Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`."]
                #[codec(index = 8u8)]
                TooManyHolds,
                #[doc = "Number of freezes exceed `MaxFreezes`."]
                #[codec(index = 9u8)]
                TooManyFreezes,
                #[doc = "The issuance cannot be modified since it is already deactivated."]
                #[codec(index = 10u8)]
                IssuanceDeactivated,
                #[doc = "The delta cannot be zero."]
                #[codec(index = 11u8)]
                DeltaZero,
                #[doc = "Lock Identifier not Found"]
                #[codec(index = 12u8)]
                LockIdentifierNotFound,
                #[doc = "Balance Overflow"]
                #[codec(index = 13u8)]
                Overflow,
                #[doc = "Max Locks Exceeded"]
                #[codec(index = 14u8)]
                MaxLocksExceeded,
            }
            impl BalancesError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::VestingBalance => "Balances.VestingBalance",
                        Self::LiquidityRestrictions => "Balances.LiquidityRestrictions",
                        Self::InsufficientBalance => "Balances.InsufficientBalance",
                        Self::ExistentialDeposit => "Balances.ExistentialDeposit",
                        Self::Expendability => "Balances.Expendability",
                        Self::ExistingVestingSchedule => "Balances.ExistingVestingSchedule",
                        Self::DeadAccount => "Balances.DeadAccount",
                        Self::TooManyReserves => "Balances.TooManyReserves",
                        Self::TooManyHolds => "Balances.TooManyHolds",
                        Self::TooManyFreezes => "Balances.TooManyFreezes",
                        Self::IssuanceDeactivated => "Balances.IssuanceDeactivated",
                        Self::DeltaZero => "Balances.DeltaZero",
                        Self::LockIdentifierNotFound => "Balances.LockIdentifierNotFound",
                        Self::Overflow => "Balances.Overflow",
                        Self::MaxLocksExceeded => "Balances.MaxLocksExceeded",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for BalancesError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::VestingBalance => &["Vesting balance too high to send value."],
                        Self::LiquidityRestrictions => {
                            &["Account liquidity restrictions prevent withdrawal."]
                        }
                        Self::InsufficientBalance => &["Balance too low to send value."],
                        Self::ExistentialDeposit => {
                            &["Value too low to create account due to existential deposit."]
                        }
                        Self::Expendability => &["Transfer/payment would kill account."],
                        Self::ExistingVestingSchedule => {
                            &["A vesting schedule already exists for this account."]
                        }
                        Self::DeadAccount => &["Beneficiary account must pre-exist."],
                        Self::TooManyReserves => {
                            &["Number of named reserves exceed `MaxReserves`."]
                        }
                        Self::TooManyHolds => {
                            &["Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`."]
                        }
                        Self::TooManyFreezes => &["Number of freezes exceed `MaxFreezes`."],
                        Self::IssuanceDeactivated => {
                            &["The issuance cannot be modified since it is already deactivated."]
                        }
                        Self::DeltaZero => &["The delta cannot be zero."],
                        Self::LockIdentifierNotFound => &["Lock Identifier not Found"],
                        Self::Overflow => &["Balance Overflow"],
                        Self::MaxLocksExceeded => &["Max Locks Exceeded"],
                        _ => &[""],
                    }
                }
            }
            impl From<BalancesError> for &'static str {
                fn from(v: BalancesError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&BalancesError> for &'static str {
                fn from(v: &BalancesError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum BalancesEvent {
                #[doc = "An account was created with some free balance."]
                #[codec(index = 0u8)]
                Endowed {
                    account: ::polymesh_api_client::AccountId,
                    free_balance: u128,
                },
                #[doc = "An account was removed whose balance was non-zero but below ExistentialDeposit,"]
                #[doc = "resulting in an outright loss."]
                #[codec(index = 1u8)]
                DustLost {
                    account: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Transfer succeeded."]
                #[codec(index = 2u8)]
                Transfer {
                    from: ::polymesh_api_client::AccountId,
                    to: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "A balance was set by root."]
                #[codec(index = 3u8)]
                BalanceSet {
                    who: ::polymesh_api_client::AccountId,
                    free: u128,
                },
                #[doc = "Some balance was reserved (moved from free to reserved)."]
                #[codec(index = 4u8)]
                Reserved {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some balance was unreserved (moved from reserved to free)."]
                #[codec(index = 5u8)]
                Unreserved {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some balance was moved from the reserve of the first account to the second account."]
                #[doc = "Final argument indicates the destination balance type."]
                #[codec(index = 6u8)]
                ReserveRepatriated {
                    from: ::polymesh_api_client::AccountId,
                    to: ::polymesh_api_client::AccountId,
                    amount: u128,
                    destination_status: frame_support::traits::tokens::misc::BalanceStatus,
                },
                #[doc = "Some amount was deposited (e.g. for transaction fees)."]
                #[codec(index = 7u8)]
                Deposit {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some amount was withdrawn from the account (e.g. for transaction fees)."]
                #[codec(index = 8u8)]
                Withdraw {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some amount was removed from the account (e.g. for misbehavior)."]
                #[codec(index = 9u8)]
                Slashed {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some amount was minted into an account."]
                #[codec(index = 10u8)]
                Minted {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some credit was balanced and added to the TotalIssuance."]
                #[codec(index = 11u8)]
                MintedCredit { amount: u128 },
                #[doc = "Some amount was burned from an account."]
                #[codec(index = 12u8)]
                Burned {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some debt has been dropped from the Total Issuance."]
                #[codec(index = 13u8)]
                BurnedDebt { amount: u128 },
                #[doc = "Some amount was suspended from an account (it can be restored later)."]
                #[codec(index = 14u8)]
                Suspended {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some amount was restored into an account."]
                #[codec(index = 15u8)]
                Restored {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "An account was upgraded."]
                #[codec(index = 16u8)]
                Upgraded {
                    who: ::polymesh_api_client::AccountId,
                },
                #[doc = "Total issuance was increased by `amount`, creating a credit to be balanced."]
                #[codec(index = 17u8)]
                Issued { amount: u128 },
                #[doc = "Total issuance was decreased by `amount`, creating a debt to be balanced."]
                #[codec(index = 18u8)]
                Rescinded { amount: u128 },
                #[doc = "Some balance was locked."]
                #[codec(index = 19u8)]
                Locked {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some balance was unlocked."]
                #[codec(index = 20u8)]
                Unlocked {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some balance was frozen."]
                #[codec(index = 21u8)]
                Frozen {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some balance was thawed."]
                #[codec(index = 22u8)]
                Thawed {
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "The `TotalIssuance` was forcefully changed."]
                #[codec(index = 23u8)]
                TotalIssuanceForced { old: u128, new: u128 },
                #[doc = "Some balance was placed on hold."]
                #[codec(index = 24u8)]
                Held {
                    reason: runtime::RuntimeHoldReason,
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Held balance was burned from an account."]
                #[codec(index = 25u8)]
                BurnedHeld {
                    reason: runtime::RuntimeHoldReason,
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "A transfer of `amount` on hold from `source` to `dest` was initiated."]
                #[codec(index = 26u8)]
                TransferOnHold {
                    reason: runtime::RuntimeHoldReason,
                    source: ::polymesh_api_client::AccountId,
                    dest: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "The `transferred` balance is placed on hold at the `dest` account."]
                #[codec(index = 27u8)]
                TransferAndHold {
                    reason: runtime::RuntimeHoldReason,
                    source: ::polymesh_api_client::AccountId,
                    dest: ::polymesh_api_client::AccountId,
                    transferred: u128,
                },
                #[doc = "Some balance was released from hold."]
                #[codec(index = 28u8)]
                Released {
                    reason: runtime::RuntimeHoldReason,
                    who: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "An unexpected/defensive event was triggered."]
                #[codec(index = 29u8)]
                Unexpected(pallet_balances::pallet::UnexpectedKind),
                #[doc = "Transfer with memo succeeded."]
                #[codec(index = 30u8)]
                TransferWithMemo {
                    from: ::polymesh_api_client::AccountId,
                    to: ::polymesh_api_client::AccountId,
                    amount: u128,
                    memo: Option<polymesh_primitives::Memo>,
                },
            }
            impl BalancesEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Endowed { .. } => "Balances.Endowed",
                        Self::DustLost { .. } => "Balances.DustLost",
                        Self::Transfer { .. } => "Balances.Transfer",
                        Self::BalanceSet { .. } => "Balances.BalanceSet",
                        Self::Reserved { .. } => "Balances.Reserved",
                        Self::Unreserved { .. } => "Balances.Unreserved",
                        Self::ReserveRepatriated { .. } => "Balances.ReserveRepatriated",
                        Self::Deposit { .. } => "Balances.Deposit",
                        Self::Withdraw { .. } => "Balances.Withdraw",
                        Self::Slashed { .. } => "Balances.Slashed",
                        Self::Minted { .. } => "Balances.Minted",
                        Self::MintedCredit { .. } => "Balances.MintedCredit",
                        Self::Burned { .. } => "Balances.Burned",
                        Self::BurnedDebt { .. } => "Balances.BurnedDebt",
                        Self::Suspended { .. } => "Balances.Suspended",
                        Self::Restored { .. } => "Balances.Restored",
                        Self::Upgraded { .. } => "Balances.Upgraded",
                        Self::Issued { .. } => "Balances.Issued",
                        Self::Rescinded { .. } => "Balances.Rescinded",
                        Self::Locked { .. } => "Balances.Locked",
                        Self::Unlocked { .. } => "Balances.Unlocked",
                        Self::Frozen { .. } => "Balances.Frozen",
                        Self::Thawed { .. } => "Balances.Thawed",
                        Self::TotalIssuanceForced { .. } => "Balances.TotalIssuanceForced",
                        Self::Held { .. } => "Balances.Held",
                        Self::BurnedHeld { .. } => "Balances.BurnedHeld",
                        Self::TransferOnHold { .. } => "Balances.TransferOnHold",
                        Self::TransferAndHold { .. } => "Balances.TransferAndHold",
                        Self::Released { .. } => "Balances.Released",
                        Self::Unexpected(_) => "Balances.Unexpected",
                        Self::TransferWithMemo { .. } => "Balances.TransferWithMemo",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for BalancesEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: Endowed { .. } => { & ["An account was created with some free balance." ,] } , Self :: DustLost { .. } => { & ["An account was removed whose balance was non-zero but below ExistentialDeposit," , "resulting in an outright loss." ,] } , Self :: Transfer { .. } => { & ["Transfer succeeded." ,] } , Self :: BalanceSet { .. } => { & ["A balance was set by root." ,] } , Self :: Reserved { .. } => { & ["Some balance was reserved (moved from free to reserved)." ,] } , Self :: Unreserved { .. } => { & ["Some balance was unreserved (moved from reserved to free)." ,] } , Self :: ReserveRepatriated { .. } => { & ["Some balance was moved from the reserve of the first account to the second account." , "Final argument indicates the destination balance type." ,] } , Self :: Deposit { .. } => { & ["Some amount was deposited (e.g. for transaction fees)." ,] } , Self :: Withdraw { .. } => { & ["Some amount was withdrawn from the account (e.g. for transaction fees)." ,] } , Self :: Slashed { .. } => { & ["Some amount was removed from the account (e.g. for misbehavior)." ,] } , Self :: Minted { .. } => { & ["Some amount was minted into an account." ,] } , Self :: MintedCredit { .. } => { & ["Some credit was balanced and added to the TotalIssuance." ,] } , Self :: Burned { .. } => { & ["Some amount was burned from an account." ,] } , Self :: BurnedDebt { .. } => { & ["Some debt has been dropped from the Total Issuance." ,] } , Self :: Suspended { .. } => { & ["Some amount was suspended from an account (it can be restored later)." ,] } , Self :: Restored { .. } => { & ["Some amount was restored into an account." ,] } , Self :: Upgraded { .. } => { & ["An account was upgraded." ,] } , Self :: Issued { .. } => { & ["Total issuance was increased by `amount`, creating a credit to be balanced." ,] } , Self :: Rescinded { .. } => { & ["Total issuance was decreased by `amount`, creating a debt to be balanced." ,] } , Self :: Locked { .. } => { & ["Some balance was locked." ,] } , Self :: Unlocked { .. } => { & ["Some balance was unlocked." ,] } , Self :: Frozen { .. } => { & ["Some balance was frozen." ,] } , Self :: Thawed { .. } => { & ["Some balance was thawed." ,] } , Self :: TotalIssuanceForced { .. } => { & ["The `TotalIssuance` was forcefully changed." ,] } , Self :: Held { .. } => { & ["Some balance was placed on hold." ,] } , Self :: BurnedHeld { .. } => { & ["Held balance was burned from an account." ,] } , Self :: TransferOnHold { .. } => { & ["A transfer of `amount` on hold from `source` to `dest` was initiated." ,] } , Self :: TransferAndHold { .. } => { & ["The `transferred` balance is placed on hold at the `dest` account." ,] } , Self :: Released { .. } => { & ["Some balance was released from hold." ,] } , Self :: Unexpected (_) => { & ["An unexpected/defensive event was triggered." ,] } , Self :: TransferWithMemo { .. } => { & ["Transfer with memo succeeded." ,] } , _ => & [""] , }
                }
            }
            impl From<BalancesEvent> for &'static str {
                fn from(v: BalancesEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&BalancesEvent> for &'static str {
                fn from(v: &BalancesEvent) -> Self {
                    v.as_static_str()
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum UnexpectedKind {
                #[codec(index = 0u8)]
                BalanceUpdated,
                #[codec(index = 1u8)]
                FailedToMutateAccount,
            }
        }
        pub mod types {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AccountData<Balance> {
                pub free: Balance,
                pub reserved: Balance,
                pub frozen: Balance,
                pub flags: pallet_balances::types::ExtraFlags,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AdjustmentDirection {
                #[codec(index = 0u8)]
                Increase,
                #[codec(index = 1u8)]
                Decrease,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct BalanceLock<Balance> {
                pub id: [u8; 8usize],
                pub amount: Balance,
                pub reasons: pallet_balances::types::Reasons,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ExtraFlags(pub u128);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum Reasons {
                #[codec(index = 0u8)]
                Fee,
                #[codec(index = 1u8)]
                Misc,
                #[codec(index = 2u8)]
                All,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ReserveData<ReserveIdentifier, Balance> {
                pub id: ReserveIdentifier,
                pub amount: Balance,
            }
        }
    }
    pub mod pallet_base {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum BaseCall {}
            impl BaseCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for BaseCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        _ => &[""],
                    }
                }
            }
            impl From<BaseCall> for &'static str {
                fn from(v: BaseCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&BaseCall> for &'static str {
                fn from(v: &BaseCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum BaseError {
                #[doc = "Exceeded a generic length limit."]
                #[doc = "The limit could be for any sort of lists of things, including a string."]
                #[codec(index = 0u8)]
                TooLong,
                #[doc = "The sequence counter for something overflowed."]
                #[doc = ""]
                #[doc = "When this happens depends on e.g., the capacity of the identifier type."]
                #[doc = "For example, we might have `pub struct PipId(u32);`, with `u32::MAX` capacity."]
                #[doc = "In practice, these errors will never happen but no code path should result in a panic,"]
                #[doc = "so these corner cases need to be covered with an error variant."]
                #[codec(index = 1u8)]
                CounterOverflow,
            }
            impl BaseError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::TooLong => "Base.TooLong",
                        Self::CounterOverflow => "Base.CounterOverflow",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for BaseError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: TooLong => { & ["Exceeded a generic length limit." , "The limit could be for any sort of lists of things, including a string." ,] } , Self :: CounterOverflow => { & ["The sequence counter for something overflowed." , "" , "When this happens depends on e.g., the capacity of the identifier type." , "For example, we might have `pub struct PipId(u32);`, with `u32::MAX` capacity." , "In practice, these errors will never happen but no code path should result in a panic," , "so these corner cases need to be covered with an error variant." ,] } , _ => & [""] , }
                }
            }
            impl From<BaseError> for &'static str {
                fn from(v: BaseError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&BaseError> for &'static str {
                fn from(v: &BaseError) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_beefy {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum BeefyCall {
                #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
                #[doc = "equivocation proof and validate the given key ownership proof"]
                #[doc = "against the extracted offender. If both are valid, the offence"]
                #[doc = "will be reported."]
                #[codec(index = 0u8)]
                report_double_voting {
                    equivocation_proof: ::alloc::boxed::Box<
                        sp_consensus_beefy::DoubleVotingProof<
                            u32,
                            sp_consensus_beefy::ecdsa_crypto::Public,
                            sp_consensus_beefy::ecdsa_crypto::Signature,
                        >,
                    >,
                    key_owner_proof: sp_session::MembershipProof,
                },
                #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
                #[doc = "equivocation proof and validate the given key ownership proof"]
                #[doc = "against the extracted offender. If both are valid, the offence"]
                #[doc = "will be reported."]
                #[doc = ""]
                #[doc = "This extrinsic must be called unsigned and it is expected that only"]
                #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
                #[doc = "if the block author is defined it will be defined as the equivocation"]
                #[doc = "reporter."]
                #[codec(index = 1u8)]
                report_double_voting_unsigned {
                    equivocation_proof: ::alloc::boxed::Box<
                        sp_consensus_beefy::DoubleVotingProof<
                            u32,
                            sp_consensus_beefy::ecdsa_crypto::Public,
                            sp_consensus_beefy::ecdsa_crypto::Signature,
                        >,
                    >,
                    key_owner_proof: sp_session::MembershipProof,
                },
                #[doc = "Reset BEEFY consensus by setting a new BEEFY genesis at `delay_in_blocks` blocks in the"]
                #[doc = "future."]
                #[doc = ""]
                #[doc = "Note: `delay_in_blocks` has to be at least 1."]
                #[codec(index = 2u8)]
                set_new_genesis { delay_in_blocks: u32 },
                #[doc = "Report fork voting equivocation. This method will verify the equivocation proof"]
                #[doc = "and validate the given key ownership proof against the extracted offender."]
                #[doc = "If both are valid, the offence will be reported."]
                #[codec(index = 3u8)]
                report_fork_voting {
                    equivocation_proof: ::alloc::boxed::Box<
                        sp_consensus_beefy::ForkVotingProof<
                            sp_runtime::generic::header::Header<u32>,
                            sp_consensus_beefy::ecdsa_crypto::Public,
                            sp_mmr_primitives::AncestryProof<primitive_types::H256>,
                        >,
                    >,
                    key_owner_proof: sp_session::MembershipProof,
                },
                #[doc = "Report fork voting equivocation. This method will verify the equivocation proof"]
                #[doc = "and validate the given key ownership proof against the extracted offender."]
                #[doc = "If both are valid, the offence will be reported."]
                #[doc = ""]
                #[doc = "This extrinsic must be called unsigned and it is expected that only"]
                #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
                #[doc = "if the block author is defined it will be defined as the equivocation"]
                #[doc = "reporter."]
                #[codec(index = 4u8)]
                report_fork_voting_unsigned {
                    equivocation_proof: ::alloc::boxed::Box<
                        sp_consensus_beefy::ForkVotingProof<
                            sp_runtime::generic::header::Header<u32>,
                            sp_consensus_beefy::ecdsa_crypto::Public,
                            sp_mmr_primitives::AncestryProof<primitive_types::H256>,
                        >,
                    >,
                    key_owner_proof: sp_session::MembershipProof,
                },
                #[doc = "Report future block voting equivocation. This method will verify the equivocation proof"]
                #[doc = "and validate the given key ownership proof against the extracted offender."]
                #[doc = "If both are valid, the offence will be reported."]
                #[codec(index = 5u8)]
                report_future_block_voting {
                    equivocation_proof: ::alloc::boxed::Box<
                        sp_consensus_beefy::FutureBlockVotingProof<
                            u32,
                            sp_consensus_beefy::ecdsa_crypto::Public,
                        >,
                    >,
                    key_owner_proof: sp_session::MembershipProof,
                },
                #[doc = "Report future block voting equivocation. This method will verify the equivocation proof"]
                #[doc = "and validate the given key ownership proof against the extracted offender."]
                #[doc = "If both are valid, the offence will be reported."]
                #[doc = ""]
                #[doc = "This extrinsic must be called unsigned and it is expected that only"]
                #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
                #[doc = "if the block author is defined it will be defined as the equivocation"]
                #[doc = "reporter."]
                #[codec(index = 6u8)]
                report_future_block_voting_unsigned {
                    equivocation_proof: ::alloc::boxed::Box<
                        sp_consensus_beefy::FutureBlockVotingProof<
                            u32,
                            sp_consensus_beefy::ecdsa_crypto::Public,
                        >,
                    >,
                    key_owner_proof: sp_session::MembershipProof,
                },
            }
            impl BeefyCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::report_double_voting { .. } => "Beefy.report_double_voting",
                        Self::report_double_voting_unsigned { .. } => {
                            "Beefy.report_double_voting_unsigned"
                        }
                        Self::set_new_genesis { .. } => "Beefy.set_new_genesis",
                        Self::report_fork_voting { .. } => "Beefy.report_fork_voting",
                        Self::report_fork_voting_unsigned { .. } => {
                            "Beefy.report_fork_voting_unsigned"
                        }
                        Self::report_future_block_voting { .. } => {
                            "Beefy.report_future_block_voting"
                        }
                        Self::report_future_block_voting_unsigned { .. } => {
                            "Beefy.report_future_block_voting_unsigned"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for BeefyCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: report_double_voting { .. } => { & ["Report voter equivocation/misbehavior. This method will verify the" , "equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence" , "will be reported." ,] } , Self :: report_double_voting_unsigned { .. } => { & ["Report voter equivocation/misbehavior. This method will verify the" , "equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence" , "will be reported." , "" , "This extrinsic must be called unsigned and it is expected that only" , "block authors will call it (validated in `ValidateUnsigned`), as such" , "if the block author is defined it will be defined as the equivocation" , "reporter." ,] } , Self :: set_new_genesis { .. } => { & ["Reset BEEFY consensus by setting a new BEEFY genesis at `delay_in_blocks` blocks in the" , "future." , "" , "Note: `delay_in_blocks` has to be at least 1." ,] } , Self :: report_fork_voting { .. } => { & ["Report fork voting equivocation. This method will verify the equivocation proof" , "and validate the given key ownership proof against the extracted offender." , "If both are valid, the offence will be reported." ,] } , Self :: report_fork_voting_unsigned { .. } => { & ["Report fork voting equivocation. This method will verify the equivocation proof" , "and validate the given key ownership proof against the extracted offender." , "If both are valid, the offence will be reported." , "" , "This extrinsic must be called unsigned and it is expected that only" , "block authors will call it (validated in `ValidateUnsigned`), as such" , "if the block author is defined it will be defined as the equivocation" , "reporter." ,] } , Self :: report_future_block_voting { .. } => { & ["Report future block voting equivocation. This method will verify the equivocation proof" , "and validate the given key ownership proof against the extracted offender." , "If both are valid, the offence will be reported." ,] } , Self :: report_future_block_voting_unsigned { .. } => { & ["Report future block voting equivocation. This method will verify the equivocation proof" , "and validate the given key ownership proof against the extracted offender." , "If both are valid, the offence will be reported." , "" , "This extrinsic must be called unsigned and it is expected that only" , "block authors will call it (validated in `ValidateUnsigned`), as such" , "if the block author is defined it will be defined as the equivocation" , "reporter." ,] } , _ => & [""] , }
                }
            }
            impl From<BeefyCall> for &'static str {
                fn from(v: BeefyCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&BeefyCall> for &'static str {
                fn from(v: &BeefyCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum BeefyError {
                #[doc = "A key ownership proof provided as part of an equivocation report is invalid."]
                #[codec(index = 0u8)]
                InvalidKeyOwnershipProof,
                #[doc = "A double voting proof provided as part of an equivocation report is invalid."]
                #[codec(index = 1u8)]
                InvalidDoubleVotingProof,
                #[doc = "A fork voting proof provided as part of an equivocation report is invalid."]
                #[codec(index = 2u8)]
                InvalidForkVotingProof,
                #[doc = "A future block voting proof provided as part of an equivocation report is invalid."]
                #[codec(index = 3u8)]
                InvalidFutureBlockVotingProof,
                #[doc = "The session of the equivocation proof is invalid"]
                #[codec(index = 4u8)]
                InvalidEquivocationProofSession,
                #[doc = "The session of the equivocation proof is not in the mapping (anymore)"]
                #[codec(index = 5u8)]
                InvalidEquivocationProofSessionMember,
                #[doc = "A given equivocation report is valid but already previously reported."]
                #[codec(index = 6u8)]
                DuplicateOffenceReport,
                #[doc = "Submitted configuration is invalid."]
                #[codec(index = 7u8)]
                InvalidConfiguration,
            }
            impl BeefyError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InvalidKeyOwnershipProof => "Beefy.InvalidKeyOwnershipProof",
                        Self::InvalidDoubleVotingProof => "Beefy.InvalidDoubleVotingProof",
                        Self::InvalidForkVotingProof => "Beefy.InvalidForkVotingProof",
                        Self::InvalidFutureBlockVotingProof => {
                            "Beefy.InvalidFutureBlockVotingProof"
                        }
                        Self::InvalidEquivocationProofSession => {
                            "Beefy.InvalidEquivocationProofSession"
                        }
                        Self::InvalidEquivocationProofSessionMember => {
                            "Beefy.InvalidEquivocationProofSessionMember"
                        }
                        Self::DuplicateOffenceReport => "Beefy.DuplicateOffenceReport",
                        Self::InvalidConfiguration => "Beefy.InvalidConfiguration",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for BeefyError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: InvalidKeyOwnershipProof => { & ["A key ownership proof provided as part of an equivocation report is invalid." ,] } , Self :: InvalidDoubleVotingProof => { & ["A double voting proof provided as part of an equivocation report is invalid." ,] } , Self :: InvalidForkVotingProof => { & ["A fork voting proof provided as part of an equivocation report is invalid." ,] } , Self :: InvalidFutureBlockVotingProof => { & ["A future block voting proof provided as part of an equivocation report is invalid." ,] } , Self :: InvalidEquivocationProofSession => { & ["The session of the equivocation proof is invalid" ,] } , Self :: InvalidEquivocationProofSessionMember => { & ["The session of the equivocation proof is not in the mapping (anymore)" ,] } , Self :: DuplicateOffenceReport => { & ["A given equivocation report is valid but already previously reported." ,] } , Self :: InvalidConfiguration => { & ["Submitted configuration is invalid." ,] } , _ => & [""] , }
                }
            }
            impl From<BeefyError> for &'static str {
                fn from(v: BeefyError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&BeefyError> for &'static str {
                fn from(v: &BeefyError) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_committee {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum UpgradeCommitteeCall {
                #[doc = "Change the vote threshold the determines the winning proposal."]
                #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
                #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
                #[codec(index = 0u8)]
                set_vote_threshold { n: u32, d: u32 },
                #[doc = "Changes the release coordinator."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `id` - The DID of the new release coordinator."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
                #[codec(index = 1u8)]
                set_release_coordinator {
                    id: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Changes the time after which a proposal expires."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `expiry` - The new expiry time."]
                #[codec(index = 2u8)]
                set_expires_after {
                    expiry: polymesh_primitives::MaybeBlock<u32>,
                },
                #[doc = "Proposes to the committee that `call` should be executed in its name."]
                #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
                #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
                #[doc = ""]
                #[doc = "# Weight"]
                #[doc = ""]
                #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
                #[doc = "for recording the vote itself."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `approve` - is this an approving vote?"]
                #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
                #[doc = "* `call` - the call to propose for execution."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
                #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
                #[codec(index = 3u8)]
                vote_or_propose {
                    approve: bool,
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                },
                #[doc = "Votes `approve`ingly (or not, if `false`)"]
                #[doc = "on an existing `proposal` given by its hash, `index`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `proposal` - A hash of the proposal to be voted on."]
                #[doc = "* `index` - The proposal index."]
                #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
                #[codec(index = 4u8)]
                vote {
                    proposal: primitive_types::H256,
                    index: u32,
                    approve: bool,
                },
            }
            impl UpgradeCommitteeCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::set_vote_threshold { .. } => "UpgradeCommittee.set_vote_threshold",
                        Self::set_release_coordinator { .. } => {
                            "UpgradeCommittee.set_release_coordinator"
                        }
                        Self::set_expires_after { .. } => "UpgradeCommittee.set_expires_after",
                        Self::vote_or_propose { .. } => "UpgradeCommittee.vote_or_propose",
                        Self::vote { .. } => "UpgradeCommittee.vote",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: set_vote_threshold { .. } => { & ["Change the vote threshold the determines the winning proposal." , "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"." , "" , "# Arguments" , "* `n` - Numerator of the fraction representing vote threshold." , "* `d` - Denominator of the fraction representing vote threshold." ,] } , Self :: set_release_coordinator { .. } => { & ["Changes the release coordinator." , "" , "# Arguments" , "* `id` - The DID of the new release coordinator." , "" , "# Errors" , "* `NotAMember`, If the new coordinator `id` is not part of the committee." ,] } , Self :: set_expires_after { .. } => { & ["Changes the time after which a proposal expires." , "" , "# Arguments" , "* `expiry` - The new expiry time." ,] } , Self :: vote_or_propose { .. } => { & ["Proposes to the committee that `call` should be executed in its name." , "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed," , "then this call counts as a vote, i.e., as if `vote_by_hash` was called." , "" , "# Weight" , "" , "The weight of this dispatchable is that of `call` as well as the complexity" , "for recording the vote itself." , "" , "# Arguments" , "* `approve` - is this an approving vote?" , "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`." , "* `call` - the call to propose for execution." , "" , "# Errors" , "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`." , "* `NotAMember`, if the `origin` is not a member of this committee." ,] } , Self :: vote { .. } => { & ["Votes `approve`ingly (or not, if `false`)" , "on an existing `proposal` given by its hash, `index`." , "" , "# Arguments" , "* `proposal` - A hash of the proposal to be voted on." , "* `index` - The proposal index." , "* `approve` - If `true` than this is a `for` vote, and `against` otherwise." , "" , "# Errors" , "* `NotAMember`, if the `origin` is not a member of this committee." ,] } , _ => & [""] , }
                }
            }
            impl From<UpgradeCommitteeCall> for &'static str {
                fn from(v: UpgradeCommitteeCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&UpgradeCommitteeCall> for &'static str {
                fn from(v: &UpgradeCommitteeCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum UpgradeCommitteeError {
                #[doc = "Duplicate votes are not allowed."]
                #[codec(index = 0u8)]
                DuplicateVote,
                #[doc = "A DID isn't part of the committee."]
                #[doc = "The DID may either be a caller or some other context."]
                #[codec(index = 1u8)]
                NotAMember,
                #[doc = "No such proposal."]
                #[codec(index = 2u8)]
                NoSuchProposal,
                #[doc = "Proposal exists, but it has expired."]
                #[codec(index = 3u8)]
                ProposalExpired,
                #[doc = "Duplicate proposal."]
                #[codec(index = 4u8)]
                DuplicateProposal,
                #[doc = "Mismatched voting index."]
                #[codec(index = 5u8)]
                MismatchedVotingIndex,
                #[doc = "Proportion must be a rational number."]
                #[codec(index = 6u8)]
                InvalidProportion,
                #[doc = "First vote on a proposal creates it, so it must be an approval."]
                #[doc = "All proposals are motions to execute something as \"GC majority\"."]
                #[doc = "To reject e.g., a PIP, a motion to reject should be *approved*."]
                #[codec(index = 7u8)]
                FirstVoteReject,
                #[doc = "Maximum number of proposals has been reached."]
                #[codec(index = 8u8)]
                ProposalsLimitReached,
            }
            impl UpgradeCommitteeError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::DuplicateVote => "UpgradeCommittee.DuplicateVote",
                        Self::NotAMember => "UpgradeCommittee.NotAMember",
                        Self::NoSuchProposal => "UpgradeCommittee.NoSuchProposal",
                        Self::ProposalExpired => "UpgradeCommittee.ProposalExpired",
                        Self::DuplicateProposal => "UpgradeCommittee.DuplicateProposal",
                        Self::MismatchedVotingIndex => "UpgradeCommittee.MismatchedVotingIndex",
                        Self::InvalidProportion => "UpgradeCommittee.InvalidProportion",
                        Self::FirstVoteReject => "UpgradeCommittee.FirstVoteReject",
                        Self::ProposalsLimitReached => "UpgradeCommittee.ProposalsLimitReached",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::DuplicateVote => &["Duplicate votes are not allowed."],
                        Self::NotAMember => &[
                            "A DID isn't part of the committee.",
                            "The DID may either be a caller or some other context.",
                        ],
                        Self::NoSuchProposal => &["No such proposal."],
                        Self::ProposalExpired => &["Proposal exists, but it has expired."],
                        Self::DuplicateProposal => &["Duplicate proposal."],
                        Self::MismatchedVotingIndex => &["Mismatched voting index."],
                        Self::InvalidProportion => &["Proportion must be a rational number."],
                        Self::FirstVoteReject => &[
                            "First vote on a proposal creates it, so it must be an approval.",
                            "All proposals are motions to execute something as \"GC majority\".",
                            "To reject e.g., a PIP, a motion to reject should be *approved*.",
                        ],
                        Self::ProposalsLimitReached => {
                            &["Maximum number of proposals has been reached."]
                        }
                        _ => &[""],
                    }
                }
            }
            impl From<UpgradeCommitteeError> for &'static str {
                fn from(v: UpgradeCommitteeError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&UpgradeCommitteeError> for &'static str {
                fn from(v: &UpgradeCommitteeError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum UpgradeCommitteeEvent {
                #[doc = "A motion (given hash) has been proposed (by given account) with a threshold (given `MemberCount`)."]
                #[doc = "Parameters: caller DID, proposal index, proposal hash."]
                #[codec(index = 0u8)]
                Proposed(
                    ::polymesh_api_client::IdentityId,
                    u32,
                    primitive_types::H256,
                ),
                #[doc = "A motion (given hash) has been voted on by given account, leaving"]
                #[doc = "a tally (yes votes, no votes and total seats given respectively as `MemberCount`)."]
                #[doc = "caller DID, Proposal index, Proposal hash, current vote, yay vote count, nay vote count, total seats."]
                #[codec(index = 1u8)]
                Voted(
                    ::polymesh_api_client::IdentityId,
                    u32,
                    primitive_types::H256,
                    bool,
                    u32,
                    u32,
                    u32,
                ),
                #[doc = "A vote on a motion (given hash) has been retracted."]
                #[doc = "caller DID, ProposalIndex, Proposal hash, vote that was retracted"]
                #[codec(index = 2u8)]
                VoteRetracted(
                    ::polymesh_api_client::IdentityId,
                    u32,
                    primitive_types::H256,
                    bool,
                ),
                #[doc = "Final votes on a motion (given hash)"]
                #[doc = "caller DID, ProposalIndex, Proposal hash, yes voters, no voter"]
                #[codec(index = 3u8)]
                FinalVotes(
                    Option<::polymesh_api_client::IdentityId>,
                    u32,
                    primitive_types::H256,
                    ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
                    ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
                ),
                #[doc = "A motion was approved by the required threshold with the following"]
                #[doc = "tally (yes votes, no votes and total seats given respectively as `MemberCount`)."]
                #[doc = "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats."]
                #[codec(index = 4u8)]
                Approved(
                    Option<::polymesh_api_client::IdentityId>,
                    primitive_types::H256,
                    u32,
                    u32,
                    u32,
                ),
                #[doc = "A motion was rejected by the required threshold with the following"]
                #[doc = "tally (yes votes, no votes and total seats given respectively as `MemberCount`)."]
                #[doc = "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats."]
                #[codec(index = 5u8)]
                Rejected(
                    Option<::polymesh_api_client::IdentityId>,
                    primitive_types::H256,
                    u32,
                    u32,
                    u32,
                ),
                #[doc = "A motion was executed; `DispatchResult` is `Ok(())` if returned without error."]
                #[doc = "Parameters: caller DID, proposal hash, result of proposal dispatch."]
                #[codec(index = 6u8)]
                Executed(
                    Option<::polymesh_api_client::IdentityId>,
                    primitive_types::H256,
                    Result<(), sp_runtime::DispatchError>,
                ),
                #[doc = "Release coordinator has been updated."]
                #[doc = "Parameters: DID of the release coordinator."]
                #[codec(index = 7u8)]
                ReleaseCoordinatorUpdated(Option<::polymesh_api_client::IdentityId>),
                #[doc = "Proposal expiry time has been updated."]
                #[doc = "Parameters: caller DID, new expiry time (if any)."]
                #[codec(index = 8u8)]
                ExpiresAfterUpdated(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::MaybeBlock<u32>,
                ),
                #[doc = "Voting threshold has been updated"]
                #[doc = "Parameters: caller DID, numerator, denominator"]
                #[codec(index = 9u8)]
                VoteThresholdUpdated(::polymesh_api_client::IdentityId, u32, u32),
            }
            impl UpgradeCommitteeEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Proposed(_, _, _) => "UpgradeCommittee.Proposed",
                        Self::Voted(_, _, _, _, _, _, _) => "UpgradeCommittee.Voted",
                        Self::VoteRetracted(_, _, _, _) => "UpgradeCommittee.VoteRetracted",
                        Self::FinalVotes(_, _, _, _, _) => "UpgradeCommittee.FinalVotes",
                        Self::Approved(_, _, _, _, _) => "UpgradeCommittee.Approved",
                        Self::Rejected(_, _, _, _, _) => "UpgradeCommittee.Rejected",
                        Self::Executed(_, _, _) => "UpgradeCommittee.Executed",
                        Self::ReleaseCoordinatorUpdated(_) => {
                            "UpgradeCommittee.ReleaseCoordinatorUpdated"
                        }
                        Self::ExpiresAfterUpdated(_, _) => "UpgradeCommittee.ExpiresAfterUpdated",
                        Self::VoteThresholdUpdated(_, _, _) => {
                            "UpgradeCommittee.VoteThresholdUpdated"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: Proposed (_ , _ , _) => { & ["A motion (given hash) has been proposed (by given account) with a threshold (given `MemberCount`)." , "Parameters: caller DID, proposal index, proposal hash." ,] } , Self :: Voted (_ , _ , _ , _ , _ , _ , _) => { & ["A motion (given hash) has been voted on by given account, leaving" , "a tally (yes votes, no votes and total seats given respectively as `MemberCount`)." , "caller DID, Proposal index, Proposal hash, current vote, yay vote count, nay vote count, total seats." ,] } , Self :: VoteRetracted (_ , _ , _ , _) => { & ["A vote on a motion (given hash) has been retracted." , "caller DID, ProposalIndex, Proposal hash, vote that was retracted" ,] } , Self :: FinalVotes (_ , _ , _ , _ , _) => { & ["Final votes on a motion (given hash)" , "caller DID, ProposalIndex, Proposal hash, yes voters, no voter" ,] } , Self :: Approved (_ , _ , _ , _ , _) => { & ["A motion was approved by the required threshold with the following" , "tally (yes votes, no votes and total seats given respectively as `MemberCount`)." , "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats." ,] } , Self :: Rejected (_ , _ , _ , _ , _) => { & ["A motion was rejected by the required threshold with the following" , "tally (yes votes, no votes and total seats given respectively as `MemberCount`)." , "Parameters: caller DID, proposal hash, yay vote count, nay vote count, total seats." ,] } , Self :: Executed (_ , _ , _) => { & ["A motion was executed; `DispatchResult` is `Ok(())` if returned without error." , "Parameters: caller DID, proposal hash, result of proposal dispatch." ,] } , Self :: ReleaseCoordinatorUpdated (_) => { & ["Release coordinator has been updated." , "Parameters: DID of the release coordinator." ,] } , Self :: ExpiresAfterUpdated (_ , _) => { & ["Proposal expiry time has been updated." , "Parameters: caller DID, new expiry time (if any)." ,] } , Self :: VoteThresholdUpdated (_ , _ , _) => { & ["Voting threshold has been updated" , "Parameters: caller DID, numerator, denominator" ,] } , _ => & [""] , }
                }
            }
            impl From<UpgradeCommitteeEvent> for &'static str {
                fn from(v: UpgradeCommitteeEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&UpgradeCommitteeEvent> for &'static str {
                fn from(v: &UpgradeCommitteeEvent) -> Self {
                    v.as_static_str()
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PolymeshVotes<BlockNumber> {
                pub index: BlockNumber,
                pub ayes: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
                pub nays: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
                pub expiry: polymesh_primitives::MaybeBlock<BlockNumber>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum RawOrigin<AccountId> {
                #[codec(index = 0u8)]
                Endorsed,
                PhantomDataVariant(core::marker::PhantomData<AccountId>),
            }
        }
    }
    pub mod pallet_compliance_manager {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ComplianceManagerCall {
                #[doc = "Adds a compliance requirement to an asset given by `asset_id`."]
                #[doc = "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
                #[doc = "* asset_id - Symbol of the asset"]
                #[doc = "* sender_conditions - Sender transfer conditions."]
                #[doc = "* receiver_conditions - Receiver transfer conditions."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 0u8)]
                add_compliance_requirement {
                    asset_id: ::polymesh_api_client::AssetId,
                    sender_conditions: ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
                    receiver_conditions:
                        ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
                },
                #[doc = "Removes a compliance requirement from an asset's compliance."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
                #[doc = "* asset_id - Symbol of the asset"]
                #[doc = "* id - Compliance requirement id which is need to be removed"]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 1u8)]
                remove_compliance_requirement {
                    asset_id: ::polymesh_api_client::AssetId,
                    id: u32,
                },
                #[doc = "Replaces an asset's compliance with a new compliance."]
                #[doc = ""]
                #[doc = "Compliance requirements will be sorted (ascending by id) before"]
                #[doc = "replacing the current requirements."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `asset_id` - the asset asset_id,"]
                #[doc = "* `asset_compliance - the new asset compliance."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `Unauthorized` if `origin` is not the owner of the asset_id."]
                #[doc = "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 2u8)]
                replace_asset_compliance {
                    asset_id: ::polymesh_api_client::AssetId,
                    asset_compliance: ::alloc::vec::Vec<
                        polymesh_primitives::compliance_manager::ComplianceRequirement,
                    >,
                },
                #[doc = "Removes an asset's compliance"]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
                #[doc = "* asset_id - Symbol of the asset"]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 3u8)]
                reset_asset_compliance {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Pauses the verification of conditions for `asset_id` during transfers."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
                #[doc = "* asset_id - Symbol of the asset"]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 4u8)]
                pause_asset_compliance {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Resumes the verification of conditions for `asset_id` during transfers."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
                #[doc = "* asset_id - Symbol of the asset"]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 5u8)]
                resume_asset_compliance {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Adds another default trusted claim issuer at the asset level."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
                #[doc = "* asset_id - Symbol of the asset."]
                #[doc = "* issuer - IdentityId of the trusted claim issuer."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 6u8)]
                add_default_trusted_claim_issuer {
                    asset_id: ::polymesh_api_client::AssetId,
                    issuer: polymesh_primitives::condition::TrustedIssuer,
                },
                #[doc = "Removes the given `issuer` from the set of default trusted claim issuers at the asset level."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
                #[doc = "* asset_id - Symbol of the asset."]
                #[doc = "* issuer - IdentityId of the trusted claim issuer."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 7u8)]
                remove_default_trusted_claim_issuer {
                    asset_id: ::polymesh_api_client::AssetId,
                    issuer: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Modify an existing compliance requirement of a given asset."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
                #[doc = "* asset_id - Symbol of the asset."]
                #[doc = "* new_req - Compliance requirement."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 8u8)]
                change_compliance_requirement {
                    asset_id: ::polymesh_api_client::AssetId,
                    new_req: polymesh_primitives::compliance_manager::ComplianceRequirement,
                },
            }
            impl ComplianceManagerCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::add_compliance_requirement { .. } => {
                            "ComplianceManager.add_compliance_requirement"
                        }
                        Self::remove_compliance_requirement { .. } => {
                            "ComplianceManager.remove_compliance_requirement"
                        }
                        Self::replace_asset_compliance { .. } => {
                            "ComplianceManager.replace_asset_compliance"
                        }
                        Self::reset_asset_compliance { .. } => {
                            "ComplianceManager.reset_asset_compliance"
                        }
                        Self::pause_asset_compliance { .. } => {
                            "ComplianceManager.pause_asset_compliance"
                        }
                        Self::resume_asset_compliance { .. } => {
                            "ComplianceManager.resume_asset_compliance"
                        }
                        Self::add_default_trusted_claim_issuer { .. } => {
                            "ComplianceManager.add_default_trusted_claim_issuer"
                        }
                        Self::remove_default_trusted_claim_issuer { .. } => {
                            "ComplianceManager.remove_default_trusted_claim_issuer"
                        }
                        Self::change_compliance_requirement { .. } => {
                            "ComplianceManager.change_compliance_requirement"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ComplianceManagerCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: add_compliance_requirement { .. } => { & ["Adds a compliance requirement to an asset given by `asset_id`." , "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset" , "* asset_id - Symbol of the asset" , "* sender_conditions - Sender transfer conditions." , "* receiver_conditions - Receiver transfer conditions." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_compliance_requirement { .. } => { & ["Removes a compliance requirement from an asset's compliance." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset" , "* asset_id - Symbol of the asset" , "* id - Compliance requirement id which is need to be removed" , "" , "# Permissions" , "* Asset" ,] } , Self :: replace_asset_compliance { .. } => { & ["Replaces an asset's compliance with a new compliance." , "" , "Compliance requirements will be sorted (ascending by id) before" , "replacing the current requirements." , "" , "# Arguments" , "* `asset_id` - the asset asset_id," , "* `asset_compliance - the new asset compliance." , "" , "# Errors" , "* `Unauthorized` if `origin` is not the owner of the asset_id." , "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`." , "" , "# Permissions" , "* Asset" ,] } , Self :: reset_asset_compliance { .. } => { & ["Removes an asset's compliance" , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset" , "* asset_id - Symbol of the asset" , "" , "# Permissions" , "* Asset" ,] } , Self :: pause_asset_compliance { .. } => { & ["Pauses the verification of conditions for `asset_id` during transfers." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset" , "* asset_id - Symbol of the asset" , "" , "# Permissions" , "* Asset" ,] } , Self :: resume_asset_compliance { .. } => { & ["Resumes the verification of conditions for `asset_id` during transfers." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset" , "* asset_id - Symbol of the asset" , "" , "# Permissions" , "* Asset" ,] } , Self :: add_default_trusted_claim_issuer { .. } => { & ["Adds another default trusted claim issuer at the asset level." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset." , "* asset_id - Symbol of the asset." , "* issuer - IdentityId of the trusted claim issuer." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_default_trusted_claim_issuer { .. } => { & ["Removes the given `issuer` from the set of default trusted claim issuers at the asset level." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset." , "* asset_id - Symbol of the asset." , "* issuer - IdentityId of the trusted claim issuer." , "" , "# Permissions" , "* Asset" ,] } , Self :: change_compliance_requirement { .. } => { & ["Modify an existing compliance requirement of a given asset." , "" , "# Arguments" , "* origin - Signer of the dispatchable. It should be the owner of the asset." , "* asset_id - Symbol of the asset." , "* new_req - Compliance requirement." , "" , "# Permissions" , "* Asset" ,] } , _ => & [""] , }
                }
            }
            impl From<ComplianceManagerCall> for &'static str {
                fn from(v: ComplianceManagerCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ComplianceManagerCall> for &'static str {
                fn from(v: &ComplianceManagerCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ComplianceManagerError {
                #[doc = "User is not authorized."]
                #[codec(index = 0u8)]
                Unauthorized,
                #[doc = "Did not exist."]
                #[codec(index = 1u8)]
                DidNotExist,
                #[doc = "Compliance requirement id doesn't exist."]
                #[codec(index = 2u8)]
                InvalidComplianceRequirementId,
                #[doc = "Issuer exist but trying to add it again."]
                #[codec(index = 3u8)]
                IncorrectOperationOnTrustedIssuer,
                #[doc = "There are duplicate compliance requirements."]
                #[codec(index = 4u8)]
                DuplicateComplianceRequirements,
                #[doc = "The worst case scenario of the compliance requirement is too complex."]
                #[codec(index = 5u8)]
                ComplianceRequirementTooComplex,
                #[doc = "The maximum weight limit for executing the function was exceeded."]
                #[codec(index = 6u8)]
                WeightLimitExceeded,
            }
            impl ComplianceManagerError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Unauthorized => "ComplianceManager.Unauthorized",
                        Self::DidNotExist => "ComplianceManager.DidNotExist",
                        Self::InvalidComplianceRequirementId => {
                            "ComplianceManager.InvalidComplianceRequirementId"
                        }
                        Self::IncorrectOperationOnTrustedIssuer => {
                            "ComplianceManager.IncorrectOperationOnTrustedIssuer"
                        }
                        Self::DuplicateComplianceRequirements => {
                            "ComplianceManager.DuplicateComplianceRequirements"
                        }
                        Self::ComplianceRequirementTooComplex => {
                            "ComplianceManager.ComplianceRequirementTooComplex"
                        }
                        Self::WeightLimitExceeded => "ComplianceManager.WeightLimitExceeded",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ComplianceManagerError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Unauthorized => &["User is not authorized."],
                        Self::DidNotExist => &["Did not exist."],
                        Self::InvalidComplianceRequirementId => {
                            &["Compliance requirement id doesn't exist."]
                        }
                        Self::IncorrectOperationOnTrustedIssuer => {
                            &["Issuer exist but trying to add it again."]
                        }
                        Self::DuplicateComplianceRequirements => {
                            &["There are duplicate compliance requirements."]
                        }
                        Self::ComplianceRequirementTooComplex => &[
                            "The worst case scenario of the compliance requirement is too complex.",
                        ],
                        Self::WeightLimitExceeded => {
                            &["The maximum weight limit for executing the function was exceeded."]
                        }
                        _ => &[""],
                    }
                }
            }
            impl From<ComplianceManagerError> for &'static str {
                fn from(v: ComplianceManagerError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ComplianceManagerError> for &'static str {
                fn from(v: &ComplianceManagerError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ComplianceManagerEvent {
                #[doc = "Emitted when new compliance requirement is created."]
                #[doc = "(caller DID, AssetId, ComplianceRequirement)."]
                #[codec(index = 0u8)]
                ComplianceRequirementCreated(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::compliance_manager::ComplianceRequirement,
                ),
                #[doc = "Emitted when a compliance requirement is removed."]
                #[doc = "(caller DID, AssetId, requirement_id)."]
                #[codec(index = 1u8)]
                ComplianceRequirementRemoved(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    u32,
                ),
                #[doc = "Emitted when an asset compliance is replaced."]
                #[doc = "Parameters: caller DID, AssetId, new asset compliance."]
                #[codec(index = 2u8)]
                AssetComplianceReplaced(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::alloc::vec::Vec<
                        polymesh_primitives::compliance_manager::ComplianceRequirement,
                    >,
                ),
                #[doc = "Emitted when an asset compliance of a asset_id is reset."]
                #[doc = "(caller DID, AssetId)."]
                #[codec(index = 3u8)]
                AssetComplianceReset(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "Emitted when an asset compliance for a given asset_id gets resume."]
                #[doc = "(caller DID, AssetId)."]
                #[codec(index = 4u8)]
                AssetComplianceResumed(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "Emitted when an asset compliance for a given asset_id gets paused."]
                #[doc = "(caller DID, AssetId)."]
                #[codec(index = 5u8)]
                AssetCompliancePaused(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "Emitted when compliance requirement get modified/change."]
                #[doc = "(caller DID, AssetId, ComplianceRequirement)."]
                #[codec(index = 6u8)]
                ComplianceRequirementChanged(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::compliance_manager::ComplianceRequirement,
                ),
                #[doc = "Emitted when default claim issuer list for a given asset_id gets added."]
                #[doc = "(caller DID, AssetId, Added TrustedIssuer)."]
                #[codec(index = 7u8)]
                TrustedDefaultClaimIssuerAdded(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::condition::TrustedIssuer,
                ),
                #[doc = "Emitted when default claim issuer list for a given asset_id get removed."]
                #[doc = "(caller DID, AssetId, Removed TrustedIssuer)."]
                #[codec(index = 8u8)]
                TrustedDefaultClaimIssuerRemoved(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::polymesh_api_client::IdentityId,
                ),
            }
            impl ComplianceManagerEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::ComplianceRequirementCreated(_, _, _) => {
                            "ComplianceManager.ComplianceRequirementCreated"
                        }
                        Self::ComplianceRequirementRemoved(_, _, _) => {
                            "ComplianceManager.ComplianceRequirementRemoved"
                        }
                        Self::AssetComplianceReplaced(_, _, _) => {
                            "ComplianceManager.AssetComplianceReplaced"
                        }
                        Self::AssetComplianceReset(_, _) => {
                            "ComplianceManager.AssetComplianceReset"
                        }
                        Self::AssetComplianceResumed(_, _) => {
                            "ComplianceManager.AssetComplianceResumed"
                        }
                        Self::AssetCompliancePaused(_, _) => {
                            "ComplianceManager.AssetCompliancePaused"
                        }
                        Self::ComplianceRequirementChanged(_, _, _) => {
                            "ComplianceManager.ComplianceRequirementChanged"
                        }
                        Self::TrustedDefaultClaimIssuerAdded(_, _, _) => {
                            "ComplianceManager.TrustedDefaultClaimIssuerAdded"
                        }
                        Self::TrustedDefaultClaimIssuerRemoved(_, _, _) => {
                            "ComplianceManager.TrustedDefaultClaimIssuerRemoved"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ComplianceManagerEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: ComplianceRequirementCreated (_ , _ , _) => { & ["Emitted when new compliance requirement is created." , "(caller DID, AssetId, ComplianceRequirement)." ,] } , Self :: ComplianceRequirementRemoved (_ , _ , _) => { & ["Emitted when a compliance requirement is removed." , "(caller DID, AssetId, requirement_id)." ,] } , Self :: AssetComplianceReplaced (_ , _ , _) => { & ["Emitted when an asset compliance is replaced." , "Parameters: caller DID, AssetId, new asset compliance." ,] } , Self :: AssetComplianceReset (_ , _) => { & ["Emitted when an asset compliance of a asset_id is reset." , "(caller DID, AssetId)." ,] } , Self :: AssetComplianceResumed (_ , _) => { & ["Emitted when an asset compliance for a given asset_id gets resume." , "(caller DID, AssetId)." ,] } , Self :: AssetCompliancePaused (_ , _) => { & ["Emitted when an asset compliance for a given asset_id gets paused." , "(caller DID, AssetId)." ,] } , Self :: ComplianceRequirementChanged (_ , _ , _) => { & ["Emitted when compliance requirement get modified/change." , "(caller DID, AssetId, ComplianceRequirement)." ,] } , Self :: TrustedDefaultClaimIssuerAdded (_ , _ , _) => { & ["Emitted when default claim issuer list for a given asset_id gets added." , "(caller DID, AssetId, Added TrustedIssuer)." ,] } , Self :: TrustedDefaultClaimIssuerRemoved (_ , _ , _) => { & ["Emitted when default claim issuer list for a given asset_id get removed." , "(caller DID, AssetId, Removed TrustedIssuer)." ,] } , _ => & [""] , }
                }
            }
            impl From<ComplianceManagerEvent> for &'static str {
                fn from(v: ComplianceManagerEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ComplianceManagerEvent> for &'static str {
                fn from(v: &ComplianceManagerEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Version(pub u8);
    }
    pub mod pallet_contracts {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ContractsCall {
                #[doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."]
                #[codec(index = 0u8)]
                call_old_weight {
                    dest:
                        ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    #[codec(compact)]
                    value: u128,
                    #[codec(compact)]
                    gas_limit: u64,
                    storage_deposit_limit: Option<::codec::Compact<u128>>,
                    data: ::alloc::vec::Vec<u8>,
                },
                #[doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."]
                #[codec(index = 1u8)]
                instantiate_with_code_old_weight {
                    #[codec(compact)]
                    value: u128,
                    #[codec(compact)]
                    gas_limit: u64,
                    storage_deposit_limit: Option<::codec::Compact<u128>>,
                    code: ::alloc::vec::Vec<u8>,
                    data: ::alloc::vec::Vec<u8>,
                    salt: ::alloc::vec::Vec<u8>,
                },
                #[doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."]
                #[codec(index = 2u8)]
                instantiate_old_weight {
                    #[codec(compact)]
                    value: u128,
                    #[codec(compact)]
                    gas_limit: u64,
                    storage_deposit_limit: Option<::codec::Compact<u128>>,
                    code_hash: primitive_types::H256,
                    data: ::alloc::vec::Vec<u8>,
                    salt: ::alloc::vec::Vec<u8>,
                },
                #[doc = "Upload new `code` without instantiating a contract from it."]
                #[doc = ""]
                #[doc = "If the code does not already exist a deposit is reserved from the caller"]
                #[doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"]
                #[doc = "depends on the size of the supplied `code`."]
                #[doc = ""]
                #[doc = "If the code already exists in storage it will still return `Ok` and upgrades"]
                #[doc = "the in storage version to the current"]
                #[doc = "[`InstructionWeights::version`](InstructionWeights)."]
                #[doc = ""]
                #[doc = "- `determinism`: If this is set to any other value but [`Determinism::Enforced`] then"]
                #[doc = "  the only way to use this code is to delegate call into it from an offchain execution."]
                #[doc = "  Set to [`Determinism::Enforced`] if in doubt."]
                #[doc = ""]
                #[doc = "# Note"]
                #[doc = ""]
                #[doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."]
                #[doc = "To avoid this situation a constructor could employ access control so that it can"]
                #[doc = "only be instantiated by permissioned entities. The same is true when uploading"]
                #[doc = "through [`Self::instantiate_with_code`]."]
                #[doc = ""]
                #[doc = "Use [`Determinism::Relaxed`] exclusively for non-deterministic code. If the uploaded"]
                #[doc = "code is deterministic, specifying [`Determinism::Relaxed`] will be disregarded and"]
                #[doc = "result in higher gas costs."]
                #[codec(index = 3u8)]
                upload_code {
                    code: ::alloc::vec::Vec<u8>,
                    storage_deposit_limit: Option<::codec::Compact<u128>>,
                    determinism: pallet_contracts::wasm::Determinism,
                },
                #[doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."]
                #[doc = ""]
                #[doc = "A code can only be removed by its original uploader (its owner) and only if it is"]
                #[doc = "not used by any contract."]
                #[codec(index = 4u8)]
                remove_code { code_hash: primitive_types::H256 },
                #[doc = "Privileged function that changes the code of an existing contract."]
                #[doc = ""]
                #[doc = "This takes care of updating refcounts and all other necessary operations. Returns"]
                #[doc = "an error if either the `code_hash` or `dest` do not exist."]
                #[doc = ""]
                #[doc = "# Note"]
                #[doc = ""]
                #[doc = "This does **not** change the address of the contract in question. This means"]
                #[doc = "that the contract address is no longer derived from its code hash after calling"]
                #[doc = "this dispatchable."]
                #[codec(index = 5u8)]
                set_code {
                    dest:
                        ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    code_hash: primitive_types::H256,
                },
                #[doc = "Makes a call to an account, optionally transferring some balance."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = ""]
                #[doc = "* `dest`: Address of the contract to call."]
                #[doc = "* `value`: The balance to transfer from the `origin` to `dest`."]
                #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
                #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"]
                #[doc = "  caller to pay for the storage consumed."]
                #[doc = "* `data`: The input data to pass to the contract."]
                #[doc = ""]
                #[doc = "* If the account is a smart-contract account, the associated code will be"]
                #[doc = "executed and any value will be transferred."]
                #[doc = "* If the account is a regular account, any value will be transferred."]
                #[doc = "* If no account exists and the call value is not less than `existential_deposit`,"]
                #[doc = "a regular account will be created and any value will be transferred."]
                #[codec(index = 6u8)]
                call {
                    dest:
                        ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    #[codec(compact)]
                    value: u128,
                    gas_limit: ::polymesh_api_client::sp_weights::Weight,
                    storage_deposit_limit: Option<::codec::Compact<u128>>,
                    data: ::alloc::vec::Vec<u8>,
                },
                #[doc = "Instantiates a new contract from the supplied `code` optionally transferring"]
                #[doc = "some balance."]
                #[doc = ""]
                #[doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"]
                #[doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"]
                #[doc = "also check the documentation of [`Self::upload_code`]."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = ""]
                #[doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."]
                #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
                #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"]
                #[doc = "  from the caller to pay for the storage consumed."]
                #[doc = "* `code`: The contract code to deploy in raw bytes."]
                #[doc = "* `data`: The input data to pass to the contract constructor."]
                #[doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."]
                #[doc = ""]
                #[doc = "Instantiation is executed as follows:"]
                #[doc = ""]
                #[doc = "- The supplied `code` is deployed, and a `code_hash` is created for that code."]
                #[doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."]
                #[doc = "- The destination address is computed based on the sender, code_hash and the salt."]
                #[doc = "- The smart-contract account is created at the computed address."]
                #[doc = "- The `value` is transferred to the new account."]
                #[doc = "- The `deploy` function is executed in the context of the newly-created account."]
                #[codec(index = 7u8)]
                instantiate_with_code {
                    #[codec(compact)]
                    value: u128,
                    gas_limit: ::polymesh_api_client::sp_weights::Weight,
                    storage_deposit_limit: Option<::codec::Compact<u128>>,
                    code: ::alloc::vec::Vec<u8>,
                    data: ::alloc::vec::Vec<u8>,
                    salt: ::alloc::vec::Vec<u8>,
                },
                #[doc = "Instantiates a contract from a previously deployed wasm binary."]
                #[doc = ""]
                #[doc = "This function is identical to [`Self::instantiate_with_code`] but without the"]
                #[doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"]
                #[doc = "must be supplied."]
                #[codec(index = 8u8)]
                instantiate {
                    #[codec(compact)]
                    value: u128,
                    gas_limit: ::polymesh_api_client::sp_weights::Weight,
                    storage_deposit_limit: Option<::codec::Compact<u128>>,
                    code_hash: primitive_types::H256,
                    data: ::alloc::vec::Vec<u8>,
                    salt: ::alloc::vec::Vec<u8>,
                },
                #[doc = "When a migration is in progress, this dispatchable can be used to run migration steps."]
                #[doc = "Calls that contribute to advancing the migration have their fees waived, as it's helpful"]
                #[doc = "for the chain. Note that while the migration is in progress, the pallet will also"]
                #[doc = "leverage the `on_idle` hooks to run migration steps."]
                #[codec(index = 9u8)]
                migrate {
                    weight_limit: ::polymesh_api_client::sp_weights::Weight,
                },
            }
            impl ContractsCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::call_old_weight { .. } => "Contracts.call_old_weight",
                        Self::instantiate_with_code_old_weight { .. } => {
                            "Contracts.instantiate_with_code_old_weight"
                        }
                        Self::instantiate_old_weight { .. } => "Contracts.instantiate_old_weight",
                        Self::upload_code { .. } => "Contracts.upload_code",
                        Self::remove_code { .. } => "Contracts.remove_code",
                        Self::set_code { .. } => "Contracts.set_code",
                        Self::call { .. } => "Contracts.call",
                        Self::instantiate_with_code { .. } => "Contracts.instantiate_with_code",
                        Self::instantiate { .. } => "Contracts.instantiate",
                        Self::migrate { .. } => "Contracts.migrate",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ContractsCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: call_old_weight { .. } => { & ["Deprecated version if [`Self::call`] for use in an in-storage `Call`." ,] } , Self :: instantiate_with_code_old_weight { .. } => { & ["Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`." ,] } , Self :: instantiate_old_weight { .. } => { & ["Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`." ,] } , Self :: upload_code { .. } => { & ["Upload new `code` without instantiating a contract from it." , "" , "If the code does not already exist a deposit is reserved from the caller" , "and unreserved only when [`Self::remove_code`] is called. The size of the reserve" , "depends on the size of the supplied `code`." , "" , "If the code already exists in storage it will still return `Ok` and upgrades" , "the in storage version to the current" , "[`InstructionWeights::version`](InstructionWeights)." , "" , "- `determinism`: If this is set to any other value but [`Determinism::Enforced`] then" , "  the only way to use this code is to delegate call into it from an offchain execution." , "  Set to [`Determinism::Enforced`] if in doubt." , "" , "# Note" , "" , "Anyone can instantiate a contract from any uploaded code and thus prevent its removal." , "To avoid this situation a constructor could employ access control so that it can" , "only be instantiated by permissioned entities. The same is true when uploading" , "through [`Self::instantiate_with_code`]." , "" , "Use [`Determinism::Relaxed`] exclusively for non-deterministic code. If the uploaded" , "code is deterministic, specifying [`Determinism::Relaxed`] will be disregarded and" , "result in higher gas costs." ,] } , Self :: remove_code { .. } => { & ["Remove the code stored under `code_hash` and refund the deposit to its owner." , "" , "A code can only be removed by its original uploader (its owner) and only if it is" , "not used by any contract." ,] } , Self :: set_code { .. } => { & ["Privileged function that changes the code of an existing contract." , "" , "This takes care of updating refcounts and all other necessary operations. Returns" , "an error if either the `code_hash` or `dest` do not exist." , "" , "# Note" , "" , "This does **not** change the address of the contract in question. This means" , "that the contract address is no longer derived from its code hash after calling" , "this dispatchable." ,] } , Self :: call { .. } => { & ["Makes a call to an account, optionally transferring some balance." , "" , "# Parameters" , "" , "* `dest`: Address of the contract to call." , "* `value`: The balance to transfer from the `origin` to `dest`." , "* `gas_limit`: The gas limit enforced when executing the constructor." , "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the" , "  caller to pay for the storage consumed." , "* `data`: The input data to pass to the contract." , "" , "* If the account is a smart-contract account, the associated code will be" , "executed and any value will be transferred." , "* If the account is a regular account, any value will be transferred." , "* If no account exists and the call value is not less than `existential_deposit`," , "a regular account will be created and any value will be transferred." ,] } , Self :: instantiate_with_code { .. } => { & ["Instantiates a new contract from the supplied `code` optionally transferring" , "some balance." , "" , "This dispatchable has the same effect as calling [`Self::upload_code`] +" , "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please" , "also check the documentation of [`Self::upload_code`]." , "" , "# Parameters" , "" , "* `value`: The balance to transfer from the `origin` to the newly created contract." , "* `gas_limit`: The gas limit enforced when executing the constructor." , "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved" , "  from the caller to pay for the storage consumed." , "* `code`: The contract code to deploy in raw bytes." , "* `data`: The input data to pass to the contract constructor." , "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]." , "" , "Instantiation is executed as follows:" , "" , "- The supplied `code` is deployed, and a `code_hash` is created for that code." , "- If the `code_hash` already exists on the chain the underlying `code` will be shared." , "- The destination address is computed based on the sender, code_hash and the salt." , "- The smart-contract account is created at the computed address." , "- The `value` is transferred to the new account." , "- The `deploy` function is executed in the context of the newly-created account." ,] } , Self :: instantiate { .. } => { & ["Instantiates a contract from a previously deployed wasm binary." , "" , "This function is identical to [`Self::instantiate_with_code`] but without the" , "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary" , "must be supplied." ,] } , Self :: migrate { .. } => { & ["When a migration is in progress, this dispatchable can be used to run migration steps." , "Calls that contribute to advancing the migration have their fees waived, as it's helpful" , "for the chain. Note that while the migration is in progress, the pallet will also" , "leverage the `on_idle` hooks to run migration steps." ,] } , _ => & [""] , }
                }
            }
            impl From<ContractsCall> for &'static str {
                fn from(v: ContractsCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ContractsCall> for &'static str {
                fn from(v: &ContractsCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ContractsError {
                #[doc = "Invalid schedule supplied, e.g. with zero weight of a basic operation."]
                #[codec(index = 0u8)]
                InvalidSchedule,
                #[doc = "Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`."]
                #[codec(index = 1u8)]
                InvalidCallFlags,
                #[doc = "The executed contract exhausted its gas limit."]
                #[codec(index = 2u8)]
                OutOfGas,
                #[doc = "The output buffer supplied to a contract API call was too small."]
                #[codec(index = 3u8)]
                OutputBufferTooSmall,
                #[doc = "Performing the requested transfer failed. Probably because there isn't enough"]
                #[doc = "free balance in the sender's account."]
                #[codec(index = 4u8)]
                TransferFailed,
                #[doc = "Performing a call was denied because the calling depth reached the limit"]
                #[doc = "of what is specified in the schedule."]
                #[codec(index = 5u8)]
                MaxCallDepthReached,
                #[doc = "No contract was found at the specified address."]
                #[codec(index = 6u8)]
                ContractNotFound,
                #[doc = "The code supplied to `instantiate_with_code` exceeds the limit specified in the"]
                #[doc = "current schedule."]
                #[codec(index = 7u8)]
                CodeTooLarge,
                #[doc = "No code could be found at the supplied code hash."]
                #[codec(index = 8u8)]
                CodeNotFound,
                #[doc = "No code info could be found at the supplied code hash."]
                #[codec(index = 9u8)]
                CodeInfoNotFound,
                #[doc = "A buffer outside of sandbox memory was passed to a contract API function."]
                #[codec(index = 10u8)]
                OutOfBounds,
                #[doc = "Input passed to a contract API function failed to decode as expected type."]
                #[codec(index = 11u8)]
                DecodingFailed,
                #[doc = "Contract trapped during execution."]
                #[codec(index = 12u8)]
                ContractTrapped,
                #[doc = "The size defined in `T::MaxValueSize` was exceeded."]
                #[codec(index = 13u8)]
                ValueTooLarge,
                #[doc = "Termination of a contract is not allowed while the contract is already"]
                #[doc = "on the call stack. Can be triggered by `seal_terminate`."]
                #[codec(index = 14u8)]
                TerminatedWhileReentrant,
                #[doc = "`seal_call` forwarded this contracts input. It therefore is no longer available."]
                #[codec(index = 15u8)]
                InputForwarded,
                #[doc = "The subject passed to `seal_random` exceeds the limit."]
                #[codec(index = 16u8)]
                RandomSubjectTooLong,
                #[doc = "The amount of topics passed to `seal_deposit_events` exceeds the limit."]
                #[codec(index = 17u8)]
                TooManyTopics,
                #[doc = "The chain does not provide a chain extension. Calling the chain extension results"]
                #[doc = "in this error. Note that this usually  shouldn't happen as deploying such contracts"]
                #[doc = "is rejected."]
                #[codec(index = 18u8)]
                NoChainExtension,
                #[doc = "Failed to decode the XCM program."]
                #[codec(index = 19u8)]
                XCMDecodeFailed,
                #[doc = "A contract with the same AccountId already exists."]
                #[codec(index = 20u8)]
                DuplicateContract,
                #[doc = "A contract self destructed in its constructor."]
                #[doc = ""]
                #[doc = "This can be triggered by a call to `seal_terminate`."]
                #[codec(index = 21u8)]
                TerminatedInConstructor,
                #[doc = "A call tried to invoke a contract that is flagged as non-reentrant."]
                #[doc = "The only other cause is that a call from a contract into the runtime tried to call back"]
                #[doc = "into `pallet-contracts`. This would make the whole pallet reentrant with regard to"]
                #[doc = "contract code execution which is not supported."]
                #[codec(index = 22u8)]
                ReentranceDenied,
                #[doc = "A contract attempted to invoke a state modifying API while being in read-only mode."]
                #[codec(index = 23u8)]
                StateChangeDenied,
                #[doc = "Origin doesn't have enough balance to pay the required storage deposits."]
                #[codec(index = 24u8)]
                StorageDepositNotEnoughFunds,
                #[doc = "More storage was created than allowed by the storage deposit limit."]
                #[codec(index = 25u8)]
                StorageDepositLimitExhausted,
                #[doc = "Code removal was denied because the code is still in use by at least one contract."]
                #[codec(index = 26u8)]
                CodeInUse,
                #[doc = "The contract ran to completion but decided to revert its storage changes."]
                #[doc = "Please note that this error is only returned from extrinsics. When called directly"]
                #[doc = "or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags"]
                #[doc = "to determine whether a reversion has taken place."]
                #[codec(index = 27u8)]
                ContractReverted,
                #[doc = "The contract's code was found to be invalid during validation."]
                #[doc = ""]
                #[doc = "The most likely cause of this is that an API was used which is not supported by the"]
                #[doc = "node. This happens if an older node is used with a new version of ink!. Try updating"]
                #[doc = "your node to the newest available version."]
                #[doc = ""]
                #[doc = "A more detailed error can be found on the node console if debug messages are enabled"]
                #[doc = "by supplying `-lruntime::contracts=debug`."]
                #[codec(index = 28u8)]
                CodeRejected,
                #[doc = "An indeterministic code was used in a context where this is not permitted."]
                #[codec(index = 29u8)]
                Indeterministic,
                #[doc = "A pending migration needs to complete before the extrinsic can be called."]
                #[codec(index = 30u8)]
                MigrationInProgress,
                #[doc = "Migrate dispatch call was attempted but no migration was performed."]
                #[codec(index = 31u8)]
                NoMigrationPerformed,
                #[doc = "The contract has reached its maximum number of delegate dependencies."]
                #[codec(index = 32u8)]
                MaxDelegateDependenciesReached,
                #[doc = "The dependency was not found in the contract's delegate dependencies."]
                #[codec(index = 33u8)]
                DelegateDependencyNotFound,
                #[doc = "The contract already depends on the given delegate dependency."]
                #[codec(index = 34u8)]
                DelegateDependencyAlreadyExists,
                #[doc = "Can not add a delegate dependency to the code hash of the contract itself."]
                #[codec(index = 35u8)]
                CannotAddSelfAsDelegateDependency,
                #[doc = "Can not add more data to transient storage."]
                #[codec(index = 36u8)]
                OutOfTransientStorage,
            }
            impl ContractsError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InvalidSchedule => "Contracts.InvalidSchedule",
                        Self::InvalidCallFlags => "Contracts.InvalidCallFlags",
                        Self::OutOfGas => "Contracts.OutOfGas",
                        Self::OutputBufferTooSmall => "Contracts.OutputBufferTooSmall",
                        Self::TransferFailed => "Contracts.TransferFailed",
                        Self::MaxCallDepthReached => "Contracts.MaxCallDepthReached",
                        Self::ContractNotFound => "Contracts.ContractNotFound",
                        Self::CodeTooLarge => "Contracts.CodeTooLarge",
                        Self::CodeNotFound => "Contracts.CodeNotFound",
                        Self::CodeInfoNotFound => "Contracts.CodeInfoNotFound",
                        Self::OutOfBounds => "Contracts.OutOfBounds",
                        Self::DecodingFailed => "Contracts.DecodingFailed",
                        Self::ContractTrapped => "Contracts.ContractTrapped",
                        Self::ValueTooLarge => "Contracts.ValueTooLarge",
                        Self::TerminatedWhileReentrant => "Contracts.TerminatedWhileReentrant",
                        Self::InputForwarded => "Contracts.InputForwarded",
                        Self::RandomSubjectTooLong => "Contracts.RandomSubjectTooLong",
                        Self::TooManyTopics => "Contracts.TooManyTopics",
                        Self::NoChainExtension => "Contracts.NoChainExtension",
                        Self::XCMDecodeFailed => "Contracts.XCMDecodeFailed",
                        Self::DuplicateContract => "Contracts.DuplicateContract",
                        Self::TerminatedInConstructor => "Contracts.TerminatedInConstructor",
                        Self::ReentranceDenied => "Contracts.ReentranceDenied",
                        Self::StateChangeDenied => "Contracts.StateChangeDenied",
                        Self::StorageDepositNotEnoughFunds => {
                            "Contracts.StorageDepositNotEnoughFunds"
                        }
                        Self::StorageDepositLimitExhausted => {
                            "Contracts.StorageDepositLimitExhausted"
                        }
                        Self::CodeInUse => "Contracts.CodeInUse",
                        Self::ContractReverted => "Contracts.ContractReverted",
                        Self::CodeRejected => "Contracts.CodeRejected",
                        Self::Indeterministic => "Contracts.Indeterministic",
                        Self::MigrationInProgress => "Contracts.MigrationInProgress",
                        Self::NoMigrationPerformed => "Contracts.NoMigrationPerformed",
                        Self::MaxDelegateDependenciesReached => {
                            "Contracts.MaxDelegateDependenciesReached"
                        }
                        Self::DelegateDependencyNotFound => "Contracts.DelegateDependencyNotFound",
                        Self::DelegateDependencyAlreadyExists => {
                            "Contracts.DelegateDependencyAlreadyExists"
                        }
                        Self::CannotAddSelfAsDelegateDependency => {
                            "Contracts.CannotAddSelfAsDelegateDependency"
                        }
                        Self::OutOfTransientStorage => "Contracts.OutOfTransientStorage",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ContractsError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: InvalidSchedule => { & ["Invalid schedule supplied, e.g. with zero weight of a basic operation." ,] } , Self :: InvalidCallFlags => { & ["Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`." ,] } , Self :: OutOfGas => { & ["The executed contract exhausted its gas limit." ,] } , Self :: OutputBufferTooSmall => { & ["The output buffer supplied to a contract API call was too small." ,] } , Self :: TransferFailed => { & ["Performing the requested transfer failed. Probably because there isn't enough" , "free balance in the sender's account." ,] } , Self :: MaxCallDepthReached => { & ["Performing a call was denied because the calling depth reached the limit" , "of what is specified in the schedule." ,] } , Self :: ContractNotFound => { & ["No contract was found at the specified address." ,] } , Self :: CodeTooLarge => { & ["The code supplied to `instantiate_with_code` exceeds the limit specified in the" , "current schedule." ,] } , Self :: CodeNotFound => { & ["No code could be found at the supplied code hash." ,] } , Self :: CodeInfoNotFound => { & ["No code info could be found at the supplied code hash." ,] } , Self :: OutOfBounds => { & ["A buffer outside of sandbox memory was passed to a contract API function." ,] } , Self :: DecodingFailed => { & ["Input passed to a contract API function failed to decode as expected type." ,] } , Self :: ContractTrapped => { & ["Contract trapped during execution." ,] } , Self :: ValueTooLarge => { & ["The size defined in `T::MaxValueSize` was exceeded." ,] } , Self :: TerminatedWhileReentrant => { & ["Termination of a contract is not allowed while the contract is already" , "on the call stack. Can be triggered by `seal_terminate`." ,] } , Self :: InputForwarded => { & ["`seal_call` forwarded this contracts input. It therefore is no longer available." ,] } , Self :: RandomSubjectTooLong => { & ["The subject passed to `seal_random` exceeds the limit." ,] } , Self :: TooManyTopics => { & ["The amount of topics passed to `seal_deposit_events` exceeds the limit." ,] } , Self :: NoChainExtension => { & ["The chain does not provide a chain extension. Calling the chain extension results" , "in this error. Note that this usually  shouldn't happen as deploying such contracts" , "is rejected." ,] } , Self :: XCMDecodeFailed => { & ["Failed to decode the XCM program." ,] } , Self :: DuplicateContract => { & ["A contract with the same AccountId already exists." ,] } , Self :: TerminatedInConstructor => { & ["A contract self destructed in its constructor." , "" , "This can be triggered by a call to `seal_terminate`." ,] } , Self :: ReentranceDenied => { & ["A call tried to invoke a contract that is flagged as non-reentrant." , "The only other cause is that a call from a contract into the runtime tried to call back" , "into `pallet-contracts`. This would make the whole pallet reentrant with regard to" , "contract code execution which is not supported." ,] } , Self :: StateChangeDenied => { & ["A contract attempted to invoke a state modifying API while being in read-only mode." ,] } , Self :: StorageDepositNotEnoughFunds => { & ["Origin doesn't have enough balance to pay the required storage deposits." ,] } , Self :: StorageDepositLimitExhausted => { & ["More storage was created than allowed by the storage deposit limit." ,] } , Self :: CodeInUse => { & ["Code removal was denied because the code is still in use by at least one contract." ,] } , Self :: ContractReverted => { & ["The contract ran to completion but decided to revert its storage changes." , "Please note that this error is only returned from extrinsics. When called directly" , "or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags" , "to determine whether a reversion has taken place." ,] } , Self :: CodeRejected => { & ["The contract's code was found to be invalid during validation." , "" , "The most likely cause of this is that an API was used which is not supported by the" , "node. This happens if an older node is used with a new version of ink!. Try updating" , "your node to the newest available version." , "" , "A more detailed error can be found on the node console if debug messages are enabled" , "by supplying `-lruntime::contracts=debug`." ,] } , Self :: Indeterministic => { & ["An indeterministic code was used in a context where this is not permitted." ,] } , Self :: MigrationInProgress => { & ["A pending migration needs to complete before the extrinsic can be called." ,] } , Self :: NoMigrationPerformed => { & ["Migrate dispatch call was attempted but no migration was performed." ,] } , Self :: MaxDelegateDependenciesReached => { & ["The contract has reached its maximum number of delegate dependencies." ,] } , Self :: DelegateDependencyNotFound => { & ["The dependency was not found in the contract's delegate dependencies." ,] } , Self :: DelegateDependencyAlreadyExists => { & ["The contract already depends on the given delegate dependency." ,] } , Self :: CannotAddSelfAsDelegateDependency => { & ["Can not add a delegate dependency to the code hash of the contract itself." ,] } , Self :: OutOfTransientStorage => { & ["Can not add more data to transient storage." ,] } , _ => & [""] , }
                }
            }
            impl From<ContractsError> for &'static str {
                fn from(v: ContractsError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ContractsError> for &'static str {
                fn from(v: &ContractsError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ContractsEvent {
                #[doc = "Contract deployed by address at the specified address."]
                #[codec(index = 0u8)]
                Instantiated {
                    deployer: ::polymesh_api_client::AccountId,
                    contract: ::polymesh_api_client::AccountId,
                },
                #[doc = "Contract has been removed."]
                #[doc = ""]
                #[doc = "# Note"]
                #[doc = ""]
                #[doc = "The only way for a contract to be removed and emitting this event is by calling"]
                #[doc = "`seal_terminate`."]
                #[codec(index = 1u8)]
                Terminated {
                    #[doc = "The contract that was terminated."]
                    contract: ::polymesh_api_client::AccountId,
                    #[doc = "The account that received the contracts remaining balance"]
                    beneficiary: ::polymesh_api_client::AccountId,
                },
                #[doc = "Code with the specified hash has been stored."]
                #[codec(index = 2u8)]
                CodeStored {
                    code_hash: primitive_types::H256,
                    deposit_held: u128,
                    uploader: ::polymesh_api_client::AccountId,
                },
                #[doc = "A custom event emitted by the contract."]
                #[codec(index = 3u8)]
                ContractEmitted {
                    #[doc = "The contract that emitted the event."]
                    contract: ::polymesh_api_client::AccountId,
                    #[doc = "Data supplied by the contract. Metadata generated during contract compilation"]
                    #[doc = "is needed to decode it."]
                    data: ::alloc::vec::Vec<u8>,
                },
                #[doc = "A code with the specified hash was removed."]
                #[codec(index = 4u8)]
                CodeRemoved {
                    code_hash: primitive_types::H256,
                    deposit_released: u128,
                    remover: ::polymesh_api_client::AccountId,
                },
                #[doc = "A contract's code was updated."]
                #[codec(index = 5u8)]
                ContractCodeUpdated {
                    #[doc = "The contract that has been updated."]
                    contract: ::polymesh_api_client::AccountId,
                    #[doc = "New code hash that was set for the contract."]
                    new_code_hash: primitive_types::H256,
                    #[doc = "Previous code hash of the contract."]
                    old_code_hash: primitive_types::H256,
                },
                #[doc = "A contract was called either by a plain account or another contract."]
                #[doc = ""]
                #[doc = "# Note"]
                #[doc = ""]
                #[doc = "Please keep in mind that like all events this is only emitted for successful"]
                #[doc = "calls. This is because on failure all storage changes including events are"]
                #[doc = "rolled back."]
                #[codec(index = 6u8)]
                Called {
                    #[doc = "The caller of the `contract`."]
                    caller: pallet_contracts::Origin<runtime::Runtime>,
                    #[doc = "The contract that was called."]
                    contract: ::polymesh_api_client::AccountId,
                },
                #[doc = "A contract delegate called a code hash."]
                #[doc = ""]
                #[doc = "# Note"]
                #[doc = ""]
                #[doc = "Please keep in mind that like all events this is only emitted for successful"]
                #[doc = "calls. This is because on failure all storage changes including events are"]
                #[doc = "rolled back."]
                #[codec(index = 7u8)]
                DelegateCalled {
                    #[doc = "The contract that performed the delegate call and hence in whose context"]
                    #[doc = "the `code_hash` is executed."]
                    contract: ::polymesh_api_client::AccountId,
                    #[doc = "The code hash that was delegate called."]
                    code_hash: primitive_types::H256,
                },
                #[doc = "Some funds have been transferred and held as storage deposit."]
                #[codec(index = 8u8)]
                StorageDepositTransferredAndHeld {
                    from: ::polymesh_api_client::AccountId,
                    to: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Some storage deposit funds have been transferred and released."]
                #[codec(index = 9u8)]
                StorageDepositTransferredAndReleased {
                    from: ::polymesh_api_client::AccountId,
                    to: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
            }
            impl ContractsEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Instantiated { .. } => "Contracts.Instantiated",
                        Self::Terminated { .. } => "Contracts.Terminated",
                        Self::CodeStored { .. } => "Contracts.CodeStored",
                        Self::ContractEmitted { .. } => "Contracts.ContractEmitted",
                        Self::CodeRemoved { .. } => "Contracts.CodeRemoved",
                        Self::ContractCodeUpdated { .. } => "Contracts.ContractCodeUpdated",
                        Self::Called { .. } => "Contracts.Called",
                        Self::DelegateCalled { .. } => "Contracts.DelegateCalled",
                        Self::StorageDepositTransferredAndHeld { .. } => {
                            "Contracts.StorageDepositTransferredAndHeld"
                        }
                        Self::StorageDepositTransferredAndReleased { .. } => {
                            "Contracts.StorageDepositTransferredAndReleased"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ContractsEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: Instantiated { .. } => { & ["Contract deployed by address at the specified address." ,] } , Self :: Terminated { .. } => { & ["Contract has been removed." , "" , "# Note" , "" , "The only way for a contract to be removed and emitting this event is by calling" , "`seal_terminate`." ,] } , Self :: CodeStored { .. } => { & ["Code with the specified hash has been stored." ,] } , Self :: ContractEmitted { .. } => { & ["A custom event emitted by the contract." ,] } , Self :: CodeRemoved { .. } => { & ["A code with the specified hash was removed." ,] } , Self :: ContractCodeUpdated { .. } => { & ["A contract's code was updated." ,] } , Self :: Called { .. } => { & ["A contract was called either by a plain account or another contract." , "" , "# Note" , "" , "Please keep in mind that like all events this is only emitted for successful" , "calls. This is because on failure all storage changes including events are" , "rolled back." ,] } , Self :: DelegateCalled { .. } => { & ["A contract delegate called a code hash." , "" , "# Note" , "" , "Please keep in mind that like all events this is only emitted for successful" , "calls. This is because on failure all storage changes including events are" , "rolled back." ,] } , Self :: StorageDepositTransferredAndHeld { .. } => { & ["Some funds have been transferred and held as storage deposit." ,] } , Self :: StorageDepositTransferredAndReleased { .. } => { & ["Some storage deposit funds have been transferred and released." ,] } , _ => & [""] , }
                }
            }
            impl From<ContractsEvent> for &'static str {
                fn from(v: ContractsEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ContractsEvent> for &'static str {
                fn from(v: &ContractsEvent) -> Self {
                    v.as_static_str()
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum HoldReason {
                #[codec(index = 0u8)]
                CodeUploadDepositReserve,
                #[codec(index = 1u8)]
                StorageDepositReserve,
            }
        }
        pub mod schedule {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct InstructionWeights {
                pub base: u32,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Limits {
                pub event_topics: u32,
                pub memory_pages: u32,
                pub subject_len: u32,
                pub payload_len: u32,
                pub runtime_memory: u32,
                pub validator_runtime_memory: u32,
                pub event_ref_time: u64,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Schedule {
                pub limits: pallet_contracts::schedule::Limits,
                pub instruction_weights: pallet_contracts::schedule::InstructionWeights,
            }
        }
        pub mod storage {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ContractInfo {
                pub trie_id: ::alloc::vec::Vec<u8>,
                pub code_hash: primitive_types::H256,
                pub storage_bytes: u32,
                pub storage_items: u32,
                pub storage_byte_deposit: u128,
                pub storage_item_deposit: u128,
                pub storage_base_deposit: u128,
                pub delegate_dependencies:
                    ::alloc::collections::BTreeMap<primitive_types::H256, u128>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct DeletionQueueManager {
                pub insert_counter: u32,
                pub delete_counter: u32,
            }
        }
        pub mod wasm {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct CodeInfo {
                pub owner: ::polymesh_api_client::AccountId,
                #[codec(compact)]
                pub deposit: u128,
                #[codec(compact)]
                pub refcount: u64,
                pub determinism: pallet_contracts::wasm::Determinism,
                pub code_len: u32,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum Determinism {
                #[codec(index = 0u8)]
                Enforced,
                #[codec(index = 1u8)]
                Relaxed,
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ApiVersion(pub u16);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Environment {
            pub account_id: pallet_contracts::EnvironmentType<::polymesh_api_client::AccountId>,
            pub balance: pallet_contracts::EnvironmentType<u128>,
            pub hash: pallet_contracts::EnvironmentType<primitive_types::H256>,
            pub hasher: pallet_contracts::EnvironmentType<sp_runtime::traits::BlakeTwo256>,
            pub timestamp: pallet_contracts::EnvironmentType<u64>,
            pub block_number: pallet_contracts::EnvironmentType<u32>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct EnvironmentType<T>(core::marker::PhantomData<T>);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Origin<T> {
            #[codec(index = 0u8)]
            Root,
            #[codec(index = 1u8)]
            Signed(::polymesh_api_client::AccountId),
            PhantomDataVariant(core::marker::PhantomData<T>),
        }
    }
    pub mod pallet_corporate_actions {
        use super::*;
        pub mod ballot {
            use super::*;
            pub mod pallet {
                use super::*;
                #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum CorporateBallotCall {
                    #[doc = "Attach a corporate ballot to the CA identified by `ca_id`."]
                    #[doc = ""]
                    #[doc = "The ballot will admit votes within `range`."]
                    #[doc = "The ballot's metadata is provided by `meta`,"]
                    #[doc = "which includes the ballot title, the motions, their choices, etc."]
                    #[doc = "See the `BallotMeta` for more."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
                    #[doc = "- `ca_id` identifies the CA to attach the ballot to."]
                    #[doc = "- `range` specifies when voting starts and ends."]
                    #[doc = "- `meta` specifies the ballot's metadata as aforementioned."]
                    #[doc = "- `rcv` specifies whether RCV is enabled for this ballot."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                    #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
                    #[doc = "- `CANotNotice` if the CA is not of the `IssuerNotice` kind."]
                    #[doc = "- `StartAfterEnd` if `range.start > range.end`."]
                    #[doc = "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp."]
                    #[doc = "- `NoRecordDate` if CA has no record date."]
                    #[doc = "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date."]
                    #[doc = "- `AlreadyExists` if there's a ballot already."]
                    #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
                    #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
                    #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
                    #[codec(index = 0u8)]
                    attach_ballot {
                        ca_id: pallet_corporate_actions::CAId,
                        range: pallet_corporate_actions::ballot::BallotTimeRange,
                        meta: pallet_corporate_actions::ballot::BallotMeta,
                        rcv: bool,
                    },
                    #[doc = "Cast `votes` in the ballot attached to the CA identified by `ca_id`."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` which must be a permissioned signer targeted by the CA."]
                    #[doc = "- `ca_id` identifies the attached ballot's CA."]
                    #[doc = "- `votes` specifies the balances to assign to each choice in the ballot."]
                    #[doc = "   The full voting power of `origin`'s DID may be used for each motion in the ballot."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
                    #[doc = "- `VotingNotStarted` if the voting period hasn't commenced yet."]
                    #[doc = "- `VotingAlreadyEnded` if the voting period has ended."]
                    #[doc = "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`."]
                    #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
                    #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
                    #[doc = "- `InsufficientVotes` if the voting power used for any motion in `votes`"]
                    #[doc = "   exceeds `origin`'s DID's voting power."]
                    #[codec(index = 1u8)]
                    vote {
                        ca_id: pallet_corporate_actions::CAId,
                        votes: ::alloc::vec::Vec<pallet_corporate_actions::ballot::BallotVote>,
                    },
                    #[doc = "Amend the end date of the ballot of the CA identified by `ca_id`."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
                    #[doc = "- `ca_id` identifies the attached ballot's CA."]
                    #[doc = "- `end` specifies the new end date of the ballot."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                    #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
                    #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
                    #[doc = "- `StartAfterEnd` if `start > end`."]
                    #[codec(index = 2u8)]
                    change_end {
                        ca_id: pallet_corporate_actions::CAId,
                        end: u64,
                    },
                    #[doc = "Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
                    #[doc = "- `ca_id` identifies the attached ballot's CA."]
                    #[doc = "- `meta` specifies the new metadata."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                    #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
                    #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
                    #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
                    #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
                    #[codec(index = 3u8)]
                    change_meta {
                        ca_id: pallet_corporate_actions::CAId,
                        meta: pallet_corporate_actions::ballot::BallotMeta,
                    },
                    #[doc = "Amend RCV support for the ballot of the CA identified by `ca_id`."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
                    #[doc = "- `ca_id` identifies the attached ballot's CA."]
                    #[doc = "- `rcv` specifies if RCV is to be supported or not."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                    #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
                    #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
                    #[codec(index = 4u8)]
                    change_rcv {
                        ca_id: pallet_corporate_actions::CAId,
                        rcv: bool,
                    },
                    #[doc = "Remove the ballot of the CA identified by `ca_id`."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
                    #[doc = "- `ca_id` identifies the attached ballot's CA."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                    #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
                    #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
                    #[codec(index = 5u8)]
                    remove_ballot {
                        ca_id: pallet_corporate_actions::CAId,
                    },
                }
                impl CorporateBallotCall {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::attach_ballot { .. } => "CorporateBallot.attach_ballot",
                            Self::vote { .. } => "CorporateBallot.vote",
                            Self::change_end { .. } => "CorporateBallot.change_end",
                            Self::change_meta { .. } => "CorporateBallot.change_meta",
                            Self::change_rcv { .. } => "CorporateBallot.change_rcv",
                            Self::remove_ballot { .. } => "CorporateBallot.remove_ballot",
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for CorporateBallotCall {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: attach_ballot { .. } => { & ["Attach a corporate ballot to the CA identified by `ca_id`." , "" , "The ballot will admit votes within `range`." , "The ballot's metadata is provided by `meta`," , "which includes the ballot title, the motions, their choices, etc." , "See the `BallotMeta` for more." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the CA to attach the ballot to." , "- `range` specifies when voting starts and ends." , "- `meta` specifies the ballot's metadata as aforementioned." , "- `rcv` specifies whether RCV is enabled for this ballot." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `CANotNotice` if the CA is not of the `IssuerNotice` kind." , "- `StartAfterEnd` if `range.start > range.end`." , "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp." , "- `NoRecordDate` if CA has no record date." , "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date." , "- `AlreadyExists` if there's a ballot already." , "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`." , "- `TooLong` if any of the embedded strings in `meta` are too long." , "- `InsufficientBalance` if the protocol fee couldn't be charged." ,] } , Self :: vote { .. } => { & ["Cast `votes` in the ballot attached to the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` which must be a permissioned signer targeted by the CA." , "- `ca_id` identifies the attached ballot's CA." , "- `votes` specifies the balances to assign to each choice in the ballot." , "   The full voting power of `origin`'s DID may be used for each motion in the ballot." , "" , "# Errors" , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingNotStarted` if the voting period hasn't commenced yet." , "- `VotingAlreadyEnded` if the voting period has ended." , "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NotTargetedByCA` if the CA does not target `origin`'s DID." , "- `InsufficientVotes` if the voting power used for any motion in `votes`" , "   exceeds `origin`'s DID's voting power." ,] } , Self :: change_end { .. } => { & ["Amend the end date of the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the attached ballot's CA." , "- `end` specifies the new end date of the ballot." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." , "- `StartAfterEnd` if `start > end`." ,] } , Self :: change_meta { .. } => { & ["Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the attached ballot's CA." , "- `meta` specifies the new metadata." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." , "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`." , "- `TooLong` if any of the embedded strings in `meta` are too long." ,] } , Self :: change_rcv { .. } => { & ["Amend RCV support for the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the attached ballot's CA." , "- `rcv` specifies if RCV is to be supported or not." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." ,] } , Self :: remove_ballot { .. } => { & ["Remove the ballot of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the attached ballot's CA." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchBallot` if `ca_id` does not identify a ballot." , "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time." ,] } , _ => & [""] , }
                    }
                }
                impl From<CorporateBallotCall> for &'static str {
                    fn from(v: CorporateBallotCall) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&CorporateBallotCall> for &'static str {
                    fn from(v: &CorporateBallotCall) -> Self {
                        v.as_static_str()
                    }
                }
                #[doc = "The `Error` enum of this pallet."]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum CorporateBallotError {
                    #[doc = "A corporate ballot was made for a non `IssuerNotice` CA."]
                    #[codec(index = 0u8)]
                    CANotNotice,
                    #[doc = "A corporate ballot already exists for this CA."]
                    #[codec(index = 1u8)]
                    AlreadyExists,
                    #[doc = "A corporate ballot doesn't exist for this CA."]
                    #[codec(index = 2u8)]
                    NoSuchBallot,
                    #[doc = "A corporate ballot's start time was strictly after the ballot's end."]
                    #[codec(index = 3u8)]
                    StartAfterEnd,
                    #[doc = "A corporate ballot's end time was strictly before the current time."]
                    #[codec(index = 4u8)]
                    NowAfterEnd,
                    #[doc = "If some motion in a corporate ballot has more choices than would fit in `u16`."]
                    #[codec(index = 5u8)]
                    NumberOfChoicesOverflow,
                    #[doc = "Voting started already. Amending a ballot is no longer possible."]
                    #[codec(index = 6u8)]
                    VotingAlreadyStarted,
                    #[doc = "Voting hasn't started yet."]
                    #[codec(index = 7u8)]
                    VotingNotStarted,
                    #[doc = "Voting ended already."]
                    #[codec(index = 8u8)]
                    VotingAlreadyEnded,
                    #[doc = "Provided list of balances does not match the total number of choices."]
                    #[codec(index = 9u8)]
                    WrongVoteCount,
                    #[doc = "Voting power used by a DID on a motion exceeds that which is available to them."]
                    #[codec(index = 10u8)]
                    InsufficientVotes,
                    #[doc = "The RCV fallback of some choice does not exist."]
                    #[codec(index = 11u8)]
                    NoSuchRCVFallback,
                    #[doc = "The RCV fallback points to the origin choice."]
                    #[codec(index = 12u8)]
                    RCVSelfCycle,
                    #[doc = "RCV is not allowed for this ballot."]
                    #[codec(index = 13u8)]
                    RCVNotAllowed,
                }
                impl CorporateBallotError {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::CANotNotice => "CorporateBallot.CANotNotice",
                            Self::AlreadyExists => "CorporateBallot.AlreadyExists",
                            Self::NoSuchBallot => "CorporateBallot.NoSuchBallot",
                            Self::StartAfterEnd => "CorporateBallot.StartAfterEnd",
                            Self::NowAfterEnd => "CorporateBallot.NowAfterEnd",
                            Self::NumberOfChoicesOverflow => {
                                "CorporateBallot.NumberOfChoicesOverflow"
                            }
                            Self::VotingAlreadyStarted => "CorporateBallot.VotingAlreadyStarted",
                            Self::VotingNotStarted => "CorporateBallot.VotingNotStarted",
                            Self::VotingAlreadyEnded => "CorporateBallot.VotingAlreadyEnded",
                            Self::WrongVoteCount => "CorporateBallot.WrongVoteCount",
                            Self::InsufficientVotes => "CorporateBallot.InsufficientVotes",
                            Self::NoSuchRCVFallback => "CorporateBallot.NoSuchRCVFallback",
                            Self::RCVSelfCycle => "CorporateBallot.RCVSelfCycle",
                            Self::RCVNotAllowed => "CorporateBallot.RCVNotAllowed",
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for CorporateBallotError {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: CANotNotice => { & ["A corporate ballot was made for a non `IssuerNotice` CA." ,] } , Self :: AlreadyExists => { & ["A corporate ballot already exists for this CA." ,] } , Self :: NoSuchBallot => { & ["A corporate ballot doesn't exist for this CA." ,] } , Self :: StartAfterEnd => { & ["A corporate ballot's start time was strictly after the ballot's end." ,] } , Self :: NowAfterEnd => { & ["A corporate ballot's end time was strictly before the current time." ,] } , Self :: NumberOfChoicesOverflow => { & ["If some motion in a corporate ballot has more choices than would fit in `u16`." ,] } , Self :: VotingAlreadyStarted => { & ["Voting started already. Amending a ballot is no longer possible." ,] } , Self :: VotingNotStarted => { & ["Voting hasn't started yet." ,] } , Self :: VotingAlreadyEnded => { & ["Voting ended already." ,] } , Self :: WrongVoteCount => { & ["Provided list of balances does not match the total number of choices." ,] } , Self :: InsufficientVotes => { & ["Voting power used by a DID on a motion exceeds that which is available to them." ,] } , Self :: NoSuchRCVFallback => { & ["The RCV fallback of some choice does not exist." ,] } , Self :: RCVSelfCycle => { & ["The RCV fallback points to the origin choice." ,] } , Self :: RCVNotAllowed => { & ["RCV is not allowed for this ballot." ,] } , _ => & [""] , }
                    }
                }
                impl From<CorporateBallotError> for &'static str {
                    fn from(v: CorporateBallotError) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&CorporateBallotError> for &'static str {
                    fn from(v: &CorporateBallotError) -> Self {
                        v.as_static_str()
                    }
                }
                #[doc = "The `Event` enum of this pallet"]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum CorporateBallotEvent {
                    #[doc = "A corporate ballot was created."]
                    #[doc = ""]
                    #[doc = "(Agent DID, CA's ID, Voting start/end, Ballot metadata, RCV enabled?)"]
                    #[codec(index = 0u8)]
                    Created(
                        ::polymesh_api_client::IdentityId,
                        pallet_corporate_actions::CAId,
                        pallet_corporate_actions::ballot::BallotTimeRange,
                        pallet_corporate_actions::ballot::BallotMeta,
                        bool,
                    ),
                    #[doc = "A vote was cast in a corporate ballot."]
                    #[doc = ""]
                    #[doc = "(voter DID, CAId, Votes)"]
                    #[codec(index = 1u8)]
                    VoteCast(
                        ::polymesh_api_client::IdentityId,
                        pallet_corporate_actions::CAId,
                        ::alloc::vec::Vec<pallet_corporate_actions::ballot::BallotVote>,
                    ),
                    #[doc = "A corporate ballot changed its start/end date range."]
                    #[doc = ""]
                    #[doc = "(Agent DID, CA's ID, Voting start/end)"]
                    #[codec(index = 2u8)]
                    RangeChanged(
                        ::polymesh_api_client::IdentityId,
                        pallet_corporate_actions::CAId,
                        pallet_corporate_actions::ballot::BallotTimeRange,
                    ),
                    #[doc = "A corporate ballot changed its metadata."]
                    #[doc = ""]
                    #[doc = "(Agent DID, CA's ID, New metadata)"]
                    #[codec(index = 3u8)]
                    MetaChanged(
                        ::polymesh_api_client::IdentityId,
                        pallet_corporate_actions::CAId,
                        pallet_corporate_actions::ballot::BallotMeta,
                    ),
                    #[doc = "A corporate ballot changed its RCV support."]
                    #[doc = ""]
                    #[doc = "(Agent DID, CA's ID, New support)"]
                    #[codec(index = 4u8)]
                    RCVChanged(
                        ::polymesh_api_client::IdentityId,
                        pallet_corporate_actions::CAId,
                        bool,
                    ),
                    #[doc = "A corporate ballot was removed."]
                    #[doc = ""]
                    #[doc = "(Agent DID, CA's ID)"]
                    #[codec(index = 5u8)]
                    Removed(
                        polymesh_primitives::event_only::EventOnly<
                            ::polymesh_api_client::IdentityId,
                        >,
                        pallet_corporate_actions::CAId,
                    ),
                }
                impl CorporateBallotEvent {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::Created(_, _, _, _, _) => "CorporateBallot.Created",
                            Self::VoteCast(_, _, _) => "CorporateBallot.VoteCast",
                            Self::RangeChanged(_, _, _) => "CorporateBallot.RangeChanged",
                            Self::MetaChanged(_, _, _) => "CorporateBallot.MetaChanged",
                            Self::RCVChanged(_, _, _) => "CorporateBallot.RCVChanged",
                            Self::Removed(_, _) => "CorporateBallot.Removed",
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for CorporateBallotEvent {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: Created (_ , _ , _ , _ , _) => { & ["A corporate ballot was created." , "" , "(Agent DID, CA's ID, Voting start/end, Ballot metadata, RCV enabled?)" ,] } , Self :: VoteCast (_ , _ , _) => { & ["A vote was cast in a corporate ballot." , "" , "(voter DID, CAId, Votes)" ,] } , Self :: RangeChanged (_ , _ , _) => { & ["A corporate ballot changed its start/end date range." , "" , "(Agent DID, CA's ID, Voting start/end)" ,] } , Self :: MetaChanged (_ , _ , _) => { & ["A corporate ballot changed its metadata." , "" , "(Agent DID, CA's ID, New metadata)" ,] } , Self :: RCVChanged (_ , _ , _) => { & ["A corporate ballot changed its RCV support." , "" , "(Agent DID, CA's ID, New support)" ,] } , Self :: Removed (_ , _) => { & ["A corporate ballot was removed." , "" , "(Agent DID, CA's ID)" ,] } , _ => & [""] , }
                    }
                }
                impl From<CorporateBallotEvent> for &'static str {
                    fn from(v: CorporateBallotEvent) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&CorporateBallotEvent> for &'static str {
                    fn from(v: &CorporateBallotEvent) -> Self {
                        v.as_static_str()
                    }
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct BallotMeta {
                pub title: pallet_corporate_actions::ballot::BallotTitle,
                pub motions: ::alloc::vec::Vec<pallet_corporate_actions::ballot::Motion>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct BallotTimeRange {
                pub start: u64,
                pub end: u64,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct BallotTitle(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct BallotVote {
                pub power: u128,
                pub fallback: Option<u16>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ChoiceTitle(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Motion {
                pub title: pallet_corporate_actions::ballot::MotionTitle,
                pub info_link: pallet_corporate_actions::ballot::MotionInfoLink,
                pub choices: ::alloc::vec::Vec<pallet_corporate_actions::ballot::ChoiceTitle>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct MotionInfoLink(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct MotionTitle(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Version(pub u8);
        }
        pub mod distribution {
            use super::*;
            pub mod pallet {
                use super::*;
                #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum CapitalDistributionCall {
                    #[doc = "Start and attach a capital distribution, to the CA identified by `ca_id`,"]
                    #[doc = "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID."]
                    #[doc = ""]
                    #[doc = "The distribution will commence at `payment_at` and expire at `expires_at`,"]
                    #[doc = "if provided, or if `None`, then there's no expiry."]
                    #[doc = ""]
                    #[doc = "The funds will be locked in `portfolio` from when `distribute` is called."]
                    #[doc = "When there's no expiry, some funds may be locked indefinitely in `portfolio`,"]
                    #[doc = "due to claimants not withdrawing or no benefits being pushed to them."]
                    #[doc = "For indivisible currencies, unlocked amounts, of less than one whole unit,"]
                    #[doc = "will not be transferable from `portfolio`."]
                    #[doc = "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units,"]
                    #[doc = "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`,"]
                    #[doc = "which is now transferrable."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
                    #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
                    #[doc = "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from."]
                    #[doc = "- `currency` to withdraw and distribute from the `portfolio`."]
                    #[doc = "- `per_share` amount of `currency` to withdraw and distribute."]
                    #[doc = "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token."]
                    #[doc = "- `amount` of `currency` to withdraw and distribute at most."]
                    #[doc = "- `payment_at` specifies when benefits may first be pushed or claimed."]
                    #[doc = "- `expires_at` specifies, if provided, when remaining benefits are forfeit"]
                    #[doc = "   and may be reclaimed by `origin`."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                    #[doc = "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`."]
                    #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
                    #[doc = "- `NoRecordDate` if CA has no record date."]
                    #[doc = "- `RecordDateAfterStart` if CA's record date > payment_at."]
                    #[doc = "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`."]
                    #[doc = "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`."]
                    #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
                    #[doc = "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit"]
                    #[doc = "- `DistributionAmountIsZero` if the `amount` is zero."]
                    #[doc = "- `DistributionPerShareIsZero` if the `per_share` is zero."]
                    #[doc = ""]
                    #[doc = "# Permissions"]
                    #[doc = "* Asset"]
                    #[doc = "* Portfolio"]
                    #[codec(index = 0u8)]
                    distribute {
                        ca_id: pallet_corporate_actions::CAId,
                        portfolio: Option<polymesh_primitives::identity_id::PortfolioNumber>,
                        currency: ::polymesh_api_client::AssetId,
                        per_share: u128,
                        amount: u128,
                        payment_at: u64,
                        expires_at: Option<u64>,
                    },
                    #[doc = "Claim a benefit of the capital distribution attached to `ca_id`."]
                    #[doc = ""]
                    #[doc = "Taxes are withheld as specified by the CA."]
                    #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
                    #[doc = ""]
                    #[doc = "All benefits are rounded by truncation, down to first integer below."]
                    #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
                    #[doc = "they are rounded down to a whole unit."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` which must be a holder of the asset and eligible for the distribution."]
                    #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit."]
                    #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
                    #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
                    #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
                    #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
                    #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
                    #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
                    #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
                    #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
                    #[codec(index = 1u8)]
                    claim {
                        ca_id: pallet_corporate_actions::CAId,
                    },
                    #[doc = "Push benefit of an ongoing distribution to the given `holder`."]
                    #[doc = ""]
                    #[doc = "Taxes are withheld as specified by the CA."]
                    #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
                    #[doc = ""]
                    #[doc = "All benefits are rounded by truncation, down to first integer below."]
                    #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
                    #[doc = "they are rounded down to a whole unit."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
                    #[doc = "- `ca_id` identifies the CA with a capital distributions to push benefits for."]
                    #[doc = "- `holder` to push benefits to."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                    #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
                    #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
                    #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
                    #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
                    #[doc = "- `NotTargetedByCA` if the CA does not target `holder`."]
                    #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
                    #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
                    #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
                    #[codec(index = 2u8)]
                    push_benefit {
                        ca_id: pallet_corporate_actions::CAId,
                        holder: ::polymesh_api_client::IdentityId,
                    },
                    #[doc = "Assuming a distribution has expired,"]
                    #[doc = "unlock the remaining amount in the distributor portfolio."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` which must be the creator of the capital distribution tied to `ca_id`."]
                    #[doc = "- `ca_id` identifies the CA with a capital distribution to reclaim for."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
                    #[doc = "- `AlreadyReclaimed` if this function has already been called successfully."]
                    #[doc = "- `NotExpired` if `now < expiry`."]
                    #[codec(index = 3u8)]
                    reclaim {
                        ca_id: pallet_corporate_actions::CAId,
                    },
                    #[doc = "Removes a distribution that hasn't started yet,"]
                    #[doc = "unlocking the full amount in the distributor portfolio."]
                    #[doc = ""]
                    #[doc = "## Arguments"]
                    #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
                    #[doc = "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove."]
                    #[doc = ""]
                    #[doc = "# Errors"]
                    #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                    #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
                    #[doc = "- `DistributionStarted` if `payment_at <= now`."]
                    #[codec(index = 4u8)]
                    remove_distribution {
                        ca_id: pallet_corporate_actions::CAId,
                    },
                }
                impl CapitalDistributionCall {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::distribute { .. } => "CapitalDistribution.distribute",
                            Self::claim { .. } => "CapitalDistribution.claim",
                            Self::push_benefit { .. } => "CapitalDistribution.push_benefit",
                            Self::reclaim { .. } => "CapitalDistribution.reclaim",
                            Self::remove_distribution { .. } => {
                                "CapitalDistribution.remove_distribution"
                            }
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for CapitalDistributionCall {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: distribute { .. } => { & ["Start and attach a capital distribution, to the CA identified by `ca_id`," , "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID." , "" , "The distribution will commence at `payment_at` and expire at `expires_at`," , "if provided, or if `None`, then there's no expiry." , "" , "The funds will be locked in `portfolio` from when `distribute` is called." , "When there's no expiry, some funds may be locked indefinitely in `portfolio`," , "due to claimants not withdrawing or no benefits being pushed to them." , "For indivisible currencies, unlocked amounts, of less than one whole unit," , "will not be transferable from `portfolio`." , "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units," , "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`," , "which is now transferrable." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the CA to start a capital distribution for." , "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from." , "- `currency` to withdraw and distribute from the `portfolio`." , "- `per_share` amount of `currency` to withdraw and distribute." , "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token." , "- `amount` of `currency` to withdraw and distribute at most." , "- `payment_at` specifies when benefits may first be pushed or claimed." , "- `expires_at` specifies, if provided, when remaining benefits are forfeit" , "   and may be reclaimed by `origin`." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NoRecordDate` if CA has no record date." , "- `RecordDateAfterStart` if CA's record date > payment_at." , "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`." , "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`." , "- `InsufficientBalance` if the protocol fee couldn't be charged." , "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit" , "- `DistributionAmountIsZero` if the `amount` is zero." , "- `DistributionPerShareIsZero` if the `per_share` is zero." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: claim { .. } => { & ["Claim a benefit of the capital distribution attached to `ca_id`." , "" , "Taxes are withheld as specified by the CA." , "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID." , "" , "All benefits are rounded by truncation, down to first integer below." , "Moreover, before post-tax earnings, in indivisible currencies are transferred," , "they are rounded down to a whole unit." , "" , "## Arguments" , "- `origin` which must be a holder of the asset and eligible for the distribution." , "- `ca_id` identifies the CA to start a capital distribution for." , "" , "# Errors" , "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit." , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `CannotClaimBeforeStart` if `now < payment_at`." , "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NotTargetedByCA` if the CA does not target `origin`'s DID." , "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow." , "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow." , "- Other errors can occur if the compliance manager rejects the transfer." ,] } , Self :: push_benefit { .. } => { & ["Push benefit of an ongoing distribution to the given `holder`." , "" , "Taxes are withheld as specified by the CA." , "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID." , "" , "All benefits are rounded by truncation, down to first integer below." , "Moreover, before post-tax earnings, in indivisible currencies are transferred," , "they are rounded down to a whole unit." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the CA with a capital distributions to push benefits for." , "- `holder` to push benefits to." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `CannotClaimBeforeStart` if `now < payment_at`." , "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`." , "- `NoSuchCA` if `ca_id` does not identify an existing CA." , "- `NotTargetedByCA` if the CA does not target `holder`." , "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow." , "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow." , "- Other errors can occur if the compliance manager rejects the transfer." ,] } , Self :: reclaim { .. } => { & ["Assuming a distribution has expired," , "unlock the remaining amount in the distributor portfolio." , "" , "## Arguments" , "- `origin` which must be the creator of the capital distribution tied to `ca_id`." , "- `ca_id` identifies the CA with a capital distribution to reclaim for." , "" , "# Errors" , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `AlreadyReclaimed` if this function has already been called successfully." , "- `NotExpired` if `now < expiry`." ,] } , Self :: remove_distribution { .. } => { & ["Removes a distribution that hasn't started yet," , "unlocking the full amount in the distributor portfolio." , "" , "## Arguments" , "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`." , "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchDistribution` if there's no capital distribution for `ca_id`." , "- `DistributionStarted` if `payment_at <= now`." ,] } , _ => & [""] , }
                    }
                }
                impl From<CapitalDistributionCall> for &'static str {
                    fn from(v: CapitalDistributionCall) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&CapitalDistributionCall> for &'static str {
                    fn from(v: &CapitalDistributionCall) -> Self {
                        v.as_static_str()
                    }
                }
                #[doc = "The `Error` enum of this pallet."]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum CapitalDistributionError {
                    #[doc = "A capital distribution was made for a non-benefit CA."]
                    #[codec(index = 0u8)]
                    CANotBenefit,
                    #[doc = "A distribution already exists for this CA."]
                    #[codec(index = 1u8)]
                    AlreadyExists,
                    #[doc = "A distributions provided expiry date was strictly before its payment date."]
                    #[doc = "In other words, everything to distribute would immediately be forfeited."]
                    #[codec(index = 2u8)]
                    ExpiryBeforePayment,
                    #[doc = "The token holder has already been paid their benefit."]
                    #[codec(index = 3u8)]
                    HolderAlreadyPaid,
                    #[doc = "A capital distribution doesn't exist for this CA."]
                    #[codec(index = 4u8)]
                    NoSuchDistribution,
                    #[doc = "Distribution allotment cannot be claimed as the current time is before start-of-payment."]
                    #[codec(index = 5u8)]
                    CannotClaimBeforeStart,
                    #[doc = "Distribution's expiry has passed. DID cannot claim anymore and has forfeited the benefits."]
                    #[codec(index = 6u8)]
                    CannotClaimAfterExpiry,
                    #[doc = "Multiplication of the balance with the per share payout amount overflowed."]
                    #[codec(index = 7u8)]
                    BalancePerShareProductOverflowed,
                    #[doc = "DID is not the one who created the distribution."]
                    #[codec(index = 8u8)]
                    NotDistributionCreator,
                    #[doc = "DID who created the distribution already did reclaim."]
                    #[codec(index = 9u8)]
                    AlreadyReclaimed,
                    #[doc = "Distribution had not expired yet, or there's no expiry date."]
                    #[codec(index = 10u8)]
                    NotExpired,
                    #[doc = "A distribution has been activated, as `payment_at <= now` holds."]
                    #[codec(index = 11u8)]
                    DistributionStarted,
                    #[doc = "A distribution has insufficient remaining amount of currency to distribute."]
                    #[codec(index = 12u8)]
                    InsufficientRemainingAmount,
                    #[doc = "Distribution `amount` cannot be zero."]
                    #[codec(index = 13u8)]
                    DistributionAmountIsZero,
                    #[doc = "Distribution `per_share` cannot be zero."]
                    #[codec(index = 14u8)]
                    DistributionPerShareIsZero,
                }
                impl CapitalDistributionError {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::CANotBenefit => "CapitalDistribution.CANotBenefit",
                            Self::AlreadyExists => "CapitalDistribution.AlreadyExists",
                            Self::ExpiryBeforePayment => "CapitalDistribution.ExpiryBeforePayment",
                            Self::HolderAlreadyPaid => "CapitalDistribution.HolderAlreadyPaid",
                            Self::NoSuchDistribution => "CapitalDistribution.NoSuchDistribution",
                            Self::CannotClaimBeforeStart => {
                                "CapitalDistribution.CannotClaimBeforeStart"
                            }
                            Self::CannotClaimAfterExpiry => {
                                "CapitalDistribution.CannotClaimAfterExpiry"
                            }
                            Self::BalancePerShareProductOverflowed => {
                                "CapitalDistribution.BalancePerShareProductOverflowed"
                            }
                            Self::NotDistributionCreator => {
                                "CapitalDistribution.NotDistributionCreator"
                            }
                            Self::AlreadyReclaimed => "CapitalDistribution.AlreadyReclaimed",
                            Self::NotExpired => "CapitalDistribution.NotExpired",
                            Self::DistributionStarted => "CapitalDistribution.DistributionStarted",
                            Self::InsufficientRemainingAmount => {
                                "CapitalDistribution.InsufficientRemainingAmount"
                            }
                            Self::DistributionAmountIsZero => {
                                "CapitalDistribution.DistributionAmountIsZero"
                            }
                            Self::DistributionPerShareIsZero => {
                                "CapitalDistribution.DistributionPerShareIsZero"
                            }
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for CapitalDistributionError {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: CANotBenefit => { & ["A capital distribution was made for a non-benefit CA." ,] } , Self :: AlreadyExists => { & ["A distribution already exists for this CA." ,] } , Self :: ExpiryBeforePayment => { & ["A distributions provided expiry date was strictly before its payment date." , "In other words, everything to distribute would immediately be forfeited." ,] } , Self :: HolderAlreadyPaid => { & ["The token holder has already been paid their benefit." ,] } , Self :: NoSuchDistribution => { & ["A capital distribution doesn't exist for this CA." ,] } , Self :: CannotClaimBeforeStart => { & ["Distribution allotment cannot be claimed as the current time is before start-of-payment." ,] } , Self :: CannotClaimAfterExpiry => { & ["Distribution's expiry has passed. DID cannot claim anymore and has forfeited the benefits." ,] } , Self :: BalancePerShareProductOverflowed => { & ["Multiplication of the balance with the per share payout amount overflowed." ,] } , Self :: NotDistributionCreator => { & ["DID is not the one who created the distribution." ,] } , Self :: AlreadyReclaimed => { & ["DID who created the distribution already did reclaim." ,] } , Self :: NotExpired => { & ["Distribution had not expired yet, or there's no expiry date." ,] } , Self :: DistributionStarted => { & ["A distribution has been activated, as `payment_at <= now` holds." ,] } , Self :: InsufficientRemainingAmount => { & ["A distribution has insufficient remaining amount of currency to distribute." ,] } , Self :: DistributionAmountIsZero => { & ["Distribution `amount` cannot be zero." ,] } , Self :: DistributionPerShareIsZero => { & ["Distribution `per_share` cannot be zero." ,] } , _ => & [""] , }
                    }
                }
                impl From<CapitalDistributionError> for &'static str {
                    fn from(v: CapitalDistributionError) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&CapitalDistributionError> for &'static str {
                    fn from(v: &CapitalDistributionError) -> Self {
                        v.as_static_str()
                    }
                }
                #[doc = "The `Event` enum of this pallet"]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum CapitalDistributionEvent {
                    #[doc = "A capital distribution, with details included,"]
                    #[doc = "was created by the DID (permissioned agent) for the CA identified by `CAId`."]
                    #[doc = ""]
                    #[doc = "(Agent DID, CA's ID, distribution details)"]
                    #[codec(index = 0u8)]
                    Created(
                        polymesh_primitives::event_only::EventOnly<
                            ::polymesh_api_client::IdentityId,
                        >,
                        pallet_corporate_actions::CAId,
                        pallet_corporate_actions::distribution::Distribution,
                    ),
                    #[doc = "A token holder's benefit of a capital distribution for the given `CAId` was claimed."]
                    #[doc = ""]
                    #[doc = "(Caller DID, Holder/Claimant DID, CA's ID, updated distribution details, DID's benefit, DID's tax %)"]
                    #[codec(index = 1u8)]
                    BenefitClaimed(
                        polymesh_primitives::event_only::EventOnly<
                            ::polymesh_api_client::IdentityId,
                        >,
                        polymesh_primitives::event_only::EventOnly<
                            ::polymesh_api_client::IdentityId,
                        >,
                        pallet_corporate_actions::CAId,
                        pallet_corporate_actions::distribution::Distribution,
                        u128,
                        ::polymesh_api_client::per_things::Permill,
                    ),
                    #[doc = "Stats from `push_benefit` was emitted."]
                    #[doc = ""]
                    #[doc = "(Agent DID, CA's ID, max requested DIDs, processed DIDs, failed DIDs)"]
                    #[codec(index = 2u8)]
                    Reclaimed(
                        polymesh_primitives::event_only::EventOnly<
                            ::polymesh_api_client::IdentityId,
                        >,
                        pallet_corporate_actions::CAId,
                        u128,
                    ),
                    #[doc = "A capital distribution was removed."]
                    #[doc = ""]
                    #[doc = "(Agent DID, CA's ID)"]
                    #[codec(index = 3u8)]
                    Removed(
                        polymesh_primitives::event_only::EventOnly<
                            ::polymesh_api_client::IdentityId,
                        >,
                        pallet_corporate_actions::CAId,
                    ),
                }
                impl CapitalDistributionEvent {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::Created(_, _, _) => "CapitalDistribution.Created",
                            Self::BenefitClaimed(_, _, _, _, _, _) => {
                                "CapitalDistribution.BenefitClaimed"
                            }
                            Self::Reclaimed(_, _, _) => "CapitalDistribution.Reclaimed",
                            Self::Removed(_, _) => "CapitalDistribution.Removed",
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for CapitalDistributionEvent {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: Created (_ , _ , _) => { & ["A capital distribution, with details included," , "was created by the DID (permissioned agent) for the CA identified by `CAId`." , "" , "(Agent DID, CA's ID, distribution details)" ,] } , Self :: BenefitClaimed (_ , _ , _ , _ , _ , _) => { & ["A token holder's benefit of a capital distribution for the given `CAId` was claimed." , "" , "(Caller DID, Holder/Claimant DID, CA's ID, updated distribution details, DID's benefit, DID's tax %)" ,] } , Self :: Reclaimed (_ , _ , _) => { & ["Stats from `push_benefit` was emitted." , "" , "(Agent DID, CA's ID, max requested DIDs, processed DIDs, failed DIDs)" ,] } , Self :: Removed (_ , _) => { & ["A capital distribution was removed." , "" , "(Agent DID, CA's ID)" ,] } , _ => & [""] , }
                    }
                }
                impl From<CapitalDistributionEvent> for &'static str {
                    fn from(v: CapitalDistributionEvent) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&CapitalDistributionEvent> for &'static str {
                    fn from(v: &CapitalDistributionEvent) -> Self {
                        v.as_static_str()
                    }
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Distribution {
                pub from: polymesh_primitives::identity_id::PortfolioId,
                pub currency: ::polymesh_api_client::AssetId,
                pub per_share: u128,
                pub amount: u128,
                pub remaining: u128,
                pub reclaimed: bool,
                pub payment_at: u64,
                pub expires_at: Option<u64>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Version(pub u8);
        }
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum CorporateActionCall {
                #[doc = "Set the max `length` of `details` in terms of bytes."]
                #[doc = "May only be called via a PIP."]
                #[codec(index = 0u8)]
                set_max_details_length { length: u32 },
                #[doc = "Set the default CA `TargetIdentities` to `targets`."]
                #[doc = ""]
                #[doc = "## Arguments"]
                #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
                #[doc = "- `asset_id` for which the default identities are changing."]
                #[doc = "- `targets` the default target identities for a CA."]
                #[doc = ""]
                #[doc = "## Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                #[doc = "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 1u8)]
                set_default_targets {
                    asset_id: ::polymesh_api_client::AssetId,
                    targets: pallet_corporate_actions::TargetIdentities,
                },
                #[doc = "Set the default withholding tax for all DIDs and CAs relevant to this `asset_id`."]
                #[doc = ""]
                #[doc = "## Arguments"]
                #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
                #[doc = "- `asset_id` that the withholding tax will apply to."]
                #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
                #[doc = ""]
                #[doc = "## Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 2u8)]
                set_default_withholding_tax {
                    asset_id: ::polymesh_api_client::AssetId,
                    tax: ::polymesh_api_client::per_things::Permill,
                },
                #[doc = "Set the withholding tax of `asset_id` for `taxed_did` to `tax`."]
                #[doc = "If `Some(tax)`, this overrides the default withholding tax of `asset_id` to `tax` for `taxed_did`."]
                #[doc = "Otherwise, if `None`, the default withholding tax will be used."]
                #[doc = ""]
                #[doc = "## Arguments"]
                #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
                #[doc = "- `asset_id` that the withholding tax will apply to."]
                #[doc = "- `taxed_did` that will have its withholding tax updated."]
                #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
                #[doc = ""]
                #[doc = "## Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                #[doc = "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 3u8)]
                set_did_withholding_tax {
                    asset_id: ::polymesh_api_client::AssetId,
                    taxed_did: ::polymesh_api_client::IdentityId,
                    tax: Option<::polymesh_api_client::per_things::Permill>,
                },
                #[doc = "Initiates a CA for `asset_id` of `kind` with `details` and other provided arguments."]
                #[doc = ""]
                #[doc = "## Arguments"]
                #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
                #[doc = "- `asset_id` that the CA is made for."]
                #[doc = "- `kind` of CA being initiated."]
                #[doc = "- `decl_date` of CA bring initialized."]
                #[doc = "- `record_date`, if any, to calculate the impact of this CA."]
                #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
                #[doc = "- `details` of the CA in free-text form, up to a certain number of bytes in length."]
                #[doc = "- `targets`, if any, which this CA is relevant/irrelevant to."]
                #[doc = "   Overrides, if provided, the default at the asset level (`set_default_targets`)."]
                #[doc = "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA."]
                #[doc = "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)."]
                #[doc = "- `withholding_tax`, if any, provides per-DID withholding tax overrides."]
                #[doc = "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`."]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                #[doc = "- `CounterOverflow` in the unlikely event that so many CAs were created for this `asset_id`,"]
                #[doc = "  that integer overflow would have occured if instead allowed."]
                #[doc = "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`."]
                #[doc = "- `DuplicateDidTax` if a DID is included more than once in `wt`."]
                #[doc = "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`."]
                #[doc = "- `DeclDateInFuture` if the declaration date is not in the past."]
                #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 4u8)]
                initiate_corporate_action {
                    asset_id: ::polymesh_api_client::AssetId,
                    kind: pallet_corporate_actions::CAKind,
                    decl_date: u64,
                    record_date: Option<pallet_corporate_actions::RecordDateSpec>,
                    details: pallet_corporate_actions::CADetails,
                    targets: Option<pallet_corporate_actions::TargetIdentities>,
                    default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
                    withholding_tax: Option<
                        ::alloc::vec::Vec<(
                            ::polymesh_api_client::IdentityId,
                            ::polymesh_api_client::per_things::Permill,
                        )>,
                    >,
                },
                #[doc = "Link the given CA `id` to the given `docs`."]
                #[doc = "Any previous links for the CA are removed in favor of `docs`."]
                #[doc = ""]
                #[doc = "The workflow here is to add the documents and initiating the CA in any order desired."]
                #[doc = "Once both exist, they can now be linked together."]
                #[doc = ""]
                #[doc = "## Arguments"]
                #[doc = "- `origin` which must be an external agent of `id.asset_id` with relevant permissions."]
                #[doc = "- `id` of the CA to associate with `docs`."]
                #[doc = "- `docs` to associate with the CA with `id`."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
                #[doc = "- `NoSuchDoc` if any of `docs` does not identify an existing document."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 5u8)]
                link_ca_doc {
                    id: pallet_corporate_actions::CAId,
                    docs: ::alloc::vec::Vec<polymesh_primitives::document::DocumentId>,
                },
                #[doc = "Removes the CA identified by `ca_id`."]
                #[doc = ""]
                #[doc = "Associated data, such as document links, ballots,"]
                #[doc = "and capital distributions are also removed."]
                #[doc = ""]
                #[doc = "Any schedule associated with the record date will see"]
                #[doc = "`strong_ref_count(schedule_id)` decremented."]
                #[doc = ""]
                #[doc = "## Arguments"]
                #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
                #[doc = "- `ca_id` of the CA to remove."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 6u8)]
                remove_ca {
                    ca_id: pallet_corporate_actions::CAId,
                },
                #[doc = "Changes the record date of the CA identified by `ca_id`."]
                #[doc = ""]
                #[doc = "## Arguments"]
                #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
                #[doc = "- `ca_id` of the CA to alter."]
                #[doc = "- `record_date`, if any, to calculate the impact of the CA."]
                #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
                #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 7u8)]
                change_record_date {
                    ca_id: pallet_corporate_actions::CAId,
                    record_date: Option<pallet_corporate_actions::RecordDateSpec>,
                },
                #[doc = "Utility extrinsic to batch `initiate_corporate_action` and `distribute`"]
                #[codec(index = 8u8)]
                initiate_corporate_action_and_distribute {
                    ca_args: pallet_corporate_actions::InitiateCorporateActionArgs,
                    portfolio: Option<polymesh_primitives::identity_id::PortfolioNumber>,
                    currency: ::polymesh_api_client::AssetId,
                    per_share: u128,
                    amount: u128,
                    payment_at: u64,
                    expires_at: Option<u64>,
                },
                #[codec(index = 9u8)]
                initiate_corporate_action_and_ballot {
                    ca_args: pallet_corporate_actions::InitiateCorporateActionArgs,
                    ballot_time_range: pallet_corporate_actions::ballot::BallotTimeRange,
                    ballot_meta: pallet_corporate_actions::ballot::BallotMeta,
                    rcv: bool,
                },
            }
            impl CorporateActionCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::set_max_details_length { .. } => {
                            "CorporateAction.set_max_details_length"
                        }
                        Self::set_default_targets { .. } => "CorporateAction.set_default_targets",
                        Self::set_default_withholding_tax { .. } => {
                            "CorporateAction.set_default_withholding_tax"
                        }
                        Self::set_did_withholding_tax { .. } => {
                            "CorporateAction.set_did_withholding_tax"
                        }
                        Self::initiate_corporate_action { .. } => {
                            "CorporateAction.initiate_corporate_action"
                        }
                        Self::link_ca_doc { .. } => "CorporateAction.link_ca_doc",
                        Self::remove_ca { .. } => "CorporateAction.remove_ca",
                        Self::change_record_date { .. } => "CorporateAction.change_record_date",
                        Self::initiate_corporate_action_and_distribute { .. } => {
                            "CorporateAction.initiate_corporate_action_and_distribute"
                        }
                        Self::initiate_corporate_action_and_ballot { .. } => {
                            "CorporateAction.initiate_corporate_action_and_ballot"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for CorporateActionCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: set_max_details_length { .. } => { & ["Set the max `length` of `details` in terms of bytes." , "May only be called via a PIP." ,] } , Self :: set_default_targets { .. } => { & ["Set the default CA `TargetIdentities` to `targets`." , "" , "## Arguments" , "- `origin` which must be an external agent of `asset_id` with relevant permissions." , "- `asset_id` for which the default identities are changing." , "- `targets` the default target identities for a CA." , "" , "## Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`." , "" , "# Permissions" , "* Asset" ,] } , Self :: set_default_withholding_tax { .. } => { & ["Set the default withholding tax for all DIDs and CAs relevant to this `asset_id`." , "" , "## Arguments" , "- `origin` which must be an external agent of `asset_id` with relevant permissions." , "- `asset_id` that the withholding tax will apply to." , "- `tax` that should be withheld when distributing dividends, etc." , "" , "## Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "" , "# Permissions" , "* Asset" ,] } , Self :: set_did_withholding_tax { .. } => { & ["Set the withholding tax of `asset_id` for `taxed_did` to `tax`." , "If `Some(tax)`, this overrides the default withholding tax of `asset_id` to `tax` for `taxed_did`." , "Otherwise, if `None`, the default withholding tax will be used." , "" , "## Arguments" , "- `origin` which must be an external agent of `asset_id` with relevant permissions." , "- `asset_id` that the withholding tax will apply to." , "- `taxed_did` that will have its withholding tax updated." , "- `tax` that should be withheld when distributing dividends, etc." , "" , "## Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`." , "" , "# Permissions" , "* Asset" ,] } , Self :: initiate_corporate_action { .. } => { & ["Initiates a CA for `asset_id` of `kind` with `details` and other provided arguments." , "" , "## Arguments" , "- `origin` which must be an external agent of `asset_id` with relevant permissions." , "- `asset_id` that the CA is made for." , "- `kind` of CA being initiated." , "- `decl_date` of CA bring initialized." , "- `record_date`, if any, to calculate the impact of this CA." , "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date." , "- `details` of the CA in free-text form, up to a certain number of bytes in length." , "- `targets`, if any, which this CA is relevant/irrelevant to." , "   Overrides, if provided, the default at the asset level (`set_default_targets`)." , "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA." , "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)." , "- `withholding_tax`, if any, provides per-DID withholding tax overrides." , "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)." , "" , "# Errors" , "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `CounterOverflow` in the unlikely event that so many CAs were created for this `asset_id`," , "  that integer overflow would have occured if instead allowed." , "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`." , "- `DuplicateDidTax` if a DID is included more than once in `wt`." , "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`." , "- `DeclDateInFuture` if the declaration date is not in the past." , "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur." , "" , "# Permissions" , "* Asset" ,] } , Self :: link_ca_doc { .. } => { & ["Link the given CA `id` to the given `docs`." , "Any previous links for the CA are removed in favor of `docs`." , "" , "The workflow here is to add the documents and initiating the CA in any order desired." , "Once both exist, they can now be linked together." , "" , "## Arguments" , "- `origin` which must be an external agent of `id.asset_id` with relevant permissions." , "- `id` of the CA to associate with `docs`." , "- `docs` to associate with the CA with `id`." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchCA` if `id` does not identify an existing CA." , "- `NoSuchDoc` if any of `docs` does not identify an existing document." , "" , "# Permissions" , "* Asset" ,] } , Self :: remove_ca { .. } => { & ["Removes the CA identified by `ca_id`." , "" , "Associated data, such as document links, ballots," , "and capital distributions are also removed." , "" , "Any schedule associated with the record date will see" , "`strong_ref_count(schedule_id)` decremented." , "" , "## Arguments" , "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions." , "- `ca_id` of the CA to remove." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchCA` if `id` does not identify an existing CA." , "" , "# Permissions" , "* Asset" ,] } , Self :: change_record_date { .. } => { & ["Changes the record date of the CA identified by `ca_id`." , "" , "## Arguments" , "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions." , "- `ca_id` of the CA to alter." , "- `record_date`, if any, to calculate the impact of the CA." , "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "- `NoSuchCA` if `id` does not identify an existing CA." , "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur." , "" , "# Permissions" , "* Asset" ,] } , Self :: initiate_corporate_action_and_distribute { .. } => { & ["Utility extrinsic to batch `initiate_corporate_action` and `distribute`" ,] } , Self :: initiate_corporate_action_and_ballot { .. } => { & ["" ,] } , _ => & [""] , }
                }
            }
            impl From<CorporateActionCall> for &'static str {
                fn from(v: CorporateActionCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&CorporateActionCall> for &'static str {
                fn from(v: &CorporateActionCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum CorporateActionError {
                #[doc = "The `details` of a CA exceeded the max allowed length."]
                #[codec(index = 0u8)]
                DetailsTooLong,
                #[doc = "A withholding tax override for a given DID was specified more than once."]
                #[doc = "The chain refused to make a choice, and hence there was an error."]
                #[codec(index = 1u8)]
                DuplicateDidTax,
                #[doc = "Too many withholding tax overrides were specified."]
                #[codec(index = 2u8)]
                TooManyDidTaxes,
                #[doc = "Too many identities in `TargetIdentities` were specified."]
                #[codec(index = 3u8)]
                TooManyTargetIds,
                #[doc = "On CA creation, a checkpoint ID was provided which doesn't exist."]
                #[codec(index = 4u8)]
                NoSuchCheckpointId,
                #[doc = "A CA with the given `CAId` did not exist."]
                #[codec(index = 5u8)]
                NoSuchCA,
                #[doc = "The CA did not have a record date."]
                #[codec(index = 6u8)]
                NoRecordDate,
                #[doc = "A CA's record date was strictly after the \"start\" time,"]
                #[doc = "where \"start\" is context dependent."]
                #[doc = "For example, it could be the start of a ballot, or the start-of-payment in capital distribution."]
                #[codec(index = 7u8)]
                RecordDateAfterStart,
                #[doc = "A CA's declaration date was strictly after its record date."]
                #[codec(index = 8u8)]
                DeclDateAfterRecordDate,
                #[doc = "A CA's declaration date occurs in the future."]
                #[codec(index = 9u8)]
                DeclDateInFuture,
                #[doc = "CA does not target the DID."]
                #[codec(index = 10u8)]
                NotTargetedByCA,
            }
            impl CorporateActionError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::DetailsTooLong => "CorporateAction.DetailsTooLong",
                        Self::DuplicateDidTax => "CorporateAction.DuplicateDidTax",
                        Self::TooManyDidTaxes => "CorporateAction.TooManyDidTaxes",
                        Self::TooManyTargetIds => "CorporateAction.TooManyTargetIds",
                        Self::NoSuchCheckpointId => "CorporateAction.NoSuchCheckpointId",
                        Self::NoSuchCA => "CorporateAction.NoSuchCA",
                        Self::NoRecordDate => "CorporateAction.NoRecordDate",
                        Self::RecordDateAfterStart => "CorporateAction.RecordDateAfterStart",
                        Self::DeclDateAfterRecordDate => "CorporateAction.DeclDateAfterRecordDate",
                        Self::DeclDateInFuture => "CorporateAction.DeclDateInFuture",
                        Self::NotTargetedByCA => "CorporateAction.NotTargetedByCA",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for CorporateActionError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: DetailsTooLong => { & ["The `details` of a CA exceeded the max allowed length." ,] } , Self :: DuplicateDidTax => { & ["A withholding tax override for a given DID was specified more than once." , "The chain refused to make a choice, and hence there was an error." ,] } , Self :: TooManyDidTaxes => { & ["Too many withholding tax overrides were specified." ,] } , Self :: TooManyTargetIds => { & ["Too many identities in `TargetIdentities` were specified." ,] } , Self :: NoSuchCheckpointId => { & ["On CA creation, a checkpoint ID was provided which doesn't exist." ,] } , Self :: NoSuchCA => { & ["A CA with the given `CAId` did not exist." ,] } , Self :: NoRecordDate => { & ["The CA did not have a record date." ,] } , Self :: RecordDateAfterStart => { & ["A CA's record date was strictly after the \"start\" time," , "where \"start\" is context dependent." , "For example, it could be the start of a ballot, or the start-of-payment in capital distribution." ,] } , Self :: DeclDateAfterRecordDate => { & ["A CA's declaration date was strictly after its record date." ,] } , Self :: DeclDateInFuture => { & ["A CA's declaration date occurs in the future." ,] } , Self :: NotTargetedByCA => { & ["CA does not target the DID." ,] } , _ => & [""] , }
                }
            }
            impl From<CorporateActionError> for &'static str {
                fn from(v: CorporateActionError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&CorporateActionError> for &'static str {
                fn from(v: &CorporateActionError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum CorporateActionEvent {
                #[doc = "The maximum length of `details` in bytes was changed."]
                #[doc = "(GC DID, new length)"]
                #[codec(index = 0u8)]
                MaxDetailsLengthChanged(::polymesh_api_client::IdentityId, u32),
                #[doc = "The set of default `TargetIdentities` for the asset changed."]
                #[doc = "(Agent DID, AssetId, New TargetIdentities)"]
                #[codec(index = 1u8)]
                DefaultTargetIdentitiesChanged(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    pallet_corporate_actions::TargetIdentities,
                ),
                #[doc = "The default withholding tax for the asset changed."]
                #[doc = "(Agent DID, AssetId, New Tax)."]
                #[codec(index = 2u8)]
                DefaultWithholdingTaxChanged(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::polymesh_api_client::per_things::Permill,
                ),
                #[doc = "The withholding tax specific to a DID for the asset changed."]
                #[doc = "(Agent DID, AssetId, Taxed DID, New Tax)."]
                #[codec(index = 3u8)]
                DidWithholdingTaxChanged(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::polymesh_api_client::IdentityId,
                    Option<::polymesh_api_client::per_things::Permill>,
                ),
                #[doc = "A CA was initiated."]
                #[doc = "(Agent DID, CA id, the CA, the CA details)"]
                #[codec(index = 4u8)]
                CAInitiated(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    pallet_corporate_actions::CAId,
                    pallet_corporate_actions::CorporateAction,
                    pallet_corporate_actions::CADetails,
                ),
                #[doc = "A CA was linked to a set of docs."]
                #[doc = "(Agent DID, CA Id, List of doc identifiers)"]
                #[codec(index = 5u8)]
                CALinkedToDoc(
                    ::polymesh_api_client::IdentityId,
                    pallet_corporate_actions::CAId,
                    ::alloc::vec::Vec<polymesh_primitives::document::DocumentId>,
                ),
                #[doc = "A CA was removed."]
                #[doc = "(Agent DID, CA Id)"]
                #[codec(index = 6u8)]
                CARemoved(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    pallet_corporate_actions::CAId,
                ),
                #[doc = "A CA's record date changed."]
                #[codec(index = 7u8)]
                RecordDateChanged(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    pallet_corporate_actions::CAId,
                    pallet_corporate_actions::CorporateAction,
                ),
            }
            impl CorporateActionEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::MaxDetailsLengthChanged(_, _) => {
                            "CorporateAction.MaxDetailsLengthChanged"
                        }
                        Self::DefaultTargetIdentitiesChanged(_, _, _) => {
                            "CorporateAction.DefaultTargetIdentitiesChanged"
                        }
                        Self::DefaultWithholdingTaxChanged(_, _, _) => {
                            "CorporateAction.DefaultWithholdingTaxChanged"
                        }
                        Self::DidWithholdingTaxChanged(_, _, _, _) => {
                            "CorporateAction.DidWithholdingTaxChanged"
                        }
                        Self::CAInitiated(_, _, _, _) => "CorporateAction.CAInitiated",
                        Self::CALinkedToDoc(_, _, _) => "CorporateAction.CALinkedToDoc",
                        Self::CARemoved(_, _) => "CorporateAction.CARemoved",
                        Self::RecordDateChanged(_, _, _) => "CorporateAction.RecordDateChanged",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for CorporateActionEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::MaxDetailsLengthChanged(_, _) => &[
                            "The maximum length of `details` in bytes was changed.",
                            "(GC DID, new length)",
                        ],
                        Self::DefaultTargetIdentitiesChanged(_, _, _) => &[
                            "The set of default `TargetIdentities` for the asset changed.",
                            "(Agent DID, AssetId, New TargetIdentities)",
                        ],
                        Self::DefaultWithholdingTaxChanged(_, _, _) => &[
                            "The default withholding tax for the asset changed.",
                            "(Agent DID, AssetId, New Tax).",
                        ],
                        Self::DidWithholdingTaxChanged(_, _, _, _) => &[
                            "The withholding tax specific to a DID for the asset changed.",
                            "(Agent DID, AssetId, Taxed DID, New Tax).",
                        ],
                        Self::CAInitiated(_, _, _, _) => &[
                            "A CA was initiated.",
                            "(Agent DID, CA id, the CA, the CA details)",
                        ],
                        Self::CALinkedToDoc(_, _, _) => &[
                            "A CA was linked to a set of docs.",
                            "(Agent DID, CA Id, List of doc identifiers)",
                        ],
                        Self::CARemoved(_, _) => &["A CA was removed.", "(Agent DID, CA Id)"],
                        Self::RecordDateChanged(_, _, _) => &["A CA's record date changed."],
                        _ => &[""],
                    }
                }
            }
            impl From<CorporateActionEvent> for &'static str {
                fn from(v: CorporateActionEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&CorporateActionEvent> for &'static str {
                fn from(v: &CorporateActionEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum CACheckpoint {
            #[codec(index = 0u8)]
            Scheduled(polymesh_primitives::checkpoint::ScheduleId, u64),
            #[codec(index = 1u8)]
            Existing(polymesh_primitives::asset::CheckpointId),
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CADetails(pub ::alloc::vec::Vec<u8>);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CAId {
            pub asset_id: ::polymesh_api_client::AssetId,
            pub local_id: pallet_corporate_actions::LocalCAId,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum CAKind {
            #[codec(index = 0u8)]
            PredictableBenefit,
            #[codec(index = 1u8)]
            UnpredictableBenefit,
            #[codec(index = 2u8)]
            IssuerNotice,
            #[codec(index = 3u8)]
            Reorganization,
            #[codec(index = 4u8)]
            Other,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct CorporateAction {
            pub kind: pallet_corporate_actions::CAKind,
            pub decl_date: u64,
            pub record_date: Option<pallet_corporate_actions::RecordDate>,
            pub targets: pallet_corporate_actions::TargetIdentities,
            pub default_withholding_tax: ::polymesh_api_client::per_things::Permill,
            pub withholding_tax: ::alloc::vec::Vec<(
                ::polymesh_api_client::IdentityId,
                ::polymesh_api_client::per_things::Permill,
            )>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct InitiateCorporateActionArgs {
            pub asset_id: ::polymesh_api_client::AssetId,
            pub kind: pallet_corporate_actions::CAKind,
            pub decl_date: u64,
            pub record_date: Option<pallet_corporate_actions::RecordDateSpec>,
            pub details: pallet_corporate_actions::CADetails,
            pub targets: Option<pallet_corporate_actions::TargetIdentities>,
            pub default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
            pub withholding_tax: Option<
                ::alloc::vec::Vec<(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::per_things::Permill,
                )>,
            >,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct LocalCAId(pub u32);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct RecordDate {
            pub date: u64,
            pub checkpoint: pallet_corporate_actions::CACheckpoint,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum RecordDateSpec {
            #[codec(index = 0u8)]
            Scheduled(u64),
            #[codec(index = 1u8)]
            ExistingSchedule(polymesh_primitives::checkpoint::ScheduleId),
            #[codec(index = 2u8)]
            Existing(polymesh_primitives::asset::CheckpointId),
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct TargetIdentities {
            pub identities: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            pub treatment: pallet_corporate_actions::TargetTreatment,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum TargetTreatment {
            #[codec(index = 0u8)]
            Include,
            #[codec(index = 1u8)]
            Exclude,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Version(pub u8);
    }
    pub mod pallet_election_provider_multi_phase {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ElectionProviderMultiPhaseCall {
                #[doc = "Submit a solution for the unsigned phase."]
                #[doc = ""]
                #[doc = "The dispatch origin fo this call must be __none__."]
                #[doc = ""]
                #[doc = "This submission is checked on the fly. Moreover, this unsigned solution is only"]
                #[doc = "validated when submitted to the pool from the **local** node. Effectively, this means"]
                #[doc = "that only active validators can submit this transaction when authoring a block (similar"]
                #[doc = "to an inherent)."]
                #[doc = ""]
                #[doc = "To prevent any incorrect solution (and thus wasted time/weight), this transaction will"]
                #[doc = "panic if the solution submitted by the validator is invalid in any way, effectively"]
                #[doc = "putting their authoring reward at risk."]
                #[doc = ""]
                #[doc = "No deposit or reward is associated with this submission."]
                #[codec(index = 0u8)]
                submit_unsigned {
                    raw_solution: ::alloc::boxed::Box<
                        pallet_election_provider_multi_phase::RawSolution<
                            polymesh_runtime_common::NposSolution16,
                        >,
                    >,
                    witness: pallet_election_provider_multi_phase::SolutionOrSnapshotSize,
                },
                #[doc = "Set a new value for `MinimumUntrustedScore`."]
                #[doc = ""]
                #[doc = "Dispatch origin must be aligned with `T::ForceOrigin`."]
                #[doc = ""]
                #[doc = "This check can be turned off by setting the value to `None`."]
                #[codec(index = 1u8)]
                set_minimum_untrusted_score {
                    maybe_next_score: Option<sp_npos_elections::ElectionScore>,
                },
                #[doc = "Set a solution in the queue, to be handed out to the client of this pallet in the next"]
                #[doc = "call to `ElectionProvider::elect`."]
                #[doc = ""]
                #[doc = "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`."]
                #[doc = ""]
                #[doc = "The solution is not checked for any feasibility and is assumed to be trustworthy, as any"]
                #[doc = "feasibility check itself can in principle cause the election process to fail (due to"]
                #[doc = "memory/weight constrains)."]
                #[codec(index = 2u8)]
                set_emergency_election_result {
                    supports: ::alloc::vec::Vec<(
                        ::polymesh_api_client::AccountId,
                        sp_npos_elections::Support<::polymesh_api_client::AccountId>,
                    )>,
                },
                #[doc = "Submit a solution for the signed phase."]
                #[doc = ""]
                #[doc = "The dispatch origin fo this call must be __signed__."]
                #[doc = ""]
                #[doc = "The solution is potentially queued, based on the claimed score and processed at the end"]
                #[doc = "of the signed phase."]
                #[doc = ""]
                #[doc = "A deposit is reserved and recorded for the solution. Based on the outcome, the solution"]
                #[doc = "might be rewarded, slashed, or get all or a part of the deposit back."]
                #[codec(index = 3u8)]
                submit {
                    raw_solution: ::alloc::boxed::Box<
                        pallet_election_provider_multi_phase::RawSolution<
                            polymesh_runtime_common::NposSolution16,
                        >,
                    >,
                },
                #[doc = "Trigger the governance fallback."]
                #[doc = ""]
                #[doc = "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to"]
                #[doc = "calling [`Call::set_emergency_election_result`]."]
                #[codec(index = 4u8)]
                governance_fallback,
            }
            impl ElectionProviderMultiPhaseCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::submit_unsigned { .. } => {
                            "ElectionProviderMultiPhase.submit_unsigned"
                        }
                        Self::set_minimum_untrusted_score { .. } => {
                            "ElectionProviderMultiPhase.set_minimum_untrusted_score"
                        }
                        Self::set_emergency_election_result { .. } => {
                            "ElectionProviderMultiPhase.set_emergency_election_result"
                        }
                        Self::submit { .. } => "ElectionProviderMultiPhase.submit",
                        Self::governance_fallback => {
                            "ElectionProviderMultiPhase.governance_fallback"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ElectionProviderMultiPhaseCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: submit_unsigned { .. } => { & ["Submit a solution for the unsigned phase." , "" , "The dispatch origin fo this call must be __none__." , "" , "This submission is checked on the fly. Moreover, this unsigned solution is only" , "validated when submitted to the pool from the **local** node. Effectively, this means" , "that only active validators can submit this transaction when authoring a block (similar" , "to an inherent)." , "" , "To prevent any incorrect solution (and thus wasted time/weight), this transaction will" , "panic if the solution submitted by the validator is invalid in any way, effectively" , "putting their authoring reward at risk." , "" , "No deposit or reward is associated with this submission." ,] } , Self :: set_minimum_untrusted_score { .. } => { & ["Set a new value for `MinimumUntrustedScore`." , "" , "Dispatch origin must be aligned with `T::ForceOrigin`." , "" , "This check can be turned off by setting the value to `None`." ,] } , Self :: set_emergency_election_result { .. } => { & ["Set a solution in the queue, to be handed out to the client of this pallet in the next" , "call to `ElectionProvider::elect`." , "" , "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`." , "" , "The solution is not checked for any feasibility and is assumed to be trustworthy, as any" , "feasibility check itself can in principle cause the election process to fail (due to" , "memory/weight constrains)." ,] } , Self :: submit { .. } => { & ["Submit a solution for the signed phase." , "" , "The dispatch origin fo this call must be __signed__." , "" , "The solution is potentially queued, based on the claimed score and processed at the end" , "of the signed phase." , "" , "A deposit is reserved and recorded for the solution. Based on the outcome, the solution" , "might be rewarded, slashed, or get all or a part of the deposit back." ,] } , Self :: governance_fallback => { & ["Trigger the governance fallback." , "" , "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to" , "calling [`Call::set_emergency_election_result`]." ,] } , _ => & [""] , }
                }
            }
            impl From<ElectionProviderMultiPhaseCall> for &'static str {
                fn from(v: ElectionProviderMultiPhaseCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ElectionProviderMultiPhaseCall> for &'static str {
                fn from(v: &ElectionProviderMultiPhaseCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "Error of the pallet that can be returned in response to dispatches."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ElectionProviderMultiPhaseError {
                #[doc = "Submission was too early."]
                #[codec(index = 0u8)]
                PreDispatchEarlySubmission,
                #[doc = "Wrong number of winners presented."]
                #[codec(index = 1u8)]
                PreDispatchWrongWinnerCount,
                #[doc = "Submission was too weak, score-wise."]
                #[codec(index = 2u8)]
                PreDispatchWeakSubmission,
                #[doc = "The queue was full, and the solution was not better than any of the existing ones."]
                #[codec(index = 3u8)]
                SignedQueueFull,
                #[doc = "The origin failed to pay the deposit."]
                #[codec(index = 4u8)]
                SignedCannotPayDeposit,
                #[doc = "Witness data to dispatchable is invalid."]
                #[codec(index = 5u8)]
                SignedInvalidWitness,
                #[doc = "The signed submission consumes too much weight"]
                #[codec(index = 6u8)]
                SignedTooMuchWeight,
                #[doc = "OCW submitted solution for wrong round"]
                #[codec(index = 7u8)]
                OcwCallWrongEra,
                #[doc = "Snapshot metadata should exist but didn't."]
                #[codec(index = 8u8)]
                MissingSnapshotMetadata,
                #[doc = "`Self::insert_submission` returned an invalid index."]
                #[codec(index = 9u8)]
                InvalidSubmissionIndex,
                #[doc = "The call is not allowed at this point."]
                #[codec(index = 10u8)]
                CallNotAllowed,
                #[doc = "The fallback failed"]
                #[codec(index = 11u8)]
                FallbackFailed,
                #[doc = "Some bound not met"]
                #[codec(index = 12u8)]
                BoundNotMet,
                #[doc = "Submitted solution has too many winners"]
                #[codec(index = 13u8)]
                TooManyWinners,
                #[doc = "Submission was prepared for a different round."]
                #[codec(index = 14u8)]
                PreDispatchDifferentRound,
            }
            impl ElectionProviderMultiPhaseError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::PreDispatchEarlySubmission => {
                            "ElectionProviderMultiPhase.PreDispatchEarlySubmission"
                        }
                        Self::PreDispatchWrongWinnerCount => {
                            "ElectionProviderMultiPhase.PreDispatchWrongWinnerCount"
                        }
                        Self::PreDispatchWeakSubmission => {
                            "ElectionProviderMultiPhase.PreDispatchWeakSubmission"
                        }
                        Self::SignedQueueFull => "ElectionProviderMultiPhase.SignedQueueFull",
                        Self::SignedCannotPayDeposit => {
                            "ElectionProviderMultiPhase.SignedCannotPayDeposit"
                        }
                        Self::SignedInvalidWitness => {
                            "ElectionProviderMultiPhase.SignedInvalidWitness"
                        }
                        Self::SignedTooMuchWeight => {
                            "ElectionProviderMultiPhase.SignedTooMuchWeight"
                        }
                        Self::OcwCallWrongEra => "ElectionProviderMultiPhase.OcwCallWrongEra",
                        Self::MissingSnapshotMetadata => {
                            "ElectionProviderMultiPhase.MissingSnapshotMetadata"
                        }
                        Self::InvalidSubmissionIndex => {
                            "ElectionProviderMultiPhase.InvalidSubmissionIndex"
                        }
                        Self::CallNotAllowed => "ElectionProviderMultiPhase.CallNotAllowed",
                        Self::FallbackFailed => "ElectionProviderMultiPhase.FallbackFailed",
                        Self::BoundNotMet => "ElectionProviderMultiPhase.BoundNotMet",
                        Self::TooManyWinners => "ElectionProviderMultiPhase.TooManyWinners",
                        Self::PreDispatchDifferentRound => {
                            "ElectionProviderMultiPhase.PreDispatchDifferentRound"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ElectionProviderMultiPhaseError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: PreDispatchEarlySubmission => { & ["Submission was too early." ,] } , Self :: PreDispatchWrongWinnerCount => { & ["Wrong number of winners presented." ,] } , Self :: PreDispatchWeakSubmission => { & ["Submission was too weak, score-wise." ,] } , Self :: SignedQueueFull => { & ["The queue was full, and the solution was not better than any of the existing ones." ,] } , Self :: SignedCannotPayDeposit => { & ["The origin failed to pay the deposit." ,] } , Self :: SignedInvalidWitness => { & ["Witness data to dispatchable is invalid." ,] } , Self :: SignedTooMuchWeight => { & ["The signed submission consumes too much weight" ,] } , Self :: OcwCallWrongEra => { & ["OCW submitted solution for wrong round" ,] } , Self :: MissingSnapshotMetadata => { & ["Snapshot metadata should exist but didn't." ,] } , Self :: InvalidSubmissionIndex => { & ["`Self::insert_submission` returned an invalid index." ,] } , Self :: CallNotAllowed => { & ["The call is not allowed at this point." ,] } , Self :: FallbackFailed => { & ["The fallback failed" ,] } , Self :: BoundNotMet => { & ["Some bound not met" ,] } , Self :: TooManyWinners => { & ["Submitted solution has too many winners" ,] } , Self :: PreDispatchDifferentRound => { & ["Submission was prepared for a different round." ,] } , _ => & [""] , }
                }
            }
            impl From<ElectionProviderMultiPhaseError> for &'static str {
                fn from(v: ElectionProviderMultiPhaseError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ElectionProviderMultiPhaseError> for &'static str {
                fn from(v: &ElectionProviderMultiPhaseError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ElectionProviderMultiPhaseEvent {
                #[doc = "A solution was stored with the given compute."]
                #[doc = ""]
                #[doc = "The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`,"]
                #[doc = "the stored solution was submitted in the signed phase by a miner with the `AccountId`."]
                #[doc = "Otherwise, the solution was stored either during the unsigned phase or by"]
                #[doc = "`T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make"]
                #[doc = "room for this one."]
                #[codec(index = 0u8)]
                SolutionStored {
                    compute: pallet_election_provider_multi_phase::ElectionCompute,
                    origin: Option<::polymesh_api_client::AccountId>,
                    prev_ejected: bool,
                },
                #[doc = "The election has been finalized, with the given computation and score."]
                #[codec(index = 1u8)]
                ElectionFinalized {
                    compute: pallet_election_provider_multi_phase::ElectionCompute,
                    score: sp_npos_elections::ElectionScore,
                },
                #[doc = "An election failed."]
                #[doc = ""]
                #[doc = "Not much can be said about which computes failed in the process."]
                #[codec(index = 2u8)]
                ElectionFailed,
                #[doc = "An account has been rewarded for their signed submission being finalized."]
                #[codec(index = 3u8)]
                Rewarded {
                    account: ::polymesh_api_client::AccountId,
                    value: u128,
                },
                #[doc = "An account has been slashed for submitting an invalid signed submission."]
                #[codec(index = 4u8)]
                Slashed {
                    account: ::polymesh_api_client::AccountId,
                    value: u128,
                },
                #[doc = "There was a phase transition in a given round."]
                #[codec(index = 5u8)]
                PhaseTransitioned {
                    from: pallet_election_provider_multi_phase::Phase<u32>,
                    to: pallet_election_provider_multi_phase::Phase<u32>,
                    round: u32,
                },
            }
            impl ElectionProviderMultiPhaseEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::SolutionStored { .. } => "ElectionProviderMultiPhase.SolutionStored",
                        Self::ElectionFinalized { .. } => {
                            "ElectionProviderMultiPhase.ElectionFinalized"
                        }
                        Self::ElectionFailed => "ElectionProviderMultiPhase.ElectionFailed",
                        Self::Rewarded { .. } => "ElectionProviderMultiPhase.Rewarded",
                        Self::Slashed { .. } => "ElectionProviderMultiPhase.Slashed",
                        Self::PhaseTransitioned { .. } => {
                            "ElectionProviderMultiPhase.PhaseTransitioned"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ElectionProviderMultiPhaseEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: SolutionStored { .. } => { & ["A solution was stored with the given compute." , "" , "The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`," , "the stored solution was submitted in the signed phase by a miner with the `AccountId`." , "Otherwise, the solution was stored either during the unsigned phase or by" , "`T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make" , "room for this one." ,] } , Self :: ElectionFinalized { .. } => { & ["The election has been finalized, with the given computation and score." ,] } , Self :: ElectionFailed => { & ["An election failed." , "" , "Not much can be said about which computes failed in the process." ,] } , Self :: Rewarded { .. } => { & ["An account has been rewarded for their signed submission being finalized." ,] } , Self :: Slashed { .. } => { & ["An account has been slashed for submitting an invalid signed submission." ,] } , Self :: PhaseTransitioned { .. } => { & ["There was a phase transition in a given round." ,] } , _ => & [""] , }
                }
            }
            impl From<ElectionProviderMultiPhaseEvent> for &'static str {
                fn from(v: ElectionProviderMultiPhaseEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ElectionProviderMultiPhaseEvent> for &'static str {
                fn from(v: &ElectionProviderMultiPhaseEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        pub mod signed {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct SignedSubmission<AccountId, Balance, Solution> {
                pub who: AccountId,
                pub deposit: Balance,
                pub raw_solution: pallet_election_provider_multi_phase::RawSolution<Solution>,
                pub call_fee: Balance,
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum ElectionCompute {
            #[codec(index = 0u8)]
            OnChain,
            #[codec(index = 1u8)]
            Signed,
            #[codec(index = 2u8)]
            Unsigned,
            #[codec(index = 3u8)]
            Fallback,
            #[codec(index = 4u8)]
            Emergency,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Phase<Bn> {
            #[codec(index = 0u8)]
            Off,
            #[codec(index = 1u8)]
            Signed,
            #[codec(index = 2u8)]
            Unsigned((bool, Bn)),
            #[codec(index = 3u8)]
            Emergency,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct RawSolution<S> {
            pub solution: S,
            pub score: sp_npos_elections::ElectionScore,
            pub round: u32,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ReadySolution {
            pub supports:
                frame_election_provider_support::BoundedSupports<::polymesh_api_client::AccountId>,
            pub score: sp_npos_elections::ElectionScore,
            pub compute: pallet_election_provider_multi_phase::ElectionCompute,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct RoundSnapshot<AccountId, VoterType> {
            pub voters: ::alloc::vec::Vec<VoterType>,
            pub targets: ::alloc::vec::Vec<AccountId>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct SolutionOrSnapshotSize {
            #[codec(compact)]
            pub voters: u32,
            #[codec(compact)]
            pub targets: u32,
        }
    }
    pub mod pallet_external_agents {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ExternalAgentsCall {
                #[doc = "Creates a custom agent group (AG) for the given `asset_id`."]
                #[doc = ""]
                #[doc = "The AG will have the permissions as given by `perms`."]
                #[doc = "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`,"]
                #[doc = "which you can use as `AgentGroup::Custom(id)` when adding agents for `asset_id`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `assetID` the [`AssetId] to add the custom group for."]
                #[doc = "- `perms` that the new AG will have."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
                #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
                #[doc = "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Agent"]
                #[codec(index = 0u8)]
                create_group {
                    asset_id: ::polymesh_api_client::AssetId,
                    perms: polymesh_primitives::secondary_key::ExtrinsicPermissions,
                },
                #[doc = "Updates the permissions of the custom AG identified by `id`, for the given `asset_id`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `assetID` the [`AssetId] the custom AG belongs to."]
                #[doc = "- `id` for the custom AG within `asset_id`."]
                #[doc = "- `perms` to update the custom AG to."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
                #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
                #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Agent"]
                #[codec(index = 1u8)]
                set_group_permissions {
                    asset_id: ::polymesh_api_client::AssetId,
                    id: polymesh_primitives::agent::AGId,
                    perms: polymesh_primitives::secondary_key::ExtrinsicPermissions,
                },
                #[doc = "Remove the given `agent` from `asset_id`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `assetID` the [`AssetId] that has the `agent` to remove."]
                #[doc = "- `agent` of `asset_id` to remove."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
                #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
                #[doc = "- `RemovingLastFullAgent` if `agent` is the last full one."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Agent"]
                #[codec(index = 2u8)]
                remove_agent {
                    asset_id: ::polymesh_api_client::AssetId,
                    agent: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Abdicate agentship for `asset_id`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `assetID` the [`AssetId] of which the caller is an agent."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `NotAnAgent` if the caller is not an agent of `asset_id`."]
                #[doc = "- `RemovingLastFullAgent` if the caller is the last full agent."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 3u8)]
                abdicate {
                    asset_id: ::polymesh_api_client::AssetId,
                },
                #[doc = "Change the agent group that `agent` belongs to in `asset_id`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `assetID` the [`AssetId] that has the `agent`."]
                #[doc = "- `agent` of `asset_id` to change the group for."]
                #[doc = "- `group` that `agent` will belong to in `asset_id`."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
                #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
                #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
                #[doc = "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Agent"]
                #[codec(index = 4u8)]
                change_group {
                    asset_id: ::polymesh_api_client::AssetId,
                    agent: ::polymesh_api_client::IdentityId,
                    group: polymesh_primitives::agent::AgentGroup,
                },
                #[doc = "Accept an authorization by an agent \"Alice\" who issued `auth_id`"]
                #[doc = "to also become an agent of the asset Alice specified."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `auth_id` identifying the authorization to accept."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `Error::InvalidAuthorization` if `auth_id` does not exist for the given caller."]
                #[doc = "- `Error::AuthorizationExpired` if `auth_id` is for an auth that has expired."]
                #[doc = "- `Error::BadAuthorizationType` if `auth_id` was not for a `BecomeAgent` auth type."]
                #[doc = "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth."]
                #[doc = "- `NoSuchAG` if the group referred to a custom that does not exist."]
                #[doc = "- `AlreadyAnAgent` if the caller is already an agent of the asset."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Agent"]
                #[codec(index = 5u8)]
                accept_become_agent { auth_id: u64 },
                #[doc = "Utility extrinsic to batch `create_group` and  `add_auth`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Agent"]
                #[codec(index = 6u8)]
                create_group_and_add_auth {
                    asset_id: ::polymesh_api_client::AssetId,
                    perms: polymesh_primitives::secondary_key::ExtrinsicPermissions,
                    target: ::polymesh_api_client::IdentityId,
                    expiry: Option<u64>,
                },
                #[doc = "Utility extrinsic to batch `create_group` and  `change_group` for custom groups only."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Agent"]
                #[codec(index = 7u8)]
                create_and_change_custom_group {
                    asset_id: ::polymesh_api_client::AssetId,
                    perms: polymesh_primitives::secondary_key::ExtrinsicPermissions,
                    agent: ::polymesh_api_client::IdentityId,
                },
            }
            impl ExternalAgentsCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::create_group { .. } => "ExternalAgents.create_group",
                        Self::set_group_permissions { .. } => {
                            "ExternalAgents.set_group_permissions"
                        }
                        Self::remove_agent { .. } => "ExternalAgents.remove_agent",
                        Self::abdicate { .. } => "ExternalAgents.abdicate",
                        Self::change_group { .. } => "ExternalAgents.change_group",
                        Self::accept_become_agent { .. } => "ExternalAgents.accept_become_agent",
                        Self::create_group_and_add_auth { .. } => {
                            "ExternalAgents.create_group_and_add_auth"
                        }
                        Self::create_and_change_custom_group { .. } => {
                            "ExternalAgents.create_and_change_custom_group"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ExternalAgentsCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: create_group { .. } => { & ["Creates a custom agent group (AG) for the given `asset_id`." , "" , "The AG will have the permissions as given by `perms`." , "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`," , "which you can use as `AgentGroup::Custom(id)` when adding agents for `asset_id`." , "" , "# Arguments" , "- `assetID` the [`AssetId] to add the custom group for." , "- `perms` that the new AG will have." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this." , "- `TooLong` if `perms` had some string or list length that was too long." , "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , Self :: set_group_permissions { .. } => { & ["Updates the permissions of the custom AG identified by `id`, for the given `asset_id`." , "" , "# Arguments" , "- `assetID` the [`AssetId] the custom AG belongs to." , "- `id` for the custom AG within `asset_id`." , "- `perms` to update the custom AG to." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this." , "- `TooLong` if `perms` had some string or list length that was too long." , "- `NoSuchAG` if `id` does not identify a custom AG." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , Self :: remove_agent { .. } => { & ["Remove the given `agent` from `asset_id`." , "" , "# Arguments" , "- `assetID` the [`AssetId] that has the `agent` to remove." , "- `agent` of `asset_id` to remove." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this." , "- `NotAnAgent` if `agent` is not an agent of `asset_id`." , "- `RemovingLastFullAgent` if `agent` is the last full one." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , Self :: abdicate { .. } => { & ["Abdicate agentship for `asset_id`." , "" , "# Arguments" , "- `assetID` the [`AssetId] of which the caller is an agent." , "" , "# Errors" , "- `NotAnAgent` if the caller is not an agent of `asset_id`." , "- `RemovingLastFullAgent` if the caller is the last full agent." , "" , "# Permissions" , "* Asset" ,] } , Self :: change_group { .. } => { & ["Change the agent group that `agent` belongs to in `asset_id`." , "" , "# Arguments" , "- `assetID` the [`AssetId] that has the `agent`." , "- `agent` of `asset_id` to change the group for." , "- `group` that `agent` will belong to in `asset_id`." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this." , "- `NoSuchAG` if `id` does not identify a custom AG." , "- `NotAnAgent` if `agent` is not an agent of `asset_id`." , "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , Self :: accept_become_agent { .. } => { & ["Accept an authorization by an agent \"Alice\" who issued `auth_id`" , "to also become an agent of the asset Alice specified." , "" , "# Arguments" , "- `auth_id` identifying the authorization to accept." , "" , "# Errors" , "- `Error::InvalidAuthorization` if `auth_id` does not exist for the given caller." , "- `Error::AuthorizationExpired` if `auth_id` is for an auth that has expired." , "- `Error::BadAuthorizationType` if `auth_id` was not for a `BecomeAgent` auth type." , "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth." , "- `NoSuchAG` if the group referred to a custom that does not exist." , "- `AlreadyAnAgent` if the caller is already an agent of the asset." , "" , "# Permissions" , "* Agent" ,] } , Self :: create_group_and_add_auth { .. } => { & ["Utility extrinsic to batch `create_group` and  `add_auth`." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , Self :: create_and_change_custom_group { .. } => { & ["Utility extrinsic to batch `create_group` and  `change_group` for custom groups only." , "" , "# Permissions" , "* Asset" , "* Agent" ,] } , _ => & [""] , }
                }
            }
            impl From<ExternalAgentsCall> for &'static str {
                fn from(v: ExternalAgentsCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ExternalAgentsCall> for &'static str {
                fn from(v: &ExternalAgentsCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ExternalAgentsError {
                #[doc = "An AG with the given `AGId` did not exist for the `AssetId`."]
                #[codec(index = 0u8)]
                NoSuchAG,
                #[doc = "The agent is not authorized to call the current extrinsic."]
                #[codec(index = 1u8)]
                UnauthorizedAgent,
                #[doc = "The provided `agent` is already an agent for the `AssetId`."]
                #[codec(index = 2u8)]
                AlreadyAnAgent,
                #[doc = "The provided `agent` is not an agent for the `AssetId`."]
                #[codec(index = 3u8)]
                NotAnAgent,
                #[doc = "This agent is the last full one, and it's being removed,"]
                #[doc = "making the asset orphaned."]
                #[codec(index = 4u8)]
                RemovingLastFullAgent,
                #[doc = "The caller's secondary key does not have the required asset permission."]
                #[codec(index = 5u8)]
                SecondaryKeyNotAuthorizedForAsset,
                #[doc = "The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is."]
                #[codec(index = 6u8)]
                BadAuthorizationType,
            }
            impl ExternalAgentsError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::NoSuchAG => "ExternalAgents.NoSuchAG",
                        Self::UnauthorizedAgent => "ExternalAgents.UnauthorizedAgent",
                        Self::AlreadyAnAgent => "ExternalAgents.AlreadyAnAgent",
                        Self::NotAnAgent => "ExternalAgents.NotAnAgent",
                        Self::RemovingLastFullAgent => "ExternalAgents.RemovingLastFullAgent",
                        Self::SecondaryKeyNotAuthorizedForAsset => {
                            "ExternalAgents.SecondaryKeyNotAuthorizedForAsset"
                        }
                        Self::BadAuthorizationType => "ExternalAgents.BadAuthorizationType",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ExternalAgentsError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: NoSuchAG => { & ["An AG with the given `AGId` did not exist for the `AssetId`." ,] } , Self :: UnauthorizedAgent => { & ["The agent is not authorized to call the current extrinsic." ,] } , Self :: AlreadyAnAgent => { & ["The provided `agent` is already an agent for the `AssetId`." ,] } , Self :: NotAnAgent => { & ["The provided `agent` is not an agent for the `AssetId`." ,] } , Self :: RemovingLastFullAgent => { & ["This agent is the last full one, and it's being removed," , "making the asset orphaned." ,] } , Self :: SecondaryKeyNotAuthorizedForAsset => { & ["The caller's secondary key does not have the required asset permission." ,] } , Self :: BadAuthorizationType => { & ["The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is." ,] } , _ => & [""] , }
                }
            }
            impl From<ExternalAgentsError> for &'static str {
                fn from(v: ExternalAgentsError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ExternalAgentsError> for &'static str {
                fn from(v: &ExternalAgentsError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ExternalAgentsEvent {
                #[doc = "An Agent Group was created."]
                #[doc = ""]
                #[doc = "(Caller DID, AG's AssetId, AG's ID, AG's permissions)"]
                #[codec(index = 0u8)]
                GroupCreated(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::agent::AGId,
                    polymesh_primitives::secondary_key::ExtrinsicPermissions,
                ),
                #[doc = "An Agent Group's permissions was updated."]
                #[doc = ""]
                #[doc = "(Caller DID, AG's AssetId, AG's ID, AG's new permissions)"]
                #[codec(index = 1u8)]
                GroupPermissionsUpdated(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::agent::AGId,
                    polymesh_primitives::secondary_key::ExtrinsicPermissions,
                ),
                #[doc = "An agent was added."]
                #[doc = ""]
                #[doc = "(Caller/Agent DID, Agent's AssetId, Agent's group)"]
                #[codec(index = 2u8)]
                AgentAdded(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::agent::AgentGroup,
                ),
                #[doc = "An agent was removed."]
                #[doc = ""]
                #[doc = "(Caller DID, Agent's AssetId, Agent's DID)"]
                #[codec(index = 3u8)]
                AgentRemoved(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    ::polymesh_api_client::AssetId,
                    ::polymesh_api_client::IdentityId,
                ),
                #[doc = "An agent's group was changed."]
                #[doc = ""]
                #[doc = "(Caller DID, Agent's AssetId, Agent's DID, The new group of the agent)"]
                #[codec(index = 4u8)]
                GroupChanged(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    ::polymesh_api_client::AssetId,
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::agent::AgentGroup,
                ),
            }
            impl ExternalAgentsEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::GroupCreated(_, _, _, _) => "ExternalAgents.GroupCreated",
                        Self::GroupPermissionsUpdated(_, _, _, _) => {
                            "ExternalAgents.GroupPermissionsUpdated"
                        }
                        Self::AgentAdded(_, _, _) => "ExternalAgents.AgentAdded",
                        Self::AgentRemoved(_, _, _) => "ExternalAgents.AgentRemoved",
                        Self::GroupChanged(_, _, _, _) => "ExternalAgents.GroupChanged",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ExternalAgentsEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: GroupCreated (_ , _ , _ , _) => { & ["An Agent Group was created." , "" , "(Caller DID, AG's AssetId, AG's ID, AG's permissions)" ,] } , Self :: GroupPermissionsUpdated (_ , _ , _ , _) => { & ["An Agent Group's permissions was updated." , "" , "(Caller DID, AG's AssetId, AG's ID, AG's new permissions)" ,] } , Self :: AgentAdded (_ , _ , _) => { & ["An agent was added." , "" , "(Caller/Agent DID, Agent's AssetId, Agent's group)" ,] } , Self :: AgentRemoved (_ , _ , _) => { & ["An agent was removed." , "" , "(Caller DID, Agent's AssetId, Agent's DID)" ,] } , Self :: GroupChanged (_ , _ , _ , _) => { & ["An agent's group was changed." , "" , "(Caller DID, Agent's AssetId, Agent's DID, The new group of the agent)" ,] } , _ => & [""] , }
                }
            }
            impl From<ExternalAgentsEvent> for &'static str {
                fn from(v: ExternalAgentsEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ExternalAgentsEvent> for &'static str {
                fn from(v: &ExternalAgentsEvent) -> Self {
                    v.as_static_str()
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Version(pub u8);
        }
    }
    pub mod pallet_grandpa {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum GrandpaCall {
                #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
                #[doc = "equivocation proof and validate the given key ownership proof"]
                #[doc = "against the extracted offender. If both are valid, the offence"]
                #[doc = "will be reported."]
                #[codec(index = 0u8)]
                report_equivocation {
                    equivocation_proof: ::alloc::boxed::Box<
                        sp_consensus_grandpa::EquivocationProof<primitive_types::H256, u32>,
                    >,
                    key_owner_proof: sp_session::MembershipProof,
                },
                #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
                #[doc = "equivocation proof and validate the given key ownership proof"]
                #[doc = "against the extracted offender. If both are valid, the offence"]
                #[doc = "will be reported."]
                #[doc = ""]
                #[doc = "This extrinsic must be called unsigned and it is expected that only"]
                #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
                #[doc = "if the block author is defined it will be defined as the equivocation"]
                #[doc = "reporter."]
                #[codec(index = 1u8)]
                report_equivocation_unsigned {
                    equivocation_proof: ::alloc::boxed::Box<
                        sp_consensus_grandpa::EquivocationProof<primitive_types::H256, u32>,
                    >,
                    key_owner_proof: sp_session::MembershipProof,
                },
                #[doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."]
                #[doc = ""]
                #[doc = "This will trigger a forced authority set change at the beginning of the next session, to"]
                #[doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"]
                #[doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."]
                #[doc = "The block production rate (which may be slowed down because of finality lagging) should"]
                #[doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"]
                #[doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"]
                #[doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"]
                #[doc = "block of all validators of the new authority set."]
                #[doc = ""]
                #[doc = "Only callable by root."]
                #[codec(index = 2u8)]
                note_stalled {
                    delay: u32,
                    best_finalized_block_number: u32,
                },
            }
            impl GrandpaCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::report_equivocation { .. } => "Grandpa.report_equivocation",
                        Self::report_equivocation_unsigned { .. } => {
                            "Grandpa.report_equivocation_unsigned"
                        }
                        Self::note_stalled { .. } => "Grandpa.note_stalled",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for GrandpaCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: report_equivocation { .. } => { & ["Report voter equivocation/misbehavior. This method will verify the" , "equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence" , "will be reported." ,] } , Self :: report_equivocation_unsigned { .. } => { & ["Report voter equivocation/misbehavior. This method will verify the" , "equivocation proof and validate the given key ownership proof" , "against the extracted offender. If both are valid, the offence" , "will be reported." , "" , "This extrinsic must be called unsigned and it is expected that only" , "block authors will call it (validated in `ValidateUnsigned`), as such" , "if the block author is defined it will be defined as the equivocation" , "reporter." ,] } , Self :: note_stalled { .. } => { & ["Note that the current authority set of the GRANDPA finality gadget has stalled." , "" , "This will trigger a forced authority set change at the beginning of the next session, to" , "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume" , "that the block signalling the forced change will not be re-orged e.g. 1000 blocks." , "The block production rate (which may be slowed down because of finality lagging) should" , "be taken into account when choosing the `delay`. The GRANDPA voters based on the new" , "authority will start voting on top of `best_finalized_block_number` for new finalized" , "blocks. `best_finalized_block_number` should be the highest of the latest finalized" , "block of all validators of the new authority set." , "" , "Only callable by root." ,] } , _ => & [""] , }
                }
            }
            impl From<GrandpaCall> for &'static str {
                fn from(v: GrandpaCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&GrandpaCall> for &'static str {
                fn from(v: &GrandpaCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum GrandpaError {
                #[doc = "Attempt to signal GRANDPA pause when the authority set isn't live"]
                #[doc = "(either paused or already pending pause)."]
                #[codec(index = 0u8)]
                PauseFailed,
                #[doc = "Attempt to signal GRANDPA resume when the authority set isn't paused"]
                #[doc = "(either live or already pending resume)."]
                #[codec(index = 1u8)]
                ResumeFailed,
                #[doc = "Attempt to signal GRANDPA change with one already pending."]
                #[codec(index = 2u8)]
                ChangePending,
                #[doc = "Cannot signal forced change so soon after last."]
                #[codec(index = 3u8)]
                TooSoon,
                #[doc = "A key ownership proof provided as part of an equivocation report is invalid."]
                #[codec(index = 4u8)]
                InvalidKeyOwnershipProof,
                #[doc = "An equivocation proof provided as part of an equivocation report is invalid."]
                #[codec(index = 5u8)]
                InvalidEquivocationProof,
                #[doc = "A given equivocation report is valid but already previously reported."]
                #[codec(index = 6u8)]
                DuplicateOffenceReport,
            }
            impl GrandpaError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::PauseFailed => "Grandpa.PauseFailed",
                        Self::ResumeFailed => "Grandpa.ResumeFailed",
                        Self::ChangePending => "Grandpa.ChangePending",
                        Self::TooSoon => "Grandpa.TooSoon",
                        Self::InvalidKeyOwnershipProof => "Grandpa.InvalidKeyOwnershipProof",
                        Self::InvalidEquivocationProof => "Grandpa.InvalidEquivocationProof",
                        Self::DuplicateOffenceReport => "Grandpa.DuplicateOffenceReport",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for GrandpaError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: PauseFailed => { & ["Attempt to signal GRANDPA pause when the authority set isn't live" , "(either paused or already pending pause)." ,] } , Self :: ResumeFailed => { & ["Attempt to signal GRANDPA resume when the authority set isn't paused" , "(either live or already pending resume)." ,] } , Self :: ChangePending => { & ["Attempt to signal GRANDPA change with one already pending." ,] } , Self :: TooSoon => { & ["Cannot signal forced change so soon after last." ,] } , Self :: InvalidKeyOwnershipProof => { & ["A key ownership proof provided as part of an equivocation report is invalid." ,] } , Self :: InvalidEquivocationProof => { & ["An equivocation proof provided as part of an equivocation report is invalid." ,] } , Self :: DuplicateOffenceReport => { & ["A given equivocation report is valid but already previously reported." ,] } , _ => & [""] , }
                }
            }
            impl From<GrandpaError> for &'static str {
                fn from(v: GrandpaError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&GrandpaError> for &'static str {
                fn from(v: &GrandpaError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum GrandpaEvent {
                #[doc = "New authority set has been applied."]
                #[codec(index = 0u8)]
                NewAuthorities {
                    authority_set: ::alloc::vec::Vec<(sp_consensus_grandpa::app::Public, u64)>,
                },
                #[doc = "Current authority set has been paused."]
                #[codec(index = 1u8)]
                Paused,
                #[doc = "Current authority set has been resumed."]
                #[codec(index = 2u8)]
                Resumed,
            }
            impl GrandpaEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::NewAuthorities { .. } => "Grandpa.NewAuthorities",
                        Self::Paused => "Grandpa.Paused",
                        Self::Resumed => "Grandpa.Resumed",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for GrandpaEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::NewAuthorities { .. } => &["New authority set has been applied."],
                        Self::Paused => &["Current authority set has been paused."],
                        Self::Resumed => &["Current authority set has been resumed."],
                        _ => &[""],
                    }
                }
            }
            impl From<GrandpaEvent> for &'static str {
                fn from(v: GrandpaEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&GrandpaEvent> for &'static str {
                fn from(v: &GrandpaEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct StoredPendingChange<N> {
            pub scheduled_at: N,
            pub delay: N,
            pub next_authorities: ::alloc::vec::Vec<(sp_consensus_grandpa::app::Public, u64)>,
            pub forced: Option<N>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum StoredState<N> {
            #[codec(index = 0u8)]
            Live,
            #[codec(index = 1u8)]
            PendingPause { scheduled_at: N, delay: N },
            #[codec(index = 2u8)]
            Paused,
            #[codec(index = 3u8)]
            PendingResume { scheduled_at: N, delay: N },
        }
    }
    pub mod pallet_group {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum UpgradeCommitteeMembershipCall {
                #[doc = "Change this group's limit for how many concurrent active members they may be."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `limit` - the number of active members there may be concurrently."]
                #[codec(index = 0u8)]
                set_active_members_limit { limit: u32 },
                #[doc = "Disables a member at specific moment."]
                #[doc = ""]
                #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
                #[doc = "time-stamp will be updated."]
                #[doc = ""]
                #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
                #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
                #[doc = "generated claim issued before `at` would be considered as a valid one."]
                #[doc = ""]
                #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `at` - Revocation time-stamp."]
                #[doc = "* `who` - Target member of the group."]
                #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
                #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
                #[codec(index = 1u8)]
                disable_member {
                    who: ::polymesh_api_client::IdentityId,
                    expiry: Option<u64>,
                    at: Option<u64>,
                },
                #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
                #[doc = "* `who` - IdentityId to be added to the group."]
                #[codec(index = 2u8)]
                add_member {
                    who: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
                #[doc = ""]
                #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
                #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
                #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
                #[doc = "claims, you have to use `Self::disable_member` function"]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
                #[doc = "* `who` - IdentityId to be removed from the group."]
                #[codec(index = 3u8)]
                remove_member {
                    who: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Swaps out one member `remove` for another member `add`."]
                #[doc = ""]
                #[doc = "May only be called from `SwapOrigin` or root."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
                #[doc = "* `remove` - IdentityId to be removed from the group."]
                #[doc = "* `add` - IdentityId to be added in place of `remove`."]
                #[codec(index = 4u8)]
                swap_member {
                    remove: ::polymesh_api_client::IdentityId,
                    add: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Changes the membership to a new set, disregarding the existing membership."]
                #[doc = "May only be called from `ResetOrigin` or root."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
                #[doc = "* `members` - New set of identities"]
                #[codec(index = 5u8)]
                reset_members {
                    members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
                },
                #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
                #[doc = "vote."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - Member of committee who wants to quit."]
                #[doc = ""]
                #[doc = "# Error"]
                #[doc = ""]
                #[doc = "* Only primary key can abdicate."]
                #[doc = "* Last member of a group cannot abdicate."]
                #[codec(index = 6u8)]
                abdicate_membership,
            }
            impl UpgradeCommitteeMembershipCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::set_active_members_limit { .. } => {
                            "UpgradeCommitteeMembership.set_active_members_limit"
                        }
                        Self::disable_member { .. } => "UpgradeCommitteeMembership.disable_member",
                        Self::add_member { .. } => "UpgradeCommitteeMembership.add_member",
                        Self::remove_member { .. } => "UpgradeCommitteeMembership.remove_member",
                        Self::swap_member { .. } => "UpgradeCommitteeMembership.swap_member",
                        Self::reset_members { .. } => "UpgradeCommitteeMembership.reset_members",
                        Self::abdicate_membership => {
                            "UpgradeCommitteeMembership.abdicate_membership"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeMembershipCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: set_active_members_limit { .. } => { & ["Change this group's limit for how many concurrent active members they may be." , "" , "# Arguments" , "* `limit` - the number of active members there may be concurrently." ,] } , Self :: disable_member { .. } => { & ["Disables a member at specific moment." , "" , "Please note that if member is already revoked (a \"valid member\"), its revocation" , "time-stamp will be updated." , "" , "Any disabled member should NOT allow to act like an active member of the group. For" , "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any" , "generated claim issued before `at` would be considered as a valid one." , "" , "If you want to invalidate any generated claim, you should use `Self::remove_member`." , "" , "# Arguments" , "* `at` - Revocation time-stamp." , "* `who` - Target member of the group." , "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the" , "generated claims will be \"invalid\" as `who` is not considered a member of the group." ,] } , Self :: add_member { .. } => { & ["Adds a member `who` to the group. May only be called from `AddOrigin` or root." , "" , "# Arguments" , "* `origin` - Origin representing `AddOrigin` or root" , "* `who` - IdentityId to be added to the group." ,] } , Self :: remove_member { .. } => { & ["Removes a member `who` from the set. May only be called from `RemoveOrigin` or root." , "" , "Any claim previously generated by this member is not valid as a group claim. For" , "instance, if a CDD member group generated a claim for a target identity and then it is" , "removed, that claim will be invalid.  In case you want to keep the validity of generated" , "claims, you have to use `Self::disable_member` function" , "" , "# Arguments" , "* `origin` - Origin representing `RemoveOrigin` or root" , "* `who` - IdentityId to be removed from the group." ,] } , Self :: swap_member { .. } => { & ["Swaps out one member `remove` for another member `add`." , "" , "May only be called from `SwapOrigin` or root." , "" , "# Arguments" , "* `origin` - Origin representing `SwapOrigin` or root" , "* `remove` - IdentityId to be removed from the group." , "* `add` - IdentityId to be added in place of `remove`." ,] } , Self :: reset_members { .. } => { & ["Changes the membership to a new set, disregarding the existing membership." , "May only be called from `ResetOrigin` or root." , "" , "# Arguments" , "* `origin` - Origin representing `ResetOrigin` or root" , "* `members` - New set of identities" ,] } , Self :: abdicate_membership => { & ["Allows the calling member to *unilaterally quit* without this being subject to a GC" , "vote." , "" , "# Arguments" , "* `origin` - Member of committee who wants to quit." , "" , "# Error" , "" , "* Only primary key can abdicate." , "* Last member of a group cannot abdicate." ,] } , _ => & [""] , }
                }
            }
            impl From<UpgradeCommitteeMembershipCall> for &'static str {
                fn from(v: UpgradeCommitteeMembershipCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&UpgradeCommitteeMembershipCall> for &'static str {
                fn from(v: &UpgradeCommitteeMembershipCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum UpgradeCommitteeMembershipError {
                #[doc = "Only primary key of the identity is allowed."]
                #[codec(index = 0u8)]
                OnlyPrimaryKeyAllowed,
                #[doc = "Group member was added already."]
                #[codec(index = 1u8)]
                DuplicateMember,
                #[doc = "Can't remove a member that doesn't exist."]
                #[codec(index = 2u8)]
                NoSuchMember,
                #[doc = "Last member of the committee can not quit."]
                #[codec(index = 3u8)]
                LastMemberCannotQuit,
                #[doc = "The limit for the number of concurrent active members for this group has been exceeded."]
                #[codec(index = 4u8)]
                ActiveMembersLimitExceeded,
                #[doc = "Active member limit was greater than maximum committee members limit."]
                #[codec(index = 5u8)]
                ActiveMembersLimitOverflow,
            }
            impl UpgradeCommitteeMembershipError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::OnlyPrimaryKeyAllowed => {
                            "UpgradeCommitteeMembership.OnlyPrimaryKeyAllowed"
                        }
                        Self::DuplicateMember => "UpgradeCommitteeMembership.DuplicateMember",
                        Self::NoSuchMember => "UpgradeCommitteeMembership.NoSuchMember",
                        Self::LastMemberCannotQuit => {
                            "UpgradeCommitteeMembership.LastMemberCannotQuit"
                        }
                        Self::ActiveMembersLimitExceeded => {
                            "UpgradeCommitteeMembership.ActiveMembersLimitExceeded"
                        }
                        Self::ActiveMembersLimitOverflow => {
                            "UpgradeCommitteeMembership.ActiveMembersLimitOverflow"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeMembershipError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: OnlyPrimaryKeyAllowed => { & ["Only primary key of the identity is allowed." ,] } , Self :: DuplicateMember => { & ["Group member was added already." ,] } , Self :: NoSuchMember => { & ["Can't remove a member that doesn't exist." ,] } , Self :: LastMemberCannotQuit => { & ["Last member of the committee can not quit." ,] } , Self :: ActiveMembersLimitExceeded => { & ["The limit for the number of concurrent active members for this group has been exceeded." ,] } , Self :: ActiveMembersLimitOverflow => { & ["Active member limit was greater than maximum committee members limit." ,] } , _ => & [""] , }
                }
            }
            impl From<UpgradeCommitteeMembershipError> for &'static str {
                fn from(v: UpgradeCommitteeMembershipError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&UpgradeCommitteeMembershipError> for &'static str {
                fn from(v: &UpgradeCommitteeMembershipError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum UpgradeCommitteeMembershipEvent {
                #[doc = "The given member was added; see the transaction for who."]
                #[doc = "caller DID, New member DID."]
                #[codec(index = 0u8)]
                MemberAdded(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                ),
                #[doc = "The given member was removed; see the transaction for who."]
                #[doc = "caller DID, member DID that get removed."]
                #[codec(index = 1u8)]
                MemberRemoved(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                ),
                #[doc = "The given member has been revoked at specific time-stamp."]
                #[doc = "caller DID, member DID that get revoked."]
                #[codec(index = 2u8)]
                MemberRevoked(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                ),
                #[doc = "Two members were swapped; see the transaction for who."]
                #[doc = "caller DID, Removed DID, New add DID."]
                #[codec(index = 3u8)]
                MembersSwapped(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                ),
                #[doc = "The membership was reset; see the transaction for who the new set is."]
                #[doc = "caller DID, List of new members."]
                #[codec(index = 4u8)]
                MembersReset(
                    ::polymesh_api_client::IdentityId,
                    ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
                ),
                #[doc = "The limit of how many active members there can be concurrently was changed."]
                #[codec(index = 5u8)]
                ActiveLimitChanged(::polymesh_api_client::IdentityId, u32, u32),
            }
            impl UpgradeCommitteeMembershipEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::MemberAdded(_, _) => "UpgradeCommitteeMembership.MemberAdded",
                        Self::MemberRemoved(_, _) => "UpgradeCommitteeMembership.MemberRemoved",
                        Self::MemberRevoked(_, _) => "UpgradeCommitteeMembership.MemberRevoked",
                        Self::MembersSwapped(_, _, _) => {
                            "UpgradeCommitteeMembership.MembersSwapped"
                        }
                        Self::MembersReset(_, _) => "UpgradeCommitteeMembership.MembersReset",
                        Self::ActiveLimitChanged(_, _, _) => {
                            "UpgradeCommitteeMembership.ActiveLimitChanged"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for UpgradeCommitteeMembershipEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: MemberAdded (_ , _) => { & ["The given member was added; see the transaction for who." , "caller DID, New member DID." ,] } , Self :: MemberRemoved (_ , _) => { & ["The given member was removed; see the transaction for who." , "caller DID, member DID that get removed." ,] } , Self :: MemberRevoked (_ , _) => { & ["The given member has been revoked at specific time-stamp." , "caller DID, member DID that get revoked." ,] } , Self :: MembersSwapped (_ , _ , _) => { & ["Two members were swapped; see the transaction for who." , "caller DID, Removed DID, New add DID." ,] } , Self :: MembersReset (_ , _) => { & ["The membership was reset; see the transaction for who the new set is." , "caller DID, List of new members." ,] } , Self :: ActiveLimitChanged (_ , _ , _) => { & ["The limit of how many active members there can be concurrently was changed." ,] } , _ => & [""] , }
                }
            }
            impl From<UpgradeCommitteeMembershipEvent> for &'static str {
                fn from(v: UpgradeCommitteeMembershipEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&UpgradeCommitteeMembershipEvent> for &'static str {
                fn from(v: &UpgradeCommitteeMembershipEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_identity {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum IdentityCall {
                #[doc = "Register `target_account` with a new Identity."]
                #[doc = ""]
                #[doc = "# Failure"]
                #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
                #[doc = "claims."]
                #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
                #[doc = "one identity."]
                #[doc = "- External secondary keys can be linked to just one identity."]
                #[codec(index = 0u8)]
                cdd_register_did {
                    target_account: ::polymesh_api_client::AccountId,
                    secondary_keys: ::alloc::vec::Vec<
                        polymesh_primitives::secondary_key::SecondaryKey<
                            ::polymesh_api_client::AccountId,
                        >,
                    >,
                },
                #[doc = "Invalidates any claim generated by `cdd` from `disable_from` timestamps."]
                #[doc = ""]
                #[doc = "You can also define an expiration time,"]
                #[doc = "which will invalidate all claims generated by that `cdd` and remove it as CDD member group."]
                #[codec(index = 1u8)]
                invalidate_cdd_claims {
                    cdd: ::polymesh_api_client::IdentityId,
                    disable_from: u64,
                    expiry: Option<u64>,
                },
                #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
                #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
                #[doc = "this change (or this is not required), primary key of the DID is updated."]
                #[doc = ""]
                #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
                #[doc = "unlinked to any identity."]
                #[doc = ""]
                #[doc = "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key"]
                #[doc = "instead of leaving it as a secondary key."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
                #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
                #[codec(index = 2u8)]
                accept_primary_key {
                    rotation_auth_id: u64,
                    optional_cdd_auth_id: Option<u64>,
                },
                #[doc = "Set if CDD authorization is required for updating primary key of an identity."]
                #[doc = "Callable via root (governance)"]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `auth_required` CDD Authorization required or not"]
                #[codec(index = 3u8)]
                change_cdd_requirement_for_mk_rotation { auth_required: bool },
                #[doc = "Join an identity as a secondary key."]
                #[codec(index = 4u8)]
                join_identity_as_key { auth_id: u64 },
                #[doc = "Leave the secondary key's identity."]
                #[codec(index = 5u8)]
                leave_identity_as_key,
                #[doc = "Adds a new claim record or edits an existing one."]
                #[doc = ""]
                #[doc = "Only called by did_issuer's secondary key."]
                #[codec(index = 6u8)]
                add_claim {
                    target: ::polymesh_api_client::IdentityId,
                    claim: polymesh_primitives::identity_claim::Claim,
                    expiry: Option<u64>,
                },
                #[doc = "Marks the specified claim as revoked."]
                #[codec(index = 7u8)]
                revoke_claim {
                    target: ::polymesh_api_client::IdentityId,
                    claim: polymesh_primitives::identity_claim::Claim,
                },
                #[doc = "It disables all secondary keys at `did` identity."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = ""]
                #[codec(index = 8u8)]
                freeze_secondary_keys,
                #[doc = "Re-enables all secondary keys of the caller's identity."]
                #[codec(index = 9u8)]
                unfreeze_secondary_keys,
                #[doc = "Adds an authorization."]
                #[codec(index = 10u8)]
                add_authorization {
                    target: polymesh_primitives::secondary_key::Signatory<
                        ::polymesh_api_client::AccountId,
                    >,
                    data: polymesh_primitives::authorization::AuthorizationData<
                        ::polymesh_api_client::AccountId,
                    >,
                    expiry: Option<u64>,
                },
                #[doc = "Removes an authorization."]
                #[doc = "`_auth_issuer_pays` determines whether the issuer of the authorisation pays the transaction fee"]
                #[codec(index = 11u8)]
                remove_authorization {
                    target: polymesh_primitives::secondary_key::Signatory<
                        ::polymesh_api_client::AccountId,
                    >,
                    auth_id: u64,
                    auth_issuer_pays: bool,
                },
                #[doc = "Assuming this is executed by the GC voting majority, adds a new cdd claim record."]
                #[codec(index = 12u8)]
                gc_add_cdd_claim {
                    target: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Assuming this is executed by the GC voting majority, removes an existing cdd claim record."]
                #[codec(index = 13u8)]
                gc_revoke_cdd_claim {
                    target: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`,"]
                #[doc = "`claim_type`, and `scope`."]
                #[doc = ""]
                #[doc = "Please note that `origin` must be the issuer of the target claim."]
                #[codec(index = 14u8)]
                revoke_claim_by_index {
                    target: ::polymesh_api_client::IdentityId,
                    claim_type: polymesh_primitives::identity_claim::ClaimType,
                    scope: Option<polymesh_primitives::identity_claim::Scope>,
                },
                #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
                #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
                #[doc = "this change, (or this is not required), primary key of the DID is updated."]
                #[doc = ""]
                #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
                #[doc = "unlinked to any identity."]
                #[doc = ""]
                #[doc = "Differs from accept_primary_key in that it will leave the old primary key as a secondary"]
                #[doc = "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization"]
                #[doc = "instead of unlinking the old primary key."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
                #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
                #[codec(index = 15u8)]
                rotate_primary_key_to_secondary {
                    auth_id: u64,
                    optional_cdd_auth_id: Option<u64>,
                },
                #[doc = "Adds secondary keys to target identity `id`."]
                #[doc = ""]
                #[doc = "Keys are directly added to identity because each of them has an authorization."]
                #[doc = ""]
                #[doc = "# Arguments:"]
                #[doc = "    - `origin` which must be the primary key of the identity `id`."]
                #[doc = "    - `id` to which new secondary keys will be added."]
                #[doc = "    - `additional_keys` which includes secondary keys,"]
                #[doc = "       coupled with authorization data, to add to target identity."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "    - Can only called by primary key owner."]
                #[doc = "    - Keys should be able to linked to any identity."]
                #[codec(index = 16u8)]
                add_secondary_keys_with_authorization {
                    additional_keys: ::alloc::vec::Vec<
                        polymesh_primitives::identity::SecondaryKeyWithAuth<
                            ::polymesh_api_client::AccountId,
                        >,
                    >,
                    expires_at: u64,
                },
                #[doc = "Sets permissions for an specific `target_key` key."]
                #[doc = ""]
                #[doc = "Only the primary key of an identity is able to set secondary key permissions."]
                #[codec(index = 17u8)]
                set_secondary_key_permissions {
                    key: ::polymesh_api_client::AccountId,
                    perms: polymesh_primitives::secondary_key::Permissions,
                },
                #[doc = "Removes specified secondary keys of a DID if present."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = ""]
                #[doc = "The extrinsic can only called by primary key owner."]
                #[codec(index = 18u8)]
                remove_secondary_keys {
                    keys_to_remove: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "Register custom claim type."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists."]
                #[doc = "* `CounterOverflow` CustomClaimTypeId has overflowed."]
                #[doc = "* `TooLong` The type being registered is too lang."]
                #[codec(index = 19u8)]
                register_custom_claim_type { ty: ::alloc::vec::Vec<u8> },
                #[doc = "Register `target_account` with a new Identity and issue a CDD claim with a blank CddId"]
                #[doc = ""]
                #[doc = "# Failure"]
                #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
                #[doc = "claims."]
                #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
                #[doc = "one identity."]
                #[doc = "- External secondary keys can be linked to just one identity."]
                #[codec(index = 20u8)]
                cdd_register_did_with_cdd {
                    target_account: ::polymesh_api_client::AccountId,
                    secondary_keys: ::alloc::vec::Vec<
                        polymesh_primitives::secondary_key::SecondaryKey<
                            ::polymesh_api_client::AccountId,
                        >,
                    >,
                    expiry: Option<u64>,
                },
                #[doc = "Create a child identity and make the `secondary_key` it's primary key."]
                #[doc = ""]
                #[doc = "Only the primary key can create child identities."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `secondary_key` the secondary key that will become the primary key of the new identity."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
                #[doc = "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity."]
                #[doc = "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity."]
                #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
                #[codec(index = 21u8)]
                create_child_identity {
                    secondary_key: ::polymesh_api_client::AccountId,
                },
                #[doc = "Create a child identities."]
                #[doc = ""]
                #[doc = "The new primary key for each child identity will need to sign (off-chain)"]
                #[doc = "an authorization."]
                #[doc = ""]
                #[doc = "Only the primary key can create child identities."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `child_keys` the keys that will become primary keys of their own child identity."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
                #[doc = "- `AlreadyLinked` one of the keys is already linked to an identity."]
                #[doc = "- `DuplicateKey` one of the keys is included multiple times."]
                #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
                #[codec(index = 22u8)]
                create_child_identities {
                    child_keys: ::alloc::vec::Vec<
                        polymesh_primitives::identity::CreateChildIdentityWithAuth<
                            ::polymesh_api_client::AccountId,
                        >,
                    >,
                    expires_at: u64,
                },
                #[doc = "Unlink a child identity from it's parent identity."]
                #[doc = ""]
                #[doc = "Only the primary key of the parent or child identities can unlink the identities."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `child_did` the child identity to unlink from its parent identity."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities."]
                #[doc = "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity."]
                #[doc = "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity."]
                #[codec(index = 23u8)]
                unlink_child_identity {
                    child_did: ::polymesh_api_client::IdentityId,
                },
            }
            impl IdentityCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::cdd_register_did { .. } => "Identity.cdd_register_did",
                        Self::invalidate_cdd_claims { .. } => "Identity.invalidate_cdd_claims",
                        Self::accept_primary_key { .. } => "Identity.accept_primary_key",
                        Self::change_cdd_requirement_for_mk_rotation { .. } => {
                            "Identity.change_cdd_requirement_for_mk_rotation"
                        }
                        Self::join_identity_as_key { .. } => "Identity.join_identity_as_key",
                        Self::leave_identity_as_key => "Identity.leave_identity_as_key",
                        Self::add_claim { .. } => "Identity.add_claim",
                        Self::revoke_claim { .. } => "Identity.revoke_claim",
                        Self::freeze_secondary_keys => "Identity.freeze_secondary_keys",
                        Self::unfreeze_secondary_keys => "Identity.unfreeze_secondary_keys",
                        Self::add_authorization { .. } => "Identity.add_authorization",
                        Self::remove_authorization { .. } => "Identity.remove_authorization",
                        Self::gc_add_cdd_claim { .. } => "Identity.gc_add_cdd_claim",
                        Self::gc_revoke_cdd_claim { .. } => "Identity.gc_revoke_cdd_claim",
                        Self::revoke_claim_by_index { .. } => "Identity.revoke_claim_by_index",
                        Self::rotate_primary_key_to_secondary { .. } => {
                            "Identity.rotate_primary_key_to_secondary"
                        }
                        Self::add_secondary_keys_with_authorization { .. } => {
                            "Identity.add_secondary_keys_with_authorization"
                        }
                        Self::set_secondary_key_permissions { .. } => {
                            "Identity.set_secondary_key_permissions"
                        }
                        Self::remove_secondary_keys { .. } => "Identity.remove_secondary_keys",
                        Self::register_custom_claim_type { .. } => {
                            "Identity.register_custom_claim_type"
                        }
                        Self::cdd_register_did_with_cdd { .. } => {
                            "Identity.cdd_register_did_with_cdd"
                        }
                        Self::create_child_identity { .. } => "Identity.create_child_identity",
                        Self::create_child_identities { .. } => "Identity.create_child_identities",
                        Self::unlink_child_identity { .. } => "Identity.unlink_child_identity",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for IdentityCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: cdd_register_did { .. } => { & ["Register `target_account` with a new Identity." , "" , "# Failure" , "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new" , "claims." , "- `target_account` (primary key of the new Identity) can be linked to just one and only" , "one identity." , "- External secondary keys can be linked to just one identity." ,] } , Self :: invalidate_cdd_claims { .. } => { & ["Invalidates any claim generated by `cdd` from `disable_from` timestamps." , "" , "You can also define an expiration time," , "which will invalidate all claims generated by that `cdd` and remove it as CDD member group." ,] } , Self :: accept_primary_key { .. } => { & ["Call this with the new primary key. By invoking this method, caller accepts authorization" , "to become the new primary key of the issuing identity. If a CDD service provider approved" , "this change (or this is not required), primary key of the DID is updated." , "" , "The caller (new primary key) must be either a secondary key of the issuing identity, or" , "unlinked to any identity." , "" , "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key" , "instead of leaving it as a secondary key." , "" , "# Arguments" , "* `owner_auth_id` Authorization from the owner who initiated the change" , "* `cdd_auth_id` Authorization from a CDD service provider" ,] } , Self :: change_cdd_requirement_for_mk_rotation { .. } => { & ["Set if CDD authorization is required for updating primary key of an identity." , "Callable via root (governance)" , "" , "# Arguments" , "* `auth_required` CDD Authorization required or not" ,] } , Self :: join_identity_as_key { .. } => { & ["Join an identity as a secondary key." ,] } , Self :: leave_identity_as_key => { & ["Leave the secondary key's identity." ,] } , Self :: add_claim { .. } => { & ["Adds a new claim record or edits an existing one." , "" , "Only called by did_issuer's secondary key." ,] } , Self :: revoke_claim { .. } => { & ["Marks the specified claim as revoked." ,] } , Self :: freeze_secondary_keys => { & ["It disables all secondary keys at `did` identity." , "" , "# Errors" , "" ,] } , Self :: unfreeze_secondary_keys => { & ["Re-enables all secondary keys of the caller's identity." ,] } , Self :: add_authorization { .. } => { & ["Adds an authorization." ,] } , Self :: remove_authorization { .. } => { & ["Removes an authorization." , "`_auth_issuer_pays` determines whether the issuer of the authorisation pays the transaction fee" ,] } , Self :: gc_add_cdd_claim { .. } => { & ["Assuming this is executed by the GC voting majority, adds a new cdd claim record." ,] } , Self :: gc_revoke_cdd_claim { .. } => { & ["Assuming this is executed by the GC voting majority, removes an existing cdd claim record." ,] } , Self :: revoke_claim_by_index { .. } => { & ["Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`," , "`claim_type`, and `scope`." , "" , "Please note that `origin` must be the issuer of the target claim." ,] } , Self :: rotate_primary_key_to_secondary { .. } => { & ["Call this with the new primary key. By invoking this method, caller accepts authorization" , "to become the new primary key of the issuing identity. If a CDD service provider approved" , "this change, (or this is not required), primary key of the DID is updated." , "" , "The caller (new primary key) must be either a secondary key of the issuing identity, or" , "unlinked to any identity." , "" , "Differs from accept_primary_key in that it will leave the old primary key as a secondary" , "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization" , "instead of unlinking the old primary key." , "" , "# Arguments" , "* `owner_auth_id` Authorization from the owner who initiated the change" , "* `cdd_auth_id` Authorization from a CDD service provider" ,] } , Self :: add_secondary_keys_with_authorization { .. } => { & ["Adds secondary keys to target identity `id`." , "" , "Keys are directly added to identity because each of them has an authorization." , "" , "# Arguments:" , "    - `origin` which must be the primary key of the identity `id`." , "    - `id` to which new secondary keys will be added." , "    - `additional_keys` which includes secondary keys," , "       coupled with authorization data, to add to target identity." , "" , "# Errors" , "    - Can only called by primary key owner." , "    - Keys should be able to linked to any identity." ,] } , Self :: set_secondary_key_permissions { .. } => { & ["Sets permissions for an specific `target_key` key." , "" , "Only the primary key of an identity is able to set secondary key permissions." ,] } , Self :: remove_secondary_keys { .. } => { & ["Removes specified secondary keys of a DID if present." , "" , "# Errors" , "" , "The extrinsic can only called by primary key owner." ,] } , Self :: register_custom_claim_type { .. } => { & ["Register custom claim type." , "" , "# Errors" , "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists." , "* `CounterOverflow` CustomClaimTypeId has overflowed." , "* `TooLong` The type being registered is too lang." ,] } , Self :: cdd_register_did_with_cdd { .. } => { & ["Register `target_account` with a new Identity and issue a CDD claim with a blank CddId" , "" , "# Failure" , "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new" , "claims." , "- `target_account` (primary key of the new Identity) can be linked to just one and only" , "one identity." , "- External secondary keys can be linked to just one identity." ,] } , Self :: create_child_identity { .. } => { & ["Create a child identity and make the `secondary_key` it's primary key." , "" , "Only the primary key can create child identities." , "" , "# Arguments" , "- `secondary_key` the secondary key that will become the primary key of the new identity." , "" , "# Errors" , "- `KeyNotAllowed` only the primary key can create a new identity." , "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity." , "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity." , "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities." ,] } , Self :: create_child_identities { .. } => { & ["Create a child identities." , "" , "The new primary key for each child identity will need to sign (off-chain)" , "an authorization." , "" , "Only the primary key can create child identities." , "" , "# Arguments" , "- `child_keys` the keys that will become primary keys of their own child identity." , "" , "# Errors" , "- `KeyNotAllowed` only the primary key can create a new identity." , "- `AlreadyLinked` one of the keys is already linked to an identity." , "- `DuplicateKey` one of the keys is included multiple times." , "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities." ,] } , Self :: unlink_child_identity { .. } => { & ["Unlink a child identity from it's parent identity." , "" , "Only the primary key of the parent or child identities can unlink the identities." , "" , "# Arguments" , "- `child_did` the child identity to unlink from its parent identity." , "" , "# Errors" , "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities." , "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity." , "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity." ,] } , _ => & [""] , }
                }
            }
            impl From<IdentityCall> for &'static str {
                fn from(v: IdentityCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&IdentityCall> for &'static str {
                fn from(v: &IdentityCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum IdentityError {
                #[doc = "One secondary or primary key can only belong to one DID"]
                #[codec(index = 0u8)]
                AlreadyLinked,
                #[doc = "Caller is missing an identity."]
                #[codec(index = 1u8)]
                MissingIdentity,
                #[doc = "Signatory is not pre authorized by the identity"]
                #[codec(index = 2u8)]
                Unauthorized,
                #[doc = "Account Id cannot be extracted from signer"]
                #[codec(index = 3u8)]
                InvalidAccountKey,
                #[doc = "Only CDD service providers are allowed."]
                #[codec(index = 4u8)]
                UnAuthorizedCddProvider,
                #[doc = "An invalid authorization from the owner."]
                #[codec(index = 5u8)]
                InvalidAuthorizationFromOwner,
                #[doc = "An invalid authorization from the CDD provider."]
                #[codec(index = 6u8)]
                InvalidAuthorizationFromCddProvider,
                #[doc = "Attestation was not by a CDD service provider."]
                #[codec(index = 7u8)]
                NotCddProviderAttestation,
                #[doc = "Authorizations are not for the same DID."]
                #[codec(index = 8u8)]
                AuthorizationsNotForSameDids,
                #[doc = "The DID must already exist."]
                #[codec(index = 9u8)]
                DidMustAlreadyExist,
                #[doc = "The offchain authorization has expired."]
                #[codec(index = 10u8)]
                AuthorizationExpired,
                #[doc = "The target DID has no valid CDD."]
                #[codec(index = 11u8)]
                TargetHasNoCdd,
                #[doc = "Authorization has been explicitly revoked."]
                #[codec(index = 12u8)]
                AuthorizationHasBeenRevoked,
                #[doc = "An invalid authorization signature."]
                #[codec(index = 13u8)]
                InvalidAuthorizationSignature,
                #[doc = "This key is not allowed to execute a given operation."]
                #[codec(index = 14u8)]
                KeyNotAllowed,
                #[doc = "Only the primary key is allowed to revoke an Identity Signatory off-chain authorization."]
                #[codec(index = 15u8)]
                NotPrimaryKey,
                #[doc = "The DID does not exist."]
                #[codec(index = 16u8)]
                DidDoesNotExist,
                #[doc = "The DID already exists."]
                #[codec(index = 17u8)]
                DidAlreadyExists,
                #[doc = "The secondary keys contain the primary key."]
                #[codec(index = 18u8)]
                SecondaryKeysContainPrimaryKey,
                #[doc = "Couldn't charge fee for the transaction."]
                #[codec(index = 19u8)]
                FailedToChargeFee,
                #[doc = "Signer is not a secondary key of the provided identity"]
                #[codec(index = 20u8)]
                NotASigner,
                #[doc = "Cannot convert a `T::AccountId` to `AnySignature::Signer::AccountId`."]
                #[codec(index = 21u8)]
                CannotDecodeSignerAccountId,
                #[doc = "The account key is being used, it can't be unlinked."]
                #[codec(index = 22u8)]
                AccountKeyIsBeingUsed,
                #[doc = "A custom scope is too long."]
                #[doc = "It can at most be `32` characters long."]
                #[codec(index = 23u8)]
                CustomScopeTooLong,
                #[doc = "The custom claim type trying to be registered already exists."]
                #[codec(index = 24u8)]
                CustomClaimTypeAlreadyExists,
                #[doc = "The custom claim type does not exist."]
                #[codec(index = 25u8)]
                CustomClaimTypeDoesNotExist,
                #[doc = "Claim does not exist."]
                #[codec(index = 26u8)]
                ClaimDoesNotExist,
                #[doc = "Identity is already a child of an other identity, can't create grand-child identity."]
                #[codec(index = 27u8)]
                IsChildIdentity,
                #[doc = "The Identity doesn't have a parent identity."]
                #[codec(index = 28u8)]
                NoParentIdentity,
                #[doc = "The caller is not the parent or child identity."]
                #[codec(index = 29u8)]
                NotParentOrChildIdentity,
                #[doc = "The same key was included multiple times."]
                #[codec(index = 30u8)]
                DuplicateKey,
                #[doc = "Cannot use Except when specifying extrinsic permissions."]
                #[codec(index = 31u8)]
                ExceptNotAllowedForExtrinsics,
                #[doc = "Maximum number of given authorizations was exceeded."]
                #[codec(index = 32u8)]
                ExceededNumberOfGivenAuths,
                #[doc = "The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is."]
                #[codec(index = 33u8)]
                BadAuthorizationType,
                #[doc = "Auth identified by an `auth_id` for a given `target` does not exist."]
                #[doc = "The `target` might be wrong or the `auth_id` was never created at all."]
                #[codec(index = 34u8)]
                InvalidAuthorization,
                #[doc = "Frozen secondary key."]
                #[codec(index = 35u8)]
                UnauthorizedCallerFrozenDid,
                #[doc = "The DID is missing a CDD claim."]
                #[codec(index = 36u8)]
                UnauthorizedCallerDidMissingCdd,
                #[doc = "The key does not have permissions to execute the extrinsic."]
                #[codec(index = 37u8)]
                UnauthorizedCallerMissingPermissions,
            }
            impl IdentityError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::AlreadyLinked => "Identity.AlreadyLinked",
                        Self::MissingIdentity => "Identity.MissingIdentity",
                        Self::Unauthorized => "Identity.Unauthorized",
                        Self::InvalidAccountKey => "Identity.InvalidAccountKey",
                        Self::UnAuthorizedCddProvider => "Identity.UnAuthorizedCddProvider",
                        Self::InvalidAuthorizationFromOwner => {
                            "Identity.InvalidAuthorizationFromOwner"
                        }
                        Self::InvalidAuthorizationFromCddProvider => {
                            "Identity.InvalidAuthorizationFromCddProvider"
                        }
                        Self::NotCddProviderAttestation => "Identity.NotCddProviderAttestation",
                        Self::AuthorizationsNotForSameDids => {
                            "Identity.AuthorizationsNotForSameDids"
                        }
                        Self::DidMustAlreadyExist => "Identity.DidMustAlreadyExist",
                        Self::AuthorizationExpired => "Identity.AuthorizationExpired",
                        Self::TargetHasNoCdd => "Identity.TargetHasNoCdd",
                        Self::AuthorizationHasBeenRevoked => "Identity.AuthorizationHasBeenRevoked",
                        Self::InvalidAuthorizationSignature => {
                            "Identity.InvalidAuthorizationSignature"
                        }
                        Self::KeyNotAllowed => "Identity.KeyNotAllowed",
                        Self::NotPrimaryKey => "Identity.NotPrimaryKey",
                        Self::DidDoesNotExist => "Identity.DidDoesNotExist",
                        Self::DidAlreadyExists => "Identity.DidAlreadyExists",
                        Self::SecondaryKeysContainPrimaryKey => {
                            "Identity.SecondaryKeysContainPrimaryKey"
                        }
                        Self::FailedToChargeFee => "Identity.FailedToChargeFee",
                        Self::NotASigner => "Identity.NotASigner",
                        Self::CannotDecodeSignerAccountId => "Identity.CannotDecodeSignerAccountId",
                        Self::AccountKeyIsBeingUsed => "Identity.AccountKeyIsBeingUsed",
                        Self::CustomScopeTooLong => "Identity.CustomScopeTooLong",
                        Self::CustomClaimTypeAlreadyExists => {
                            "Identity.CustomClaimTypeAlreadyExists"
                        }
                        Self::CustomClaimTypeDoesNotExist => "Identity.CustomClaimTypeDoesNotExist",
                        Self::ClaimDoesNotExist => "Identity.ClaimDoesNotExist",
                        Self::IsChildIdentity => "Identity.IsChildIdentity",
                        Self::NoParentIdentity => "Identity.NoParentIdentity",
                        Self::NotParentOrChildIdentity => "Identity.NotParentOrChildIdentity",
                        Self::DuplicateKey => "Identity.DuplicateKey",
                        Self::ExceptNotAllowedForExtrinsics => {
                            "Identity.ExceptNotAllowedForExtrinsics"
                        }
                        Self::ExceededNumberOfGivenAuths => "Identity.ExceededNumberOfGivenAuths",
                        Self::BadAuthorizationType => "Identity.BadAuthorizationType",
                        Self::InvalidAuthorization => "Identity.InvalidAuthorization",
                        Self::UnauthorizedCallerFrozenDid => "Identity.UnauthorizedCallerFrozenDid",
                        Self::UnauthorizedCallerDidMissingCdd => {
                            "Identity.UnauthorizedCallerDidMissingCdd"
                        }
                        Self::UnauthorizedCallerMissingPermissions => {
                            "Identity.UnauthorizedCallerMissingPermissions"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for IdentityError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: AlreadyLinked => { & ["One secondary or primary key can only belong to one DID" ,] } , Self :: MissingIdentity => { & ["Caller is missing an identity." ,] } , Self :: Unauthorized => { & ["Signatory is not pre authorized by the identity" ,] } , Self :: InvalidAccountKey => { & ["Account Id cannot be extracted from signer" ,] } , Self :: UnAuthorizedCddProvider => { & ["Only CDD service providers are allowed." ,] } , Self :: InvalidAuthorizationFromOwner => { & ["An invalid authorization from the owner." ,] } , Self :: InvalidAuthorizationFromCddProvider => { & ["An invalid authorization from the CDD provider." ,] } , Self :: NotCddProviderAttestation => { & ["Attestation was not by a CDD service provider." ,] } , Self :: AuthorizationsNotForSameDids => { & ["Authorizations are not for the same DID." ,] } , Self :: DidMustAlreadyExist => { & ["The DID must already exist." ,] } , Self :: AuthorizationExpired => { & ["The offchain authorization has expired." ,] } , Self :: TargetHasNoCdd => { & ["The target DID has no valid CDD." ,] } , Self :: AuthorizationHasBeenRevoked => { & ["Authorization has been explicitly revoked." ,] } , Self :: InvalidAuthorizationSignature => { & ["An invalid authorization signature." ,] } , Self :: KeyNotAllowed => { & ["This key is not allowed to execute a given operation." ,] } , Self :: NotPrimaryKey => { & ["Only the primary key is allowed to revoke an Identity Signatory off-chain authorization." ,] } , Self :: DidDoesNotExist => { & ["The DID does not exist." ,] } , Self :: DidAlreadyExists => { & ["The DID already exists." ,] } , Self :: SecondaryKeysContainPrimaryKey => { & ["The secondary keys contain the primary key." ,] } , Self :: FailedToChargeFee => { & ["Couldn't charge fee for the transaction." ,] } , Self :: NotASigner => { & ["Signer is not a secondary key of the provided identity" ,] } , Self :: CannotDecodeSignerAccountId => { & ["Cannot convert a `T::AccountId` to `AnySignature::Signer::AccountId`." ,] } , Self :: AccountKeyIsBeingUsed => { & ["The account key is being used, it can't be unlinked." ,] } , Self :: CustomScopeTooLong => { & ["A custom scope is too long." , "It can at most be `32` characters long." ,] } , Self :: CustomClaimTypeAlreadyExists => { & ["The custom claim type trying to be registered already exists." ,] } , Self :: CustomClaimTypeDoesNotExist => { & ["The custom claim type does not exist." ,] } , Self :: ClaimDoesNotExist => { & ["Claim does not exist." ,] } , Self :: IsChildIdentity => { & ["Identity is already a child of an other identity, can't create grand-child identity." ,] } , Self :: NoParentIdentity => { & ["The Identity doesn't have a parent identity." ,] } , Self :: NotParentOrChildIdentity => { & ["The caller is not the parent or child identity." ,] } , Self :: DuplicateKey => { & ["The same key was included multiple times." ,] } , Self :: ExceptNotAllowedForExtrinsics => { & ["Cannot use Except when specifying extrinsic permissions." ,] } , Self :: ExceededNumberOfGivenAuths => { & ["Maximum number of given authorizations was exceeded." ,] } , Self :: BadAuthorizationType => { & ["The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is." ,] } , Self :: InvalidAuthorization => { & ["Auth identified by an `auth_id` for a given `target` does not exist." , "The `target` might be wrong or the `auth_id` was never created at all." ,] } , Self :: UnauthorizedCallerFrozenDid => { & ["Frozen secondary key." ,] } , Self :: UnauthorizedCallerDidMissingCdd => { & ["The DID is missing a CDD claim." ,] } , Self :: UnauthorizedCallerMissingPermissions => { & ["The key does not have permissions to execute the extrinsic." ,] } , _ => & [""] , }
                }
            }
            impl From<IdentityError> for &'static str {
                fn from(v: IdentityError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&IdentityError> for &'static str {
                fn from(v: &IdentityError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum IdentityEvent {
                #[doc = "Identity created."]
                #[doc = ""]
                #[doc = "(DID, primary key, secondary keys)"]
                #[codec(index = 0u8)]
                DidCreated(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AccountId,
                    ::alloc::vec::Vec<
                        polymesh_primitives::secondary_key::SecondaryKey<
                            ::polymesh_api_client::AccountId,
                        >,
                    >,
                ),
                #[doc = "Secondary keys added to identity."]
                #[doc = ""]
                #[doc = "(DID, new keys)"]
                #[codec(index = 1u8)]
                SecondaryKeysAdded(
                    ::polymesh_api_client::IdentityId,
                    ::alloc::vec::Vec<
                        polymesh_primitives::secondary_key::SecondaryKey<
                            ::polymesh_api_client::AccountId,
                        >,
                    >,
                ),
                #[doc = "Secondary keys removed from identity."]
                #[doc = ""]
                #[doc = "(DID, the keys that got removed)"]
                #[codec(index = 2u8)]
                SecondaryKeysRemoved(
                    ::polymesh_api_client::IdentityId,
                    ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                ),
                #[doc = "A secondary key left their identity."]
                #[doc = ""]
                #[doc = "(DID, secondary key)"]
                #[codec(index = 3u8)]
                SecondaryKeyLeftIdentity(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AccountId,
                ),
                #[doc = "Secondary key permissions updated."]
                #[doc = ""]
                #[doc = "(DID, updated secondary key, previous permissions, new permissions)"]
                #[codec(index = 4u8)]
                SecondaryKeyPermissionsUpdated(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AccountId,
                    polymesh_primitives::secondary_key::Permissions,
                    polymesh_primitives::secondary_key::Permissions,
                ),
                #[doc = "Primary key of identity changed."]
                #[doc = ""]
                #[doc = "(DID, old primary key account ID, new ID)"]
                #[codec(index = 5u8)]
                PrimaryKeyUpdated(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AccountId,
                    ::polymesh_api_client::AccountId,
                ),
                #[doc = "Claim added to identity."]
                #[doc = ""]
                #[doc = "(DID, claim)"]
                #[codec(index = 6u8)]
                ClaimAdded(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_claim::IdentityClaim,
                ),
                #[doc = "Claim revoked from identity."]
                #[doc = ""]
                #[doc = "(DID, claim)"]
                #[codec(index = 7u8)]
                ClaimRevoked(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_claim::IdentityClaim,
                ),
                #[doc = "Asset's identity registered."]
                #[doc = ""]
                #[doc = "(Asset DID, ticker)"]
                #[codec(index = 8u8)]
                AssetDidRegistered(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::ticker::Ticker,
                ),
                #[doc = "New authorization added."]
                #[doc = ""]
                #[doc = "(authorised_by, target_did, target_key, auth_id, authorization_data, expiry)"]
                #[codec(index = 9u8)]
                AuthorizationAdded(
                    ::polymesh_api_client::IdentityId,
                    Option<::polymesh_api_client::IdentityId>,
                    Option<::polymesh_api_client::AccountId>,
                    u64,
                    polymesh_primitives::authorization::AuthorizationData<
                        ::polymesh_api_client::AccountId,
                    >,
                    Option<u64>,
                ),
                #[doc = "Authorization revoked by the authorizer."]
                #[doc = ""]
                #[doc = "(authorized_identity, authorized_key, auth_id)"]
                #[codec(index = 10u8)]
                AuthorizationRevoked(
                    Option<::polymesh_api_client::IdentityId>,
                    Option<::polymesh_api_client::AccountId>,
                    u64,
                ),
                #[doc = "Authorization rejected by the user who was authorized."]
                #[doc = ""]
                #[doc = "(authorized_identity, authorized_key, auth_id)"]
                #[codec(index = 11u8)]
                AuthorizationRejected(
                    Option<::polymesh_api_client::IdentityId>,
                    Option<::polymesh_api_client::AccountId>,
                    u64,
                ),
                #[doc = "Authorization consumed."]
                #[doc = ""]
                #[doc = "(authorized_identity, authorized_key, auth_id)"]
                #[codec(index = 12u8)]
                AuthorizationConsumed(
                    Option<::polymesh_api_client::IdentityId>,
                    Option<::polymesh_api_client::AccountId>,
                    u64,
                ),
                #[doc = "Accepting Authorization retry limit reached."]
                #[doc = ""]
                #[doc = "(authorized_identity, authorized_key, auth_id)"]
                #[codec(index = 13u8)]
                AuthorizationRetryLimitReached(
                    Option<::polymesh_api_client::IdentityId>,
                    Option<::polymesh_api_client::AccountId>,
                    u64,
                ),
                #[doc = "CDD requirement for updating primary key changed."]
                #[doc = ""]
                #[doc = "(new_requirement)"]
                #[codec(index = 14u8)]
                CddRequirementForPrimaryKeyUpdated(bool),
                #[doc = "CDD claims generated by `IdentityId` (a CDD Provider) have been invalidated from"]
                #[doc = "`Moment`."]
                #[doc = ""]
                #[doc = "(CDD provider DID, disable from date)"]
                #[codec(index = 15u8)]
                CddClaimsInvalidated(::polymesh_api_client::IdentityId, u64),
                #[doc = "All Secondary keys of the identity ID are frozen."]
                #[doc = ""]
                #[doc = "(DID)"]
                #[codec(index = 16u8)]
                SecondaryKeysFrozen(::polymesh_api_client::IdentityId),
                #[doc = "All Secondary keys of the identity ID are unfrozen."]
                #[doc = ""]
                #[doc = "(DID)"]
                #[codec(index = 17u8)]
                SecondaryKeysUnfrozen(::polymesh_api_client::IdentityId),
                #[doc = "A new CustomClaimType was added."]
                #[doc = ""]
                #[doc = "(DID, id, Type)"]
                #[codec(index = 18u8)]
                CustomClaimTypeAdded(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_claim::CustomClaimTypeId,
                    ::alloc::vec::Vec<u8>,
                ),
                #[doc = "Child identity created."]
                #[doc = ""]
                #[doc = "(Parent DID, Child DID, primary key)"]
                #[codec(index = 19u8)]
                ChildDidCreated(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AccountId,
                ),
                #[doc = "Child identity unlinked from parent identity."]
                #[doc = ""]
                #[doc = "(Caller DID, Parent DID, Child DID)"]
                #[codec(index = 20u8)]
                ChildDidUnlinked(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                ),
            }
            impl IdentityEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::DidCreated(_, _, _) => "Identity.DidCreated",
                        Self::SecondaryKeysAdded(_, _) => "Identity.SecondaryKeysAdded",
                        Self::SecondaryKeysRemoved(_, _) => "Identity.SecondaryKeysRemoved",
                        Self::SecondaryKeyLeftIdentity(_, _) => "Identity.SecondaryKeyLeftIdentity",
                        Self::SecondaryKeyPermissionsUpdated(_, _, _, _) => {
                            "Identity.SecondaryKeyPermissionsUpdated"
                        }
                        Self::PrimaryKeyUpdated(_, _, _) => "Identity.PrimaryKeyUpdated",
                        Self::ClaimAdded(_, _) => "Identity.ClaimAdded",
                        Self::ClaimRevoked(_, _) => "Identity.ClaimRevoked",
                        Self::AssetDidRegistered(_, _) => "Identity.AssetDidRegistered",
                        Self::AuthorizationAdded(_, _, _, _, _, _) => "Identity.AuthorizationAdded",
                        Self::AuthorizationRevoked(_, _, _) => "Identity.AuthorizationRevoked",
                        Self::AuthorizationRejected(_, _, _) => "Identity.AuthorizationRejected",
                        Self::AuthorizationConsumed(_, _, _) => "Identity.AuthorizationConsumed",
                        Self::AuthorizationRetryLimitReached(_, _, _) => {
                            "Identity.AuthorizationRetryLimitReached"
                        }
                        Self::CddRequirementForPrimaryKeyUpdated(_) => {
                            "Identity.CddRequirementForPrimaryKeyUpdated"
                        }
                        Self::CddClaimsInvalidated(_, _) => "Identity.CddClaimsInvalidated",
                        Self::SecondaryKeysFrozen(_) => "Identity.SecondaryKeysFrozen",
                        Self::SecondaryKeysUnfrozen(_) => "Identity.SecondaryKeysUnfrozen",
                        Self::CustomClaimTypeAdded(_, _, _) => "Identity.CustomClaimTypeAdded",
                        Self::ChildDidCreated(_, _, _) => "Identity.ChildDidCreated",
                        Self::ChildDidUnlinked(_, _, _) => "Identity.ChildDidUnlinked",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for IdentityEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: DidCreated (_ , _ , _) => { & ["Identity created." , "" , "(DID, primary key, secondary keys)" ,] } , Self :: SecondaryKeysAdded (_ , _) => { & ["Secondary keys added to identity." , "" , "(DID, new keys)" ,] } , Self :: SecondaryKeysRemoved (_ , _) => { & ["Secondary keys removed from identity." , "" , "(DID, the keys that got removed)" ,] } , Self :: SecondaryKeyLeftIdentity (_ , _) => { & ["A secondary key left their identity." , "" , "(DID, secondary key)" ,] } , Self :: SecondaryKeyPermissionsUpdated (_ , _ , _ , _) => { & ["Secondary key permissions updated." , "" , "(DID, updated secondary key, previous permissions, new permissions)" ,] } , Self :: PrimaryKeyUpdated (_ , _ , _) => { & ["Primary key of identity changed." , "" , "(DID, old primary key account ID, new ID)" ,] } , Self :: ClaimAdded (_ , _) => { & ["Claim added to identity." , "" , "(DID, claim)" ,] } , Self :: ClaimRevoked (_ , _) => { & ["Claim revoked from identity." , "" , "(DID, claim)" ,] } , Self :: AssetDidRegistered (_ , _) => { & ["Asset's identity registered." , "" , "(Asset DID, ticker)" ,] } , Self :: AuthorizationAdded (_ , _ , _ , _ , _ , _) => { & ["New authorization added." , "" , "(authorised_by, target_did, target_key, auth_id, authorization_data, expiry)" ,] } , Self :: AuthorizationRevoked (_ , _ , _) => { & ["Authorization revoked by the authorizer." , "" , "(authorized_identity, authorized_key, auth_id)" ,] } , Self :: AuthorizationRejected (_ , _ , _) => { & ["Authorization rejected by the user who was authorized." , "" , "(authorized_identity, authorized_key, auth_id)" ,] } , Self :: AuthorizationConsumed (_ , _ , _) => { & ["Authorization consumed." , "" , "(authorized_identity, authorized_key, auth_id)" ,] } , Self :: AuthorizationRetryLimitReached (_ , _ , _) => { & ["Accepting Authorization retry limit reached." , "" , "(authorized_identity, authorized_key, auth_id)" ,] } , Self :: CddRequirementForPrimaryKeyUpdated (_) => { & ["CDD requirement for updating primary key changed." , "" , "(new_requirement)" ,] } , Self :: CddClaimsInvalidated (_ , _) => { & ["CDD claims generated by `IdentityId` (a CDD Provider) have been invalidated from" , "`Moment`." , "" , "(CDD provider DID, disable from date)" ,] } , Self :: SecondaryKeysFrozen (_) => { & ["All Secondary keys of the identity ID are frozen." , "" , "(DID)" ,] } , Self :: SecondaryKeysUnfrozen (_) => { & ["All Secondary keys of the identity ID are unfrozen." , "" , "(DID)" ,] } , Self :: CustomClaimTypeAdded (_ , _ , _) => { & ["A new CustomClaimType was added." , "" , "(DID, id, Type)" ,] } , Self :: ChildDidCreated (_ , _ , _) => { & ["Child identity created." , "" , "(Parent DID, Child DID, primary key)" ,] } , Self :: ChildDidUnlinked (_ , _ , _) => { & ["Child identity unlinked from parent identity." , "" , "(Caller DID, Parent DID, Child DID)" ,] } , _ => & [""] , }
                }
            }
            impl From<IdentityEvent> for &'static str {
                fn from(v: IdentityEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&IdentityEvent> for &'static str {
                fn from(v: &IdentityEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        pub mod types {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Claim1stKey {
                pub target: ::polymesh_api_client::IdentityId,
                pub claim_type: polymesh_primitives::identity_claim::ClaimType,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Claim2ndKey {
                pub issuer: ::polymesh_api_client::IdentityId,
                pub scope: Option<polymesh_primitives::identity_claim::Scope>,
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Version(pub u8);
    }
    pub mod pallet_im_online {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ImOnlineCall {
                #[doc = "## Complexity:"]
                #[doc = "- `O(K)` where K is length of `Keys` (heartbeat.validators_len)"]
                #[doc = "  - `O(K)`: decoding of length `K`"]
                #[codec(index = 0u8)]
                heartbeat {
                    heartbeat: pallet_im_online::Heartbeat<u32>,
                    signature: pallet_im_online::sr25519::app_sr25519::Signature,
                },
            }
            impl ImOnlineCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::heartbeat { .. } => "ImOnline.heartbeat",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ImOnlineCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::heartbeat { .. } => &[
                            "## Complexity:",
                            "- `O(K)` where K is length of `Keys` (heartbeat.validators_len)",
                            "  - `O(K)`: decoding of length `K`",
                        ],
                        _ => &[""],
                    }
                }
            }
            impl From<ImOnlineCall> for &'static str {
                fn from(v: ImOnlineCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ImOnlineCall> for &'static str {
                fn from(v: &ImOnlineCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ImOnlineError {
                #[doc = "Non existent public key."]
                #[codec(index = 0u8)]
                InvalidKey,
                #[doc = "Duplicated heartbeat."]
                #[codec(index = 1u8)]
                DuplicatedHeartbeat,
            }
            impl ImOnlineError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InvalidKey => "ImOnline.InvalidKey",
                        Self::DuplicatedHeartbeat => "ImOnline.DuplicatedHeartbeat",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ImOnlineError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InvalidKey => &["Non existent public key."],
                        Self::DuplicatedHeartbeat => &["Duplicated heartbeat."],
                        _ => &[""],
                    }
                }
            }
            impl From<ImOnlineError> for &'static str {
                fn from(v: ImOnlineError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ImOnlineError> for &'static str {
                fn from(v: &ImOnlineError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ImOnlineEvent {
                #[doc = "A new heartbeat was received from `AuthorityId`."]
                #[codec(index = 0u8)]
                HeartbeatReceived {
                    authority_id: pallet_im_online::sr25519::app_sr25519::Public,
                },
                #[doc = "At the end of the session, no offence was committed."]
                #[codec(index = 1u8)]
                AllGood,
                #[doc = "At the end of the session, at least one validator was found to be offline."]
                #[codec(index = 2u8)]
                SomeOffline {
                    offline: ::alloc::vec::Vec<(
                        ::polymesh_api_client::AccountId,
                        sp_staking::Exposure<::polymesh_api_client::AccountId, u128>,
                    )>,
                },
            }
            impl ImOnlineEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::HeartbeatReceived { .. } => "ImOnline.HeartbeatReceived",
                        Self::AllGood => "ImOnline.AllGood",
                        Self::SomeOffline { .. } => "ImOnline.SomeOffline",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ImOnlineEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: HeartbeatReceived { .. } => { & ["A new heartbeat was received from `AuthorityId`." ,] } , Self :: AllGood => { & ["At the end of the session, no offence was committed." ,] } , Self :: SomeOffline { .. } => { & ["At the end of the session, at least one validator was found to be offline." ,] } , _ => & [""] , }
                }
            }
            impl From<ImOnlineEvent> for &'static str {
                fn from(v: ImOnlineEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ImOnlineEvent> for &'static str {
                fn from(v: &ImOnlineEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        pub mod sr25519 {
            use super::*;
            pub mod app_sr25519 {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct Public(pub [u8; 32usize]);
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct Signature(
                    #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                    pub [u8; 64usize],
                );
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Heartbeat<BlockNumber> {
            pub block_number: BlockNumber,
            pub session_index: BlockNumber,
            pub authority_index: BlockNumber,
            pub validators_len: BlockNumber,
        }
    }
    pub mod pallet_indices {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum IndicesCall {
                #[doc = "Assign an previously unassigned index."]
                #[doc = ""]
                #[doc = "Payment: `Deposit` is reserved from the sender account."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Signed_."]
                #[doc = ""]
                #[doc = "- `index`: the index to be claimed. This must not be in use."]
                #[doc = ""]
                #[doc = "Emits `IndexAssigned` if successful."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- `O(1)`."]
                #[codec(index = 0u8)]
                claim { index: u32 },
                #[doc = "Assign an index already owned by the sender to another account. The balance reservation"]
                #[doc = "is effectively transferred to the new account."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Signed_."]
                #[doc = ""]
                #[doc = "- `index`: the index to be re-assigned. This must be owned by the sender."]
                #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
                #[doc = ""]
                #[doc = "Emits `IndexAssigned` if successful."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- `O(1)`."]
                #[codec(index = 1u8)]
                transfer {
                    new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    index: u32,
                },
                #[doc = "Free up an index owned by the sender."]
                #[doc = ""]
                #[doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."]
                #[doc = ""]
                #[doc = "- `index`: the index to be freed. This must be owned by the sender."]
                #[doc = ""]
                #[doc = "Emits `IndexFreed` if successful."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- `O(1)`."]
                #[codec(index = 2u8)]
                free { index: u32 },
                #[doc = "Force an index to an account. This doesn't require a deposit. If the index is already"]
                #[doc = "held, then any deposit is reimbursed to its current owner."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Root_."]
                #[doc = ""]
                #[doc = "- `index`: the index to be (re-)assigned."]
                #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
                #[doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."]
                #[doc = ""]
                #[doc = "Emits `IndexAssigned` if successful."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- `O(1)`."]
                #[codec(index = 3u8)]
                force_transfer {
                    new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    index: u32,
                    freeze: bool,
                },
                #[doc = "Freeze an index so it will always point to the sender account. This consumes the"]
                #[doc = "deposit."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
                #[doc = "non-frozen account `index`."]
                #[doc = ""]
                #[doc = "- `index`: the index to be frozen in place."]
                #[doc = ""]
                #[doc = "Emits `IndexFrozen` if successful."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- `O(1)`."]
                #[codec(index = 4u8)]
                freeze { index: u32 },
                #[doc = "Poke the deposit reserved for an index."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
                #[doc = "non-frozen account `index`."]
                #[doc = ""]
                #[doc = "The transaction fees is waived if the deposit is changed after poking/reconsideration."]
                #[doc = ""]
                #[doc = "- `index`: the index whose deposit is to be poked/reconsidered."]
                #[doc = ""]
                #[doc = "Emits `DepositPoked` if successful."]
                #[codec(index = 5u8)]
                poke_deposit { index: u32 },
            }
            impl IndicesCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::claim { .. } => "Indices.claim",
                        Self::transfer { .. } => "Indices.transfer",
                        Self::free { .. } => "Indices.free",
                        Self::force_transfer { .. } => "Indices.force_transfer",
                        Self::freeze { .. } => "Indices.freeze",
                        Self::poke_deposit { .. } => "Indices.poke_deposit",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for IndicesCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: claim { .. } => { & ["Assign an previously unassigned index." , "" , "Payment: `Deposit` is reserved from the sender account." , "" , "The dispatch origin for this call must be _Signed_." , "" , "- `index`: the index to be claimed. This must not be in use." , "" , "Emits `IndexAssigned` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: transfer { .. } => { & ["Assign an index already owned by the sender to another account. The balance reservation" , "is effectively transferred to the new account." , "" , "The dispatch origin for this call must be _Signed_." , "" , "- `index`: the index to be re-assigned. This must be owned by the sender." , "- `new`: the new owner of the index. This function is a no-op if it is equal to sender." , "" , "Emits `IndexAssigned` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: free { .. } => { & ["Free up an index owned by the sender." , "" , "Payment: Any previous deposit placed for the index is unreserved in the sender account." , "" , "The dispatch origin for this call must be _Signed_ and the sender must own the index." , "" , "- `index`: the index to be freed. This must be owned by the sender." , "" , "Emits `IndexFreed` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: force_transfer { .. } => { & ["Force an index to an account. This doesn't require a deposit. If the index is already" , "held, then any deposit is reimbursed to its current owner." , "" , "The dispatch origin for this call must be _Root_." , "" , "- `index`: the index to be (re-)assigned." , "- `new`: the new owner of the index. This function is a no-op if it is equal to sender." , "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred." , "" , "Emits `IndexAssigned` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: freeze { .. } => { & ["Freeze an index so it will always point to the sender account. This consumes the" , "deposit." , "" , "The dispatch origin for this call must be _Signed_ and the signing account must have a" , "non-frozen account `index`." , "" , "- `index`: the index to be frozen in place." , "" , "Emits `IndexFrozen` if successful." , "" , "## Complexity" , "- `O(1)`." ,] } , Self :: poke_deposit { .. } => { & ["Poke the deposit reserved for an index." , "" , "The dispatch origin for this call must be _Signed_ and the signing account must have a" , "non-frozen account `index`." , "" , "The transaction fees is waived if the deposit is changed after poking/reconsideration." , "" , "- `index`: the index whose deposit is to be poked/reconsidered." , "" , "Emits `DepositPoked` if successful." ,] } , _ => & [""] , }
                }
            }
            impl From<IndicesCall> for &'static str {
                fn from(v: IndicesCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&IndicesCall> for &'static str {
                fn from(v: &IndicesCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum IndicesError {
                #[doc = "The index was not already assigned."]
                #[codec(index = 0u8)]
                NotAssigned,
                #[doc = "The index is assigned to another account."]
                #[codec(index = 1u8)]
                NotOwner,
                #[doc = "The index was not available."]
                #[codec(index = 2u8)]
                InUse,
                #[doc = "The source and destination accounts are identical."]
                #[codec(index = 3u8)]
                NotTransfer,
                #[doc = "The index is permanent and may not be freed/changed."]
                #[codec(index = 4u8)]
                Permanent,
            }
            impl IndicesError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::NotAssigned => "Indices.NotAssigned",
                        Self::NotOwner => "Indices.NotOwner",
                        Self::InUse => "Indices.InUse",
                        Self::NotTransfer => "Indices.NotTransfer",
                        Self::Permanent => "Indices.Permanent",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for IndicesError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::NotAssigned => &["The index was not already assigned."],
                        Self::NotOwner => &["The index is assigned to another account."],
                        Self::InUse => &["The index was not available."],
                        Self::NotTransfer => {
                            &["The source and destination accounts are identical."]
                        }
                        Self::Permanent => {
                            &["The index is permanent and may not be freed/changed."]
                        }
                        _ => &[""],
                    }
                }
            }
            impl From<IndicesError> for &'static str {
                fn from(v: IndicesError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&IndicesError> for &'static str {
                fn from(v: &IndicesError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum IndicesEvent {
                #[doc = "A account index was assigned."]
                #[codec(index = 0u8)]
                IndexAssigned {
                    who: ::polymesh_api_client::AccountId,
                    index: u32,
                },
                #[doc = "A account index has been freed up (unassigned)."]
                #[codec(index = 1u8)]
                IndexFreed { index: u32 },
                #[doc = "A account index has been frozen to its current account ID."]
                #[codec(index = 2u8)]
                IndexFrozen {
                    index: u32,
                    who: ::polymesh_api_client::AccountId,
                },
                #[doc = "A deposit to reserve an index has been poked/reconsidered."]
                #[codec(index = 3u8)]
                DepositPoked {
                    who: ::polymesh_api_client::AccountId,
                    index: u32,
                    old_deposit: u128,
                    new_deposit: u128,
                },
            }
            impl IndicesEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::IndexAssigned { .. } => "Indices.IndexAssigned",
                        Self::IndexFreed { .. } => "Indices.IndexFreed",
                        Self::IndexFrozen { .. } => "Indices.IndexFrozen",
                        Self::DepositPoked { .. } => "Indices.DepositPoked",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for IndicesEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::IndexAssigned { .. } => &["A account index was assigned."],
                        Self::IndexFreed { .. } => {
                            &["A account index has been freed up (unassigned)."]
                        }
                        Self::IndexFrozen { .. } => {
                            &["A account index has been frozen to its current account ID."]
                        }
                        Self::DepositPoked { .. } => {
                            &["A deposit to reserve an index has been poked/reconsidered."]
                        }
                        _ => &[""],
                    }
                }
            }
            impl From<IndicesEvent> for &'static str {
                fn from(v: IndicesEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&IndicesEvent> for &'static str {
                fn from(v: &IndicesEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_multisig {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum MultiSigCall {
                #[doc = "Creates a multisig"]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)."]
                #[doc = "* `sigs_required` - Number of sigs required to process a multi-sig tx."]
                #[doc = "* `permissions` - optional custom permissions.  Only the primary key can provide custom permissions."]
                #[codec(index = 0u8)]
                create_multisig {
                    signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                    sigs_required: u64,
                    permissions: Option<polymesh_primitives::secondary_key::Permissions>,
                },
                #[doc = "Creates a multisig proposal"]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `multisig` - MultiSig address."]
                #[doc = "* `proposal` - Proposal to be voted on."]
                #[doc = "* `expiry` - Optional proposal expiry time."]
                #[doc = ""]
                #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
                #[codec(index = 1u8)]
                create_proposal {
                    multisig: ::polymesh_api_client::AccountId,
                    proposal: ::alloc::boxed::Box<runtime::RuntimeCall>,
                    expiry: Option<u64>,
                },
                #[doc = "Approves a multisig proposal using the caller's secondary key (`AccountId`)."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `multisig` - MultiSig address."]
                #[doc = "* `proposal_id` - Proposal id to approve."]
                #[doc = "* `max_weight` - The maximum weight to execute the proposal."]
                #[doc = ""]
                #[doc = "If quorum is reached, the proposal will be immediately executed."]
                #[codec(index = 2u8)]
                approve {
                    multisig: ::polymesh_api_client::AccountId,
                    proposal_id: u64,
                    max_weight: Option<::polymesh_api_client::sp_weights::Weight>,
                },
                #[doc = "Rejects a multisig proposal using the caller's secondary key (`AccountId`)."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `multisig` - MultiSig address."]
                #[doc = "* `proposal_id` - Proposal id to reject."]
                #[doc = "If quorum is reached, the proposal will be immediately executed."]
                #[codec(index = 3u8)]
                reject {
                    multisig: ::polymesh_api_client::AccountId,
                    proposal_id: u64,
                },
                #[doc = "Accepts a multisig signer authorization given to signer's key (AccountId)."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `auth_id` - Auth id of the authorization."]
                #[codec(index = 4u8)]
                accept_multisig_signer { auth_id: u64 },
                #[doc = "Adds signers to the multisig.  This must be called by the multisig itself."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `signers` - Signers to add."]
                #[codec(index = 5u8)]
                add_multisig_signers {
                    signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "Removes signers from the multisig.  This must be called by the multisig itself."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `signers` - Signers to remove."]
                #[codec(index = 6u8)]
                remove_multisig_signers {
                    signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "Adds a signer to the multisig.  This must be called by the admin identity of the"]
                #[doc = "multisig."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `multisig` - Address of the multi sig"]
                #[doc = "* `signers` - Signers to add."]
                #[doc = ""]
                #[codec(index = 7u8)]
                add_multisig_signers_via_admin {
                    multisig: ::polymesh_api_client::AccountId,
                    signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "Removes a signer from the multisig."]
                #[doc = "This must be called by the admin identity of the multisig."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `multisig` - Address of the multisig."]
                #[doc = "* `signers` - Signers to remove."]
                #[doc = ""]
                #[codec(index = 8u8)]
                remove_multisig_signers_via_admin {
                    multisig: ::polymesh_api_client::AccountId,
                    signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "Changes the number of signatures required by a multisig.  This must be called by the"]
                #[doc = "multisig itself."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `sigs_required` - New number of required signatures."]
                #[codec(index = 9u8)]
                change_sigs_required { sigs_required: u64 },
                #[doc = "Changes the number of signatures required by a multisig.  This must be called by the admin of the multisig."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `multisig` - The account identifier ([`AccountId`]) for the multi signature account."]
                #[doc = "* `signatures_required` - The number of required signatures."]
                #[codec(index = 10u8)]
                change_sigs_required_via_admin {
                    multisig: ::polymesh_api_client::AccountId,
                    signatures_required: u64,
                },
                #[doc = "Add an admin identity to the multisig.  This must be called by the multisig itself."]
                #[codec(index = 11u8)]
                add_admin {
                    admin_did: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Removes the admin identity from the `multisig`.  This must be called by the admin of the multisig."]
                #[codec(index = 12u8)]
                remove_admin_via_admin {
                    multisig: ::polymesh_api_client::AccountId,
                },
                #[doc = "Removes the paying identity from the `multisig`.  This must be called by the multisig itself."]
                #[codec(index = 13u8)]
                remove_payer,
                #[doc = "Removes the paying identity from the `multisig`.  This must be called by the paying identity of the multisig."]
                #[codec(index = 14u8)]
                remove_payer_via_payer {
                    multisig: ::polymesh_api_client::AccountId,
                },
                #[doc = "Approves a multisig join identity proposal."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `multisig` - MultiSig address."]
                #[doc = "* `auth_id` - The join identity authorization to approve."]
                #[doc = ""]
                #[doc = "If quorum is reached, the join identity proposal will be immediately executed."]
                #[codec(index = 15u8)]
                approve_join_identity {
                    multisig: ::polymesh_api_client::AccountId,
                    auth_id: u64,
                },
                #[doc = "Accept a JoinIdentity authorization for this multisig.  This must be called by the multisig itself."]
                #[codec(index = 16u8)]
                join_identity { auth_id: u64 },
                #[doc = "Removes the admin identity from the `multisig`.  This must be called by the multisig itself."]
                #[codec(index = 17u8)]
                remove_admin,
            }
            impl MultiSigCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::create_multisig { .. } => "MultiSig.create_multisig",
                        Self::create_proposal { .. } => "MultiSig.create_proposal",
                        Self::approve { .. } => "MultiSig.approve",
                        Self::reject { .. } => "MultiSig.reject",
                        Self::accept_multisig_signer { .. } => "MultiSig.accept_multisig_signer",
                        Self::add_multisig_signers { .. } => "MultiSig.add_multisig_signers",
                        Self::remove_multisig_signers { .. } => "MultiSig.remove_multisig_signers",
                        Self::add_multisig_signers_via_admin { .. } => {
                            "MultiSig.add_multisig_signers_via_admin"
                        }
                        Self::remove_multisig_signers_via_admin { .. } => {
                            "MultiSig.remove_multisig_signers_via_admin"
                        }
                        Self::change_sigs_required { .. } => "MultiSig.change_sigs_required",
                        Self::change_sigs_required_via_admin { .. } => {
                            "MultiSig.change_sigs_required_via_admin"
                        }
                        Self::add_admin { .. } => "MultiSig.add_admin",
                        Self::remove_admin_via_admin { .. } => "MultiSig.remove_admin_via_admin",
                        Self::remove_payer => "MultiSig.remove_payer",
                        Self::remove_payer_via_payer { .. } => "MultiSig.remove_payer_via_payer",
                        Self::approve_join_identity { .. } => "MultiSig.approve_join_identity",
                        Self::join_identity { .. } => "MultiSig.join_identity",
                        Self::remove_admin => "MultiSig.remove_admin",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for MultiSigCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: create_multisig { .. } => { & ["Creates a multisig" , "" , "# Arguments" , "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)." , "* `sigs_required` - Number of sigs required to process a multi-sig tx." , "* `permissions` - optional custom permissions.  Only the primary key can provide custom permissions." ,] } , Self :: create_proposal { .. } => { & ["Creates a multisig proposal" , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal` - Proposal to be voted on." , "* `expiry` - Optional proposal expiry time." , "" , "If this is 1 out of `m` multisig, the proposal will be immediately executed." ,] } , Self :: approve { .. } => { & ["Approves a multisig proposal using the caller's secondary key (`AccountId`)." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal_id` - Proposal id to approve." , "* `max_weight` - The maximum weight to execute the proposal." , "" , "If quorum is reached, the proposal will be immediately executed." ,] } , Self :: reject { .. } => { & ["Rejects a multisig proposal using the caller's secondary key (`AccountId`)." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `proposal_id` - Proposal id to reject." , "If quorum is reached, the proposal will be immediately executed." ,] } , Self :: accept_multisig_signer { .. } => { & ["Accepts a multisig signer authorization given to signer's key (AccountId)." , "" , "# Arguments" , "* `auth_id` - Auth id of the authorization." ,] } , Self :: add_multisig_signers { .. } => { & ["Adds signers to the multisig.  This must be called by the multisig itself." , "" , "# Arguments" , "* `signers` - Signers to add." ,] } , Self :: remove_multisig_signers { .. } => { & ["Removes signers from the multisig.  This must be called by the multisig itself." , "" , "# Arguments" , "* `signers` - Signers to remove." ,] } , Self :: add_multisig_signers_via_admin { .. } => { & ["Adds a signer to the multisig.  This must be called by the admin identity of the" , "multisig." , "" , "# Arguments" , "* `multisig` - Address of the multi sig" , "* `signers` - Signers to add." , "" ,] } , Self :: remove_multisig_signers_via_admin { .. } => { & ["Removes a signer from the multisig." , "This must be called by the admin identity of the multisig." , "" , "# Arguments" , "* `multisig` - Address of the multisig." , "* `signers` - Signers to remove." , "" ,] } , Self :: change_sigs_required { .. } => { & ["Changes the number of signatures required by a multisig.  This must be called by the" , "multisig itself." , "" , "# Arguments" , "* `sigs_required` - New number of required signatures." ,] } , Self :: change_sigs_required_via_admin { .. } => { & ["Changes the number of signatures required by a multisig.  This must be called by the admin of the multisig." , "" , "# Arguments" , "* `multisig` - The account identifier ([`AccountId`]) for the multi signature account." , "* `signatures_required` - The number of required signatures." ,] } , Self :: add_admin { .. } => { & ["Add an admin identity to the multisig.  This must be called by the multisig itself." ,] } , Self :: remove_admin_via_admin { .. } => { & ["Removes the admin identity from the `multisig`.  This must be called by the admin of the multisig." ,] } , Self :: remove_payer => { & ["Removes the paying identity from the `multisig`.  This must be called by the multisig itself." ,] } , Self :: remove_payer_via_payer { .. } => { & ["Removes the paying identity from the `multisig`.  This must be called by the paying identity of the multisig." ,] } , Self :: approve_join_identity { .. } => { & ["Approves a multisig join identity proposal." , "" , "# Arguments" , "* `multisig` - MultiSig address." , "* `auth_id` - The join identity authorization to approve." , "" , "If quorum is reached, the join identity proposal will be immediately executed." ,] } , Self :: join_identity { .. } => { & ["Accept a JoinIdentity authorization for this multisig.  This must be called by the multisig itself." ,] } , Self :: remove_admin => { & ["Removes the admin identity from the `multisig`.  This must be called by the multisig itself." ,] } , _ => & [""] , }
                }
            }
            impl From<MultiSigCall> for &'static str {
                fn from(v: MultiSigCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&MultiSigCall> for &'static str {
                fn from(v: &MultiSigCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "Multisig module errors."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum MultiSigError {
                #[doc = "The proposal does not exist."]
                #[codec(index = 0u8)]
                ProposalMissing,
                #[doc = "Multisig address."]
                #[codec(index = 1u8)]
                DecodingError,
                #[doc = "Required number of signers must be greater then zero."]
                #[codec(index = 2u8)]
                RequiredSignersIsZero,
                #[doc = "Not a signer."]
                #[codec(index = 3u8)]
                NotASigner,
                #[doc = "No such multisig."]
                #[codec(index = 4u8)]
                NoSuchMultisig,
                #[doc = "Not enough signers.  The number of signers has to be greater then or equal to"]
                #[doc = "the required number of signers to approve proposals."]
                #[codec(index = 5u8)]
                NotEnoughSigners,
                #[doc = "A nonce overflow."]
                #[codec(index = 6u8)]
                NonceOverflow,
                #[doc = "Already voted."]
                #[codec(index = 7u8)]
                AlreadyVoted,
                #[doc = "Already a signer."]
                #[codec(index = 8u8)]
                AlreadyASigner,
                #[doc = "Identity provided is not the multisig's admin."]
                #[codec(index = 9u8)]
                IdentityNotAdmin,
                #[doc = "Identity provided is not the multisig's payer."]
                #[codec(index = 10u8)]
                IdentityNotPayer,
                #[doc = "Changing multisig parameters not allowed since multisig is a primary key."]
                #[codec(index = 11u8)]
                ChangeNotAllowed,
                #[doc = "Signer is an account key that is already associated with a multisig."]
                #[codec(index = 12u8)]
                SignerAlreadyLinkedToMultisig,
                #[doc = "Signer is an account key that is already associated with an identity."]
                #[codec(index = 13u8)]
                SignerAlreadyLinkedToIdentity,
                #[doc = "A multisig can't be a signer of another multisig."]
                #[codec(index = 14u8)]
                NestingNotAllowed,
                #[doc = "Proposal was rejected earlier"]
                #[codec(index = 15u8)]
                ProposalAlreadyRejected,
                #[doc = "Proposal has expired"]
                #[codec(index = 16u8)]
                ProposalExpired,
                #[doc = "Proposal was executed earlier"]
                #[codec(index = 17u8)]
                ProposalAlreadyExecuted,
                #[doc = "Max weight not enough to execute proposal."]
                #[codec(index = 18u8)]
                MaxWeightTooLow,
                #[doc = "Multisig is not attached to an identity"]
                #[codec(index = 19u8)]
                MultisigMissingIdentity,
                #[doc = "Tried to add/remove too many signers."]
                #[codec(index = 20u8)]
                TooManySigners,
                #[doc = "Multisig doesn't have a paying DID."]
                #[codec(index = 21u8)]
                NoPayingDid,
                #[doc = "Expiry must be in the future."]
                #[codec(index = 22u8)]
                InvalidExpiryDate,
                #[doc = "The proposal has been invalidated after a multisg update."]
                #[codec(index = 23u8)]
                InvalidatedProposal,
                #[doc = "Multisig has no admin."]
                #[codec(index = 24u8)]
                AdminNotFound,
                #[doc = "The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is."]
                #[codec(index = 25u8)]
                BadAuthorizationType,
            }
            impl MultiSigError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::ProposalMissing => "MultiSig.ProposalMissing",
                        Self::DecodingError => "MultiSig.DecodingError",
                        Self::RequiredSignersIsZero => "MultiSig.RequiredSignersIsZero",
                        Self::NotASigner => "MultiSig.NotASigner",
                        Self::NoSuchMultisig => "MultiSig.NoSuchMultisig",
                        Self::NotEnoughSigners => "MultiSig.NotEnoughSigners",
                        Self::NonceOverflow => "MultiSig.NonceOverflow",
                        Self::AlreadyVoted => "MultiSig.AlreadyVoted",
                        Self::AlreadyASigner => "MultiSig.AlreadyASigner",
                        Self::IdentityNotAdmin => "MultiSig.IdentityNotAdmin",
                        Self::IdentityNotPayer => "MultiSig.IdentityNotPayer",
                        Self::ChangeNotAllowed => "MultiSig.ChangeNotAllowed",
                        Self::SignerAlreadyLinkedToMultisig => {
                            "MultiSig.SignerAlreadyLinkedToMultisig"
                        }
                        Self::SignerAlreadyLinkedToIdentity => {
                            "MultiSig.SignerAlreadyLinkedToIdentity"
                        }
                        Self::NestingNotAllowed => "MultiSig.NestingNotAllowed",
                        Self::ProposalAlreadyRejected => "MultiSig.ProposalAlreadyRejected",
                        Self::ProposalExpired => "MultiSig.ProposalExpired",
                        Self::ProposalAlreadyExecuted => "MultiSig.ProposalAlreadyExecuted",
                        Self::MaxWeightTooLow => "MultiSig.MaxWeightTooLow",
                        Self::MultisigMissingIdentity => "MultiSig.MultisigMissingIdentity",
                        Self::TooManySigners => "MultiSig.TooManySigners",
                        Self::NoPayingDid => "MultiSig.NoPayingDid",
                        Self::InvalidExpiryDate => "MultiSig.InvalidExpiryDate",
                        Self::InvalidatedProposal => "MultiSig.InvalidatedProposal",
                        Self::AdminNotFound => "MultiSig.AdminNotFound",
                        Self::BadAuthorizationType => "MultiSig.BadAuthorizationType",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for MultiSigError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: ProposalMissing => { & ["The proposal does not exist." ,] } , Self :: DecodingError => { & ["Multisig address." ,] } , Self :: RequiredSignersIsZero => { & ["Required number of signers must be greater then zero." ,] } , Self :: NotASigner => { & ["Not a signer." ,] } , Self :: NoSuchMultisig => { & ["No such multisig." ,] } , Self :: NotEnoughSigners => { & ["Not enough signers.  The number of signers has to be greater then or equal to" , "the required number of signers to approve proposals." ,] } , Self :: NonceOverflow => { & ["A nonce overflow." ,] } , Self :: AlreadyVoted => { & ["Already voted." ,] } , Self :: AlreadyASigner => { & ["Already a signer." ,] } , Self :: IdentityNotAdmin => { & ["Identity provided is not the multisig's admin." ,] } , Self :: IdentityNotPayer => { & ["Identity provided is not the multisig's payer." ,] } , Self :: ChangeNotAllowed => { & ["Changing multisig parameters not allowed since multisig is a primary key." ,] } , Self :: SignerAlreadyLinkedToMultisig => { & ["Signer is an account key that is already associated with a multisig." ,] } , Self :: SignerAlreadyLinkedToIdentity => { & ["Signer is an account key that is already associated with an identity." ,] } , Self :: NestingNotAllowed => { & ["A multisig can't be a signer of another multisig." ,] } , Self :: ProposalAlreadyRejected => { & ["Proposal was rejected earlier" ,] } , Self :: ProposalExpired => { & ["Proposal has expired" ,] } , Self :: ProposalAlreadyExecuted => { & ["Proposal was executed earlier" ,] } , Self :: MaxWeightTooLow => { & ["Max weight not enough to execute proposal." ,] } , Self :: MultisigMissingIdentity => { & ["Multisig is not attached to an identity" ,] } , Self :: TooManySigners => { & ["Tried to add/remove too many signers." ,] } , Self :: NoPayingDid => { & ["Multisig doesn't have a paying DID." ,] } , Self :: InvalidExpiryDate => { & ["Expiry must be in the future." ,] } , Self :: InvalidatedProposal => { & ["The proposal has been invalidated after a multisg update." ,] } , Self :: AdminNotFound => { & ["Multisig has no admin." ,] } , Self :: BadAuthorizationType => { & ["The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is." ,] } , _ => & [""] , }
                }
            }
            impl From<MultiSigError> for &'static str {
                fn from(v: MultiSigError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&MultiSigError> for &'static str {
                fn from(v: &MultiSigError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum MultiSigEvent {
                #[doc = "A Multisig has been created."]
                #[codec(index = 0u8)]
                MultiSigCreated {
                    caller_did: ::polymesh_api_client::IdentityId,
                    multisig: ::polymesh_api_client::AccountId,
                    caller: ::polymesh_api_client::AccountId,
                    signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                    sigs_required: u64,
                },
                #[doc = "A Multisig proposal has been created."]
                #[codec(index = 1u8)]
                ProposalAdded {
                    caller_did: Option<::polymesh_api_client::IdentityId>,
                    multisig: ::polymesh_api_client::AccountId,
                    proposal_id: u64,
                },
                #[doc = "A Multisig proposal has been executed."]
                #[codec(index = 2u8)]
                ProposalExecuted {
                    caller_did: Option<::polymesh_api_client::IdentityId>,
                    multisig: ::polymesh_api_client::AccountId,
                    proposal_id: u64,
                    result: Result<(), sp_runtime::DispatchError>,
                },
                #[doc = "A new signer has been added to a Multisig."]
                #[codec(index = 3u8)]
                MultiSigSignerAdded {
                    caller_did: ::polymesh_api_client::IdentityId,
                    multisig: ::polymesh_api_client::AccountId,
                    signer: ::polymesh_api_client::AccountId,
                },
                #[doc = "New keys have been authorized to be signers on a Multisig."]
                #[codec(index = 4u8)]
                MultiSigSignersAuthorized {
                    caller_did: ::polymesh_api_client::IdentityId,
                    multisig: ::polymesh_api_client::AccountId,
                    signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "Signers have been removed from a Multisig."]
                #[codec(index = 5u8)]
                MultiSigSignersRemoved {
                    caller_did: ::polymesh_api_client::IdentityId,
                    multisig: ::polymesh_api_client::AccountId,
                    signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "A Multisig has changed its required number of approvals."]
                #[codec(index = 6u8)]
                MultiSigSignersRequiredChanged {
                    caller_did: Option<::polymesh_api_client::IdentityId>,
                    multisig: ::polymesh_api_client::AccountId,
                    sigs_required: u64,
                },
                #[doc = "A signer has voted to approve a Multisig proposal."]
                #[codec(index = 7u8)]
                ProposalApprovalVote {
                    caller_did: Option<::polymesh_api_client::IdentityId>,
                    multisig: ::polymesh_api_client::AccountId,
                    signer: ::polymesh_api_client::AccountId,
                    proposal_id: u64,
                },
                #[doc = "A signer has voted to reject a Multisig proposal."]
                #[codec(index = 8u8)]
                ProposalRejectionVote {
                    caller_did: Option<::polymesh_api_client::IdentityId>,
                    multisig: ::polymesh_api_client::AccountId,
                    signer: ::polymesh_api_client::AccountId,
                    proposal_id: u64,
                },
                #[doc = "A Multisig proposal has been approved."]
                #[codec(index = 9u8)]
                ProposalApproved {
                    caller_did: Option<::polymesh_api_client::IdentityId>,
                    multisig: ::polymesh_api_client::AccountId,
                    proposal_id: u64,
                },
                #[doc = "A Multisig proposal has been rejected."]
                #[codec(index = 10u8)]
                ProposalRejected {
                    caller_did: Option<::polymesh_api_client::IdentityId>,
                    multisig: ::polymesh_api_client::AccountId,
                    proposal_id: u64,
                },
                #[doc = "A Multisig has added an admin DID."]
                #[codec(index = 11u8)]
                MultiSigAddedAdmin {
                    caller_did: ::polymesh_api_client::IdentityId,
                    multisig: ::polymesh_api_client::AccountId,
                    admin_did: ::polymesh_api_client::IdentityId,
                },
                #[doc = "A Multisig has removed it's admin DID."]
                #[codec(index = 12u8)]
                MultiSigRemovedAdmin {
                    caller_did: ::polymesh_api_client::IdentityId,
                    multisig: ::polymesh_api_client::AccountId,
                    admin_did: ::polymesh_api_client::IdentityId,
                },
                #[doc = "A Multisig has removed it's paying DID."]
                #[codec(index = 13u8)]
                MultiSigRemovedPayingDid {
                    caller_did: ::polymesh_api_client::IdentityId,
                    multisig: ::polymesh_api_client::AccountId,
                    paying_did: ::polymesh_api_client::IdentityId,
                },
            }
            impl MultiSigEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::MultiSigCreated { .. } => "MultiSig.MultiSigCreated",
                        Self::ProposalAdded { .. } => "MultiSig.ProposalAdded",
                        Self::ProposalExecuted { .. } => "MultiSig.ProposalExecuted",
                        Self::MultiSigSignerAdded { .. } => "MultiSig.MultiSigSignerAdded",
                        Self::MultiSigSignersAuthorized { .. } => {
                            "MultiSig.MultiSigSignersAuthorized"
                        }
                        Self::MultiSigSignersRemoved { .. } => "MultiSig.MultiSigSignersRemoved",
                        Self::MultiSigSignersRequiredChanged { .. } => {
                            "MultiSig.MultiSigSignersRequiredChanged"
                        }
                        Self::ProposalApprovalVote { .. } => "MultiSig.ProposalApprovalVote",
                        Self::ProposalRejectionVote { .. } => "MultiSig.ProposalRejectionVote",
                        Self::ProposalApproved { .. } => "MultiSig.ProposalApproved",
                        Self::ProposalRejected { .. } => "MultiSig.ProposalRejected",
                        Self::MultiSigAddedAdmin { .. } => "MultiSig.MultiSigAddedAdmin",
                        Self::MultiSigRemovedAdmin { .. } => "MultiSig.MultiSigRemovedAdmin",
                        Self::MultiSigRemovedPayingDid { .. } => {
                            "MultiSig.MultiSigRemovedPayingDid"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for MultiSigEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::MultiSigCreated { .. } => &["A Multisig has been created."],
                        Self::ProposalAdded { .. } => &["A Multisig proposal has been created."],
                        Self::ProposalExecuted { .. } => {
                            &["A Multisig proposal has been executed."]
                        }
                        Self::MultiSigSignerAdded { .. } => {
                            &["A new signer has been added to a Multisig."]
                        }
                        Self::MultiSigSignersAuthorized { .. } => {
                            &["New keys have been authorized to be signers on a Multisig."]
                        }
                        Self::MultiSigSignersRemoved { .. } => {
                            &["Signers have been removed from a Multisig."]
                        }
                        Self::MultiSigSignersRequiredChanged { .. } => {
                            &["A Multisig has changed its required number of approvals."]
                        }
                        Self::ProposalApprovalVote { .. } => {
                            &["A signer has voted to approve a Multisig proposal."]
                        }
                        Self::ProposalRejectionVote { .. } => {
                            &["A signer has voted to reject a Multisig proposal."]
                        }
                        Self::ProposalApproved { .. } => {
                            &["A Multisig proposal has been approved."]
                        }
                        Self::ProposalRejected { .. } => {
                            &["A Multisig proposal has been rejected."]
                        }
                        Self::MultiSigAddedAdmin { .. } => &["A Multisig has added an admin DID."],
                        Self::MultiSigRemovedAdmin { .. } => {
                            &["A Multisig has removed it's admin DID."]
                        }
                        Self::MultiSigRemovedPayingDid { .. } => {
                            &["A Multisig has removed it's paying DID."]
                        }
                        _ => &[""],
                    }
                }
            }
            impl From<MultiSigEvent> for &'static str {
                fn from(v: MultiSigEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&MultiSigEvent> for &'static str {
                fn from(v: &MultiSigEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Version(pub u8);
    }
    pub mod pallet_nft {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum NftCall {
                #[doc = "Cretes a new `NFTCollection`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
                #[doc = "* `asset_id` - optional [`AssetId`] associated to the new collection. `None` will create a new asset."]
                #[doc = "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type."]
                #[doc = "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have."]
                #[doc = ""]
                #[doc = "## Errors"]
                #[doc = "- `CollectionAlredyRegistered` - if the asset_id is already associated to an NFT collection."]
                #[doc = "- `InvalidAssetType` - if the associated asset is not of type NFT."]
                #[doc = "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed."]
                #[doc = "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered."]
                #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 0u8)]
                create_nft_collection {
                    asset_id: Option<::polymesh_api_client::AssetId>,
                    nft_type: Option<polymesh_primitives::asset::NonFungibleType>,
                    collection_keys: polymesh_primitives::nft::NFTCollectionKeys,
                },
                #[doc = "Issues an NFT to the caller."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
                #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
                #[doc = "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT."]
                #[doc = "- `portfolio_kind` - the portfolio that will receive the minted nft."]
                #[doc = ""]
                #[doc = "## Errors"]
                #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
                #[doc = "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection."]
                #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
                #[doc = ""]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Portfolio"]
                #[codec(index = 1u8)]
                issue_nft {
                    asset_id: ::polymesh_api_client::AssetId,
                    nft_metadata_attributes:
                        ::alloc::vec::Vec<polymesh_primitives::nft::NFTMetadataAttribute>,
                    portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
                },
                #[doc = "Redeems the given NFT from the caller's portfolio."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
                #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
                #[doc = "* `nft_id` - the id of the NFT to be burned."]
                #[doc = "* `portfolio_kind` - the portfolio that contains the nft."]
                #[doc = ""]
                #[doc = "## Errors"]
                #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
                #[doc = "- `NFTNotFound` - if the given NFT does not exist in the portfolio."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Portfolio"]
                #[codec(index = 2u8)]
                redeem_nft {
                    asset_id: ::polymesh_api_client::AssetId,
                    nft_id: polymesh_primitives::nft::NFTId,
                    portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
                    number_of_keys: Option<u8>,
                },
                #[doc = "Forces the transfer of NFTs from a given portfolio to the caller's portfolio."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
                #[doc = "* `nft_id` - the [`NFTId`] of the NFT to be transferred."]
                #[doc = "* `source_portfolio` - the [`PortfolioId`] that currently holds the NFT."]
                #[doc = "* `callers_portfolio_kind` - the [`PortfolioKind`] of the caller's portfolio."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[doc = "* Portfolio"]
                #[codec(index = 3u8)]
                controller_transfer {
                    nfts: polymesh_primitives::nft::NFTs,
                    source_portfolio: polymesh_primitives::identity_id::PortfolioId,
                    callers_portfolio_kind: polymesh_primitives::identity_id::PortfolioKind,
                },
            }
            impl NftCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::create_nft_collection { .. } => "Nft.create_nft_collection",
                        Self::issue_nft { .. } => "Nft.issue_nft",
                        Self::redeem_nft { .. } => "Nft.redeem_nft",
                        Self::controller_transfer { .. } => "Nft.controller_transfer",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for NftCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: create_nft_collection { .. } => { & ["Cretes a new `NFTCollection`." , "" , "# Arguments" , "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)." , "* `asset_id` - optional [`AssetId`] associated to the new collection. `None` will create a new asset." , "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type." , "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have." , "" , "## Errors" , "- `CollectionAlredyRegistered` - if the asset_id is already associated to an NFT collection." , "- `InvalidAssetType` - if the associated asset is not of type NFT." , "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed." , "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered." , "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input." , "" , "# Permissions" , "* Asset" ,] } , Self :: issue_nft { .. } => { & ["Issues an NFT to the caller." , "" , "# Arguments" , "* `origin` - is a signer that has permissions to act as an agent of `asset_id`." , "* `asset_id` - the [`AssetId`] of the NFT collection." , "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT." , "- `portfolio_kind` - the portfolio that will receive the minted nft." , "" , "## Errors" , "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created." , "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection." , "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input." , "" , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: redeem_nft { .. } => { & ["Redeems the given NFT from the caller's portfolio." , "" , "# Arguments" , "* `origin` - is a signer that has permissions to act as an agent of `asset_id`." , "* `asset_id` - the [`AssetId`] of the NFT collection." , "* `nft_id` - the id of the NFT to be burned." , "* `portfolio_kind` - the portfolio that contains the nft." , "" , "## Errors" , "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created." , "- `NFTNotFound` - if the given NFT does not exist in the portfolio." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , Self :: controller_transfer { .. } => { & ["Forces the transfer of NFTs from a given portfolio to the caller's portfolio." , "" , "# Arguments" , "* `origin` - is a signer that has permissions to act as an agent of `asset_id`." , "* `nft_id` - the [`NFTId`] of the NFT to be transferred." , "* `source_portfolio` - the [`PortfolioId`] that currently holds the NFT." , "* `callers_portfolio_kind` - the [`PortfolioKind`] of the caller's portfolio." , "" , "# Permissions" , "* Asset" , "* Portfolio" ,] } , _ => & [""] , }
                }
            }
            impl From<NftCall> for &'static str {
                fn from(v: NftCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&NftCall> for &'static str {
                fn from(v: &NftCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum NftError {
                #[doc = "An overflow while calculating the balance."]
                #[codec(index = 0u8)]
                BalanceOverflow,
                #[doc = "An underflow while calculating the balance."]
                #[codec(index = 1u8)]
                BalanceUnderflow,
                #[doc = "The asset_id is already associated to an NFT collection."]
                #[codec(index = 2u8)]
                CollectionAlredyRegistered,
                #[doc = "The NFT collection does not exist."]
                #[codec(index = 3u8)]
                CollectionNotFound,
                #[doc = "A duplicate metadata key has been passed as parameter."]
                #[codec(index = 4u8)]
                DuplicateMetadataKey,
                #[doc = "Duplicate ids are not allowed."]
                #[codec(index = 5u8)]
                DuplicatedNFTId,
                #[doc = "The asset must be of type non-fungible."]
                #[codec(index = 6u8)]
                InvalidAssetType,
                #[doc = "Either the number of keys or the key identifier does not match the keys defined for the collection."]
                #[codec(index = 7u8)]
                InvalidMetadataAttribute,
                #[doc = "Failed to transfer an NFT - NFT collection not found."]
                #[codec(index = 8u8)]
                InvalidNFTTransferCollectionNotFound,
                #[doc = "Failed to transfer an NFT - attempt to move to the same portfolio."]
                #[codec(index = 9u8)]
                InvalidNFTTransferSamePortfolio,
                #[doc = "Failed to transfer an NFT - NFT not found in portfolio."]
                #[codec(index = 10u8)]
                InvalidNFTTransferNFTNotOwned,
                #[doc = "Failed to transfer an NFT - identity count would overflow."]
                #[codec(index = 11u8)]
                InvalidNFTTransferCountOverflow,
                #[doc = "Failed to transfer an NFT - compliance failed."]
                #[codec(index = 12u8)]
                InvalidNFTTransferComplianceFailure,
                #[doc = "Failed to transfer an NFT - asset is frozen."]
                #[codec(index = 13u8)]
                InvalidNFTTransferFrozenAsset,
                #[doc = "Failed to transfer an NFT - the number of nfts in the identity is insufficient."]
                #[codec(index = 14u8)]
                InvalidNFTTransferInsufficientCount,
                #[doc = "The maximum number of metadata keys was exceeded."]
                #[codec(index = 15u8)]
                MaxNumberOfKeysExceeded,
                #[doc = "The maximum number of nfts being transferred in one leg was exceeded."]
                #[codec(index = 16u8)]
                MaxNumberOfNFTsPerLegExceeded,
                #[doc = "The NFT does not exist."]
                #[codec(index = 17u8)]
                NFTNotFound,
                #[doc = "At least one of the metadata keys has not been registered."]
                #[codec(index = 18u8)]
                UnregisteredMetadataKey,
                #[doc = "It is not possible to transferr zero nft."]
                #[codec(index = 19u8)]
                ZeroCount,
                #[doc = "An overflow while calculating the updated supply."]
                #[codec(index = 20u8)]
                SupplyOverflow,
                #[doc = "An underflow while calculating the updated supply."]
                #[codec(index = 21u8)]
                SupplyUnderflow,
                #[doc = "Failed to transfer an NFT - nft is locked."]
                #[codec(index = 22u8)]
                InvalidNFTTransferNFTIsLocked,
                #[doc = "The sender identity can't be the same as the receiver identity."]
                #[codec(index = 23u8)]
                InvalidNFTTransferSenderIdMatchesReceiverId,
                #[doc = "The receiver has an invalid CDD."]
                #[codec(index = 24u8)]
                InvalidNFTTransferInvalidReceiverCDD,
                #[doc = "The sender has an invalid CDD."]
                #[codec(index = 25u8)]
                InvalidNFTTransferInvalidSenderCDD,
                #[doc = "There's no asset associated to the given asset_id."]
                #[codec(index = 26u8)]
                InvalidAssetId,
                #[doc = "The NFT is locked."]
                #[codec(index = 27u8)]
                NFTIsLocked,
                #[doc = "The number of keys in the collection is greater than the input."]
                #[codec(index = 28u8)]
                NumberOfKeysIsLessThanExpected,
            }
            impl NftError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::BalanceOverflow => "Nft.BalanceOverflow",
                        Self::BalanceUnderflow => "Nft.BalanceUnderflow",
                        Self::CollectionAlredyRegistered => "Nft.CollectionAlredyRegistered",
                        Self::CollectionNotFound => "Nft.CollectionNotFound",
                        Self::DuplicateMetadataKey => "Nft.DuplicateMetadataKey",
                        Self::DuplicatedNFTId => "Nft.DuplicatedNFTId",
                        Self::InvalidAssetType => "Nft.InvalidAssetType",
                        Self::InvalidMetadataAttribute => "Nft.InvalidMetadataAttribute",
                        Self::InvalidNFTTransferCollectionNotFound => {
                            "Nft.InvalidNFTTransferCollectionNotFound"
                        }
                        Self::InvalidNFTTransferSamePortfolio => {
                            "Nft.InvalidNFTTransferSamePortfolio"
                        }
                        Self::InvalidNFTTransferNFTNotOwned => "Nft.InvalidNFTTransferNFTNotOwned",
                        Self::InvalidNFTTransferCountOverflow => {
                            "Nft.InvalidNFTTransferCountOverflow"
                        }
                        Self::InvalidNFTTransferComplianceFailure => {
                            "Nft.InvalidNFTTransferComplianceFailure"
                        }
                        Self::InvalidNFTTransferFrozenAsset => "Nft.InvalidNFTTransferFrozenAsset",
                        Self::InvalidNFTTransferInsufficientCount => {
                            "Nft.InvalidNFTTransferInsufficientCount"
                        }
                        Self::MaxNumberOfKeysExceeded => "Nft.MaxNumberOfKeysExceeded",
                        Self::MaxNumberOfNFTsPerLegExceeded => "Nft.MaxNumberOfNFTsPerLegExceeded",
                        Self::NFTNotFound => "Nft.NFTNotFound",
                        Self::UnregisteredMetadataKey => "Nft.UnregisteredMetadataKey",
                        Self::ZeroCount => "Nft.ZeroCount",
                        Self::SupplyOverflow => "Nft.SupplyOverflow",
                        Self::SupplyUnderflow => "Nft.SupplyUnderflow",
                        Self::InvalidNFTTransferNFTIsLocked => "Nft.InvalidNFTTransferNFTIsLocked",
                        Self::InvalidNFTTransferSenderIdMatchesReceiverId => {
                            "Nft.InvalidNFTTransferSenderIdMatchesReceiverId"
                        }
                        Self::InvalidNFTTransferInvalidReceiverCDD => {
                            "Nft.InvalidNFTTransferInvalidReceiverCDD"
                        }
                        Self::InvalidNFTTransferInvalidSenderCDD => {
                            "Nft.InvalidNFTTransferInvalidSenderCDD"
                        }
                        Self::InvalidAssetId => "Nft.InvalidAssetId",
                        Self::NFTIsLocked => "Nft.NFTIsLocked",
                        Self::NumberOfKeysIsLessThanExpected => {
                            "Nft.NumberOfKeysIsLessThanExpected"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for NftError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: BalanceOverflow => { & ["An overflow while calculating the balance." ,] } , Self :: BalanceUnderflow => { & ["An underflow while calculating the balance." ,] } , Self :: CollectionAlredyRegistered => { & ["The asset_id is already associated to an NFT collection." ,] } , Self :: CollectionNotFound => { & ["The NFT collection does not exist." ,] } , Self :: DuplicateMetadataKey => { & ["A duplicate metadata key has been passed as parameter." ,] } , Self :: DuplicatedNFTId => { & ["Duplicate ids are not allowed." ,] } , Self :: InvalidAssetType => { & ["The asset must be of type non-fungible." ,] } , Self :: InvalidMetadataAttribute => { & ["Either the number of keys or the key identifier does not match the keys defined for the collection." ,] } , Self :: InvalidNFTTransferCollectionNotFound => { & ["Failed to transfer an NFT - NFT collection not found." ,] } , Self :: InvalidNFTTransferSamePortfolio => { & ["Failed to transfer an NFT - attempt to move to the same portfolio." ,] } , Self :: InvalidNFTTransferNFTNotOwned => { & ["Failed to transfer an NFT - NFT not found in portfolio." ,] } , Self :: InvalidNFTTransferCountOverflow => { & ["Failed to transfer an NFT - identity count would overflow." ,] } , Self :: InvalidNFTTransferComplianceFailure => { & ["Failed to transfer an NFT - compliance failed." ,] } , Self :: InvalidNFTTransferFrozenAsset => { & ["Failed to transfer an NFT - asset is frozen." ,] } , Self :: InvalidNFTTransferInsufficientCount => { & ["Failed to transfer an NFT - the number of nfts in the identity is insufficient." ,] } , Self :: MaxNumberOfKeysExceeded => { & ["The maximum number of metadata keys was exceeded." ,] } , Self :: MaxNumberOfNFTsPerLegExceeded => { & ["The maximum number of nfts being transferred in one leg was exceeded." ,] } , Self :: NFTNotFound => { & ["The NFT does not exist." ,] } , Self :: UnregisteredMetadataKey => { & ["At least one of the metadata keys has not been registered." ,] } , Self :: ZeroCount => { & ["It is not possible to transferr zero nft." ,] } , Self :: SupplyOverflow => { & ["An overflow while calculating the updated supply." ,] } , Self :: SupplyUnderflow => { & ["An underflow while calculating the updated supply." ,] } , Self :: InvalidNFTTransferNFTIsLocked => { & ["Failed to transfer an NFT - nft is locked." ,] } , Self :: InvalidNFTTransferSenderIdMatchesReceiverId => { & ["The sender identity can't be the same as the receiver identity." ,] } , Self :: InvalidNFTTransferInvalidReceiverCDD => { & ["The receiver has an invalid CDD." ,] } , Self :: InvalidNFTTransferInvalidSenderCDD => { & ["The sender has an invalid CDD." ,] } , Self :: InvalidAssetId => { & ["There's no asset associated to the given asset_id." ,] } , Self :: NFTIsLocked => { & ["The NFT is locked." ,] } , Self :: NumberOfKeysIsLessThanExpected => { & ["The number of keys in the collection is greater than the input." ,] } , _ => & [""] , }
                }
            }
            impl From<NftError> for &'static str {
                fn from(v: NftError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&NftError> for &'static str {
                fn from(v: &NftError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum NftEvent {
                #[doc = "Emitted when a new nft collection is created."]
                #[codec(index = 0u8)]
                NftCollectionCreated(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::nft::NFTCollectionId,
                ),
                #[doc = "Emitted when NFTs were issued, redeemed or transferred."]
                #[doc = "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`NFTs`], the [`PortfolioId`] of the source, the [`PortfolioId`]"]
                #[doc = "of the destination and the [`PortfolioUpdateReason`]."]
                #[codec(index = 1u8)]
                NFTPortfolioUpdated(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::nft::NFTs,
                    Option<polymesh_primitives::identity_id::PortfolioId>,
                    Option<polymesh_primitives::identity_id::PortfolioId>,
                    polymesh_primitives::portfolio::PortfolioUpdateReason,
                ),
            }
            impl NftEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::NftCollectionCreated(_, _, _) => "Nft.NftCollectionCreated",
                        Self::NFTPortfolioUpdated(_, _, _, _, _) => "Nft.NFTPortfolioUpdated",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for NftEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: NftCollectionCreated (_ , _ , _) => { & ["Emitted when a new nft collection is created." ,] } , Self :: NFTPortfolioUpdated (_ , _ , _ , _ , _) => { & ["Emitted when NFTs were issued, redeemed or transferred." , "Contains the [`IdentityId`] of the receiver/issuer/redeemer, the [`NFTs`], the [`PortfolioId`] of the source, the [`PortfolioId`]" , "of the destination and the [`PortfolioUpdateReason`]." ,] } , _ => & [""] , }
                }
            }
            impl From<NftEvent> for &'static str {
                fn from(v: NftEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&NftEvent> for &'static str {
                fn from(v: &NftEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_offences {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Events type."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum OffencesEvent {
                #[doc = "There is an offence reported of the given `kind` happened at the `session_index` and"]
                #[doc = "(kind-specific) time slot. This event is not deposited for duplicate slashes."]
                #[doc = "\\[kind, timeslot\\]."]
                #[codec(index = 0u8)]
                Offence {
                    kind: [u8; 16usize],
                    timeslot: ::alloc::vec::Vec<u8>,
                },
            }
            impl OffencesEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Offence { .. } => "Offences.Offence",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for OffencesEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: Offence { .. } => { & ["There is an offence reported of the given `kind` happened at the `session_index` and" , "(kind-specific) time slot. This event is not deposited for duplicate slashes." , "\\[kind, timeslot\\]." ,] } , _ => & [""] , }
                }
            }
            impl From<OffencesEvent> for &'static str {
                fn from(v: OffencesEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&OffencesEvent> for &'static str {
                fn from(v: &OffencesEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_permissions {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PermissionsError {
                #[doc = "The caller is not authorized to call the current extrinsic."]
                #[codec(index = 0u8)]
                UnauthorizedCaller,
            }
            impl PermissionsError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::UnauthorizedCaller => "Permissions.UnauthorizedCaller",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PermissionsError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::UnauthorizedCaller => {
                            &["The caller is not authorized to call the current extrinsic."]
                        }
                        _ => &[""],
                    }
                }
            }
            impl From<PermissionsError> for &'static str {
                fn from(v: PermissionsError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PermissionsError> for &'static str {
                fn from(v: &PermissionsError) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct StoreCallMetadata();
    }
    pub mod pallet_pips {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PipsCall {
                #[doc = "Sets the pruning setting for historical PIPs. This function can only be called by the root origin."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be the root."]
                #[doc = "* `prune` - A boolean flag indicating whether completed PIPs should be pruned (`true`) or retained (`false`)."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `HistoricalPipsPruned` - Emitted when the pruning setting is changed, containing the old and new values."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
                #[codec(index = 0u8)]
                set_prune_historical_pips { prune: bool },
                #[doc = "Changes the minimum proposal deposit amount required to start a proposal. This function can only be called by the root origin."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be the root."]
                #[doc = "* `deposit` - The new minimum deposit required to start a proposal."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `MinimumProposalDepositChanged` - Emitted when the minimum proposal deposit is changed, containing the old and new values."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
                #[codec(index = 1u8)]
                set_min_proposal_deposit { deposit: u128 },
                #[doc = "Changes the default enactment period. This function can only be called by the root origin."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be the root."]
                #[doc = "* `period` - The new default enactment period."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `DefaultEnactmentPeriodChanged` - Emitted when the default enactment period is changed, containing the old and new values."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
                #[codec(index = 2u8)]
                set_default_enactment_period { duration: u32 },
                #[doc = "Sets the expiry duration (in blocks) for pending PIPs. This function can only be called by the root origin."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be the root."]
                #[doc = "* `expiry` - The new expiry duration for pending PIPs. If `None`, PIPs never expire."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `PendingPipExpiryChanged` - Emitted when the pending PIP expiry duration is changed, containing the old and new values."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
                #[codec(index = 3u8)]
                set_pending_pip_expiry {
                    expiry: polymesh_primitives::MaybeBlock<u32>,
                },
                #[doc = "Sets the maximum number of times a PIP can be skipped. This function can only be called by the root origin."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be the root."]
                #[doc = "* `max` - The new maximum skip count for PIPs."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `MaxPipSkipCountChanged` - Emitted when the maximum PIP skip count is changed, containing the old and new values."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
                #[codec(index = 4u8)]
                set_max_pip_skip_count { max: u8 },
                #[doc = "Sets the limit on the number of active PIPs. This function can only be called by the root origin."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be the root."]
                #[doc = "* `limit` - The new limit on the number of active PIPs."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `ActivePipLimitChanged` - Emitted when the active PIP limit is changed, containing the old and new values."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
                #[codec(index = 5u8)]
                set_active_pip_limit { limit: u32 },
                #[doc = "Proposes a new PIP by submitting a dispatchable which changes the network."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call."]
                #[doc = "* `proposal` - The dispatchable call."]
                #[doc = "* `deposit` - The deposit amount for the proposal."]
                #[doc = "* `url` - A link to a website for proposal discussion."]
                #[doc = "* `description` - A short description of the proposal."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `ProposalCreated`."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `IncorrectDeposit` - If the deposit amount is less than the required minimum."]
                #[doc = "* `TooManyActivePips` - If the number of active PIPs exceeds the maximum."]
                #[codec(index = 6u8)]
                propose {
                    proposal: ::alloc::boxed::Box<runtime::RuntimeCall>,
                    deposit: u128,
                    url: Option<polymesh_primitives::Url>,
                    description: Option<pallet_pips::types::PipDescription>,
                },
                #[doc = "Casts a vote either in favor or against a PIP with `id`."]
                #[doc = "The \"conviction\" or strength of the vote is given by `deposit`, which is reserved."]
                #[doc = ""]
                #[doc = "Note that `vote` is *not* additive."]
                #[doc = "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`"]
                #[doc = "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit."]
                #[doc = "To add atop of existing votes, you'll need `existing_deposit + addition`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call."]
                #[doc = "* `id` - The proposal ID to vote on."]
                #[doc = "* `aye_or_nay` - A boolean representing a vote in favor (`true`) or against (`false`)."]
                #[doc = "* `deposit` - The \"conviction\" or strength of the vote, represented by the amount of deposit."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `Voted` - Emitted when a vote is successfully cast."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `NoSuchProposal` - If the `id` does not reference a valid PIP."]
                #[doc = "* `NotFromCommunity` - If the proposal was made by a committee."]
                #[doc = "* `IncorrectProposalState` - If the PIP is not in a pending state."]
                #[doc = "* `InsufficientDeposit` - If the `origin` cannot reserve the required deposit."]
                #[doc = "* `IncorrectDeposit` - If the deposit amount is less than the required minimum."]
                #[codec(index = 7u8)]
                vote {
                    id: pallet_pips::types::PipId,
                    aye_or_nay: bool,
                    deposit: u128,
                },
                #[doc = "Approves the pending committee PIP given by the `id`."]
                #[doc = ""]
                #[doc = "This function can only be called by a Governance Committee (GC) voting majority."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
                #[doc = "* `id` - The proposal ID of the PIP to be approved."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
                #[doc = "* `NoSuchProposal` - If the PIP with the given `id` does not exist."]
                #[doc = "* `IncorrectProposalState` - If the proposal is not in a pending state."]
                #[doc = "* `NotByCommittee` - If the proposal was not made by a committee."]
                #[doc = ""]
                #[doc = "# Notes"]
                #[doc = "This function schedules the PIP for execution if all checks pass."]
                #[codec(index = 8u8)]
                approve_committee_proposal { id: pallet_pips::types::PipId },
                #[doc = "Rejects the PIP given by the `id`. Bonded funds will be refunded, assuming it hasn't"]
                #[doc = "been cancelled or executed."]
                #[doc = ""]
                #[doc = "This function can only be called by a Governance Committee (GC) voting majority."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
                #[doc = "* `id` - The proposal ID of the PIP to be rejected."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
                #[doc = "* `NoSuchProposal` - If the PIP with the given `id` does not exist."]
                #[doc = "* `IncorrectProposalState` - If the proposal was cancelled or executed."]
                #[doc = ""]
                #[doc = "# Notes"]
                #[doc = "This function will unschedule the PIP if it was scheduled for execution and will"]
                #[doc = "unsnapshot the PIP if it was part of a snapshot. It will also handle the rejection"]
                #[doc = "of the proposal and refund any bonded funds."]
                #[codec(index = 9u8)]
                reject_proposal { id: pallet_pips::types::PipId },
                #[doc = "Prunes the PIP given by the `id`. The PIP must not be active."]
                #[doc = ""]
                #[doc = "This function is intended for storage garbage collection purposes and can only be called by a Governance Committee (GC) voting majority."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
                #[doc = "* `id` - The proposal ID of the PIP to be pruned."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
                #[doc = "* `NoSuchProposal` - If the PIP with the given `id` does not exist."]
                #[doc = "* `IncorrectProposalState` - If the proposal is active."]
                #[doc = ""]
                #[doc = "# Notes"]
                #[doc = "This function will remove the PIP from storage and refund any remaining bonded funds."]
                #[codec(index = 10u8)]
                prune_proposal { id: pallet_pips::types::PipId },
                #[doc = "Updates the execution schedule of the PIP given by `id`."]
                #[doc = "This function can only be called by the release coordinator."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be the release coordinator."]
                #[doc = "* `id` - The proposal ID of the PIP to be rescheduled."]
                #[doc = "* `until` - An optional future block number where the enactment period will finish."]
                #[doc = "   If `None`, the enactment period will finish in the next block."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `RescheduleNotByReleaseCoordinator` - If the call is not made by the release coordinator."]
                #[doc = "* `IncorrectProposalState` - If the proposal is not in a scheduled state."]
                #[doc = "* `InvalidFutureBlockNumber` - If the provided block number is not a valid future block number."]
                #[codec(index = 11u8)]
                reschedule_execution {
                    id: pallet_pips::types::PipId,
                    until: Option<u32>,
                },
                #[doc = "Clears the snapshot and emits the event `SnapshotCleared`."]
                #[doc = ""]
                #[doc = "This function can only be called by a Governance Committee (GC) member."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be a GC member."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `SnapshotCleared` - Emitted when the snapshot is successfully cleared, containing the ID of the cleared snapshot."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `NotACommitteeMember` - If the call is not made by a GC member."]
                #[codec(index = 12u8)]
                clear_snapshot,
                #[doc = "Takes a new snapshot of the current list of active and pending PIPs."]
                #[doc = "The PIPs are then sorted into a priority queue based on each PIP's weight."]
                #[doc = ""]
                #[doc = "This function can only be called by a Governance Committee (GC) member."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be a GC member."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `SnapshotTaken` - Emitted when a snapshot is successfully taken, containing the ID of the snapshot and the queue of PIPs."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `NotACommitteeMember` - If the call is not made by a GC member."]
                #[codec(index = 13u8)]
                snapshot,
                #[doc = "Enacts the results for the PIPs in the snapshot queue."]
                #[doc = ""]
                #[doc = "The snapshot will be available for further enactments until it is cleared."]
                #[doc = ""]
                #[doc = "The `results` parameter is a list of `(id, result)` tuples where `result` is applied to the PIP with the given `id`."]
                #[doc = "Note that the snapshot priority queue is encoded with the *lowest priority first*."]
                #[doc = "For example, `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
                #[doc = "* `results` - A vector of tuples where each tuple contains a PIP ID and a `SnapshotResult` (either `Approve`, `Reject`, or `Skip`)."]
                #[doc = ""]
                #[doc = "# Events"]
                #[doc = "* `SnapshotResultsEnacted` - Emitted when the snapshot results are successfully enacted, containing the ID of the snapshot and the actions taken."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
                #[doc = "* `CannotSkipPip` - If a given PIP has already been skipped too many times."]
                #[doc = "* `SnapshotResultTooLarge` - If the length of `results` is greater than the length of the snapshot queue."]
                #[doc = "* `SnapshotIdMismatch` - If there is a mismatch between the PIP IDs in `results` and the snapshot queue."]
                #[doc = ""]
                #[doc = "# Notes"]
                #[doc = "This function will:"]
                #[doc = "- Update the skip counts for PIPs that are skipped."]
                #[doc = "- Reject PIPs that are marked for rejection and refund any bonded funds."]
                #[doc = "- Approve PIPs that are marked for approval and schedule them for execution."]
                #[codec(index = 14u8)]
                enact_snapshot_results {
                    results: ::alloc::vec::Vec<(
                        pallet_pips::types::PipId,
                        pallet_pips::types::SnapshotResult,
                    )>,
                },
                #[doc = "Executes a scheduled PIP (Polymesh Improvement Proposal)."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be the root."]
                #[doc = "* `id` - The unique identifier of the PIP to be executed."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
                #[doc = ""]
                #[doc = "# Notes"]
                #[doc = "This function will:"]
                #[doc = "- Remove the PIP from the scheduling queue."]
                #[doc = "- Execute the proposal associated with the PIP."]
                #[codec(index = 15u8)]
                execute_scheduled_pip { id: pallet_pips::types::PipId },
                #[doc = "Expires a scheduled PIP (Polymesh Improvement Proposal)."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, which must be the root."]
                #[doc = "* `did` - The identity ID of the entity initiating the expiration."]
                #[doc = "* `id` - The unique identifier of the PIP to be expired."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
                #[doc = ""]
                #[doc = "# Notes"]
                #[doc = "This function will:"]
                #[doc = "- Check if the PIP is in a pending state."]
                #[doc = "- Unsnapshot the PIP if it was part of a snapshot."]
                #[doc = "- Prune the PIP data if it is in an expired state."]
                #[codec(index = 16u8)]
                expire_scheduled_pip {
                    did: ::polymesh_api_client::IdentityId,
                    id: pallet_pips::types::PipId,
                },
            }
            impl PipsCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::set_prune_historical_pips { .. } => "Pips.set_prune_historical_pips",
                        Self::set_min_proposal_deposit { .. } => "Pips.set_min_proposal_deposit",
                        Self::set_default_enactment_period { .. } => {
                            "Pips.set_default_enactment_period"
                        }
                        Self::set_pending_pip_expiry { .. } => "Pips.set_pending_pip_expiry",
                        Self::set_max_pip_skip_count { .. } => "Pips.set_max_pip_skip_count",
                        Self::set_active_pip_limit { .. } => "Pips.set_active_pip_limit",
                        Self::propose { .. } => "Pips.propose",
                        Self::vote { .. } => "Pips.vote",
                        Self::approve_committee_proposal { .. } => {
                            "Pips.approve_committee_proposal"
                        }
                        Self::reject_proposal { .. } => "Pips.reject_proposal",
                        Self::prune_proposal { .. } => "Pips.prune_proposal",
                        Self::reschedule_execution { .. } => "Pips.reschedule_execution",
                        Self::clear_snapshot => "Pips.clear_snapshot",
                        Self::snapshot => "Pips.snapshot",
                        Self::enact_snapshot_results { .. } => "Pips.enact_snapshot_results",
                        Self::execute_scheduled_pip { .. } => "Pips.execute_scheduled_pip",
                        Self::expire_scheduled_pip { .. } => "Pips.expire_scheduled_pip",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PipsCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: set_prune_historical_pips { .. } => { & ["Sets the pruning setting for historical PIPs. This function can only be called by the root origin." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be the root." , "* `prune` - A boolean flag indicating whether completed PIPs should be pruned (`true`) or retained (`false`)." , "" , "# Events" , "* `HistoricalPipsPruned` - Emitted when the pruning setting is changed, containing the old and new values." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by the root origin." ,] } , Self :: set_min_proposal_deposit { .. } => { & ["Changes the minimum proposal deposit amount required to start a proposal. This function can only be called by the root origin." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be the root." , "* `deposit` - The new minimum deposit required to start a proposal." , "" , "# Events" , "* `MinimumProposalDepositChanged` - Emitted when the minimum proposal deposit is changed, containing the old and new values." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by the root origin." ,] } , Self :: set_default_enactment_period { .. } => { & ["Changes the default enactment period. This function can only be called by the root origin." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be the root." , "* `period` - The new default enactment period." , "" , "# Events" , "* `DefaultEnactmentPeriodChanged` - Emitted when the default enactment period is changed, containing the old and new values." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by the root origin." ,] } , Self :: set_pending_pip_expiry { .. } => { & ["Sets the expiry duration (in blocks) for pending PIPs. This function can only be called by the root origin." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be the root." , "* `expiry` - The new expiry duration for pending PIPs. If `None`, PIPs never expire." , "" , "# Events" , "* `PendingPipExpiryChanged` - Emitted when the pending PIP expiry duration is changed, containing the old and new values." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by the root origin." ,] } , Self :: set_max_pip_skip_count { .. } => { & ["Sets the maximum number of times a PIP can be skipped. This function can only be called by the root origin." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be the root." , "* `max` - The new maximum skip count for PIPs." , "" , "# Events" , "* `MaxPipSkipCountChanged` - Emitted when the maximum PIP skip count is changed, containing the old and new values." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by the root origin." ,] } , Self :: set_active_pip_limit { .. } => { & ["Sets the limit on the number of active PIPs. This function can only be called by the root origin." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be the root." , "* `limit` - The new limit on the number of active PIPs." , "" , "# Events" , "* `ActivePipLimitChanged` - Emitted when the active PIP limit is changed, containing the old and new values." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by the root origin." ,] } , Self :: propose { .. } => { & ["Proposes a new PIP by submitting a dispatchable which changes the network." , "" , "# Arguments" , "* `origin` - The origin of the call." , "* `proposal` - The dispatchable call." , "* `deposit` - The deposit amount for the proposal." , "* `url` - A link to a website for proposal discussion." , "* `description` - A short description of the proposal." , "" , "# Events" , "* `ProposalCreated`." , "" , "# Errors" , "* `IncorrectDeposit` - If the deposit amount is less than the required minimum." , "* `TooManyActivePips` - If the number of active PIPs exceeds the maximum." ,] } , Self :: vote { .. } => { & ["Casts a vote either in favor or against a PIP with `id`." , "The \"conviction\" or strength of the vote is given by `deposit`, which is reserved." , "" , "Note that `vote` is *not* additive." , "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`" , "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit." , "To add atop of existing votes, you'll need `existing_deposit + addition`." , "" , "# Arguments" , "* `origin` - The origin of the call." , "* `id` - The proposal ID to vote on." , "* `aye_or_nay` - A boolean representing a vote in favor (`true`) or against (`false`)." , "* `deposit` - The \"conviction\" or strength of the vote, represented by the amount of deposit." , "" , "# Events" , "* `Voted` - Emitted when a vote is successfully cast." , "" , "# Errors" , "* `NoSuchProposal` - If the `id` does not reference a valid PIP." , "* `NotFromCommunity` - If the proposal was made by a committee." , "* `IncorrectProposalState` - If the PIP is not in a pending state." , "* `InsufficientDeposit` - If the `origin` cannot reserve the required deposit." , "* `IncorrectDeposit` - If the deposit amount is less than the required minimum." ,] } , Self :: approve_committee_proposal { .. } => { & ["Approves the pending committee PIP given by the `id`." , "" , "This function can only be called by a Governance Committee (GC) voting majority." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be a GC voting majority." , "* `id` - The proposal ID of the PIP to be approved." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by a GC voting majority." , "* `NoSuchProposal` - If the PIP with the given `id` does not exist." , "* `IncorrectProposalState` - If the proposal is not in a pending state." , "* `NotByCommittee` - If the proposal was not made by a committee." , "" , "# Notes" , "This function schedules the PIP for execution if all checks pass." ,] } , Self :: reject_proposal { .. } => { & ["Rejects the PIP given by the `id`. Bonded funds will be refunded, assuming it hasn't" , "been cancelled or executed." , "" , "This function can only be called by a Governance Committee (GC) voting majority." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be a GC voting majority." , "* `id` - The proposal ID of the PIP to be rejected." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by a GC voting majority." , "* `NoSuchProposal` - If the PIP with the given `id` does not exist." , "* `IncorrectProposalState` - If the proposal was cancelled or executed." , "" , "# Notes" , "This function will unschedule the PIP if it was scheduled for execution and will" , "unsnapshot the PIP if it was part of a snapshot. It will also handle the rejection" , "of the proposal and refund any bonded funds." ,] } , Self :: prune_proposal { .. } => { & ["Prunes the PIP given by the `id`. The PIP must not be active." , "" , "This function is intended for storage garbage collection purposes and can only be called by a Governance Committee (GC) voting majority." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be a GC voting majority." , "* `id` - The proposal ID of the PIP to be pruned." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by a GC voting majority." , "* `NoSuchProposal` - If the PIP with the given `id` does not exist." , "* `IncorrectProposalState` - If the proposal is active." , "" , "# Notes" , "This function will remove the PIP from storage and refund any remaining bonded funds." ,] } , Self :: reschedule_execution { .. } => { & ["Updates the execution schedule of the PIP given by `id`." , "This function can only be called by the release coordinator." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be the release coordinator." , "* `id` - The proposal ID of the PIP to be rescheduled." , "* `until` - An optional future block number where the enactment period will finish." , "   If `None`, the enactment period will finish in the next block." , "" , "# Errors" , "* `RescheduleNotByReleaseCoordinator` - If the call is not made by the release coordinator." , "* `IncorrectProposalState` - If the proposal is not in a scheduled state." , "* `InvalidFutureBlockNumber` - If the provided block number is not a valid future block number." ,] } , Self :: clear_snapshot => { & ["Clears the snapshot and emits the event `SnapshotCleared`." , "" , "This function can only be called by a Governance Committee (GC) member." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be a GC member." , "" , "# Events" , "* `SnapshotCleared` - Emitted when the snapshot is successfully cleared, containing the ID of the cleared snapshot." , "" , "# Errors" , "* `NotACommitteeMember` - If the call is not made by a GC member." ,] } , Self :: snapshot => { & ["Takes a new snapshot of the current list of active and pending PIPs." , "The PIPs are then sorted into a priority queue based on each PIP's weight." , "" , "This function can only be called by a Governance Committee (GC) member." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be a GC member." , "" , "# Events" , "* `SnapshotTaken` - Emitted when a snapshot is successfully taken, containing the ID of the snapshot and the queue of PIPs." , "" , "# Errors" , "* `NotACommitteeMember` - If the call is not made by a GC member." ,] } , Self :: enact_snapshot_results { .. } => { & ["Enacts the results for the PIPs in the snapshot queue." , "" , "The snapshot will be available for further enactments until it is cleared." , "" , "The `results` parameter is a list of `(id, result)` tuples where `result` is applied to the PIP with the given `id`." , "Note that the snapshot priority queue is encoded with the *lowest priority first*." , "For example, `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be a GC voting majority." , "* `results` - A vector of tuples where each tuple contains a PIP ID and a `SnapshotResult` (either `Approve`, `Reject`, or `Skip`)." , "" , "# Events" , "* `SnapshotResultsEnacted` - Emitted when the snapshot results are successfully enacted, containing the ID of the snapshot and the actions taken." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by a GC voting majority." , "* `CannotSkipPip` - If a given PIP has already been skipped too many times." , "* `SnapshotResultTooLarge` - If the length of `results` is greater than the length of the snapshot queue." , "* `SnapshotIdMismatch` - If there is a mismatch between the PIP IDs in `results` and the snapshot queue." , "" , "# Notes" , "This function will:" , "- Update the skip counts for PIPs that are skipped." , "- Reject PIPs that are marked for rejection and refund any bonded funds." , "- Approve PIPs that are marked for approval and schedule them for execution." ,] } , Self :: execute_scheduled_pip { .. } => { & ["Executes a scheduled PIP (Polymesh Improvement Proposal)." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be the root." , "* `id` - The unique identifier of the PIP to be executed." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by the root origin." , "" , "# Notes" , "This function will:" , "- Remove the PIP from the scheduling queue." , "- Execute the proposal associated with the PIP." ,] } , Self :: expire_scheduled_pip { .. } => { & ["Expires a scheduled PIP (Polymesh Improvement Proposal)." , "" , "# Arguments" , "* `origin` - The origin of the call, which must be the root." , "* `did` - The identity ID of the entity initiating the expiration." , "* `id` - The unique identifier of the PIP to be expired." , "" , "# Errors" , "* `BadOrigin` - If the call is not made by the root origin." , "" , "# Notes" , "This function will:" , "- Check if the PIP is in a pending state." , "- Unsnapshot the PIP if it was part of a snapshot." , "- Prune the PIP data if it is in an expired state." ,] } , _ => & [""] , }
                }
            }
            impl From<PipsCall> for &'static str {
                fn from(v: PipsCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PipsCall> for &'static str {
                fn from(v: &PipsCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PipsError {
                #[doc = "Only the GC release coordinator is allowed to reschedule proposal execution."]
                #[codec(index = 0u8)]
                RescheduleNotByReleaseCoordinator,
                #[doc = "The given dispatchable call is not valid for this proposal."]
                #[doc = "The proposal must be from the community, but isn't."]
                #[codec(index = 1u8)]
                NotFromCommunity,
                #[doc = "The given dispatchable call is not valid for this proposal."]
                #[doc = "The proposal must be from a committee, but isn't."]
                #[codec(index = 2u8)]
                NotByCommittee,
                #[doc = "The current number of active (pending or scheduled) PIPs exceeds the maximum"]
                #[doc = "and the proposal is not by a committee."]
                #[codec(index = 3u8)]
                TooManyActivePips,
                #[doc = "Proposer specifies an incorrect deposit amount."]
                #[codec(index = 4u8)]
                IncorrectDeposit,
                #[doc = "Proposer cannot afford to lock the minimum deposit."]
                #[codec(index = 5u8)]
                InsufficientDeposit,
                #[doc = "The proposal does not exist."]
                #[codec(index = 6u8)]
                NoSuchProposal,
                #[doc = "The caller is not a member of the governance committee."]
                #[codec(index = 7u8)]
                NotACommitteeMember,
                #[doc = "The specified block number is less than the current block number."]
                #[codec(index = 8u8)]
                InvalidFutureBlockNumber,
                #[doc = "The number of votes exceeds the allowed limit."]
                #[codec(index = 9u8)]
                NumberOfVotesExceeded,
                #[doc = "The stake amount of a vote exceeds the allowed limit."]
                #[codec(index = 10u8)]
                StakeAmountOfVotesExceeded,
                #[doc = "The current DID is missing."]
                #[codec(index = 11u8)]
                MissingCurrentIdentity,
                #[doc = "The proposal is not in the correct state for the requested operation."]
                #[codec(index = 12u8)]
                IncorrectProposalState,
                #[doc = "When enacting snapshot results, an unskippable PIP was skipped."]
                #[codec(index = 13u8)]
                CannotSkipPip,
                #[doc = "Tried to enact results for the snapshot queue overflowing its length."]
                #[codec(index = 14u8)]
                SnapshotResultTooLarge,
                #[doc = "Tried to enact result for PIP with an ID different from that at the position in the queue."]
                #[codec(index = 15u8)]
                SnapshotIdMismatch,
                #[doc = "Execution of a scheduled proposal failed because it is missing."]
                #[codec(index = 16u8)]
                ScheduledProposalDoesntExist,
                #[doc = "A proposal that is not in a scheduled state cannot be executed."]
                #[codec(index = 17u8)]
                ProposalNotInScheduledState,
                #[doc = "Invalid PIP ID. Pip id was not expected to be in the live queue."]
                #[codec(index = 18u8)]
                InvalidPipId,
                #[doc = "TaskName cannot exceed 32 bytes."]
                #[codec(index = 19u8)]
                InvalidTaskName,
            }
            impl PipsError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::RescheduleNotByReleaseCoordinator => {
                            "Pips.RescheduleNotByReleaseCoordinator"
                        }
                        Self::NotFromCommunity => "Pips.NotFromCommunity",
                        Self::NotByCommittee => "Pips.NotByCommittee",
                        Self::TooManyActivePips => "Pips.TooManyActivePips",
                        Self::IncorrectDeposit => "Pips.IncorrectDeposit",
                        Self::InsufficientDeposit => "Pips.InsufficientDeposit",
                        Self::NoSuchProposal => "Pips.NoSuchProposal",
                        Self::NotACommitteeMember => "Pips.NotACommitteeMember",
                        Self::InvalidFutureBlockNumber => "Pips.InvalidFutureBlockNumber",
                        Self::NumberOfVotesExceeded => "Pips.NumberOfVotesExceeded",
                        Self::StakeAmountOfVotesExceeded => "Pips.StakeAmountOfVotesExceeded",
                        Self::MissingCurrentIdentity => "Pips.MissingCurrentIdentity",
                        Self::IncorrectProposalState => "Pips.IncorrectProposalState",
                        Self::CannotSkipPip => "Pips.CannotSkipPip",
                        Self::SnapshotResultTooLarge => "Pips.SnapshotResultTooLarge",
                        Self::SnapshotIdMismatch => "Pips.SnapshotIdMismatch",
                        Self::ScheduledProposalDoesntExist => "Pips.ScheduledProposalDoesntExist",
                        Self::ProposalNotInScheduledState => "Pips.ProposalNotInScheduledState",
                        Self::InvalidPipId => "Pips.InvalidPipId",
                        Self::InvalidTaskName => "Pips.InvalidTaskName",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PipsError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: RescheduleNotByReleaseCoordinator => { & ["Only the GC release coordinator is allowed to reschedule proposal execution." ,] } , Self :: NotFromCommunity => { & ["The given dispatchable call is not valid for this proposal." , "The proposal must be from the community, but isn't." ,] } , Self :: NotByCommittee => { & ["The given dispatchable call is not valid for this proposal." , "The proposal must be from a committee, but isn't." ,] } , Self :: TooManyActivePips => { & ["The current number of active (pending or scheduled) PIPs exceeds the maximum" , "and the proposal is not by a committee." ,] } , Self :: IncorrectDeposit => { & ["Proposer specifies an incorrect deposit amount." ,] } , Self :: InsufficientDeposit => { & ["Proposer cannot afford to lock the minimum deposit." ,] } , Self :: NoSuchProposal => { & ["The proposal does not exist." ,] } , Self :: NotACommitteeMember => { & ["The caller is not a member of the governance committee." ,] } , Self :: InvalidFutureBlockNumber => { & ["The specified block number is less than the current block number." ,] } , Self :: NumberOfVotesExceeded => { & ["The number of votes exceeds the allowed limit." ,] } , Self :: StakeAmountOfVotesExceeded => { & ["The stake amount of a vote exceeds the allowed limit." ,] } , Self :: MissingCurrentIdentity => { & ["The current DID is missing." ,] } , Self :: IncorrectProposalState => { & ["The proposal is not in the correct state for the requested operation." ,] } , Self :: CannotSkipPip => { & ["When enacting snapshot results, an unskippable PIP was skipped." ,] } , Self :: SnapshotResultTooLarge => { & ["Tried to enact results for the snapshot queue overflowing its length." ,] } , Self :: SnapshotIdMismatch => { & ["Tried to enact result for PIP with an ID different from that at the position in the queue." ,] } , Self :: ScheduledProposalDoesntExist => { & ["Execution of a scheduled proposal failed because it is missing." ,] } , Self :: ProposalNotInScheduledState => { & ["A proposal that is not in a scheduled state cannot be executed." ,] } , Self :: InvalidPipId => { & ["Invalid PIP ID. Pip id was not expected to be in the live queue." ,] } , Self :: InvalidTaskName => { & ["TaskName cannot exceed 32 bytes." ,] } , _ => & [""] , }
                }
            }
            impl From<PipsError> for &'static str {
                fn from(v: PipsError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PipsError> for &'static str {
                fn from(v: &PipsError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PipsEvent {
                #[doc = "Historical PIPs Pruning has been set."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `bool`: The old value of the pruning setting."]
                #[doc = "- `bool`: The new value of the pruning setting."]
                #[codec(index = 0u8)]
                HistoricalPipsPruned(::polymesh_api_client::IdentityId, bool, bool),
                #[doc = "A PIP was created with a specified `Balance` stake."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `Proposer<T::AccountId>`: The proposer of the PIP."]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[doc = "- `Balance`: The deposit amount."]
                #[doc = "- `Option<Url>`: The URL for proposal discussion."]
                #[doc = "- `Option<PipDescription>`: The description of the proposal."]
                #[doc = "- `MaybeBlock<T::BlockNumber>`: The expiry time of the proposal."]
                #[doc = "- `ProposalData`: The data of the proposal."]
                #[codec(index = 1u8)]
                ProposalCreated(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::Proposer<::polymesh_api_client::AccountId>,
                    pallet_pips::types::PipId,
                    u128,
                    Option<polymesh_primitives::Url>,
                    Option<pallet_pips::types::PipDescription>,
                    polymesh_primitives::MaybeBlock<u32>,
                    pallet_pips::types::ProposalData,
                ),
                #[doc = "The state of a proposal was updated."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[doc = "- `ProposalState`: The new state of the proposal."]
                #[codec(index = 2u8)]
                ProposalStateUpdated(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::PipId,
                    pallet_pips::types::ProposalState,
                ),
                #[doc = "An account voted on a proposal."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `T::AccountId`: The account that voted."]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[doc = "- `bool`: The vote (true for aye, false for nay)."]
                #[doc = "- `Balance`: The deposit amount of the vote."]
                #[codec(index = 3u8)]
                Voted(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AccountId,
                    pallet_pips::types::PipId,
                    bool,
                    u128,
                ),
                #[doc = "A PIP was closed."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[doc = "- `bool`: Indicates whether the data was pruned."]
                #[codec(index = 4u8)]
                PipClosed(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::PipId,
                    bool,
                ),
                #[doc = "The execution of a PIP was scheduled."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[doc = "- `BlockNumber`: The block number at which the PIP is scheduled for execution."]
                #[codec(index = 5u8)]
                ExecutionScheduled(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::PipId,
                    u32,
                ),
                #[doc = "The default enactment period was changed."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `BlockNumber`: The old enactment period."]
                #[doc = "- `BlockNumber`: The new enactment period."]
                #[codec(index = 6u8)]
                DefaultEnactmentPeriodChanged(::polymesh_api_client::IdentityId, u32, u32),
                #[doc = "The minimum deposit amount for proposals was changed."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `Balance`: The old deposit amount."]
                #[doc = "- `Balance`: The new deposit amount."]
                #[codec(index = 7u8)]
                MinimumProposalDepositChanged(::polymesh_api_client::IdentityId, u128, u128),
                #[doc = "The expiry time for pending PIPs was changed."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `MaybeBlock<T::BlockNumber>`: The old expiry time."]
                #[doc = "- `MaybeBlock<T::BlockNumber>`: The new expiry time."]
                #[codec(index = 8u8)]
                PendingPipExpiryChanged(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::MaybeBlock<u32>,
                    polymesh_primitives::MaybeBlock<u32>,
                ),
                #[doc = "The maximum number of times a PIP can be skipped was changed."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `SkippedCount`: The old skip count."]
                #[doc = "- `SkippedCount`: The new skip count."]
                #[codec(index = 9u8)]
                MaxPipSkipCountChanged(::polymesh_api_client::IdentityId, u8, u8),
                #[doc = "The maximum number of active PIPs was changed."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `u32`: The old active PIP limit."]
                #[doc = "- `u32`: The new active PIP limit."]
                #[codec(index = 10u8)]
                ActivePipLimitChanged(::polymesh_api_client::IdentityId, u32, u32),
                #[doc = "A proposal was refunded."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[doc = "- `Balance`: The total amount refunded."]
                #[codec(index = 11u8)]
                ProposalRefund(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::PipId,
                    u128,
                ),
                #[doc = "The snapshot was cleared."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `SnapshotId`: The ID of the snapshot."]
                #[codec(index = 12u8)]
                SnapshotCleared(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::SnapshotId,
                ),
                #[doc = "A new snapshot was taken."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `SnapshotId`: The ID of the snapshot."]
                #[doc = "- `Vec<SnapshottedPip>`: The list of PIPs in the snapshot."]
                #[codec(index = 13u8)]
                SnapshotTaken(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::SnapshotId,
                    ::alloc::vec::Vec<pallet_pips::types::SnapshottedPip>,
                ),
                #[doc = "A PIP in the snapshot queue was skipped."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[doc = "- `SkippedCount`: The new skip count."]
                #[codec(index = 14u8)]
                PipSkipped(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::PipId,
                    u8,
                ),
                #[doc = "Results were enacted for some PIPs in the snapshot queue."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `Option<SnapshotId>`: The ID of the snapshot, if any."]
                #[doc = "- `Vec<(PipId, SkippedCount)>`: The list of skipped PIPs with their new skip counts."]
                #[doc = "- `Vec<PipId>`: The list of rejected PIPs."]
                #[doc = "- `Vec<PipId>`: The list of approved PIPs."]
                #[codec(index = 15u8)]
                SnapshotResultsEnacted(
                    ::polymesh_api_client::IdentityId,
                    Option<pallet_pips::types::SnapshotId>,
                    ::alloc::vec::Vec<(pallet_pips::types::PipId, u8)>,
                    ::alloc::vec::Vec<pallet_pips::types::PipId>,
                    ::alloc::vec::Vec<pallet_pips::types::PipId>,
                ),
                #[doc = "Scheduling of the PIP for execution failed in the scheduler pallet."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[doc = "- `BlockNumber`: The block number at which the PIP was scheduled for execution."]
                #[codec(index = 16u8)]
                ExecutionSchedulingFailed(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::PipId,
                    u32,
                ),
                #[doc = "The PIP has been scheduled for expiry."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[doc = "- `BlockNumber`: The block number at which the PIP is scheduled for expiry."]
                #[codec(index = 17u8)]
                ExpiryScheduled(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::PipId,
                    u32,
                ),
                #[doc = "Scheduling of the PIP for expiry failed in the scheduler pallet."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The DID of the caller."]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[doc = "- `BlockNumber`: The block number at which the PIP was scheduled for expiry."]
                #[codec(index = 18u8)]
                ExpirySchedulingFailed(
                    ::polymesh_api_client::IdentityId,
                    pallet_pips::types::PipId,
                    u32,
                ),
                #[doc = "Cancelling the PIP execution failed in the scheduler pallet."]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `PipId`: The ID of the PIP."]
                #[codec(index = 19u8)]
                ExecutionCancellingFailed(pallet_pips::types::PipId),
            }
            impl PipsEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::HistoricalPipsPruned(_, _, _) => "Pips.HistoricalPipsPruned",
                        Self::ProposalCreated(_, _, _, _, _, _, _, _) => "Pips.ProposalCreated",
                        Self::ProposalStateUpdated(_, _, _) => "Pips.ProposalStateUpdated",
                        Self::Voted(_, _, _, _, _) => "Pips.Voted",
                        Self::PipClosed(_, _, _) => "Pips.PipClosed",
                        Self::ExecutionScheduled(_, _, _) => "Pips.ExecutionScheduled",
                        Self::DefaultEnactmentPeriodChanged(_, _, _) => {
                            "Pips.DefaultEnactmentPeriodChanged"
                        }
                        Self::MinimumProposalDepositChanged(_, _, _) => {
                            "Pips.MinimumProposalDepositChanged"
                        }
                        Self::PendingPipExpiryChanged(_, _, _) => "Pips.PendingPipExpiryChanged",
                        Self::MaxPipSkipCountChanged(_, _, _) => "Pips.MaxPipSkipCountChanged",
                        Self::ActivePipLimitChanged(_, _, _) => "Pips.ActivePipLimitChanged",
                        Self::ProposalRefund(_, _, _) => "Pips.ProposalRefund",
                        Self::SnapshotCleared(_, _) => "Pips.SnapshotCleared",
                        Self::SnapshotTaken(_, _, _) => "Pips.SnapshotTaken",
                        Self::PipSkipped(_, _, _) => "Pips.PipSkipped",
                        Self::SnapshotResultsEnacted(_, _, _, _, _) => {
                            "Pips.SnapshotResultsEnacted"
                        }
                        Self::ExecutionSchedulingFailed(_, _, _) => {
                            "Pips.ExecutionSchedulingFailed"
                        }
                        Self::ExpiryScheduled(_, _, _) => "Pips.ExpiryScheduled",
                        Self::ExpirySchedulingFailed(_, _, _) => "Pips.ExpirySchedulingFailed",
                        Self::ExecutionCancellingFailed(_) => "Pips.ExecutionCancellingFailed",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PipsEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: HistoricalPipsPruned (_ , _ , _) => { & ["Historical PIPs Pruning has been set." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `bool`: The old value of the pruning setting." , "- `bool`: The new value of the pruning setting." ,] } , Self :: ProposalCreated (_ , _ , _ , _ , _ , _ , _ , _) => { & ["A PIP was created with a specified `Balance` stake." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `Proposer<T::AccountId>`: The proposer of the PIP." , "- `PipId`: The ID of the PIP." , "- `Balance`: The deposit amount." , "- `Option<Url>`: The URL for proposal discussion." , "- `Option<PipDescription>`: The description of the proposal." , "- `MaybeBlock<T::BlockNumber>`: The expiry time of the proposal." , "- `ProposalData`: The data of the proposal." ,] } , Self :: ProposalStateUpdated (_ , _ , _) => { & ["The state of a proposal was updated." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `PipId`: The ID of the PIP." , "- `ProposalState`: The new state of the proposal." ,] } , Self :: Voted (_ , _ , _ , _ , _) => { & ["An account voted on a proposal." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `T::AccountId`: The account that voted." , "- `PipId`: The ID of the PIP." , "- `bool`: The vote (true for aye, false for nay)." , "- `Balance`: The deposit amount of the vote." ,] } , Self :: PipClosed (_ , _ , _) => { & ["A PIP was closed." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `PipId`: The ID of the PIP." , "- `bool`: Indicates whether the data was pruned." ,] } , Self :: ExecutionScheduled (_ , _ , _) => { & ["The execution of a PIP was scheduled." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `PipId`: The ID of the PIP." , "- `BlockNumber`: The block number at which the PIP is scheduled for execution." ,] } , Self :: DefaultEnactmentPeriodChanged (_ , _ , _) => { & ["The default enactment period was changed." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `BlockNumber`: The old enactment period." , "- `BlockNumber`: The new enactment period." ,] } , Self :: MinimumProposalDepositChanged (_ , _ , _) => { & ["The minimum deposit amount for proposals was changed." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `Balance`: The old deposit amount." , "- `Balance`: The new deposit amount." ,] } , Self :: PendingPipExpiryChanged (_ , _ , _) => { & ["The expiry time for pending PIPs was changed." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `MaybeBlock<T::BlockNumber>`: The old expiry time." , "- `MaybeBlock<T::BlockNumber>`: The new expiry time." ,] } , Self :: MaxPipSkipCountChanged (_ , _ , _) => { & ["The maximum number of times a PIP can be skipped was changed." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `SkippedCount`: The old skip count." , "- `SkippedCount`: The new skip count." ,] } , Self :: ActivePipLimitChanged (_ , _ , _) => { & ["The maximum number of active PIPs was changed." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `u32`: The old active PIP limit." , "- `u32`: The new active PIP limit." ,] } , Self :: ProposalRefund (_ , _ , _) => { & ["A proposal was refunded." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `PipId`: The ID of the PIP." , "- `Balance`: The total amount refunded." ,] } , Self :: SnapshotCleared (_ , _) => { & ["The snapshot was cleared." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `SnapshotId`: The ID of the snapshot." ,] } , Self :: SnapshotTaken (_ , _ , _) => { & ["A new snapshot was taken." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `SnapshotId`: The ID of the snapshot." , "- `Vec<SnapshottedPip>`: The list of PIPs in the snapshot." ,] } , Self :: PipSkipped (_ , _ , _) => { & ["A PIP in the snapshot queue was skipped." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `PipId`: The ID of the PIP." , "- `SkippedCount`: The new skip count." ,] } , Self :: SnapshotResultsEnacted (_ , _ , _ , _ , _) => { & ["Results were enacted for some PIPs in the snapshot queue." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `Option<SnapshotId>`: The ID of the snapshot, if any." , "- `Vec<(PipId, SkippedCount)>`: The list of skipped PIPs with their new skip counts." , "- `Vec<PipId>`: The list of rejected PIPs." , "- `Vec<PipId>`: The list of approved PIPs." ,] } , Self :: ExecutionSchedulingFailed (_ , _ , _) => { & ["Scheduling of the PIP for execution failed in the scheduler pallet." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `PipId`: The ID of the PIP." , "- `BlockNumber`: The block number at which the PIP was scheduled for execution." ,] } , Self :: ExpiryScheduled (_ , _ , _) => { & ["The PIP has been scheduled for expiry." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `PipId`: The ID of the PIP." , "- `BlockNumber`: The block number at which the PIP is scheduled for expiry." ,] } , Self :: ExpirySchedulingFailed (_ , _ , _) => { & ["Scheduling of the PIP for expiry failed in the scheduler pallet." , "" , "Parameters:" , "- `IdentityId`: The DID of the caller." , "- `PipId`: The ID of the PIP." , "- `BlockNumber`: The block number at which the PIP was scheduled for expiry." ,] } , Self :: ExecutionCancellingFailed (_) => { & ["Cancelling the PIP execution failed in the scheduler pallet." , "" , "Parameters:" , "- `PipId`: The ID of the PIP." ,] } , _ => & [""] , }
                }
            }
            impl From<PipsEvent> for &'static str {
                fn from(v: PipsEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PipsEvent> for &'static str {
                fn from(v: &PipsEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        pub mod types {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum Committee {
                #[codec(index = 0u8)]
                Technical,
                #[codec(index = 1u8)]
                Upgrade,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct DepositInfo<AccountId> {
                pub owner: AccountId,
                pub amount: u128,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Pip<Proposal, AccountId> {
                pub id: pallet_pips::types::PipId,
                pub proposal: Proposal,
                pub proposer: pallet_pips::types::Proposer<AccountId>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PipDescription(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PipId(pub u32);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PipsMetadata<BlockNumber> {
                pub id: pallet_pips::types::PipId,
                pub url: Option<polymesh_primitives::Url>,
                pub description: Option<pallet_pips::types::PipDescription>,
                pub created_at: BlockNumber,
                pub transaction_version: BlockNumber,
                pub expiry: polymesh_primitives::MaybeBlock<BlockNumber>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ProposalData {
                #[codec(index = 0u8)]
                Hash(primitive_types::H256),
                #[codec(index = 1u8)]
                Proposal(::alloc::vec::Vec<u8>),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ProposalState {
                #[codec(index = 0u8)]
                Pending,
                #[codec(index = 1u8)]
                Rejected,
                #[codec(index = 2u8)]
                Scheduled,
                #[codec(index = 3u8)]
                Failed,
                #[codec(index = 4u8)]
                Executed,
                #[codec(index = 5u8)]
                Expired,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum Proposer<AccountId> {
                #[codec(index = 0u8)]
                Community(AccountId),
                #[codec(index = 1u8)]
                Committee(pallet_pips::types::Committee),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct SnapshotId(pub u32);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct SnapshotMetadata<BlockNumber, AccountId> {
                pub created_at: BlockNumber,
                pub made_by: AccountId,
                pub id: pallet_pips::types::SnapshotId,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SnapshotResult {
                #[codec(index = 0u8)]
                Approve,
                #[codec(index = 1u8)]
                Reject,
                #[codec(index = 2u8)]
                Skip,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct SnapshottedPip {
                pub id: pallet_pips::types::PipId,
                pub weight: (bool, u128),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Vote(pub bool, pub u128);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct VotingResult {
                pub ayes_count: u32,
                pub ayes_stake: u128,
                pub nays_count: u32,
                pub nays_stake: u128,
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Version(pub u8);
    }
    pub mod pallet_portfolio {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PortfolioCall {
                #[doc = "Creates a portfolio with the given `name`."]
                #[codec(index = 0u8)]
                create_portfolio {
                    name: polymesh_primitives::identity_id::PortfolioName,
                },
                #[doc = "Deletes a user portfolio. A portfolio can be deleted only if it has no funds."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
                #[doc = "* `PortfolioNotEmpty` if the portfolio still holds any asset"]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 1u8)]
                delete_portfolio {
                    num: polymesh_primitives::identity_id::PortfolioNumber,
                },
                #[doc = "Renames a non-default portfolio."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 2u8)]
                rename_portfolio {
                    num: polymesh_primitives::identity_id::PortfolioNumber,
                    to_name: polymesh_primitives::identity_id::PortfolioName,
                },
                #[doc = "When called by the custodian of `portfolio_id`,"]
                #[doc = "allows returning the custody of the portfolio to the portfolio owner unilaterally."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 3u8)]
                quit_portfolio_custody {
                    pid: polymesh_primitives::identity_id::PortfolioId,
                },
                #[codec(index = 4u8)]
                accept_portfolio_custody { auth_id: u64 },
                #[doc = "Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same"]
                #[doc = "identity. Must be called by the custodian of the sender."]
                #[doc = "Funds from deleted portfolios can also be recovered via this method."]
                #[doc = ""]
                #[doc = "A short memo can be added to to each token amount moved."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio."]
                #[doc = "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same"]
                #[doc = "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities"]
                #[doc = "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio"]
                #[doc = "* `InsufficientPortfolioBalance` if the sender does not have enough free balance"]
                #[doc = "* `NoDuplicateAssetsAllowed` the same asset can't be repeated in the items vector."]
                #[doc = "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own."]
                #[doc = "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 5u8)]
                move_portfolio_funds {
                    from: polymesh_primitives::identity_id::PortfolioId,
                    to: polymesh_primitives::identity_id::PortfolioId,
                    funds: ::alloc::vec::Vec<polymesh_primitives::portfolio::Fund>,
                },
                #[doc = "Pre-approves the receivement of an asset to a portfolio."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - the secondary key of the sender."]
                #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
                #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 6u8)]
                pre_approve_portfolio {
                    asset_id: ::polymesh_api_client::AssetId,
                    portfolio_id: polymesh_primitives::identity_id::PortfolioId,
                },
                #[doc = "Removes the pre approval of an asset to a portfolio."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - the secondary key of the sender."]
                #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
                #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 7u8)]
                remove_portfolio_pre_approval {
                    asset_id: ::polymesh_api_client::AssetId,
                    portfolio_id: polymesh_primitives::identity_id::PortfolioId,
                },
                #[doc = "Adds an identity that will be allowed to create and take custody of a portfolio under the caller's identity."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `trusted_identity` - the [`IdentityId`] that will be allowed to call `create_custody_portfolio`."]
                #[doc = ""]
                #[codec(index = 8u8)]
                allow_identity_to_create_portfolios {
                    trusted_identity: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Removes permission of an identity to create and take custody of a portfolio under the caller's identity."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `identity` - the [`IdentityId`] that will have the permissions to call `create_custody_portfolio` revoked."]
                #[doc = ""]
                #[codec(index = 9u8)]
                revoke_create_portfolios_permission {
                    identity: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Creates a portfolio under the `portfolio_owner_id` identity and transfers its custody to the caller's identity."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `portfolio_owner_id` - the [`IdentityId`] that will own the new portfolio."]
                #[doc = "* `portfolio_name` - the [`PortfolioName`] of the new portfolio."]
                #[doc = ""]
                #[codec(index = 10u8)]
                create_custody_portfolio {
                    portfolio_owner_id: ::polymesh_api_client::IdentityId,
                    portfolio_name: polymesh_primitives::identity_id::PortfolioName,
                },
            }
            impl PortfolioCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::create_portfolio { .. } => "Portfolio.create_portfolio",
                        Self::delete_portfolio { .. } => "Portfolio.delete_portfolio",
                        Self::rename_portfolio { .. } => "Portfolio.rename_portfolio",
                        Self::quit_portfolio_custody { .. } => "Portfolio.quit_portfolio_custody",
                        Self::accept_portfolio_custody { .. } => {
                            "Portfolio.accept_portfolio_custody"
                        }
                        Self::move_portfolio_funds { .. } => "Portfolio.move_portfolio_funds",
                        Self::pre_approve_portfolio { .. } => "Portfolio.pre_approve_portfolio",
                        Self::remove_portfolio_pre_approval { .. } => {
                            "Portfolio.remove_portfolio_pre_approval"
                        }
                        Self::allow_identity_to_create_portfolios { .. } => {
                            "Portfolio.allow_identity_to_create_portfolios"
                        }
                        Self::revoke_create_portfolios_permission { .. } => {
                            "Portfolio.revoke_create_portfolios_permission"
                        }
                        Self::create_custody_portfolio { .. } => {
                            "Portfolio.create_custody_portfolio"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PortfolioCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: create_portfolio { .. } => { & ["Creates a portfolio with the given `name`." ,] } , Self :: delete_portfolio { .. } => { & ["Deletes a user portfolio. A portfolio can be deleted only if it has no funds." , "" , "# Errors" , "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio." , "* `PortfolioNotEmpty` if the portfolio still holds any asset" , "" , "# Permissions" , "* Portfolio" ,] } , Self :: rename_portfolio { .. } => { & ["Renames a non-default portfolio." , "" , "# Errors" , "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: quit_portfolio_custody { .. } => { & ["When called by the custodian of `portfolio_id`," , "allows returning the custody of the portfolio to the portfolio owner unilaterally." , "" , "# Errors" , "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: accept_portfolio_custody { .. } => { & ["" ,] } , Self :: move_portfolio_funds { .. } => { & ["Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same" , "identity. Must be called by the custodian of the sender." , "Funds from deleted portfolios can also be recovered via this method." , "" , "A short memo can be added to to each token amount moved." , "" , "# Errors" , "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio." , "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same" , "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities" , "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio" , "* `InsufficientPortfolioBalance` if the sender does not have enough free balance" , "* `NoDuplicateAssetsAllowed` the same asset can't be repeated in the items vector." , "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own." , "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: pre_approve_portfolio { .. } => { & ["Pre-approves the receivement of an asset to a portfolio." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `asset_id` - the [`AssetId`] that will be exempt from affirmation." , "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: remove_portfolio_pre_approval { .. } => { & ["Removes the pre approval of an asset to a portfolio." , "" , "# Arguments" , "* `origin` - the secondary key of the sender." , "* `asset_id` - the [`AssetId`] that will be exempt from affirmation." , "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: allow_identity_to_create_portfolios { .. } => { & ["Adds an identity that will be allowed to create and take custody of a portfolio under the caller's identity." , "" , "# Arguments" , "* `trusted_identity` - the [`IdentityId`] that will be allowed to call `create_custody_portfolio`." , "" ,] } , Self :: revoke_create_portfolios_permission { .. } => { & ["Removes permission of an identity to create and take custody of a portfolio under the caller's identity." , "" , "# Arguments" , "* `identity` - the [`IdentityId`] that will have the permissions to call `create_custody_portfolio` revoked." , "" ,] } , Self :: create_custody_portfolio { .. } => { & ["Creates a portfolio under the `portfolio_owner_id` identity and transfers its custody to the caller's identity." , "" , "# Arguments" , "* `portfolio_owner_id` - the [`IdentityId`] that will own the new portfolio." , "* `portfolio_name` - the [`PortfolioName`] of the new portfolio." , "" ,] } , _ => & [""] , }
                }
            }
            impl From<PortfolioCall> for &'static str {
                fn from(v: PortfolioCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PortfolioCall> for &'static str {
                fn from(v: &PortfolioCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PortfolioError {
                #[doc = "The portfolio doesn't exist."]
                #[codec(index = 0u8)]
                PortfolioDoesNotExist,
                #[doc = "Insufficient balance for a transaction."]
                #[codec(index = 1u8)]
                InsufficientPortfolioBalance,
                #[doc = "The source and destination portfolios should be different."]
                #[codec(index = 2u8)]
                DestinationIsSamePortfolio,
                #[doc = "The portfolio couldn't be renamed because the chosen name is already in use."]
                #[codec(index = 3u8)]
                PortfolioNameAlreadyInUse,
                #[doc = "The secondary key is not authorized to access the portfolio(s)."]
                #[codec(index = 4u8)]
                SecondaryKeyNotAuthorizedForPortfolio,
                #[doc = "The porfolio's custody is with someone other than the caller."]
                #[codec(index = 5u8)]
                UnauthorizedCustodian,
                #[doc = "Can not unlock more tokens than what are locked"]
                #[codec(index = 6u8)]
                InsufficientTokensLocked,
                #[doc = "The portfolio still has some asset balance left"]
                #[codec(index = 7u8)]
                PortfolioNotEmpty,
                #[doc = "The portfolios belong to different identities"]
                #[codec(index = 8u8)]
                DifferentIdentityPortfolios,
                #[doc = "Duplicate asset among the items."]
                #[codec(index = 9u8)]
                NoDuplicateAssetsAllowed,
                #[doc = "The NFT does not exist in the portfolio."]
                #[codec(index = 10u8)]
                NFTNotFoundInPortfolio,
                #[doc = "The NFT is already locked."]
                #[codec(index = 11u8)]
                NFTAlreadyLocked,
                #[doc = "The NFT has never been locked."]
                #[codec(index = 12u8)]
                NFTNotLocked,
                #[doc = "Only owned NFTs can be moved between portfolios."]
                #[codec(index = 13u8)]
                InvalidTransferNFTNotOwned,
                #[doc = "Locked NFTs can not be moved between portfolios."]
                #[codec(index = 14u8)]
                InvalidTransferNFTIsLocked,
                #[doc = "Trying to move an amount of zero assets."]
                #[codec(index = 15u8)]
                EmptyTransfer,
                #[doc = "The caller doesn't have permission to create portfolios on the owner's behalf."]
                #[codec(index = 16u8)]
                MissingOwnersPermission,
                #[doc = "The sender identity can't be the same as the receiver identity."]
                #[codec(index = 17u8)]
                InvalidTransferSenderIdMatchesReceiverId,
                #[doc = "Adding itself as an AllowedCustodian is not permitted."]
                #[codec(index = 18u8)]
                SelfAdditionNotAllowed,
                #[doc = "The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is."]
                #[codec(index = 19u8)]
                BadAuthorizationType,
                #[doc = "Default portfolios cannot have custodians."]
                #[codec(index = 20u8)]
                DefaultPortfoliosCannotHaveCustodians,
            }
            impl PortfolioError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::PortfolioDoesNotExist => "Portfolio.PortfolioDoesNotExist",
                        Self::InsufficientPortfolioBalance => {
                            "Portfolio.InsufficientPortfolioBalance"
                        }
                        Self::DestinationIsSamePortfolio => "Portfolio.DestinationIsSamePortfolio",
                        Self::PortfolioNameAlreadyInUse => "Portfolio.PortfolioNameAlreadyInUse",
                        Self::SecondaryKeyNotAuthorizedForPortfolio => {
                            "Portfolio.SecondaryKeyNotAuthorizedForPortfolio"
                        }
                        Self::UnauthorizedCustodian => "Portfolio.UnauthorizedCustodian",
                        Self::InsufficientTokensLocked => "Portfolio.InsufficientTokensLocked",
                        Self::PortfolioNotEmpty => "Portfolio.PortfolioNotEmpty",
                        Self::DifferentIdentityPortfolios => {
                            "Portfolio.DifferentIdentityPortfolios"
                        }
                        Self::NoDuplicateAssetsAllowed => "Portfolio.NoDuplicateAssetsAllowed",
                        Self::NFTNotFoundInPortfolio => "Portfolio.NFTNotFoundInPortfolio",
                        Self::NFTAlreadyLocked => "Portfolio.NFTAlreadyLocked",
                        Self::NFTNotLocked => "Portfolio.NFTNotLocked",
                        Self::InvalidTransferNFTNotOwned => "Portfolio.InvalidTransferNFTNotOwned",
                        Self::InvalidTransferNFTIsLocked => "Portfolio.InvalidTransferNFTIsLocked",
                        Self::EmptyTransfer => "Portfolio.EmptyTransfer",
                        Self::MissingOwnersPermission => "Portfolio.MissingOwnersPermission",
                        Self::InvalidTransferSenderIdMatchesReceiverId => {
                            "Portfolio.InvalidTransferSenderIdMatchesReceiverId"
                        }
                        Self::SelfAdditionNotAllowed => "Portfolio.SelfAdditionNotAllowed",
                        Self::BadAuthorizationType => "Portfolio.BadAuthorizationType",
                        Self::DefaultPortfoliosCannotHaveCustodians => {
                            "Portfolio.DefaultPortfoliosCannotHaveCustodians"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PortfolioError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: PortfolioDoesNotExist => { & ["The portfolio doesn't exist." ,] } , Self :: InsufficientPortfolioBalance => { & ["Insufficient balance for a transaction." ,] } , Self :: DestinationIsSamePortfolio => { & ["The source and destination portfolios should be different." ,] } , Self :: PortfolioNameAlreadyInUse => { & ["The portfolio couldn't be renamed because the chosen name is already in use." ,] } , Self :: SecondaryKeyNotAuthorizedForPortfolio => { & ["The secondary key is not authorized to access the portfolio(s)." ,] } , Self :: UnauthorizedCustodian => { & ["The porfolio's custody is with someone other than the caller." ,] } , Self :: InsufficientTokensLocked => { & ["Can not unlock more tokens than what are locked" ,] } , Self :: PortfolioNotEmpty => { & ["The portfolio still has some asset balance left" ,] } , Self :: DifferentIdentityPortfolios => { & ["The portfolios belong to different identities" ,] } , Self :: NoDuplicateAssetsAllowed => { & ["Duplicate asset among the items." ,] } , Self :: NFTNotFoundInPortfolio => { & ["The NFT does not exist in the portfolio." ,] } , Self :: NFTAlreadyLocked => { & ["The NFT is already locked." ,] } , Self :: NFTNotLocked => { & ["The NFT has never been locked." ,] } , Self :: InvalidTransferNFTNotOwned => { & ["Only owned NFTs can be moved between portfolios." ,] } , Self :: InvalidTransferNFTIsLocked => { & ["Locked NFTs can not be moved between portfolios." ,] } , Self :: EmptyTransfer => { & ["Trying to move an amount of zero assets." ,] } , Self :: MissingOwnersPermission => { & ["The caller doesn't have permission to create portfolios on the owner's behalf." ,] } , Self :: InvalidTransferSenderIdMatchesReceiverId => { & ["The sender identity can't be the same as the receiver identity." ,] } , Self :: SelfAdditionNotAllowed => { & ["Adding itself as an AllowedCustodian is not permitted." ,] } , Self :: BadAuthorizationType => { & ["The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is." ,] } , Self :: DefaultPortfoliosCannotHaveCustodians => { & ["Default portfolios cannot have custodians." ,] } , _ => & [""] , }
                }
            }
            impl From<PortfolioError> for &'static str {
                fn from(v: PortfolioError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PortfolioError> for &'static str {
                fn from(v: &PortfolioError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PortfolioEvent {
                #[doc = "The portfolio has been successfully created."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* origin DID"]
                #[doc = "* portfolio number"]
                #[doc = "* portfolio name"]
                #[codec(index = 0u8)]
                PortfolioCreated(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_id::PortfolioNumber,
                    polymesh_primitives::identity_id::PortfolioName,
                ),
                #[doc = "The portfolio has been successfully removed."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* origin DID"]
                #[doc = "* portfolio number"]
                #[codec(index = 1u8)]
                PortfolioDeleted(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_id::PortfolioNumber,
                ),
                #[doc = "The portfolio identified with `num` has been renamed to `name`."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* origin DID"]
                #[doc = "* portfolio number"]
                #[doc = "* portfolio name"]
                #[codec(index = 2u8)]
                PortfolioRenamed(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_id::PortfolioNumber,
                    polymesh_primitives::identity_id::PortfolioName,
                ),
                #[doc = "All non-default portfolio numbers and names of a DID."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* origin DID"]
                #[doc = "* vector of number-name pairs"]
                #[codec(index = 3u8)]
                UserPortfolios(
                    ::polymesh_api_client::IdentityId,
                    ::alloc::vec::Vec<(
                        polymesh_primitives::identity_id::PortfolioNumber,
                        polymesh_primitives::identity_id::PortfolioName,
                    )>,
                ),
                #[doc = "Custody of a portfolio has been given to a different identity"]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* origin DID"]
                #[doc = "* portfolio id"]
                #[doc = "* portfolio custodian did"]
                #[codec(index = 4u8)]
                PortfolioCustodianChanged(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_id::PortfolioId,
                    ::polymesh_api_client::IdentityId,
                ),
                #[doc = "Funds have moved between portfolios"]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* Origin DID."]
                #[doc = "* Source portfolio."]
                #[doc = "* Destination portfolio."]
                #[doc = "* The type of fund that was moved."]
                #[doc = "* Optional memo for the move."]
                #[codec(index = 5u8)]
                FundsMovedBetweenPortfolios(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_id::PortfolioId,
                    polymesh_primitives::identity_id::PortfolioId,
                    polymesh_primitives::portfolio::FundDescription,
                    Option<polymesh_primitives::Memo>,
                ),
                #[doc = "A portfolio has pre approved the receivement of an asset."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* [`IdentityId`] of the caller."]
                #[doc = "* [`PortfolioId`] that will receive assets without explicit affirmation."]
                #[doc = "* [`AssetId`] of the asset that has been exempt from explicit affirmation."]
                #[codec(index = 6u8)]
                PreApprovedPortfolio(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_id::PortfolioId,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "A portfolio has removed the approval of an asset."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* [`IdentityId`] of the caller."]
                #[doc = "* [`PortfolioId`] that had its pre approval revoked."]
                #[doc = "* [`AssetId`] of the asset that had its pre approval revoked."]
                #[codec(index = 7u8)]
                RevokePreApprovedPortfolio(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_id::PortfolioId,
                    ::polymesh_api_client::AssetId,
                ),
                #[doc = "Allow another identity to create portfolios."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* [`IdentityId`] of the caller."]
                #[doc = "* [`IdentityId`] allowed to create portfolios."]
                #[codec(index = 8u8)]
                AllowIdentityToCreatePortfolios(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                ),
                #[doc = "Revoke another identities permission to create portfolios."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* [`IdentityId`] of the caller."]
                #[doc = "* [`IdentityId`] permissions to create portfolios is revoked."]
                #[codec(index = 9u8)]
                RevokeCreatePortfoliosPermission(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                ),
            }
            impl PortfolioEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::PortfolioCreated(_, _, _) => "Portfolio.PortfolioCreated",
                        Self::PortfolioDeleted(_, _) => "Portfolio.PortfolioDeleted",
                        Self::PortfolioRenamed(_, _, _) => "Portfolio.PortfolioRenamed",
                        Self::UserPortfolios(_, _) => "Portfolio.UserPortfolios",
                        Self::PortfolioCustodianChanged(_, _, _) => {
                            "Portfolio.PortfolioCustodianChanged"
                        }
                        Self::FundsMovedBetweenPortfolios(_, _, _, _, _) => {
                            "Portfolio.FundsMovedBetweenPortfolios"
                        }
                        Self::PreApprovedPortfolio(_, _, _) => "Portfolio.PreApprovedPortfolio",
                        Self::RevokePreApprovedPortfolio(_, _, _) => {
                            "Portfolio.RevokePreApprovedPortfolio"
                        }
                        Self::AllowIdentityToCreatePortfolios(_, _) => {
                            "Portfolio.AllowIdentityToCreatePortfolios"
                        }
                        Self::RevokeCreatePortfoliosPermission(_, _) => {
                            "Portfolio.RevokeCreatePortfoliosPermission"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PortfolioEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: PortfolioCreated (_ , _ , _) => { & ["The portfolio has been successfully created." , "" , "# Parameters" , "* origin DID" , "* portfolio number" , "* portfolio name" ,] } , Self :: PortfolioDeleted (_ , _) => { & ["The portfolio has been successfully removed." , "" , "# Parameters" , "* origin DID" , "* portfolio number" ,] } , Self :: PortfolioRenamed (_ , _ , _) => { & ["The portfolio identified with `num` has been renamed to `name`." , "" , "# Parameters" , "* origin DID" , "* portfolio number" , "* portfolio name" ,] } , Self :: UserPortfolios (_ , _) => { & ["All non-default portfolio numbers and names of a DID." , "" , "# Parameters" , "* origin DID" , "* vector of number-name pairs" ,] } , Self :: PortfolioCustodianChanged (_ , _ , _) => { & ["Custody of a portfolio has been given to a different identity" , "" , "# Parameters" , "* origin DID" , "* portfolio id" , "* portfolio custodian did" ,] } , Self :: FundsMovedBetweenPortfolios (_ , _ , _ , _ , _) => { & ["Funds have moved between portfolios" , "" , "# Parameters" , "* Origin DID." , "* Source portfolio." , "* Destination portfolio." , "* The type of fund that was moved." , "* Optional memo for the move." ,] } , Self :: PreApprovedPortfolio (_ , _ , _) => { & ["A portfolio has pre approved the receivement of an asset." , "" , "# Parameters" , "* [`IdentityId`] of the caller." , "* [`PortfolioId`] that will receive assets without explicit affirmation." , "* [`AssetId`] of the asset that has been exempt from explicit affirmation." ,] } , Self :: RevokePreApprovedPortfolio (_ , _ , _) => { & ["A portfolio has removed the approval of an asset." , "" , "# Parameters" , "* [`IdentityId`] of the caller." , "* [`PortfolioId`] that had its pre approval revoked." , "* [`AssetId`] of the asset that had its pre approval revoked." ,] } , Self :: AllowIdentityToCreatePortfolios (_ , _) => { & ["Allow another identity to create portfolios." , "" , "# Parameters" , "* [`IdentityId`] of the caller." , "* [`IdentityId`] allowed to create portfolios." ,] } , Self :: RevokeCreatePortfoliosPermission (_ , _) => { & ["Revoke another identities permission to create portfolios." , "" , "# Parameters" , "* [`IdentityId`] of the caller." , "* [`IdentityId`] permissions to create portfolios is revoked." ,] } , _ => & [""] , }
                }
            }
            impl From<PortfolioEvent> for &'static str {
                fn from(v: PortfolioEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PortfolioEvent> for &'static str {
                fn from(v: &PortfolioEvent) -> Self {
                    v.as_static_str()
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Version(pub u8);
        }
    }
    pub mod pallet_preimage {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PreimageCall {
                #[doc = "Register a preimage on-chain."]
                #[doc = ""]
                #[doc = "If the preimage was previously requested, no fees or deposits are taken for providing"]
                #[doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."]
                #[codec(index = 0u8)]
                note_preimage { bytes: ::alloc::vec::Vec<u8> },
                #[doc = "Clear an unrequested preimage from the runtime storage."]
                #[doc = ""]
                #[doc = "If `len` is provided, then it will be a much cheaper operation."]
                #[doc = ""]
                #[doc = "- `hash`: The hash of the preimage to be removed from the store."]
                #[doc = "- `len`: The length of the preimage of `hash`."]
                #[codec(index = 1u8)]
                unnote_preimage { hash: primitive_types::H256 },
                #[doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."]
                #[doc = ""]
                #[doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"]
                #[doc = "a user may have paid, and take the control of the preimage out of their hands."]
                #[codec(index = 2u8)]
                request_preimage { hash: primitive_types::H256 },
                #[doc = "Clear a previously made request for a preimage."]
                #[doc = ""]
                #[doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."]
                #[codec(index = 3u8)]
                unrequest_preimage { hash: primitive_types::H256 },
                #[doc = "Ensure that the bulk of pre-images is upgraded."]
                #[doc = ""]
                #[doc = "The caller pays no fee if at least 90% of pre-images were successfully updated."]
                #[codec(index = 4u8)]
                ensure_updated {
                    hashes: ::alloc::vec::Vec<primitive_types::H256>,
                },
            }
            impl PreimageCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::note_preimage { .. } => "Preimage.note_preimage",
                        Self::unnote_preimage { .. } => "Preimage.unnote_preimage",
                        Self::request_preimage { .. } => "Preimage.request_preimage",
                        Self::unrequest_preimage { .. } => "Preimage.unrequest_preimage",
                        Self::ensure_updated { .. } => "Preimage.ensure_updated",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PreimageCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: note_preimage { .. } => { & ["Register a preimage on-chain." , "" , "If the preimage was previously requested, no fees or deposits are taken for providing" , "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage." ,] } , Self :: unnote_preimage { .. } => { & ["Clear an unrequested preimage from the runtime storage." , "" , "If `len` is provided, then it will be a much cheaper operation." , "" , "- `hash`: The hash of the preimage to be removed from the store." , "- `len`: The length of the preimage of `hash`." ,] } , Self :: request_preimage { .. } => { & ["Request a preimage be uploaded to the chain without paying any fees or deposits." , "" , "If the preimage requests has already been provided on-chain, we unreserve any deposit" , "a user may have paid, and take the control of the preimage out of their hands." ,] } , Self :: unrequest_preimage { .. } => { & ["Clear a previously made request for a preimage." , "" , "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`." ,] } , Self :: ensure_updated { .. } => { & ["Ensure that the bulk of pre-images is upgraded." , "" , "The caller pays no fee if at least 90% of pre-images were successfully updated." ,] } , _ => & [""] , }
                }
            }
            impl From<PreimageCall> for &'static str {
                fn from(v: PreimageCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PreimageCall> for &'static str {
                fn from(v: &PreimageCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PreimageError {
                #[doc = "Preimage is too large to store on-chain."]
                #[codec(index = 0u8)]
                TooBig,
                #[doc = "Preimage has already been noted on-chain."]
                #[codec(index = 1u8)]
                AlreadyNoted,
                #[doc = "The user is not authorized to perform this action."]
                #[codec(index = 2u8)]
                NotAuthorized,
                #[doc = "The preimage cannot be removed since it has not yet been noted."]
                #[codec(index = 3u8)]
                NotNoted,
                #[doc = "A preimage may not be removed when there are outstanding requests."]
                #[codec(index = 4u8)]
                Requested,
                #[doc = "The preimage request cannot be removed since no outstanding requests exist."]
                #[codec(index = 5u8)]
                NotRequested,
                #[doc = "More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once."]
                #[codec(index = 6u8)]
                TooMany,
                #[doc = "Too few hashes were requested to be upgraded (i.e. zero)."]
                #[codec(index = 7u8)]
                TooFew,
            }
            impl PreimageError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::TooBig => "Preimage.TooBig",
                        Self::AlreadyNoted => "Preimage.AlreadyNoted",
                        Self::NotAuthorized => "Preimage.NotAuthorized",
                        Self::NotNoted => "Preimage.NotNoted",
                        Self::Requested => "Preimage.Requested",
                        Self::NotRequested => "Preimage.NotRequested",
                        Self::TooMany => "Preimage.TooMany",
                        Self::TooFew => "Preimage.TooFew",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PreimageError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: TooBig => { & ["Preimage is too large to store on-chain." ,] } , Self :: AlreadyNoted => { & ["Preimage has already been noted on-chain." ,] } , Self :: NotAuthorized => { & ["The user is not authorized to perform this action." ,] } , Self :: NotNoted => { & ["The preimage cannot be removed since it has not yet been noted." ,] } , Self :: Requested => { & ["A preimage may not be removed when there are outstanding requests." ,] } , Self :: NotRequested => { & ["The preimage request cannot be removed since no outstanding requests exist." ,] } , Self :: TooMany => { & ["More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once." ,] } , Self :: TooFew => { & ["Too few hashes were requested to be upgraded (i.e. zero)." ,] } , _ => & [""] , }
                }
            }
            impl From<PreimageError> for &'static str {
                fn from(v: PreimageError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PreimageError> for &'static str {
                fn from(v: &PreimageError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PreimageEvent {
                #[doc = "A preimage has been noted."]
                #[codec(index = 0u8)]
                Noted { hash: primitive_types::H256 },
                #[doc = "A preimage has been requested."]
                #[codec(index = 1u8)]
                Requested { hash: primitive_types::H256 },
                #[doc = "A preimage has ben cleared."]
                #[codec(index = 2u8)]
                Cleared { hash: primitive_types::H256 },
            }
            impl PreimageEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Noted { .. } => "Preimage.Noted",
                        Self::Requested { .. } => "Preimage.Requested",
                        Self::Cleared { .. } => "Preimage.Cleared",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PreimageEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Noted { .. } => &["A preimage has been noted."],
                        Self::Requested { .. } => &["A preimage has been requested."],
                        Self::Cleared { .. } => &["A preimage has ben cleared."],
                        _ => &[""],
                    }
                }
            }
            impl From<PreimageEvent> for &'static str {
                fn from(v: PreimageEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PreimageEvent> for &'static str {
                fn from(v: &PreimageEvent) -> Self {
                    v.as_static_str()
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum HoldReason {
                #[codec(index = 0u8)]
                Preimage,
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum OldRequestStatus<AccountId, Balance> {
            #[codec(index = 0u8)]
            Unrequested {
                deposit: (AccountId, Balance),
                len: u32,
            },
            #[codec(index = 1u8)]
            Requested {
                deposit: Option<(AccountId, Balance)>,
                count: u32,
                len: Option<u32>,
            },
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum RequestStatus<AccountId, Ticket> {
            #[codec(index = 0u8)]
            Unrequested {
                ticket: (AccountId, Ticket),
                len: u32,
            },
            #[codec(index = 1u8)]
            Requested {
                maybe_ticket: Option<(AccountId, Ticket)>,
                count: u32,
                maybe_len: Option<u32>,
            },
        }
    }
    pub mod pallet_protocol_fee {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ProtocolFeeCall {
                #[doc = "Changes the fee coefficient for the root origin."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - Only root allowed."]
                #[codec(index = 0u8)]
                change_coefficient {
                    coefficient: polymesh_primitives::PosRatio,
                },
                #[doc = "Changes the a base fee for the root origin."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `BadOrigin` - Only root allowed."]
                #[codec(index = 1u8)]
                change_base_fee {
                    op: polymesh_common_utilities::protocol_fee::ProtocolOp,
                    base_fee: u128,
                },
            }
            impl ProtocolFeeCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::change_coefficient { .. } => "ProtocolFee.change_coefficient",
                        Self::change_base_fee { .. } => "ProtocolFee.change_base_fee",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ProtocolFeeCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::change_coefficient { .. } => &[
                            "Changes the fee coefficient for the root origin.",
                            "",
                            "# Errors",
                            "* `BadOrigin` - Only root allowed.",
                        ],
                        Self::change_base_fee { .. } => &[
                            "Changes the a base fee for the root origin.",
                            "",
                            "# Errors",
                            "* `BadOrigin` - Only root allowed.",
                        ],
                        _ => &[""],
                    }
                }
            }
            impl From<ProtocolFeeCall> for &'static str {
                fn from(v: ProtocolFeeCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ProtocolFeeCall> for &'static str {
                fn from(v: &ProtocolFeeCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ProtocolFeeError {
                #[doc = "Insufficient account balance to pay the fee."]
                #[codec(index = 0u8)]
                InsufficientAccountBalance,
                #[doc = "Not able to handled the imbalances"]
                #[codec(index = 1u8)]
                UnHandledImbalances,
                #[doc = "Insufficient subsidy balance to pay the fee."]
                #[codec(index = 2u8)]
                InsufficientSubsidyBalance,
            }
            impl ProtocolFeeError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InsufficientAccountBalance => {
                            "ProtocolFee.InsufficientAccountBalance"
                        }
                        Self::UnHandledImbalances => "ProtocolFee.UnHandledImbalances",
                        Self::InsufficientSubsidyBalance => {
                            "ProtocolFee.InsufficientSubsidyBalance"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ProtocolFeeError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InsufficientAccountBalance => {
                            &["Insufficient account balance to pay the fee."]
                        }
                        Self::UnHandledImbalances => &["Not able to handled the imbalances"],
                        Self::InsufficientSubsidyBalance => {
                            &["Insufficient subsidy balance to pay the fee."]
                        }
                        _ => &[""],
                    }
                }
            }
            impl From<ProtocolFeeError> for &'static str {
                fn from(v: ProtocolFeeError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ProtocolFeeError> for &'static str {
                fn from(v: &ProtocolFeeError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ProtocolFeeEvent {
                #[doc = "The protocol fee of an operation."]
                #[codec(index = 0u8)]
                FeeSet(::polymesh_api_client::IdentityId, u128),
                #[doc = "The fee coefficient."]
                #[codec(index = 1u8)]
                CoefficientSet(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::PosRatio,
                ),
                #[doc = "Fee charged."]
                #[codec(index = 2u8)]
                FeeCharged(::polymesh_api_client::AccountId, u128),
            }
            impl ProtocolFeeEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::FeeSet(_, _) => "ProtocolFee.FeeSet",
                        Self::CoefficientSet(_, _) => "ProtocolFee.CoefficientSet",
                        Self::FeeCharged(_, _) => "ProtocolFee.FeeCharged",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ProtocolFeeEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::FeeSet(_, _) => &["The protocol fee of an operation."],
                        Self::CoefficientSet(_, _) => &["The fee coefficient."],
                        Self::FeeCharged(_, _) => &["Fee charged."],
                        _ => &[""],
                    }
                }
            }
            impl From<ProtocolFeeEvent> for &'static str {
                fn from(v: ProtocolFeeEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ProtocolFeeEvent> for &'static str {
                fn from(v: &ProtocolFeeEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_relayer {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum RelayerCall {
                #[doc = "Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `user_key` the user key to subsidise."]
                #[doc = "- `polyx_limit` the initial POLYX limit for this subsidy."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
                #[codec(index = 0u8)]
                set_paying_key {
                    user_key: ::polymesh_api_client::AccountId,
                    polyx_limit: u128,
                },
                #[doc = "Accepts a `paying_key` authorization."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `auth_id` the authorization id to accept a `paying_key`."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `Error::InvalidAuthorization` if `auth_id` does not exist for the given caller."]
                #[doc = "- `Error::AuthorizationExpired` if `auth_id` the authorization has expired."]
                #[doc = "- `Error::BadAuthorizationType` if `auth_id` was not a `AddRelayerPayingKey` authorization."]
                #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`."]
                #[doc = "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity."]
                #[doc = "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity."]
                #[doc = "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity."]
                #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
                #[codec(index = 1u8)]
                accept_paying_key { auth_id: u64 },
                #[doc = "Removes the `paying_key` from a `user_key`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `user_key` the user key to remove the subsidy from."]
                #[doc = "- `paying_key` the paying key that was subsidising the `user_key`."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`."]
                #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
                #[doc = "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`."]
                #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
                #[codec(index = 2u8)]
                remove_paying_key {
                    user_key: ::polymesh_api_client::AccountId,
                    paying_key: ::polymesh_api_client::AccountId,
                },
                #[doc = "Updates the available POLYX for a `user_key`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
                #[doc = "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
                #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
                #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
                #[codec(index = 3u8)]
                update_polyx_limit {
                    user_key: ::polymesh_api_client::AccountId,
                    polyx_limit: u128,
                },
                #[doc = "Increase the available POLYX for a `user_key`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
                #[doc = "- `amount` the amount of POLYX to add to the subsidy of `user_key`."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
                #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
                #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
                #[doc = "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`."]
                #[codec(index = 4u8)]
                increase_polyx_limit {
                    user_key: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
                #[doc = "Decrease the available POLYX for a `user_key`."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
                #[doc = "- `amount` the amount of POLYX to remove from the subsidy of `user_key`."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
                #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
                #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
                #[doc = "- `Overlow` if the subsidy has less then `amount` POLYX remaining."]
                #[codec(index = 5u8)]
                decrease_polyx_limit {
                    user_key: ::polymesh_api_client::AccountId,
                    amount: u128,
                },
            }
            impl RelayerCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::set_paying_key { .. } => "Relayer.set_paying_key",
                        Self::accept_paying_key { .. } => "Relayer.accept_paying_key",
                        Self::remove_paying_key { .. } => "Relayer.remove_paying_key",
                        Self::update_polyx_limit { .. } => "Relayer.update_polyx_limit",
                        Self::increase_polyx_limit { .. } => "Relayer.increase_polyx_limit",
                        Self::decrease_polyx_limit { .. } => "Relayer.decrease_polyx_limit",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for RelayerCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: set_paying_key { .. } => { & ["Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser." , "" , "# Arguments" , "- `user_key` the user key to subsidise." , "- `polyx_limit` the initial POLYX limit for this subsidy." , "" , "# Errors" , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: accept_paying_key { .. } => { & ["Accepts a `paying_key` authorization." , "" , "# Arguments" , "- `auth_id` the authorization id to accept a `paying_key`." , "" , "# Errors" , "- `Error::InvalidAuthorization` if `auth_id` does not exist for the given caller." , "- `Error::AuthorizationExpired` if `auth_id` the authorization has expired." , "- `Error::BadAuthorizationType` if `auth_id` was not a `AddRelayerPayingKey` authorization." , "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`." , "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity." , "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity." , "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: remove_paying_key { .. } => { & ["Removes the `paying_key` from a `user_key`." , "" , "# Arguments" , "- `user_key` the user key to remove the subsidy from." , "- `paying_key` the paying key that was subsidising the `user_key`." , "" , "# Errors" , "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`." , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: update_polyx_limit { .. } => { & ["Updates the available POLYX for a `user_key`." , "" , "# Arguments" , "- `user_key` the user key of the subsidy to update the available POLYX." , "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`." , "" , "# Errors" , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if `origin` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." ,] } , Self :: increase_polyx_limit { .. } => { & ["Increase the available POLYX for a `user_key`." , "" , "# Arguments" , "- `user_key` the user key of the subsidy to update the available POLYX." , "- `amount` the amount of POLYX to add to the subsidy of `user_key`." , "" , "# Errors" , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if `origin` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." , "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`." ,] } , Self :: decrease_polyx_limit { .. } => { & ["Decrease the available POLYX for a `user_key`." , "" , "# Arguments" , "- `user_key` the user key of the subsidy to update the available POLYX." , "- `amount` the amount of POLYX to remove from the subsidy of `user_key`." , "" , "# Errors" , "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`." , "- `NotPayingKey` if `origin` doesn't match the current `paying_key`." , "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic." , "- `Overlow` if the subsidy has less then `amount` POLYX remaining." ,] } , _ => & [""] , }
                }
            }
            impl From<RelayerCall> for &'static str {
                fn from(v: RelayerCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&RelayerCall> for &'static str {
                fn from(v: &RelayerCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum RelayerError {
                #[doc = "The `user_key` is not attached to a CDD'd identity."]
                #[codec(index = 0u8)]
                UserKeyCddMissing,
                #[doc = "The `user_key` is not attached to a CDD'd identity."]
                #[codec(index = 1u8)]
                PayingKeyCddMissing,
                #[doc = "The `user_key` doesn't have a `paying_key`."]
                #[codec(index = 2u8)]
                NoPayingKey,
                #[doc = "The `user_key` has a different `paying_key`."]
                #[codec(index = 3u8)]
                NotPayingKey,
                #[doc = "The signer is not authorized for `paying_key`."]
                #[codec(index = 4u8)]
                NotAuthorizedForPayingKey,
                #[doc = "The signer is not authorized for `user_key`."]
                #[codec(index = 5u8)]
                NotAuthorizedForUserKey,
                #[doc = "The remaining POLYX for `user_key` overflowed."]
                #[codec(index = 6u8)]
                Overflow,
                #[doc = "The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is."]
                #[codec(index = 7u8)]
                BadAuthorizationType,
            }
            impl RelayerError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::UserKeyCddMissing => "Relayer.UserKeyCddMissing",
                        Self::PayingKeyCddMissing => "Relayer.PayingKeyCddMissing",
                        Self::NoPayingKey => "Relayer.NoPayingKey",
                        Self::NotPayingKey => "Relayer.NotPayingKey",
                        Self::NotAuthorizedForPayingKey => "Relayer.NotAuthorizedForPayingKey",
                        Self::NotAuthorizedForUserKey => "Relayer.NotAuthorizedForUserKey",
                        Self::Overflow => "Relayer.Overflow",
                        Self::BadAuthorizationType => "Relayer.BadAuthorizationType",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for RelayerError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: UserKeyCddMissing => { & ["The `user_key` is not attached to a CDD'd identity." ,] } , Self :: PayingKeyCddMissing => { & ["The `user_key` is not attached to a CDD'd identity." ,] } , Self :: NoPayingKey => { & ["The `user_key` doesn't have a `paying_key`." ,] } , Self :: NotPayingKey => { & ["The `user_key` has a different `paying_key`." ,] } , Self :: NotAuthorizedForPayingKey => { & ["The signer is not authorized for `paying_key`." ,] } , Self :: NotAuthorizedForUserKey => { & ["The signer is not authorized for `user_key`." ,] } , Self :: Overflow => { & ["The remaining POLYX for `user_key` overflowed." ,] } , Self :: BadAuthorizationType => { & ["The extrinsic expected a different `AuthorizationType` than what the `data.auth_type()` is." ,] } , _ => & [""] , }
                }
            }
            impl From<RelayerError> for &'static str {
                fn from(v: RelayerError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&RelayerError> for &'static str {
                fn from(v: &RelayerError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum RelayerEvent {
                #[doc = "Authorization given for `paying_key` to `user_key`."]
                #[doc = ""]
                #[doc = "(Caller DID, User Key, Paying Key, Initial POLYX limit, Auth ID)"]
                #[codec(index = 0u8)]
                AuthorizedPayingKey(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    ::polymesh_api_client::AccountId,
                    ::polymesh_api_client::AccountId,
                    u128,
                    u64,
                ),
                #[doc = "Accepted paying key."]
                #[doc = ""]
                #[doc = "(Caller DID, User Key, Paying Key)"]
                #[codec(index = 1u8)]
                AcceptedPayingKey(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    ::polymesh_api_client::AccountId,
                    ::polymesh_api_client::AccountId,
                ),
                #[doc = "Removed paying key."]
                #[doc = ""]
                #[doc = "(Caller DID, User Key, Paying Key)"]
                #[codec(index = 2u8)]
                RemovedPayingKey(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    ::polymesh_api_client::AccountId,
                    ::polymesh_api_client::AccountId,
                ),
                #[doc = "Updated polyx limit."]
                #[doc = ""]
                #[doc = "(Caller DID, User Key, Paying Key, POLYX limit, old remaining POLYX)"]
                #[codec(index = 3u8)]
                UpdatedPolyxLimit(
                    polymesh_primitives::event_only::EventOnly<::polymesh_api_client::IdentityId>,
                    ::polymesh_api_client::AccountId,
                    ::polymesh_api_client::AccountId,
                    u128,
                    u128,
                ),
            }
            impl RelayerEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::AuthorizedPayingKey(_, _, _, _, _) => "Relayer.AuthorizedPayingKey",
                        Self::AcceptedPayingKey(_, _, _) => "Relayer.AcceptedPayingKey",
                        Self::RemovedPayingKey(_, _, _) => "Relayer.RemovedPayingKey",
                        Self::UpdatedPolyxLimit(_, _, _, _, _) => "Relayer.UpdatedPolyxLimit",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for RelayerEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::AuthorizedPayingKey(_, _, _, _, _) => &[
                            "Authorization given for `paying_key` to `user_key`.",
                            "",
                            "(Caller DID, User Key, Paying Key, Initial POLYX limit, Auth ID)",
                        ],
                        Self::AcceptedPayingKey(_, _, _) => &[
                            "Accepted paying key.",
                            "",
                            "(Caller DID, User Key, Paying Key)",
                        ],
                        Self::RemovedPayingKey(_, _, _) => &[
                            "Removed paying key.",
                            "",
                            "(Caller DID, User Key, Paying Key)",
                        ],
                        Self::UpdatedPolyxLimit(_, _, _, _, _) => &[
                            "Updated polyx limit.",
                            "",
                            "(Caller DID, User Key, Paying Key, POLYX limit, old remaining POLYX)",
                        ],
                        _ => &[""],
                    }
                }
            }
            impl From<RelayerEvent> for &'static str {
                fn from(v: RelayerEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&RelayerEvent> for &'static str {
                fn from(v: &RelayerEvent) -> Self {
                    v.as_static_str()
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Subsidy<Acc> {
                pub paying_key: Acc,
                pub remaining: u128,
            }
        }
    }
    pub mod pallet_scheduler {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SchedulerCall {
                #[doc = "Anonymously schedule a task."]
                #[codec(index = 0u8)]
                schedule {
                    when: u32,
                    maybe_periodic: Option<(u32, u32)>,
                    priority: u8,
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                },
                #[doc = "Cancel an anonymously scheduled task."]
                #[codec(index = 1u8)]
                cancel { when: u32, index: u32 },
                #[doc = "Schedule a named task."]
                #[codec(index = 2u8)]
                schedule_named {
                    id: [u8; 32usize],
                    when: u32,
                    maybe_periodic: Option<(u32, u32)>,
                    priority: u8,
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                },
                #[doc = "Cancel a named scheduled task."]
                #[codec(index = 3u8)]
                cancel_named { id: [u8; 32usize] },
                #[doc = "Anonymously schedule a task after a delay."]
                #[codec(index = 4u8)]
                schedule_after {
                    after: u32,
                    maybe_periodic: Option<(u32, u32)>,
                    priority: u8,
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                },
                #[doc = "Schedule a named task after a delay."]
                #[codec(index = 5u8)]
                schedule_named_after {
                    id: [u8; 32usize],
                    after: u32,
                    maybe_periodic: Option<(u32, u32)>,
                    priority: u8,
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                },
                #[doc = "Set a retry configuration for a task so that, in case its scheduled run fails, it will"]
                #[doc = "be retried after `period` blocks, for a total amount of `retries` retries or until it"]
                #[doc = "succeeds."]
                #[doc = ""]
                #[doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"]
                #[doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"]
                #[doc = "normally while the task is retrying."]
                #[doc = ""]
                #[doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"]
                #[doc = "clones of the original task. Their retry configuration will be derived from the"]
                #[doc = "original task's configuration, but will have a lower value for `remaining` than the"]
                #[doc = "original `total_retries`."]
                #[codec(index = 6u8)]
                set_retry {
                    task: (u32, u32),
                    retries: u8,
                    period: u32,
                },
                #[doc = "Set a retry configuration for a named task so that, in case its scheduled run fails, it"]
                #[doc = "will be retried after `period` blocks, for a total amount of `retries` retries or until"]
                #[doc = "it succeeds."]
                #[doc = ""]
                #[doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"]
                #[doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"]
                #[doc = "normally while the task is retrying."]
                #[doc = ""]
                #[doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"]
                #[doc = "clones of the original task. Their retry configuration will be derived from the"]
                #[doc = "original task's configuration, but will have a lower value for `remaining` than the"]
                #[doc = "original `total_retries`."]
                #[codec(index = 7u8)]
                set_retry_named {
                    id: [u8; 32usize],
                    retries: u8,
                    period: u32,
                },
                #[doc = "Removes the retry configuration of a task."]
                #[codec(index = 8u8)]
                cancel_retry { task: (u32, u32) },
                #[doc = "Cancel the retry configuration of a named task."]
                #[codec(index = 9u8)]
                cancel_retry_named { id: [u8; 32usize] },
            }
            impl SchedulerCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::schedule { .. } => "Scheduler.schedule",
                        Self::cancel { .. } => "Scheduler.cancel",
                        Self::schedule_named { .. } => "Scheduler.schedule_named",
                        Self::cancel_named { .. } => "Scheduler.cancel_named",
                        Self::schedule_after { .. } => "Scheduler.schedule_after",
                        Self::schedule_named_after { .. } => "Scheduler.schedule_named_after",
                        Self::set_retry { .. } => "Scheduler.set_retry",
                        Self::set_retry_named { .. } => "Scheduler.set_retry_named",
                        Self::cancel_retry { .. } => "Scheduler.cancel_retry",
                        Self::cancel_retry_named { .. } => "Scheduler.cancel_retry_named",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SchedulerCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: schedule { .. } => { & ["Anonymously schedule a task." ,] } , Self :: cancel { .. } => { & ["Cancel an anonymously scheduled task." ,] } , Self :: schedule_named { .. } => { & ["Schedule a named task." ,] } , Self :: cancel_named { .. } => { & ["Cancel a named scheduled task." ,] } , Self :: schedule_after { .. } => { & ["Anonymously schedule a task after a delay." ,] } , Self :: schedule_named_after { .. } => { & ["Schedule a named task after a delay." ,] } , Self :: set_retry { .. } => { & ["Set a retry configuration for a task so that, in case its scheduled run fails, it will" , "be retried after `period` blocks, for a total amount of `retries` retries or until it" , "succeeds." , "" , "Tasks which need to be scheduled for a retry are still subject to weight metering and" , "agenda space, same as a regular task. If a periodic task fails, it will be scheduled" , "normally while the task is retrying." , "" , "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic" , "clones of the original task. Their retry configuration will be derived from the" , "original task's configuration, but will have a lower value for `remaining` than the" , "original `total_retries`." ,] } , Self :: set_retry_named { .. } => { & ["Set a retry configuration for a named task so that, in case its scheduled run fails, it" , "will be retried after `period` blocks, for a total amount of `retries` retries or until" , "it succeeds." , "" , "Tasks which need to be scheduled for a retry are still subject to weight metering and" , "agenda space, same as a regular task. If a periodic task fails, it will be scheduled" , "normally while the task is retrying." , "" , "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic" , "clones of the original task. Their retry configuration will be derived from the" , "original task's configuration, but will have a lower value for `remaining` than the" , "original `total_retries`." ,] } , Self :: cancel_retry { .. } => { & ["Removes the retry configuration of a task." ,] } , Self :: cancel_retry_named { .. } => { & ["Cancel the retry configuration of a named task." ,] } , _ => & [""] , }
                }
            }
            impl From<SchedulerCall> for &'static str {
                fn from(v: SchedulerCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SchedulerCall> for &'static str {
                fn from(v: &SchedulerCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SchedulerError {
                #[doc = "Failed to schedule a call"]
                #[codec(index = 0u8)]
                FailedToSchedule,
                #[doc = "Cannot find the scheduled call."]
                #[codec(index = 1u8)]
                NotFound,
                #[doc = "Given target block number is in the past."]
                #[codec(index = 2u8)]
                TargetBlockNumberInPast,
                #[doc = "Reschedule failed because it does not change scheduled time."]
                #[codec(index = 3u8)]
                RescheduleNoChange,
                #[doc = "Attempt to use a non-named function on a named task."]
                #[codec(index = 4u8)]
                Named,
            }
            impl SchedulerError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::FailedToSchedule => "Scheduler.FailedToSchedule",
                        Self::NotFound => "Scheduler.NotFound",
                        Self::TargetBlockNumberInPast => "Scheduler.TargetBlockNumberInPast",
                        Self::RescheduleNoChange => "Scheduler.RescheduleNoChange",
                        Self::Named => "Scheduler.Named",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SchedulerError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::FailedToSchedule => &["Failed to schedule a call"],
                        Self::NotFound => &["Cannot find the scheduled call."],
                        Self::TargetBlockNumberInPast => {
                            &["Given target block number is in the past."]
                        }
                        Self::RescheduleNoChange => {
                            &["Reschedule failed because it does not change scheduled time."]
                        }
                        Self::Named => &["Attempt to use a non-named function on a named task."],
                        _ => &[""],
                    }
                }
            }
            impl From<SchedulerError> for &'static str {
                fn from(v: SchedulerError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SchedulerError> for &'static str {
                fn from(v: &SchedulerError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "Events type."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SchedulerEvent {
                #[doc = "Scheduled some task."]
                #[codec(index = 0u8)]
                Scheduled { when: u32, index: u32 },
                #[doc = "Canceled some task."]
                #[codec(index = 1u8)]
                Canceled { when: u32, index: u32 },
                #[doc = "Dispatched some task."]
                #[codec(index = 2u8)]
                Dispatched {
                    task: (u32, u32),
                    id: Option<[u8; 32usize]>,
                    result: Result<(), sp_runtime::DispatchError>,
                },
                #[doc = "Set a retry configuration for some task."]
                #[codec(index = 3u8)]
                RetrySet {
                    task: (u32, u32),
                    id: Option<[u8; 32usize]>,
                    period: u32,
                    retries: u8,
                },
                #[doc = "Cancel a retry configuration for some task."]
                #[codec(index = 4u8)]
                RetryCancelled {
                    task: (u32, u32),
                    id: Option<[u8; 32usize]>,
                },
                #[doc = "The call for the provided hash was not found so the task has been aborted."]
                #[codec(index = 5u8)]
                CallUnavailable {
                    task: (u32, u32),
                    id: Option<[u8; 32usize]>,
                },
                #[doc = "The given task was unable to be renewed since the agenda is full at that block."]
                #[codec(index = 6u8)]
                PeriodicFailed {
                    task: (u32, u32),
                    id: Option<[u8; 32usize]>,
                },
                #[doc = "The given task was unable to be retried since the agenda is full at that block or there"]
                #[doc = "was not enough weight to reschedule it."]
                #[codec(index = 7u8)]
                RetryFailed {
                    task: (u32, u32),
                    id: Option<[u8; 32usize]>,
                },
                #[doc = "The given task can never be executed since it is overweight."]
                #[codec(index = 8u8)]
                PermanentlyOverweight {
                    task: (u32, u32),
                    id: Option<[u8; 32usize]>,
                },
                #[doc = "Agenda is incomplete from `when`."]
                #[codec(index = 9u8)]
                AgendaIncomplete { when: u32 },
            }
            impl SchedulerEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Scheduled { .. } => "Scheduler.Scheduled",
                        Self::Canceled { .. } => "Scheduler.Canceled",
                        Self::Dispatched { .. } => "Scheduler.Dispatched",
                        Self::RetrySet { .. } => "Scheduler.RetrySet",
                        Self::RetryCancelled { .. } => "Scheduler.RetryCancelled",
                        Self::CallUnavailable { .. } => "Scheduler.CallUnavailable",
                        Self::PeriodicFailed { .. } => "Scheduler.PeriodicFailed",
                        Self::RetryFailed { .. } => "Scheduler.RetryFailed",
                        Self::PermanentlyOverweight { .. } => "Scheduler.PermanentlyOverweight",
                        Self::AgendaIncomplete { .. } => "Scheduler.AgendaIncomplete",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SchedulerEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: Scheduled { .. } => { & ["Scheduled some task." ,] } , Self :: Canceled { .. } => { & ["Canceled some task." ,] } , Self :: Dispatched { .. } => { & ["Dispatched some task." ,] } , Self :: RetrySet { .. } => { & ["Set a retry configuration for some task." ,] } , Self :: RetryCancelled { .. } => { & ["Cancel a retry configuration for some task." ,] } , Self :: CallUnavailable { .. } => { & ["The call for the provided hash was not found so the task has been aborted." ,] } , Self :: PeriodicFailed { .. } => { & ["The given task was unable to be renewed since the agenda is full at that block." ,] } , Self :: RetryFailed { .. } => { & ["The given task was unable to be retried since the agenda is full at that block or there" , "was not enough weight to reschedule it." ,] } , Self :: PermanentlyOverweight { .. } => { & ["The given task can never be executed since it is overweight." ,] } , Self :: AgendaIncomplete { .. } => { & ["Agenda is incomplete from `when`." ,] } , _ => & [""] , }
                }
            }
            impl From<SchedulerEvent> for &'static str {
                fn from(v: SchedulerEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SchedulerEvent> for &'static str {
                fn from(v: &SchedulerEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct RetryConfig<Period> {
            pub total_retries: u8,
            pub remaining: u8,
            pub period: Period,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Scheduled<Name, Call, BlockNumber, PalletsOrigin, AccountId> {
            pub maybe_id: Option<Name>,
            pub priority: u8,
            pub call: Call,
            pub maybe_periodic: Option<(BlockNumber, BlockNumber)>,
            pub origin: PalletsOrigin,
            _phantom_data: core::marker::PhantomData<AccountId>,
        }
    }
    pub mod pallet_session {
        use super::*;
        pub mod historical {
            use super::*;
            pub mod pallet {
                use super::*;
                #[doc = "The `Event` enum of this pallet"]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum HistoricalEvent {
                    #[doc = "The merkle root of the validators of the said session were stored"]
                    #[codec(index = 0u8)]
                    RootStored { index: u32 },
                    #[doc = "The merkle roots of up to this session index were pruned"]
                    #[codec(index = 1u8)]
                    RootsPruned { up_to: u32 },
                }
                impl HistoricalEvent {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::RootStored { .. } => "Historical.RootStored",
                            Self::RootsPruned { .. } => "Historical.RootsPruned",
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for HistoricalEvent {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::RootStored { .. } => &[
                                "The merkle root of the validators of the said session were stored",
                            ],
                            Self::RootsPruned { .. } => {
                                &["The merkle roots of up to this session index were pruned"]
                            }
                            _ => &[""],
                        }
                    }
                }
                impl From<HistoricalEvent> for &'static str {
                    fn from(v: HistoricalEvent) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&HistoricalEvent> for &'static str {
                    fn from(v: &HistoricalEvent) -> Self {
                        v.as_static_str()
                    }
                }
            }
        }
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SessionCall {
                #[doc = "Sets the session key(s) of the function caller to `keys`."]
                #[doc = "Allows an account to set its session key prior to becoming a validator."]
                #[doc = "This doesn't take effect until the next session."]
                #[doc = ""]
                #[doc = "The dispatch origin of this function must be signed."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"]
                #[doc = "  fixed."]
                #[codec(index = 0u8)]
                set_keys {
                    keys: runtime::SessionKeys,
                    proof: ::alloc::vec::Vec<u8>,
                },
                #[doc = "Removes any session key(s) of the function caller."]
                #[doc = ""]
                #[doc = "This doesn't take effect until the next session."]
                #[doc = ""]
                #[doc = "The dispatch origin of this function must be Signed and the account must be either be"]
                #[doc = "convertible to a validator ID using the chain's typical addressing system (this usually"]
                #[doc = "means being a controller account) or directly convertible into a validator ID (which"]
                #[doc = "usually means being a stash account)."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"]
                #[doc = "  `T::Keys::key_ids()` which is fixed."]
                #[codec(index = 1u8)]
                purge_keys,
            }
            impl SessionCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::set_keys { .. } => "Session.set_keys",
                        Self::purge_keys => "Session.purge_keys",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SessionCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: set_keys { .. } => { & ["Sets the session key(s) of the function caller to `keys`." , "Allows an account to set its session key prior to becoming a validator." , "This doesn't take effect until the next session." , "" , "The dispatch origin of this function must be signed." , "" , "## Complexity" , "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is" , "  fixed." ,] } , Self :: purge_keys => { & ["Removes any session key(s) of the function caller." , "" , "This doesn't take effect until the next session." , "" , "The dispatch origin of this function must be Signed and the account must be either be" , "convertible to a validator ID using the chain's typical addressing system (this usually" , "means being a controller account) or directly convertible into a validator ID (which" , "usually means being a stash account)." , "" , "## Complexity" , "- `O(1)` in number of key types. Actual cost depends on the number of length of" , "  `T::Keys::key_ids()` which is fixed." ,] } , _ => & [""] , }
                }
            }
            impl From<SessionCall> for &'static str {
                fn from(v: SessionCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SessionCall> for &'static str {
                fn from(v: &SessionCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "Error for the session pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SessionError {
                #[doc = "Invalid ownership proof."]
                #[codec(index = 0u8)]
                InvalidProof,
                #[doc = "No associated validator ID for account."]
                #[codec(index = 1u8)]
                NoAssociatedValidatorId,
                #[doc = "Registered duplicate key."]
                #[codec(index = 2u8)]
                DuplicatedKey,
                #[doc = "No keys are associated with this account."]
                #[codec(index = 3u8)]
                NoKeys,
                #[doc = "Key setting account is not live, so it's impossible to associate keys."]
                #[codec(index = 4u8)]
                NoAccount,
            }
            impl SessionError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InvalidProof => "Session.InvalidProof",
                        Self::NoAssociatedValidatorId => "Session.NoAssociatedValidatorId",
                        Self::DuplicatedKey => "Session.DuplicatedKey",
                        Self::NoKeys => "Session.NoKeys",
                        Self::NoAccount => "Session.NoAccount",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SessionError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: InvalidProof => { & ["Invalid ownership proof." ,] } , Self :: NoAssociatedValidatorId => { & ["No associated validator ID for account." ,] } , Self :: DuplicatedKey => { & ["Registered duplicate key." ,] } , Self :: NoKeys => { & ["No keys are associated with this account." ,] } , Self :: NoAccount => { & ["Key setting account is not live, so it's impossible to associate keys." ,] } , _ => & [""] , }
                }
            }
            impl From<SessionError> for &'static str {
                fn from(v: SessionError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SessionError> for &'static str {
                fn from(v: &SessionError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SessionEvent {
                #[doc = "New session has happened. Note that the argument is the session index, not the"]
                #[doc = "block number as the type might suggest."]
                #[codec(index = 0u8)]
                NewSession { session_index: u32 },
                #[doc = "The `NewSession` event in the current block also implies a new validator set to be"]
                #[doc = "queued."]
                #[codec(index = 1u8)]
                NewQueued,
                #[doc = "Validator has been disabled."]
                #[codec(index = 2u8)]
                ValidatorDisabled {
                    validator: ::polymesh_api_client::AccountId,
                },
                #[doc = "Validator has been re-enabled."]
                #[codec(index = 3u8)]
                ValidatorReenabled {
                    validator: ::polymesh_api_client::AccountId,
                },
            }
            impl SessionEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::NewSession { .. } => "Session.NewSession",
                        Self::NewQueued => "Session.NewQueued",
                        Self::ValidatorDisabled { .. } => "Session.ValidatorDisabled",
                        Self::ValidatorReenabled { .. } => "Session.ValidatorReenabled",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SessionEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: NewSession { .. } => { & ["New session has happened. Note that the argument is the session index, not the" , "block number as the type might suggest." ,] } , Self :: NewQueued => { & ["The `NewSession` event in the current block also implies a new validator set to be" , "queued." ,] } , Self :: ValidatorDisabled { .. } => { & ["Validator has been disabled." ,] } , Self :: ValidatorReenabled { .. } => { & ["Validator has been re-enabled." ,] } , _ => & [""] , }
                }
            }
            impl From<SessionEvent> for &'static str {
                fn from(v: SessionEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SessionEvent> for &'static str {
                fn from(v: &SessionEvent) -> Self {
                    v.as_static_str()
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum HoldReason {
                #[codec(index = 0u8)]
                Keys,
            }
        }
    }
    pub mod pallet_settlement {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SettlementCall {
                #[doc = "Registers a new venue."]
                #[doc = ""]
                #[doc = "* `details` - Extra details about a venue"]
                #[doc = "* `signers` - Array of signers that are allowed to sign receipts for this venue"]
                #[doc = "* `typ` - Type of venue being created"]
                #[codec(index = 0u8)]
                create_venue {
                    details: polymesh_primitives::settlement::VenueDetails,
                    signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                    typ: polymesh_primitives::settlement::VenueType,
                },
                #[doc = "Edit a venue's details."]
                #[doc = ""]
                #[doc = "* `id` specifies the ID of the venue to edit."]
                #[doc = "* `details` specifies the updated venue details."]
                #[codec(index = 1u8)]
                update_venue_details {
                    id: polymesh_primitives::settlement::VenueId,
                    details: polymesh_primitives::settlement::VenueDetails,
                },
                #[doc = "Edit a venue's type."]
                #[doc = ""]
                #[doc = "* `id` specifies the ID of the venue to edit."]
                #[doc = "* `type` specifies the new type of the venue."]
                #[codec(index = 2u8)]
                update_venue_type {
                    id: polymesh_primitives::settlement::VenueId,
                    typ: polymesh_primitives::settlement::VenueType,
                },
                #[doc = "Affirms an instruction using receipts for offchain transfers."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
                #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
                #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 3u8)]
                affirm_with_receipts {
                    id: polymesh_primitives::settlement::InstructionId,
                    receipt_details: ::alloc::vec::Vec<
                        polymesh_primitives::settlement::ReceiptDetails<
                            ::polymesh_api_client::AccountId,
                            ::polymesh_api_client::MultiSignature,
                        >,
                    >,
                    portfolios: ::alloc::collections::BTreeSet<
                        polymesh_primitives::identity_id::PortfolioId,
                    >,
                },
                #[doc = "Enables or disabled venue filtering for a token."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `asset_id` - AssetId of the token in question."]
                #[doc = "* `enabled` - Boolean that decides if the filtering should be enabled."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 4u8)]
                set_venue_filtering {
                    asset_id: ::polymesh_api_client::AssetId,
                    enabled: bool,
                },
                #[doc = "Allows additional venues to create instructions involving an asset."]
                #[doc = ""]
                #[doc = "* `asset_id` - AssetId of the token in question."]
                #[doc = "* `venues` - Array of venues that are allowed to create instructions for the token in question."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 5u8)]
                allow_venues {
                    asset_id: ::polymesh_api_client::AssetId,
                    venues: ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
                },
                #[doc = "Revokes permission given to venues for creating instructions involving a particular asset."]
                #[doc = ""]
                #[doc = "* `asset_id` - AssetId of the token in question."]
                #[doc = "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Asset"]
                #[codec(index = 6u8)]
                disallow_venues {
                    asset_id: ::polymesh_api_client::AssetId,
                    venues: ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
                },
                #[doc = "Edit a venue's signers."]
                #[doc = "* `id` specifies the ID of the venue to edit."]
                #[doc = "* `signers` specifies the signers to add/remove."]
                #[doc = "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false."]
                #[codec(index = 7u8)]
                update_venue_signers {
                    id: polymesh_primitives::settlement::VenueId,
                    signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                    add_signers: bool,
                },
                #[doc = "Manually executes an instruction."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `id`: The [`InstructionId`] of the instruction to be executed."]
                #[doc = "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction."]
                #[doc = "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]."]
                #[doc = "* `fungible_transfers`: The number of fungible legs in the instruction."]
                #[doc = "* `nfts_transfers`: The number of nfts being transferred in the instruction."]
                #[doc = "* `offchain_transfers`: The number of offchain legs in the instruction."]
                #[doc = "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction."]
                #[doc = "If the `weight_limit` is less than the required amount, the instruction will fail execution."]
                #[doc = ""]
                #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters."]
                #[codec(index = 8u8)]
                execute_manual_instruction {
                    id: polymesh_primitives::settlement::InstructionId,
                    portfolio: Option<polymesh_primitives::identity_id::PortfolioId>,
                    fungible_transfers: u32,
                    nfts_transfers: u32,
                    offchain_transfers: u32,
                    weight_limit: Option<::polymesh_api_client::sp_weights::Weight>,
                },
                #[doc = "Adds a new instruction."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `venue_id`: The optional [`VenueId`] of the venue this instruction belongs to."]
                #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
                #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
                #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
                #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
                #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
                #[codec(index = 9u8)]
                add_instruction {
                    venue_id: Option<polymesh_primitives::settlement::VenueId>,
                    settlement_type: polymesh_primitives::settlement::SettlementType<u32>,
                    trade_date: Option<u64>,
                    value_date: Option<u64>,
                    legs: ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
                    instruction_memo: Option<polymesh_primitives::Memo>,
                },
                #[doc = "Adds and affirms a new instruction."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
                #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
                #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
                #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
                #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
                #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
                #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 10u8)]
                add_and_affirm_instruction {
                    venue_id: Option<polymesh_primitives::settlement::VenueId>,
                    settlement_type: polymesh_primitives::settlement::SettlementType<u32>,
                    trade_date: Option<u64>,
                    value_date: Option<u64>,
                    legs: ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
                    portfolios: ::alloc::collections::BTreeSet<
                        polymesh_primitives::identity_id::PortfolioId,
                    >,
                    instruction_memo: Option<polymesh_primitives::Memo>,
                },
                #[doc = "Provide affirmation to an existing instruction."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
                #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 11u8)]
                affirm_instruction {
                    id: polymesh_primitives::settlement::InstructionId,
                    portfolios: ::alloc::collections::BTreeSet<
                        polymesh_primitives::identity_id::PortfolioId,
                    >,
                },
                #[doc = "Withdraw an affirmation for a given instruction."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
                #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 12u8)]
                withdraw_affirmation {
                    id: polymesh_primitives::settlement::InstructionId,
                    portfolios: ::alloc::collections::BTreeSet<
                        polymesh_primitives::identity_id::PortfolioId,
                    >,
                },
                #[doc = "Rejects an existing instruction."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
                #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 13u8)]
                reject_instruction {
                    id: polymesh_primitives::settlement::InstructionId,
                    portfolio: polymesh_primitives::identity_id::PortfolioId,
                },
                #[doc = "Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction."]
                #[codec(index = 14u8)]
                execute_scheduled_instruction {
                    id: polymesh_primitives::settlement::InstructionId,
                    weight_limit: ::polymesh_api_client::sp_weights::Weight,
                },
                #[doc = "Affirms an instruction using receipts for offchain transfers."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
                #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
                #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
                #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
                #[doc = ""]
                #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 15u8)]
                affirm_with_receipts_with_count {
                    id: polymesh_primitives::settlement::InstructionId,
                    receipt_details: ::alloc::vec::Vec<
                        polymesh_primitives::settlement::ReceiptDetails<
                            ::polymesh_api_client::AccountId,
                            ::polymesh_api_client::MultiSignature,
                        >,
                    >,
                    portfolios: ::alloc::collections::BTreeSet<
                        polymesh_primitives::identity_id::PortfolioId,
                    >,
                    number_of_assets: Option<polymesh_primitives::settlement::AffirmationCount>,
                },
                #[doc = "Provide affirmation to an existing instruction."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
                #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
                #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
                #[doc = ""]
                #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 16u8)]
                affirm_instruction_with_count {
                    id: polymesh_primitives::settlement::InstructionId,
                    portfolios: ::alloc::collections::BTreeSet<
                        polymesh_primitives::identity_id::PortfolioId,
                    >,
                    number_of_assets: Option<polymesh_primitives::settlement::AffirmationCount>,
                },
                #[doc = "Rejects an existing instruction."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
                #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
                #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
                #[doc = ""]
                #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 17u8)]
                reject_instruction_with_count {
                    id: polymesh_primitives::settlement::InstructionId,
                    portfolio: polymesh_primitives::identity_id::PortfolioId,
                    number_of_assets: Option<polymesh_primitives::settlement::AssetCount>,
                },
                #[doc = "Withdraw an affirmation for a given instruction."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
                #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
                #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
                #[doc = ""]
                #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 18u8)]
                withdraw_affirmation_with_count {
                    id: polymesh_primitives::settlement::InstructionId,
                    portfolios: ::alloc::collections::BTreeSet<
                        polymesh_primitives::identity_id::PortfolioId,
                    >,
                    number_of_assets: Option<polymesh_primitives::settlement::AffirmationCount>,
                },
                #[doc = "Adds a new instruction with mediators."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
                #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
                #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
                #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
                #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
                #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
                #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
                #[codec(index = 19u8)]
                add_instruction_with_mediators {
                    venue_id: Option<polymesh_primitives::settlement::VenueId>,
                    settlement_type: polymesh_primitives::settlement::SettlementType<u32>,
                    trade_date: Option<u64>,
                    value_date: Option<u64>,
                    legs: ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
                    instruction_memo: Option<polymesh_primitives::Memo>,
                    mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
                },
                #[doc = "Adds and affirms a new instruction with mediators."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
                #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
                #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
                #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
                #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
                #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
                #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
                #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "* Portfolio"]
                #[codec(index = 20u8)]
                add_and_affirm_with_mediators {
                    venue_id: Option<polymesh_primitives::settlement::VenueId>,
                    settlement_type: polymesh_primitives::settlement::SettlementType<u32>,
                    trade_date: Option<u64>,
                    value_date: Option<u64>,
                    legs: ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
                    portfolios: ::alloc::collections::BTreeSet<
                        polymesh_primitives::identity_id::PortfolioId,
                    >,
                    instruction_memo: Option<polymesh_primitives::Memo>,
                    mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
                },
                #[doc = "Affirms the instruction as a mediator - should only be called by mediators, otherwise it will fail."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin`: The secondary key of the sender."]
                #[doc = "* `instruction_id`: The [`InstructionId`] that will be affirmed by the mediator."]
                #[doc = "* `expiry`: An Optional value for defining when the affirmation will expire (None means it will always be valid)."]
                #[codec(index = 21u8)]
                affirm_instruction_as_mediator {
                    instruction_id: polymesh_primitives::settlement::InstructionId,
                    expiry: Option<u64>,
                },
                #[doc = "Removes the mediator's affirmation for the instruction - should only be called by mediators, otherwise it will fail."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin`: The secondary key of the sender."]
                #[doc = "* `instruction_id`: The [`InstructionId`] that will have the affirmation removed."]
                #[codec(index = 22u8)]
                withdraw_affirmation_as_mediator {
                    instruction_id: polymesh_primitives::settlement::InstructionId,
                },
                #[doc = "Rejects an existing instruction - should only be called by mediators, otherwise it will fail."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `instruction_id` - the [`InstructionId`] of the instruction being rejected."]
                #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
                #[doc = ""]
                #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
                #[codec(index = 23u8)]
                reject_instruction_as_mediator {
                    instruction_id: polymesh_primitives::settlement::InstructionId,
                    number_of_assets: Option<polymesh_primitives::settlement::AssetCount>,
                },
                #[doc = "Moves the instruction status to `LockedForExecution`. This function must be called by a"]
                #[doc = "mediator of the instruction and will only suceed if the following conditions are met:"]
                #[doc = "- All affirmations have been received."]
                #[doc = "- Instruction is pending or has failed at least one time."]
                #[doc = "- All mediator's affirmations are still valid."]
                #[doc = "- All assets are in the allowed venue list."]
                #[doc = "- All senders have the right amount of assets being transferred."]
                #[doc = "- All senders and receivers are compliant and have valid CDD claims."]
                #[doc = "- All assets' statistics are still valid."]
                #[doc = "- There are no frozen assets."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `origin` - The origin of the call, specifying the caller."]
                #[doc = "* `inst_id` - The [`InstructionId`] of the instruction to be locked."]
                #[doc = "* `weight_limit` - A maximum [`Weight`] value to be charged for locking the instruction."]
                #[codec(index = 24u8)]
                lock_instruction {
                    inst_id: polymesh_primitives::settlement::InstructionId,
                    weight_limit: ::polymesh_api_client::sp_weights::Weight,
                },
            }
            impl SettlementCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::create_venue { .. } => "Settlement.create_venue",
                        Self::update_venue_details { .. } => "Settlement.update_venue_details",
                        Self::update_venue_type { .. } => "Settlement.update_venue_type",
                        Self::affirm_with_receipts { .. } => "Settlement.affirm_with_receipts",
                        Self::set_venue_filtering { .. } => "Settlement.set_venue_filtering",
                        Self::allow_venues { .. } => "Settlement.allow_venues",
                        Self::disallow_venues { .. } => "Settlement.disallow_venues",
                        Self::update_venue_signers { .. } => "Settlement.update_venue_signers",
                        Self::execute_manual_instruction { .. } => {
                            "Settlement.execute_manual_instruction"
                        }
                        Self::add_instruction { .. } => "Settlement.add_instruction",
                        Self::add_and_affirm_instruction { .. } => {
                            "Settlement.add_and_affirm_instruction"
                        }
                        Self::affirm_instruction { .. } => "Settlement.affirm_instruction",
                        Self::withdraw_affirmation { .. } => "Settlement.withdraw_affirmation",
                        Self::reject_instruction { .. } => "Settlement.reject_instruction",
                        Self::execute_scheduled_instruction { .. } => {
                            "Settlement.execute_scheduled_instruction"
                        }
                        Self::affirm_with_receipts_with_count { .. } => {
                            "Settlement.affirm_with_receipts_with_count"
                        }
                        Self::affirm_instruction_with_count { .. } => {
                            "Settlement.affirm_instruction_with_count"
                        }
                        Self::reject_instruction_with_count { .. } => {
                            "Settlement.reject_instruction_with_count"
                        }
                        Self::withdraw_affirmation_with_count { .. } => {
                            "Settlement.withdraw_affirmation_with_count"
                        }
                        Self::add_instruction_with_mediators { .. } => {
                            "Settlement.add_instruction_with_mediators"
                        }
                        Self::add_and_affirm_with_mediators { .. } => {
                            "Settlement.add_and_affirm_with_mediators"
                        }
                        Self::affirm_instruction_as_mediator { .. } => {
                            "Settlement.affirm_instruction_as_mediator"
                        }
                        Self::withdraw_affirmation_as_mediator { .. } => {
                            "Settlement.withdraw_affirmation_as_mediator"
                        }
                        Self::reject_instruction_as_mediator { .. } => {
                            "Settlement.reject_instruction_as_mediator"
                        }
                        Self::lock_instruction { .. } => "Settlement.lock_instruction",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SettlementCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: create_venue { .. } => { & ["Registers a new venue." , "" , "* `details` - Extra details about a venue" , "* `signers` - Array of signers that are allowed to sign receipts for this venue" , "* `typ` - Type of venue being created" ,] } , Self :: update_venue_details { .. } => { & ["Edit a venue's details." , "" , "* `id` specifies the ID of the venue to edit." , "* `details` specifies the updated venue details." ,] } , Self :: update_venue_type { .. } => { & ["Edit a venue's type." , "" , "* `id` specifies the ID of the venue to edit." , "* `type` specifies the new type of the venue." ,] } , Self :: affirm_with_receipts { .. } => { & ["Affirms an instruction using receipts for offchain transfers." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being affirmed." , "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: set_venue_filtering { .. } => { & ["Enables or disabled venue filtering for a token." , "" , "# Arguments" , "* `asset_id` - AssetId of the token in question." , "* `enabled` - Boolean that decides if the filtering should be enabled." , "" , "# Permissions" , "* Asset" ,] } , Self :: allow_venues { .. } => { & ["Allows additional venues to create instructions involving an asset." , "" , "* `asset_id` - AssetId of the token in question." , "* `venues` - Array of venues that are allowed to create instructions for the token in question." , "" , "# Permissions" , "* Asset" ,] } , Self :: disallow_venues { .. } => { & ["Revokes permission given to venues for creating instructions involving a particular asset." , "" , "* `asset_id` - AssetId of the token in question." , "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question." , "" , "# Permissions" , "* Asset" ,] } , Self :: update_venue_signers { .. } => { & ["Edit a venue's signers." , "* `id` specifies the ID of the venue to edit." , "* `signers` specifies the signers to add/remove." , "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false." ,] } , Self :: execute_manual_instruction { .. } => { & ["Manually executes an instruction." , "" , "# Arguments" , "* `id`: The [`InstructionId`] of the instruction to be executed." , "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction." , "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]." , "* `fungible_transfers`: The number of fungible legs in the instruction." , "* `nfts_transfers`: The number of nfts being transferred in the instruction." , "* `offchain_transfers`: The number of offchain legs in the instruction." , "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction." , "If the `weight_limit` is less than the required amount, the instruction will fail execution." , "" , "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters." ,] } , Self :: add_instruction { .. } => { & ["Adds a new instruction." , "" , "# Arguments" , "* `venue_id`: The optional [`VenueId`] of the venue this instruction belongs to." , "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled." , "* `trade_date`: Optional date from which people can interact with this instruction." , "* `value_date`: Optional date after which the instruction should be settled (not enforced)." , "* `legs`: A vector of all [`Leg`] included in this instruction." , "* `memo`: An optional [`Memo`] field for this instruction." ,] } , Self :: add_and_affirm_instruction { .. } => { & ["Adds and affirms a new instruction." , "" , "# Arguments" , "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to." , "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled." , "* `trade_date`: Optional date from which people can interact with this instruction." , "* `value_date`: Optional date after which the instruction should be settled (not enforced)." , "* `legs`: A vector of all [`Leg`] included in this instruction." , "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "* `memo`: An optional [`Memo`] field for this instruction." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: affirm_instruction { .. } => { & ["Provide affirmation to an existing instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being affirmed." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: withdraw_affirmation { .. } => { & ["Withdraw an affirmation for a given instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: reject_instruction { .. } => { & ["Rejects an existing instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being rejected." , "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: execute_scheduled_instruction { .. } => { & ["Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction." ,] } , Self :: affirm_with_receipts_with_count { .. } => { & ["Affirms an instruction using receipts for offchain transfers." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being affirmed." , "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic." , "" , "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: affirm_instruction_with_count { .. } => { & ["Provide affirmation to an existing instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being affirmed." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic." , "" , "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: reject_instruction_with_count { .. } => { & ["Rejects an existing instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction being rejected." , "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it." , "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic." , "" , "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: withdraw_affirmation_with_count { .. } => { & ["Withdraw an affirmation for a given instruction." , "" , "# Arguments" , "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn." , "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal." , "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic." , "" , "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: add_instruction_with_mediators { .. } => { & ["Adds a new instruction with mediators." , "" , "# Arguments" , "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to." , "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled." , "* `trade_date`: Optional date from which people can interact with this instruction." , "* `value_date`: Optional date after which the instruction should be settled (not enforced)." , "* `legs`: A vector of all [`Leg`] included in this instruction." , "* `instruction_memo`: An optional [`Memo`] field for this instruction." , "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction." ,] } , Self :: add_and_affirm_with_mediators { .. } => { & ["Adds and affirms a new instruction with mediators." , "" , "# Arguments" , "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to." , "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled." , "* `trade_date`: Optional date from which people can interact with this instruction." , "* `value_date`: Optional date after which the instruction should be settled (not enforced)." , "* `legs`: A vector of all [`Leg`] included in this instruction." , "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation." , "* `instruction_memo`: An optional [`Memo`] field for this instruction." , "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction." , "" , "# Permissions" , "* Portfolio" ,] } , Self :: affirm_instruction_as_mediator { .. } => { & ["Affirms the instruction as a mediator - should only be called by mediators, otherwise it will fail." , "" , "# Arguments" , "* `origin`: The secondary key of the sender." , "* `instruction_id`: The [`InstructionId`] that will be affirmed by the mediator." , "* `expiry`: An Optional value for defining when the affirmation will expire (None means it will always be valid)." ,] } , Self :: withdraw_affirmation_as_mediator { .. } => { & ["Removes the mediator's affirmation for the instruction - should only be called by mediators, otherwise it will fail." , "" , "# Arguments" , "* `origin`: The secondary key of the sender." , "* `instruction_id`: The [`InstructionId`] that will have the affirmation removed." ,] } , Self :: reject_instruction_as_mediator { .. } => { & ["Rejects an existing instruction - should only be called by mediators, otherwise it will fail." , "" , "# Arguments" , "* `instruction_id` - the [`InstructionId`] of the instruction being rejected." , "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic." , "" , "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count." ,] } , Self :: lock_instruction { .. } => { & ["Moves the instruction status to `LockedForExecution`. This function must be called by a" , "mediator of the instruction and will only suceed if the following conditions are met:" , "- All affirmations have been received." , "- Instruction is pending or has failed at least one time." , "- All mediator's affirmations are still valid." , "- All assets are in the allowed venue list." , "- All senders have the right amount of assets being transferred." , "- All senders and receivers are compliant and have valid CDD claims." , "- All assets' statistics are still valid." , "- There are no frozen assets." , "" , "# Arguments" , "* `origin` - The origin of the call, specifying the caller." , "* `inst_id` - The [`InstructionId`] of the instruction to be locked." , "* `weight_limit` - A maximum [`Weight`] value to be charged for locking the instruction." ,] } , _ => & [""] , }
                }
            }
            impl From<SettlementCall> for &'static str {
                fn from(v: SettlementCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SettlementCall> for &'static str {
                fn from(v: &SettlementCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SettlementError {
                #[doc = "Venue does not exist."]
                #[codec(index = 0u8)]
                InvalidVenue,
                #[doc = "Sender does not have required permissions."]
                #[codec(index = 1u8)]
                Unauthorized,
                #[doc = "Instruction has not been affirmed."]
                #[codec(index = 2u8)]
                InstructionNotAffirmed,
                #[doc = "Signer is not authorized by the venue."]
                #[codec(index = 3u8)]
                UnauthorizedSigner,
                #[doc = "Receipt already used."]
                #[codec(index = 4u8)]
                ReceiptAlreadyClaimed,
                #[doc = "Venue does not have required permissions."]
                #[codec(index = 5u8)]
                UnauthorizedVenue,
                #[doc = "Instruction has invalid dates"]
                #[codec(index = 6u8)]
                InstructionDatesInvalid,
                #[doc = "Instruction's target settle block reached."]
                #[codec(index = 7u8)]
                InstructionSettleBlockPassed,
                #[doc = "Offchain signature is invalid."]
                #[codec(index = 8u8)]
                InvalidSignature,
                #[doc = "Sender and receiver are the same."]
                #[codec(index = 9u8)]
                SameSenderReceiver,
                #[doc = "The provided settlement block number is in the past and cannot be used by the scheduler."]
                #[codec(index = 10u8)]
                SettleOnPastBlock,
                #[doc = "The current instruction affirmation status does not support the requested action."]
                #[codec(index = 11u8)]
                UnexpectedAffirmationStatus,
                #[doc = "Scheduling of an instruction fails."]
                #[codec(index = 12u8)]
                FailedToSchedule,
                #[doc = "Instruction status is unknown"]
                #[codec(index = 13u8)]
                UnknownInstruction,
                #[doc = "Signer is already added to venue."]
                #[codec(index = 14u8)]
                SignerAlreadyExists,
                #[doc = "Signer is not added to venue."]
                #[codec(index = 15u8)]
                SignerDoesNotExist,
                #[doc = "Instruction leg amount can't be zero."]
                #[codec(index = 16u8)]
                ZeroAmount,
                #[doc = "Instruction settlement block has not yet been reached."]
                #[codec(index = 17u8)]
                InstructionSettleBlockNotReached,
                #[doc = "The caller is not a party of this instruction."]
                #[codec(index = 18u8)]
                CallerIsNotAParty,
                #[doc = "The number of nfts being transferred in the instruction was exceeded."]
                #[codec(index = 19u8)]
                MaxNumberOfNFTsExceeded,
                #[doc = "The given number of nfts being transferred was underestimated."]
                #[codec(index = 20u8)]
                NumberOfTransferredNFTsUnderestimated,
                #[doc = "Off-chain receipts can only be used for off-chain leg type."]
                #[codec(index = 21u8)]
                ReceiptForInvalidLegType,
                #[doc = "The maximum weight limit for executing the function was exceeded."]
                #[codec(index = 22u8)]
                WeightLimitExceeded,
                #[doc = "The maximum number of fungible assets was exceeded."]
                #[codec(index = 23u8)]
                MaxNumberOfFungibleAssetsExceeded,
                #[doc = "The maximum number of off-chain assets was exceeded."]
                #[codec(index = 24u8)]
                MaxNumberOfOffChainAssetsExceeded,
                #[doc = "The given number of fungible transfers was underestimated."]
                #[codec(index = 25u8)]
                NumberOfFungibleTransfersUnderestimated,
                #[doc = "AssetId could not be found on chain."]
                #[codec(index = 26u8)]
                UnexpectedOFFChainAsset,
                #[doc = "Off-Chain assets cannot be locked."]
                #[codec(index = 27u8)]
                OffChainAssetCantBeLocked,
                #[doc = "The given number of off-chain transfers was underestimated."]
                #[codec(index = 28u8)]
                NumberOfOffChainTransfersUnderestimated,
                #[doc = "No leg with the given id was found"]
                #[codec(index = 29u8)]
                LegNotFound,
                #[doc = "The input weight is less than the minimum required."]
                #[codec(index = 30u8)]
                InputWeightIsLessThanMinimum,
                #[doc = "The maximum number of receipts was exceeded."]
                #[codec(index = 31u8)]
                MaxNumberOfReceiptsExceeded,
                #[doc = "There are parties who have not affirmed the instruction."]
                #[codec(index = 32u8)]
                NotAllAffirmationsHaveBeenReceived,
                #[doc = "Only [`InstructionStatus::Pending`] or [`InstructionStatus::Failed`] instructions can be executed."]
                #[codec(index = 33u8)]
                InvalidInstructionStatusForExecution,
                #[doc = "The instruction failed to release asset locks or transfer the assets."]
                #[codec(index = 34u8)]
                FailedToReleaseLockOrTransferAssets,
                #[doc = "No duplicate uid are allowed for different receipts."]
                #[codec(index = 35u8)]
                DuplicateReceiptUid,
                #[doc = "The instruction id in all receipts must match the extrinsic parameter."]
                #[codec(index = 36u8)]
                ReceiptInstructionIdMissmatch,
                #[doc = "Multiple receipts for the same leg are not allowed."]
                #[codec(index = 37u8)]
                MultipleReceiptsForOneLeg,
                #[doc = "An invalid has been reached."]
                #[codec(index = 38u8)]
                UnexpectedLegStatus,
                #[doc = "The maximum number of venue signers was exceeded."]
                #[codec(index = 39u8)]
                NumberOfVenueSignersExceeded,
                #[doc = "The caller is not a mediator in the instruction."]
                #[codec(index = 40u8)]
                CallerIsNotAMediator,
                #[doc = "The mediator's expiry date must be in the future."]
                #[codec(index = 41u8)]
                InvalidExpiryDate,
                #[doc = "The expiry date for the mediator's affirmation has passed."]
                #[codec(index = 42u8)]
                MediatorAffirmationExpired,
                #[doc = "Offchain assets must have a venue."]
                #[codec(index = 43u8)]
                OffChainAssetsMustHaveAVenue,
                #[doc = "Unexpected settlement type."]
                #[codec(index = 44u8)]
                UnexpectedSettlementType,
                #[doc = "[`InstructionStatus::Unknow`] can't be rejected."]
                #[codec(index = 45u8)]
                InvalidInstructionStatusForRejection,
                #[doc = "All locked instructions must register a lock timestamp."]
                #[codec(index = 46u8)]
                LockTimestampNotFound,
                #[doc = "The instruction has been locked for too much time."]
                #[codec(index = 47u8)]
                ExceededMaximumLockingPeriod,
                #[doc = "Not all conditions for transferring the asset have been met."]
                #[codec(index = 48u8)]
                FailedAssetTransferringConditions,
                #[doc = "Locked instructions can't have affirmations withdrawn."]
                #[codec(index = 49u8)]
                InvalidInstructionStatusForWithdrawal,
                #[doc = "TaskName cannot exceed 32 bytes."]
                #[codec(index = 50u8)]
                InvalidTaskName,
            }
            impl SettlementError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InvalidVenue => "Settlement.InvalidVenue",
                        Self::Unauthorized => "Settlement.Unauthorized",
                        Self::InstructionNotAffirmed => "Settlement.InstructionNotAffirmed",
                        Self::UnauthorizedSigner => "Settlement.UnauthorizedSigner",
                        Self::ReceiptAlreadyClaimed => "Settlement.ReceiptAlreadyClaimed",
                        Self::UnauthorizedVenue => "Settlement.UnauthorizedVenue",
                        Self::InstructionDatesInvalid => "Settlement.InstructionDatesInvalid",
                        Self::InstructionSettleBlockPassed => {
                            "Settlement.InstructionSettleBlockPassed"
                        }
                        Self::InvalidSignature => "Settlement.InvalidSignature",
                        Self::SameSenderReceiver => "Settlement.SameSenderReceiver",
                        Self::SettleOnPastBlock => "Settlement.SettleOnPastBlock",
                        Self::UnexpectedAffirmationStatus => {
                            "Settlement.UnexpectedAffirmationStatus"
                        }
                        Self::FailedToSchedule => "Settlement.FailedToSchedule",
                        Self::UnknownInstruction => "Settlement.UnknownInstruction",
                        Self::SignerAlreadyExists => "Settlement.SignerAlreadyExists",
                        Self::SignerDoesNotExist => "Settlement.SignerDoesNotExist",
                        Self::ZeroAmount => "Settlement.ZeroAmount",
                        Self::InstructionSettleBlockNotReached => {
                            "Settlement.InstructionSettleBlockNotReached"
                        }
                        Self::CallerIsNotAParty => "Settlement.CallerIsNotAParty",
                        Self::MaxNumberOfNFTsExceeded => "Settlement.MaxNumberOfNFTsExceeded",
                        Self::NumberOfTransferredNFTsUnderestimated => {
                            "Settlement.NumberOfTransferredNFTsUnderestimated"
                        }
                        Self::ReceiptForInvalidLegType => "Settlement.ReceiptForInvalidLegType",
                        Self::WeightLimitExceeded => "Settlement.WeightLimitExceeded",
                        Self::MaxNumberOfFungibleAssetsExceeded => {
                            "Settlement.MaxNumberOfFungibleAssetsExceeded"
                        }
                        Self::MaxNumberOfOffChainAssetsExceeded => {
                            "Settlement.MaxNumberOfOffChainAssetsExceeded"
                        }
                        Self::NumberOfFungibleTransfersUnderestimated => {
                            "Settlement.NumberOfFungibleTransfersUnderestimated"
                        }
                        Self::UnexpectedOFFChainAsset => "Settlement.UnexpectedOFFChainAsset",
                        Self::OffChainAssetCantBeLocked => "Settlement.OffChainAssetCantBeLocked",
                        Self::NumberOfOffChainTransfersUnderestimated => {
                            "Settlement.NumberOfOffChainTransfersUnderestimated"
                        }
                        Self::LegNotFound => "Settlement.LegNotFound",
                        Self::InputWeightIsLessThanMinimum => {
                            "Settlement.InputWeightIsLessThanMinimum"
                        }
                        Self::MaxNumberOfReceiptsExceeded => {
                            "Settlement.MaxNumberOfReceiptsExceeded"
                        }
                        Self::NotAllAffirmationsHaveBeenReceived => {
                            "Settlement.NotAllAffirmationsHaveBeenReceived"
                        }
                        Self::InvalidInstructionStatusForExecution => {
                            "Settlement.InvalidInstructionStatusForExecution"
                        }
                        Self::FailedToReleaseLockOrTransferAssets => {
                            "Settlement.FailedToReleaseLockOrTransferAssets"
                        }
                        Self::DuplicateReceiptUid => "Settlement.DuplicateReceiptUid",
                        Self::ReceiptInstructionIdMissmatch => {
                            "Settlement.ReceiptInstructionIdMissmatch"
                        }
                        Self::MultipleReceiptsForOneLeg => "Settlement.MultipleReceiptsForOneLeg",
                        Self::UnexpectedLegStatus => "Settlement.UnexpectedLegStatus",
                        Self::NumberOfVenueSignersExceeded => {
                            "Settlement.NumberOfVenueSignersExceeded"
                        }
                        Self::CallerIsNotAMediator => "Settlement.CallerIsNotAMediator",
                        Self::InvalidExpiryDate => "Settlement.InvalidExpiryDate",
                        Self::MediatorAffirmationExpired => "Settlement.MediatorAffirmationExpired",
                        Self::OffChainAssetsMustHaveAVenue => {
                            "Settlement.OffChainAssetsMustHaveAVenue"
                        }
                        Self::UnexpectedSettlementType => "Settlement.UnexpectedSettlementType",
                        Self::InvalidInstructionStatusForRejection => {
                            "Settlement.InvalidInstructionStatusForRejection"
                        }
                        Self::LockTimestampNotFound => "Settlement.LockTimestampNotFound",
                        Self::ExceededMaximumLockingPeriod => {
                            "Settlement.ExceededMaximumLockingPeriod"
                        }
                        Self::FailedAssetTransferringConditions => {
                            "Settlement.FailedAssetTransferringConditions"
                        }
                        Self::InvalidInstructionStatusForWithdrawal => {
                            "Settlement.InvalidInstructionStatusForWithdrawal"
                        }
                        Self::InvalidTaskName => "Settlement.InvalidTaskName",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SettlementError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: InvalidVenue => { & ["Venue does not exist." ,] } , Self :: Unauthorized => { & ["Sender does not have required permissions." ,] } , Self :: InstructionNotAffirmed => { & ["Instruction has not been affirmed." ,] } , Self :: UnauthorizedSigner => { & ["Signer is not authorized by the venue." ,] } , Self :: ReceiptAlreadyClaimed => { & ["Receipt already used." ,] } , Self :: UnauthorizedVenue => { & ["Venue does not have required permissions." ,] } , Self :: InstructionDatesInvalid => { & ["Instruction has invalid dates" ,] } , Self :: InstructionSettleBlockPassed => { & ["Instruction's target settle block reached." ,] } , Self :: InvalidSignature => { & ["Offchain signature is invalid." ,] } , Self :: SameSenderReceiver => { & ["Sender and receiver are the same." ,] } , Self :: SettleOnPastBlock => { & ["The provided settlement block number is in the past and cannot be used by the scheduler." ,] } , Self :: UnexpectedAffirmationStatus => { & ["The current instruction affirmation status does not support the requested action." ,] } , Self :: FailedToSchedule => { & ["Scheduling of an instruction fails." ,] } , Self :: UnknownInstruction => { & ["Instruction status is unknown" ,] } , Self :: SignerAlreadyExists => { & ["Signer is already added to venue." ,] } , Self :: SignerDoesNotExist => { & ["Signer is not added to venue." ,] } , Self :: ZeroAmount => { & ["Instruction leg amount can't be zero." ,] } , Self :: InstructionSettleBlockNotReached => { & ["Instruction settlement block has not yet been reached." ,] } , Self :: CallerIsNotAParty => { & ["The caller is not a party of this instruction." ,] } , Self :: MaxNumberOfNFTsExceeded => { & ["The number of nfts being transferred in the instruction was exceeded." ,] } , Self :: NumberOfTransferredNFTsUnderestimated => { & ["The given number of nfts being transferred was underestimated." ,] } , Self :: ReceiptForInvalidLegType => { & ["Off-chain receipts can only be used for off-chain leg type." ,] } , Self :: WeightLimitExceeded => { & ["The maximum weight limit for executing the function was exceeded." ,] } , Self :: MaxNumberOfFungibleAssetsExceeded => { & ["The maximum number of fungible assets was exceeded." ,] } , Self :: MaxNumberOfOffChainAssetsExceeded => { & ["The maximum number of off-chain assets was exceeded." ,] } , Self :: NumberOfFungibleTransfersUnderestimated => { & ["The given number of fungible transfers was underestimated." ,] } , Self :: UnexpectedOFFChainAsset => { & ["AssetId could not be found on chain." ,] } , Self :: OffChainAssetCantBeLocked => { & ["Off-Chain assets cannot be locked." ,] } , Self :: NumberOfOffChainTransfersUnderestimated => { & ["The given number of off-chain transfers was underestimated." ,] } , Self :: LegNotFound => { & ["No leg with the given id was found" ,] } , Self :: InputWeightIsLessThanMinimum => { & ["The input weight is less than the minimum required." ,] } , Self :: MaxNumberOfReceiptsExceeded => { & ["The maximum number of receipts was exceeded." ,] } , Self :: NotAllAffirmationsHaveBeenReceived => { & ["There are parties who have not affirmed the instruction." ,] } , Self :: InvalidInstructionStatusForExecution => { & ["Only [`InstructionStatus::Pending`] or [`InstructionStatus::Failed`] instructions can be executed." ,] } , Self :: FailedToReleaseLockOrTransferAssets => { & ["The instruction failed to release asset locks or transfer the assets." ,] } , Self :: DuplicateReceiptUid => { & ["No duplicate uid are allowed for different receipts." ,] } , Self :: ReceiptInstructionIdMissmatch => { & ["The instruction id in all receipts must match the extrinsic parameter." ,] } , Self :: MultipleReceiptsForOneLeg => { & ["Multiple receipts for the same leg are not allowed." ,] } , Self :: UnexpectedLegStatus => { & ["An invalid has been reached." ,] } , Self :: NumberOfVenueSignersExceeded => { & ["The maximum number of venue signers was exceeded." ,] } , Self :: CallerIsNotAMediator => { & ["The caller is not a mediator in the instruction." ,] } , Self :: InvalidExpiryDate => { & ["The mediator's expiry date must be in the future." ,] } , Self :: MediatorAffirmationExpired => { & ["The expiry date for the mediator's affirmation has passed." ,] } , Self :: OffChainAssetsMustHaveAVenue => { & ["Offchain assets must have a venue." ,] } , Self :: UnexpectedSettlementType => { & ["Unexpected settlement type." ,] } , Self :: InvalidInstructionStatusForRejection => { & ["[`InstructionStatus::Unknow`] can't be rejected." ,] } , Self :: LockTimestampNotFound => { & ["All locked instructions must register a lock timestamp." ,] } , Self :: ExceededMaximumLockingPeriod => { & ["The instruction has been locked for too much time." ,] } , Self :: FailedAssetTransferringConditions => { & ["Not all conditions for transferring the asset have been met." ,] } , Self :: InvalidInstructionStatusForWithdrawal => { & ["Locked instructions can't have affirmations withdrawn." ,] } , Self :: InvalidTaskName => { & ["TaskName cannot exceed 32 bytes." ,] } , _ => & [""] , }
                }
            }
            impl From<SettlementError> for &'static str {
                fn from(v: SettlementError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SettlementError> for &'static str {
                fn from(v: &SettlementError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SettlementEvent {
                #[doc = "A new venue has been created (did, venue_id, details, type)"]
                #[codec(index = 0u8)]
                VenueCreated(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::VenueId,
                    polymesh_primitives::settlement::VenueDetails,
                    polymesh_primitives::settlement::VenueType,
                ),
                #[doc = "An existing venue's details has been updated (did, venue_id, details)"]
                #[codec(index = 1u8)]
                VenueDetailsUpdated(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::VenueId,
                    polymesh_primitives::settlement::VenueDetails,
                ),
                #[doc = "An existing venue's type has been updated (did, venue_id, type)"]
                #[codec(index = 2u8)]
                VenueTypeUpdated(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::VenueId,
                    polymesh_primitives::settlement::VenueType,
                ),
                #[doc = "An instruction has been affirmed (did, portfolio, instruction_id)"]
                #[codec(index = 3u8)]
                InstructionAffirmed(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_id::PortfolioId,
                    polymesh_primitives::settlement::InstructionId,
                ),
                #[doc = "An affirmation has been withdrawn (did, portfolio, instruction_id)"]
                #[codec(index = 4u8)]
                AffirmationWithdrawn(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_id::PortfolioId,
                    polymesh_primitives::settlement::InstructionId,
                ),
                #[doc = "An instruction has been rejected (did, instruction_id)"]
                #[codec(index = 5u8)]
                InstructionRejected(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::InstructionId,
                ),
                #[doc = "A receipt has been claimed (did, instruction_id, leg_id, receipt_uid, signer, receipt metadata)"]
                #[codec(index = 6u8)]
                ReceiptClaimed(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::InstructionId,
                    polymesh_primitives::settlement::LegId,
                    u64,
                    ::polymesh_api_client::AccountId,
                    Option<polymesh_primitives::settlement::ReceiptMetadata>,
                ),
                #[doc = "Venue filtering has been enabled or disabled for an asset (did, AssetId, filtering_enabled)"]
                #[codec(index = 7u8)]
                VenueFiltering(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    bool,
                ),
                #[doc = "Venues added to allow list (did, AssetId, vec<venue_id>)"]
                #[codec(index = 8u8)]
                VenuesAllowed(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
                ),
                #[doc = "Venues added to block list (did, AssetId, vec<venue_id>)"]
                #[codec(index = 9u8)]
                VenuesBlocked(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::alloc::vec::Vec<polymesh_primitives::settlement::VenueId>,
                ),
                #[doc = "Execution of a leg failed (did, instruction_id, leg_id)"]
                #[codec(index = 10u8)]
                LegFailedExecution(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::InstructionId,
                    polymesh_primitives::settlement::LegId,
                ),
                #[doc = "Instruction executed successfully(did, instruction_id)"]
                #[codec(index = 11u8)]
                InstructionExecuted(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::InstructionId,
                ),
                #[doc = "Venue not part of the token's allow list (did, AssetId, venue_id)"]
                #[codec(index = 12u8)]
                VenueUnauthorized(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::settlement::VenueId,
                ),
                #[doc = "Scheduling of instruction fails."]
                #[codec(index = 13u8)]
                SchedulingFailed(
                    polymesh_primitives::settlement::InstructionId,
                    sp_runtime::DispatchError,
                ),
                #[doc = "Instruction is rescheduled."]
                #[doc = "(caller DID, instruction_id)"]
                #[codec(index = 14u8)]
                InstructionRescheduled(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::InstructionId,
                ),
                #[doc = "An existing venue's signers has been updated (did, venue_id, signers, update_type)"]
                #[codec(index = 15u8)]
                VenueSignersUpdated(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::VenueId,
                    ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                    bool,
                ),
                #[doc = "Settlement manually executed (did, id)"]
                #[codec(index = 16u8)]
                SettlementManuallyExecuted(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::InstructionId,
                ),
                #[doc = "A new instruction has been created"]
                #[doc = "(did, venue_id, instruction_id, settlement_type, trade_date, value_date, legs, memo)"]
                #[codec(index = 17u8)]
                InstructionCreated(
                    ::polymesh_api_client::IdentityId,
                    Option<polymesh_primitives::settlement::VenueId>,
                    polymesh_primitives::settlement::InstructionId,
                    polymesh_primitives::settlement::SettlementType<u32>,
                    Option<u64>,
                    Option<u64>,
                    ::alloc::vec::Vec<polymesh_primitives::settlement::Leg>,
                    Option<polymesh_primitives::Memo>,
                ),
                #[doc = "Failed to execute instruction."]
                #[codec(index = 18u8)]
                FailedToExecuteInstruction(
                    polymesh_primitives::settlement::InstructionId,
                    sp_runtime::DispatchError,
                ),
                #[doc = "An instruction has been automatically affirmed."]
                #[doc = "Parameters: [`IdentityId`] of the caller, [`PortfolioId`] of the receiver, and [`InstructionId`] of the instruction."]
                #[codec(index = 19u8)]
                InstructionAutomaticallyAffirmed(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::identity_id::PortfolioId,
                    polymesh_primitives::settlement::InstructionId,
                ),
                #[doc = "An instruction has affirmed by a mediator."]
                #[doc = "Parameters: [`IdentityId`] of the mediator and [`InstructionId`] of the instruction."]
                #[codec(index = 20u8)]
                MediatorAffirmationReceived(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::InstructionId,
                    Option<u64>,
                ),
                #[doc = "An instruction affirmation has been withdrawn by a mediator."]
                #[doc = "Parameters: [`IdentityId`] of the mediator and [`InstructionId`] of the instruction."]
                #[codec(index = 21u8)]
                MediatorAffirmationWithdrawn(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::InstructionId,
                ),
                #[doc = "An instruction with mediators has been created."]
                #[doc = "Parameters: [`InstructionId`] of the instruction and the [`IdentityId`] of all mediators."]
                #[codec(index = 22u8)]
                InstructionMediators(
                    polymesh_primitives::settlement::InstructionId,
                    ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
                ),
                #[doc = "An instruction has been sucessfully locked for execution"]
                #[doc = ""]
                #[doc = "Parameters:"]
                #[doc = "- `IdentityId`: The [`IdentityId`] of the caller."]
                #[doc = "- `InstructionId`: The [`InstructionId`] of the instruction."]
                #[codec(index = 23u8)]
                InstructionLocked(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::settlement::InstructionId,
                ),
            }
            impl SettlementEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::VenueCreated(_, _, _, _) => "Settlement.VenueCreated",
                        Self::VenueDetailsUpdated(_, _, _) => "Settlement.VenueDetailsUpdated",
                        Self::VenueTypeUpdated(_, _, _) => "Settlement.VenueTypeUpdated",
                        Self::InstructionAffirmed(_, _, _) => "Settlement.InstructionAffirmed",
                        Self::AffirmationWithdrawn(_, _, _) => "Settlement.AffirmationWithdrawn",
                        Self::InstructionRejected(_, _) => "Settlement.InstructionRejected",
                        Self::ReceiptClaimed(_, _, _, _, _, _) => "Settlement.ReceiptClaimed",
                        Self::VenueFiltering(_, _, _) => "Settlement.VenueFiltering",
                        Self::VenuesAllowed(_, _, _) => "Settlement.VenuesAllowed",
                        Self::VenuesBlocked(_, _, _) => "Settlement.VenuesBlocked",
                        Self::LegFailedExecution(_, _, _) => "Settlement.LegFailedExecution",
                        Self::InstructionExecuted(_, _) => "Settlement.InstructionExecuted",
                        Self::VenueUnauthorized(_, _, _) => "Settlement.VenueUnauthorized",
                        Self::SchedulingFailed(_, _) => "Settlement.SchedulingFailed",
                        Self::InstructionRescheduled(_, _) => "Settlement.InstructionRescheduled",
                        Self::VenueSignersUpdated(_, _, _, _) => "Settlement.VenueSignersUpdated",
                        Self::SettlementManuallyExecuted(_, _) => {
                            "Settlement.SettlementManuallyExecuted"
                        }
                        Self::InstructionCreated(_, _, _, _, _, _, _, _) => {
                            "Settlement.InstructionCreated"
                        }
                        Self::FailedToExecuteInstruction(_, _) => {
                            "Settlement.FailedToExecuteInstruction"
                        }
                        Self::InstructionAutomaticallyAffirmed(_, _, _) => {
                            "Settlement.InstructionAutomaticallyAffirmed"
                        }
                        Self::MediatorAffirmationReceived(_, _, _) => {
                            "Settlement.MediatorAffirmationReceived"
                        }
                        Self::MediatorAffirmationWithdrawn(_, _) => {
                            "Settlement.MediatorAffirmationWithdrawn"
                        }
                        Self::InstructionMediators(_, _) => "Settlement.InstructionMediators",
                        Self::InstructionLocked(_, _) => "Settlement.InstructionLocked",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SettlementEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: VenueCreated (_ , _ , _ , _) => { & ["A new venue has been created (did, venue_id, details, type)" ,] } , Self :: VenueDetailsUpdated (_ , _ , _) => { & ["An existing venue's details has been updated (did, venue_id, details)" ,] } , Self :: VenueTypeUpdated (_ , _ , _) => { & ["An existing venue's type has been updated (did, venue_id, type)" ,] } , Self :: InstructionAffirmed (_ , _ , _) => { & ["An instruction has been affirmed (did, portfolio, instruction_id)" ,] } , Self :: AffirmationWithdrawn (_ , _ , _) => { & ["An affirmation has been withdrawn (did, portfolio, instruction_id)" ,] } , Self :: InstructionRejected (_ , _) => { & ["An instruction has been rejected (did, instruction_id)" ,] } , Self :: ReceiptClaimed (_ , _ , _ , _ , _ , _) => { & ["A receipt has been claimed (did, instruction_id, leg_id, receipt_uid, signer, receipt metadata)" ,] } , Self :: VenueFiltering (_ , _ , _) => { & ["Venue filtering has been enabled or disabled for an asset (did, AssetId, filtering_enabled)" ,] } , Self :: VenuesAllowed (_ , _ , _) => { & ["Venues added to allow list (did, AssetId, vec<venue_id>)" ,] } , Self :: VenuesBlocked (_ , _ , _) => { & ["Venues added to block list (did, AssetId, vec<venue_id>)" ,] } , Self :: LegFailedExecution (_ , _ , _) => { & ["Execution of a leg failed (did, instruction_id, leg_id)" ,] } , Self :: InstructionExecuted (_ , _) => { & ["Instruction executed successfully(did, instruction_id)" ,] } , Self :: VenueUnauthorized (_ , _ , _) => { & ["Venue not part of the token's allow list (did, AssetId, venue_id)" ,] } , Self :: SchedulingFailed (_ , _) => { & ["Scheduling of instruction fails." ,] } , Self :: InstructionRescheduled (_ , _) => { & ["Instruction is rescheduled." , "(caller DID, instruction_id)" ,] } , Self :: VenueSignersUpdated (_ , _ , _ , _) => { & ["An existing venue's signers has been updated (did, venue_id, signers, update_type)" ,] } , Self :: SettlementManuallyExecuted (_ , _) => { & ["Settlement manually executed (did, id)" ,] } , Self :: InstructionCreated (_ , _ , _ , _ , _ , _ , _ , _) => { & ["A new instruction has been created" , "(did, venue_id, instruction_id, settlement_type, trade_date, value_date, legs, memo)" ,] } , Self :: FailedToExecuteInstruction (_ , _) => { & ["Failed to execute instruction." ,] } , Self :: InstructionAutomaticallyAffirmed (_ , _ , _) => { & ["An instruction has been automatically affirmed." , "Parameters: [`IdentityId`] of the caller, [`PortfolioId`] of the receiver, and [`InstructionId`] of the instruction." ,] } , Self :: MediatorAffirmationReceived (_ , _ , _) => { & ["An instruction has affirmed by a mediator." , "Parameters: [`IdentityId`] of the mediator and [`InstructionId`] of the instruction." ,] } , Self :: MediatorAffirmationWithdrawn (_ , _) => { & ["An instruction affirmation has been withdrawn by a mediator." , "Parameters: [`IdentityId`] of the mediator and [`InstructionId`] of the instruction." ,] } , Self :: InstructionMediators (_ , _) => { & ["An instruction with mediators has been created." , "Parameters: [`InstructionId`] of the instruction and the [`IdentityId`] of all mediators." ,] } , Self :: InstructionLocked (_ , _) => { & ["An instruction has been sucessfully locked for execution" , "" , "Parameters:" , "- `IdentityId`: The [`IdentityId`] of the caller." , "- `InstructionId`: The [`InstructionId`] of the instruction." ,] } , _ => & [""] , }
                }
            }
            impl From<SettlementEvent> for &'static str {
                fn from(v: SettlementEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SettlementEvent> for &'static str {
                fn from(v: &SettlementEvent) -> Self {
                    v.as_static_str()
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Version(pub u8);
        }
    }
    pub mod pallet_staking {
        use super::*;
        pub mod pallet {
            use super::*;
            pub mod pallet {
                use super::*;
                #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum StakingCall {
                    #[doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"]
                    #[doc = "be the account that controls it."]
                    #[doc = ""]
                    #[doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_ by the stash account."]
                    #[doc = ""]
                    #[doc = "Emits `Bonded`."]
                    #[doc = "## Complexity"]
                    #[doc = "- Independent of the arguments. Moderate complexity."]
                    #[doc = "- O(1)."]
                    #[doc = "- Three extra DB entries."]
                    #[doc = ""]
                    #[doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"]
                    #[doc = "unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed"]
                    #[doc = "as dust."]
                    #[codec(index = 0u8)]
                    bond {
                        #[codec(compact)]
                        value: u128,
                        payee: pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
                    },
                    #[doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"]
                    #[doc = "for staking."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
                    #[doc = ""]
                    #[doc = "Use this if there are additional funds in your stash account that you wish to bond."]
                    #[doc = "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose"]
                    #[doc = "any limitation on the amount that can be added."]
                    #[doc = ""]
                    #[doc = "Emits `Bonded`."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "- Independent of the arguments. Insignificant complexity."]
                    #[doc = "- O(1)."]
                    #[codec(index = 1u8)]
                    bond_extra {
                        #[codec(compact)]
                        max_additional: u128,
                    },
                    #[doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"]
                    #[doc = "period ends. If this leaves an amount actively bonded less than"]
                    #[doc = "[`asset::existential_deposit`], then it is increased to the full amount."]
                    #[doc = ""]
                    #[doc = "The stash may be chilled if the ledger total amount falls to 0 after unbonding."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
                    #[doc = ""]
                    #[doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"]
                    #[doc = "the funds out of management ready for transfer."]
                    #[doc = ""]
                    #[doc = "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)"]
                    #[doc = "can co-exists at the same time. If there are no unlocking chunks slots available"]
                    #[doc = "[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible)."]
                    #[doc = ""]
                    #[doc = "If a user encounters the `InsufficientBond` error when calling this extrinsic,"]
                    #[doc = "they should call `chill` first in order to free up their bonded funds."]
                    #[doc = ""]
                    #[doc = "Emits `Unbonded`."]
                    #[doc = ""]
                    #[doc = "See also [`Call::withdraw_unbonded`]."]
                    #[codec(index = 2u8)]
                    unbond {
                        #[codec(compact)]
                        value: u128,
                    },
                    #[doc = "Remove any unlocked chunks from the `unlocking` queue from our management."]
                    #[doc = ""]
                    #[doc = "This essentially frees up that balance to be used by the stash account to do whatever"]
                    #[doc = "it wants."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_ by the controller."]
                    #[doc = ""]
                    #[doc = "Emits `Withdrawn`."]
                    #[doc = ""]
                    #[doc = "See also [`Call::unbond`]."]
                    #[doc = ""]
                    #[doc = "## Parameters"]
                    #[doc = ""]
                    #[doc = "- `num_slashing_spans` indicates the number of metadata slashing spans to clear when"]
                    #[doc = "this call results in a complete removal of all the data related to the stash account."]
                    #[doc = "In this case, the `num_slashing_spans` must be larger or equal to the number of"]
                    #[doc = "slashing spans associated with the stash account in the [`SlashingSpans`] storage type,"]
                    #[doc = "otherwise the call will fail. The call weight is directly proportional to"]
                    #[doc = "`num_slashing_spans`."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "O(S) where S is the number of slashing spans to remove"]
                    #[doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."]
                    #[codec(index = 3u8)]
                    withdraw_unbonded { num_slashing_spans: u32 },
                    #[doc = "Declare the desire to validate for the origin controller."]
                    #[doc = ""]
                    #[doc = "Effects will be felt at the beginning of the next era."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
                    #[codec(index = 4u8)]
                    validate {
                        prefs: pallet_staking::ValidatorPrefs,
                    },
                    #[doc = "Declare the desire to nominate `targets` for the origin controller."]
                    #[doc = ""]
                    #[doc = "Effects will be felt at the beginning of the next era."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "- The transaction's complexity is proportional to the size of `targets` (N)"]
                    #[doc = "which is capped at CompactAssignments::LIMIT (T::MaxNominations)."]
                    #[doc = "- Both the reads and writes follow a similar pattern."]
                    #[codec(index = 5u8)]
                    nominate {
                        targets: ::alloc::vec::Vec<
                            ::polymesh_api_client::MultiAddress<
                                ::polymesh_api_client::AccountId,
                                u32,
                            >,
                        >,
                    },
                    #[doc = "Declare no desire to either validate or nominate."]
                    #[doc = ""]
                    #[doc = "Effects will be felt at the beginning of the next era."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "- Independent of the arguments. Insignificant complexity."]
                    #[doc = "- Contains one read."]
                    #[doc = "- Writes are limited to the `origin` account key."]
                    #[codec(index = 6u8)]
                    chill,
                    #[doc = "(Re-)set the payment target for a controller."]
                    #[doc = ""]
                    #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "- O(1)"]
                    #[doc = "- Independent of the arguments. Insignificant complexity."]
                    #[doc = "- Contains a limited number of reads."]
                    #[doc = "- Writes are limited to the `origin` account key."]
                    #[doc = "---------"]
                    #[codec(index = 7u8)]
                    set_payee {
                        payee: pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
                    },
                    #[doc = "(Re-)sets the controller of a stash to the stash itself. This function previously"]
                    #[doc = "accepted a `controller` argument to set the controller to an account other than the"]
                    #[doc = "stash itself. This functionality has now been removed, now only setting the controller"]
                    #[doc = "to the stash, if it is not already."]
                    #[doc = ""]
                    #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "O(1)"]
                    #[doc = "- Independent of the arguments. Insignificant complexity."]
                    #[doc = "- Contains a limited number of reads."]
                    #[doc = "- Writes are limited to the `origin` account key."]
                    #[codec(index = 8u8)]
                    set_controller,
                    #[doc = "Sets the ideal number of validators."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be Root."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "O(1)"]
                    #[codec(index = 9u8)]
                    set_validator_count {
                        #[codec(compact)]
                        new: u32,
                    },
                    #[doc = "Increments the ideal number of validators up to maximum of"]
                    #[doc = "`ElectionProviderBase::MaxWinners`."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be Root."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "Same as [`Self::set_validator_count`]."]
                    #[codec(index = 10u8)]
                    increase_validator_count {
                        #[codec(compact)]
                        additional: u32,
                    },
                    #[doc = "Scale up the ideal number of validators by a factor up to maximum of"]
                    #[doc = "`ElectionProviderBase::MaxWinners`."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be Root."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "Same as [`Self::set_validator_count`]."]
                    #[codec(index = 11u8)]
                    scale_validator_count {
                        factor: ::polymesh_api_client::per_things::Percent,
                    },
                    #[doc = "Force there to be no new eras indefinitely."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be Root."]
                    #[doc = ""]
                    #[doc = "# Warning"]
                    #[doc = ""]
                    #[doc = "The election process starts multiple blocks before the end of the era."]
                    #[doc = "Thus the election process may be ongoing when this is called. In this case the"]
                    #[doc = "election will continue until the next era is triggered."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "- No arguments."]
                    #[doc = "- Weight: O(1)"]
                    #[codec(index = 12u8)]
                    force_no_eras,
                    #[doc = "Force there to be a new era at the end of the next session. After this, it will be"]
                    #[doc = "reset to normal (non-forced) behaviour."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be Root."]
                    #[doc = ""]
                    #[doc = "# Warning"]
                    #[doc = ""]
                    #[doc = "The election process starts multiple blocks before the end of the era."]
                    #[doc = "If this is called just before a new era is triggered, the election process may not"]
                    #[doc = "have enough blocks to get a result."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "- No arguments."]
                    #[doc = "- Weight: O(1)"]
                    #[codec(index = 13u8)]
                    force_new_era,
                    #[doc = "Set the validators who cannot be slashed (if any)."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be Root."]
                    #[codec(index = 14u8)]
                    set_invulnerables {
                        invulnerables: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                    },
                    #[doc = "Force a current staker to become completely unstaked, immediately."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be Root."]
                    #[doc = ""]
                    #[doc = "## Parameters"]
                    #[doc = ""]
                    #[doc = "- `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more"]
                    #[doc = "details."]
                    #[codec(index = 15u8)]
                    force_unstake {
                        stash: ::polymesh_api_client::AccountId,
                        num_slashing_spans: u32,
                    },
                    #[doc = "Force there to be a new era at the end of sessions indefinitely."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be Root."]
                    #[doc = ""]
                    #[doc = "# Warning"]
                    #[doc = ""]
                    #[doc = "The election process starts multiple blocks before the end of the era."]
                    #[doc = "If this is called just before a new era is triggered, the election process may not"]
                    #[doc = "have enough blocks to get a result."]
                    #[codec(index = 16u8)]
                    force_new_era_always,
                    #[doc = "Cancel enactment of a deferred slash."]
                    #[doc = ""]
                    #[doc = "Can be called by the `T::AdminOrigin`."]
                    #[doc = ""]
                    #[doc = "Parameters: era and indices of the slashes for that era to kill."]
                    #[doc = "They **must** be sorted in ascending order, *and* unique."]
                    #[codec(index = 17u8)]
                    cancel_deferred_slash {
                        era: u32,
                        slash_indices: ::alloc::vec::Vec<u32>,
                    },
                    #[doc = "Pay out next page of the stakers behind a validator for the given era."]
                    #[doc = ""]
                    #[doc = "- `validator_stash` is the stash account of the validator."]
                    #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
                    #[doc = ""]
                    #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
                    #[doc = "it is not one of the stakers."]
                    #[doc = ""]
                    #[doc = "The reward payout could be paged in case there are too many nominators backing the"]
                    #[doc = "`validator_stash`. This call will payout unpaid pages in an ascending order. To claim a"]
                    #[doc = "specific page, use `payout_stakers_by_page`.`"]
                    #[doc = ""]
                    #[doc = "If all pages are claimed, it returns an error `InvalidPage`."]
                    #[codec(index = 18u8)]
                    payout_stakers {
                        validator_stash: ::polymesh_api_client::AccountId,
                        era: u32,
                    },
                    #[doc = "Rebond a portion of the stash scheduled to be unlocked."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be signed by the controller."]
                    #[doc = ""]
                    #[doc = "## Complexity"]
                    #[doc = "- Time complexity: O(L), where L is unlocking chunks"]
                    #[doc = "- Bounded by `MaxUnlockingChunks`."]
                    #[codec(index = 19u8)]
                    rebond {
                        #[codec(compact)]
                        value: u128,
                    },
                    #[doc = "Remove all data structures concerning a staker/stash once it is at a state where it can"]
                    #[doc = "be considered `dust` in the staking system. The requirements are:"]
                    #[doc = ""]
                    #[doc = "1. the `total_balance` of the stash is below existential deposit."]
                    #[doc = "2. or, the `ledger.total` of the stash is below existential deposit."]
                    #[doc = "3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero."]
                    #[doc = ""]
                    #[doc = "The former can happen in cases like a slash; the latter when a fully unbonded account"]
                    #[doc = "is still receiving staking rewards in `RewardDestination::Staked`."]
                    #[doc = ""]
                    #[doc = "It can be called by anyone, as long as `stash` meets the above requirements."]
                    #[doc = ""]
                    #[doc = "Refunds the transaction fees upon successful execution."]
                    #[doc = ""]
                    #[doc = "## Parameters"]
                    #[doc = ""]
                    #[doc = "- `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more"]
                    #[doc = "details."]
                    #[codec(index = 20u8)]
                    reap_stash {
                        stash: ::polymesh_api_client::AccountId,
                        num_slashing_spans: u32,
                    },
                    #[doc = "Remove the given nominations from the calling validator."]
                    #[doc = ""]
                    #[doc = "Effects will be felt at the beginning of the next era."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
                    #[doc = ""]
                    #[doc = "- `who`: A list of nominator stash accounts who are nominating this validator which"]
                    #[doc = "  should no longer be nominating this validator."]
                    #[doc = ""]
                    #[doc = "Note: Making this call only makes sense if you first set the validator preferences to"]
                    #[doc = "block any further nominations."]
                    #[codec(index = 21u8)]
                    kick {
                        who: ::alloc::vec::Vec<
                            ::polymesh_api_client::MultiAddress<
                                ::polymesh_api_client::AccountId,
                                u32,
                            >,
                        >,
                    },
                    #[doc = "Update the various staking configurations ."]
                    #[doc = ""]
                    #[doc = "* `min_nominator_bond`: The minimum active bond needed to be a nominator."]
                    #[doc = "* `min_validator_bond`: The minimum active bond needed to be a validator."]
                    #[doc = "* `max_nominator_count`: The max number of users who can be a nominator at once. When"]
                    #[doc = "  set to `None`, no limit is enforced."]
                    #[doc = "* `max_validator_count`: The max number of users who can be a validator at once. When"]
                    #[doc = "  set to `None`, no limit is enforced."]
                    #[doc = "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which"]
                    #[doc = "  should be filled in order for the `chill_other` transaction to work."]
                    #[doc = "* `min_commission`: The minimum amount of commission that each validators must maintain."]
                    #[doc = "  This is checked only upon calling `validate`. Existing validators are not affected."]
                    #[doc = ""]
                    #[doc = "RuntimeOrigin must be Root to call this function."]
                    #[doc = ""]
                    #[doc = "NOTE: Existing nominators and validators will not be affected by this update."]
                    #[doc = "to kick people under the new limits, `chill_other` should be called."]
                    #[codec(index = 22u8)]
                    set_staking_configs {
                        min_nominator_bond: pallet_staking::pallet::pallet::ConfigOp<u128>,
                        min_validator_bond: pallet_staking::pallet::pallet::ConfigOp<u128>,
                        max_nominator_count: pallet_staking::pallet::pallet::ConfigOp<u32>,
                        max_validator_count: pallet_staking::pallet::pallet::ConfigOp<u32>,
                        chill_threshold: pallet_staking::pallet::pallet::ConfigOp<
                            ::polymesh_api_client::per_things::Percent,
                        >,
                        min_commission: pallet_staking::pallet::pallet::ConfigOp<
                            ::polymesh_api_client::per_things::Perbill,
                        >,
                        max_staked_rewards: pallet_staking::pallet::pallet::ConfigOp<
                            ::polymesh_api_client::per_things::Percent,
                        >,
                    },
                    #[doc = "Declare a `controller` to stop participating as either a validator or nominator."]
                    #[doc = ""]
                    #[doc = "Effects will be felt at the beginning of the next era."]
                    #[doc = ""]
                    #[doc = "The dispatch origin for this call must be _Signed_, but can be called by anyone."]
                    #[doc = ""]
                    #[doc = "If the caller is the same as the controller being targeted, then no further checks are"]
                    #[doc = "enforced, and this function behaves just like `chill`."]
                    #[doc = ""]
                    #[doc = "If the caller is different than the controller being targeted, the following conditions"]
                    #[doc = "must be met:"]
                    #[doc = ""]
                    #[doc = "* `controller` must belong to a nominator who has become non-decodable,"]
                    #[doc = ""]
                    #[doc = "Or:"]
                    #[doc = ""]
                    #[doc = "* A `ChillThreshold` must be set and checked which defines how close to the max"]
                    #[doc = "  nominators or validators we must reach before users can start chilling one-another."]
                    #[doc = "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine"]
                    #[doc = "  how close we are to the threshold."]
                    #[doc = "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines"]
                    #[doc = "  if this is a person that should be chilled because they have not met the threshold"]
                    #[doc = "  bond required."]
                    #[doc = ""]
                    #[doc = "This can be helpful if bond requirements are updated, and we need to remove old users"]
                    #[doc = "who do not satisfy these requirements."]
                    #[codec(index = 23u8)]
                    chill_other {
                        stash: ::polymesh_api_client::AccountId,
                    },
                    #[doc = "Force a validator to have at least the minimum commission. This will not affect a"]
                    #[doc = "validator who already has a commission greater than or equal to the minimum. Any account"]
                    #[doc = "can call this."]
                    #[codec(index = 24u8)]
                    force_apply_min_commission {
                        validator_stash: ::polymesh_api_client::AccountId,
                    },
                    #[doc = "Sets the minimum amount of commission that each validators must maintain."]
                    #[doc = ""]
                    #[doc = "This call has lower privilege requirements than `set_staking_config` and can be called"]
                    #[doc = "by the `T::AdminOrigin`. Root can always call this."]
                    #[codec(index = 25u8)]
                    set_min_commission {
                        new: ::polymesh_api_client::per_things::Perbill,
                    },
                    #[doc = "Pay out a page of the stakers behind a validator for the given era and page."]
                    #[doc = ""]
                    #[doc = "- `validator_stash` is the stash account of the validator."]
                    #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
                    #[doc = "- `page` is the page index of nominators to pay out with value between 0 and"]
                    #[doc = "  `num_nominators / T::MaxExposurePageSize`."]
                    #[doc = ""]
                    #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
                    #[doc = "it is not one of the stakers."]
                    #[doc = ""]
                    #[doc = "If a validator has more than [`Config::MaxExposurePageSize`] nominators backing"]
                    #[doc = "them, then the list of nominators is paged, with each page being capped at"]
                    #[doc = "[`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,"]
                    #[doc = "the call needs to be made for each page separately in order for all the nominators"]
                    #[doc = "backing a validator to receive the reward. The nominators are not sorted across pages"]
                    #[doc = "and so it should not be assumed the highest staker would be on the topmost page and vice"]
                    #[doc = "versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost."]
                    #[codec(index = 26u8)]
                    payout_stakers_by_page {
                        validator_stash: ::polymesh_api_client::AccountId,
                        era: u32,
                        page: u32,
                    },
                    #[doc = "Migrates an account's `RewardDestination::Controller` to"]
                    #[doc = "`RewardDestination::Account(controller)`."]
                    #[doc = ""]
                    #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
                    #[doc = ""]
                    #[doc = "This will waive the transaction fee if the `payee` is successfully migrated."]
                    #[codec(index = 27u8)]
                    update_payee {
                        controller: ::polymesh_api_client::AccountId,
                    },
                    #[doc = "Updates a batch of controller accounts to their corresponding stash account if they are"]
                    #[doc = "not the same. Ignores any controller accounts that do not exist, and does not operate if"]
                    #[doc = "the stash and controller are already the same."]
                    #[doc = ""]
                    #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be `T::AdminOrigin`."]
                    #[codec(index = 28u8)]
                    deprecate_controller_batch {
                        controllers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                    },
                    #[doc = "Restores the state of a ledger which is in an inconsistent state."]
                    #[doc = ""]
                    #[doc = "The requirements to restore a ledger are the following:"]
                    #[doc = "* The stash is bonded; or"]
                    #[doc = "* The stash is not bonded but it has a staking lock left behind; or"]
                    #[doc = "* If the stash has an associated ledger and its state is inconsistent; or"]
                    #[doc = "* If the ledger is not corrupted *but* its staking lock is out of sync."]
                    #[doc = ""]
                    #[doc = "The `maybe_*` input parameters will overwrite the corresponding data and metadata of the"]
                    #[doc = "ledger associated with the stash. If the input parameters are not set, the ledger will"]
                    #[doc = "be reset values from on-chain state."]
                    #[codec(index = 29u8)]
                    restore_ledger {
                        stash: ::polymesh_api_client::AccountId,
                        maybe_controller: Option<::polymesh_api_client::AccountId>,
                        maybe_total: Option<u128>,
                        maybe_unlocking:
                            Option<::alloc::vec::Vec<pallet_staking::UnlockChunk<u128>>>,
                    },
                    #[doc = "Removes the legacy Staking locks if they exist."]
                    #[doc = ""]
                    #[doc = "This removes the legacy lock on the stake with [`Config::OldCurrency`] and creates a"]
                    #[doc = "hold on it if needed. If all stake cannot be held, the best effort is made to hold as"]
                    #[doc = "much as possible. The remaining stake is forced withdrawn from the ledger."]
                    #[doc = ""]
                    #[doc = "The fee is waived if the migration is successful."]
                    #[codec(index = 30u8)]
                    migrate_currency {
                        stash: ::polymesh_api_client::AccountId,
                    },
                    #[doc = "This function allows governance to manually slash a validator and is a"]
                    #[doc = "**fallback mechanism**."]
                    #[doc = ""]
                    #[doc = "The dispatch origin must be `T::AdminOrigin`."]
                    #[doc = ""]
                    #[doc = "## Parameters"]
                    #[doc = "- `validator_stash` - The stash account of the validator to slash."]
                    #[doc = "- `era` - The era in which the validator was in the active set."]
                    #[doc = "- `slash_fraction` - The percentage of the stake to slash, expressed as a Perbill."]
                    #[doc = ""]
                    #[doc = "## Behavior"]
                    #[doc = ""]
                    #[doc = "The slash will be applied using the standard slashing mechanics, respecting the"]
                    #[doc = "configured `SlashDeferDuration`."]
                    #[doc = ""]
                    #[doc = "This means:"]
                    #[doc = "- If the validator was already slashed by a higher percentage for the same era, this"]
                    #[doc = "  slash will have no additional effect."]
                    #[doc = "- If the validator was previously slashed by a lower percentage, only the difference"]
                    #[doc = "  will be applied."]
                    #[doc = "- The slash will be deferred by `SlashDeferDuration` eras before being enacted."]
                    #[codec(index = 33u8)]
                    manual_slash {
                        validator_stash: ::polymesh_api_client::AccountId,
                        era: u32,
                        slash_fraction: ::polymesh_api_client::per_things::Perbill,
                    },
                }
                impl StakingCall {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::bond { .. } => "Staking.bond",
                            Self::bond_extra { .. } => "Staking.bond_extra",
                            Self::unbond { .. } => "Staking.unbond",
                            Self::withdraw_unbonded { .. } => "Staking.withdraw_unbonded",
                            Self::validate { .. } => "Staking.validate",
                            Self::nominate { .. } => "Staking.nominate",
                            Self::chill => "Staking.chill",
                            Self::set_payee { .. } => "Staking.set_payee",
                            Self::set_controller => "Staking.set_controller",
                            Self::set_validator_count { .. } => "Staking.set_validator_count",
                            Self::increase_validator_count { .. } => {
                                "Staking.increase_validator_count"
                            }
                            Self::scale_validator_count { .. } => "Staking.scale_validator_count",
                            Self::force_no_eras => "Staking.force_no_eras",
                            Self::force_new_era => "Staking.force_new_era",
                            Self::set_invulnerables { .. } => "Staking.set_invulnerables",
                            Self::force_unstake { .. } => "Staking.force_unstake",
                            Self::force_new_era_always => "Staking.force_new_era_always",
                            Self::cancel_deferred_slash { .. } => "Staking.cancel_deferred_slash",
                            Self::payout_stakers { .. } => "Staking.payout_stakers",
                            Self::rebond { .. } => "Staking.rebond",
                            Self::reap_stash { .. } => "Staking.reap_stash",
                            Self::kick { .. } => "Staking.kick",
                            Self::set_staking_configs { .. } => "Staking.set_staking_configs",
                            Self::chill_other { .. } => "Staking.chill_other",
                            Self::force_apply_min_commission { .. } => {
                                "Staking.force_apply_min_commission"
                            }
                            Self::set_min_commission { .. } => "Staking.set_min_commission",
                            Self::payout_stakers_by_page { .. } => "Staking.payout_stakers_by_page",
                            Self::update_payee { .. } => "Staking.update_payee",
                            Self::deprecate_controller_batch { .. } => {
                                "Staking.deprecate_controller_batch"
                            }
                            Self::restore_ledger { .. } => "Staking.restore_ledger",
                            Self::migrate_currency { .. } => "Staking.migrate_currency",
                            Self::manual_slash { .. } => "Staking.manual_slash",
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for StakingCall {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: bond { .. } => { & ["Take the origin account as a stash and lock up `value` of its balance. `controller` will" , "be the account that controls it." , "" , "`value` must be more than the `minimum_balance` specified by `T::Currency`." , "" , "The dispatch origin for this call must be _Signed_ by the stash account." , "" , "Emits `Bonded`." , "## Complexity" , "- Independent of the arguments. Moderate complexity." , "- O(1)." , "- Three extra DB entries." , "" , "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned" , "unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed" , "as dust." ,] } , Self :: bond_extra { .. } => { & ["Add some extra amount that have appeared in the stash `free_balance` into the balance up" , "for staking." , "" , "The dispatch origin for this call must be _Signed_ by the stash, not the controller." , "" , "Use this if there are additional funds in your stash account that you wish to bond." , "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose" , "any limitation on the amount that can be added." , "" , "Emits `Bonded`." , "" , "## Complexity" , "- Independent of the arguments. Insignificant complexity." , "- O(1)." ,] } , Self :: unbond { .. } => { & ["Schedule a portion of the stash to be unlocked ready for transfer out after the bond" , "period ends. If this leaves an amount actively bonded less than" , "[`asset::existential_deposit`], then it is increased to the full amount." , "" , "The stash may be chilled if the ledger total amount falls to 0 after unbonding." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "Once the unlock period is done, you can call `withdraw_unbonded` to actually move" , "the funds out of management ready for transfer." , "" , "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)" , "can co-exists at the same time. If there are no unlocking chunks slots available" , "[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible)." , "" , "If a user encounters the `InsufficientBond` error when calling this extrinsic," , "they should call `chill` first in order to free up their bonded funds." , "" , "Emits `Unbonded`." , "" , "See also [`Call::withdraw_unbonded`]." ,] } , Self :: withdraw_unbonded { .. } => { & ["Remove any unlocked chunks from the `unlocking` queue from our management." , "" , "This essentially frees up that balance to be used by the stash account to do whatever" , "it wants." , "" , "The dispatch origin for this call must be _Signed_ by the controller." , "" , "Emits `Withdrawn`." , "" , "See also [`Call::unbond`]." , "" , "## Parameters" , "" , "- `num_slashing_spans` indicates the number of metadata slashing spans to clear when" , "this call results in a complete removal of all the data related to the stash account." , "In this case, the `num_slashing_spans` must be larger or equal to the number of" , "slashing spans associated with the stash account in the [`SlashingSpans`] storage type," , "otherwise the call will fail. The call weight is directly proportional to" , "`num_slashing_spans`." , "" , "## Complexity" , "O(S) where S is the number of slashing spans to remove" , "NOTE: Weight annotation is the kill scenario, we refund otherwise." ,] } , Self :: validate { .. } => { & ["Declare the desire to validate for the origin controller." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." ,] } , Self :: nominate { .. } => { & ["Declare the desire to nominate `targets` for the origin controller." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "## Complexity" , "- The transaction's complexity is proportional to the size of `targets` (N)" , "which is capped at CompactAssignments::LIMIT (T::MaxNominations)." , "- Both the reads and writes follow a similar pattern." ,] } , Self :: chill => { & ["Declare no desire to either validate or nominate." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "## Complexity" , "- Independent of the arguments. Insignificant complexity." , "- Contains one read." , "- Writes are limited to the `origin` account key." ,] } , Self :: set_payee { .. } => { & ["(Re-)set the payment target for a controller." , "" , "Effects will be felt instantly (as soon as this function is completed successfully)." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "## Complexity" , "- O(1)" , "- Independent of the arguments. Insignificant complexity." , "- Contains a limited number of reads." , "- Writes are limited to the `origin` account key." , "---------" ,] } , Self :: set_controller => { & ["(Re-)sets the controller of a stash to the stash itself. This function previously" , "accepted a `controller` argument to set the controller to an account other than the" , "stash itself. This functionality has now been removed, now only setting the controller" , "to the stash, if it is not already." , "" , "Effects will be felt instantly (as soon as this function is completed successfully)." , "" , "The dispatch origin for this call must be _Signed_ by the stash, not the controller." , "" , "## Complexity" , "O(1)" , "- Independent of the arguments. Insignificant complexity." , "- Contains a limited number of reads." , "- Writes are limited to the `origin` account key." ,] } , Self :: set_validator_count { .. } => { & ["Sets the ideal number of validators." , "" , "The dispatch origin must be Root." , "" , "## Complexity" , "O(1)" ,] } , Self :: increase_validator_count { .. } => { & ["Increments the ideal number of validators up to maximum of" , "`ElectionProviderBase::MaxWinners`." , "" , "The dispatch origin must be Root." , "" , "## Complexity" , "Same as [`Self::set_validator_count`]." ,] } , Self :: scale_validator_count { .. } => { & ["Scale up the ideal number of validators by a factor up to maximum of" , "`ElectionProviderBase::MaxWinners`." , "" , "The dispatch origin must be Root." , "" , "## Complexity" , "Same as [`Self::set_validator_count`]." ,] } , Self :: force_no_eras => { & ["Force there to be no new eras indefinitely." , "" , "The dispatch origin must be Root." , "" , "# Warning" , "" , "The election process starts multiple blocks before the end of the era." , "Thus the election process may be ongoing when this is called. In this case the" , "election will continue until the next era is triggered." , "" , "## Complexity" , "- No arguments." , "- Weight: O(1)" ,] } , Self :: force_new_era => { & ["Force there to be a new era at the end of the next session. After this, it will be" , "reset to normal (non-forced) behaviour." , "" , "The dispatch origin must be Root." , "" , "# Warning" , "" , "The election process starts multiple blocks before the end of the era." , "If this is called just before a new era is triggered, the election process may not" , "have enough blocks to get a result." , "" , "## Complexity" , "- No arguments." , "- Weight: O(1)" ,] } , Self :: set_invulnerables { .. } => { & ["Set the validators who cannot be slashed (if any)." , "" , "The dispatch origin must be Root." ,] } , Self :: force_unstake { .. } => { & ["Force a current staker to become completely unstaked, immediately." , "" , "The dispatch origin must be Root." , "" , "## Parameters" , "" , "- `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more" , "details." ,] } , Self :: force_new_era_always => { & ["Force there to be a new era at the end of sessions indefinitely." , "" , "The dispatch origin must be Root." , "" , "# Warning" , "" , "The election process starts multiple blocks before the end of the era." , "If this is called just before a new era is triggered, the election process may not" , "have enough blocks to get a result." ,] } , Self :: cancel_deferred_slash { .. } => { & ["Cancel enactment of a deferred slash." , "" , "Can be called by the `T::AdminOrigin`." , "" , "Parameters: era and indices of the slashes for that era to kill." , "They **must** be sorted in ascending order, *and* unique." ,] } , Self :: payout_stakers { .. } => { & ["Pay out next page of the stakers behind a validator for the given era." , "" , "- `validator_stash` is the stash account of the validator." , "- `era` may be any era between `[current_era - history_depth; current_era]`." , "" , "The origin of this call must be _Signed_. Any account can call this function, even if" , "it is not one of the stakers." , "" , "The reward payout could be paged in case there are too many nominators backing the" , "`validator_stash`. This call will payout unpaid pages in an ascending order. To claim a" , "specific page, use `payout_stakers_by_page`.`" , "" , "If all pages are claimed, it returns an error `InvalidPage`." ,] } , Self :: rebond { .. } => { & ["Rebond a portion of the stash scheduled to be unlocked." , "" , "The dispatch origin must be signed by the controller." , "" , "## Complexity" , "- Time complexity: O(L), where L is unlocking chunks" , "- Bounded by `MaxUnlockingChunks`." ,] } , Self :: reap_stash { .. } => { & ["Remove all data structures concerning a staker/stash once it is at a state where it can" , "be considered `dust` in the staking system. The requirements are:" , "" , "1. the `total_balance` of the stash is below existential deposit." , "2. or, the `ledger.total` of the stash is below existential deposit." , "3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero." , "" , "The former can happen in cases like a slash; the latter when a fully unbonded account" , "is still receiving staking rewards in `RewardDestination::Staked`." , "" , "It can be called by anyone, as long as `stash` meets the above requirements." , "" , "Refunds the transaction fees upon successful execution." , "" , "## Parameters" , "" , "- `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more" , "details." ,] } , Self :: kick { .. } => { & ["Remove the given nominations from the calling validator." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_ by the controller, not the stash." , "" , "- `who`: A list of nominator stash accounts who are nominating this validator which" , "  should no longer be nominating this validator." , "" , "Note: Making this call only makes sense if you first set the validator preferences to" , "block any further nominations." ,] } , Self :: set_staking_configs { .. } => { & ["Update the various staking configurations ." , "" , "* `min_nominator_bond`: The minimum active bond needed to be a nominator." , "* `min_validator_bond`: The minimum active bond needed to be a validator." , "* `max_nominator_count`: The max number of users who can be a nominator at once. When" , "  set to `None`, no limit is enforced." , "* `max_validator_count`: The max number of users who can be a validator at once. When" , "  set to `None`, no limit is enforced." , "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which" , "  should be filled in order for the `chill_other` transaction to work." , "* `min_commission`: The minimum amount of commission that each validators must maintain." , "  This is checked only upon calling `validate`. Existing validators are not affected." , "" , "RuntimeOrigin must be Root to call this function." , "" , "NOTE: Existing nominators and validators will not be affected by this update." , "to kick people under the new limits, `chill_other` should be called." ,] } , Self :: chill_other { .. } => { & ["Declare a `controller` to stop participating as either a validator or nominator." , "" , "Effects will be felt at the beginning of the next era." , "" , "The dispatch origin for this call must be _Signed_, but can be called by anyone." , "" , "If the caller is the same as the controller being targeted, then no further checks are" , "enforced, and this function behaves just like `chill`." , "" , "If the caller is different than the controller being targeted, the following conditions" , "must be met:" , "" , "* `controller` must belong to a nominator who has become non-decodable," , "" , "Or:" , "" , "* A `ChillThreshold` must be set and checked which defines how close to the max" , "  nominators or validators we must reach before users can start chilling one-another." , "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine" , "  how close we are to the threshold." , "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines" , "  if this is a person that should be chilled because they have not met the threshold" , "  bond required." , "" , "This can be helpful if bond requirements are updated, and we need to remove old users" , "who do not satisfy these requirements." ,] } , Self :: force_apply_min_commission { .. } => { & ["Force a validator to have at least the minimum commission. This will not affect a" , "validator who already has a commission greater than or equal to the minimum. Any account" , "can call this." ,] } , Self :: set_min_commission { .. } => { & ["Sets the minimum amount of commission that each validators must maintain." , "" , "This call has lower privilege requirements than `set_staking_config` and can be called" , "by the `T::AdminOrigin`. Root can always call this." ,] } , Self :: payout_stakers_by_page { .. } => { & ["Pay out a page of the stakers behind a validator for the given era and page." , "" , "- `validator_stash` is the stash account of the validator." , "- `era` may be any era between `[current_era - history_depth; current_era]`." , "- `page` is the page index of nominators to pay out with value between 0 and" , "  `num_nominators / T::MaxExposurePageSize`." , "" , "The origin of this call must be _Signed_. Any account can call this function, even if" , "it is not one of the stakers." , "" , "If a validator has more than [`Config::MaxExposurePageSize`] nominators backing" , "them, then the list of nominators is paged, with each page being capped at" , "[`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators," , "the call needs to be made for each page separately in order for all the nominators" , "backing a validator to receive the reward. The nominators are not sorted across pages" , "and so it should not be assumed the highest staker would be on the topmost page and vice" , "versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost." ,] } , Self :: update_payee { .. } => { & ["Migrates an account's `RewardDestination::Controller` to" , "`RewardDestination::Account(controller)`." , "" , "Effects will be felt instantly (as soon as this function is completed successfully)." , "" , "This will waive the transaction fee if the `payee` is successfully migrated." ,] } , Self :: deprecate_controller_batch { .. } => { & ["Updates a batch of controller accounts to their corresponding stash account if they are" , "not the same. Ignores any controller accounts that do not exist, and does not operate if" , "the stash and controller are already the same." , "" , "Effects will be felt instantly (as soon as this function is completed successfully)." , "" , "The dispatch origin must be `T::AdminOrigin`." ,] } , Self :: restore_ledger { .. } => { & ["Restores the state of a ledger which is in an inconsistent state." , "" , "The requirements to restore a ledger are the following:" , "* The stash is bonded; or" , "* The stash is not bonded but it has a staking lock left behind; or" , "* If the stash has an associated ledger and its state is inconsistent; or" , "* If the ledger is not corrupted *but* its staking lock is out of sync." , "" , "The `maybe_*` input parameters will overwrite the corresponding data and metadata of the" , "ledger associated with the stash. If the input parameters are not set, the ledger will" , "be reset values from on-chain state." ,] } , Self :: migrate_currency { .. } => { & ["Removes the legacy Staking locks if they exist." , "" , "This removes the legacy lock on the stake with [`Config::OldCurrency`] and creates a" , "hold on it if needed. If all stake cannot be held, the best effort is made to hold as" , "much as possible. The remaining stake is forced withdrawn from the ledger." , "" , "The fee is waived if the migration is successful." ,] } , Self :: manual_slash { .. } => { & ["This function allows governance to manually slash a validator and is a" , "**fallback mechanism**." , "" , "The dispatch origin must be `T::AdminOrigin`." , "" , "## Parameters" , "- `validator_stash` - The stash account of the validator to slash." , "- `era` - The era in which the validator was in the active set." , "- `slash_fraction` - The percentage of the stake to slash, expressed as a Perbill." , "" , "## Behavior" , "" , "The slash will be applied using the standard slashing mechanics, respecting the" , "configured `SlashDeferDuration`." , "" , "This means:" , "- If the validator was already slashed by a higher percentage for the same era, this" , "  slash will have no additional effect." , "- If the validator was previously slashed by a lower percentage, only the difference" , "  will be applied." , "- The slash will be deferred by `SlashDeferDuration` eras before being enacted." ,] } , _ => & [""] , }
                    }
                }
                impl From<StakingCall> for &'static str {
                    fn from(v: StakingCall) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&StakingCall> for &'static str {
                    fn from(v: &StakingCall) -> Self {
                        v.as_static_str()
                    }
                }
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum ConfigOp<T> {
                    #[codec(index = 0u8)]
                    Noop,
                    #[codec(index = 1u8)]
                    Set(T),
                    #[codec(index = 2u8)]
                    Remove,
                }
                #[doc = "The `Error` enum of this pallet."]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum StakingError {
                    #[doc = "Not a controller account."]
                    #[codec(index = 0u8)]
                    NotController,
                    #[doc = "Not a stash account."]
                    #[codec(index = 1u8)]
                    NotStash,
                    #[doc = "Stash is already bonded."]
                    #[codec(index = 2u8)]
                    AlreadyBonded,
                    #[doc = "Controller is already paired."]
                    #[codec(index = 3u8)]
                    AlreadyPaired,
                    #[doc = "Targets cannot be empty."]
                    #[codec(index = 4u8)]
                    EmptyTargets,
                    #[doc = "Duplicate index."]
                    #[codec(index = 5u8)]
                    DuplicateIndex,
                    #[doc = "Slash record index out of bounds."]
                    #[codec(index = 6u8)]
                    InvalidSlashIndex,
                    #[doc = "Cannot have a validator or nominator role, with value less than the minimum defined by"]
                    #[doc = "governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the"]
                    #[doc = "intention, `chill` first to remove one's role as validator/nominator."]
                    #[codec(index = 7u8)]
                    InsufficientBond,
                    #[doc = "Can not schedule more unlock chunks."]
                    #[codec(index = 8u8)]
                    NoMoreChunks,
                    #[doc = "Can not rebond without unlocking chunks."]
                    #[codec(index = 9u8)]
                    NoUnlockChunk,
                    #[doc = "Attempting to target a stash that still has funds."]
                    #[codec(index = 10u8)]
                    FundedTarget,
                    #[doc = "Invalid era to reward."]
                    #[codec(index = 11u8)]
                    InvalidEraToReward,
                    #[doc = "Invalid number of nominations."]
                    #[codec(index = 12u8)]
                    InvalidNumberOfNominations,
                    #[doc = "Items are not sorted and unique."]
                    #[codec(index = 13u8)]
                    NotSortedAndUnique,
                    #[doc = "Rewards for this era have already been claimed for this validator."]
                    #[codec(index = 14u8)]
                    AlreadyClaimed,
                    #[doc = "No nominators exist on this page."]
                    #[codec(index = 15u8)]
                    InvalidPage,
                    #[doc = "Incorrect previous history depth input provided."]
                    #[codec(index = 16u8)]
                    IncorrectHistoryDepth,
                    #[doc = "Incorrect number of slashing spans provided."]
                    #[codec(index = 17u8)]
                    IncorrectSlashingSpans,
                    #[doc = "Internal state has become somehow corrupted and the operation cannot continue."]
                    #[codec(index = 18u8)]
                    BadState,
                    #[doc = "Too many nomination targets supplied."]
                    #[codec(index = 19u8)]
                    TooManyTargets,
                    #[doc = "A nomination target was supplied that was blocked or otherwise not a validator."]
                    #[codec(index = 20u8)]
                    BadTarget,
                    #[doc = "The user has enough bond and thus cannot be chilled forcefully by an external person."]
                    #[codec(index = 21u8)]
                    CannotChillOther,
                    #[doc = "There are too many nominators in the system. Governance needs to adjust the staking"]
                    #[doc = "settings to keep things safe for the runtime."]
                    #[codec(index = 22u8)]
                    TooManyNominators,
                    #[doc = "There are too many validator candidates in the system. Governance needs to adjust the"]
                    #[doc = "staking settings to keep things safe for the runtime."]
                    #[codec(index = 23u8)]
                    TooManyValidators,
                    #[doc = "Commission is too low. Must be at least `MinCommission`."]
                    #[codec(index = 24u8)]
                    CommissionTooLow,
                    #[doc = "Some bound is not met."]
                    #[codec(index = 25u8)]
                    BoundNotMet,
                    #[doc = "Used when attempting to use deprecated controller account logic."]
                    #[codec(index = 26u8)]
                    ControllerDeprecated,
                    #[doc = "Cannot reset a ledger."]
                    #[codec(index = 27u8)]
                    CannotRestoreLedger,
                    #[doc = "Provided reward destination is not allowed."]
                    #[codec(index = 28u8)]
                    RewardDestinationRestricted,
                    #[doc = "Not enough funds available to withdraw."]
                    #[codec(index = 29u8)]
                    NotEnoughFunds,
                    #[doc = "Operation not allowed for virtual stakers."]
                    #[codec(index = 30u8)]
                    VirtualStakerNotAllowed,
                    #[doc = "Stash could not be reaped as other pallet might depend on it."]
                    #[codec(index = 31u8)]
                    CannotReapStash,
                    #[doc = "The stake of this account is already migrated to `Fungible` holds."]
                    #[codec(index = 32u8)]
                    AlreadyMigrated,
                    #[doc = "Account is restricted from participation in staking. This may happen if the account is"]
                    #[doc = "staking in another way already, such as via pool."]
                    #[codec(index = 33u8)]
                    Restricted,
                }
                impl StakingError {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::NotController => "Staking.NotController",
                            Self::NotStash => "Staking.NotStash",
                            Self::AlreadyBonded => "Staking.AlreadyBonded",
                            Self::AlreadyPaired => "Staking.AlreadyPaired",
                            Self::EmptyTargets => "Staking.EmptyTargets",
                            Self::DuplicateIndex => "Staking.DuplicateIndex",
                            Self::InvalidSlashIndex => "Staking.InvalidSlashIndex",
                            Self::InsufficientBond => "Staking.InsufficientBond",
                            Self::NoMoreChunks => "Staking.NoMoreChunks",
                            Self::NoUnlockChunk => "Staking.NoUnlockChunk",
                            Self::FundedTarget => "Staking.FundedTarget",
                            Self::InvalidEraToReward => "Staking.InvalidEraToReward",
                            Self::InvalidNumberOfNominations => {
                                "Staking.InvalidNumberOfNominations"
                            }
                            Self::NotSortedAndUnique => "Staking.NotSortedAndUnique",
                            Self::AlreadyClaimed => "Staking.AlreadyClaimed",
                            Self::InvalidPage => "Staking.InvalidPage",
                            Self::IncorrectHistoryDepth => "Staking.IncorrectHistoryDepth",
                            Self::IncorrectSlashingSpans => "Staking.IncorrectSlashingSpans",
                            Self::BadState => "Staking.BadState",
                            Self::TooManyTargets => "Staking.TooManyTargets",
                            Self::BadTarget => "Staking.BadTarget",
                            Self::CannotChillOther => "Staking.CannotChillOther",
                            Self::TooManyNominators => "Staking.TooManyNominators",
                            Self::TooManyValidators => "Staking.TooManyValidators",
                            Self::CommissionTooLow => "Staking.CommissionTooLow",
                            Self::BoundNotMet => "Staking.BoundNotMet",
                            Self::ControllerDeprecated => "Staking.ControllerDeprecated",
                            Self::CannotRestoreLedger => "Staking.CannotRestoreLedger",
                            Self::RewardDestinationRestricted => {
                                "Staking.RewardDestinationRestricted"
                            }
                            Self::NotEnoughFunds => "Staking.NotEnoughFunds",
                            Self::VirtualStakerNotAllowed => "Staking.VirtualStakerNotAllowed",
                            Self::CannotReapStash => "Staking.CannotReapStash",
                            Self::AlreadyMigrated => "Staking.AlreadyMigrated",
                            Self::Restricted => "Staking.Restricted",
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for StakingError {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: NotController => { & ["Not a controller account." ,] } , Self :: NotStash => { & ["Not a stash account." ,] } , Self :: AlreadyBonded => { & ["Stash is already bonded." ,] } , Self :: AlreadyPaired => { & ["Controller is already paired." ,] } , Self :: EmptyTargets => { & ["Targets cannot be empty." ,] } , Self :: DuplicateIndex => { & ["Duplicate index." ,] } , Self :: InvalidSlashIndex => { & ["Slash record index out of bounds." ,] } , Self :: InsufficientBond => { & ["Cannot have a validator or nominator role, with value less than the minimum defined by" , "governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the" , "intention, `chill` first to remove one's role as validator/nominator." ,] } , Self :: NoMoreChunks => { & ["Can not schedule more unlock chunks." ,] } , Self :: NoUnlockChunk => { & ["Can not rebond without unlocking chunks." ,] } , Self :: FundedTarget => { & ["Attempting to target a stash that still has funds." ,] } , Self :: InvalidEraToReward => { & ["Invalid era to reward." ,] } , Self :: InvalidNumberOfNominations => { & ["Invalid number of nominations." ,] } , Self :: NotSortedAndUnique => { & ["Items are not sorted and unique." ,] } , Self :: AlreadyClaimed => { & ["Rewards for this era have already been claimed for this validator." ,] } , Self :: InvalidPage => { & ["No nominators exist on this page." ,] } , Self :: IncorrectHistoryDepth => { & ["Incorrect previous history depth input provided." ,] } , Self :: IncorrectSlashingSpans => { & ["Incorrect number of slashing spans provided." ,] } , Self :: BadState => { & ["Internal state has become somehow corrupted and the operation cannot continue." ,] } , Self :: TooManyTargets => { & ["Too many nomination targets supplied." ,] } , Self :: BadTarget => { & ["A nomination target was supplied that was blocked or otherwise not a validator." ,] } , Self :: CannotChillOther => { & ["The user has enough bond and thus cannot be chilled forcefully by an external person." ,] } , Self :: TooManyNominators => { & ["There are too many nominators in the system. Governance needs to adjust the staking" , "settings to keep things safe for the runtime." ,] } , Self :: TooManyValidators => { & ["There are too many validator candidates in the system. Governance needs to adjust the" , "staking settings to keep things safe for the runtime." ,] } , Self :: CommissionTooLow => { & ["Commission is too low. Must be at least `MinCommission`." ,] } , Self :: BoundNotMet => { & ["Some bound is not met." ,] } , Self :: ControllerDeprecated => { & ["Used when attempting to use deprecated controller account logic." ,] } , Self :: CannotRestoreLedger => { & ["Cannot reset a ledger." ,] } , Self :: RewardDestinationRestricted => { & ["Provided reward destination is not allowed." ,] } , Self :: NotEnoughFunds => { & ["Not enough funds available to withdraw." ,] } , Self :: VirtualStakerNotAllowed => { & ["Operation not allowed for virtual stakers." ,] } , Self :: CannotReapStash => { & ["Stash could not be reaped as other pallet might depend on it." ,] } , Self :: AlreadyMigrated => { & ["The stake of this account is already migrated to `Fungible` holds." ,] } , Self :: Restricted => { & ["Account is restricted from participation in staking. This may happen if the account is" , "staking in another way already, such as via pool." ,] } , _ => & [""] , }
                    }
                }
                impl From<StakingError> for &'static str {
                    fn from(v: StakingError) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&StakingError> for &'static str {
                    fn from(v: &StakingError) -> Self {
                        v.as_static_str()
                    }
                }
                #[doc = "The `Event` enum of this pallet"]
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum StakingEvent {
                    #[doc = "The era payout has been set; the first balance is the validator-payout; the second is"]
                    #[doc = "the remainder from the maximum amount of reward."]
                    #[codec(index = 0u8)]
                    EraPaid {
                        era_index: u32,
                        validator_payout: u128,
                        remainder: u128,
                    },
                    #[doc = "The nominator has been rewarded by this amount to this destination."]
                    #[codec(index = 1u8)]
                    Rewarded {
                        stash: ::polymesh_api_client::AccountId,
                        dest: pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
                        amount: u128,
                    },
                    #[doc = "A staker (validator or nominator) has been slashed by the given amount."]
                    #[codec(index = 2u8)]
                    Slashed {
                        staker: ::polymesh_api_client::AccountId,
                        amount: u128,
                    },
                    #[doc = "A slash for the given validator, for the given percentage of their stake, at the given"]
                    #[doc = "era as been reported."]
                    #[codec(index = 3u8)]
                    SlashReported {
                        validator: ::polymesh_api_client::AccountId,
                        fraction: ::polymesh_api_client::per_things::Perbill,
                        slash_era: u32,
                    },
                    #[doc = "An old slashing report from a prior era was discarded because it could"]
                    #[doc = "not be processed."]
                    #[codec(index = 4u8)]
                    OldSlashingReportDiscarded { session_index: u32 },
                    #[doc = "A new set of stakers was elected."]
                    #[codec(index = 5u8)]
                    StakersElected,
                    #[doc = "An account has bonded this amount. \\[stash, amount\\]"]
                    #[doc = ""]
                    #[doc = "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,"]
                    #[doc = "it will not be emitted for staking rewards when they are added to stake."]
                    #[codec(index = 6u8)]
                    Bonded {
                        stash: ::polymesh_api_client::AccountId,
                        amount: u128,
                    },
                    #[doc = "An account has unbonded this amount."]
                    #[codec(index = 7u8)]
                    Unbonded {
                        stash: ::polymesh_api_client::AccountId,
                        amount: u128,
                    },
                    #[doc = "An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`"]
                    #[doc = "from the unlocking queue."]
                    #[codec(index = 8u8)]
                    Withdrawn {
                        stash: ::polymesh_api_client::AccountId,
                        amount: u128,
                    },
                    #[doc = "A nominator has been kicked from a validator."]
                    #[codec(index = 9u8)]
                    Kicked {
                        nominator: ::polymesh_api_client::AccountId,
                        stash: ::polymesh_api_client::AccountId,
                    },
                    #[doc = "The election failed. No new era is planned."]
                    #[codec(index = 10u8)]
                    StakingElectionFailed,
                    #[doc = "An account has stopped participating as either a validator or nominator."]
                    #[codec(index = 11u8)]
                    Chilled {
                        stash: ::polymesh_api_client::AccountId,
                    },
                    #[doc = "A Page of stakers rewards are getting paid. `next` is `None` if all pages are claimed."]
                    #[codec(index = 12u8)]
                    PayoutStarted {
                        era_index: u32,
                        validator_stash: ::polymesh_api_client::AccountId,
                        page: u32,
                        next: Option<u32>,
                    },
                    #[doc = "A validator has set their preferences."]
                    #[codec(index = 13u8)]
                    ValidatorPrefsSet {
                        stash: ::polymesh_api_client::AccountId,
                        prefs: pallet_staking::ValidatorPrefs,
                    },
                    #[doc = "Voters size limit reached."]
                    #[codec(index = 14u8)]
                    SnapshotVotersSizeExceeded { size: u32 },
                    #[doc = "Targets size limit reached."]
                    #[codec(index = 15u8)]
                    SnapshotTargetsSizeExceeded { size: u32 },
                    #[doc = "A new force era mode was set."]
                    #[codec(index = 16u8)]
                    ForceEra { mode: pallet_staking::Forcing },
                    #[doc = "Report of a controller batch deprecation."]
                    #[codec(index = 17u8)]
                    ControllerBatchDeprecated { failures: u32 },
                    #[doc = "Staking balance migrated from locks to holds, with any balance that could not be held"]
                    #[doc = "is force withdrawn."]
                    #[codec(index = 18u8)]
                    CurrencyMigrated {
                        stash: ::polymesh_api_client::AccountId,
                        force_withdraw: u128,
                    },
                }
                impl StakingEvent {
                    pub fn as_static_str(&self) -> &'static str {
                        #[allow(unreachable_patterns)]
                        match self {
                            Self::EraPaid { .. } => "Staking.EraPaid",
                            Self::Rewarded { .. } => "Staking.Rewarded",
                            Self::Slashed { .. } => "Staking.Slashed",
                            Self::SlashReported { .. } => "Staking.SlashReported",
                            Self::OldSlashingReportDiscarded { .. } => {
                                "Staking.OldSlashingReportDiscarded"
                            }
                            Self::StakersElected => "Staking.StakersElected",
                            Self::Bonded { .. } => "Staking.Bonded",
                            Self::Unbonded { .. } => "Staking.Unbonded",
                            Self::Withdrawn { .. } => "Staking.Withdrawn",
                            Self::Kicked { .. } => "Staking.Kicked",
                            Self::StakingElectionFailed => "Staking.StakingElectionFailed",
                            Self::Chilled { .. } => "Staking.Chilled",
                            Self::PayoutStarted { .. } => "Staking.PayoutStarted",
                            Self::ValidatorPrefsSet { .. } => "Staking.ValidatorPrefsSet",
                            Self::SnapshotVotersSizeExceeded { .. } => {
                                "Staking.SnapshotVotersSizeExceeded"
                            }
                            Self::SnapshotTargetsSizeExceeded { .. } => {
                                "Staking.SnapshotTargetsSizeExceeded"
                            }
                            Self::ForceEra { .. } => "Staking.ForceEra",
                            Self::ControllerBatchDeprecated { .. } => {
                                "Staking.ControllerBatchDeprecated"
                            }
                            Self::CurrencyMigrated { .. } => "Staking.CurrencyMigrated",
                            _ => "Unknown",
                        }
                    }
                }
                #[cfg(not(feature = "ink"))]
                impl ::polymesh_api_client::EnumInfo for StakingEvent {
                    fn as_name(&self) -> &'static str {
                        self.as_static_str()
                    }
                    fn as_docs(&self) -> &'static [&'static str] {
                        # [allow (unreachable_patterns)] match self { Self :: EraPaid { .. } => { & ["The era payout has been set; the first balance is the validator-payout; the second is" , "the remainder from the maximum amount of reward." ,] } , Self :: Rewarded { .. } => { & ["The nominator has been rewarded by this amount to this destination." ,] } , Self :: Slashed { .. } => { & ["A staker (validator or nominator) has been slashed by the given amount." ,] } , Self :: SlashReported { .. } => { & ["A slash for the given validator, for the given percentage of their stake, at the given" , "era as been reported." ,] } , Self :: OldSlashingReportDiscarded { .. } => { & ["An old slashing report from a prior era was discarded because it could" , "not be processed." ,] } , Self :: StakersElected => { & ["A new set of stakers was elected." ,] } , Self :: Bonded { .. } => { & ["An account has bonded this amount. \\[stash, amount\\]" , "" , "NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably," , "it will not be emitted for staking rewards when they are added to stake." ,] } , Self :: Unbonded { .. } => { & ["An account has unbonded this amount." ,] } , Self :: Withdrawn { .. } => { & ["An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`" , "from the unlocking queue." ,] } , Self :: Kicked { .. } => { & ["A nominator has been kicked from a validator." ,] } , Self :: StakingElectionFailed => { & ["The election failed. No new era is planned." ,] } , Self :: Chilled { .. } => { & ["An account has stopped participating as either a validator or nominator." ,] } , Self :: PayoutStarted { .. } => { & ["A Page of stakers rewards are getting paid. `next` is `None` if all pages are claimed." ,] } , Self :: ValidatorPrefsSet { .. } => { & ["A validator has set their preferences." ,] } , Self :: SnapshotVotersSizeExceeded { .. } => { & ["Voters size limit reached." ,] } , Self :: SnapshotTargetsSizeExceeded { .. } => { & ["Targets size limit reached." ,] } , Self :: ForceEra { .. } => { & ["A new force era mode was set." ,] } , Self :: ControllerBatchDeprecated { .. } => { & ["Report of a controller batch deprecation." ,] } , Self :: CurrencyMigrated { .. } => { & ["Staking balance migrated from locks to holds, with any balance that could not be held" , "is force withdrawn." ,] } , _ => & [""] , }
                    }
                }
                impl From<StakingEvent> for &'static str {
                    fn from(v: StakingEvent) -> Self {
                        v.as_static_str()
                    }
                }
                impl From<&StakingEvent> for &'static str {
                    fn from(v: &StakingEvent) -> Self {
                        v.as_static_str()
                    }
                }
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum HoldReason {
                    #[codec(index = 0u8)]
                    Staking,
                }
            }
        }
        pub mod slashing {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct SlashingSpans {
                pub span_index: u32,
                pub last_start: u32,
                pub last_nonzero_slash: u32,
                pub prior: ::alloc::vec::Vec<u32>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct SpanRecord<Balance> {
                pub slashed: Balance,
                pub paid_out: Balance,
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ActiveEraInfo {
            pub index: u32,
            pub start: Option<u64>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct EraRewardPoints<AccountId: Ord> {
            pub total: u32,
            pub individual: ::alloc::collections::BTreeMap<AccountId, u32>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Forcing {
            #[codec(index = 0u8)]
            NotForcing,
            #[codec(index = 1u8)]
            ForceNew,
            #[codec(index = 2u8)]
            ForceNone,
            #[codec(index = 3u8)]
            ForceAlways,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Nominations {
            pub targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            pub submitted_in: u32,
            pub suppressed: bool,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum RewardDestination<AccountId> {
            #[codec(index = 0u8)]
            Staked,
            #[codec(index = 1u8)]
            Stash,
            #[codec(index = 2u8)]
            Controller,
            #[codec(index = 3u8)]
            Account(AccountId),
            #[codec(index = 4u8)]
            None,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct StakingLedger {
            pub stash: ::polymesh_api_client::AccountId,
            #[codec(compact)]
            pub total: u128,
            #[codec(compact)]
            pub active: u128,
            pub unlocking: ::alloc::vec::Vec<pallet_staking::UnlockChunk<u128>>,
            pub legacy_claimed_rewards: ::alloc::vec::Vec<u32>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct UnappliedSlash<AccountId, Balance> {
            pub validator: AccountId,
            pub own: Balance,
            pub others: ::alloc::vec::Vec<(AccountId, Balance)>,
            pub reporters: ::alloc::vec::Vec<AccountId>,
            pub payout: Balance,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct UnlockChunk<Balance> {
            #[codec(compact)]
            pub value: Balance,
            #[codec(compact)]
            pub era: u32,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ValidatorPrefs {
            #[codec(compact)]
            pub commission: ::polymesh_api_client::per_things::Perbill,
            pub blocked: bool,
        }
    }
    pub mod pallet_statistics {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum StatisticsCall {
                #[doc = "Set the active asset stat_types."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
                #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
                #[doc = "- `stat_types` - the new stat types to replace any existing types."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `StatTypeLimitReached` - too many stat types enabled for the `asset_id`."]
                #[doc = "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions."]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "- Agent"]
                #[doc = "- Asset"]
                #[codec(index = 0u8)]
                set_active_asset_stats {
                    asset_id: ::polymesh_api_client::AssetId,
                    stat_types:
                        ::alloc::collections::BTreeSet<polymesh_primitives::statistics::StatType>,
                },
                #[doc = "Allow a trusted issuer to init/resync asset/company stats."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
                #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
                #[doc = "- `stat_type` - stat type to update."]
                #[doc = "- `values` - Updated values for `stat_type`."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `StatTypeMissing` - `stat_type` is not enabled for the `asset_id`."]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "- Agent"]
                #[doc = "- Asset"]
                #[codec(index = 1u8)]
                batch_update_asset_stats {
                    asset_id: ::polymesh_api_client::AssetId,
                    stat_type: polymesh_primitives::statistics::StatType,
                    values:
                        ::alloc::collections::BTreeSet<polymesh_primitives::statistics::StatUpdate>,
                },
                #[doc = "Set asset transfer compliance rules."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
                #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
                #[doc = "- `transfer_conditions` - the new transfer condition to replace any existing conditions."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset_id`."]
                #[doc = "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset_id`."]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "- Agent"]
                #[doc = "- Asset"]
                #[codec(index = 2u8)]
                set_asset_transfer_compliance {
                    asset_id: ::polymesh_api_client::AssetId,
                    transfer_conditions: ::alloc::collections::BTreeSet<
                        polymesh_primitives::transfer_compliance::TransferCondition,
                    >,
                },
                #[doc = "Set/unset entities exempt from an asset's transfer compliance rules."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`."]
                #[doc = "- `is_exempt` - enable/disable exemption for `entities`."]
                #[doc = "- `exempt_key` - the asset and stat type to exempt the `entities` from."]
                #[doc = "- `entities` - the entities to set/unset the exemption for."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
                #[doc = ""]
                #[doc = "# Permissions"]
                #[doc = "- Agent"]
                #[doc = "- Asset"]
                #[codec(index = 3u8)]
                set_entities_exempt {
                    is_exempt: bool,
                    exempt_key:
                        polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
                    entities: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
                },
            }
            impl StatisticsCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::set_active_asset_stats { .. } => "Statistics.set_active_asset_stats",
                        Self::batch_update_asset_stats { .. } => {
                            "Statistics.batch_update_asset_stats"
                        }
                        Self::set_asset_transfer_compliance { .. } => {
                            "Statistics.set_asset_transfer_compliance"
                        }
                        Self::set_entities_exempt { .. } => "Statistics.set_entities_exempt",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for StatisticsCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: set_active_asset_stats { .. } => { & ["Set the active asset stat_types." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `asset_id`." , "- `asset_id` - the [`AssetId`] to change the active stats on." , "- `stat_types` - the new stat types to replace any existing types." , "" , "# Errors" , "- `StatTypeLimitReached` - too many stat types enabled for the `asset_id`." , "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , Self :: batch_update_asset_stats { .. } => { & ["Allow a trusted issuer to init/resync asset/company stats." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `asset_id`." , "- `asset_id` - the [`AssetId`] to change the active stats on." , "- `stat_type` - stat type to update." , "- `values` - Updated values for `stat_type`." , "" , "# Errors" , "- `StatTypeMissing` - `stat_type` is not enabled for the `asset_id`." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , Self :: set_asset_transfer_compliance { .. } => { & ["Set asset transfer compliance rules." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `asset_id`." , "- `asset_id` - the [`AssetId`] to change the active stats on." , "- `transfer_conditions` - the new transfer condition to replace any existing conditions." , "" , "# Errors" , "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset_id`." , "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset_id`." , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , Self :: set_entities_exempt { .. } => { & ["Set/unset entities exempt from an asset's transfer compliance rules." , "" , "# Arguments" , "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`." , "- `is_exempt` - enable/disable exemption for `entities`." , "- `exempt_key` - the asset and stat type to exempt the `entities` from." , "- `entities` - the entities to set/unset the exemption for." , "" , "# Errors" , "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`." , "" , "# Permissions" , "- Agent" , "- Asset" ,] } , _ => & [""] , }
                }
            }
            impl From<StatisticsCall> for &'static str {
                fn from(v: StatisticsCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&StatisticsCall> for &'static str {
                fn from(v: &StatisticsCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum StatisticsError {
                #[doc = "Invalid transfer [`TransferCondition`] not respected."]
                #[codec(index = 0u8)]
                InvalidTransferStatisticsFailure,
                #[doc = "StatType is not enabled."]
                #[codec(index = 1u8)]
                StatTypeMissing,
                #[doc = "StatType is needed by TransferCondition."]
                #[codec(index = 2u8)]
                StatTypeNeededByTransferCondition,
                #[doc = "A Stattype is in use and can't be removed."]
                #[codec(index = 3u8)]
                CannotRemoveStatTypeInUse,
                #[doc = "The limit of StatTypes allowed for an asset has been reached."]
                #[codec(index = 4u8)]
                StatTypeLimitReached,
                #[doc = "The limit of TransferConditions allowed for an asset has been reached."]
                #[codec(index = 5u8)]
                TransferConditionLimitReached,
                #[doc = "The maximum weight limit for executing the function was exceeded."]
                #[codec(index = 6u8)]
                WeightLimitExceeded,
            }
            impl StatisticsError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InvalidTransferStatisticsFailure => {
                            "Statistics.InvalidTransferStatisticsFailure"
                        }
                        Self::StatTypeMissing => "Statistics.StatTypeMissing",
                        Self::StatTypeNeededByTransferCondition => {
                            "Statistics.StatTypeNeededByTransferCondition"
                        }
                        Self::CannotRemoveStatTypeInUse => "Statistics.CannotRemoveStatTypeInUse",
                        Self::StatTypeLimitReached => "Statistics.StatTypeLimitReached",
                        Self::TransferConditionLimitReached => {
                            "Statistics.TransferConditionLimitReached"
                        }
                        Self::WeightLimitExceeded => "Statistics.WeightLimitExceeded",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for StatisticsError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: InvalidTransferStatisticsFailure => { & ["Invalid transfer [`TransferCondition`] not respected." ,] } , Self :: StatTypeMissing => { & ["StatType is not enabled." ,] } , Self :: StatTypeNeededByTransferCondition => { & ["StatType is needed by TransferCondition." ,] } , Self :: CannotRemoveStatTypeInUse => { & ["A Stattype is in use and can't be removed." ,] } , Self :: StatTypeLimitReached => { & ["The limit of StatTypes allowed for an asset has been reached." ,] } , Self :: TransferConditionLimitReached => { & ["The limit of TransferConditions allowed for an asset has been reached." ,] } , Self :: WeightLimitExceeded => { & ["The maximum weight limit for executing the function was exceeded." ,] } , _ => & [""] , }
                }
            }
            impl From<StatisticsError> for &'static str {
                fn from(v: StatisticsError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&StatisticsError> for &'static str {
                fn from(v: &StatisticsError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum StatisticsEvent {
                #[doc = "Stat types added to asset."]
                #[doc = ""]
                #[doc = "(Caller DID, AssetId, Stat types)"]
                #[codec(index = 0u8)]
                StatTypesAdded(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::alloc::vec::Vec<polymesh_primitives::statistics::StatType>,
                ),
                #[doc = "Stat types removed from asset."]
                #[doc = ""]
                #[doc = "(Caller DID, AssetId, Stat types)"]
                #[codec(index = 1u8)]
                StatTypesRemoved(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::alloc::vec::Vec<polymesh_primitives::statistics::StatType>,
                ),
                #[doc = "Asset stats updated."]
                #[doc = ""]
                #[doc = "(Caller DID, AssetId, Stat type, Updates)"]
                #[codec(index = 2u8)]
                AssetStatsUpdated(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::statistics::StatType,
                    ::alloc::vec::Vec<polymesh_primitives::statistics::StatUpdate>,
                ),
                #[doc = "Set Transfer compliance rules for asset."]
                #[doc = ""]
                #[doc = "(Caller DID, AssetId, Transfer conditions)"]
                #[codec(index = 3u8)]
                SetAssetTransferCompliance(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AssetId,
                    ::alloc::vec::Vec<polymesh_primitives::transfer_compliance::TransferCondition>,
                ),
                #[doc = "Add `IdentityId`s exempt for transfer conditions matching exempt key."]
                #[doc = ""]
                #[doc = "(Caller DID, Exempt key, Entities)"]
                #[codec(index = 4u8)]
                TransferConditionExemptionsAdded(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
                    ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
                ),
                #[doc = "Remove `IdentityId`s exempt for transfer conditions matching exempt key."]
                #[doc = ""]
                #[doc = "(Caller DID, Exempt key, Entities)"]
                #[codec(index = 5u8)]
                TransferConditionExemptionsRemoved(
                    ::polymesh_api_client::IdentityId,
                    polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
                    ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
                ),
            }
            impl StatisticsEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::StatTypesAdded(_, _, _) => "Statistics.StatTypesAdded",
                        Self::StatTypesRemoved(_, _, _) => "Statistics.StatTypesRemoved",
                        Self::AssetStatsUpdated(_, _, _, _) => "Statistics.AssetStatsUpdated",
                        Self::SetAssetTransferCompliance(_, _, _) => {
                            "Statistics.SetAssetTransferCompliance"
                        }
                        Self::TransferConditionExemptionsAdded(_, _, _) => {
                            "Statistics.TransferConditionExemptionsAdded"
                        }
                        Self::TransferConditionExemptionsRemoved(_, _, _) => {
                            "Statistics.TransferConditionExemptionsRemoved"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for StatisticsEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: StatTypesAdded (_ , _ , _) => { & ["Stat types added to asset." , "" , "(Caller DID, AssetId, Stat types)" ,] } , Self :: StatTypesRemoved (_ , _ , _) => { & ["Stat types removed from asset." , "" , "(Caller DID, AssetId, Stat types)" ,] } , Self :: AssetStatsUpdated (_ , _ , _ , _) => { & ["Asset stats updated." , "" , "(Caller DID, AssetId, Stat type, Updates)" ,] } , Self :: SetAssetTransferCompliance (_ , _ , _) => { & ["Set Transfer compliance rules for asset." , "" , "(Caller DID, AssetId, Transfer conditions)" ,] } , Self :: TransferConditionExemptionsAdded (_ , _ , _) => { & ["Add `IdentityId`s exempt for transfer conditions matching exempt key." , "" , "(Caller DID, Exempt key, Entities)" ,] } , Self :: TransferConditionExemptionsRemoved (_ , _ , _) => { & ["Remove `IdentityId`s exempt for transfer conditions matching exempt key." , "" , "(Caller DID, Exempt key, Entities)" ,] } , _ => & [""] , }
                }
            }
            impl From<StatisticsEvent> for &'static str {
                fn from(v: StatisticsEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&StatisticsEvent> for &'static str {
                fn from(v: &StatisticsEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Version(pub u8);
    }
    pub mod pallet_sto {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum StoCall {
                #[doc = "Create a new fundraiser for a security token offering."]
                #[doc = ""]
                #[doc = "This function creates a tiered pricing fundraiser where investors can purchase"]
                #[doc = "tokens at different price points. The fundraiser uses Polymesh's settlement"]
                #[doc = "infrastructure to ensure compliant and secure token transfers."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* `offering_portfolio` - Portfolio containing the tokens being offered for sale"]
                #[doc = "* `offering_asset` - Asset ID of the security token being sold"]
                #[doc = "* `raising_portfolio` - Portfolio that will receive the raised funds"]
                #[doc = "* `raising_asset` - Asset ID of the payment token (e.g., POLYX, stablecoin)"]
                #[doc = "* `tiers` - Vector of price tiers (1-10 tiers), each with total amount and price per unit"]
                #[doc = "* `venue_id` - STO venue ID for handling settlements (must be owned by caller)"]
                #[doc = "* `start` - Optional start time; if `None`, fundraiser begins immediately"]
                #[doc = "* `end` - Optional end time; if `None`, fundraiser runs indefinitely"]
                #[doc = "* `minimum_investment` - Minimum amount of `raising_asset` required per investment"]
                #[doc = "* `fundraiser_name` - Human-readable name for UI display (length limited)"]
                #[doc = ""]
                #[doc = "# Permissions Required"]
                #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
                #[doc = "* **Portfolio Custody**: Caller must have custody of both `offering_portfolio` and `raising_portfolio`"]
                #[doc = "* **Venue Ownership**: The specified `venue_id` must be an STO venue owned by the caller"]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `InvalidVenue` - Venue doesn't exist, wrong type, or not owned by caller"]
                #[doc = "* `InvalidPriceTiers` - Invalid tier configuration (0 tiers, >10 tiers, zero amounts)"]
                #[doc = "* `InvalidOfferingWindow` - Start time is after end time"]
                #[doc = "* `Overflow` - Total offering amount calculation overflowed"]
                #[codec(index = 0u8)]
                create_fundraiser {
                    offering_portfolio: polymesh_primitives::identity_id::PortfolioId,
                    offering_asset: ::polymesh_api_client::AssetId,
                    raising_portfolio: polymesh_primitives::identity_id::PortfolioId,
                    raising_asset: ::polymesh_api_client::AssetId,
                    tiers: ::alloc::vec::Vec<pallet_sto::PriceTier>,
                    venue_id: polymesh_primitives::settlement::VenueId,
                    start: Option<u64>,
                    end: Option<u64>,
                    minimum_investment: u128,
                    fundraiser_name: pallet_sto::FundraiserName,
                },
                #[doc = "Invest in a fundraiser using on-chain or off-chain funding."]
                #[doc = ""]
                #[doc = "This function allows investors to purchase tokens from an active fundraiser."]
                #[doc = "The investment is processed through multiple price tiers in order, starting"]
                #[doc = "with the lowest-priced tier. The purchase creates a settlement instruction"]
                #[doc = "that transfers tokens and payment between the appropriate portfolios."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* `offering_asset` - Asset ID of the security token being purchased"]
                #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to invest in"]
                #[doc = "* `investment_portfolio` - Portfolio where purchased tokens will be deposited"]
                #[doc = "* `funding` - Payment method: either `OnChain(portfolio_id)` for on-chain assets"]
                #[doc = "  or `OffChain(receipt_details)` for off-chain receipts with signature verification"]
                #[doc = "* `purchase_amount` - Number of `offering_asset` tokens to purchase"]
                #[doc = "* `max_price` - Optional maximum price per token; if specified, investment fails"]
                #[doc = "  if the blended price across tiers exceeds this limit"]
                #[doc = ""]
                #[doc = "# Permissions Required"]
                #[doc = "* **Portfolio Custody**: Caller must have custody of `investment_portfolio`"]
                #[doc = "* **Funding Portfolio**: If using on-chain funding, caller must have custody"]
                #[doc = "  of the funding portfolio specified in the `FundingMethod`"]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
                #[doc = "* `FundraiserNotLive` - Fundraiser is frozen or closed"]
                #[doc = "* `FundraiserExpired` - Current time is outside fundraiser's active window"]
                #[doc = "* `InsufficientTokensRemaining` - Not enough tokens available across all tiers"]
                #[doc = "* `InvestmentAmountTooLow` - Total cost is below minimum investment threshold"]
                #[doc = "* `MaxPriceExceeded` - Blended price exceeds investor's maximum price limit"]
                #[doc = "* `OffchainFundingNotAllowed` - Off-chain funding not enabled for this fundraiser"]
                #[doc = "* `InvalidSignature` - Off-chain receipt signature verification failed"]
                #[codec(index = 1u8)]
                invest {
                    offering_asset: ::polymesh_api_client::AssetId,
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                    investment_portfolio: polymesh_primitives::identity_id::PortfolioId,
                    funding: pallet_sto::FundingMethod<
                        ::polymesh_api_client::AccountId,
                        ::polymesh_api_client::MultiSignature,
                    >,
                    purchase_amount: u128,
                    max_price: Option<u128>,
                },
                #[doc = "Temporarily freeze a fundraiser to prevent new investments."]
                #[doc = ""]
                #[doc = "When a fundraiser is frozen, it cannot accept new investments but remains"]
                #[doc = "otherwise intact. This is useful for pausing activity while resolving"]
                #[doc = "issues or during maintenance periods. The fundraiser can be unfrozen"]
                #[doc = "later to resume normal operations."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to freeze"]
                #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to freeze"]
                #[doc = ""]
                #[doc = "# Permissions Required"]
                #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
                #[doc = "* `FundraiserClosed` - Fundraiser has already been permanently closed"]
                #[doc = "* `Unauthorized` - Caller lacks required asset agent permissions"]
                #[codec(index = 2u8)]
                freeze_fundraiser {
                    offering_asset: ::polymesh_api_client::AssetId,
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                },
                #[doc = "Resume a frozen fundraiser to allow new investments."]
                #[doc = ""]
                #[doc = "This function unfreezes a previously frozen fundraiser, returning it to"]
                #[doc = "the Live status where it can accept new investments. The fundraiser"]
                #[doc = "must not be permanently closed for this operation to succeed."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to unfreeze"]
                #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to unfreeze"]
                #[doc = ""]
                #[doc = "# Permissions Required"]
                #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
                #[doc = "* `FundraiserClosed` - Fundraiser has been permanently closed and cannot be unfrozen"]
                #[doc = "* `Unauthorized` - Caller lacks required asset agent permissions"]
                #[codec(index = 3u8)]
                unfreeze_fundraiser {
                    offering_asset: ::polymesh_api_client::AssetId,
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                },
                #[doc = "Modify the time window when a fundraiser is active for investments."]
                #[doc = ""]
                #[doc = "This function allows authorized agents to update the start and end times"]
                #[doc = "of an active fundraiser. This can be useful for extending fundraising"]
                #[doc = "periods, adjusting launch timing, or responding to market conditions."]
                #[doc = "The fundraiser must not be permanently closed to modify its window."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to modify"]
                #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to modify"]
                #[doc = "* `start` - New start time for the fundraiser (can be in the past or future)"]
                #[doc = "* `end` - New optional end time; if `None`, the fundraiser runs indefinitely"]
                #[doc = ""]
                #[doc = "# Permissions Required"]
                #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
                #[doc = "* `FundraiserClosed` - Fundraiser has been permanently closed"]
                #[doc = "* `FundraiserExpired` - Fundraiser has already expired (past its original end time)"]
                #[doc = "* `InvalidOfferingWindow` - New start time is after new end time"]
                #[doc = "* `Unauthorized` - Caller lacks required asset agent permissions"]
                #[codec(index = 4u8)]
                modify_fundraiser_window {
                    offering_asset: ::polymesh_api_client::AssetId,
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                    start: u64,
                    end: Option<u64>,
                },
                #[doc = "Permanently stop a fundraiser and unlock remaining tokens."]
                #[doc = ""]
                #[doc = "This function permanently closes a fundraiser, preventing any further"]
                #[doc = "investments. Any remaining tokens that haven't been sold are unlocked"]
                #[doc = "and returned to the offering portfolio. Once stopped, a fundraiser"]
                #[doc = "cannot be restarted."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to stop"]
                #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to stop"]
                #[doc = ""]
                #[doc = "# Permissions Required"]
                #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
                #[doc = "  OR be the original creator of the fundraiser"]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
                #[doc = "* `FundraiserClosed` - Fundraiser has already been permanently closed"]
                #[doc = "* `Unauthorized` - Caller lacks required permissions"]
                #[codec(index = 5u8)]
                stop {
                    offering_asset: ::polymesh_api_client::AssetId,
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                },
                #[doc = "Enable off-chain funding support for a fundraiser."]
                #[doc = ""]
                #[doc = "This function allows a fundraiser to accept off-chain payments through"]
                #[doc = "cryptographically signed receipts. Once enabled, investors can use the"]
                #[doc = "`invest` function with `FundingMethod::OffChain` to provide payment"]
                #[doc = "receipts instead of on-chain portfolio transfers."]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "* `offering_asset` - Asset ID associated with the fundraiser"]
                #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to enable off-chain funding for"]
                #[doc = "* `ticker` - Ticker symbol of the off-chain asset that will be accepted as payment"]
                #[doc = ""]
                #[doc = "# Permissions Required"]
                #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
                #[doc = "  OR be the original creator of the fundraiser"]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
                #[doc = "* `FundraiserClosed` - Fundraiser has been permanently closed"]
                #[doc = "* `Unauthorized` - Caller lacks required permissions"]
                #[codec(index = 6u8)]
                enable_offchain_funding {
                    offering_asset: ::polymesh_api_client::AssetId,
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                    ticker: polymesh_primitives::ticker::Ticker,
                },
            }
            impl StoCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::create_fundraiser { .. } => "Sto.create_fundraiser",
                        Self::invest { .. } => "Sto.invest",
                        Self::freeze_fundraiser { .. } => "Sto.freeze_fundraiser",
                        Self::unfreeze_fundraiser { .. } => "Sto.unfreeze_fundraiser",
                        Self::modify_fundraiser_window { .. } => "Sto.modify_fundraiser_window",
                        Self::stop { .. } => "Sto.stop",
                        Self::enable_offchain_funding { .. } => "Sto.enable_offchain_funding",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for StoCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: create_fundraiser { .. } => { & ["Create a new fundraiser for a security token offering." , "" , "This function creates a tiered pricing fundraiser where investors can purchase" , "tokens at different price points. The fundraiser uses Polymesh's settlement" , "infrastructure to ensure compliant and secure token transfers." , "" , "# Parameters" , "* `offering_portfolio` - Portfolio containing the tokens being offered for sale" , "* `offering_asset` - Asset ID of the security token being sold" , "* `raising_portfolio` - Portfolio that will receive the raised funds" , "* `raising_asset` - Asset ID of the payment token (e.g., POLYX, stablecoin)" , "* `tiers` - Vector of price tiers (1-10 tiers), each with total amount and price per unit" , "* `venue_id` - STO venue ID for handling settlements (must be owned by caller)" , "* `start` - Optional start time; if `None`, fundraiser begins immediately" , "* `end` - Optional end time; if `None`, fundraiser runs indefinitely" , "* `minimum_investment` - Minimum amount of `raising_asset` required per investment" , "* `fundraiser_name` - Human-readable name for UI display (length limited)" , "" , "# Permissions Required" , "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`" , "* **Portfolio Custody**: Caller must have custody of both `offering_portfolio` and `raising_portfolio`" , "* **Venue Ownership**: The specified `venue_id` must be an STO venue owned by the caller" , "" , "# Errors" , "* `InvalidVenue` - Venue doesn't exist, wrong type, or not owned by caller" , "* `InvalidPriceTiers` - Invalid tier configuration (0 tiers, >10 tiers, zero amounts)" , "* `InvalidOfferingWindow` - Start time is after end time" , "* `Overflow` - Total offering amount calculation overflowed" ,] } , Self :: invest { .. } => { & ["Invest in a fundraiser using on-chain or off-chain funding." , "" , "This function allows investors to purchase tokens from an active fundraiser." , "The investment is processed through multiple price tiers in order, starting" , "with the lowest-priced tier. The purchase creates a settlement instruction" , "that transfers tokens and payment between the appropriate portfolios." , "" , "# Parameters" , "* `offering_asset` - Asset ID of the security token being purchased" , "* `fundraiser_id` - Unique identifier of the fundraiser to invest in" , "* `investment_portfolio` - Portfolio where purchased tokens will be deposited" , "* `funding` - Payment method: either `OnChain(portfolio_id)` for on-chain assets" , "  or `OffChain(receipt_details)` for off-chain receipts with signature verification" , "* `purchase_amount` - Number of `offering_asset` tokens to purchase" , "* `max_price` - Optional maximum price per token; if specified, investment fails" , "  if the blended price across tiers exceeds this limit" , "" , "# Permissions Required" , "* **Portfolio Custody**: Caller must have custody of `investment_portfolio`" , "* **Funding Portfolio**: If using on-chain funding, caller must have custody" , "  of the funding portfolio specified in the `FundingMethod`" , "" , "# Errors" , "* `FundraiserNotFound` - Specified fundraiser doesn't exist" , "* `FundraiserNotLive` - Fundraiser is frozen or closed" , "* `FundraiserExpired` - Current time is outside fundraiser's active window" , "* `InsufficientTokensRemaining` - Not enough tokens available across all tiers" , "* `InvestmentAmountTooLow` - Total cost is below minimum investment threshold" , "* `MaxPriceExceeded` - Blended price exceeds investor's maximum price limit" , "* `OffchainFundingNotAllowed` - Off-chain funding not enabled for this fundraiser" , "* `InvalidSignature` - Off-chain receipt signature verification failed" ,] } , Self :: freeze_fundraiser { .. } => { & ["Temporarily freeze a fundraiser to prevent new investments." , "" , "When a fundraiser is frozen, it cannot accept new investments but remains" , "otherwise intact. This is useful for pausing activity while resolving" , "issues or during maintenance periods. The fundraiser can be unfrozen" , "later to resume normal operations." , "" , "# Parameters" , "* `offering_asset` - Asset ID associated with the fundraiser to freeze" , "* `fundraiser_id` - Unique identifier of the fundraiser to freeze" , "" , "# Permissions Required" , "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`" , "" , "# Errors" , "* `FundraiserNotFound` - Specified fundraiser doesn't exist" , "* `FundraiserClosed` - Fundraiser has already been permanently closed" , "* `Unauthorized` - Caller lacks required asset agent permissions" ,] } , Self :: unfreeze_fundraiser { .. } => { & ["Resume a frozen fundraiser to allow new investments." , "" , "This function unfreezes a previously frozen fundraiser, returning it to" , "the Live status where it can accept new investments. The fundraiser" , "must not be permanently closed for this operation to succeed." , "" , "# Parameters" , "* `offering_asset` - Asset ID associated with the fundraiser to unfreeze" , "* `fundraiser_id` - Unique identifier of the fundraiser to unfreeze" , "" , "# Permissions Required" , "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`" , "" , "# Errors" , "* `FundraiserNotFound` - Specified fundraiser doesn't exist" , "* `FundraiserClosed` - Fundraiser has been permanently closed and cannot be unfrozen" , "* `Unauthorized` - Caller lacks required asset agent permissions" ,] } , Self :: modify_fundraiser_window { .. } => { & ["Modify the time window when a fundraiser is active for investments." , "" , "This function allows authorized agents to update the start and end times" , "of an active fundraiser. This can be useful for extending fundraising" , "periods, adjusting launch timing, or responding to market conditions." , "The fundraiser must not be permanently closed to modify its window." , "" , "# Parameters" , "* `offering_asset` - Asset ID associated with the fundraiser to modify" , "* `fundraiser_id` - Unique identifier of the fundraiser to modify" , "* `start` - New start time for the fundraiser (can be in the past or future)" , "* `end` - New optional end time; if `None`, the fundraiser runs indefinitely" , "" , "# Permissions Required" , "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`" , "" , "# Errors" , "* `FundraiserNotFound` - Specified fundraiser doesn't exist" , "* `FundraiserClosed` - Fundraiser has been permanently closed" , "* `FundraiserExpired` - Fundraiser has already expired (past its original end time)" , "* `InvalidOfferingWindow` - New start time is after new end time" , "* `Unauthorized` - Caller lacks required asset agent permissions" ,] } , Self :: stop { .. } => { & ["Permanently stop a fundraiser and unlock remaining tokens." , "" , "This function permanently closes a fundraiser, preventing any further" , "investments. Any remaining tokens that haven't been sold are unlocked" , "and returned to the offering portfolio. Once stopped, a fundraiser" , "cannot be restarted." , "" , "# Parameters" , "* `offering_asset` - Asset ID associated with the fundraiser to stop" , "* `fundraiser_id` - Unique identifier of the fundraiser to stop" , "" , "# Permissions Required" , "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`" , "  OR be the original creator of the fundraiser" , "" , "# Errors" , "* `FundraiserNotFound` - Specified fundraiser doesn't exist" , "* `FundraiserClosed` - Fundraiser has already been permanently closed" , "* `Unauthorized` - Caller lacks required permissions" ,] } , Self :: enable_offchain_funding { .. } => { & ["Enable off-chain funding support for a fundraiser." , "" , "This function allows a fundraiser to accept off-chain payments through" , "cryptographically signed receipts. Once enabled, investors can use the" , "`invest` function with `FundingMethod::OffChain` to provide payment" , "receipts instead of on-chain portfolio transfers." , "" , "# Parameters" , "* `offering_asset` - Asset ID associated with the fundraiser" , "* `fundraiser_id` - Unique identifier of the fundraiser to enable off-chain funding for" , "* `ticker` - Ticker symbol of the off-chain asset that will be accepted as payment" , "" , "# Permissions Required" , "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`" , "  OR be the original creator of the fundraiser" , "" , "# Errors" , "* `FundraiserNotFound` - Specified fundraiser doesn't exist" , "* `FundraiserClosed` - Fundraiser has been permanently closed" , "* `Unauthorized` - Caller lacks required permissions" ,] } , _ => & [""] , }
                }
            }
            impl From<StoCall> for &'static str {
                fn from(v: StoCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&StoCall> for &'static str {
                fn from(v: &StoCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum StoError {
                #[doc = "Sender does not have required permissions for the requested operation."]
                #[codec(index = 0u8)]
                Unauthorized,
                #[doc = "An arithmetic operation resulted in overflow or underflow."]
                #[codec(index = 1u8)]
                Overflow,
                #[doc = "The fundraiser does not have enough tokens remaining to fulfil the investment."]
                #[codec(index = 2u8)]
                InsufficientTokensRemaining,
                #[doc = "The specified fundraiser does not exist for the given asset."]
                #[codec(index = 3u8)]
                FundraiserNotFound,
                #[doc = "The fundraiser is not in a live state (either frozen or stopped)."]
                #[codec(index = 4u8)]
                FundraiserNotLive,
                #[doc = "The fundraiser has been permanently closed or stopped."]
                #[codec(index = 5u8)]
                FundraiserClosed,
                #[doc = "Attempting to interact with a fundraiser after its end time has passed."]
                #[codec(index = 6u8)]
                FundraiserExpired,
                #[doc = "The provided venue is invalid (does not exist, wrong type, or wrong creator)."]
                #[codec(index = 7u8)]
                InvalidVenue,
                #[doc = "One or more price tiers have invalid parameters (zero total, too many tiers, etc.)."]
                #[codec(index = 8u8)]
                InvalidPriceTiers,
                #[doc = "The fundraiser time window has invalid parameters (start time after end time)."]
                #[codec(index = 9u8)]
                InvalidOfferingWindow,
                #[doc = "The calculated price per token exceeds the maximum price specified by the investor."]
                #[codec(index = 10u8)]
                MaxPriceExceeded,
                #[doc = "The investment amount is below the minimum investment threshold for this fundraiser."]
                #[codec(index = 11u8)]
                InvestmentAmountTooLow,
                #[doc = "The off-chain receipt signature is invalid or could not be verified."]
                #[codec(index = 12u8)]
                InvalidSignature,
                #[doc = "Off-chain funding has not been enabled for this fundraiser."]
                #[codec(index = 13u8)]
                OffchainFundingNotAllowed,
            }
            impl StoError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Unauthorized => "Sto.Unauthorized",
                        Self::Overflow => "Sto.Overflow",
                        Self::InsufficientTokensRemaining => "Sto.InsufficientTokensRemaining",
                        Self::FundraiserNotFound => "Sto.FundraiserNotFound",
                        Self::FundraiserNotLive => "Sto.FundraiserNotLive",
                        Self::FundraiserClosed => "Sto.FundraiserClosed",
                        Self::FundraiserExpired => "Sto.FundraiserExpired",
                        Self::InvalidVenue => "Sto.InvalidVenue",
                        Self::InvalidPriceTiers => "Sto.InvalidPriceTiers",
                        Self::InvalidOfferingWindow => "Sto.InvalidOfferingWindow",
                        Self::MaxPriceExceeded => "Sto.MaxPriceExceeded",
                        Self::InvestmentAmountTooLow => "Sto.InvestmentAmountTooLow",
                        Self::InvalidSignature => "Sto.InvalidSignature",
                        Self::OffchainFundingNotAllowed => "Sto.OffchainFundingNotAllowed",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for StoError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: Unauthorized => { & ["Sender does not have required permissions for the requested operation." ,] } , Self :: Overflow => { & ["An arithmetic operation resulted in overflow or underflow." ,] } , Self :: InsufficientTokensRemaining => { & ["The fundraiser does not have enough tokens remaining to fulfil the investment." ,] } , Self :: FundraiserNotFound => { & ["The specified fundraiser does not exist for the given asset." ,] } , Self :: FundraiserNotLive => { & ["The fundraiser is not in a live state (either frozen or stopped)." ,] } , Self :: FundraiserClosed => { & ["The fundraiser has been permanently closed or stopped." ,] } , Self :: FundraiserExpired => { & ["Attempting to interact with a fundraiser after its end time has passed." ,] } , Self :: InvalidVenue => { & ["The provided venue is invalid (does not exist, wrong type, or wrong creator)." ,] } , Self :: InvalidPriceTiers => { & ["One or more price tiers have invalid parameters (zero total, too many tiers, etc.)." ,] } , Self :: InvalidOfferingWindow => { & ["The fundraiser time window has invalid parameters (start time after end time)." ,] } , Self :: MaxPriceExceeded => { & ["The calculated price per token exceeds the maximum price specified by the investor." ,] } , Self :: InvestmentAmountTooLow => { & ["The investment amount is below the minimum investment threshold for this fundraiser." ,] } , Self :: InvalidSignature => { & ["The off-chain receipt signature is invalid or could not be verified." ,] } , Self :: OffchainFundingNotAllowed => { & ["Off-chain funding has not been enabled for this fundraiser." ,] } , _ => & [""] , }
                }
            }
            impl From<StoError> for &'static str {
                fn from(v: StoError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&StoError> for &'static str {
                fn from(v: &StoError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum StoEvent {
                #[doc = "A new fundraiser has been created."]
                #[doc = ""]
                #[doc = "[agent_did, offering_asset, raising_asset, fundraiser_id, fundraiser_name, fundraiser]"]
                #[codec(index = 0u8)]
                FundraiserCreated {
                    #[doc = "Identity of the external agent who created the fundraiser."]
                    agent_did: ::polymesh_api_client::IdentityId,
                    #[doc = "Asset being offered for sale in the fundraiser."]
                    offering_asset: ::polymesh_api_client::AssetId,
                    #[doc = "Asset being accepted as payment in the fundraiser."]
                    raising_asset: ::polymesh_api_client::AssetId,
                    #[doc = "Unique identifier for the fundraiser."]
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                    #[doc = "Human-readable name of the fundraiser."]
                    fundraiser_name: pallet_sto::FundraiserName,
                    #[doc = "Complete fundraiser configuration."]
                    fundraiser: pallet_sto::Fundraiser<u64>,
                },
                #[doc = "An investor successfully invested in the fundraiser."]
                #[doc = ""]
                #[doc = "[investor_did, offering_asset, fundraiser_id, funding_asset, offering_amount, raise_amount]"]
                #[codec(index = 1u8)]
                Invested {
                    #[doc = "Identity of the investor."]
                    investor_did: ::polymesh_api_client::IdentityId,
                    #[doc = "Asset being purchased."]
                    offering_asset: ::polymesh_api_client::AssetId,
                    #[doc = "Fundraiser that was invested in."]
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                    #[doc = "Type of funding used (on-chain or off-chain)."]
                    funding_asset: pallet_sto::FundingAsset,
                    #[doc = "Amount of offering asset purchased."]
                    offering_amount: u128,
                    #[doc = "Amount of raising asset spent."]
                    raise_amount: u128,
                },
                #[doc = "A fundraiser has been frozen, preventing new investments."]
                #[doc = ""]
                #[doc = "[agent_did, offering_asset, fundraiser_id]"]
                #[codec(index = 2u8)]
                FundraiserFrozen {
                    #[doc = "Identity of the external agent who froze the fundraiser."]
                    agent_did: ::polymesh_api_client::IdentityId,
                    #[doc = "Asset associated with the fundraiser."]
                    offering_asset: ::polymesh_api_client::AssetId,
                    #[doc = "Fundraiser that was frozen."]
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                },
                #[doc = "A fundraiser has been unfrozen, allowing new investments."]
                #[doc = ""]
                #[doc = "[agent_did, offering_asset, fundraiser_id]"]
                #[codec(index = 3u8)]
                FundraiserUnfrozen {
                    #[doc = "Identity of the external agent who unfroze the fundraiser."]
                    agent_did: ::polymesh_api_client::IdentityId,
                    #[doc = "Asset associated with the fundraiser."]
                    offering_asset: ::polymesh_api_client::AssetId,
                    #[doc = "Fundraiser that was unfrozen."]
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                },
                #[doc = "A fundraiser's time window has been modified."]
                #[doc = ""]
                #[doc = "[agent_did, offering_asset, fundraiser_id, old_start, old_end, new_start, new_end]"]
                #[codec(index = 4u8)]
                FundraiserWindowModified {
                    #[doc = "Identity of the external agent who modified the window."]
                    agent_did: polymesh_primitives::event_only::EventOnly<
                        ::polymesh_api_client::IdentityId,
                    >,
                    #[doc = "Asset associated with the fundraiser."]
                    offering_asset: ::polymesh_api_client::AssetId,
                    #[doc = "Fundraiser whose window was modified."]
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                    #[doc = "Previous start time."]
                    old_start: u64,
                    #[doc = "Previous end time (if any)."]
                    old_end: Option<u64>,
                    #[doc = "New start time."]
                    new_start: u64,
                    #[doc = "New end time (if any)."]
                    new_end: Option<u64>,
                },
                #[doc = "A fundraiser has been permanently closed."]
                #[doc = ""]
                #[doc = "[agent_did, offering_asset, fundraiser_id]"]
                #[codec(index = 5u8)]
                FundraiserClosed {
                    #[doc = "Identity of the external agent who closed the fundraiser."]
                    agent_did: ::polymesh_api_client::IdentityId,
                    #[doc = "Asset associated with the fundraiser."]
                    offering_asset: ::polymesh_api_client::AssetId,
                    #[doc = "Fundraiser that was closed."]
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                },
                #[doc = "Off-chain funding has been enabled for a fundraiser."]
                #[doc = ""]
                #[doc = "[agent_did, offering_asset, fundraiser_id, ticker]"]
                #[codec(index = 6u8)]
                FundraiserOffchainFundingEnabled {
                    #[doc = "Identity of the external agent who enabled off-chain funding."]
                    agent_did: ::polymesh_api_client::IdentityId,
                    #[doc = "Asset associated with the fundraiser."]
                    offering_asset: ::polymesh_api_client::AssetId,
                    #[doc = "Fundraiser for which off-chain funding was enabled."]
                    fundraiser_id: polymesh_primitives::sto::FundraiserId,
                    #[doc = "Ticker symbol of the off-chain asset."]
                    ticker: polymesh_primitives::ticker::Ticker,
                },
            }
            impl StoEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::FundraiserCreated { .. } => "Sto.FundraiserCreated",
                        Self::Invested { .. } => "Sto.Invested",
                        Self::FundraiserFrozen { .. } => "Sto.FundraiserFrozen",
                        Self::FundraiserUnfrozen { .. } => "Sto.FundraiserUnfrozen",
                        Self::FundraiserWindowModified { .. } => "Sto.FundraiserWindowModified",
                        Self::FundraiserClosed { .. } => "Sto.FundraiserClosed",
                        Self::FundraiserOffchainFundingEnabled { .. } => {
                            "Sto.FundraiserOffchainFundingEnabled"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for StoEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: FundraiserCreated { .. } => { & ["A new fundraiser has been created." , "" , "[agent_did, offering_asset, raising_asset, fundraiser_id, fundraiser_name, fundraiser]" ,] } , Self :: Invested { .. } => { & ["An investor successfully invested in the fundraiser." , "" , "[investor_did, offering_asset, fundraiser_id, funding_asset, offering_amount, raise_amount]" ,] } , Self :: FundraiserFrozen { .. } => { & ["A fundraiser has been frozen, preventing new investments." , "" , "[agent_did, offering_asset, fundraiser_id]" ,] } , Self :: FundraiserUnfrozen { .. } => { & ["A fundraiser has been unfrozen, allowing new investments." , "" , "[agent_did, offering_asset, fundraiser_id]" ,] } , Self :: FundraiserWindowModified { .. } => { & ["A fundraiser's time window has been modified." , "" , "[agent_did, offering_asset, fundraiser_id, old_start, old_end, new_start, new_end]" ,] } , Self :: FundraiserClosed { .. } => { & ["A fundraiser has been permanently closed." , "" , "[agent_did, offering_asset, fundraiser_id]" ,] } , Self :: FundraiserOffchainFundingEnabled { .. } => { & ["Off-chain funding has been enabled for a fundraiser." , "" , "[agent_did, offering_asset, fundraiser_id, ticker]" ,] } , _ => & [""] , }
                }
            }
            impl From<StoEvent> for &'static str {
                fn from(v: StoEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&StoEvent> for &'static str {
                fn from(v: &StoEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum FundingAsset {
            #[codec(index = 0u8)]
            OnChain(::polymesh_api_client::AssetId),
            #[codec(index = 1u8)]
            OffChain(polymesh_primitives::ticker::Ticker),
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum FundingMethod<AccountId, OffChainSignature> {
            #[codec(index = 0u8)]
            OnChain(polymesh_primitives::identity_id::PortfolioId),
            #[codec(index = 1u8)]
            OffChain(
                polymesh_primitives::sto::FundraiserReceiptDetails<AccountId, OffChainSignature>,
            ),
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Fundraiser<Moment> {
            pub creator: ::polymesh_api_client::IdentityId,
            pub offering_portfolio: polymesh_primitives::identity_id::PortfolioId,
            pub offering_asset: ::polymesh_api_client::AssetId,
            pub raising_portfolio: polymesh_primitives::identity_id::PortfolioId,
            pub raising_asset: ::polymesh_api_client::AssetId,
            pub tiers: ::alloc::vec::Vec<pallet_sto::FundraiserTier>,
            pub venue_id: polymesh_primitives::settlement::VenueId,
            pub start: Moment,
            pub end: Option<Moment>,
            pub status: pallet_sto::FundraiserStatus,
            pub minimum_investment: u128,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct FundraiserName(pub ::alloc::vec::Vec<u8>);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum FundraiserStatus {
            #[codec(index = 0u8)]
            Live,
            #[codec(index = 1u8)]
            Frozen,
            #[codec(index = 2u8)]
            Closed,
            #[codec(index = 3u8)]
            ClosedEarly,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct FundraiserTier {
            pub total: u128,
            pub price: u128,
            pub remaining: u128,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct PriceTier {
            pub total: u128,
            pub price: u128,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Version(pub u8);
    }
    pub mod pallet_sudo {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SudoCall {
                #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
                #[codec(index = 0u8)]
                sudo {
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                },
                #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
                #[doc = "This function does not check the weight of the call, and instead allows the"]
                #[doc = "Sudo user to specify the weight of the call."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Signed_."]
                #[codec(index = 1u8)]
                sudo_unchecked_weight {
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                    weight: ::polymesh_api_client::sp_weights::Weight,
                },
                #[doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"]
                #[doc = "key."]
                #[codec(index = 2u8)]
                set_key {
                    new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                },
                #[doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"]
                #[doc = "a given account."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Signed_."]
                #[codec(index = 3u8)]
                sudo_as {
                    who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                },
                #[doc = "Permanently removes the sudo key."]
                #[doc = ""]
                #[doc = "**This cannot be un-done.**"]
                #[codec(index = 4u8)]
                remove_key,
            }
            impl SudoCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::sudo { .. } => "Sudo.sudo",
                        Self::sudo_unchecked_weight { .. } => "Sudo.sudo_unchecked_weight",
                        Self::set_key { .. } => "Sudo.set_key",
                        Self::sudo_as { .. } => "Sudo.sudo_as",
                        Self::remove_key => "Sudo.remove_key",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SudoCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: sudo { .. } => { & ["Authenticates the sudo key and dispatches a function call with `Root` origin." ,] } , Self :: sudo_unchecked_weight { .. } => { & ["Authenticates the sudo key and dispatches a function call with `Root` origin." , "This function does not check the weight of the call, and instead allows the" , "Sudo user to specify the weight of the call." , "" , "The dispatch origin for this call must be _Signed_." ,] } , Self :: set_key { .. } => { & ["Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo" , "key." ,] } , Self :: sudo_as { .. } => { & ["Authenticates the sudo key and dispatches a function call with `Signed` origin from" , "a given account." , "" , "The dispatch origin for this call must be _Signed_." ,] } , Self :: remove_key => { & ["Permanently removes the sudo key." , "" , "**This cannot be un-done.**" ,] } , _ => & [""] , }
                }
            }
            impl From<SudoCall> for &'static str {
                fn from(v: SudoCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SudoCall> for &'static str {
                fn from(v: &SudoCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "Error for the Sudo pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SudoError {
                #[doc = "Sender must be the Sudo account."]
                #[codec(index = 0u8)]
                RequireSudo,
            }
            impl SudoError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::RequireSudo => "Sudo.RequireSudo",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SudoError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::RequireSudo => &["Sender must be the Sudo account."],
                        _ => &[""],
                    }
                }
            }
            impl From<SudoError> for &'static str {
                fn from(v: SudoError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SudoError> for &'static str {
                fn from(v: &SudoError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SudoEvent {
                #[doc = "A sudo call just took place."]
                #[codec(index = 0u8)]
                Sudid {
                    #[doc = "The result of the call made by the sudo user."]
                    sudo_result: Result<(), sp_runtime::DispatchError>,
                },
                #[doc = "The sudo key has been updated."]
                #[codec(index = 1u8)]
                KeyChanged {
                    #[doc = "The old sudo key (if one was previously set)."]
                    old: Option<::polymesh_api_client::AccountId>,
                    #[doc = "The new sudo key (if one was set)."]
                    new: ::polymesh_api_client::AccountId,
                },
                #[doc = "The key was permanently removed."]
                #[codec(index = 2u8)]
                KeyRemoved,
                #[doc = "A [sudo_as](Pallet::sudo_as) call just took place."]
                #[codec(index = 3u8)]
                SudoAsDone {
                    #[doc = "The result of the call made by the sudo user."]
                    sudo_result: Result<(), sp_runtime::DispatchError>,
                },
            }
            impl SudoEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Sudid { .. } => "Sudo.Sudid",
                        Self::KeyChanged { .. } => "Sudo.KeyChanged",
                        Self::KeyRemoved => "Sudo.KeyRemoved",
                        Self::SudoAsDone { .. } => "Sudo.SudoAsDone",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for SudoEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Sudid { .. } => &["A sudo call just took place."],
                        Self::KeyChanged { .. } => &["The sudo key has been updated."],
                        Self::KeyRemoved => &["The key was permanently removed."],
                        Self::SudoAsDone { .. } => {
                            &["A [sudo_as](Pallet::sudo_as) call just took place."]
                        }
                        _ => &[""],
                    }
                }
            }
            impl From<SudoEvent> for &'static str {
                fn from(v: SudoEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&SudoEvent> for &'static str {
                fn from(v: &SudoEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_timestamp {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum TimestampCall {
                #[doc = "Set the current time."]
                #[doc = ""]
                #[doc = "This call should be invoked exactly once per block. It will panic at the finalization"]
                #[doc = "phase, if this call hasn't been invoked by that time."]
                #[doc = ""]
                #[doc = "The timestamp should be greater than the previous one by the amount specified by"]
                #[doc = "[`Config::MinimumPeriod`]."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _None_."]
                #[doc = ""]
                #[doc = "This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware"]
                #[doc = "that changing the complexity of this call could result exhausting the resources in a"]
                #[doc = "block to execute any other calls."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"]
                #[doc = "- 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in"]
                #[doc = "  `on_finalize`)"]
                #[doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."]
                #[codec(index = 0u8)]
                set {
                    #[codec(compact)]
                    now: u64,
                },
            }
            impl TimestampCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::set { .. } => "Timestamp.set",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for TimestampCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: set { .. } => { & ["Set the current time." , "" , "This call should be invoked exactly once per block. It will panic at the finalization" , "phase, if this call hasn't been invoked by that time." , "" , "The timestamp should be greater than the previous one by the amount specified by" , "[`Config::MinimumPeriod`]." , "" , "The dispatch origin for this call must be _None_." , "" , "This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware" , "that changing the complexity of this call could result exhausting the resources in a" , "block to execute any other calls." , "" , "## Complexity" , "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)" , "- 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in" , "  `on_finalize`)" , "- 1 event handler `on_timestamp_set`. Must be `O(1)`." ,] } , _ => & [""] , }
                }
            }
            impl From<TimestampCall> for &'static str {
                fn from(v: TimestampCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&TimestampCall> for &'static str {
                fn from(v: &TimestampCall) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_transaction_payment {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum TransactionPaymentEvent {
                #[doc = "A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,"]
                #[doc = "has been paid by `who`."]
                #[codec(index = 0u8)]
                TransactionFeePaid {
                    who: ::polymesh_api_client::AccountId,
                    actual_fee: u128,
                    tip: u128,
                },
            }
            impl TransactionPaymentEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::TransactionFeePaid { .. } => "TransactionPayment.TransactionFeePaid",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for TransactionPaymentEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: TransactionFeePaid { .. } => { & ["A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee," , "has been paid by `who`." ,] } , _ => & [""] , }
                }
            }
            impl From<TransactionPaymentEvent> for &'static str {
                fn from(v: TransactionPaymentEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&TransactionPaymentEvent> for &'static str {
                fn from(v: &TransactionPaymentEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Releases {
            #[codec(index = 0u8)]
            V1Ancient,
            #[codec(index = 1u8)]
            V2,
        }
    }
    pub mod pallet_treasury {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum TreasuryCall {
                #[doc = "It transfers balances from treasury to each of beneficiaries and the specific amount"]
                #[doc = "for each of them."]
                #[doc = ""]
                #[doc = "# Error"]
                #[doc = "* `BadOrigin`: Only root can execute transaction."]
                #[doc = "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries."]
                #[doc = "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity."]
                #[codec(index = 0u8)]
                disbursement {
                    beneficiaries: ::alloc::vec::Vec<polymesh_primitives::Beneficiary<u128>>,
                },
                #[doc = "It transfers the specific `amount` from `origin` account into treasury."]
                #[doc = ""]
                #[doc = "Only accounts which are associated to an identity can make a donation to treasury."]
                #[codec(index = 1u8)]
                reimbursement { amount: u128 },
            }
            impl TreasuryCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::disbursement { .. } => "Treasury.disbursement",
                        Self::reimbursement { .. } => "Treasury.reimbursement",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for TreasuryCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: disbursement { .. } => { & ["It transfers balances from treasury to each of beneficiaries and the specific amount" , "for each of them." , "" , "# Error" , "* `BadOrigin`: Only root can execute transaction." , "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries." , "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity." ,] } , Self :: reimbursement { .. } => { & ["It transfers the specific `amount` from `origin` account into treasury." , "" , "Only accounts which are associated to an identity can make a donation to treasury." ,] } , _ => & [""] , }
                }
            }
            impl From<TreasuryCall> for &'static str {
                fn from(v: TreasuryCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&TreasuryCall> for &'static str {
                fn from(v: &TreasuryCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum TreasuryError {
                #[doc = "Proposer's balance is too low."]
                #[codec(index = 0u8)]
                InsufficientBalance,
                #[doc = "Invalid identity for disbursement."]
                #[codec(index = 1u8)]
                InvalidIdentity,
            }
            impl TreasuryError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InsufficientBalance => "Treasury.InsufficientBalance",
                        Self::InvalidIdentity => "Treasury.InvalidIdentity",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for TreasuryError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InsufficientBalance => &["Proposer's balance is too low."],
                        Self::InvalidIdentity => &["Invalid identity for disbursement."],
                        _ => &[""],
                    }
                }
            }
            impl From<TreasuryError> for &'static str {
                fn from(v: TreasuryError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&TreasuryError> for &'static str {
                fn from(v: &TreasuryError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum TreasuryEvent {
                #[doc = "Disbursement to a target Identity."]
                #[doc = ""]
                #[doc = "(treasury identity, target identity, target primary key, amount)"]
                #[codec(index = 0u8)]
                TreasuryDisbursement(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AccountId,
                    u128,
                ),
                #[doc = "Disbursement to a target Identity failed."]
                #[doc = ""]
                #[doc = "(treasury identity, target identity, target primary key, amount)"]
                #[codec(index = 1u8)]
                TreasuryDisbursementFailed(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::AccountId,
                    u128,
                ),
                #[doc = "Treasury reimbursement."]
                #[doc = ""]
                #[doc = "(source identity, amount)"]
                #[codec(index = 2u8)]
                TreasuryReimbursement(::polymesh_api_client::IdentityId, u128),
            }
            impl TreasuryEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::TreasuryDisbursement(_, _, _, _) => "Treasury.TreasuryDisbursement",
                        Self::TreasuryDisbursementFailed(_, _, _, _) => {
                            "Treasury.TreasuryDisbursementFailed"
                        }
                        Self::TreasuryReimbursement(_, _) => "Treasury.TreasuryReimbursement",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for TreasuryEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::TreasuryDisbursement(_, _, _, _) => &[
                            "Disbursement to a target Identity.",
                            "",
                            "(treasury identity, target identity, target primary key, amount)",
                        ],
                        Self::TreasuryDisbursementFailed(_, _, _, _) => &[
                            "Disbursement to a target Identity failed.",
                            "",
                            "(treasury identity, target identity, target primary key, amount)",
                        ],
                        Self::TreasuryReimbursement(_, _) => {
                            &["Treasury reimbursement.", "", "(source identity, amount)"]
                        }
                        _ => &[""],
                    }
                }
            }
            impl From<TreasuryEvent> for &'static str {
                fn from(v: TreasuryEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&TreasuryEvent> for &'static str {
                fn from(v: &TreasuryEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
    }
    pub mod pallet_utility {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum UtilityCall {
                #[doc = "Send a batch of dispatch calls."]
                #[doc = ""]
                #[doc = "May be called from any origin except `None`."]
                #[doc = ""]
                #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
                #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
                #[doc = ""]
                #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
                #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- O(C) where C is the number of calls to be batched."]
                #[doc = ""]
                #[doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"]
                #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
                #[doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"]
                #[doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"]
                #[doc = "event is deposited."]
                #[codec(index = 0u8)]
                batch {
                    calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
                },
                #[doc = "Relay a call for a target from an origin"]
                #[doc = ""]
                #[doc = "Relaying in this context refers to the ability of origin to make a call on behalf of"]
                #[doc = "target."]
                #[doc = ""]
                #[doc = "Fees are charged to origin"]
                #[doc = ""]
                #[doc = "# Parameters"]
                #[doc = "- `target`: Account to be relayed"]
                #[doc = "- `signature`: Signature from target authorizing the relay"]
                #[doc = "- `call`: Call to be relayed on behalf of target"]
                #[doc = ""]
                #[doc = "POLYMESH: added."]
                #[codec(index = 1u8)]
                relay_tx {
                    target: ::polymesh_api_client::AccountId,
                    signature: ::polymesh_api_client::MultiSignature,
                    call: pallet_utility::UniqueCall<runtime::RuntimeCall>,
                },
                #[doc = "Send a batch of dispatch calls and atomically execute them."]
                #[doc = "The whole transaction will rollback and fail if any of the calls failed."]
                #[doc = ""]
                #[doc = "May be called from any origin except `None`."]
                #[doc = ""]
                #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
                #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
                #[doc = ""]
                #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
                #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- O(C) where C is the number of calls to be batched."]
                #[codec(index = 2u8)]
                batch_all {
                    calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
                },
                #[doc = "Dispatches a function call with a provided origin."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Root_."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- O(1)."]
                #[codec(index = 3u8)]
                dispatch_as {
                    as_origin: ::alloc::boxed::Box<runtime::OriginCaller>,
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                },
                #[doc = "Send a batch of dispatch calls."]
                #[doc = "Unlike `batch`, it allows errors and won't interrupt."]
                #[doc = ""]
                #[doc = "May be called from any origin except `None`."]
                #[doc = ""]
                #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
                #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
                #[doc = ""]
                #[doc = "If origin is root then the calls are dispatch without checking origin filter. (This"]
                #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
                #[doc = ""]
                #[doc = "## Complexity"]
                #[doc = "- O(C) where C is the number of calls to be batched."]
                #[codec(index = 4u8)]
                force_batch {
                    calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
                },
                #[doc = "Dispatch a function call with a specified weight."]
                #[doc = ""]
                #[doc = "This function does not check the weight of the call, and instead allows the"]
                #[doc = "Root origin to specify the weight of the call."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Root_."]
                #[codec(index = 5u8)]
                with_weight {
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                    weight: ::polymesh_api_client::sp_weights::Weight,
                },
                #[doc = "Send a call through an indexed pseudonym of the sender."]
                #[doc = ""]
                #[doc = "Filter from origin are passed along. The call will be dispatched with an origin which"]
                #[doc = "use the same filter as the origin of this call."]
                #[doc = ""]
                #[doc = "The dispatch origin for this call must be _Signed_."]
                #[codec(index = 9u8)]
                as_derivative {
                    index: u16,
                    call: ::alloc::boxed::Box<runtime::RuntimeCall>,
                },
            }
            impl UtilityCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::batch { .. } => "Utility.batch",
                        Self::relay_tx { .. } => "Utility.relay_tx",
                        Self::batch_all { .. } => "Utility.batch_all",
                        Self::dispatch_as { .. } => "Utility.dispatch_as",
                        Self::force_batch { .. } => "Utility.force_batch",
                        Self::with_weight { .. } => "Utility.with_weight",
                        Self::as_derivative { .. } => "Utility.as_derivative",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for UtilityCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: batch { .. } => { & ["Send a batch of dispatch calls." , "" , "May be called from any origin except `None`." , "" , "- `calls`: The calls to be dispatched from the same origin. The number of call must not" , "  exceed the constant: `batched_calls_limit` (available in constant metadata)." , "" , "If origin is root then the calls are dispatched without checking origin filter. (This" , "includes bypassing `frame_system::Config::BaseCallFilter`)." , "" , "## Complexity" , "- O(C) where C is the number of calls to be batched." , "" , "This will return `Ok` in all circumstances. To determine the success of the batch, an" , "event is deposited. If a call failed and the batch was interrupted, then the" , "`BatchInterrupted` event is deposited, along with the number of successful calls made" , "and the error of the failed call. If all were successful, then the `BatchCompleted`" , "event is deposited." ,] } , Self :: relay_tx { .. } => { & ["Relay a call for a target from an origin" , "" , "Relaying in this context refers to the ability of origin to make a call on behalf of" , "target." , "" , "Fees are charged to origin" , "" , "# Parameters" , "- `target`: Account to be relayed" , "- `signature`: Signature from target authorizing the relay" , "- `call`: Call to be relayed on behalf of target" , "" , "POLYMESH: added." ,] } , Self :: batch_all { .. } => { & ["Send a batch of dispatch calls and atomically execute them." , "The whole transaction will rollback and fail if any of the calls failed." , "" , "May be called from any origin except `None`." , "" , "- `calls`: The calls to be dispatched from the same origin. The number of call must not" , "  exceed the constant: `batched_calls_limit` (available in constant metadata)." , "" , "If origin is root then the calls are dispatched without checking origin filter. (This" , "includes bypassing `frame_system::Config::BaseCallFilter`)." , "" , "## Complexity" , "- O(C) where C is the number of calls to be batched." ,] } , Self :: dispatch_as { .. } => { & ["Dispatches a function call with a provided origin." , "" , "The dispatch origin for this call must be _Root_." , "" , "## Complexity" , "- O(1)." ,] } , Self :: force_batch { .. } => { & ["Send a batch of dispatch calls." , "Unlike `batch`, it allows errors and won't interrupt." , "" , "May be called from any origin except `None`." , "" , "- `calls`: The calls to be dispatched from the same origin. The number of call must not" , "  exceed the constant: `batched_calls_limit` (available in constant metadata)." , "" , "If origin is root then the calls are dispatch without checking origin filter. (This" , "includes bypassing `frame_system::Config::BaseCallFilter`)." , "" , "## Complexity" , "- O(C) where C is the number of calls to be batched." ,] } , Self :: with_weight { .. } => { & ["Dispatch a function call with a specified weight." , "" , "This function does not check the weight of the call, and instead allows the" , "Root origin to specify the weight of the call." , "" , "The dispatch origin for this call must be _Root_." ,] } , Self :: as_derivative { .. } => { & ["Send a call through an indexed pseudonym of the sender." , "" , "Filter from origin are passed along. The call will be dispatched with an origin which" , "use the same filter as the origin of this call." , "" , "The dispatch origin for this call must be _Signed_." ,] } , _ => & [""] , }
                }
            }
            impl From<UtilityCall> for &'static str {
                fn from(v: UtilityCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&UtilityCall> for &'static str {
                fn from(v: &UtilityCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum UtilityError {
                #[doc = "Too many calls batched."]
                #[codec(index = 0u8)]
                TooManyCalls,
                #[doc = "Offchain signature is invalid"]
                #[doc = "POLYMESH error"]
                #[codec(index = 1u8)]
                InvalidSignature,
                #[doc = "Target does not have a valid CDD"]
                #[doc = "POLYMESH error"]
                #[codec(index = 2u8)]
                TargetCddMissing,
                #[doc = "Provided nonce was invalid"]
                #[doc = "If the provided nonce < current nonce, the call was already executed"]
                #[doc = "If the provided nonce > current nonce, the call(s) before the current failed to execute"]
                #[doc = "POLYMESH error"]
                #[codec(index = 3u8)]
                InvalidNonce,
                #[doc = "Decoding derivative account Id failed."]
                #[codec(index = 4u8)]
                UnableToDeriveAccountId,
            }
            impl UtilityError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::TooManyCalls => "Utility.TooManyCalls",
                        Self::InvalidSignature => "Utility.InvalidSignature",
                        Self::TargetCddMissing => "Utility.TargetCddMissing",
                        Self::InvalidNonce => "Utility.InvalidNonce",
                        Self::UnableToDeriveAccountId => "Utility.UnableToDeriveAccountId",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for UtilityError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: TooManyCalls => { & ["Too many calls batched." ,] } , Self :: InvalidSignature => { & ["Offchain signature is invalid" , "POLYMESH error" ,] } , Self :: TargetCddMissing => { & ["Target does not have a valid CDD" , "POLYMESH error" ,] } , Self :: InvalidNonce => { & ["Provided nonce was invalid" , "If the provided nonce < current nonce, the call was already executed" , "If the provided nonce > current nonce, the call(s) before the current failed to execute" , "POLYMESH error" ,] } , Self :: UnableToDeriveAccountId => { & ["Decoding derivative account Id failed." ,] } , _ => & [""] , }
                }
            }
            impl From<UtilityError> for &'static str {
                fn from(v: UtilityError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&UtilityError> for &'static str {
                fn from(v: &UtilityError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum UtilityEvent {
                #[doc = "Batch of dispatches did not complete fully. Index of first failing dispatch given, as"]
                #[doc = "well as the error."]
                #[codec(index = 0u8)]
                BatchInterrupted {
                    index: u32,
                    error: sp_runtime::DispatchError,
                },
                #[doc = "Batch of dispatches completed fully with no error."]
                #[codec(index = 1u8)]
                BatchCompleted,
                #[doc = "Batch of dispatches completed but has errors."]
                #[codec(index = 2u8)]
                BatchCompletedWithErrors,
                #[doc = "A single item within a Batch of dispatches has completed with no error."]
                #[codec(index = 3u8)]
                ItemCompleted,
                #[doc = "A single item within a Batch of dispatches has completed with error."]
                #[codec(index = 4u8)]
                ItemFailed { error: sp_runtime::DispatchError },
                #[doc = "A call was dispatched."]
                #[codec(index = 5u8)]
                DispatchedAs {
                    result: Result<(), sp_runtime::DispatchError>,
                },
                #[doc = "Relayed transaction."]
                #[doc = "POLYMESH: event."]
                #[codec(index = 6u8)]
                RelayedTx {
                    caller_did: ::polymesh_api_client::IdentityId,
                    target: ::polymesh_api_client::AccountId,
                    result: Result<(), sp_runtime::DispatchError>,
                },
            }
            impl UtilityEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::BatchInterrupted { .. } => "Utility.BatchInterrupted",
                        Self::BatchCompleted => "Utility.BatchCompleted",
                        Self::BatchCompletedWithErrors => "Utility.BatchCompletedWithErrors",
                        Self::ItemCompleted => "Utility.ItemCompleted",
                        Self::ItemFailed { .. } => "Utility.ItemFailed",
                        Self::DispatchedAs { .. } => "Utility.DispatchedAs",
                        Self::RelayedTx { .. } => "Utility.RelayedTx",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for UtilityEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: BatchInterrupted { .. } => { & ["Batch of dispatches did not complete fully. Index of first failing dispatch given, as" , "well as the error." ,] } , Self :: BatchCompleted => { & ["Batch of dispatches completed fully with no error." ,] } , Self :: BatchCompletedWithErrors => { & ["Batch of dispatches completed but has errors." ,] } , Self :: ItemCompleted => { & ["A single item within a Batch of dispatches has completed with no error." ,] } , Self :: ItemFailed { .. } => { & ["A single item within a Batch of dispatches has completed with error." ,] } , Self :: DispatchedAs { .. } => { & ["A call was dispatched." ,] } , Self :: RelayedTx { .. } => { & ["Relayed transaction." , "POLYMESH: event." ,] } , _ => & [""] , }
                }
            }
            impl From<UtilityEvent> for &'static str {
                fn from(v: UtilityEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&UtilityEvent> for &'static str {
                fn from(v: &UtilityEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct UniqueCall<C> {
            pub nonce: u64,
            pub call: ::alloc::boxed::Box<C>,
        }
    }
    pub mod pallet_validators {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ValidatorsCall {
                #[doc = "Adds a permissioned identity and sets its preferences."]
                #[doc = ""]
                #[doc = "The dispatch origin must be Root."]
                #[codec(index = 0u8)]
                add_permissioned_validator {
                    identity: ::polymesh_api_client::IdentityId,
                    intended_count: Option<u32>,
                },
                #[doc = "Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session."]
                #[doc = ""]
                #[doc = "The dispatch origin must be Root."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* origin Required origin for removing a potential validator."]
                #[doc = "* identity Validator's IdentityId."]
                #[codec(index = 1u8)]
                remove_permissioned_validator {
                    identity: ::polymesh_api_client::IdentityId,
                },
                #[codec(index = 2u8)]
                payout_stakers_by_system {
                    validator_stash: ::polymesh_api_client::AccountId,
                    era: u32,
                },
                #[doc = "Switch slashing status on the basis of given `slashing_switch`. Can only be called by root."]
                #[codec(index = 3u8)]
                change_slashing_allowed_for {
                    slashing_switch: pallet_validators::types::SlashingSwitch,
                },
                #[doc = "Sets the intended count to `new_intended_count` for the given `identity`."]
                #[codec(index = 4u8)]
                update_permissioned_validator_intended_count {
                    identity: ::polymesh_api_client::IdentityId,
                    new_intended_count: u32,
                },
                #[doc = "Governance council forcefully chills a validator. Effects will be felt at the beginning of the next era."]
                #[codec(index = 5u8)]
                chill_from_governance {
                    identity: ::polymesh_api_client::IdentityId,
                    stash_keys: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "Changes commission rate which applies to all validators. Only Governance"]
                #[doc = "committee is allowed to change this value."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "* `new_cap` the new commission cap."]
                #[codec(index = 6u8)]
                set_commission_cap {
                    new_cap: ::polymesh_api_client::per_things::Perbill,
                },
            }
            impl ValidatorsCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::add_permissioned_validator { .. } => {
                            "Validators.add_permissioned_validator"
                        }
                        Self::remove_permissioned_validator { .. } => {
                            "Validators.remove_permissioned_validator"
                        }
                        Self::payout_stakers_by_system { .. } => {
                            "Validators.payout_stakers_by_system"
                        }
                        Self::change_slashing_allowed_for { .. } => {
                            "Validators.change_slashing_allowed_for"
                        }
                        Self::update_permissioned_validator_intended_count { .. } => {
                            "Validators.update_permissioned_validator_intended_count"
                        }
                        Self::chill_from_governance { .. } => "Validators.chill_from_governance",
                        Self::set_commission_cap { .. } => "Validators.set_commission_cap",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ValidatorsCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: add_permissioned_validator { .. } => { & ["Adds a permissioned identity and sets its preferences." , "" , "The dispatch origin must be Root." ,] } , Self :: remove_permissioned_validator { .. } => { & ["Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session." , "" , "The dispatch origin must be Root." , "" , "# Arguments" , "* origin Required origin for removing a potential validator." , "* identity Validator's IdentityId." ,] } , Self :: payout_stakers_by_system { .. } => { & ["" ,] } , Self :: change_slashing_allowed_for { .. } => { & ["Switch slashing status on the basis of given `slashing_switch`. Can only be called by root." ,] } , Self :: update_permissioned_validator_intended_count { .. } => { & ["Sets the intended count to `new_intended_count` for the given `identity`." ,] } , Self :: chill_from_governance { .. } => { & ["Governance council forcefully chills a validator. Effects will be felt at the beginning of the next era." ,] } , Self :: set_commission_cap { .. } => { & ["Changes commission rate which applies to all validators. Only Governance" , "committee is allowed to change this value." , "" , "# Arguments" , "* `new_cap` the new commission cap." ,] } , _ => & [""] , }
                }
            }
            impl From<ValidatorsCall> for &'static str {
                fn from(v: ValidatorsCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ValidatorsCall> for &'static str {
                fn from(v: &ValidatorsCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ValidatorsError {
                #[doc = "Validator or nominator stash identity does not exist."]
                #[codec(index = 0u8)]
                StashIdentityDoesNotExist,
                #[doc = "Validator's stash identity is not permissioned."]
                #[codec(index = 1u8)]
                StashIdentityNotPermissioned,
                #[doc = "Permissioned validator already exists."]
                #[codec(index = 2u8)]
                IdentityIsAlreadyPermissioned,
                #[doc = "Identity has not gone throught CDD."]
                #[codec(index = 3u8)]
                IdentityIsMissingCDD,
                #[doc = "When the intended number of validators to run is >= 2/3 of `validator_count`."]
                #[codec(index = 4u8)]
                IntendedCountIsExceedingConsensusLimit,
                #[doc = "Identity was not found in the permissioned identity pool."]
                #[codec(index = 5u8)]
                IdentityNotFound,
                #[doc = "No validator was found for the given key."]
                #[codec(index = 6u8)]
                ValidatorNotFound,
                #[doc = "Validator commiission is above maximum."]
                #[codec(index = 7u8)]
                CommissionTooHigh,
                #[doc = "New commission must be different from previous commission."]
                #[codec(index = 8u8)]
                CommissionUnchanged,
            }
            impl ValidatorsError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::StashIdentityDoesNotExist => "Validators.StashIdentityDoesNotExist",
                        Self::StashIdentityNotPermissioned => {
                            "Validators.StashIdentityNotPermissioned"
                        }
                        Self::IdentityIsAlreadyPermissioned => {
                            "Validators.IdentityIsAlreadyPermissioned"
                        }
                        Self::IdentityIsMissingCDD => "Validators.IdentityIsMissingCDD",
                        Self::IntendedCountIsExceedingConsensusLimit => {
                            "Validators.IntendedCountIsExceedingConsensusLimit"
                        }
                        Self::IdentityNotFound => "Validators.IdentityNotFound",
                        Self::ValidatorNotFound => "Validators.ValidatorNotFound",
                        Self::CommissionTooHigh => "Validators.CommissionTooHigh",
                        Self::CommissionUnchanged => "Validators.CommissionUnchanged",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ValidatorsError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: StashIdentityDoesNotExist => { & ["Validator or nominator stash identity does not exist." ,] } , Self :: StashIdentityNotPermissioned => { & ["Validator's stash identity is not permissioned." ,] } , Self :: IdentityIsAlreadyPermissioned => { & ["Permissioned validator already exists." ,] } , Self :: IdentityIsMissingCDD => { & ["Identity has not gone throught CDD." ,] } , Self :: IntendedCountIsExceedingConsensusLimit => { & ["When the intended number of validators to run is >= 2/3 of `validator_count`." ,] } , Self :: IdentityNotFound => { & ["Identity was not found in the permissioned identity pool." ,] } , Self :: ValidatorNotFound => { & ["No validator was found for the given key." ,] } , Self :: CommissionTooHigh => { & ["Validator commiission is above maximum." ,] } , Self :: CommissionUnchanged => { & ["New commission must be different from previous commission." ,] } , _ => & [""] , }
                }
            }
            impl From<ValidatorsError> for &'static str {
                fn from(v: ValidatorsError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ValidatorsError> for &'static str {
                fn from(v: &ValidatorsError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ValidatorsEvent {
                #[doc = "User has updated their nominations."]
                #[codec(index = 0u8)]
                Nominated {
                    nominator_identity: ::polymesh_api_client::IdentityId,
                    stash: ::polymesh_api_client::AccountId,
                    targets: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "An identity has issued a candidacy for becoming a validator."]
                #[codec(index = 1u8)]
                PermissionedIdentityAdded {
                    governance_councill_did: ::polymesh_api_client::IdentityId,
                    validators_identity: ::polymesh_api_client::IdentityId,
                },
                #[doc = "An identity has been removed from the permissioned identities pool."]
                #[codec(index = 2u8)]
                PermissionedIdentityRemoved {
                    governance_councill_did: ::polymesh_api_client::IdentityId,
                    validators_identity: ::polymesh_api_client::IdentityId,
                },
                #[doc = "Remove the nominators from the valid nominators when there CDD expired."]
                #[codec(index = 3u8)]
                InvalidatedNominators {
                    governance_councill_did: ::polymesh_api_client::IdentityId,
                    governance_councill_account: ::polymesh_api_client::IdentityId,
                    expired_nominators: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                },
                #[doc = "Slashing allowed has been updated."]
                #[codec(index = 4u8)]
                SlashingAllowedForChanged {
                    slashing_switch: pallet_validators::types::SlashingSwitch,
                },
                #[doc = "Reward scheduling interrupted."]
                #[codec(index = 5u8)]
                RewardPaymentSchedulingInterrupted {
                    account_id: ::polymesh_api_client::AccountId,
                    era: u32,
                    error: sp_runtime::DispatchError,
                },
                #[doc = "Commission cap has been updated."]
                #[codec(index = 6u8)]
                CommissionCapUpdated {
                    governance_councill_did: ::polymesh_api_client::IdentityId,
                    old_commission_cap: ::polymesh_api_client::per_things::Perbill,
                    new_commission_cap: ::polymesh_api_client::per_things::Perbill,
                },
            }
            impl ValidatorsEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::Nominated { .. } => "Validators.Nominated",
                        Self::PermissionedIdentityAdded { .. } => {
                            "Validators.PermissionedIdentityAdded"
                        }
                        Self::PermissionedIdentityRemoved { .. } => {
                            "Validators.PermissionedIdentityRemoved"
                        }
                        Self::InvalidatedNominators { .. } => "Validators.InvalidatedNominators",
                        Self::SlashingAllowedForChanged { .. } => {
                            "Validators.SlashingAllowedForChanged"
                        }
                        Self::RewardPaymentSchedulingInterrupted { .. } => {
                            "Validators.RewardPaymentSchedulingInterrupted"
                        }
                        Self::CommissionCapUpdated { .. } => "Validators.CommissionCapUpdated",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for ValidatorsEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: Nominated { .. } => { & ["User has updated their nominations." ,] } , Self :: PermissionedIdentityAdded { .. } => { & ["An identity has issued a candidacy for becoming a validator." ,] } , Self :: PermissionedIdentityRemoved { .. } => { & ["An identity has been removed from the permissioned identities pool." ,] } , Self :: InvalidatedNominators { .. } => { & ["Remove the nominators from the valid nominators when there CDD expired." ,] } , Self :: SlashingAllowedForChanged { .. } => { & ["Slashing allowed has been updated." ,] } , Self :: RewardPaymentSchedulingInterrupted { .. } => { & ["Reward scheduling interrupted." ,] } , Self :: CommissionCapUpdated { .. } => { & ["Commission cap has been updated." ,] } , _ => & [""] , }
                }
            }
            impl From<ValidatorsEvent> for &'static str {
                fn from(v: ValidatorsEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&ValidatorsEvent> for &'static str {
                fn from(v: &ValidatorsEvent) -> Self {
                    v.as_static_str()
                }
            }
        }
        pub mod types {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PermissionedIdentityPrefs {
                pub intended_count: u32,
                pub running_count: u32,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SlashingSwitch {
                #[codec(index = 0u8)]
                Validator,
                #[codec(index = 1u8)]
                ValidatorAndNominator,
                #[codec(index = 2u8)]
                None,
            }
        }
    }
    pub mod polymesh_common_utilities {
        use super::*;
        pub mod protocol_fee {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ProtocolOp {
                #[codec(index = 0u8)]
                AssetRegisterTicker,
                #[codec(index = 1u8)]
                AssetIssue,
                #[codec(index = 2u8)]
                AssetAddDocuments,
                #[codec(index = 3u8)]
                AssetCreateAsset,
                #[codec(index = 4u8)]
                CheckpointCreateSchedule,
                #[codec(index = 5u8)]
                ComplianceManagerAddComplianceRequirement,
                #[codec(index = 6u8)]
                IdentityCddRegisterDid,
                #[codec(index = 7u8)]
                IdentityAddClaim,
                #[codec(index = 8u8)]
                IdentityAddSecondaryKeysWithAuthorization,
                #[codec(index = 9u8)]
                PipsPropose,
                #[codec(index = 10u8)]
                ContractsPutCode,
                #[codec(index = 11u8)]
                CorporateBallotAttachBallot,
                #[codec(index = 12u8)]
                CapitalDistributionDistribute,
                #[codec(index = 13u8)]
                NFTCreateCollection,
                #[codec(index = 14u8)]
                NFTMint,
                #[codec(index = 15u8)]
                IdentityCreateChildIdentity,
            }
        }
    }
    pub mod polymesh_contracts {
        use super::*;
        pub mod chain_extension {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ExtrinsicId(pub u8, pub u8);
        }
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PolymeshContractsCall {
                #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
                #[doc = ""]
                #[doc = "The contract will be attached as a secondary key,"]
                #[doc = "with `perms` as its permissions, to `origin`'s identity."]
                #[doc = ""]
                #[doc = "The contract is transferred `endowment` amount of POLYX."]
                #[doc = "This is distinct from the `gas_limit`,"]
                #[doc = "which controls how much gas the deployment code may at most consume."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
                #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
                #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
                #[doc = "  from the caller to pay for the storage consumed."]
                #[doc = "- `code` with the WASM binary defining the smart contract."]
                #[doc = "- `data` The input data to pass to the contract constructor."]
                #[doc = "- `salt` used for contract address derivation."]
                #[doc = "   By varying this, the same `code` can be used under the same identity."]
                #[doc = "- `perms` that the new secondary key will have."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here."]
                #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
                #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
                #[codec(index = 0u8)]
                instantiate_with_code_perms {
                    endowment: u128,
                    gas_limit: ::polymesh_api_client::sp_weights::Weight,
                    storage_deposit_limit: Option<u128>,
                    code: ::alloc::vec::Vec<u8>,
                    data: ::alloc::vec::Vec<u8>,
                    salt: ::alloc::vec::Vec<u8>,
                    perms: polymesh_primitives::secondary_key::Permissions,
                },
                #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
                #[doc = ""]
                #[doc = "Unlike `instantiate_with_code`,"]
                #[doc = "this assumes that at least one contract with the same WASM code has already been uploaded."]
                #[doc = ""]
                #[doc = "The contract will be attached as a secondary key,"]
                #[doc = "with `perms` as its permissions, to `origin`'s identity."]
                #[doc = ""]
                #[doc = "The contract is transferred `endowment` amount of POLYX."]
                #[doc = "This is distinct from the `gas_limit`,"]
                #[doc = "which controls how much gas the deployment code may at most consume."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
                #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
                #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
                #[doc = "  from the caller to pay for the storage consumed."]
                #[doc = "- `code_hash` of an already uploaded WASM binary."]
                #[doc = "- `data` The input data to pass to the contract constructor."]
                #[doc = "- `salt` used for contract address derivation."]
                #[doc = "   By varying this, the same `code` can be used under the same identity."]
                #[doc = "- `perms` that the new secondary key will have."]
                #[doc = ""]
                #[doc = "# Errors"]
                #[doc = "- All the errors in `pallet_contracts::Call::instantiate` can also happen here."]
                #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
                #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
                #[codec(index = 1u8)]
                instantiate_with_hash_perms {
                    endowment: u128,
                    gas_limit: ::polymesh_api_client::sp_weights::Weight,
                    storage_deposit_limit: Option<u128>,
                    code_hash: primitive_types::H256,
                    data: ::alloc::vec::Vec<u8>,
                    salt: ::alloc::vec::Vec<u8>,
                    perms: polymesh_primitives::secondary_key::Permissions,
                },
                #[doc = "Update CallRuntime whitelist."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = ""]
                #[doc = "# Errors"]
                #[codec(index = 2u8)]
                update_call_runtime_whitelist {
                    updates:
                        ::alloc::vec::Vec<(polymesh_contracts::chain_extension::ExtrinsicId, bool)>,
                },
                #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
                #[doc = ""]
                #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `endowment`: Amount of POLYX to transfer to the contract."]
                #[doc = "- `gas_limit`: For how much gas the `deploy` code in the contract may at most consume."]
                #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
                #[doc = "- `code`: The WASM binary defining the smart contract."]
                #[doc = "- `data`: The input data to pass to the contract constructor."]
                #[doc = "- `salt`: Used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
                #[doc = ""]
                #[codec(index = 3u8)]
                instantiate_with_code_as_primary_key {
                    endowment: u128,
                    gas_limit: ::polymesh_api_client::sp_weights::Weight,
                    storage_deposit_limit: Option<u128>,
                    code: ::alloc::vec::Vec<u8>,
                    data: ::alloc::vec::Vec<u8>,
                    salt: ::alloc::vec::Vec<u8>,
                },
                #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
                #[doc = ""]
                #[doc = "Unlike `instantiate_with_code`, this assumes that at least one contract with the same WASM code has already been uploaded."]
                #[doc = ""]
                #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
                #[doc = ""]
                #[doc = "# Arguments"]
                #[doc = "- `endowment`: amount of POLYX to transfer to the contract."]
                #[doc = "- `gas_limit`: for how much gas the `deploy` code in the contract may at most consume."]
                #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
                #[doc = "- `code_hash`: of an already uploaded WASM binary."]
                #[doc = "- `data`: The input data to pass to the contract constructor."]
                #[doc = "- `salt`: used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
                #[doc = ""]
                #[codec(index = 4u8)]
                instantiate_with_hash_as_primary_key {
                    endowment: u128,
                    gas_limit: ::polymesh_api_client::sp_weights::Weight,
                    storage_deposit_limit: Option<u128>,
                    code_hash: primitive_types::H256,
                    data: ::alloc::vec::Vec<u8>,
                    salt: ::alloc::vec::Vec<u8>,
                },
                #[codec(index = 5u8)]
                upgrade_api {
                    api: polymesh_contracts::Api,
                    next_upgrade: polymesh_contracts::NextUpgrade,
                },
            }
            impl PolymeshContractsCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::instantiate_with_code_perms { .. } => {
                            "PolymeshContracts.instantiate_with_code_perms"
                        }
                        Self::instantiate_with_hash_perms { .. } => {
                            "PolymeshContracts.instantiate_with_hash_perms"
                        }
                        Self::update_call_runtime_whitelist { .. } => {
                            "PolymeshContracts.update_call_runtime_whitelist"
                        }
                        Self::instantiate_with_code_as_primary_key { .. } => {
                            "PolymeshContracts.instantiate_with_code_as_primary_key"
                        }
                        Self::instantiate_with_hash_as_primary_key { .. } => {
                            "PolymeshContracts.instantiate_with_hash_as_primary_key"
                        }
                        Self::upgrade_api { .. } => "PolymeshContracts.upgrade_api",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PolymeshContractsCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: instantiate_with_code_perms { .. } => { & ["Instantiates a smart contract defining it with the given `code` and `salt`." , "" , "The contract will be attached as a secondary key," , "with `perms` as its permissions, to `origin`'s identity." , "" , "The contract is transferred `endowment` amount of POLYX." , "This is distinct from the `gas_limit`," , "which controls how much gas the deployment code may at most consume." , "" , "# Arguments" , "- `endowment` amount of POLYX to transfer to the contract." , "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume." , "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved" , "  from the caller to pay for the storage consumed." , "- `code` with the WASM binary defining the smart contract." , "- `data` The input data to pass to the contract constructor." , "- `salt` used for contract address derivation." , "   By varying this, the same `code` can be used under the same identity." , "- `perms` that the new secondary key will have." , "" , "# Errors" , "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here." , "- CDD/Permissions are checked, unlike in `pallet_contracts`." , "- Errors that arise when adding a new secondary key can also occur here." ,] } , Self :: instantiate_with_hash_perms { .. } => { & ["Instantiates a smart contract defining using the given `code_hash` and `salt`." , "" , "Unlike `instantiate_with_code`," , "this assumes that at least one contract with the same WASM code has already been uploaded." , "" , "The contract will be attached as a secondary key," , "with `perms` as its permissions, to `origin`'s identity." , "" , "The contract is transferred `endowment` amount of POLYX." , "This is distinct from the `gas_limit`," , "which controls how much gas the deployment code may at most consume." , "" , "# Arguments" , "- `endowment` amount of POLYX to transfer to the contract." , "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume." , "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved" , "  from the caller to pay for the storage consumed." , "- `code_hash` of an already uploaded WASM binary." , "- `data` The input data to pass to the contract constructor." , "- `salt` used for contract address derivation." , "   By varying this, the same `code` can be used under the same identity." , "- `perms` that the new secondary key will have." , "" , "# Errors" , "- All the errors in `pallet_contracts::Call::instantiate` can also happen here." , "- CDD/Permissions are checked, unlike in `pallet_contracts`." , "- Errors that arise when adding a new secondary key can also occur here." ,] } , Self :: update_call_runtime_whitelist { .. } => { & ["Update CallRuntime whitelist." , "" , "# Arguments" , "" , "# Errors" ,] } , Self :: instantiate_with_code_as_primary_key { .. } => { & ["Instantiates a smart contract defining it with the given `code` and `salt`." , "" , "The contract will be attached as a primary key of a newly created child identity of the caller." , "" , "# Arguments" , "- `endowment`: Amount of POLYX to transfer to the contract." , "- `gas_limit`: For how much gas the `deploy` code in the contract may at most consume." , "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed." , "- `code`: The WASM binary defining the smart contract." , "- `data`: The input data to pass to the contract constructor." , "- `salt`: Used for contract address derivation. By varying this, the same `code` can be used under the same identity." , "" ,] } , Self :: instantiate_with_hash_as_primary_key { .. } => { & ["Instantiates a smart contract defining using the given `code_hash` and `salt`." , "" , "Unlike `instantiate_with_code`, this assumes that at least one contract with the same WASM code has already been uploaded." , "" , "The contract will be attached as a primary key of a newly created child identity of the caller." , "" , "# Arguments" , "- `endowment`: amount of POLYX to transfer to the contract." , "- `gas_limit`: for how much gas the `deploy` code in the contract may at most consume." , "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed." , "- `code_hash`: of an already uploaded WASM binary." , "- `data`: The input data to pass to the contract constructor." , "- `salt`: used for contract address derivation. By varying this, the same `code` can be used under the same identity." , "" ,] } , Self :: upgrade_api { .. } => { & ["" ,] } , _ => & [""] , }
                }
            }
            impl From<PolymeshContractsCall> for &'static str {
                fn from(v: PolymeshContractsCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PolymeshContractsCall> for &'static str {
                fn from(v: &PolymeshContractsCall) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Error` enum of this pallet."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PolymeshContractsError {
                #[doc = "Invalid `func_id` provided from contract."]
                #[codec(index = 0u8)]
                InvalidFuncId,
                #[doc = "Failed to decode a valid `RuntimeCall`."]
                #[codec(index = 1u8)]
                InvalidRuntimeCall,
                #[doc = "`ReadStorage` failed to write value into the contract's buffer."]
                #[codec(index = 2u8)]
                ReadStorageFailed,
                #[doc = "Data left in input when decoding arguments of a call."]
                #[codec(index = 3u8)]
                DataLeftAfterDecoding,
                #[doc = "Input data that a contract passed when using the ChainExtension was too large."]
                #[codec(index = 4u8)]
                InLenTooLarge,
                #[doc = "Output data returned from the ChainExtension was too large."]
                #[codec(index = 5u8)]
                OutLenTooLarge,
                #[doc = "A contract was attempted to be instantiated,"]
                #[doc = "but no identity was given to associate the new contract's key with."]
                #[codec(index = 6u8)]
                InstantiatorWithNoIdentity,
                #[doc = "Extrinsic is not allowed to be called by contracts."]
                #[codec(index = 7u8)]
                RuntimeCallDenied,
                #[doc = "The caller is not a primary key."]
                #[codec(index = 8u8)]
                CallerNotAPrimaryKey,
                #[doc = "Secondary key permissions are missing."]
                #[codec(index = 9u8)]
                MissingKeyPermissions,
                #[doc = "Only future chain versions are allowed."]
                #[codec(index = 10u8)]
                InvalidChainVersion,
                #[doc = "There are no api upgrades supported for the contract."]
                #[codec(index = 11u8)]
                NoUpgradesSupported,
            }
            impl PolymeshContractsError {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::InvalidFuncId => "PolymeshContracts.InvalidFuncId",
                        Self::InvalidRuntimeCall => "PolymeshContracts.InvalidRuntimeCall",
                        Self::ReadStorageFailed => "PolymeshContracts.ReadStorageFailed",
                        Self::DataLeftAfterDecoding => "PolymeshContracts.DataLeftAfterDecoding",
                        Self::InLenTooLarge => "PolymeshContracts.InLenTooLarge",
                        Self::OutLenTooLarge => "PolymeshContracts.OutLenTooLarge",
                        Self::InstantiatorWithNoIdentity => {
                            "PolymeshContracts.InstantiatorWithNoIdentity"
                        }
                        Self::RuntimeCallDenied => "PolymeshContracts.RuntimeCallDenied",
                        Self::CallerNotAPrimaryKey => "PolymeshContracts.CallerNotAPrimaryKey",
                        Self::MissingKeyPermissions => "PolymeshContracts.MissingKeyPermissions",
                        Self::InvalidChainVersion => "PolymeshContracts.InvalidChainVersion",
                        Self::NoUpgradesSupported => "PolymeshContracts.NoUpgradesSupported",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PolymeshContractsError {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: InvalidFuncId => { & ["Invalid `func_id` provided from contract." ,] } , Self :: InvalidRuntimeCall => { & ["Failed to decode a valid `RuntimeCall`." ,] } , Self :: ReadStorageFailed => { & ["`ReadStorage` failed to write value into the contract's buffer." ,] } , Self :: DataLeftAfterDecoding => { & ["Data left in input when decoding arguments of a call." ,] } , Self :: InLenTooLarge => { & ["Input data that a contract passed when using the ChainExtension was too large." ,] } , Self :: OutLenTooLarge => { & ["Output data returned from the ChainExtension was too large." ,] } , Self :: InstantiatorWithNoIdentity => { & ["A contract was attempted to be instantiated," , "but no identity was given to associate the new contract's key with." ,] } , Self :: RuntimeCallDenied => { & ["Extrinsic is not allowed to be called by contracts." ,] } , Self :: CallerNotAPrimaryKey => { & ["The caller is not a primary key." ,] } , Self :: MissingKeyPermissions => { & ["Secondary key permissions are missing." ,] } , Self :: InvalidChainVersion => { & ["Only future chain versions are allowed." ,] } , Self :: NoUpgradesSupported => { & ["There are no api upgrades supported for the contract." ,] } , _ => & [""] , }
                }
            }
            impl From<PolymeshContractsError> for &'static str {
                fn from(v: PolymeshContractsError) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PolymeshContractsError> for &'static str {
                fn from(v: &PolymeshContractsError) -> Self {
                    v.as_static_str()
                }
            }
            #[doc = "The `Event` enum of this pallet"]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PolymeshContractsEvent {
                #[doc = "Emitted when a contract starts supporting a new API upgrade."]
                #[doc = "Contains the [`Api`], [`ChainVersion`], and the bytes for the code hash."]
                #[codec(index = 0u8)]
                ApiHashUpdated(
                    polymesh_contracts::Api,
                    polymesh_contracts::ChainVersion,
                    primitive_types::H256,
                ),
                #[doc = "Emitted when a contract calls into the runtime."]
                #[doc = "Contains the account id set by the contract owner and the [`ExtrinsicId`]."]
                #[codec(index = 1u8)]
                SCRuntimeCall(
                    ::polymesh_api_client::AccountId,
                    polymesh_contracts::chain_extension::ExtrinsicId,
                ),
            }
            impl PolymeshContractsEvent {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::ApiHashUpdated(_, _, _) => "PolymeshContracts.ApiHashUpdated",
                        Self::SCRuntimeCall(_, _) => "PolymeshContracts.SCRuntimeCall",
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PolymeshContractsEvent {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    # [allow (unreachable_patterns)] match self { Self :: ApiHashUpdated (_ , _ , _) => { & ["Emitted when a contract starts supporting a new API upgrade." , "Contains the [`Api`], [`ChainVersion`], and the bytes for the code hash." ,] } , Self :: SCRuntimeCall (_ , _) => { & ["Emitted when a contract calls into the runtime." , "Contains the account id set by the contract owner and the [`ExtrinsicId`]." ,] } , _ => & [""] , }
                }
            }
            impl From<PolymeshContractsEvent> for &'static str {
                fn from(v: PolymeshContractsEvent) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PolymeshContractsEvent> for &'static str {
                fn from(v: &PolymeshContractsEvent) -> Self {
                    v.as_static_str()
                }
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Version(pub u8);
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Api {
            pub desc: [u8; 4usize],
            pub major: u32,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ApiCodeHash {
            pub hash: primitive_types::H256,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ChainVersion {
            pub spec_version: u32,
            pub tx_version: u32,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct NextUpgrade {
            pub chain_version: polymesh_contracts::ChainVersion,
            pub api_hash: polymesh_contracts::ApiCodeHash,
        }
    }
    pub mod polymesh_primitives {
        use super::*;
        pub mod agent {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AGId(pub u32);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AgentGroup {
                #[codec(index = 0u8)]
                Full,
                #[codec(index = 1u8)]
                Custom(polymesh_primitives::agent::AGId),
                #[codec(index = 2u8)]
                ExceptMeta,
                #[codec(index = 3u8)]
                PolymeshV1CAA,
                #[codec(index = 4u8)]
                PolymeshV1PIA,
            }
        }
        pub mod asset {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetId(pub [u8; 16usize]);
            #[derive(Clone, Debug, PartialEq, Eq, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetName(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, Copy)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AssetType {
                #[codec(index = 0u8)]
                EquityCommon,
                #[codec(index = 1u8)]
                EquityPreferred,
                #[codec(index = 2u8)]
                Commodity,
                #[codec(index = 3u8)]
                FixedIncome,
                #[codec(index = 4u8)]
                REIT,
                #[codec(index = 5u8)]
                Fund,
                #[codec(index = 6u8)]
                RevenueShareAgreement,
                #[codec(index = 7u8)]
                StructuredProduct,
                #[codec(index = 8u8)]
                Derivative,
                #[codec(index = 9u8)]
                Custom(polymesh_primitives::asset::CustomAssetTypeId),
                #[codec(index = 10u8)]
                StableCoin,
                #[codec(index = 11u8)]
                NonFungible(polymesh_primitives::asset::NonFungibleType),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct CheckpointId(pub u64);
            #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct CustomAssetTypeId(pub u32);
            #[derive(Clone, Debug, PartialEq, Eq, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct FundingRoundName(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, Copy)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum NonFungibleType {
                #[codec(index = 0u8)]
                Derivative,
                #[codec(index = 1u8)]
                FixedIncome,
                #[codec(index = 2u8)]
                Invoice,
                #[codec(index = 3u8)]
                Custom(polymesh_primitives::asset::CustomAssetTypeId),
            }
        }
        pub mod asset_identifier {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, Copy)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AssetIdentifier {
                #[codec(index = 0u8)]
                CUSIP([u8; 9usize]),
                #[codec(index = 1u8)]
                CINS([u8; 9usize]),
                #[codec(index = 2u8)]
                ISIN([u8; 12usize]),
                #[codec(index = 3u8)]
                LEI([u8; 20usize]),
                #[codec(index = 4u8)]
                FIGI([u8; 12usize]),
            }
        }
        pub mod asset_metadata {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetMetadataDescription(pub ::alloc::vec::Vec<u8>);
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetMetadataGlobalKey(pub u64);
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AssetMetadataKey {
                #[codec(index = 0u8)]
                Global(polymesh_primitives::asset_metadata::AssetMetadataGlobalKey),
                #[codec(index = 1u8)]
                Local(polymesh_primitives::asset_metadata::AssetMetadataLocalKey),
            }
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetMetadataLocalKey(pub u64);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AssetMetadataLockStatus<Moment> {
                #[codec(index = 0u8)]
                Unlocked,
                #[codec(index = 1u8)]
                Locked,
                #[codec(index = 2u8)]
                LockedUntil(Moment),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetMetadataName(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetMetadataSpec {
                pub url: Option<polymesh_primitives::Url>,
                pub description:
                    Option<polymesh_primitives::asset_metadata::AssetMetadataDescription>,
                pub type_def: Option<::alloc::vec::Vec<u8>>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetMetadataValue(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetMetadataValueDetail<Moment> {
                pub expire: Option<Moment>,
                pub lock_status:
                    polymesh_primitives::asset_metadata::AssetMetadataLockStatus<Moment>,
            }
        }
        pub mod authorization {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Authorization<AccountId, Moment> {
                pub authorization_data:
                    polymesh_primitives::authorization::AuthorizationData<AccountId>,
                pub authorized_by: ::polymesh_api_client::IdentityId,
                pub expiry: Option<Moment>,
                pub auth_id: Moment,
                pub count: u32,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AuthorizationData<AccountId> {
                #[codec(index = 0u8)]
                AttestPrimaryKeyRotation(::polymesh_api_client::IdentityId),
                #[codec(index = 1u8)]
                RotatePrimaryKey,
                #[codec(index = 2u8)]
                TransferTicker(polymesh_primitives::ticker::Ticker),
                #[codec(index = 3u8)]
                AddMultiSigSigner(AccountId),
                #[codec(index = 4u8)]
                TransferAssetOwnership(::polymesh_api_client::AssetId),
                #[codec(index = 5u8)]
                JoinIdentity(polymesh_primitives::secondary_key::Permissions),
                #[codec(index = 6u8)]
                PortfolioCustody(polymesh_primitives::identity_id::PortfolioId),
                #[codec(index = 7u8)]
                BecomeAgent(
                    ::polymesh_api_client::AssetId,
                    polymesh_primitives::agent::AgentGroup,
                ),
                #[codec(index = 8u8)]
                AddRelayerPayingKey(AccountId, AccountId, u128),
                #[codec(index = 9u8)]
                RotatePrimaryKeyToSecondary(polymesh_primitives::secondary_key::Permissions),
            }
        }
        pub mod cdd_id {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct CddId(pub [u8; 32usize]);
        }
        pub mod checkpoint {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct NextCheckpoints {
                pub next_at: u64,
                pub total_pending: u64,
                pub schedules: ::alloc::collections::BTreeMap<
                    polymesh_primitives::checkpoint::ScheduleId,
                    u64,
                >,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ScheduleCheckpoints {
                pub pending: ::alloc::collections::BTreeSet<u64>,
            }
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ScheduleId(pub u64);
        }
        pub mod compliance_manager {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetCompliance {
                pub paused: bool,
                pub requirements: ::alloc::vec::Vec<
                    polymesh_primitives::compliance_manager::ComplianceRequirement,
                >,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ComplianceRequirement {
                pub sender_conditions: ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
                pub receiver_conditions:
                    ::alloc::vec::Vec<polymesh_primitives::condition::Condition>,
                pub id: u32,
            }
        }
        pub mod condition {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Condition {
                pub condition_type: polymesh_primitives::condition::ConditionType,
                pub issuers: ::alloc::vec::Vec<polymesh_primitives::condition::TrustedIssuer>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ConditionType {
                #[codec(index = 0u8)]
                IsPresent(polymesh_primitives::identity_claim::Claim),
                #[codec(index = 1u8)]
                IsAbsent(polymesh_primitives::identity_claim::Claim),
                #[codec(index = 2u8)]
                IsAnyOf(::alloc::vec::Vec<polymesh_primitives::identity_claim::Claim>),
                #[codec(index = 3u8)]
                IsNoneOf(::alloc::vec::Vec<polymesh_primitives::identity_claim::Claim>),
                #[codec(index = 4u8)]
                IsIdentity(polymesh_primitives::condition::TargetIdentity),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum TargetIdentity {
                #[codec(index = 0u8)]
                ExternalAgent,
                #[codec(index = 1u8)]
                Specific(::polymesh_api_client::IdentityId),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum TrustedFor {
                #[codec(index = 0u8)]
                Any,
                #[codec(index = 1u8)]
                Specific(::alloc::vec::Vec<polymesh_primitives::identity_claim::ClaimType>),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct TrustedIssuer {
                pub issuer: ::polymesh_api_client::IdentityId,
                pub trusted_for: polymesh_primitives::condition::TrustedFor,
            }
        }
        pub mod document {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Document {
                pub uri: polymesh_primitives::document::DocumentUri,
                pub content_hash: polymesh_primitives::document_hash::DocumentHash,
                pub name: polymesh_primitives::document::DocumentName,
                pub doc_type: Option<polymesh_primitives::document::DocumentType>,
                pub filing_date: Option<u64>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct DocumentId(pub u32);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct DocumentName(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct DocumentType(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct DocumentUri(pub ::alloc::vec::Vec<u8>);
        }
        pub mod document_hash {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum DocumentHash {
                #[codec(index = 0u8)]
                None,
                #[codec(index = 1u8)]
                H512(
                    #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                    [u8; 64usize],
                ),
                #[codec(index = 2u8)]
                H384(
                    #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                    [u8; 48usize],
                ),
                #[codec(index = 3u8)]
                H320(
                    #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                    [u8; 40usize],
                ),
                #[codec(index = 4u8)]
                H256([u8; 32usize]),
                #[codec(index = 5u8)]
                H224([u8; 28usize]),
                #[codec(index = 6u8)]
                H192([u8; 24usize]),
                #[codec(index = 7u8)]
                H160([u8; 20usize]),
                #[codec(index = 8u8)]
                H128([u8; 16usize]),
            }
        }
        pub mod event_only {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct EventOnly<T>(pub T);
        }
        pub mod identity {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct CreateChildIdentityWithAuth<AccountId> {
                pub key: AccountId,
                pub auth_signature: primitive_types::H512,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct DidRecord<AccountId> {
                pub primary_key: Option<AccountId>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct SecondaryKeyWithAuth<AccountId> {
                pub secondary_key: polymesh_primitives::secondary_key::SecondaryKey<AccountId>,
                pub auth_signature: primitive_types::H512,
            }
        }
        pub mod identity_claim {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum Claim {
                #[codec(index = 0u8)]
                Accredited(polymesh_primitives::identity_claim::Scope),
                #[codec(index = 1u8)]
                Affiliate(polymesh_primitives::identity_claim::Scope),
                #[codec(index = 2u8)]
                BuyLockup(polymesh_primitives::identity_claim::Scope),
                #[codec(index = 3u8)]
                SellLockup(polymesh_primitives::identity_claim::Scope),
                #[codec(index = 4u8)]
                CustomerDueDiligence(polymesh_primitives::cdd_id::CddId),
                #[codec(index = 5u8)]
                KnowYourCustomer(polymesh_primitives::identity_claim::Scope),
                #[codec(index = 6u8)]
                Jurisdiction(
                    polymesh_primitives::jurisdiction::CountryCode,
                    polymesh_primitives::identity_claim::Scope,
                ),
                #[codec(index = 7u8)]
                Exempted(polymesh_primitives::identity_claim::Scope),
                #[codec(index = 8u8)]
                Blocked(polymesh_primitives::identity_claim::Scope),
                #[codec(index = 9u8)]
                Custom(
                    polymesh_primitives::identity_claim::CustomClaimTypeId,
                    Option<polymesh_primitives::identity_claim::Scope>,
                ),
            }
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ClaimType {
                #[codec(index = 0u8)]
                Accredited,
                #[codec(index = 1u8)]
                Affiliate,
                #[codec(index = 2u8)]
                BuyLockup,
                #[codec(index = 3u8)]
                SellLockup,
                #[codec(index = 4u8)]
                CustomerDueDiligence,
                #[codec(index = 5u8)]
                KnowYourCustomer,
                #[codec(index = 6u8)]
                Jurisdiction,
                #[codec(index = 7u8)]
                Exempted,
                #[codec(index = 8u8)]
                Blocked,
                #[codec(index = 9u8)]
                Custom(polymesh_primitives::identity_claim::CustomClaimTypeId),
            }
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct CustomClaimTypeId(pub u32);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct IdentityClaim {
                pub claim_issuer: ::polymesh_api_client::IdentityId,
                pub issuance_date: u64,
                pub last_update_date: u64,
                pub expiry: Option<u64>,
                pub claim: polymesh_primitives::identity_claim::Claim,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum Scope {
                #[codec(index = 0u8)]
                Identity(::polymesh_api_client::IdentityId),
                #[codec(index = 1u8)]
                Asset(::polymesh_api_client::AssetId),
                #[codec(index = 2u8)]
                Custom(::alloc::vec::Vec<u8>),
            }
        }
        pub mod identity_id {
            use super::*;
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct IdentityId(pub [u8; 32usize]);
            #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PortfolioId {
                pub did: ::polymesh_api_client::IdentityId,
                pub kind: polymesh_primitives::identity_id::PortfolioKind,
            }
            #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PortfolioKind {
                #[codec(index = 0u8)]
                Default,
                #[codec(index = 1u8)]
                User(polymesh_primitives::identity_id::PortfolioNumber),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PortfolioName(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Copy, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PortfolioNumber(pub u64);
        }
        pub mod jurisdiction {
            use super::*;
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum CountryCode {
                #[codec(index = 0u8)]
                AF,
                #[codec(index = 1u8)]
                AX,
                #[codec(index = 2u8)]
                AL,
                #[codec(index = 3u8)]
                DZ,
                #[codec(index = 4u8)]
                AS,
                #[codec(index = 5u8)]
                AD,
                #[codec(index = 6u8)]
                AO,
                #[codec(index = 7u8)]
                AI,
                #[codec(index = 8u8)]
                AQ,
                #[codec(index = 9u8)]
                AG,
                #[codec(index = 10u8)]
                AR,
                #[codec(index = 11u8)]
                AM,
                #[codec(index = 12u8)]
                AW,
                #[codec(index = 13u8)]
                AU,
                #[codec(index = 14u8)]
                AT,
                #[codec(index = 15u8)]
                AZ,
                #[codec(index = 16u8)]
                BS,
                #[codec(index = 17u8)]
                BH,
                #[codec(index = 18u8)]
                BD,
                #[codec(index = 19u8)]
                BB,
                #[codec(index = 20u8)]
                BY,
                #[codec(index = 21u8)]
                BE,
                #[codec(index = 22u8)]
                BZ,
                #[codec(index = 23u8)]
                BJ,
                #[codec(index = 24u8)]
                BM,
                #[codec(index = 25u8)]
                BT,
                #[codec(index = 26u8)]
                BO,
                #[codec(index = 27u8)]
                BA,
                #[codec(index = 28u8)]
                BW,
                #[codec(index = 29u8)]
                BV,
                #[codec(index = 30u8)]
                BR,
                #[codec(index = 31u8)]
                VG,
                #[codec(index = 32u8)]
                IO,
                #[codec(index = 33u8)]
                BN,
                #[codec(index = 34u8)]
                BG,
                #[codec(index = 35u8)]
                BF,
                #[codec(index = 36u8)]
                BI,
                #[codec(index = 37u8)]
                KH,
                #[codec(index = 38u8)]
                CM,
                #[codec(index = 39u8)]
                CA,
                #[codec(index = 40u8)]
                CV,
                #[codec(index = 41u8)]
                KY,
                #[codec(index = 42u8)]
                CF,
                #[codec(index = 43u8)]
                TD,
                #[codec(index = 44u8)]
                CL,
                #[codec(index = 45u8)]
                CN,
                #[codec(index = 46u8)]
                HK,
                #[codec(index = 47u8)]
                MO,
                #[codec(index = 48u8)]
                CX,
                #[codec(index = 49u8)]
                CC,
                #[codec(index = 50u8)]
                CO,
                #[codec(index = 51u8)]
                KM,
                #[codec(index = 52u8)]
                CG,
                #[codec(index = 53u8)]
                CD,
                #[codec(index = 54u8)]
                CK,
                #[codec(index = 55u8)]
                CR,
                #[codec(index = 56u8)]
                CI,
                #[codec(index = 57u8)]
                HR,
                #[codec(index = 58u8)]
                CU,
                #[codec(index = 59u8)]
                CY,
                #[codec(index = 60u8)]
                CZ,
                #[codec(index = 61u8)]
                DK,
                #[codec(index = 62u8)]
                DJ,
                #[codec(index = 63u8)]
                DM,
                #[codec(index = 64u8)]
                DO,
                #[codec(index = 65u8)]
                EC,
                #[codec(index = 66u8)]
                EG,
                #[codec(index = 67u8)]
                SV,
                #[codec(index = 68u8)]
                GQ,
                #[codec(index = 69u8)]
                ER,
                #[codec(index = 70u8)]
                EE,
                #[codec(index = 71u8)]
                ET,
                #[codec(index = 72u8)]
                FK,
                #[codec(index = 73u8)]
                FO,
                #[codec(index = 74u8)]
                FJ,
                #[codec(index = 75u8)]
                FI,
                #[codec(index = 76u8)]
                FR,
                #[codec(index = 77u8)]
                GF,
                #[codec(index = 78u8)]
                PF,
                #[codec(index = 79u8)]
                TF,
                #[codec(index = 80u8)]
                GA,
                #[codec(index = 81u8)]
                GM,
                #[codec(index = 82u8)]
                GE,
                #[codec(index = 83u8)]
                DE,
                #[codec(index = 84u8)]
                GH,
                #[codec(index = 85u8)]
                GI,
                #[codec(index = 86u8)]
                GR,
                #[codec(index = 87u8)]
                GL,
                #[codec(index = 88u8)]
                GD,
                #[codec(index = 89u8)]
                GP,
                #[codec(index = 90u8)]
                GU,
                #[codec(index = 91u8)]
                GT,
                #[codec(index = 92u8)]
                GG,
                #[codec(index = 93u8)]
                GN,
                #[codec(index = 94u8)]
                GW,
                #[codec(index = 95u8)]
                GY,
                #[codec(index = 96u8)]
                HT,
                #[codec(index = 97u8)]
                HM,
                #[codec(index = 98u8)]
                VA,
                #[codec(index = 99u8)]
                HN,
                #[codec(index = 100u8)]
                HU,
                #[codec(index = 101u8)]
                IS,
                #[codec(index = 102u8)]
                IN,
                #[codec(index = 103u8)]
                ID,
                #[codec(index = 104u8)]
                IR,
                #[codec(index = 105u8)]
                IQ,
                #[codec(index = 106u8)]
                IE,
                #[codec(index = 107u8)]
                IM,
                #[codec(index = 108u8)]
                IL,
                #[codec(index = 109u8)]
                IT,
                #[codec(index = 110u8)]
                JM,
                #[codec(index = 111u8)]
                JP,
                #[codec(index = 112u8)]
                JE,
                #[codec(index = 113u8)]
                JO,
                #[codec(index = 114u8)]
                KZ,
                #[codec(index = 115u8)]
                KE,
                #[codec(index = 116u8)]
                KI,
                #[codec(index = 117u8)]
                KP,
                #[codec(index = 118u8)]
                KR,
                #[codec(index = 119u8)]
                KW,
                #[codec(index = 120u8)]
                KG,
                #[codec(index = 121u8)]
                LA,
                #[codec(index = 122u8)]
                LV,
                #[codec(index = 123u8)]
                LB,
                #[codec(index = 124u8)]
                LS,
                #[codec(index = 125u8)]
                LR,
                #[codec(index = 126u8)]
                LY,
                #[codec(index = 127u8)]
                LI,
                #[codec(index = 128u8)]
                LT,
                #[codec(index = 129u8)]
                LU,
                #[codec(index = 130u8)]
                MK,
                #[codec(index = 131u8)]
                MG,
                #[codec(index = 132u8)]
                MW,
                #[codec(index = 133u8)]
                MY,
                #[codec(index = 134u8)]
                MV,
                #[codec(index = 135u8)]
                ML,
                #[codec(index = 136u8)]
                MT,
                #[codec(index = 137u8)]
                MH,
                #[codec(index = 138u8)]
                MQ,
                #[codec(index = 139u8)]
                MR,
                #[codec(index = 140u8)]
                MU,
                #[codec(index = 141u8)]
                YT,
                #[codec(index = 142u8)]
                MX,
                #[codec(index = 143u8)]
                FM,
                #[codec(index = 144u8)]
                MD,
                #[codec(index = 145u8)]
                MC,
                #[codec(index = 146u8)]
                MN,
                #[codec(index = 147u8)]
                ME,
                #[codec(index = 148u8)]
                MS,
                #[codec(index = 149u8)]
                MA,
                #[codec(index = 150u8)]
                MZ,
                #[codec(index = 151u8)]
                MM,
                #[codec(index = 152u8)]
                NA,
                #[codec(index = 153u8)]
                NR,
                #[codec(index = 154u8)]
                NP,
                #[codec(index = 155u8)]
                NL,
                #[codec(index = 156u8)]
                AN,
                #[codec(index = 157u8)]
                NC,
                #[codec(index = 158u8)]
                NZ,
                #[codec(index = 159u8)]
                NI,
                #[codec(index = 160u8)]
                NE,
                #[codec(index = 161u8)]
                NG,
                #[codec(index = 162u8)]
                NU,
                #[codec(index = 163u8)]
                NF,
                #[codec(index = 164u8)]
                MP,
                #[codec(index = 165u8)]
                NO,
                #[codec(index = 166u8)]
                OM,
                #[codec(index = 167u8)]
                PK,
                #[codec(index = 168u8)]
                PW,
                #[codec(index = 169u8)]
                PS,
                #[codec(index = 170u8)]
                PA,
                #[codec(index = 171u8)]
                PG,
                #[codec(index = 172u8)]
                PY,
                #[codec(index = 173u8)]
                PE,
                #[codec(index = 174u8)]
                PH,
                #[codec(index = 175u8)]
                PN,
                #[codec(index = 176u8)]
                PL,
                #[codec(index = 177u8)]
                PT,
                #[codec(index = 178u8)]
                PR,
                #[codec(index = 179u8)]
                QA,
                #[codec(index = 180u8)]
                RE,
                #[codec(index = 181u8)]
                RO,
                #[codec(index = 182u8)]
                RU,
                #[codec(index = 183u8)]
                RW,
                #[codec(index = 184u8)]
                BL,
                #[codec(index = 185u8)]
                SH,
                #[codec(index = 186u8)]
                KN,
                #[codec(index = 187u8)]
                LC,
                #[codec(index = 188u8)]
                MF,
                #[codec(index = 189u8)]
                PM,
                #[codec(index = 190u8)]
                VC,
                #[codec(index = 191u8)]
                WS,
                #[codec(index = 192u8)]
                SM,
                #[codec(index = 193u8)]
                ST,
                #[codec(index = 194u8)]
                SA,
                #[codec(index = 195u8)]
                SN,
                #[codec(index = 196u8)]
                RS,
                #[codec(index = 197u8)]
                SC,
                #[codec(index = 198u8)]
                SL,
                #[codec(index = 199u8)]
                SG,
                #[codec(index = 200u8)]
                SK,
                #[codec(index = 201u8)]
                SI,
                #[codec(index = 202u8)]
                SB,
                #[codec(index = 203u8)]
                SO,
                #[codec(index = 204u8)]
                ZA,
                #[codec(index = 205u8)]
                GS,
                #[codec(index = 206u8)]
                SS,
                #[codec(index = 207u8)]
                ES,
                #[codec(index = 208u8)]
                LK,
                #[codec(index = 209u8)]
                SD,
                #[codec(index = 210u8)]
                SR,
                #[codec(index = 211u8)]
                SJ,
                #[codec(index = 212u8)]
                SZ,
                #[codec(index = 213u8)]
                SE,
                #[codec(index = 214u8)]
                CH,
                #[codec(index = 215u8)]
                SY,
                #[codec(index = 216u8)]
                TW,
                #[codec(index = 217u8)]
                TJ,
                #[codec(index = 218u8)]
                TZ,
                #[codec(index = 219u8)]
                TH,
                #[codec(index = 220u8)]
                TL,
                #[codec(index = 221u8)]
                TG,
                #[codec(index = 222u8)]
                TK,
                #[codec(index = 223u8)]
                TO,
                #[codec(index = 224u8)]
                TT,
                #[codec(index = 225u8)]
                TN,
                #[codec(index = 226u8)]
                TR,
                #[codec(index = 227u8)]
                TM,
                #[codec(index = 228u8)]
                TC,
                #[codec(index = 229u8)]
                TV,
                #[codec(index = 230u8)]
                UG,
                #[codec(index = 231u8)]
                UA,
                #[codec(index = 232u8)]
                AE,
                #[codec(index = 233u8)]
                GB,
                #[codec(index = 234u8)]
                US,
                #[codec(index = 235u8)]
                UM,
                #[codec(index = 236u8)]
                UY,
                #[codec(index = 237u8)]
                UZ,
                #[codec(index = 238u8)]
                VU,
                #[codec(index = 239u8)]
                VE,
                #[codec(index = 240u8)]
                VN,
                #[codec(index = 241u8)]
                VI,
                #[codec(index = 242u8)]
                WF,
                #[codec(index = 243u8)]
                EH,
                #[codec(index = 244u8)]
                YE,
                #[codec(index = 245u8)]
                ZM,
                #[codec(index = 246u8)]
                ZW,
                #[codec(index = 247u8)]
                BQ,
                #[codec(index = 248u8)]
                CW,
                #[codec(index = 249u8)]
                SX,
            }
        }
        pub mod multisig {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ProposalState<Moment> {
                #[codec(index = 0u8)]
                Active { until: Option<Moment> },
                #[codec(index = 1u8)]
                ExecutionSuccessful,
                #[codec(index = 2u8)]
                ExecutionFailed,
                #[codec(index = 3u8)]
                Rejected,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ProposalVoteCount {
                pub approvals: u64,
                pub rejections: u64,
            }
        }
        pub mod nft {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct NFTCollection {
                pub id: polymesh_primitives::nft::NFTCollectionId,
                pub asset_id: ::polymesh_api_client::AssetId,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct NFTCollectionId(pub u64);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct NFTCollectionKeys(
                pub ::alloc::vec::Vec<polymesh_primitives::asset_metadata::AssetMetadataKey>,
            );
            #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct NFTId(pub u64);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct NFTMetadataAttribute {
                pub key: polymesh_primitives::asset_metadata::AssetMetadataKey,
                pub value: polymesh_primitives::asset_metadata::AssetMetadataValue,
            }
            #[derive(Clone, Debug, PartialEq, Eq)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct NFTs {
                pub asset_id: ::polymesh_api_client::AssetId,
                pub ids: ::alloc::vec::Vec<polymesh_primitives::nft::NFTId>,
            }
        }
        pub mod portfolio {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Fund {
                pub description: polymesh_primitives::portfolio::FundDescription,
                pub memo: Option<polymesh_primitives::Memo>,
            }
            #[derive(Clone, Debug, PartialEq, Eq)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum FundDescription {
                #[codec(index = 0u8)]
                Fungible {
                    asset_id: ::polymesh_api_client::AssetId,
                    amount: u128,
                },
                #[codec(index = 1u8)]
                NonFungible(polymesh_primitives::nft::NFTs),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PortfolioUpdateReason {
                #[codec(index = 0u8)]
                Issued {
                    funding_round_name: Option<polymesh_primitives::asset::FundingRoundName>,
                },
                #[codec(index = 1u8)]
                Redeemed,
                #[codec(index = 2u8)]
                Transferred {
                    instruction_id: Option<polymesh_primitives::settlement::InstructionId>,
                    instruction_memo: Option<polymesh_primitives::Memo>,
                },
                #[codec(index = 3u8)]
                ControllerTransfer,
            }
        }
        pub mod secondary_key {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum ExtrinsicPermissions {
                #[codec(index = 0u8)]
                Whole,
                #[codec(index = 1u8)]
                These(
                    ::alloc::collections::BTreeMap<
                        polymesh_primitives::PalletName,
                        polymesh_primitives::secondary_key::PalletPermissions,
                    >,
                ),
                #[codec(index = 2u8)]
                Except(
                    ::alloc::collections::BTreeMap<
                        polymesh_primitives::PalletName,
                        polymesh_primitives::secondary_key::PalletPermissions,
                    >,
                ),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum KeyRecord<AccountId> {
                #[codec(index = 0u8)]
                PrimaryKey(::polymesh_api_client::IdentityId),
                #[codec(index = 1u8)]
                SecondaryKey(::polymesh_api_client::IdentityId),
                #[codec(index = 2u8)]
                MultiSigSignerKey(AccountId),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PalletPermissions {
                pub extrinsics: polymesh_primitives::subset::SubsetRestriction<
                    polymesh_primitives::ExtrinsicName,
                >,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Permissions {
                pub asset:
                    polymesh_primitives::subset::SubsetRestriction<::polymesh_api_client::AssetId>,
                pub extrinsic: polymesh_primitives::secondary_key::ExtrinsicPermissions,
                pub portfolio: polymesh_primitives::subset::SubsetRestriction<
                    polymesh_primitives::identity_id::PortfolioId,
                >,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct SecondaryKey<AccountId> {
                pub key: AccountId,
                pub permissions: polymesh_primitives::secondary_key::Permissions,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum Signatory<AccountId> {
                #[codec(index = 0u8)]
                Identity(::polymesh_api_client::IdentityId),
                #[codec(index = 1u8)]
                Account(AccountId),
            }
        }
        pub mod settlement {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AffirmationCount {
                pub sender_asset_count: polymesh_primitives::settlement::AssetCount,
                pub receiver_asset_count: polymesh_primitives::settlement::AssetCount,
                pub offchain_count: u32,
            }
            #[derive(Clone, Debug, PartialEq, Eq, Copy)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum AffirmationStatus {
                #[codec(index = 0u8)]
                Unknown,
                #[codec(index = 1u8)]
                Pending,
                #[codec(index = 2u8)]
                Affirmed,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetCount {
                pub fungible: u32,
                pub non_fungible: u32,
                pub off_chain: u32,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Instruction<Moment, BlockNumber> {
                pub instruction_id: polymesh_primitives::settlement::InstructionId,
                pub venue_id: Option<polymesh_primitives::settlement::VenueId>,
                pub settlement_type: polymesh_primitives::settlement::SettlementType<BlockNumber>,
                pub created_at: Option<Moment>,
                pub trade_date: Option<Moment>,
                pub value_date: Option<Moment>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct InstructionId(pub u64);
            #[derive(Clone, Debug, PartialEq, Eq, Copy)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum InstructionStatus<BlockNumber> {
                #[codec(index = 0u8)]
                Unknown,
                #[codec(index = 1u8)]
                Pending,
                #[codec(index = 2u8)]
                Failed,
                #[codec(index = 3u8)]
                Success(BlockNumber),
                #[codec(index = 4u8)]
                Rejected(BlockNumber),
                #[codec(index = 5u8)]
                LockedForExecution,
            }
            #[derive(Clone, Debug, PartialEq, Eq)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum Leg {
                #[codec(index = 0u8)]
                Fungible {
                    sender: polymesh_primitives::identity_id::PortfolioId,
                    receiver: polymesh_primitives::identity_id::PortfolioId,
                    asset_id: ::polymesh_api_client::AssetId,
                    amount: u128,
                },
                #[codec(index = 1u8)]
                NonFungible {
                    sender: polymesh_primitives::identity_id::PortfolioId,
                    receiver: polymesh_primitives::identity_id::PortfolioId,
                    nfts: polymesh_primitives::nft::NFTs,
                },
                #[codec(index = 2u8)]
                OffChain {
                    sender_identity: ::polymesh_api_client::IdentityId,
                    receiver_identity: ::polymesh_api_client::IdentityId,
                    ticker: polymesh_primitives::ticker::Ticker,
                    amount: u128,
                },
            }
            #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct LegId(pub u64);
            #[derive(Clone, Debug, PartialEq, Eq, Copy)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum LegStatus<AccountId> {
                #[codec(index = 0u8)]
                PendingTokenLock,
                #[codec(index = 1u8)]
                ExecutionPending,
                #[codec(index = 2u8)]
                ExecutionToBeSkipped(AccountId, u64),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum MediatorAffirmationStatus<T> {
                #[codec(index = 0u8)]
                Unknown,
                #[codec(index = 1u8)]
                Pending,
                #[codec(index = 2u8)]
                Affirmed { expiry: Option<T> },
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ReceiptDetails<AccountId, OffChainSignature> {
                pub uid: u64,
                pub instruction_id: polymesh_primitives::settlement::InstructionId,
                pub leg_id: polymesh_primitives::settlement::LegId,
                pub signer: AccountId,
                pub signature: OffChainSignature,
                pub metadata: Option<polymesh_primitives::settlement::ReceiptMetadata>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct ReceiptMetadata(pub [u8; 32usize]);
            #[derive(Clone, Debug, PartialEq, Eq, Copy)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SettlementType<BlockNumber> {
                #[codec(index = 0u8)]
                SettleOnAffirmation,
                #[codec(index = 1u8)]
                SettleOnBlock(BlockNumber),
                #[codec(index = 2u8)]
                SettleManual(BlockNumber),
                #[codec(index = 3u8)]
                SettleAfterLock,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Venue {
                pub creator: ::polymesh_api_client::IdentityId,
                pub venue_type: polymesh_primitives::settlement::VenueType,
            }
            #[derive(Clone, Debug, PartialEq, Eq, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct VenueDetails(pub ::alloc::vec::Vec<u8>);
            #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct VenueId(pub u64);
            #[derive(Clone, Debug, PartialEq, Eq, Copy)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum VenueType {
                #[codec(index = 0u8)]
                Other,
                #[codec(index = 1u8)]
                Distribution,
                #[codec(index = 2u8)]
                Sto,
                #[codec(index = 3u8)]
                Exchange,
            }
        }
        pub mod statistics {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Stat1stKey {
                pub asset_id: ::polymesh_api_client::AssetId,
                pub stat_type: polymesh_primitives::statistics::StatType,
            }
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum Stat2ndKey {
                #[codec(index = 0u8)]
                NoClaimStat,
                #[codec(index = 1u8)]
                Claim(polymesh_primitives::statistics::StatClaim),
            }
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum StatClaim {
                #[codec(index = 0u8)]
                Accredited(bool),
                #[codec(index = 1u8)]
                Affiliate(bool),
                #[codec(index = 2u8)]
                Jurisdiction(Option<polymesh_primitives::jurisdiction::CountryCode>),
            }
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum StatOpType {
                #[codec(index = 0u8)]
                Count,
                #[codec(index = 1u8)]
                Balance,
            }
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct StatType {
                pub operation_type: polymesh_primitives::statistics::StatOpType,
                pub claim_issuer: Option<(
                    polymesh_primitives::identity_claim::ClaimType,
                    ::polymesh_api_client::IdentityId,
                )>,
            }
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct StatUpdate {
                pub key2: polymesh_primitives::statistics::Stat2ndKey,
                pub value: Option<u128>,
            }
        }
        pub mod sto {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct FundraiserId(pub u64);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct FundraiserReceiptDetails<AccountId, OffChainSignature> {
                pub uid: u64,
                pub signer: AccountId,
                pub signature: OffChainSignature,
                pub metadata: Option<polymesh_primitives::settlement::ReceiptMetadata>,
            }
        }
        pub mod subset {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum SubsetRestriction<A: Ord> {
                #[codec(index = 0u8)]
                Whole,
                #[codec(index = 1u8)]
                These(::alloc::collections::BTreeSet<A>),
                #[codec(index = 2u8)]
                Except(::alloc::collections::BTreeSet<A>),
            }
        }
        pub mod ticker {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
            #[cfg_attr(
                all(feature = "ink", feature = "std"),
                derive(::ink::storage::traits::StorageLayout)
            )]
            #[derive(:: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Ticker(pub [u8; 12usize]);
        }
        pub mod traits {
            use super::*;
            pub mod group {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct InactiveMember<Moment> {
                    pub id: ::polymesh_api_client::IdentityId,
                    pub deactivated_at: Moment,
                    pub expiry: Option<Moment>,
                }
            }
        }
        pub mod transfer_compliance {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AssetTransferCompliance {
                pub paused: bool,
                pub requirements: ::alloc::collections::BTreeSet<
                    polymesh_primitives::transfer_compliance::TransferCondition,
                >,
            }
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum TransferCondition {
                #[codec(index = 0u8)]
                MaxInvestorCount(u64),
                #[codec(index = 1u8)]
                MaxInvestorOwnership(::polymesh_api_client::per_things::Permill),
                #[codec(index = 2u8)]
                ClaimCount(
                    polymesh_primitives::statistics::StatClaim,
                    ::polymesh_api_client::IdentityId,
                    u64,
                    Option<u64>,
                ),
                #[codec(index = 3u8)]
                ClaimOwnership(
                    polymesh_primitives::statistics::StatClaim,
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::per_things::Permill,
                    ::polymesh_api_client::per_things::Permill,
                ),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct TransferConditionExemptKey {
                pub asset_id: ::polymesh_api_client::AssetId,
                pub op: polymesh_primitives::statistics::StatOpType,
                pub claim_type: Option<polymesh_primitives::identity_claim::ClaimType>,
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Beneficiary<Balance> {
            pub id: ::polymesh_api_client::IdentityId,
            pub amount: Balance,
        }
        #[derive(
            Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
        )]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ExtrinsicName(pub ::alloc::string::String);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum MaybeBlock<BlockNumber> {
            #[codec(index = 0u8)]
            Some(BlockNumber),
            #[codec(index = 1u8)]
            None,
        }
        #[derive(Clone, Debug, PartialEq, Eq)]
        #[cfg_attr(
            all(feature = "ink", feature = "std"),
            derive(::ink::storage::traits::StorageLayout)
        )]
        #[derive(:: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Memo(pub [u8; 32usize]);
        #[derive(
            Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
        )]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct PalletName(pub ::alloc::string::String);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct PosRatio(pub u32, pub u32);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Url(pub ::alloc::vec::Vec<u8>);
    }
    pub mod polymesh_runtime_common {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct NposSolution16 {
            pub votes1: ::alloc::vec::Vec<(::codec::Compact<u32>, ::codec::Compact<u16>)>,
            pub votes2: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                (
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ),
                ::codec::Compact<u16>,
            )>,
            pub votes3: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 2usize],
                ::codec::Compact<u16>,
            )>,
            pub votes4: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 3usize],
                ::codec::Compact<u16>,
            )>,
            pub votes5: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 4usize],
                ::codec::Compact<u16>,
            )>,
            pub votes6: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 5usize],
                ::codec::Compact<u16>,
            )>,
            pub votes7: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 6usize],
                ::codec::Compact<u16>,
            )>,
            pub votes8: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 7usize],
                ::codec::Compact<u16>,
            )>,
            pub votes9: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 8usize],
                ::codec::Compact<u16>,
            )>,
            pub votes10: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 9usize],
                ::codec::Compact<u16>,
            )>,
            pub votes11: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 10usize],
                ::codec::Compact<u16>,
            )>,
            pub votes12: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 11usize],
                ::codec::Compact<u16>,
            )>,
            pub votes13: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 12usize],
                ::codec::Compact<u16>,
            )>,
            pub votes14: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 13usize],
                ::codec::Compact<u16>,
            )>,
            pub votes15: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 14usize],
                ::codec::Compact<u16>,
            )>,
            pub votes16: ::alloc::vec::Vec<(
                ::codec::Compact<u32>,
                [(
                    ::codec::Compact<u16>,
                    ::codec::Compact<::polymesh_api_client::per_things::PerU16>,
                ); 15usize],
                ::codec::Compact<u16>,
            )>,
        }
    }
    pub mod polymesh_transaction_payment {
        use super::*;
        pub mod pallet {
            use super::*;
            #[doc = "Contains a variant per dispatchable extrinsic that this pallet has."]
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PolymeshTransactionPaymentCall {
                #[codec(index = 0u8)]
                set_disable_fees { value: bool },
            }
            impl PolymeshTransactionPaymentCall {
                pub fn as_static_str(&self) -> &'static str {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::set_disable_fees { .. } => {
                            "PolymeshTransactionPayment.set_disable_fees"
                        }
                        _ => "Unknown",
                    }
                }
            }
            #[cfg(not(feature = "ink"))]
            impl ::polymesh_api_client::EnumInfo for PolymeshTransactionPaymentCall {
                fn as_name(&self) -> &'static str {
                    self.as_static_str()
                }
                fn as_docs(&self) -> &'static [&'static str] {
                    #[allow(unreachable_patterns)]
                    match self {
                        Self::set_disable_fees { .. } => &[""],
                        _ => &[""],
                    }
                }
            }
            impl From<PolymeshTransactionPaymentCall> for &'static str {
                fn from(v: PolymeshTransactionPaymentCall) -> Self {
                    v.as_static_str()
                }
            }
            impl From<&PolymeshTransactionPaymentCall> for &'static str {
                fn from(v: &PolymeshTransactionPaymentCall) -> Self {
                    v.as_static_str()
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ChargeTransactionPayment(#[codec(compact)] pub u128);
    }
    pub mod primitive_types {
        use super::*;
        #[derive(
            Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
        )]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct H256(pub [u8; 32usize]);
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct H512(
            #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
            pub  [u8; 64usize],
        );
    }
    pub mod runtime {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum OriginCaller {
            #[codec(index = 0u8)]
            system(frame_support::dispatch::RawOrigin<::polymesh_api_client::AccountId>),
            #[codec(index = 9u8)]
            PolymeshCommittee(
                pallet_committee::pallet::RawOrigin<::polymesh_api_client::AccountId>,
            ),
            #[codec(index = 11u8)]
            TechnicalCommittee(
                pallet_committee::pallet::RawOrigin<::polymesh_api_client::AccountId>,
            ),
            #[codec(index = 13u8)]
            UpgradeCommittee(pallet_committee::pallet::RawOrigin<::polymesh_api_client::AccountId>),
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Runtime();
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum RuntimeCall {
            #[codec(index = 0u8)]
            System(frame_system::pallet::SystemCall),
            #[codec(index = 1u8)]
            Babe(pallet_babe::pallet::BabeCall),
            #[codec(index = 2u8)]
            Timestamp(pallet_timestamp::pallet::TimestampCall),
            #[codec(index = 3u8)]
            Indices(pallet_indices::pallet::IndicesCall),
            #[codec(index = 5u8)]
            Balances(pallet_balances::pallet::BalancesCall),
            #[codec(index = 7u8)]
            Identity(pallet_identity::pallet::IdentityCall),
            #[codec(index = 8u8)]
            CddServiceProviders(pallet_group::pallet::UpgradeCommitteeMembershipCall),
            #[codec(index = 9u8)]
            PolymeshCommittee(pallet_committee::pallet::UpgradeCommitteeCall),
            #[codec(index = 10u8)]
            CommitteeMembership(pallet_group::pallet::UpgradeCommitteeMembershipCall),
            #[codec(index = 11u8)]
            TechnicalCommittee(pallet_committee::pallet::UpgradeCommitteeCall),
            #[codec(index = 12u8)]
            TechnicalCommitteeMembership(pallet_group::pallet::UpgradeCommitteeMembershipCall),
            #[codec(index = 13u8)]
            UpgradeCommittee(pallet_committee::pallet::UpgradeCommitteeCall),
            #[codec(index = 14u8)]
            UpgradeCommitteeMembership(pallet_group::pallet::UpgradeCommitteeMembershipCall),
            #[codec(index = 15u8)]
            MultiSig(pallet_multisig::pallet::MultiSigCall),
            #[codec(index = 16u8)]
            Validators(pallet_validators::pallet::ValidatorsCall),
            #[codec(index = 17u8)]
            Staking(pallet_staking::pallet::pallet::StakingCall),
            #[codec(index = 19u8)]
            Session(pallet_session::pallet::SessionCall),
            #[codec(index = 21u8)]
            Grandpa(pallet_grandpa::pallet::GrandpaCall),
            #[codec(index = 23u8)]
            ImOnline(pallet_im_online::pallet::ImOnlineCall),
            #[codec(index = 25u8)]
            Sudo(pallet_sudo::pallet::SudoCall),
            #[codec(index = 26u8)]
            Asset(pallet_asset::pallet::AssetCall),
            #[codec(index = 27u8)]
            CapitalDistribution(
                pallet_corporate_actions::distribution::pallet::CapitalDistributionCall,
            ),
            #[codec(index = 28u8)]
            Checkpoint(pallet_asset::checkpoint::pallet::CheckpointCall),
            #[codec(index = 29u8)]
            ComplianceManager(pallet_compliance_manager::pallet::ComplianceManagerCall),
            #[codec(index = 30u8)]
            CorporateAction(pallet_corporate_actions::pallet::CorporateActionCall),
            #[codec(index = 31u8)]
            CorporateBallot(pallet_corporate_actions::ballot::pallet::CorporateBallotCall),
            #[codec(index = 33u8)]
            Pips(pallet_pips::pallet::PipsCall),
            #[codec(index = 34u8)]
            Portfolio(pallet_portfolio::pallet::PortfolioCall),
            #[codec(index = 35u8)]
            ProtocolFee(pallet_protocol_fee::pallet::ProtocolFeeCall),
            #[codec(index = 36u8)]
            Scheduler(pallet_scheduler::pallet::SchedulerCall),
            #[codec(index = 37u8)]
            Settlement(pallet_settlement::pallet::SettlementCall),
            #[codec(index = 38u8)]
            Statistics(pallet_statistics::pallet::StatisticsCall),
            #[codec(index = 39u8)]
            Sto(pallet_sto::pallet::StoCall),
            #[codec(index = 40u8)]
            Treasury(pallet_treasury::pallet::TreasuryCall),
            #[codec(index = 41u8)]
            Utility(pallet_utility::pallet::UtilityCall),
            #[codec(index = 42u8)]
            Base(pallet_base::pallet::BaseCall),
            #[codec(index = 43u8)]
            ExternalAgents(pallet_external_agents::pallet::ExternalAgentsCall),
            #[codec(index = 44u8)]
            Relayer(pallet_relayer::pallet::RelayerCall),
            #[codec(index = 46u8)]
            Contracts(pallet_contracts::pallet::ContractsCall),
            #[codec(index = 47u8)]
            PolymeshContracts(polymesh_contracts::pallet::PolymeshContractsCall),
            #[codec(index = 48u8)]
            Preimage(pallet_preimage::pallet::PreimageCall),
            #[codec(index = 49u8)]
            Nft(pallet_nft::pallet::NftCall),
            #[codec(index = 50u8)]
            ElectionProviderMultiPhase(
                pallet_election_provider_multi_phase::pallet::ElectionProviderMultiPhaseCall,
            ),
            #[codec(index = 51u8)]
            PolymeshTransactionPayment(
                polymesh_transaction_payment::pallet::PolymeshTransactionPaymentCall,
            ),
            #[codec(index = 52u8)]
            Beefy(pallet_beefy::pallet::BeefyCall),
        }
        impl RuntimeCall {
            pub fn as_static_str(&self) -> &'static str {
                #[allow(unreachable_patterns)]
                match self {
                    Self::System(val) => val.as_static_str(),
                    Self::Babe(val) => val.as_static_str(),
                    Self::Timestamp(val) => val.as_static_str(),
                    Self::Indices(val) => val.as_static_str(),
                    Self::Balances(val) => val.as_static_str(),
                    Self::Identity(val) => val.as_static_str(),
                    Self::CddServiceProviders(val) => val.as_static_str(),
                    Self::PolymeshCommittee(val) => val.as_static_str(),
                    Self::CommitteeMembership(val) => val.as_static_str(),
                    Self::TechnicalCommittee(val) => val.as_static_str(),
                    Self::TechnicalCommitteeMembership(val) => val.as_static_str(),
                    Self::UpgradeCommittee(val) => val.as_static_str(),
                    Self::UpgradeCommitteeMembership(val) => val.as_static_str(),
                    Self::MultiSig(val) => val.as_static_str(),
                    Self::Validators(val) => val.as_static_str(),
                    Self::Staking(val) => val.as_static_str(),
                    Self::Session(val) => val.as_static_str(),
                    Self::Grandpa(val) => val.as_static_str(),
                    Self::ImOnline(val) => val.as_static_str(),
                    Self::Sudo(val) => val.as_static_str(),
                    Self::Asset(val) => val.as_static_str(),
                    Self::CapitalDistribution(val) => val.as_static_str(),
                    Self::Checkpoint(val) => val.as_static_str(),
                    Self::ComplianceManager(val) => val.as_static_str(),
                    Self::CorporateAction(val) => val.as_static_str(),
                    Self::CorporateBallot(val) => val.as_static_str(),
                    Self::Pips(val) => val.as_static_str(),
                    Self::Portfolio(val) => val.as_static_str(),
                    Self::ProtocolFee(val) => val.as_static_str(),
                    Self::Scheduler(val) => val.as_static_str(),
                    Self::Settlement(val) => val.as_static_str(),
                    Self::Statistics(val) => val.as_static_str(),
                    Self::Sto(val) => val.as_static_str(),
                    Self::Treasury(val) => val.as_static_str(),
                    Self::Utility(val) => val.as_static_str(),
                    Self::Base(val) => val.as_static_str(),
                    Self::ExternalAgents(val) => val.as_static_str(),
                    Self::Relayer(val) => val.as_static_str(),
                    Self::Contracts(val) => val.as_static_str(),
                    Self::PolymeshContracts(val) => val.as_static_str(),
                    Self::Preimage(val) => val.as_static_str(),
                    Self::Nft(val) => val.as_static_str(),
                    Self::ElectionProviderMultiPhase(val) => val.as_static_str(),
                    Self::PolymeshTransactionPayment(val) => val.as_static_str(),
                    Self::Beefy(val) => val.as_static_str(),
                    _ => "Unknown",
                }
            }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for RuntimeCall {
            fn as_name(&self) -> &'static str {
                self.as_static_str()
            }
            fn as_docs(&self) -> &'static [&'static str] {
                #[allow(unreachable_patterns)]
                match self {
                    Self::System(val) => val.as_docs(),
                    Self::Babe(val) => val.as_docs(),
                    Self::Timestamp(val) => val.as_docs(),
                    Self::Indices(val) => val.as_docs(),
                    Self::Balances(val) => val.as_docs(),
                    Self::Identity(val) => val.as_docs(),
                    Self::CddServiceProviders(val) => val.as_docs(),
                    Self::PolymeshCommittee(val) => val.as_docs(),
                    Self::CommitteeMembership(val) => val.as_docs(),
                    Self::TechnicalCommittee(val) => val.as_docs(),
                    Self::TechnicalCommitteeMembership(val) => val.as_docs(),
                    Self::UpgradeCommittee(val) => val.as_docs(),
                    Self::UpgradeCommitteeMembership(val) => val.as_docs(),
                    Self::MultiSig(val) => val.as_docs(),
                    Self::Validators(val) => val.as_docs(),
                    Self::Staking(val) => val.as_docs(),
                    Self::Session(val) => val.as_docs(),
                    Self::Grandpa(val) => val.as_docs(),
                    Self::ImOnline(val) => val.as_docs(),
                    Self::Sudo(val) => val.as_docs(),
                    Self::Asset(val) => val.as_docs(),
                    Self::CapitalDistribution(val) => val.as_docs(),
                    Self::Checkpoint(val) => val.as_docs(),
                    Self::ComplianceManager(val) => val.as_docs(),
                    Self::CorporateAction(val) => val.as_docs(),
                    Self::CorporateBallot(val) => val.as_docs(),
                    Self::Pips(val) => val.as_docs(),
                    Self::Portfolio(val) => val.as_docs(),
                    Self::ProtocolFee(val) => val.as_docs(),
                    Self::Scheduler(val) => val.as_docs(),
                    Self::Settlement(val) => val.as_docs(),
                    Self::Statistics(val) => val.as_docs(),
                    Self::Sto(val) => val.as_docs(),
                    Self::Treasury(val) => val.as_docs(),
                    Self::Utility(val) => val.as_docs(),
                    Self::Base(val) => val.as_docs(),
                    Self::ExternalAgents(val) => val.as_docs(),
                    Self::Relayer(val) => val.as_docs(),
                    Self::Contracts(val) => val.as_docs(),
                    Self::PolymeshContracts(val) => val.as_docs(),
                    Self::Preimage(val) => val.as_docs(),
                    Self::Nft(val) => val.as_docs(),
                    Self::ElectionProviderMultiPhase(val) => val.as_docs(),
                    Self::PolymeshTransactionPayment(val) => val.as_docs(),
                    Self::Beefy(val) => val.as_docs(),
                    _ => &[""],
                }
            }
        }
        impl From<RuntimeCall> for &'static str {
            fn from(v: RuntimeCall) -> Self {
                v.as_static_str()
            }
        }
        impl From<&RuntimeCall> for &'static str {
            fn from(v: &RuntimeCall) -> Self {
                v.as_static_str()
            }
        }
        pub mod events {
            use super::*;
            pub type SystemEvent = frame_system::pallet::SystemEvent;
            pub type IndicesEvent = pallet_indices::pallet::IndicesEvent;
            pub type BalancesEvent = pallet_balances::pallet::BalancesEvent;
            pub type TransactionPaymentEvent =
                pallet_transaction_payment::pallet::TransactionPaymentEvent;
            pub type IdentityEvent = pallet_identity::pallet::IdentityEvent;
            pub type CddServiceProvidersEvent =
                pallet_group::pallet::UpgradeCommitteeMembershipEvent;
            pub type PolymeshCommitteeEvent = pallet_committee::pallet::UpgradeCommitteeEvent;
            pub type CommitteeMembershipEvent =
                pallet_group::pallet::UpgradeCommitteeMembershipEvent;
            pub type TechnicalCommitteeEvent = pallet_committee::pallet::UpgradeCommitteeEvent;
            pub type TechnicalCommitteeMembershipEvent =
                pallet_group::pallet::UpgradeCommitteeMembershipEvent;
            pub type UpgradeCommitteeEvent = pallet_committee::pallet::UpgradeCommitteeEvent;
            pub type UpgradeCommitteeMembershipEvent =
                pallet_group::pallet::UpgradeCommitteeMembershipEvent;
            pub type MultiSigEvent = pallet_multisig::pallet::MultiSigEvent;
            pub type ValidatorsEvent = pallet_validators::pallet::ValidatorsEvent;
            pub type StakingEvent = pallet_staking::pallet::pallet::StakingEvent;
            pub type OffencesEvent = pallet_offences::pallet::OffencesEvent;
            pub type SessionEvent = pallet_session::pallet::SessionEvent;
            pub type GrandpaEvent = pallet_grandpa::pallet::GrandpaEvent;
            pub type HistoricalEvent = pallet_session::historical::pallet::HistoricalEvent;
            pub type ImOnlineEvent = pallet_im_online::pallet::ImOnlineEvent;
            pub type SudoEvent = pallet_sudo::pallet::SudoEvent;
            pub type AssetEvent = pallet_asset::pallet::AssetEvent;
            pub type CapitalDistributionEvent =
                pallet_corporate_actions::distribution::pallet::CapitalDistributionEvent;
            pub type CheckpointEvent = pallet_asset::checkpoint::pallet::CheckpointEvent;
            pub type ComplianceManagerEvent =
                pallet_compliance_manager::pallet::ComplianceManagerEvent;
            pub type CorporateActionEvent = pallet_corporate_actions::pallet::CorporateActionEvent;
            pub type CorporateBallotEvent =
                pallet_corporate_actions::ballot::pallet::CorporateBallotEvent;
            pub type PipsEvent = pallet_pips::pallet::PipsEvent;
            pub type PortfolioEvent = pallet_portfolio::pallet::PortfolioEvent;
            pub type ProtocolFeeEvent = pallet_protocol_fee::pallet::ProtocolFeeEvent;
            pub type SchedulerEvent = pallet_scheduler::pallet::SchedulerEvent;
            pub type SettlementEvent = pallet_settlement::pallet::SettlementEvent;
            pub type StatisticsEvent = pallet_statistics::pallet::StatisticsEvent;
            pub type StoEvent = pallet_sto::pallet::StoEvent;
            pub type TreasuryEvent = pallet_treasury::pallet::TreasuryEvent;
            pub type UtilityEvent = pallet_utility::pallet::UtilityEvent;
            pub type ExternalAgentsEvent = pallet_external_agents::pallet::ExternalAgentsEvent;
            pub type RelayerEvent = pallet_relayer::pallet::RelayerEvent;
            pub type ContractsEvent = pallet_contracts::pallet::ContractsEvent;
            pub type PolymeshContractsEvent = polymesh_contracts::pallet::PolymeshContractsEvent;
            pub type PreimageEvent = pallet_preimage::pallet::PreimageEvent;
            pub type NftEvent = pallet_nft::pallet::NftEvent;
            pub type ElectionProviderMultiPhaseEvent =
                pallet_election_provider_multi_phase::pallet::ElectionProviderMultiPhaseEvent;
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum RuntimeEvent {
            #[codec(index = 0u8)]
            System(events::SystemEvent),
            #[codec(index = 3u8)]
            Indices(events::IndicesEvent),
            #[codec(index = 5u8)]
            Balances(events::BalancesEvent),
            #[codec(index = 6u8)]
            TransactionPayment(events::TransactionPaymentEvent),
            #[codec(index = 7u8)]
            Identity(events::IdentityEvent),
            #[codec(index = 8u8)]
            CddServiceProviders(events::CddServiceProvidersEvent),
            #[codec(index = 9u8)]
            PolymeshCommittee(events::PolymeshCommitteeEvent),
            #[codec(index = 10u8)]
            CommitteeMembership(events::CommitteeMembershipEvent),
            #[codec(index = 11u8)]
            TechnicalCommittee(events::TechnicalCommitteeEvent),
            #[codec(index = 12u8)]
            TechnicalCommitteeMembership(events::TechnicalCommitteeMembershipEvent),
            #[codec(index = 13u8)]
            UpgradeCommittee(events::UpgradeCommitteeEvent),
            #[codec(index = 14u8)]
            UpgradeCommitteeMembership(events::UpgradeCommitteeMembershipEvent),
            #[codec(index = 15u8)]
            MultiSig(events::MultiSigEvent),
            #[codec(index = 16u8)]
            Validators(events::ValidatorsEvent),
            #[codec(index = 17u8)]
            Staking(events::StakingEvent),
            #[codec(index = 18u8)]
            Offences(events::OffencesEvent),
            #[codec(index = 19u8)]
            Session(events::SessionEvent),
            #[codec(index = 21u8)]
            Grandpa(events::GrandpaEvent),
            #[codec(index = 22u8)]
            Historical(events::HistoricalEvent),
            #[codec(index = 23u8)]
            ImOnline(events::ImOnlineEvent),
            #[codec(index = 25u8)]
            Sudo(events::SudoEvent),
            #[codec(index = 26u8)]
            Asset(events::AssetEvent),
            #[codec(index = 27u8)]
            CapitalDistribution(events::CapitalDistributionEvent),
            #[codec(index = 28u8)]
            Checkpoint(events::CheckpointEvent),
            #[codec(index = 29u8)]
            ComplianceManager(events::ComplianceManagerEvent),
            #[codec(index = 30u8)]
            CorporateAction(events::CorporateActionEvent),
            #[codec(index = 31u8)]
            CorporateBallot(events::CorporateBallotEvent),
            #[codec(index = 33u8)]
            Pips(events::PipsEvent),
            #[codec(index = 34u8)]
            Portfolio(events::PortfolioEvent),
            #[codec(index = 35u8)]
            ProtocolFee(events::ProtocolFeeEvent),
            #[codec(index = 36u8)]
            Scheduler(events::SchedulerEvent),
            #[codec(index = 37u8)]
            Settlement(events::SettlementEvent),
            #[codec(index = 38u8)]
            Statistics(events::StatisticsEvent),
            #[codec(index = 39u8)]
            Sto(events::StoEvent),
            #[codec(index = 40u8)]
            Treasury(events::TreasuryEvent),
            #[codec(index = 41u8)]
            Utility(events::UtilityEvent),
            #[codec(index = 43u8)]
            ExternalAgents(events::ExternalAgentsEvent),
            #[codec(index = 44u8)]
            Relayer(events::RelayerEvent),
            #[codec(index = 46u8)]
            Contracts(events::ContractsEvent),
            #[codec(index = 47u8)]
            PolymeshContracts(events::PolymeshContractsEvent),
            #[codec(index = 48u8)]
            Preimage(events::PreimageEvent),
            #[codec(index = 49u8)]
            Nft(events::NftEvent),
            #[codec(index = 50u8)]
            ElectionProviderMultiPhase(events::ElectionProviderMultiPhaseEvent),
        }
        impl RuntimeEvent {
            pub fn as_static_str(&self) -> &'static str {
                #[allow(unreachable_patterns)]
                match self {
                    Self::System(val) => val.as_static_str(),
                    Self::Indices(val) => val.as_static_str(),
                    Self::Balances(val) => val.as_static_str(),
                    Self::TransactionPayment(val) => val.as_static_str(),
                    Self::Identity(val) => val.as_static_str(),
                    Self::CddServiceProviders(val) => val.as_static_str(),
                    Self::PolymeshCommittee(val) => val.as_static_str(),
                    Self::CommitteeMembership(val) => val.as_static_str(),
                    Self::TechnicalCommittee(val) => val.as_static_str(),
                    Self::TechnicalCommitteeMembership(val) => val.as_static_str(),
                    Self::UpgradeCommittee(val) => val.as_static_str(),
                    Self::UpgradeCommitteeMembership(val) => val.as_static_str(),
                    Self::MultiSig(val) => val.as_static_str(),
                    Self::Validators(val) => val.as_static_str(),
                    Self::Staking(val) => val.as_static_str(),
                    Self::Offences(val) => val.as_static_str(),
                    Self::Session(val) => val.as_static_str(),
                    Self::Grandpa(val) => val.as_static_str(),
                    Self::Historical(val) => val.as_static_str(),
                    Self::ImOnline(val) => val.as_static_str(),
                    Self::Sudo(val) => val.as_static_str(),
                    Self::Asset(val) => val.as_static_str(),
                    Self::CapitalDistribution(val) => val.as_static_str(),
                    Self::Checkpoint(val) => val.as_static_str(),
                    Self::ComplianceManager(val) => val.as_static_str(),
                    Self::CorporateAction(val) => val.as_static_str(),
                    Self::CorporateBallot(val) => val.as_static_str(),
                    Self::Pips(val) => val.as_static_str(),
                    Self::Portfolio(val) => val.as_static_str(),
                    Self::ProtocolFee(val) => val.as_static_str(),
                    Self::Scheduler(val) => val.as_static_str(),
                    Self::Settlement(val) => val.as_static_str(),
                    Self::Statistics(val) => val.as_static_str(),
                    Self::Sto(val) => val.as_static_str(),
                    Self::Treasury(val) => val.as_static_str(),
                    Self::Utility(val) => val.as_static_str(),
                    Self::ExternalAgents(val) => val.as_static_str(),
                    Self::Relayer(val) => val.as_static_str(),
                    Self::Contracts(val) => val.as_static_str(),
                    Self::PolymeshContracts(val) => val.as_static_str(),
                    Self::Preimage(val) => val.as_static_str(),
                    Self::Nft(val) => val.as_static_str(),
                    Self::ElectionProviderMultiPhase(val) => val.as_static_str(),
                    _ => "Unknown",
                }
            }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for RuntimeEvent {
            fn as_name(&self) -> &'static str {
                self.as_static_str()
            }
            fn as_docs(&self) -> &'static [&'static str] {
                #[allow(unreachable_patterns)]
                match self {
                    Self::System(val) => val.as_docs(),
                    Self::Indices(val) => val.as_docs(),
                    Self::Balances(val) => val.as_docs(),
                    Self::TransactionPayment(val) => val.as_docs(),
                    Self::Identity(val) => val.as_docs(),
                    Self::CddServiceProviders(val) => val.as_docs(),
                    Self::PolymeshCommittee(val) => val.as_docs(),
                    Self::CommitteeMembership(val) => val.as_docs(),
                    Self::TechnicalCommittee(val) => val.as_docs(),
                    Self::TechnicalCommitteeMembership(val) => val.as_docs(),
                    Self::UpgradeCommittee(val) => val.as_docs(),
                    Self::UpgradeCommitteeMembership(val) => val.as_docs(),
                    Self::MultiSig(val) => val.as_docs(),
                    Self::Validators(val) => val.as_docs(),
                    Self::Staking(val) => val.as_docs(),
                    Self::Offences(val) => val.as_docs(),
                    Self::Session(val) => val.as_docs(),
                    Self::Grandpa(val) => val.as_docs(),
                    Self::Historical(val) => val.as_docs(),
                    Self::ImOnline(val) => val.as_docs(),
                    Self::Sudo(val) => val.as_docs(),
                    Self::Asset(val) => val.as_docs(),
                    Self::CapitalDistribution(val) => val.as_docs(),
                    Self::Checkpoint(val) => val.as_docs(),
                    Self::ComplianceManager(val) => val.as_docs(),
                    Self::CorporateAction(val) => val.as_docs(),
                    Self::CorporateBallot(val) => val.as_docs(),
                    Self::Pips(val) => val.as_docs(),
                    Self::Portfolio(val) => val.as_docs(),
                    Self::ProtocolFee(val) => val.as_docs(),
                    Self::Scheduler(val) => val.as_docs(),
                    Self::Settlement(val) => val.as_docs(),
                    Self::Statistics(val) => val.as_docs(),
                    Self::Sto(val) => val.as_docs(),
                    Self::Treasury(val) => val.as_docs(),
                    Self::Utility(val) => val.as_docs(),
                    Self::ExternalAgents(val) => val.as_docs(),
                    Self::Relayer(val) => val.as_docs(),
                    Self::Contracts(val) => val.as_docs(),
                    Self::PolymeshContracts(val) => val.as_docs(),
                    Self::Preimage(val) => val.as_docs(),
                    Self::Nft(val) => val.as_docs(),
                    Self::ElectionProviderMultiPhase(val) => val.as_docs(),
                    _ => &[""],
                }
            }
        }
        impl From<RuntimeEvent> for &'static str {
            fn from(v: RuntimeEvent) -> Self {
                v.as_static_str()
            }
        }
        impl From<&RuntimeEvent> for &'static str {
            fn from(v: &RuntimeEvent) -> Self {
                v.as_static_str()
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum RuntimeHoldReason {
            #[codec(index = 17u8)]
            Staking(pallet_staking::pallet::pallet::HoldReason),
            #[codec(index = 19u8)]
            Session(pallet_session::pallet::HoldReason),
            #[codec(index = 46u8)]
            Contracts(pallet_contracts::pallet::HoldReason),
            #[codec(index = 48u8)]
            Preimage(pallet_preimage::pallet::HoldReason),
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct SessionKeys {
            pub grandpa: sp_consensus_grandpa::app::Public,
            pub babe: sp_consensus_babe::app::Public,
            pub im_online: pallet_im_online::sr25519::app_sr25519::Public,
            pub authority_discovery: sp_authority_discovery::app::Public,
            pub beefy: sp_consensus_beefy::ecdsa_crypto::Public,
        }
    }
    pub mod sp_arithmetic {
        use super::*;
        pub mod fixed_point {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct FixedU128(pub u128);
        }
        pub mod per_things {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PerU16(pub u16);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Perbill(pub u32);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Percent(pub u8);
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Permill(pub u32);
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum ArithmeticError {
            #[codec(index = 0u8)]
            Underflow,
            #[codec(index = 1u8)]
            Overflow,
            #[codec(index = 2u8)]
            DivisionByZero,
        }
        impl ArithmeticError {
            pub fn as_static_str(&self) -> &'static str {
                #[allow(unreachable_patterns)]
                match self {
                    Self::Underflow => "Underflow",
                    Self::Overflow => "Overflow",
                    Self::DivisionByZero => "DivisionByZero",
                    _ => "Unknown",
                }
            }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for ArithmeticError {
            fn as_name(&self) -> &'static str {
                self.as_static_str()
            }
            fn as_docs(&self) -> &'static [&'static str] {
                #[allow(unreachable_patterns)]
                match self {
                    Self::Underflow => &[""],
                    Self::Overflow => &[""],
                    Self::DivisionByZero => &[""],
                    _ => &[""],
                }
            }
        }
        impl From<ArithmeticError> for &'static str {
            fn from(v: ArithmeticError) -> Self {
                v.as_static_str()
            }
        }
        impl From<&ArithmeticError> for &'static str {
            fn from(v: &ArithmeticError) -> Self {
                v.as_static_str()
            }
        }
    }
    pub mod sp_authority_discovery {
        use super::*;
        pub mod app {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Public(pub [u8; 32usize]);
        }
    }
    pub mod sp_consensus_babe {
        use super::*;
        pub mod app {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Public(pub [u8; 32usize]);
        }
        pub mod digests {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum NextConfigDescriptor {
                #[codec(index = 1u8)]
                V1 {
                    c: (u64, u64),
                    allowed_slots: sp_consensus_babe::AllowedSlots,
                },
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum PreDigest {
                #[codec(index = 1u8)]
                Primary(sp_consensus_babe::digests::PrimaryPreDigest),
                #[codec(index = 2u8)]
                SecondaryPlain(sp_consensus_babe::digests::SecondaryPlainPreDigest),
                #[codec(index = 3u8)]
                SecondaryVRF(sp_consensus_babe::digests::SecondaryVRFPreDigest),
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct PrimaryPreDigest {
                pub authority_index: u32,
                pub slot: sp_consensus_slots::Slot,
                pub vrf_signature: sp_core::sr25519::vrf::VrfSignature,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct SecondaryPlainPreDigest {
                pub authority_index: u32,
                pub slot: sp_consensus_slots::Slot,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct SecondaryVRFPreDigest {
                pub authority_index: u32,
                pub slot: sp_consensus_slots::Slot,
                pub vrf_signature: sp_core::sr25519::vrf::VrfSignature,
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum AllowedSlots {
            #[codec(index = 0u8)]
            PrimarySlots,
            #[codec(index = 1u8)]
            PrimaryAndSecondaryPlainSlots,
            #[codec(index = 2u8)]
            PrimaryAndSecondaryVRFSlots,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct BabeEpochConfiguration {
            pub c: (u64, u64),
            pub allowed_slots: sp_consensus_babe::AllowedSlots,
        }
    }
    pub mod sp_consensus_beefy {
        use super::*;
        pub mod commitment {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Commitment<TBlockNumber> {
                pub payload: sp_consensus_beefy::payload::Payload,
                pub block_number: TBlockNumber,
                pub validator_set_id: u64,
            }
        }
        pub mod ecdsa_crypto {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Public(
                #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                pub  [u8; 33usize],
            );
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Signature(
                #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                pub  [u8; 65usize],
            );
        }
        pub mod mmr {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct BeefyAuthoritySet<AuthoritySetCommitment> {
                pub id: u64,
                pub len: u32,
                pub keyset_commitment: AuthoritySetCommitment,
            }
        }
        pub mod payload {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Payload(pub ::alloc::vec::Vec<([u8; 2usize], ::alloc::vec::Vec<u8>)>);
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct DoubleVotingProof<Number, Id, Signature> {
            pub first: sp_consensus_beefy::VoteMessage<Number, Id, Signature>,
            pub second: sp_consensus_beefy::VoteMessage<Number, Id, Signature>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ForkVotingProof<Header, Id, AncestryProof> {
            pub vote: sp_consensus_beefy::VoteMessage<
                u32,
                Id,
                sp_consensus_beefy::ecdsa_crypto::Signature,
            >,
            pub ancestry_proof: AncestryProof,
            pub header: Header,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct FutureBlockVotingProof<Number, Id> {
            pub vote: sp_consensus_beefy::VoteMessage<
                Number,
                Id,
                sp_consensus_beefy::ecdsa_crypto::Signature,
            >,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct VoteMessage<Number, Id, Signature> {
            pub commitment: sp_consensus_beefy::commitment::Commitment<Number>,
            pub id: Id,
            pub signature: Signature,
        }
    }
    pub mod sp_consensus_grandpa {
        use super::*;
        pub mod app {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Public(pub [u8; 32usize]);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct Signature(
                #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                pub  [u8; 64usize],
            );
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum Equivocation<H, N> {
            #[codec(index = 0u8)]
            Prevote(
                finality_grandpa::Equivocation<
                    sp_consensus_grandpa::app::Public,
                    finality_grandpa::Prevote<H, N>,
                    sp_consensus_grandpa::app::Signature,
                >,
            ),
            #[codec(index = 1u8)]
            Precommit(
                finality_grandpa::Equivocation<
                    sp_consensus_grandpa::app::Public,
                    finality_grandpa::Precommit<H, N>,
                    sp_consensus_grandpa::app::Signature,
                >,
            ),
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct EquivocationProof<H, N> {
            pub set_id: u64,
            pub equivocation: sp_consensus_grandpa::Equivocation<H, N>,
        }
    }
    pub mod sp_consensus_slots {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct EquivocationProof<Header, Id> {
            pub offender: Id,
            pub slot: sp_consensus_slots::Slot,
            pub first_header: Header,
            pub second_header: Header,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Slot(pub u64);
    }
    pub mod sp_core {
        use super::*;
        pub mod crypto {
            use super::*;
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, :: codec :: Encode, :: codec :: Decode,
            )]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct AccountId32(pub [u8; 32usize]);
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct KeyTypeId(pub [u8; 4usize]);
        }
        pub mod sr25519 {
            use super::*;
            pub mod vrf {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct VrfSignature {
                    pub pre_output: [u8; 32usize],
                    #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                    pub proof: [u8; 64usize],
                }
            }
        }
    }
    pub mod sp_mmr_primitives {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct AncestryProof<Hash> {
            pub prev_peaks: ::alloc::vec::Vec<Hash>,
            pub prev_leaf_count: u64,
            pub leaf_count: u64,
            pub items: ::alloc::vec::Vec<(u64, Hash)>,
        }
    }
    pub mod sp_npos_elections {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ElectionScore {
            pub minimal_stake: u128,
            pub sum_stake: u128,
            pub sum_stake_squared: u128,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Support<AccountId> {
            pub total: u128,
            pub voters: ::alloc::vec::Vec<(AccountId, u128)>,
        }
    }
    pub mod sp_runtime {
        use super::*;
        pub mod generic {
            use super::*;
            pub mod digest {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct Digest {
                    pub logs: ::alloc::vec::Vec<sp_runtime::generic::digest::DigestItem>,
                }
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum DigestItem {
                    #[codec(index = 6u8)]
                    PreRuntime([u8; 4usize], ::alloc::vec::Vec<u8>),
                    #[codec(index = 4u8)]
                    Consensus([u8; 4usize], ::alloc::vec::Vec<u8>),
                    #[codec(index = 5u8)]
                    Seal([u8; 4usize], ::alloc::vec::Vec<u8>),
                    #[codec(index = 0u8)]
                    Other(::alloc::vec::Vec<u8>),
                    #[codec(index = 8u8)]
                    RuntimeEnvironmentUpdated,
                }
            }
            pub mod era {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub enum Era {
                    #[codec(index = 0u8)]
                    Immortal,
                    #[codec(index = 1u8)]
                    Mortal1(u8),
                    #[codec(index = 2u8)]
                    Mortal2(u8),
                    #[codec(index = 3u8)]
                    Mortal3(u8),
                    #[codec(index = 4u8)]
                    Mortal4(u8),
                    #[codec(index = 5u8)]
                    Mortal5(u8),
                    #[codec(index = 6u8)]
                    Mortal6(u8),
                    #[codec(index = 7u8)]
                    Mortal7(u8),
                    #[codec(index = 8u8)]
                    Mortal8(u8),
                    #[codec(index = 9u8)]
                    Mortal9(u8),
                    #[codec(index = 10u8)]
                    Mortal10(u8),
                    #[codec(index = 11u8)]
                    Mortal11(u8),
                    #[codec(index = 12u8)]
                    Mortal12(u8),
                    #[codec(index = 13u8)]
                    Mortal13(u8),
                    #[codec(index = 14u8)]
                    Mortal14(u8),
                    #[codec(index = 15u8)]
                    Mortal15(u8),
                    #[codec(index = 16u8)]
                    Mortal16(u8),
                    #[codec(index = 17u8)]
                    Mortal17(u8),
                    #[codec(index = 18u8)]
                    Mortal18(u8),
                    #[codec(index = 19u8)]
                    Mortal19(u8),
                    #[codec(index = 20u8)]
                    Mortal20(u8),
                    #[codec(index = 21u8)]
                    Mortal21(u8),
                    #[codec(index = 22u8)]
                    Mortal22(u8),
                    #[codec(index = 23u8)]
                    Mortal23(u8),
                    #[codec(index = 24u8)]
                    Mortal24(u8),
                    #[codec(index = 25u8)]
                    Mortal25(u8),
                    #[codec(index = 26u8)]
                    Mortal26(u8),
                    #[codec(index = 27u8)]
                    Mortal27(u8),
                    #[codec(index = 28u8)]
                    Mortal28(u8),
                    #[codec(index = 29u8)]
                    Mortal29(u8),
                    #[codec(index = 30u8)]
                    Mortal30(u8),
                    #[codec(index = 31u8)]
                    Mortal31(u8),
                    #[codec(index = 32u8)]
                    Mortal32(u8),
                    #[codec(index = 33u8)]
                    Mortal33(u8),
                    #[codec(index = 34u8)]
                    Mortal34(u8),
                    #[codec(index = 35u8)]
                    Mortal35(u8),
                    #[codec(index = 36u8)]
                    Mortal36(u8),
                    #[codec(index = 37u8)]
                    Mortal37(u8),
                    #[codec(index = 38u8)]
                    Mortal38(u8),
                    #[codec(index = 39u8)]
                    Mortal39(u8),
                    #[codec(index = 40u8)]
                    Mortal40(u8),
                    #[codec(index = 41u8)]
                    Mortal41(u8),
                    #[codec(index = 42u8)]
                    Mortal42(u8),
                    #[codec(index = 43u8)]
                    Mortal43(u8),
                    #[codec(index = 44u8)]
                    Mortal44(u8),
                    #[codec(index = 45u8)]
                    Mortal45(u8),
                    #[codec(index = 46u8)]
                    Mortal46(u8),
                    #[codec(index = 47u8)]
                    Mortal47(u8),
                    #[codec(index = 48u8)]
                    Mortal48(u8),
                    #[codec(index = 49u8)]
                    Mortal49(u8),
                    #[codec(index = 50u8)]
                    Mortal50(u8),
                    #[codec(index = 51u8)]
                    Mortal51(u8),
                    #[codec(index = 52u8)]
                    Mortal52(u8),
                    #[codec(index = 53u8)]
                    Mortal53(u8),
                    #[codec(index = 54u8)]
                    Mortal54(u8),
                    #[codec(index = 55u8)]
                    Mortal55(u8),
                    #[codec(index = 56u8)]
                    Mortal56(u8),
                    #[codec(index = 57u8)]
                    Mortal57(u8),
                    #[codec(index = 58u8)]
                    Mortal58(u8),
                    #[codec(index = 59u8)]
                    Mortal59(u8),
                    #[codec(index = 60u8)]
                    Mortal60(u8),
                    #[codec(index = 61u8)]
                    Mortal61(u8),
                    #[codec(index = 62u8)]
                    Mortal62(u8),
                    #[codec(index = 63u8)]
                    Mortal63(u8),
                    #[codec(index = 64u8)]
                    Mortal64(u8),
                    #[codec(index = 65u8)]
                    Mortal65(u8),
                    #[codec(index = 66u8)]
                    Mortal66(u8),
                    #[codec(index = 67u8)]
                    Mortal67(u8),
                    #[codec(index = 68u8)]
                    Mortal68(u8),
                    #[codec(index = 69u8)]
                    Mortal69(u8),
                    #[codec(index = 70u8)]
                    Mortal70(u8),
                    #[codec(index = 71u8)]
                    Mortal71(u8),
                    #[codec(index = 72u8)]
                    Mortal72(u8),
                    #[codec(index = 73u8)]
                    Mortal73(u8),
                    #[codec(index = 74u8)]
                    Mortal74(u8),
                    #[codec(index = 75u8)]
                    Mortal75(u8),
                    #[codec(index = 76u8)]
                    Mortal76(u8),
                    #[codec(index = 77u8)]
                    Mortal77(u8),
                    #[codec(index = 78u8)]
                    Mortal78(u8),
                    #[codec(index = 79u8)]
                    Mortal79(u8),
                    #[codec(index = 80u8)]
                    Mortal80(u8),
                    #[codec(index = 81u8)]
                    Mortal81(u8),
                    #[codec(index = 82u8)]
                    Mortal82(u8),
                    #[codec(index = 83u8)]
                    Mortal83(u8),
                    #[codec(index = 84u8)]
                    Mortal84(u8),
                    #[codec(index = 85u8)]
                    Mortal85(u8),
                    #[codec(index = 86u8)]
                    Mortal86(u8),
                    #[codec(index = 87u8)]
                    Mortal87(u8),
                    #[codec(index = 88u8)]
                    Mortal88(u8),
                    #[codec(index = 89u8)]
                    Mortal89(u8),
                    #[codec(index = 90u8)]
                    Mortal90(u8),
                    #[codec(index = 91u8)]
                    Mortal91(u8),
                    #[codec(index = 92u8)]
                    Mortal92(u8),
                    #[codec(index = 93u8)]
                    Mortal93(u8),
                    #[codec(index = 94u8)]
                    Mortal94(u8),
                    #[codec(index = 95u8)]
                    Mortal95(u8),
                    #[codec(index = 96u8)]
                    Mortal96(u8),
                    #[codec(index = 97u8)]
                    Mortal97(u8),
                    #[codec(index = 98u8)]
                    Mortal98(u8),
                    #[codec(index = 99u8)]
                    Mortal99(u8),
                    #[codec(index = 100u8)]
                    Mortal100(u8),
                    #[codec(index = 101u8)]
                    Mortal101(u8),
                    #[codec(index = 102u8)]
                    Mortal102(u8),
                    #[codec(index = 103u8)]
                    Mortal103(u8),
                    #[codec(index = 104u8)]
                    Mortal104(u8),
                    #[codec(index = 105u8)]
                    Mortal105(u8),
                    #[codec(index = 106u8)]
                    Mortal106(u8),
                    #[codec(index = 107u8)]
                    Mortal107(u8),
                    #[codec(index = 108u8)]
                    Mortal108(u8),
                    #[codec(index = 109u8)]
                    Mortal109(u8),
                    #[codec(index = 110u8)]
                    Mortal110(u8),
                    #[codec(index = 111u8)]
                    Mortal111(u8),
                    #[codec(index = 112u8)]
                    Mortal112(u8),
                    #[codec(index = 113u8)]
                    Mortal113(u8),
                    #[codec(index = 114u8)]
                    Mortal114(u8),
                    #[codec(index = 115u8)]
                    Mortal115(u8),
                    #[codec(index = 116u8)]
                    Mortal116(u8),
                    #[codec(index = 117u8)]
                    Mortal117(u8),
                    #[codec(index = 118u8)]
                    Mortal118(u8),
                    #[codec(index = 119u8)]
                    Mortal119(u8),
                    #[codec(index = 120u8)]
                    Mortal120(u8),
                    #[codec(index = 121u8)]
                    Mortal121(u8),
                    #[codec(index = 122u8)]
                    Mortal122(u8),
                    #[codec(index = 123u8)]
                    Mortal123(u8),
                    #[codec(index = 124u8)]
                    Mortal124(u8),
                    #[codec(index = 125u8)]
                    Mortal125(u8),
                    #[codec(index = 126u8)]
                    Mortal126(u8),
                    #[codec(index = 127u8)]
                    Mortal127(u8),
                    #[codec(index = 128u8)]
                    Mortal128(u8),
                    #[codec(index = 129u8)]
                    Mortal129(u8),
                    #[codec(index = 130u8)]
                    Mortal130(u8),
                    #[codec(index = 131u8)]
                    Mortal131(u8),
                    #[codec(index = 132u8)]
                    Mortal132(u8),
                    #[codec(index = 133u8)]
                    Mortal133(u8),
                    #[codec(index = 134u8)]
                    Mortal134(u8),
                    #[codec(index = 135u8)]
                    Mortal135(u8),
                    #[codec(index = 136u8)]
                    Mortal136(u8),
                    #[codec(index = 137u8)]
                    Mortal137(u8),
                    #[codec(index = 138u8)]
                    Mortal138(u8),
                    #[codec(index = 139u8)]
                    Mortal139(u8),
                    #[codec(index = 140u8)]
                    Mortal140(u8),
                    #[codec(index = 141u8)]
                    Mortal141(u8),
                    #[codec(index = 142u8)]
                    Mortal142(u8),
                    #[codec(index = 143u8)]
                    Mortal143(u8),
                    #[codec(index = 144u8)]
                    Mortal144(u8),
                    #[codec(index = 145u8)]
                    Mortal145(u8),
                    #[codec(index = 146u8)]
                    Mortal146(u8),
                    #[codec(index = 147u8)]
                    Mortal147(u8),
                    #[codec(index = 148u8)]
                    Mortal148(u8),
                    #[codec(index = 149u8)]
                    Mortal149(u8),
                    #[codec(index = 150u8)]
                    Mortal150(u8),
                    #[codec(index = 151u8)]
                    Mortal151(u8),
                    #[codec(index = 152u8)]
                    Mortal152(u8),
                    #[codec(index = 153u8)]
                    Mortal153(u8),
                    #[codec(index = 154u8)]
                    Mortal154(u8),
                    #[codec(index = 155u8)]
                    Mortal155(u8),
                    #[codec(index = 156u8)]
                    Mortal156(u8),
                    #[codec(index = 157u8)]
                    Mortal157(u8),
                    #[codec(index = 158u8)]
                    Mortal158(u8),
                    #[codec(index = 159u8)]
                    Mortal159(u8),
                    #[codec(index = 160u8)]
                    Mortal160(u8),
                    #[codec(index = 161u8)]
                    Mortal161(u8),
                    #[codec(index = 162u8)]
                    Mortal162(u8),
                    #[codec(index = 163u8)]
                    Mortal163(u8),
                    #[codec(index = 164u8)]
                    Mortal164(u8),
                    #[codec(index = 165u8)]
                    Mortal165(u8),
                    #[codec(index = 166u8)]
                    Mortal166(u8),
                    #[codec(index = 167u8)]
                    Mortal167(u8),
                    #[codec(index = 168u8)]
                    Mortal168(u8),
                    #[codec(index = 169u8)]
                    Mortal169(u8),
                    #[codec(index = 170u8)]
                    Mortal170(u8),
                    #[codec(index = 171u8)]
                    Mortal171(u8),
                    #[codec(index = 172u8)]
                    Mortal172(u8),
                    #[codec(index = 173u8)]
                    Mortal173(u8),
                    #[codec(index = 174u8)]
                    Mortal174(u8),
                    #[codec(index = 175u8)]
                    Mortal175(u8),
                    #[codec(index = 176u8)]
                    Mortal176(u8),
                    #[codec(index = 177u8)]
                    Mortal177(u8),
                    #[codec(index = 178u8)]
                    Mortal178(u8),
                    #[codec(index = 179u8)]
                    Mortal179(u8),
                    #[codec(index = 180u8)]
                    Mortal180(u8),
                    #[codec(index = 181u8)]
                    Mortal181(u8),
                    #[codec(index = 182u8)]
                    Mortal182(u8),
                    #[codec(index = 183u8)]
                    Mortal183(u8),
                    #[codec(index = 184u8)]
                    Mortal184(u8),
                    #[codec(index = 185u8)]
                    Mortal185(u8),
                    #[codec(index = 186u8)]
                    Mortal186(u8),
                    #[codec(index = 187u8)]
                    Mortal187(u8),
                    #[codec(index = 188u8)]
                    Mortal188(u8),
                    #[codec(index = 189u8)]
                    Mortal189(u8),
                    #[codec(index = 190u8)]
                    Mortal190(u8),
                    #[codec(index = 191u8)]
                    Mortal191(u8),
                    #[codec(index = 192u8)]
                    Mortal192(u8),
                    #[codec(index = 193u8)]
                    Mortal193(u8),
                    #[codec(index = 194u8)]
                    Mortal194(u8),
                    #[codec(index = 195u8)]
                    Mortal195(u8),
                    #[codec(index = 196u8)]
                    Mortal196(u8),
                    #[codec(index = 197u8)]
                    Mortal197(u8),
                    #[codec(index = 198u8)]
                    Mortal198(u8),
                    #[codec(index = 199u8)]
                    Mortal199(u8),
                    #[codec(index = 200u8)]
                    Mortal200(u8),
                    #[codec(index = 201u8)]
                    Mortal201(u8),
                    #[codec(index = 202u8)]
                    Mortal202(u8),
                    #[codec(index = 203u8)]
                    Mortal203(u8),
                    #[codec(index = 204u8)]
                    Mortal204(u8),
                    #[codec(index = 205u8)]
                    Mortal205(u8),
                    #[codec(index = 206u8)]
                    Mortal206(u8),
                    #[codec(index = 207u8)]
                    Mortal207(u8),
                    #[codec(index = 208u8)]
                    Mortal208(u8),
                    #[codec(index = 209u8)]
                    Mortal209(u8),
                    #[codec(index = 210u8)]
                    Mortal210(u8),
                    #[codec(index = 211u8)]
                    Mortal211(u8),
                    #[codec(index = 212u8)]
                    Mortal212(u8),
                    #[codec(index = 213u8)]
                    Mortal213(u8),
                    #[codec(index = 214u8)]
                    Mortal214(u8),
                    #[codec(index = 215u8)]
                    Mortal215(u8),
                    #[codec(index = 216u8)]
                    Mortal216(u8),
                    #[codec(index = 217u8)]
                    Mortal217(u8),
                    #[codec(index = 218u8)]
                    Mortal218(u8),
                    #[codec(index = 219u8)]
                    Mortal219(u8),
                    #[codec(index = 220u8)]
                    Mortal220(u8),
                    #[codec(index = 221u8)]
                    Mortal221(u8),
                    #[codec(index = 222u8)]
                    Mortal222(u8),
                    #[codec(index = 223u8)]
                    Mortal223(u8),
                    #[codec(index = 224u8)]
                    Mortal224(u8),
                    #[codec(index = 225u8)]
                    Mortal225(u8),
                    #[codec(index = 226u8)]
                    Mortal226(u8),
                    #[codec(index = 227u8)]
                    Mortal227(u8),
                    #[codec(index = 228u8)]
                    Mortal228(u8),
                    #[codec(index = 229u8)]
                    Mortal229(u8),
                    #[codec(index = 230u8)]
                    Mortal230(u8),
                    #[codec(index = 231u8)]
                    Mortal231(u8),
                    #[codec(index = 232u8)]
                    Mortal232(u8),
                    #[codec(index = 233u8)]
                    Mortal233(u8),
                    #[codec(index = 234u8)]
                    Mortal234(u8),
                    #[codec(index = 235u8)]
                    Mortal235(u8),
                    #[codec(index = 236u8)]
                    Mortal236(u8),
                    #[codec(index = 237u8)]
                    Mortal237(u8),
                    #[codec(index = 238u8)]
                    Mortal238(u8),
                    #[codec(index = 239u8)]
                    Mortal239(u8),
                    #[codec(index = 240u8)]
                    Mortal240(u8),
                    #[codec(index = 241u8)]
                    Mortal241(u8),
                    #[codec(index = 242u8)]
                    Mortal242(u8),
                    #[codec(index = 243u8)]
                    Mortal243(u8),
                    #[codec(index = 244u8)]
                    Mortal244(u8),
                    #[codec(index = 245u8)]
                    Mortal245(u8),
                    #[codec(index = 246u8)]
                    Mortal246(u8),
                    #[codec(index = 247u8)]
                    Mortal247(u8),
                    #[codec(index = 248u8)]
                    Mortal248(u8),
                    #[codec(index = 249u8)]
                    Mortal249(u8),
                    #[codec(index = 250u8)]
                    Mortal250(u8),
                    #[codec(index = 251u8)]
                    Mortal251(u8),
                    #[codec(index = 252u8)]
                    Mortal252(u8),
                    #[codec(index = 253u8)]
                    Mortal253(u8),
                    #[codec(index = 254u8)]
                    Mortal254(u8),
                    #[codec(index = 255u8)]
                    Mortal255(u8),
                }
            }
            pub mod header {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct Header<Number> {
                    pub parent_hash: primitive_types::H256,
                    #[codec(compact)]
                    pub number: Number,
                    pub state_root: primitive_types::H256,
                    pub extrinsics_root: primitive_types::H256,
                    pub digest: sp_runtime::generic::digest::Digest,
                }
            }
            pub mod unchecked_extrinsic {
                use super::*;
                #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
                #[cfg_attr(
                    all(feature = "std", feature = "type_info"),
                    derive(::scale_info::TypeInfo)
                )]
                #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
                pub struct UncheckedExtrinsic<Address, Call, Signature, Extra>(
                    pub ::alloc::vec::Vec<u8>,
                    core::marker::PhantomData<(Address, Call, Signature, Extra)>,
                );
            }
        }
        pub mod multiaddress {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum MultiAddress<AccountId, AccountIndex> {
                #[codec(index = 0u8)]
                Id(AccountId),
                #[codec(index = 1u8)]
                Index(#[codec(compact)] AccountIndex),
                #[codec(index = 2u8)]
                Raw(::alloc::vec::Vec<u8>),
                #[codec(index = 3u8)]
                Address32([u8; 32usize]),
                #[codec(index = 4u8)]
                Address20([u8; 20usize]),
            }
        }
        pub mod proving_trie {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub enum TrieError {
                #[codec(index = 0u8)]
                InvalidStateRoot,
                #[codec(index = 1u8)]
                IncompleteDatabase,
                #[codec(index = 2u8)]
                ValueAtIncompleteKey,
                #[codec(index = 3u8)]
                DecoderError,
                #[codec(index = 4u8)]
                InvalidHash,
                #[codec(index = 5u8)]
                DuplicateKey,
                #[codec(index = 6u8)]
                ExtraneousNode,
                #[codec(index = 7u8)]
                ExtraneousValue,
                #[codec(index = 8u8)]
                ExtraneousHashReference,
                #[codec(index = 9u8)]
                InvalidChildReference,
                #[codec(index = 10u8)]
                ValueMismatch,
                #[codec(index = 11u8)]
                IncompleteProof,
                #[codec(index = 12u8)]
                RootMismatch,
                #[codec(index = 13u8)]
                DecodeError,
            }
        }
        pub mod traits {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct BlakeTwo256();
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum DispatchError {
            Other,
            CannotLookup,
            BadOrigin,
            Module(ModuleError),
            ConsumerRemaining,
            NoProviders,
            TooManyConsumers,
            Token(sp_runtime::TokenError),
            Arithmetic(sp_arithmetic::ArithmeticError),
            Transactional(sp_runtime::TransactionalError),
            Exhausted,
            Corruption,
            Unavailable,
            RootNotAllowed,
        }
        impl DispatchError {
            pub fn as_static_str(&self) -> &'static str {
                match self {
                    Self::Other => "Other",
                    Self::CannotLookup => "CannotLookup",
                    Self::BadOrigin => "BadOrigin",
                    Self::Module(err) => err.as_static_str(),
                    Self::ConsumerRemaining => "ConsumerRemaining",
                    Self::NoProviders => "NoProviders",
                    Self::TooManyConsumers => "TooManyConsumers",
                    Self::Token(err) => err.as_static_str(),
                    Self::Arithmetic(err) => err.as_static_str(),
                    Self::Transactional(err) => err.as_static_str(),
                    Self::Exhausted => "Exhausted",
                    Self::Corruption => "Corruption",
                    Self::Unavailable => "Unavailable",
                    Self::RootNotAllowed => "RootNotAllowed",
                }
            }
        }
        impl From<DispatchError> for &'static str {
            fn from(v: DispatchError) -> Self {
                v.as_static_str()
            }
        }
        impl From<&DispatchError> for &'static str {
            fn from(v: &DispatchError) -> Self {
                v.as_static_str()
            }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for DispatchError {
            fn as_name(&self) -> &'static str {
                self.as_static_str()
            }
            fn as_docs(&self) -> &'static [&'static str] {
                match self { Self :: Other => & ["Some error occurred."] , Self :: CannotLookup => & ["Failed to lookup some data."] , Self :: BadOrigin => & ["A bad origin."] , Self :: Module (err) => err . as_docs () , Self :: ConsumerRemaining => & ["At least one consumer is remaining so the account cannot be destroyed."] , Self :: NoProviders => & ["There are no providers so the account cannot be created."] , Self :: TooManyConsumers => & ["There are too many consumers so the account cannot be created."] , Self :: Token (err) => err . as_docs () , Self :: Arithmetic (err) => err . as_docs () , Self :: Transactional (err) => err . as_docs () , Self :: Exhausted => & ["Resources exhausted, e.g. attempt to read/write data which is too large to manipulate."] , Self :: Corruption => & ["The state is corrupt; this is generally not going to fix itself."] , Self :: Unavailable => & ["Some resource (e.g. a preimage) is unavailable right now. This might fix itself later."] , Self :: RootNotAllowed => & ["Root origin is not allowed."] , }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum RuntimeError {
            #[codec(index = 0u8)]
            System(frame_system::pallet::SystemError),
            #[codec(index = 1u8)]
            Babe(pallet_babe::pallet::BabeError),
            #[codec(index = 3u8)]
            Indices(pallet_indices::pallet::IndicesError),
            #[codec(index = 5u8)]
            Balances(pallet_balances::pallet::BalancesError),
            #[codec(index = 7u8)]
            Identity(pallet_identity::pallet::IdentityError),
            #[codec(index = 8u8)]
            CddServiceProviders(pallet_group::pallet::UpgradeCommitteeMembershipError),
            #[codec(index = 9u8)]
            PolymeshCommittee(pallet_committee::pallet::UpgradeCommitteeError),
            #[codec(index = 10u8)]
            CommitteeMembership(pallet_group::pallet::UpgradeCommitteeMembershipError),
            #[codec(index = 11u8)]
            TechnicalCommittee(pallet_committee::pallet::UpgradeCommitteeError),
            #[codec(index = 12u8)]
            TechnicalCommitteeMembership(pallet_group::pallet::UpgradeCommitteeMembershipError),
            #[codec(index = 13u8)]
            UpgradeCommittee(pallet_committee::pallet::UpgradeCommitteeError),
            #[codec(index = 14u8)]
            UpgradeCommitteeMembership(pallet_group::pallet::UpgradeCommitteeMembershipError),
            #[codec(index = 15u8)]
            MultiSig(pallet_multisig::pallet::MultiSigError),
            #[codec(index = 16u8)]
            Validators(pallet_validators::pallet::ValidatorsError),
            #[codec(index = 17u8)]
            Staking(pallet_staking::pallet::pallet::StakingError),
            #[codec(index = 19u8)]
            Session(pallet_session::pallet::SessionError),
            #[codec(index = 21u8)]
            Grandpa(pallet_grandpa::pallet::GrandpaError),
            #[codec(index = 23u8)]
            ImOnline(pallet_im_online::pallet::ImOnlineError),
            #[codec(index = 25u8)]
            Sudo(pallet_sudo::pallet::SudoError),
            #[codec(index = 26u8)]
            Asset(pallet_asset::pallet::AssetError),
            #[codec(index = 27u8)]
            CapitalDistribution(
                pallet_corporate_actions::distribution::pallet::CapitalDistributionError,
            ),
            #[codec(index = 28u8)]
            Checkpoint(pallet_asset::checkpoint::pallet::CheckpointError),
            #[codec(index = 29u8)]
            ComplianceManager(pallet_compliance_manager::pallet::ComplianceManagerError),
            #[codec(index = 30u8)]
            CorporateAction(pallet_corporate_actions::pallet::CorporateActionError),
            #[codec(index = 31u8)]
            CorporateBallot(pallet_corporate_actions::ballot::pallet::CorporateBallotError),
            #[codec(index = 32u8)]
            Permissions(pallet_permissions::pallet::PermissionsError),
            #[codec(index = 33u8)]
            Pips(pallet_pips::pallet::PipsError),
            #[codec(index = 34u8)]
            Portfolio(pallet_portfolio::pallet::PortfolioError),
            #[codec(index = 35u8)]
            ProtocolFee(pallet_protocol_fee::pallet::ProtocolFeeError),
            #[codec(index = 36u8)]
            Scheduler(pallet_scheduler::pallet::SchedulerError),
            #[codec(index = 37u8)]
            Settlement(pallet_settlement::pallet::SettlementError),
            #[codec(index = 38u8)]
            Statistics(pallet_statistics::pallet::StatisticsError),
            #[codec(index = 39u8)]
            Sto(pallet_sto::pallet::StoError),
            #[codec(index = 40u8)]
            Treasury(pallet_treasury::pallet::TreasuryError),
            #[codec(index = 41u8)]
            Utility(pallet_utility::pallet::UtilityError),
            #[codec(index = 42u8)]
            Base(pallet_base::pallet::BaseError),
            #[codec(index = 43u8)]
            ExternalAgents(pallet_external_agents::pallet::ExternalAgentsError),
            #[codec(index = 44u8)]
            Relayer(pallet_relayer::pallet::RelayerError),
            #[codec(index = 46u8)]
            Contracts(pallet_contracts::pallet::ContractsError),
            #[codec(index = 47u8)]
            PolymeshContracts(polymesh_contracts::pallet::PolymeshContractsError),
            #[codec(index = 48u8)]
            Preimage(pallet_preimage::pallet::PreimageError),
            #[codec(index = 49u8)]
            Nft(pallet_nft::pallet::NftError),
            #[codec(index = 50u8)]
            ElectionProviderMultiPhase(
                pallet_election_provider_multi_phase::pallet::ElectionProviderMultiPhaseError,
            ),
            #[codec(index = 52u8)]
            Beefy(pallet_beefy::pallet::BeefyError),
        }
        impl RuntimeError {
            pub fn as_static_str(&self) -> &'static str {
                match self {
                    RuntimeError::System(err) => err.as_static_str(),
                    RuntimeError::Babe(err) => err.as_static_str(),
                    RuntimeError::Indices(err) => err.as_static_str(),
                    RuntimeError::Balances(err) => err.as_static_str(),
                    RuntimeError::Identity(err) => err.as_static_str(),
                    RuntimeError::CddServiceProviders(err) => err.as_static_str(),
                    RuntimeError::PolymeshCommittee(err) => err.as_static_str(),
                    RuntimeError::CommitteeMembership(err) => err.as_static_str(),
                    RuntimeError::TechnicalCommittee(err) => err.as_static_str(),
                    RuntimeError::TechnicalCommitteeMembership(err) => err.as_static_str(),
                    RuntimeError::UpgradeCommittee(err) => err.as_static_str(),
                    RuntimeError::UpgradeCommitteeMembership(err) => err.as_static_str(),
                    RuntimeError::MultiSig(err) => err.as_static_str(),
                    RuntimeError::Validators(err) => err.as_static_str(),
                    RuntimeError::Staking(err) => err.as_static_str(),
                    RuntimeError::Session(err) => err.as_static_str(),
                    RuntimeError::Grandpa(err) => err.as_static_str(),
                    RuntimeError::ImOnline(err) => err.as_static_str(),
                    RuntimeError::Sudo(err) => err.as_static_str(),
                    RuntimeError::Asset(err) => err.as_static_str(),
                    RuntimeError::CapitalDistribution(err) => err.as_static_str(),
                    RuntimeError::Checkpoint(err) => err.as_static_str(),
                    RuntimeError::ComplianceManager(err) => err.as_static_str(),
                    RuntimeError::CorporateAction(err) => err.as_static_str(),
                    RuntimeError::CorporateBallot(err) => err.as_static_str(),
                    RuntimeError::Permissions(err) => err.as_static_str(),
                    RuntimeError::Pips(err) => err.as_static_str(),
                    RuntimeError::Portfolio(err) => err.as_static_str(),
                    RuntimeError::ProtocolFee(err) => err.as_static_str(),
                    RuntimeError::Scheduler(err) => err.as_static_str(),
                    RuntimeError::Settlement(err) => err.as_static_str(),
                    RuntimeError::Statistics(err) => err.as_static_str(),
                    RuntimeError::Sto(err) => err.as_static_str(),
                    RuntimeError::Treasury(err) => err.as_static_str(),
                    RuntimeError::Utility(err) => err.as_static_str(),
                    RuntimeError::Base(err) => err.as_static_str(),
                    RuntimeError::ExternalAgents(err) => err.as_static_str(),
                    RuntimeError::Relayer(err) => err.as_static_str(),
                    RuntimeError::Contracts(err) => err.as_static_str(),
                    RuntimeError::PolymeshContracts(err) => err.as_static_str(),
                    RuntimeError::Preimage(err) => err.as_static_str(),
                    RuntimeError::Nft(err) => err.as_static_str(),
                    RuntimeError::ElectionProviderMultiPhase(err) => err.as_static_str(),
                    RuntimeError::Beefy(err) => err.as_static_str(),
                }
            }
        }
        impl From<RuntimeError> for &'static str {
            fn from(v: RuntimeError) -> Self {
                v.as_static_str()
            }
        }
        impl From<&RuntimeError> for &'static str {
            fn from(v: &RuntimeError) -> Self {
                v.as_static_str()
            }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for RuntimeError {
            fn as_name(&self) -> &'static str {
                self.as_static_str()
            }
            fn as_docs(&self) -> &'static [&'static str] {
                match self {
                    RuntimeError::System(err) => err.as_docs(),
                    RuntimeError::Babe(err) => err.as_docs(),
                    RuntimeError::Indices(err) => err.as_docs(),
                    RuntimeError::Balances(err) => err.as_docs(),
                    RuntimeError::Identity(err) => err.as_docs(),
                    RuntimeError::CddServiceProviders(err) => err.as_docs(),
                    RuntimeError::PolymeshCommittee(err) => err.as_docs(),
                    RuntimeError::CommitteeMembership(err) => err.as_docs(),
                    RuntimeError::TechnicalCommittee(err) => err.as_docs(),
                    RuntimeError::TechnicalCommitteeMembership(err) => err.as_docs(),
                    RuntimeError::UpgradeCommittee(err) => err.as_docs(),
                    RuntimeError::UpgradeCommitteeMembership(err) => err.as_docs(),
                    RuntimeError::MultiSig(err) => err.as_docs(),
                    RuntimeError::Validators(err) => err.as_docs(),
                    RuntimeError::Staking(err) => err.as_docs(),
                    RuntimeError::Session(err) => err.as_docs(),
                    RuntimeError::Grandpa(err) => err.as_docs(),
                    RuntimeError::ImOnline(err) => err.as_docs(),
                    RuntimeError::Sudo(err) => err.as_docs(),
                    RuntimeError::Asset(err) => err.as_docs(),
                    RuntimeError::CapitalDistribution(err) => err.as_docs(),
                    RuntimeError::Checkpoint(err) => err.as_docs(),
                    RuntimeError::ComplianceManager(err) => err.as_docs(),
                    RuntimeError::CorporateAction(err) => err.as_docs(),
                    RuntimeError::CorporateBallot(err) => err.as_docs(),
                    RuntimeError::Permissions(err) => err.as_docs(),
                    RuntimeError::Pips(err) => err.as_docs(),
                    RuntimeError::Portfolio(err) => err.as_docs(),
                    RuntimeError::ProtocolFee(err) => err.as_docs(),
                    RuntimeError::Scheduler(err) => err.as_docs(),
                    RuntimeError::Settlement(err) => err.as_docs(),
                    RuntimeError::Statistics(err) => err.as_docs(),
                    RuntimeError::Sto(err) => err.as_docs(),
                    RuntimeError::Treasury(err) => err.as_docs(),
                    RuntimeError::Utility(err) => err.as_docs(),
                    RuntimeError::Base(err) => err.as_docs(),
                    RuntimeError::ExternalAgents(err) => err.as_docs(),
                    RuntimeError::Relayer(err) => err.as_docs(),
                    RuntimeError::Contracts(err) => err.as_docs(),
                    RuntimeError::PolymeshContracts(err) => err.as_docs(),
                    RuntimeError::Preimage(err) => err.as_docs(),
                    RuntimeError::Nft(err) => err.as_docs(),
                    RuntimeError::ElectionProviderMultiPhase(err) => err.as_docs(),
                    RuntimeError::Beefy(err) => err.as_docs(),
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ModuleError(pub RuntimeError);
        impl ::codec::Encode for ModuleError {
            fn encode_to<T: ::codec::Output + ?Sized>(&self, output: &mut T) {
                let mut raw = self.0.encode();
                raw.resize(5usize, 0);
                output.write(raw.as_slice());
            }
        }
        impl ::codec::Decode for ModuleError {
            fn decode<I: ::codec::Input>(input: &mut I) -> Result<Self, ::codec::Error> {
                let raw: [u8; 5usize] = ::codec::Decode::decode(input)?;
                Ok(Self(RuntimeError::decode(&mut &raw[..])?))
            }
        }
        impl ModuleError {
            pub fn as_static_str(&self) -> &'static str {
                self.0.as_static_str()
            }
        }
        impl From<ModuleError> for &'static str {
            fn from(v: ModuleError) -> Self {
                v.as_static_str()
            }
        }
        impl From<&ModuleError> for &'static str {
            fn from(v: &ModuleError) -> Self {
                v.as_static_str()
            }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for ModuleError {
            fn as_name(&self) -> &'static str {
                self.as_static_str()
            }
            fn as_docs(&self) -> &'static [&'static str] {
                self.0.as_docs()
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum MultiSignature {
            #[codec(index = 0u8)]
            Ed25519(
                #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                [u8; 64usize],
            ),
            #[codec(index = 1u8)]
            Sr25519(
                #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                [u8; 64usize],
            ),
            #[codec(index = 2u8)]
            Ecdsa(
                #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                [u8; 65usize],
            ),
            #[codec(index = 3u8)]
            Eth(
                #[cfg_attr(feature = "serde", serde(with = "::serde_big_array::BigArray"))]
                [u8; 65usize],
            ),
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum TokenError {
            #[codec(index = 0u8)]
            FundsUnavailable,
            #[codec(index = 1u8)]
            OnlyProvider,
            #[codec(index = 2u8)]
            BelowMinimum,
            #[codec(index = 3u8)]
            CannotCreate,
            #[codec(index = 4u8)]
            UnknownAsset,
            #[codec(index = 5u8)]
            Frozen,
            #[codec(index = 6u8)]
            Unsupported,
            #[codec(index = 7u8)]
            CannotCreateHold,
            #[codec(index = 8u8)]
            NotExpendable,
            #[codec(index = 9u8)]
            Blocked,
        }
        impl TokenError {
            pub fn as_static_str(&self) -> &'static str {
                #[allow(unreachable_patterns)]
                match self {
                    Self::FundsUnavailable => "FundsUnavailable",
                    Self::OnlyProvider => "OnlyProvider",
                    Self::BelowMinimum => "BelowMinimum",
                    Self::CannotCreate => "CannotCreate",
                    Self::UnknownAsset => "UnknownAsset",
                    Self::Frozen => "Frozen",
                    Self::Unsupported => "Unsupported",
                    Self::CannotCreateHold => "CannotCreateHold",
                    Self::NotExpendable => "NotExpendable",
                    Self::Blocked => "Blocked",
                    _ => "Unknown",
                }
            }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for TokenError {
            fn as_name(&self) -> &'static str {
                self.as_static_str()
            }
            fn as_docs(&self) -> &'static [&'static str] {
                #[allow(unreachable_patterns)]
                match self {
                    Self::FundsUnavailable => &[""],
                    Self::OnlyProvider => &[""],
                    Self::BelowMinimum => &[""],
                    Self::CannotCreate => &[""],
                    Self::UnknownAsset => &[""],
                    Self::Frozen => &[""],
                    Self::Unsupported => &[""],
                    Self::CannotCreateHold => &[""],
                    Self::NotExpendable => &[""],
                    Self::Blocked => &[""],
                    _ => &[""],
                }
            }
        }
        impl From<TokenError> for &'static str {
            fn from(v: TokenError) -> Self {
                v.as_static_str()
            }
        }
        impl From<&TokenError> for &'static str {
            fn from(v: &TokenError) -> Self {
                v.as_static_str()
            }
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub enum TransactionalError {
            #[codec(index = 0u8)]
            LimitReached,
            #[codec(index = 1u8)]
            NoLayer,
        }
        impl TransactionalError {
            pub fn as_static_str(&self) -> &'static str {
                #[allow(unreachable_patterns)]
                match self {
                    Self::LimitReached => "LimitReached",
                    Self::NoLayer => "NoLayer",
                    _ => "Unknown",
                }
            }
        }
        #[cfg(not(feature = "ink"))]
        impl ::polymesh_api_client::EnumInfo for TransactionalError {
            fn as_name(&self) -> &'static str {
                self.as_static_str()
            }
            fn as_docs(&self) -> &'static [&'static str] {
                #[allow(unreachable_patterns)]
                match self {
                    Self::LimitReached => &[""],
                    Self::NoLayer => &[""],
                    _ => &[""],
                }
            }
        }
        impl From<TransactionalError> for &'static str {
            fn from(v: TransactionalError) -> Self {
                v.as_static_str()
            }
        }
        impl From<&TransactionalError> for &'static str {
            fn from(v: &TransactionalError) -> Self {
                v.as_static_str()
            }
        }
    }
    pub mod sp_session {
        use super::*;
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct MembershipProof {
            pub session: u32,
            pub trie_nodes: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
            pub validator_count: u32,
        }
    }
    pub mod sp_staking {
        use super::*;
        pub mod offence {
            use super::*;
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct OffenceDetails<Reporter, Offender> {
                pub offender: Offender,
                pub reporters: ::alloc::vec::Vec<Reporter>,
            }
            #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
            #[cfg_attr(
                all(feature = "std", feature = "type_info"),
                derive(::scale_info::TypeInfo)
            )]
            #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
            pub struct OffenceSeverity(pub ::polymesh_api_client::per_things::Perbill);
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct Exposure<AccountId, Balance> {
            #[codec(compact)]
            pub total: Balance,
            #[codec(compact)]
            pub own: Balance,
            pub others: ::alloc::vec::Vec<sp_staking::IndividualExposure<AccountId, Balance>>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct ExposurePage<AccountId, Balance> {
            #[codec(compact)]
            pub page_total: Balance,
            pub others: ::alloc::vec::Vec<sp_staking::IndividualExposure<AccountId, Balance>>,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct IndividualExposure<AccountId, Balance> {
            pub who: AccountId,
            #[codec(compact)]
            pub value: Balance,
        }
        #[derive(Clone, Debug, PartialEq, Eq, :: codec :: Encode, :: codec :: Decode)]
        #[cfg_attr(
            all(feature = "std", feature = "type_info"),
            derive(::scale_info::TypeInfo)
        )]
        #[cfg_attr(feature = "serde", derive(::serde::Serialize, ::serde::Deserialize))]
        pub struct PagedExposureMetadata<Balance> {
            #[codec(compact)]
            pub total: Balance,
            #[codec(compact)]
            pub own: Balance,
            pub nominator_count: u32,
            pub page_count: u32,
        }
    }
}
#[allow(dead_code, unused_imports, non_camel_case_types)]
pub mod api {
    use super::types;
    use super::types::*;
    use super::WrappedCall;
    pub mod system {
        use super::*;
        #[derive(Clone)]
        pub struct SystemCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> SystemCallApi<'api> {
            #[doc = "Make some on-chain remark."]
            #[doc = ""]
            #[doc = "Can be executed by every `origin`."]
            #[cfg(not(feature = "ink"))]
            pub fn remark(
                &self,
                remark: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::remark { remark },
                ))
            }
            #[doc = "Make some on-chain remark."]
            #[doc = ""]
            #[doc = "Can be executed by every `origin`."]
            #[cfg(feature = "ink")]
            pub fn remark(&self, remark: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 0u8];
                remark.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set the number of pages in the WebAssembly environment's heap."]
            #[cfg(not(feature = "ink"))]
            pub fn set_heap_pages(
                &self,
                pages: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::set_heap_pages { pages },
                ))
            }
            #[doc = "Set the number of pages in the WebAssembly environment's heap."]
            #[cfg(feature = "ink")]
            pub fn set_heap_pages(&self, pages: u64) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 1u8];
                pages.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set the new runtime code."]
            #[cfg(not(feature = "ink"))]
            pub fn set_code(
                &self,
                code: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::set_code { code },
                ))
            }
            #[doc = "Set the new runtime code."]
            #[cfg(feature = "ink")]
            pub fn set_code(&self, code: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 2u8];
                code.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set the new runtime code without doing any checks of the given `code`."]
            #[doc = ""]
            #[doc = "Note that runtime upgrades will not run if this is called with a not-increasing spec"]
            #[doc = "version!"]
            #[cfg(not(feature = "ink"))]
            pub fn set_code_without_checks(
                &self,
                code: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::set_code_without_checks { code },
                ))
            }
            #[doc = "Set the new runtime code without doing any checks of the given `code`."]
            #[doc = ""]
            #[doc = "Note that runtime upgrades will not run if this is called with a not-increasing spec"]
            #[doc = "version!"]
            #[cfg(feature = "ink")]
            pub fn set_code_without_checks(
                &self,
                code: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 3u8];
                code.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set some items of storage."]
            #[cfg(not(feature = "ink"))]
            pub fn set_storage(
                &self,
                items: ::alloc::vec::Vec<(::alloc::vec::Vec<u8>, ::alloc::vec::Vec<u8>)>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::set_storage { items },
                ))
            }
            #[doc = "Set some items of storage."]
            #[cfg(feature = "ink")]
            pub fn set_storage(
                &self,
                items: ::alloc::vec::Vec<(::alloc::vec::Vec<u8>, ::alloc::vec::Vec<u8>)>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 4u8];
                items.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Kill some items from storage."]
            #[cfg(not(feature = "ink"))]
            pub fn kill_storage(
                &self,
                keys: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::kill_storage { keys },
                ))
            }
            #[doc = "Kill some items from storage."]
            #[cfg(feature = "ink")]
            pub fn kill_storage(
                &self,
                keys: ::alloc::vec::Vec<::alloc::vec::Vec<u8>>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 5u8];
                keys.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Kill all storage items with a key that starts with the given prefix."]
            #[doc = ""]
            #[doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"]
            #[doc = "the prefix we are removing to accurately calculate the weight of this function."]
            #[cfg(not(feature = "ink"))]
            pub fn kill_prefix(
                &self,
                prefix: ::alloc::vec::Vec<u8>,
                subkeys: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::kill_prefix { prefix, subkeys },
                ))
            }
            #[doc = "Kill all storage items with a key that starts with the given prefix."]
            #[doc = ""]
            #[doc = "**NOTE:** We rely on the Root origin to provide us the number of subkeys under"]
            #[doc = "the prefix we are removing to accurately calculate the weight of this function."]
            #[cfg(feature = "ink")]
            pub fn kill_prefix(
                &self,
                prefix: ::alloc::vec::Vec<u8>,
                subkeys: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 6u8];
                prefix.encode_to(&mut buf);
                subkeys.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Make some on-chain remark and emit event."]
            #[cfg(not(feature = "ink"))]
            pub fn remark_with_event(
                &self,
                remark: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::remark_with_event { remark },
                ))
            }
            #[doc = "Make some on-chain remark and emit event."]
            #[cfg(feature = "ink")]
            pub fn remark_with_event(
                &self,
                remark: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 7u8];
                remark.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"]
            #[doc = "later."]
            #[doc = ""]
            #[doc = "This call requires Root origin."]
            #[cfg(not(feature = "ink"))]
            pub fn authorize_upgrade(
                &self,
                code_hash: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::authorize_upgrade { code_hash },
                ))
            }
            #[doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"]
            #[doc = "later."]
            #[doc = ""]
            #[doc = "This call requires Root origin."]
            #[cfg(feature = "ink")]
            pub fn authorize_upgrade(
                &self,
                code_hash: types::primitive_types::H256,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 9u8];
                code_hash.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"]
            #[doc = "later."]
            #[doc = ""]
            #[doc = "WARNING: This authorizes an upgrade that will take place without any safety checks, for"]
            #[doc = "example that the spec name remains the same and that the version number increases. Not"]
            #[doc = "recommended for normal use. Use `authorize_upgrade` instead."]
            #[doc = ""]
            #[doc = "This call requires Root origin."]
            #[cfg(not(feature = "ink"))]
            pub fn authorize_upgrade_without_checks(
                &self,
                code_hash: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::authorize_upgrade_without_checks {
                        code_hash,
                    },
                ))
            }
            #[doc = "Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied"]
            #[doc = "later."]
            #[doc = ""]
            #[doc = "WARNING: This authorizes an upgrade that will take place without any safety checks, for"]
            #[doc = "example that the spec name remains the same and that the version number increases. Not"]
            #[doc = "recommended for normal use. Use `authorize_upgrade` instead."]
            #[doc = ""]
            #[doc = "This call requires Root origin."]
            #[cfg(feature = "ink")]
            pub fn authorize_upgrade_without_checks(
                &self,
                code_hash: types::primitive_types::H256,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 10u8];
                code_hash.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Provide the preimage (runtime binary) `code` for an upgrade that has been authorized."]
            #[doc = ""]
            #[doc = "If the authorization required a version check, this call will ensure the spec name"]
            #[doc = "remains unchanged and that the spec version has increased."]
            #[doc = ""]
            #[doc = "Depending on the runtime's `OnSetCode` configuration, this function may directly apply"]
            #[doc = "the new `code` in the same block or attempt to schedule the upgrade."]
            #[doc = ""]
            #[doc = "All origins are allowed."]
            #[cfg(not(feature = "ink"))]
            pub fn apply_authorized_upgrade(
                &self,
                code: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::System(
                    types::frame_system::pallet::SystemCall::apply_authorized_upgrade { code },
                ))
            }
            #[doc = "Provide the preimage (runtime binary) `code` for an upgrade that has been authorized."]
            #[doc = ""]
            #[doc = "If the authorization required a version check, this call will ensure the spec name"]
            #[doc = "remains unchanged and that the spec version has increased."]
            #[doc = ""]
            #[doc = "Depending on the runtime's `OnSetCode` configuration, this function may directly apply"]
            #[doc = "the new `code` in the same block or attempt to schedule the upgrade."]
            #[doc = ""]
            #[doc = "All origins are allowed."]
            #[cfg(feature = "ink")]
            pub fn apply_authorized_upgrade(
                &self,
                code: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![0u8, 11u8];
                code.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for SystemCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct SystemQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> SystemQueryApi<'api> {
            #[doc = " The full account information for a particular account ID."]
            #[cfg(not(feature = "ink"))]
            pub async fn account(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                types::frame_system::AccountInfo<
                    u32,
                    types::pallet_balances::types::AccountData<u128>,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8,
                    156u8, 12u8, 243u8, 14u8, 136u8, 134u8, 55u8, 29u8, 169u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 128u8,
                    ];
                    <types::frame_system::AccountInfo<
                        u32,
                        types::pallet_balances::types::AccountData<u128>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " The full account information for a particular account ID."]
            #[cfg(feature = "ink")]
            pub fn account(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                types::frame_system::AccountInfo<
                    u32,
                    types::pallet_balances::types::AccountData<u128>,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8,
                    156u8, 12u8, 243u8, 14u8, 136u8, 134u8, 55u8, 29u8, 169u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 128u8,
                    ];
                    <types::frame_system::AccountInfo<
                        u32,
                        types::pallet_balances::types::AccountData<u128>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Total extrinsics count for the current block."]
            #[cfg(not(feature = "ink"))]
            pub async fn extrinsic_count(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<u32>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 189u8, 192u8, 189u8, 48u8, 62u8, 152u8, 85u8, 129u8,
                    58u8, 168u8, 163u8, 13u8, 78u8, 252u8, 81u8, 18u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Total extrinsics count for the current block."]
            #[cfg(feature = "ink")]
            pub fn extrinsic_count(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 189u8, 192u8, 189u8, 48u8, 62u8, 152u8, 85u8, 129u8,
                    58u8, 168u8, 163u8, 13u8, 78u8, 252u8, 81u8, 18u8,
                ])?;
                Ok(value)
            }
            #[doc = " Whether all inherents have been applied."]
            #[cfg(not(feature = "ink"))]
            pub async fn inherents_applied(&self) -> ::polymesh_api_client::error::Result<bool> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 21u8, 106u8, 254u8, 37u8, 50u8, 60u8, 112u8, 228u8,
                    62u8, 183u8, 34u8, 237u8, 124u8, 136u8, 98u8, 151u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Whether all inherents have been applied."]
            #[cfg(feature = "ink")]
            pub fn inherents_applied(&self) -> ::polymesh_api_ink::error::Result<bool> {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 21u8, 106u8, 254u8, 37u8, 50u8, 60u8, 112u8, 228u8,
                    62u8, 183u8, 34u8, 237u8, 124u8, 136u8, 98u8, 151u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The current weight for the block."]
            #[cfg(not(feature = "ink"))]
            pub async fn block_weight(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::frame_support::dispatch::PerDispatchClass<
                    ::polymesh_api_client::sp_weights::Weight,
                >,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 52u8, 171u8, 245u8, 203u8, 52u8, 214u8, 36u8, 67u8,
                    120u8, 205u8, 219u8, 241u8, 142u8, 132u8, 157u8, 150u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::frame_support::dispatch::PerDispatchClass<
                        ::polymesh_api_client::sp_weights::Weight,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " The current weight for the block."]
            #[cfg(feature = "ink")]
            pub fn block_weight(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                types::frame_support::dispatch::PerDispatchClass<
                    ::polymesh_api_client::sp_weights::Weight,
                >,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 52u8, 171u8, 245u8, 203u8, 52u8, 214u8, 36u8, 67u8,
                    120u8, 205u8, 219u8, 241u8, 142u8, 132u8, 157u8, 150u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::frame_support::dispatch::PerDispatchClass<
                        ::polymesh_api_client::sp_weights::Weight,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Total length (in bytes) for all extrinsics put together, for the current block."]
            #[cfg(not(feature = "ink"))]
            pub async fn all_extrinsics_len(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<u32>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 168u8, 109u8, 165u8, 169u8, 50u8, 104u8, 79u8, 25u8,
                    149u8, 57u8, 131u8, 111u8, 203u8, 140u8, 136u8, 111u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Total length (in bytes) for all extrinsics put together, for the current block."]
            #[cfg(feature = "ink")]
            pub fn all_extrinsics_len(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 168u8, 109u8, 165u8, 169u8, 50u8, 104u8, 79u8, 25u8,
                    149u8, 57u8, 131u8, 111u8, 203u8, 140u8, 136u8, 111u8,
                ])?;
                Ok(value)
            }
            #[doc = " Map of block numbers to block hashes."]
            #[cfg(not(feature = "ink"))]
            pub async fn block_hash(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<types::primitive_types::H256> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 164u8, 71u8, 4u8, 181u8, 104u8, 210u8, 22u8, 103u8,
                    53u8, 106u8, 90u8, 5u8, 12u8, 17u8, 135u8, 70u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Map of block numbers to block hashes."]
            #[cfg(feature = "ink")]
            pub fn block_hash(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<types::primitive_types::H256> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 164u8, 71u8, 4u8, 181u8, 104u8, 210u8, 22u8, 103u8,
                    53u8, 106u8, 90u8, 5u8, 12u8, 17u8, 135u8, 70u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."]
            #[cfg(not(feature = "ink"))]
            pub async fn extrinsic_data(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u8>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 223u8, 29u8, 174u8, 184u8, 152u8, 104u8, 55u8,
                    242u8, 28u8, 197u8, 209u8, 117u8, 150u8, 187u8, 120u8, 209u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."]
            #[cfg(feature = "ink")]
            pub fn extrinsic_data(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u8>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 223u8, 29u8, 174u8, 184u8, 152u8, 104u8, 55u8,
                    242u8, 28u8, 197u8, 209u8, 117u8, 150u8, 187u8, 120u8, 209u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The current block number being processed. Set by `execute_block`."]
            #[cfg(not(feature = "ink"))]
            pub async fn number(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 2u8, 165u8, 193u8, 177u8, 154u8, 183u8, 160u8, 79u8,
                    83u8, 108u8, 81u8, 154u8, 202u8, 73u8, 131u8, 172u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The current block number being processed. Set by `execute_block`."]
            #[cfg(feature = "ink")]
            pub fn number(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 2u8, 165u8, 193u8, 177u8, 154u8, 183u8, 160u8, 79u8,
                    83u8, 108u8, 81u8, 154u8, 202u8, 73u8, 131u8, 172u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Hash of the previous block."]
            #[cfg(not(feature = "ink"))]
            pub async fn parent_hash(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::primitive_types::H256> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 138u8, 66u8, 243u8, 51u8, 35u8, 203u8, 92u8, 237u8,
                    59u8, 68u8, 221u8, 130u8, 95u8, 218u8, 159u8, 204u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Hash of the previous block."]
            #[cfg(feature = "ink")]
            pub fn parent_hash(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::primitive_types::H256> {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 138u8, 66u8, 243u8, 51u8, 35u8, 203u8, 92u8, 237u8,
                    59u8, 68u8, 221u8, 130u8, 95u8, 218u8, 159u8, 204u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Digest of the current block, also part of the block header."]
            #[cfg(not(feature = "ink"))]
            pub async fn digest(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::sp_runtime::generic::digest::Digest>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 153u8, 231u8, 249u8, 63u8, 198u8, 169u8, 143u8, 8u8,
                    116u8, 253u8, 5u8, 127u8, 17u8, 28u8, 77u8, 45u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::sp_runtime::generic::digest::Digest>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Digest of the current block, also part of the block header."]
            #[cfg(feature = "ink")]
            pub fn digest(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::sp_runtime::generic::digest::Digest>
            {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 153u8, 231u8, 249u8, 63u8, 198u8, 169u8, 143u8, 8u8,
                    116u8, 253u8, 5u8, 127u8, 17u8, 28u8, 77u8, 45u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::sp_runtime::generic::digest::Digest>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Events deposited for the current block."]
            #[doc = ""]
            #[doc = " NOTE: The item is unbound and should therefore never be read on chain."]
            #[doc = " It could otherwise inflate the PoV size of a block."]
            #[doc = ""]
            #[doc = " Events have a large in-memory size. Box the events to not go out-of-memory"]
            #[doc = " just in case someone still reads them from within the runtime."]
            #[cfg(not(feature = "ink"))]
            pub async fn events(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 128u8, 212u8, 30u8, 94u8, 22u8, 5u8, 103u8, 101u8,
                    188u8, 132u8, 97u8, 133u8, 16u8, 114u8, 201u8, 215u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        ::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Events deposited for the current block."]
            #[doc = ""]
            #[doc = " NOTE: The item is unbound and should therefore never be read on chain."]
            #[doc = " It could otherwise inflate the PoV size of a block."]
            #[doc = ""]
            #[doc = " Events have a large in-memory size. Box the events to not go out-of-memory"]
            #[doc = " just in case someone still reads them from within the runtime."]
            #[cfg(feature = "ink")]
            pub fn events(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 128u8, 212u8, 30u8, 94u8, 22u8, 5u8, 103u8, 101u8,
                    188u8, 132u8, 97u8, 133u8, 16u8, 114u8, 201u8, 215u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        ::polymesh_api_client::EventRecord<types::runtime::RuntimeEvent>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " The number of events in the `Events<T>` list."]
            #[cfg(not(feature = "ink"))]
            pub async fn event_count(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 10u8, 152u8, 253u8, 190u8, 156u8, 230u8, 197u8,
                    88u8, 55u8, 87u8, 108u8, 96u8, 199u8, 175u8, 56u8, 80u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The number of events in the `Events<T>` list."]
            #[cfg(feature = "ink")]
            pub fn event_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 10u8, 152u8, 253u8, 190u8, 156u8, 230u8, 197u8,
                    88u8, 55u8, 87u8, 108u8, 96u8, 199u8, 175u8, 56u8, 80u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"]
            #[doc = " of events in the `<Events<T>>` list."]
            #[doc = ""]
            #[doc = " All topic vectors have deterministic storage locations depending on the topic. This"]
            #[doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"]
            #[doc = " in case of changes fetch the list of events of interest."]
            #[doc = ""]
            #[doc = " The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just"]
            #[doc = " the `EventIndex` then in case if the topic has the same contents on the next block"]
            #[doc = " no notification will be triggered thus the event might be lost."]
            #[cfg(not(feature = "ink"))]
            pub async fn event_topics(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<(u32, u32)>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 187u8, 148u8, 225u8, 194u8, 26u8, 218u8, 183u8,
                    20u8, 152u8, 60u8, 240u8, 102u8, 34u8, 225u8, 222u8, 118u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"]
            #[doc = " of events in the `<Events<T>>` list."]
            #[doc = ""]
            #[doc = " All topic vectors have deterministic storage locations depending on the topic. This"]
            #[doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"]
            #[doc = " in case of changes fetch the list of events of interest."]
            #[doc = ""]
            #[doc = " The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just"]
            #[doc = " the `EventIndex` then in case if the topic has the same contents on the next block"]
            #[doc = " no notification will be triggered thus the event might be lost."]
            #[cfg(feature = "ink")]
            pub fn event_topics(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<(u32, u32)>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 187u8, 148u8, 225u8, 194u8, 26u8, 218u8, 183u8,
                    20u8, 152u8, 60u8, 240u8, 102u8, 34u8, 225u8, 222u8, 118u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."]
            #[cfg(not(feature = "ink"))]
            pub async fn last_runtime_upgrade(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::frame_system::LastRuntimeUpgradeInfo>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 249u8, 204u8, 233u8, 200u8, 136u8, 70u8, 155u8,
                    177u8, 160u8, 220u8, 234u8, 161u8, 41u8, 103u8, 46u8, 248u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."]
            #[cfg(feature = "ink")]
            pub fn last_runtime_upgrade(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::frame_system::LastRuntimeUpgradeInfo>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 249u8, 204u8, 233u8, 200u8, 136u8, 70u8, 155u8,
                    177u8, 160u8, 220u8, 234u8, 161u8, 41u8, 103u8, 46u8, 248u8,
                ])?;
                Ok(value)
            }
            #[doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."]
            #[cfg(not(feature = "ink"))]
            pub async fn upgraded_to_u32_ref_count(
                &self,
            ) -> ::polymesh_api_client::error::Result<bool> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 86u8, 132u8, 160u8, 34u8, 163u8, 77u8, 216u8, 191u8,
                    162u8, 186u8, 175u8, 68u8, 241u8, 114u8, 183u8, 16u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."]
            #[cfg(feature = "ink")]
            pub fn upgraded_to_u32_ref_count(&self) -> ::polymesh_api_ink::error::Result<bool> {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 86u8, 132u8, 160u8, 34u8, 163u8, 77u8, 216u8, 191u8,
                    162u8, 186u8, 175u8, 68u8, 241u8, 114u8, 183u8, 16u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"]
            #[doc = " (default) if not."]
            #[cfg(not(feature = "ink"))]
            pub async fn upgraded_to_triple_ref_count(
                &self,
            ) -> ::polymesh_api_client::error::Result<bool> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 167u8, 253u8, 108u8, 40u8, 131u8, 107u8, 154u8,
                    40u8, 82u8, 45u8, 201u8, 36u8, 17u8, 12u8, 244u8, 57u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False"]
            #[doc = " (default) if not."]
            #[cfg(feature = "ink")]
            pub fn upgraded_to_triple_ref_count(&self) -> ::polymesh_api_ink::error::Result<bool> {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 167u8, 253u8, 108u8, 40u8, 131u8, 107u8, 154u8,
                    40u8, 82u8, 45u8, 201u8, 36u8, 17u8, 12u8, 244u8, 57u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The execution phase of the block."]
            #[cfg(not(feature = "ink"))]
            pub async fn execution_phase(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<types::frame_system::Phase>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 255u8, 85u8, 59u8, 90u8, 152u8, 98u8, 165u8, 22u8,
                    147u8, 157u8, 130u8, 179u8, 211u8, 216u8, 102u8, 26u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The execution phase of the block."]
            #[cfg(feature = "ink")]
            pub fn execution_phase(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<types::frame_system::Phase>> {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 255u8, 85u8, 59u8, 90u8, 152u8, 98u8, 165u8, 22u8,
                    147u8, 157u8, 130u8, 179u8, 211u8, 216u8, 102u8, 26u8,
                ])?;
                Ok(value)
            }
            #[doc = " `Some` if a code upgrade has been authorized."]
            #[cfg(not(feature = "ink"))]
            pub async fn authorized_upgrade(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::frame_system::CodeUpgradeAuthorization>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 47u8, 169u8, 241u8, 191u8, 37u8, 86u8, 120u8, 8u8,
                    119u8, 27u8, 255u8, 9u8, 29u8, 200u8, 158u8, 205u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " `Some` if a code upgrade has been authorized."]
            #[cfg(feature = "ink")]
            pub fn authorized_upgrade(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::frame_system::CodeUpgradeAuthorization>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 47u8, 169u8, 241u8, 191u8, 37u8, 86u8, 120u8, 8u8,
                    119u8, 27u8, 255u8, 9u8, 29u8, 200u8, 158u8, 205u8,
                ])?;
                Ok(value)
            }
            #[doc = " The weight reclaimed for the extrinsic."]
            #[doc = ""]
            #[doc = " This information is available until the end of the extrinsic execution."]
            #[doc = " More precisely this information is removed in `note_applied_extrinsic`."]
            #[doc = ""]
            #[doc = " Logic doing some post dispatch weight reduction must update this storage to avoid duplicate"]
            #[doc = " reduction."]
            #[cfg(not(feature = "ink"))]
            pub async fn extrinsic_weight_reclaimed(
                &self,
            ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::sp_weights::Weight>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 12u8, 207u8, 5u8, 87u8, 67u8, 115u8, 139u8, 122u8,
                    145u8, 166u8, 251u8, 136u8, 236u8, 227u8, 60u8, 172u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8];
                    <::polymesh_api_client::sp_weights::Weight>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The weight reclaimed for the extrinsic."]
            #[doc = ""]
            #[doc = " This information is available until the end of the extrinsic execution."]
            #[doc = " More precisely this information is removed in `note_applied_extrinsic`."]
            #[doc = ""]
            #[doc = " Logic doing some post dispatch weight reduction must update this storage to avoid duplicate"]
            #[doc = " reduction."]
            #[cfg(feature = "ink")]
            pub fn extrinsic_weight_reclaimed(
                &self,
            ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::sp_weights::Weight>
            {
                let value = self.api.read_storage(::alloc::vec![
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 12u8, 207u8, 5u8, 87u8, 67u8, 115u8, 139u8, 122u8,
                    145u8, 166u8, 251u8, 136u8, 236u8, 227u8, 60u8, 172u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8];
                    <::polymesh_api_client::sp_weights::Weight>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct SystemPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> SystemPagedQueryApi<'api> {
            #[doc = " The full account information for a particular account ID."]
            pub fn account(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::frame_system::AccountInfo<
                    u32,
                    types::pallet_balances::types::AccountData<u128>,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8,
                    156u8, 12u8, 243u8, 14u8, 136u8, 134u8, 55u8, 29u8, 169u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Map of block numbers to block hashes."]
            pub fn block_hash(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<u32, types::primitive_types::H256>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 164u8, 71u8, 4u8, 181u8, 104u8, 210u8, 22u8, 103u8,
                    53u8, 106u8, 90u8, 5u8, 12u8, 17u8, 135u8, 70u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Extrinsics data for the current block (maps an extrinsic's index to its data)."]
            pub fn extrinsic_data(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<u32, ::alloc::vec::Vec<u8>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 223u8, 29u8, 174u8, 184u8, 152u8, 104u8, 55u8,
                    242u8, 28u8, 197u8, 209u8, 117u8, 150u8, 187u8, 120u8, 209u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Mapping between a topic (represented by T::Hash) and a vector of indexes"]
            #[doc = " of events in the `<Events<T>>` list."]
            #[doc = ""]
            #[doc = " All topic vectors have deterministic storage locations depending on the topic. This"]
            #[doc = " allows light-clients to leverage the changes trie storage tracking mechanism and"]
            #[doc = " in case of changes fetch the list of events of interest."]
            #[doc = ""]
            #[doc = " The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just"]
            #[doc = " the `EventIndex` then in case if the topic has the same contents on the next block"]
            #[doc = " no notification will be triggered thus the event might be lost."]
            pub fn event_topics(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                ::alloc::vec::Vec<(u32, u32)>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    38u8, 170u8, 57u8, 78u8, 234u8, 86u8, 48u8, 224u8, 124u8, 72u8, 174u8, 12u8,
                    149u8, 88u8, 206u8, 247u8, 187u8, 148u8, 225u8, 194u8, 26u8, 218u8, 183u8,
                    20u8, 152u8, 60u8, 240u8, 102u8, 34u8, 225u8, 222u8, 118u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
        }
    }
    pub mod babe {
        use super::*;
        #[derive(Clone)]
        pub struct BabeCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> BabeCallApi<'api> {
            #[doc = "Report authority equivocation/misbehavior. This method will verify"]
            #[doc = "the equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence will"]
            #[doc = "be reported."]
            #[cfg(not(feature = "ink"))]
            pub fn report_equivocation(
                &self,
                equivocation_proof: types::sp_consensus_slots::EquivocationProof<
                    types::sp_runtime::generic::header::Header<u32>,
                    types::sp_consensus_babe::app::Public,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Babe(
                    types::pallet_babe::pallet::BabeCall::report_equivocation {
                        equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
                        key_owner_proof,
                    },
                ))
            }
            #[doc = "Report authority equivocation/misbehavior. This method will verify"]
            #[doc = "the equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence will"]
            #[doc = "be reported."]
            #[cfg(feature = "ink")]
            pub fn report_equivocation(
                &self,
                equivocation_proof: types::sp_consensus_slots::EquivocationProof<
                    types::sp_runtime::generic::header::Header<u32>,
                    types::sp_consensus_babe::app::Public,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![1u8, 0u8];
                equivocation_proof.encode_to(&mut buf);
                key_owner_proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Report authority equivocation/misbehavior. This method will verify"]
            #[doc = "the equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence will"]
            #[doc = "be reported."]
            #[doc = "This extrinsic must be called unsigned and it is expected that only"]
            #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
            #[doc = "if the block author is defined it will be defined as the equivocation"]
            #[doc = "reporter."]
            #[cfg(not(feature = "ink"))]
            pub fn report_equivocation_unsigned(
                &self,
                equivocation_proof: types::sp_consensus_slots::EquivocationProof<
                    types::sp_runtime::generic::header::Header<u32>,
                    types::sp_consensus_babe::app::Public,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Babe(
                    types::pallet_babe::pallet::BabeCall::report_equivocation_unsigned {
                        equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
                        key_owner_proof,
                    },
                ))
            }
            #[doc = "Report authority equivocation/misbehavior. This method will verify"]
            #[doc = "the equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence will"]
            #[doc = "be reported."]
            #[doc = "This extrinsic must be called unsigned and it is expected that only"]
            #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
            #[doc = "if the block author is defined it will be defined as the equivocation"]
            #[doc = "reporter."]
            #[cfg(feature = "ink")]
            pub fn report_equivocation_unsigned(
                &self,
                equivocation_proof: types::sp_consensus_slots::EquivocationProof<
                    types::sp_runtime::generic::header::Header<u32>,
                    types::sp_consensus_babe::app::Public,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![1u8, 1u8];
                equivocation_proof.encode_to(&mut buf);
                key_owner_proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"]
            #[doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."]
            #[doc = "Multiple calls to this method will replace any existing planned config change that had"]
            #[doc = "not been enacted yet."]
            #[cfg(not(feature = "ink"))]
            pub fn plan_config_change(
                &self,
                config: types::sp_consensus_babe::digests::NextConfigDescriptor,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Babe(
                    types::pallet_babe::pallet::BabeCall::plan_config_change { config },
                ))
            }
            #[doc = "Plan an epoch config change. The epoch config change is recorded and will be enacted on"]
            #[doc = "the next call to `enact_epoch_change`. The config will be activated one epoch after."]
            #[doc = "Multiple calls to this method will replace any existing planned config change that had"]
            #[doc = "not been enacted yet."]
            #[cfg(feature = "ink")]
            pub fn plan_config_change(
                &self,
                config: types::sp_consensus_babe::digests::NextConfigDescriptor,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![1u8, 2u8];
                config.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for BabeCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct BabeQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> BabeQueryApi<'api> {
            #[doc = " Current epoch index."]
            #[cfg(not(feature = "ink"))]
            pub async fn epoch_index(&self) -> ::polymesh_api_client::error::Result<u64> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 56u8, 49u8, 108u8, 191u8, 143u8, 160u8, 218u8, 130u8,
                    42u8, 32u8, 172u8, 28u8, 85u8, 191u8, 27u8, 227u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Current epoch index."]
            #[cfg(feature = "ink")]
            pub fn epoch_index(&self) -> ::polymesh_api_ink::error::Result<u64> {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 56u8, 49u8, 108u8, 191u8, 143u8, 160u8, 218u8, 130u8,
                    42u8, 32u8, 172u8, 28u8, 85u8, 191u8, 27u8, 227u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Current epoch authorities."]
            #[cfg(not(feature = "ink"))]
            pub async fn authorities(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 94u8, 6u8, 33u8, 196u8, 134u8, 154u8, 166u8, 12u8,
                    2u8, 190u8, 154u8, 220u8, 201u8, 138u8, 13u8, 29u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Current epoch authorities."]
            #[cfg(feature = "ink")]
            pub fn authorities(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 94u8, 6u8, 33u8, 196u8, 134u8, 154u8, 166u8, 12u8,
                    2u8, 190u8, 154u8, 220u8, 201u8, 138u8, 13u8, 29u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The slot at which the first epoch actually started. This is 0"]
            #[doc = " until the first block of the chain."]
            #[cfg(not(feature = "ink"))]
            pub async fn genesis_slot(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::sp_consensus_slots::Slot> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 103u8, 135u8, 17u8, 209u8, 94u8, 187u8, 206u8, 186u8,
                    92u8, 208u8, 206u8, 161u8, 88u8, 230u8, 103u8, 90u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The slot at which the first epoch actually started. This is 0"]
            #[doc = " until the first block of the chain."]
            #[cfg(feature = "ink")]
            pub fn genesis_slot(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::sp_consensus_slots::Slot> {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 103u8, 135u8, 17u8, 209u8, 94u8, 187u8, 206u8, 186u8,
                    92u8, 208u8, 206u8, 161u8, 88u8, 230u8, 103u8, 90u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Current slot number."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_slot(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::sp_consensus_slots::Slot> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 6u8, 21u8, 91u8, 60u8, 217u8, 168u8, 201u8, 229u8,
                    233u8, 162u8, 63u8, 213u8, 220u8, 19u8, 165u8, 237u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Current slot number."]
            #[cfg(feature = "ink")]
            pub fn current_slot(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::sp_consensus_slots::Slot> {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 6u8, 21u8, 91u8, 60u8, 217u8, 168u8, 201u8, 229u8,
                    233u8, 162u8, 63u8, 213u8, 220u8, 19u8, 165u8, 237u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::sp_consensus_slots::Slot>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The epoch randomness for the *current* epoch."]
            #[doc = ""]
            #[doc = " # Security"]
            #[doc = ""]
            #[doc = " This MUST NOT be used for gambling, as it can be influenced by a"]
            #[doc = " malicious validator in the short term. It MAY be used in many"]
            #[doc = " cryptographic protocols, however, so long as one remembers that this"]
            #[doc = " (like everything else on-chain) it is public. For example, it can be"]
            #[doc = " used where a number is needed that cannot have been chosen by an"]
            #[doc = " adversary, for purposes such as public-coin zero-knowledge proofs."]
            #[cfg(not(feature = "ink"))]
            pub async fn randomness(&self) -> ::polymesh_api_client::error::Result<[u8; 32usize]> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 122u8, 65u8, 76u8, 176u8, 8u8, 224u8, 230u8, 30u8,
                    70u8, 114u8, 42u8, 166u8, 10u8, 189u8, 214u8, 114u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The epoch randomness for the *current* epoch."]
            #[doc = ""]
            #[doc = " # Security"]
            #[doc = ""]
            #[doc = " This MUST NOT be used for gambling, as it can be influenced by a"]
            #[doc = " malicious validator in the short term. It MAY be used in many"]
            #[doc = " cryptographic protocols, however, so long as one remembers that this"]
            #[doc = " (like everything else on-chain) it is public. For example, it can be"]
            #[doc = " used where a number is needed that cannot have been chosen by an"]
            #[doc = " adversary, for purposes such as public-coin zero-knowledge proofs."]
            #[cfg(feature = "ink")]
            pub fn randomness(&self) -> ::polymesh_api_ink::error::Result<[u8; 32usize]> {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 122u8, 65u8, 76u8, 176u8, 8u8, 224u8, 230u8, 30u8,
                    70u8, 114u8, 42u8, 166u8, 10u8, 189u8, 214u8, 114u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Pending epoch configuration change that will be applied when the next epoch is enacted."]
            #[cfg(not(feature = "ink"))]
            pub async fn pending_epoch_config_change(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::sp_consensus_babe::digests::NextConfigDescriptor>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 139u8, 67u8, 40u8, 227u8, 67u8, 195u8, 224u8, 172u8,
                    144u8, 248u8, 61u8, 164u8, 134u8, 12u8, 190u8, 54u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Pending epoch configuration change that will be applied when the next epoch is enacted."]
            #[cfg(feature = "ink")]
            pub fn pending_epoch_config_change(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::sp_consensus_babe::digests::NextConfigDescriptor>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 139u8, 67u8, 40u8, 227u8, 67u8, 195u8, 224u8, 172u8,
                    144u8, 248u8, 61u8, 164u8, 134u8, 12u8, 190u8, 54u8,
                ])?;
                Ok(value)
            }
            #[doc = " Next epoch randomness."]
            #[cfg(not(feature = "ink"))]
            pub async fn next_randomness(
                &self,
            ) -> ::polymesh_api_client::error::Result<[u8; 32usize]> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 124u8, 230u8, 120u8, 121u8, 157u8, 62u8, 255u8, 2u8,
                    66u8, 83u8, 185u8, 14u8, 132u8, 146u8, 124u8, 198u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Next epoch randomness."]
            #[cfg(feature = "ink")]
            pub fn next_randomness(&self) -> ::polymesh_api_ink::error::Result<[u8; 32usize]> {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 124u8, 230u8, 120u8, 121u8, 157u8, 62u8, 255u8, 2u8,
                    66u8, 83u8, 185u8, 14u8, 132u8, 146u8, 124u8, 198u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <[u8; 32usize]>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Next epoch authorities."]
            #[cfg(not(feature = "ink"))]
            pub async fn next_authorities(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 170u8, 207u8, 0u8, 185u8, 180u8, 31u8, 218u8, 122u8,
                    146u8, 104u8, 130u8, 28u8, 42u8, 43u8, 62u8, 76u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Next epoch authorities."]
            #[cfg(feature = "ink")]
            pub fn next_authorities(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 170u8, 207u8, 0u8, 185u8, 180u8, 31u8, 218u8, 122u8,
                    146u8, 104u8, 130u8, 28u8, 42u8, 43u8, 62u8, 76u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(types::sp_consensus_babe::app::Public, u64)>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Randomness under construction."]
            #[doc = ""]
            #[doc = " We make a trade-off between storage accesses and list length."]
            #[doc = " We store the under-construction randomness in segments of up to"]
            #[doc = " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`."]
            #[doc = ""]
            #[doc = " Once a segment reaches this length, we begin the next one."]
            #[doc = " We reset all segments and return to `0` at the beginning of every"]
            #[doc = " epoch."]
            #[cfg(not(feature = "ink"))]
            pub async fn segment_index(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 102u8, 232u8, 240u8, 53u8, 200u8, 173u8, 190u8, 127u8,
                    21u8, 71u8, 180u8, 60u8, 81u8, 230u8, 248u8, 164u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Randomness under construction."]
            #[doc = ""]
            #[doc = " We make a trade-off between storage accesses and list length."]
            #[doc = " We store the under-construction randomness in segments of up to"]
            #[doc = " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`."]
            #[doc = ""]
            #[doc = " Once a segment reaches this length, we begin the next one."]
            #[doc = " We reset all segments and return to `0` at the beginning of every"]
            #[doc = " epoch."]
            #[cfg(feature = "ink")]
            pub fn segment_index(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 102u8, 232u8, 240u8, 53u8, 200u8, 173u8, 190u8, 127u8,
                    21u8, 71u8, 180u8, 60u8, 81u8, 230u8, 248u8, 164u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."]
            #[cfg(not(feature = "ink"))]
            pub async fn under_construction(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<[u8; 32usize]>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 185u8, 9u8, 54u8, 89u8, 215u8, 168u8, 86u8, 128u8,
                    151u8, 87u8, 19u8, 77u8, 43u8, 200u8, 110u8, 98u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<[u8; 32usize]>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."]
            #[cfg(feature = "ink")]
            pub fn under_construction(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<[u8; 32usize]>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 185u8, 9u8, 54u8, 89u8, 215u8, 168u8, 86u8, 128u8,
                    151u8, 87u8, 19u8, 77u8, 43u8, 200u8, 110u8, 98u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<[u8; 32usize]>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Temporary value (cleared at block finalization) which is `Some`"]
            #[doc = " if per-block initialization has already been called for current block."]
            #[cfg(not(feature = "ink"))]
            pub async fn initialized(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<Option<types::sp_consensus_babe::digests::PreDigest>>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 250u8, 146u8, 222u8, 145u8, 10u8, 124u8, 226u8, 189u8,
                    88u8, 233u8, 151u8, 41u8, 198u8, 151u8, 39u8, 193u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Temporary value (cleared at block finalization) which is `Some`"]
            #[doc = " if per-block initialization has already been called for current block."]
            #[cfg(feature = "ink")]
            pub fn initialized(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<Option<types::sp_consensus_babe::digests::PreDigest>>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 250u8, 146u8, 222u8, 145u8, 10u8, 124u8, 226u8, 189u8,
                    88u8, 233u8, 151u8, 41u8, 198u8, 151u8, 39u8, 193u8,
                ])?;
                Ok(value)
            }
            #[doc = " This field should always be populated during block processing unless"]
            #[doc = " secondary plain slots are enabled (which don't contain a VRF output)."]
            #[doc = ""]
            #[doc = " It is set in `on_finalize`, before it will contain the value from the last block."]
            #[cfg(not(feature = "ink"))]
            pub async fn author_vrf_randomness(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<[u8; 32usize]>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 208u8, 119u8, 223u8, 219u8, 138u8, 219u8, 16u8, 247u8,
                    143u8, 16u8, 165u8, 223u8, 135u8, 66u8, 197u8, 69u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <Option<[u8; 32usize]>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " This field should always be populated during block processing unless"]
            #[doc = " secondary plain slots are enabled (which don't contain a VRF output)."]
            #[doc = ""]
            #[doc = " It is set in `on_finalize`, before it will contain the value from the last block."]
            #[cfg(feature = "ink")]
            pub fn author_vrf_randomness(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<[u8; 32usize]>> {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 208u8, 119u8, 223u8, 219u8, 138u8, 219u8, 16u8, 247u8,
                    143u8, 16u8, 165u8, 223u8, 135u8, 66u8, 197u8, 69u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <Option<[u8; 32usize]>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The block numbers when the last and current epoch have started, respectively `N-1` and"]
            #[doc = " `N`."]
            #[doc = " NOTE: We track this is in order to annotate the block number when a given pool of"]
            #[doc = " entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in"]
            #[doc = " slots, which may be skipped, the block numbers may not line up with the slot numbers."]
            #[cfg(not(feature = "ink"))]
            pub async fn epoch_start(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 233u8, 14u8, 47u8, 191u8, 45u8, 121u8, 44u8, 179u8,
                    36u8, 191u8, 250u8, 148u8, 39u8, 254u8, 31u8, 14u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The block numbers when the last and current epoch have started, respectively `N-1` and"]
            #[doc = " `N`."]
            #[doc = " NOTE: We track this is in order to annotate the block number when a given pool of"]
            #[doc = " entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in"]
            #[doc = " slots, which may be skipped, the block numbers may not line up with the slot numbers."]
            #[cfg(feature = "ink")]
            pub fn epoch_start(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 233u8, 14u8, 47u8, 191u8, 45u8, 121u8, 44u8, 179u8,
                    36u8, 191u8, 250u8, 148u8, 39u8, 254u8, 31u8, 14u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " How late the current block is compared to its parent."]
            #[doc = ""]
            #[doc = " This entry is populated as part of block execution and is cleaned up"]
            #[doc = " on block finalization. Querying this storage entry outside of block"]
            #[doc = " execution context should always yield zero."]
            #[cfg(not(feature = "ink"))]
            pub async fn lateness(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 3u8, 35u8, 71u8, 86u8, 87u8, 224u8, 137u8, 15u8,
                    189u8, 191u8, 102u8, 251u8, 36u8, 180u8, 100u8, 158u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " How late the current block is compared to its parent."]
            #[doc = ""]
            #[doc = " This entry is populated as part of block execution and is cleaned up"]
            #[doc = " on block finalization. Querying this storage entry outside of block"]
            #[doc = " execution context should always yield zero."]
            #[cfg(feature = "ink")]
            pub fn lateness(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 3u8, 35u8, 71u8, 86u8, 87u8, 224u8, 137u8, 15u8,
                    189u8, 191u8, 102u8, 251u8, 36u8, 180u8, 100u8, 158u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The configuration for the current epoch. Should never be `None` as it is initialized in"]
            #[doc = " genesis."]
            #[cfg(not(feature = "ink"))]
            pub async fn epoch_config(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::sp_consensus_babe::BabeEpochConfiguration>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 220u8, 107u8, 23u8, 27u8, 119u8, 48u8, 66u8, 99u8,
                    194u8, 146u8, 204u8, 62u8, 165u8, 237u8, 49u8, 239u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The configuration for the current epoch. Should never be `None` as it is initialized in"]
            #[doc = " genesis."]
            #[cfg(feature = "ink")]
            pub fn epoch_config(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::sp_consensus_babe::BabeEpochConfiguration>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 220u8, 107u8, 23u8, 27u8, 119u8, 48u8, 66u8, 99u8,
                    194u8, 146u8, 204u8, 62u8, 165u8, 237u8, 49u8, 239u8,
                ])?;
                Ok(value)
            }
            #[doc = " The configuration for the next epoch, `None` if the config will not change"]
            #[doc = " (you can fallback to `EpochConfig` instead in that case)."]
            #[cfg(not(feature = "ink"))]
            pub async fn next_epoch_config(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::sp_consensus_babe::BabeEpochConfiguration>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 154u8, 171u8, 10u8, 91u8, 99u8, 179u8, 89u8, 81u8,
                    45u8, 238u8, 229u8, 87u8, 201u8, 244u8, 207u8, 99u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The configuration for the next epoch, `None` if the config will not change"]
            #[doc = " (you can fallback to `EpochConfig` instead in that case)."]
            #[cfg(feature = "ink")]
            pub fn next_epoch_config(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::sp_consensus_babe::BabeEpochConfiguration>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 154u8, 171u8, 10u8, 91u8, 99u8, 179u8, 89u8, 81u8,
                    45u8, 238u8, 229u8, 87u8, 201u8, 244u8, 207u8, 99u8,
                ])?;
                Ok(value)
            }
            #[doc = " A list of the last 100 skipped epochs and the corresponding session index"]
            #[doc = " when the epoch was skipped."]
            #[doc = ""]
            #[doc = " This is only used for validating equivocation proofs. An equivocation proof"]
            #[doc = " must contains a key-ownership proof for a given session, therefore we need a"]
            #[doc = " way to tie together sessions and epoch indices, i.e. we need to validate that"]
            #[doc = " a validator was the owner of a given key on a given session, and what the"]
            #[doc = " active epoch index was during that session."]
            #[cfg(not(feature = "ink"))]
            pub async fn skipped_epochs(
                &self,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<(u64, u32)>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 55u8, 184u8, 132u8, 47u8, 84u8, 199u8, 237u8, 223u8,
                    2u8, 181u8, 229u8, 132u8, 170u8, 42u8, 230u8, 204u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(u64, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " A list of the last 100 skipped epochs and the corresponding session index"]
            #[doc = " when the epoch was skipped."]
            #[doc = ""]
            #[doc = " This is only used for validating equivocation proofs. An equivocation proof"]
            #[doc = " must contains a key-ownership proof for a given session, therefore we need a"]
            #[doc = " way to tie together sessions and epoch indices, i.e. we need to validate that"]
            #[doc = " a validator was the owner of a given key on a given session, and what the"]
            #[doc = " active epoch index was during that session."]
            #[cfg(feature = "ink")]
            pub fn skipped_epochs(
                &self,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<(u64, u32)>> {
                let value = self.api.read_storage(::alloc::vec![
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 55u8, 184u8, 132u8, 47u8, 84u8, 199u8, 237u8, 223u8,
                    2u8, 181u8, 229u8, 132u8, 170u8, 42u8, 230u8, 204u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(u64, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct BabePagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> BabePagedQueryApi<'api> {
            #[doc = " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."]
            pub fn under_construction(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<u32, ::alloc::vec::Vec<[u8; 32usize]>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    28u8, 182u8, 243u8, 110u8, 2u8, 122u8, 187u8, 32u8, 145u8, 207u8, 181u8, 17u8,
                    10u8, 181u8, 8u8, 127u8, 185u8, 9u8, 54u8, 89u8, 215u8, 168u8, 86u8, 128u8,
                    151u8, 87u8, 19u8, 77u8, 43u8, 200u8, 110u8, 98u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod timestamp {
        use super::*;
        #[derive(Clone)]
        pub struct TimestampCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> TimestampCallApi<'api> {
            #[doc = "Set the current time."]
            #[doc = ""]
            #[doc = "This call should be invoked exactly once per block. It will panic at the finalization"]
            #[doc = "phase, if this call hasn't been invoked by that time."]
            #[doc = ""]
            #[doc = "The timestamp should be greater than the previous one by the amount specified by"]
            #[doc = "[`Config::MinimumPeriod`]."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _None_."]
            #[doc = ""]
            #[doc = "This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware"]
            #[doc = "that changing the complexity of this call could result exhausting the resources in a"]
            #[doc = "block to execute any other calls."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"]
            #[doc = "- 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in"]
            #[doc = "  `on_finalize`)"]
            #[doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."]
            #[cfg(not(feature = "ink"))]
            pub fn set(
                &self,
                now: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Timestamp(
                    types::pallet_timestamp::pallet::TimestampCall::set { now },
                ))
            }
            #[doc = "Set the current time."]
            #[doc = ""]
            #[doc = "This call should be invoked exactly once per block. It will panic at the finalization"]
            #[doc = "phase, if this call hasn't been invoked by that time."]
            #[doc = ""]
            #[doc = "The timestamp should be greater than the previous one by the amount specified by"]
            #[doc = "[`Config::MinimumPeriod`]."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _None_."]
            #[doc = ""]
            #[doc = "This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware"]
            #[doc = "that changing the complexity of this call could result exhausting the resources in a"]
            #[doc = "block to execute any other calls."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)"]
            #[doc = "- 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in"]
            #[doc = "  `on_finalize`)"]
            #[doc = "- 1 event handler `on_timestamp_set`. Must be `O(1)`."]
            #[cfg(feature = "ink")]
            pub fn set(&self, now: u64) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![2u8, 0u8];
                now.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for TimestampCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct TimestampQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> TimestampQueryApi<'api> {
            #[doc = " The current time for the current block."]
            #[cfg(not(feature = "ink"))]
            pub async fn now(&self) -> ::polymesh_api_client::error::Result<u64> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8,
                    14u8, 122u8, 65u8, 19u8, 196u8, 159u8, 31u8, 5u8, 21u8, 244u8, 98u8, 205u8,
                    207u8, 132u8, 224u8, 241u8, 214u8, 4u8, 93u8, 252u8, 187u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The current time for the current block."]
            #[cfg(feature = "ink")]
            pub fn now(&self) -> ::polymesh_api_ink::error::Result<u64> {
                let value = self.api.read_storage(::alloc::vec![
                    240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8,
                    14u8, 122u8, 65u8, 19u8, 196u8, 159u8, 31u8, 5u8, 21u8, 244u8, 98u8, 205u8,
                    207u8, 132u8, 224u8, 241u8, 214u8, 4u8, 93u8, 252u8, 187u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Whether the timestamp has been updated in this block."]
            #[doc = ""]
            #[doc = " This value is updated to `true` upon successful submission of a timestamp by a node."]
            #[doc = " It is then checked at the end of each block execution in the `on_finalize` hook."]
            #[cfg(not(feature = "ink"))]
            pub async fn did_update(&self) -> ::polymesh_api_client::error::Result<bool> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8,
                    14u8, 122u8, 65u8, 19u8, 196u8, 187u8, 209u8, 8u8, 196u8, 137u8, 153u8, 100u8,
                    247u8, 7u8, 253u8, 175u8, 251u8, 130u8, 99u8, 96u8, 101u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Whether the timestamp has been updated in this block."]
            #[doc = ""]
            #[doc = " This value is updated to `true` upon successful submission of a timestamp by a node."]
            #[doc = " It is then checked at the end of each block execution in the `on_finalize` hook."]
            #[cfg(feature = "ink")]
            pub fn did_update(&self) -> ::polymesh_api_ink::error::Result<bool> {
                let value = self.api.read_storage(::alloc::vec![
                    240u8, 195u8, 101u8, 195u8, 207u8, 89u8, 214u8, 113u8, 235u8, 114u8, 218u8,
                    14u8, 122u8, 65u8, 19u8, 196u8, 187u8, 209u8, 8u8, 196u8, 137u8, 153u8, 100u8,
                    247u8, 7u8, 253u8, 175u8, 251u8, 130u8, 99u8, 96u8, 101u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct TimestampPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> TimestampPagedQueryApi<'api> {}
    }
    pub mod indices {
        use super::*;
        #[derive(Clone)]
        pub struct IndicesCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> IndicesCallApi<'api> {
            #[doc = "Assign an previously unassigned index."]
            #[doc = ""]
            #[doc = "Payment: `Deposit` is reserved from the sender account."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_."]
            #[doc = ""]
            #[doc = "- `index`: the index to be claimed. This must not be in use."]
            #[doc = ""]
            #[doc = "Emits `IndexAssigned` if successful."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`."]
            #[cfg(not(feature = "ink"))]
            pub fn claim(
                &self,
                index: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Indices(
                    types::pallet_indices::pallet::IndicesCall::claim { index },
                ))
            }
            #[doc = "Assign an previously unassigned index."]
            #[doc = ""]
            #[doc = "Payment: `Deposit` is reserved from the sender account."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_."]
            #[doc = ""]
            #[doc = "- `index`: the index to be claimed. This must not be in use."]
            #[doc = ""]
            #[doc = "Emits `IndexAssigned` if successful."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`."]
            #[cfg(feature = "ink")]
            pub fn claim(&self, index: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![3u8, 0u8];
                index.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Assign an index already owned by the sender to another account. The balance reservation"]
            #[doc = "is effectively transferred to the new account."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_."]
            #[doc = ""]
            #[doc = "- `index`: the index to be re-assigned. This must be owned by the sender."]
            #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
            #[doc = ""]
            #[doc = "Emits `IndexAssigned` if successful."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`."]
            #[cfg(not(feature = "ink"))]
            pub fn transfer(
                &self,
                new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                index: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Indices(
                    types::pallet_indices::pallet::IndicesCall::transfer { new, index },
                ))
            }
            #[doc = "Assign an index already owned by the sender to another account. The balance reservation"]
            #[doc = "is effectively transferred to the new account."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_."]
            #[doc = ""]
            #[doc = "- `index`: the index to be re-assigned. This must be owned by the sender."]
            #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
            #[doc = ""]
            #[doc = "Emits `IndexAssigned` if successful."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`."]
            #[cfg(feature = "ink")]
            pub fn transfer(
                &self,
                new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                index: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![3u8, 1u8];
                new.encode_to(&mut buf);
                index.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Free up an index owned by the sender."]
            #[doc = ""]
            #[doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."]
            #[doc = ""]
            #[doc = "- `index`: the index to be freed. This must be owned by the sender."]
            #[doc = ""]
            #[doc = "Emits `IndexFreed` if successful."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`."]
            #[cfg(not(feature = "ink"))]
            pub fn free(
                &self,
                index: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Indices(
                    types::pallet_indices::pallet::IndicesCall::free { index },
                ))
            }
            #[doc = "Free up an index owned by the sender."]
            #[doc = ""]
            #[doc = "Payment: Any previous deposit placed for the index is unreserved in the sender account."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ and the sender must own the index."]
            #[doc = ""]
            #[doc = "- `index`: the index to be freed. This must be owned by the sender."]
            #[doc = ""]
            #[doc = "Emits `IndexFreed` if successful."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`."]
            #[cfg(feature = "ink")]
            pub fn free(&self, index: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![3u8, 2u8];
                index.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Force an index to an account. This doesn't require a deposit. If the index is already"]
            #[doc = "held, then any deposit is reimbursed to its current owner."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Root_."]
            #[doc = ""]
            #[doc = "- `index`: the index to be (re-)assigned."]
            #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
            #[doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."]
            #[doc = ""]
            #[doc = "Emits `IndexAssigned` if successful."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`."]
            #[cfg(not(feature = "ink"))]
            pub fn force_transfer(
                &self,
                new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                index: u32,
                freeze: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Indices(
                    types::pallet_indices::pallet::IndicesCall::force_transfer {
                        new,
                        index,
                        freeze,
                    },
                ))
            }
            #[doc = "Force an index to an account. This doesn't require a deposit. If the index is already"]
            #[doc = "held, then any deposit is reimbursed to its current owner."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Root_."]
            #[doc = ""]
            #[doc = "- `index`: the index to be (re-)assigned."]
            #[doc = "- `new`: the new owner of the index. This function is a no-op if it is equal to sender."]
            #[doc = "- `freeze`: if set to `true`, will freeze the index so it cannot be transferred."]
            #[doc = ""]
            #[doc = "Emits `IndexAssigned` if successful."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`."]
            #[cfg(feature = "ink")]
            pub fn force_transfer(
                &self,
                new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                index: u32,
                freeze: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![3u8, 3u8];
                new.encode_to(&mut buf);
                index.encode_to(&mut buf);
                freeze.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Freeze an index so it will always point to the sender account. This consumes the"]
            #[doc = "deposit."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
            #[doc = "non-frozen account `index`."]
            #[doc = ""]
            #[doc = "- `index`: the index to be frozen in place."]
            #[doc = ""]
            #[doc = "Emits `IndexFrozen` if successful."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`."]
            #[cfg(not(feature = "ink"))]
            pub fn freeze(
                &self,
                index: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Indices(
                    types::pallet_indices::pallet::IndicesCall::freeze { index },
                ))
            }
            #[doc = "Freeze an index so it will always point to the sender account. This consumes the"]
            #[doc = "deposit."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
            #[doc = "non-frozen account `index`."]
            #[doc = ""]
            #[doc = "- `index`: the index to be frozen in place."]
            #[doc = ""]
            #[doc = "Emits `IndexFrozen` if successful."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`."]
            #[cfg(feature = "ink")]
            pub fn freeze(&self, index: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![3u8, 4u8];
                index.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Poke the deposit reserved for an index."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
            #[doc = "non-frozen account `index`."]
            #[doc = ""]
            #[doc = "The transaction fees is waived if the deposit is changed after poking/reconsideration."]
            #[doc = ""]
            #[doc = "- `index`: the index whose deposit is to be poked/reconsidered."]
            #[doc = ""]
            #[doc = "Emits `DepositPoked` if successful."]
            #[cfg(not(feature = "ink"))]
            pub fn poke_deposit(
                &self,
                index: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Indices(
                    types::pallet_indices::pallet::IndicesCall::poke_deposit { index },
                ))
            }
            #[doc = "Poke the deposit reserved for an index."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ and the signing account must have a"]
            #[doc = "non-frozen account `index`."]
            #[doc = ""]
            #[doc = "The transaction fees is waived if the deposit is changed after poking/reconsideration."]
            #[doc = ""]
            #[doc = "- `index`: the index whose deposit is to be poked/reconsidered."]
            #[doc = ""]
            #[doc = "Emits `DepositPoked` if successful."]
            #[cfg(feature = "ink")]
            pub fn poke_deposit(&self, index: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![3u8, 5u8];
                index.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for IndicesCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct IndicesQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> IndicesQueryApi<'api> {
            #[doc = " The lookup from index to account."]
            #[cfg(not(feature = "ink"))]
            pub async fn accounts(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<
                Option<(::polymesh_api_client::AccountId, u128, bool)>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    26u8, 115u8, 109u8, 55u8, 80u8, 76u8, 46u8, 63u8, 183u8, 61u8, 173u8, 22u8,
                    12u8, 85u8, 178u8, 145u8, 142u8, 231u8, 65u8, 138u8, 101u8, 49u8, 23u8, 61u8,
                    96u8, 209u8, 246u8, 168u8, 45u8, 143u8, 77u8, 81u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The lookup from index to account."]
            #[cfg(feature = "ink")]
            pub fn accounts(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<
                Option<(::polymesh_api_client::AccountId, u128, bool)>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    26u8, 115u8, 109u8, 55u8, 80u8, 76u8, 46u8, 63u8, 183u8, 61u8, 173u8, 22u8,
                    12u8, 85u8, 178u8, 145u8, 142u8, 231u8, 65u8, 138u8, 101u8, 49u8, 23u8, 61u8,
                    96u8, 209u8, 246u8, 168u8, 45u8, 143u8, 77u8, 81u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct IndicesPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> IndicesPagedQueryApi<'api> {
            #[doc = " The lookup from index to account."]
            pub fn accounts(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                u32,
                (::polymesh_api_client::AccountId, u128, bool),
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    26u8, 115u8, 109u8, 55u8, 80u8, 76u8, 46u8, 63u8, 183u8, 61u8, 173u8, 22u8,
                    12u8, 85u8, 178u8, 145u8, 142u8, 231u8, 65u8, 138u8, 101u8, 49u8, 23u8, 61u8,
                    96u8, 209u8, 246u8, 168u8, 45u8, 143u8, 77u8, 81u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
        }
    }
    pub mod authorship {
        use super::*;
        #[derive(Clone)]
        pub struct AuthorshipCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> AuthorshipCallApi<'api> {}
        impl<'api> From<&'api super::super::Api> for AuthorshipCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct AuthorshipQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> AuthorshipQueryApi<'api> {
            #[doc = " Author of current block."]
            #[cfg(not(feature = "ink"))]
            pub async fn author(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    213u8, 123u8, 206u8, 84u8, 95u8, 179u8, 130u8, 195u8, 69u8, 112u8, 229u8,
                    223u8, 191u8, 51u8, 143u8, 94u8, 50u8, 109u8, 33u8, 188u8, 103u8, 164u8, 179u8,
                    64u8, 35u8, 213u8, 119u8, 88u8, 93u8, 114u8, 191u8, 215u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Author of current block."]
            #[cfg(feature = "ink")]
            pub fn author(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    213u8, 123u8, 206u8, 84u8, 95u8, 179u8, 130u8, 195u8, 69u8, 112u8, 229u8,
                    223u8, 191u8, 51u8, 143u8, 94u8, 50u8, 109u8, 33u8, 188u8, 103u8, 164u8, 179u8,
                    64u8, 35u8, 213u8, 119u8, 88u8, 93u8, 114u8, 191u8, 215u8,
                ])?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct AuthorshipPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> AuthorshipPagedQueryApi<'api> {}
    }
    pub mod balances {
        use super::*;
        #[derive(Clone)]
        pub struct BalancesCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> BalancesCallApi<'api> {
            #[doc = "Transfer some liquid free balance to another account."]
            #[doc = ""]
            #[doc = "`transfer_allow_death` will set the `FreeBalance` of the sender and receiver."]
            #[doc = "If the sender's account is below the existential deposit as a result"]
            #[doc = "of the transfer, the account will be reaped."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
            #[cfg(not(feature = "ink"))]
            pub fn transfer_allow_death(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Balances(
                    types::pallet_balances::pallet::BalancesCall::transfer_allow_death {
                        dest,
                        value,
                    },
                ))
            }
            #[doc = "Transfer some liquid free balance to another account."]
            #[doc = ""]
            #[doc = "`transfer_allow_death` will set the `FreeBalance` of the sender and receiver."]
            #[doc = "If the sender's account is below the existential deposit as a result"]
            #[doc = "of the transfer, the account will be reaped."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
            #[cfg(feature = "ink")]
            pub fn transfer_allow_death(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![5u8, 0u8];
                dest.encode_to(&mut buf);
                value.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Exactly as `transfer_allow_death`, except the origin must be root and the source account"]
            #[doc = "may be specified."]
            #[cfg(not(feature = "ink"))]
            pub fn force_transfer(
                &self,
                source: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Balances(
                    types::pallet_balances::pallet::BalancesCall::force_transfer {
                        source,
                        dest,
                        value,
                    },
                ))
            }
            #[doc = "Exactly as `transfer_allow_death`, except the origin must be root and the source account"]
            #[doc = "may be specified."]
            #[cfg(feature = "ink")]
            pub fn force_transfer(
                &self,
                source: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![5u8, 2u8];
                source.encode_to(&mut buf);
                dest.encode_to(&mut buf);
                value.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Same as the [`transfer_allow_death`] call, but with a check that the transfer will not"]
            #[doc = "kill the origin account."]
            #[doc = ""]
            #[doc = "99% of the time you want [`transfer_allow_death`] instead."]
            #[doc = ""]
            #[doc = "[`transfer_allow_death`]: struct.Pallet.html#method.transfer"]
            #[cfg(not(feature = "ink"))]
            pub fn transfer_keep_alive(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Balances(
                    types::pallet_balances::pallet::BalancesCall::transfer_keep_alive {
                        dest,
                        value,
                    },
                ))
            }
            #[doc = "Same as the [`transfer_allow_death`] call, but with a check that the transfer will not"]
            #[doc = "kill the origin account."]
            #[doc = ""]
            #[doc = "99% of the time you want [`transfer_allow_death`] instead."]
            #[doc = ""]
            #[doc = "[`transfer_allow_death`]: struct.Pallet.html#method.transfer"]
            #[cfg(feature = "ink")]
            pub fn transfer_keep_alive(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![5u8, 3u8];
                dest.encode_to(&mut buf);
                value.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Transfer the entire transferable balance from the caller account."]
            #[doc = ""]
            #[doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"]
            #[doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"]
            #[doc = "transferred by this function. To ensure that this function results in a killed account,"]
            #[doc = "you might need to prepare the account by removing any reference counters, storage"]
            #[doc = "deposits, etc..."]
            #[doc = ""]
            #[doc = "The dispatch origin of this call must be Signed."]
            #[doc = ""]
            #[doc = "- `dest`: The recipient of the transfer."]
            #[doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"]
            #[doc = "  of the funds the account has, causing the sender account to be killed (false), or"]
            #[doc = "  transfer everything except at least the existential deposit, which will guarantee to"]
            #[doc = "  keep the sender account alive (true)."]
            #[cfg(not(feature = "ink"))]
            pub fn transfer_all(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                keep_alive: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Balances(
                    types::pallet_balances::pallet::BalancesCall::transfer_all { dest, keep_alive },
                ))
            }
            #[doc = "Transfer the entire transferable balance from the caller account."]
            #[doc = ""]
            #[doc = "NOTE: This function only attempts to transfer _transferable_ balances. This means that"]
            #[doc = "any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be"]
            #[doc = "transferred by this function. To ensure that this function results in a killed account,"]
            #[doc = "you might need to prepare the account by removing any reference counters, storage"]
            #[doc = "deposits, etc..."]
            #[doc = ""]
            #[doc = "The dispatch origin of this call must be Signed."]
            #[doc = ""]
            #[doc = "- `dest`: The recipient of the transfer."]
            #[doc = "- `keep_alive`: A boolean to determine if the `transfer_all` operation should send all"]
            #[doc = "  of the funds the account has, causing the sender account to be killed (false), or"]
            #[doc = "  transfer everything except at least the existential deposit, which will guarantee to"]
            #[doc = "  keep the sender account alive (true)."]
            #[cfg(feature = "ink")]
            pub fn transfer_all(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                keep_alive: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![5u8, 4u8];
                dest.encode_to(&mut buf);
                keep_alive.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Unreserve some balance from a user by force."]
            #[doc = ""]
            #[doc = "Can only be called by ROOT."]
            #[cfg(not(feature = "ink"))]
            pub fn force_unreserve(
                &self,
                who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                amount: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Balances(
                    types::pallet_balances::pallet::BalancesCall::force_unreserve { who, amount },
                ))
            }
            #[doc = "Unreserve some balance from a user by force."]
            #[doc = ""]
            #[doc = "Can only be called by ROOT."]
            #[cfg(feature = "ink")]
            pub fn force_unreserve(
                &self,
                who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                amount: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![5u8, 5u8];
                who.encode_to(&mut buf);
                amount.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Upgrade a specified account."]
            #[doc = ""]
            #[doc = "- `origin`: Must be `Signed`."]
            #[doc = "- `who`: The account to be upgraded."]
            #[doc = ""]
            #[doc = "This will waive the transaction fee if at least all but 10% of the accounts needed to"]
            #[doc = "be upgraded. (We let some not have to be upgraded just in order to allow for the"]
            #[doc = "possibility of churn)."]
            #[cfg(not(feature = "ink"))]
            pub fn upgrade_accounts(
                &self,
                who: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Balances(
                    types::pallet_balances::pallet::BalancesCall::upgrade_accounts { who },
                ))
            }
            #[doc = "Upgrade a specified account."]
            #[doc = ""]
            #[doc = "- `origin`: Must be `Signed`."]
            #[doc = "- `who`: The account to be upgraded."]
            #[doc = ""]
            #[doc = "This will waive the transaction fee if at least all but 10% of the accounts needed to"]
            #[doc = "be upgraded. (We let some not have to be upgraded just in order to allow for the"]
            #[doc = "possibility of churn)."]
            #[cfg(feature = "ink")]
            pub fn upgrade_accounts(
                &self,
                who: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![5u8, 6u8];
                who.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set the regular balance of a given account."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call is `root`."]
            #[cfg(not(feature = "ink"))]
            pub fn force_set_balance(
                &self,
                who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                new_free: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Balances(
                    types::pallet_balances::pallet::BalancesCall::force_set_balance {
                        who,
                        new_free,
                    },
                ))
            }
            #[doc = "Set the regular balance of a given account."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call is `root`."]
            #[cfg(feature = "ink")]
            pub fn force_set_balance(
                &self,
                who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                new_free: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![5u8, 8u8];
                who.encode_to(&mut buf);
                new_free.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adjust the total issuance in a saturating way."]
            #[doc = ""]
            #[doc = "Can only be called by root and always needs a positive `delta`."]
            #[doc = ""]
            #[doc = "# Example"]
            #[cfg(not(feature = "ink"))]
            pub fn force_adjust_total_issuance(
                &self,
                direction: types::pallet_balances::types::AdjustmentDirection,
                delta: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Balances(
                    types::pallet_balances::pallet::BalancesCall::force_adjust_total_issuance {
                        direction,
                        delta,
                    },
                ))
            }
            #[doc = "Adjust the total issuance in a saturating way."]
            #[doc = ""]
            #[doc = "Can only be called by root and always needs a positive `delta`."]
            #[doc = ""]
            #[doc = "# Example"]
            #[cfg(feature = "ink")]
            pub fn force_adjust_total_issuance(
                &self,
                direction: types::pallet_balances::types::AdjustmentDirection,
                delta: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![5u8, 9u8];
                direction.encode_to(&mut buf);
                delta.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Burn the specified liquid free balance from the origin account."]
            #[doc = ""]
            #[doc = "If the origin's account ends up below the existential deposit as a result"]
            #[doc = "of the burn and `keep_alive` is false, the account will be reaped."]
            #[doc = ""]
            #[doc = "Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,"]
            #[doc = "this `burn` operation will reduce total issuance by the amount _burned_."]
            #[cfg(not(feature = "ink"))]
            pub fn burn(
                &self,
                value: u128,
                keep_alive: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Balances(
                    types::pallet_balances::pallet::BalancesCall::burn { value, keep_alive },
                ))
            }
            #[doc = "Burn the specified liquid free balance from the origin account."]
            #[doc = ""]
            #[doc = "If the origin's account ends up below the existential deposit as a result"]
            #[doc = "of the burn and `keep_alive` is false, the account will be reaped."]
            #[doc = ""]
            #[doc = "Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,"]
            #[doc = "this `burn` operation will reduce total issuance by the amount _burned_."]
            #[cfg(feature = "ink")]
            pub fn burn(&self, value: u128, keep_alive: bool) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![5u8, 10u8];
                value.encode_to(&mut buf);
                keep_alive.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Transfer some liquid free balance to another account."]
            #[doc = ""]
            #[doc = "`transfer` will set the `FreeBalance` of the sender and receiver."]
            #[doc = "If the sender's account is below the existential deposit as a result"]
            #[doc = "of the transfer, the account will be reaped."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- Dependent on arguments but not critical, given proper implementations for input config"]
            #[doc = "  types. See related functions below."]
            #[doc = "- It contains a limited number of reads and writes internally and no complex"]
            #[doc = "  computation."]
            #[doc = ""]
            #[doc = "Related functions:"]
            #[doc = ""]
            #[doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."]
            #[doc = "  - Transferring balances to accounts that did not exist before will cause"]
            #[doc = "    `T::OnNewAccount::on_new_account` to be called."]
            #[doc = "  - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`."]
            #[doc = "  - `transfer_keep_alive` works the same way as `transfer`, but has an additional check"]
            #[doc = "    that the transfer will not kill the origin account."]
            #[cfg(not(feature = "ink"))]
            pub fn transfer_with_memo(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
                memo: Option<types::polymesh_primitives::Memo>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Balances(
                    types::pallet_balances::pallet::BalancesCall::transfer_with_memo {
                        dest,
                        value,
                        memo,
                    },
                ))
            }
            #[doc = "Transfer some liquid free balance to another account."]
            #[doc = ""]
            #[doc = "`transfer` will set the `FreeBalance` of the sender and receiver."]
            #[doc = "If the sender's account is below the existential deposit as a result"]
            #[doc = "of the transfer, the account will be reaped."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be `Signed` by the transactor."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- Dependent on arguments but not critical, given proper implementations for input config"]
            #[doc = "  types. See related functions below."]
            #[doc = "- It contains a limited number of reads and writes internally and no complex"]
            #[doc = "  computation."]
            #[doc = ""]
            #[doc = "Related functions:"]
            #[doc = ""]
            #[doc = "  - `ensure_can_withdraw` is always called internally but has a bounded complexity."]
            #[doc = "  - Transferring balances to accounts that did not exist before will cause"]
            #[doc = "    `T::OnNewAccount::on_new_account` to be called."]
            #[doc = "  - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`."]
            #[doc = "  - `transfer_keep_alive` works the same way as `transfer`, but has an additional check"]
            #[doc = "    that the transfer will not kill the origin account."]
            #[cfg(feature = "ink")]
            pub fn transfer_with_memo(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
                memo: Option<types::polymesh_primitives::Memo>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![5u8, 40u8];
                dest.encode_to(&mut buf);
                value.encode_to(&mut buf);
                memo.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for BalancesCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct BalancesQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> BalancesQueryApi<'api> {
            #[doc = " The total units issued in the system."]
            #[cfg(not(feature = "ink"))]
            pub async fn total_issuance(&self) -> ::polymesh_api_client::error::Result<u128> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 87u8, 200u8, 117u8, 228u8, 207u8, 247u8, 65u8, 72u8,
                    228u8, 98u8, 143u8, 38u8, 75u8, 151u8, 76u8, 128u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The total units issued in the system."]
            #[cfg(feature = "ink")]
            pub fn total_issuance(&self) -> ::polymesh_api_ink::error::Result<u128> {
                let value = self.api.read_storage(::alloc::vec![
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 87u8, 200u8, 117u8, 228u8, 207u8, 247u8, 65u8, 72u8,
                    228u8, 98u8, 143u8, 38u8, 75u8, 151u8, 76u8, 128u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The total units of outstanding deactivated balance in the system."]
            #[cfg(not(feature = "ink"))]
            pub async fn inactive_issuance(&self) -> ::polymesh_api_client::error::Result<u128> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 28u8, 205u8, 230u8, 135u8, 40u8, 129u8, 248u8, 147u8,
                    162u8, 29u8, 233u8, 61u8, 254u8, 151u8, 12u8, 213u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The total units of outstanding deactivated balance in the system."]
            #[cfg(feature = "ink")]
            pub fn inactive_issuance(&self) -> ::polymesh_api_ink::error::Result<u128> {
                let value = self.api.read_storage(::alloc::vec![
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 28u8, 205u8, 230u8, 135u8, 40u8, 129u8, 248u8, 147u8,
                    162u8, 29u8, 233u8, 61u8, 254u8, 151u8, 12u8, 213u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The Balances pallet example of storing the balance of an account."]
            #[doc = ""]
            #[doc = " # Example"]
            #[doc = ""]
            #[doc = " ```nocompile"]
            #[doc = "  impl pallet_balances::Config for Runtime {"]
            #[doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"]
            #[doc = "  }"]
            #[doc = " ```"]
            #[doc = ""]
            #[doc = " You can also store the balance of an account in the `System` pallet."]
            #[doc = ""]
            #[doc = " # Example"]
            #[doc = ""]
            #[doc = " ```nocompile"]
            #[doc = "  impl pallet_balances::Config for Runtime {"]
            #[doc = "   type AccountStore = System"]
            #[doc = "  }"]
            #[doc = " ```"]
            #[doc = ""]
            #[doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"]
            #[doc = " `frame_system` data alongside the account data contrary to storing account balances in the"]
            #[doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."]
            #[doc = " NOTE: This is only used in the case that this pallet is used to store balances."]
            #[cfg(not(feature = "ink"))]
            pub async fn account(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                types::pallet_balances::types::AccountData<u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8,
                    156u8, 12u8, 243u8, 14u8, 136u8, 134u8, 55u8, 29u8, 169u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 128u8,
                    ];
                    <types::pallet_balances::types::AccountData<u128>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The Balances pallet example of storing the balance of an account."]
            #[doc = ""]
            #[doc = " # Example"]
            #[doc = ""]
            #[doc = " ```nocompile"]
            #[doc = "  impl pallet_balances::Config for Runtime {"]
            #[doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"]
            #[doc = "  }"]
            #[doc = " ```"]
            #[doc = ""]
            #[doc = " You can also store the balance of an account in the `System` pallet."]
            #[doc = ""]
            #[doc = " # Example"]
            #[doc = ""]
            #[doc = " ```nocompile"]
            #[doc = "  impl pallet_balances::Config for Runtime {"]
            #[doc = "   type AccountStore = System"]
            #[doc = "  }"]
            #[doc = " ```"]
            #[doc = ""]
            #[doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"]
            #[doc = " `frame_system` data alongside the account data contrary to storing account balances in the"]
            #[doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."]
            #[doc = " NOTE: This is only used in the case that this pallet is used to store balances."]
            #[cfg(feature = "ink")]
            pub fn account(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_balances::types::AccountData<u128>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8,
                    156u8, 12u8, 243u8, 14u8, 136u8, 134u8, 55u8, 29u8, 169u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 128u8,
                    ];
                    <types::pallet_balances::types::AccountData<u128>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Any liquidity locks on some account balances."]
            #[doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."]
            #[doc = ""]
            #[doc = " Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`"]
            #[cfg(not(feature = "ink"))]
            pub async fn locks(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::pallet_balances::types::BalanceLock<u128>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 33u8, 143u8, 38u8, 199u8, 58u8, 221u8, 99u8, 72u8,
                    151u8, 85u8, 11u8, 64u8, 3u8, 178u8, 107u8, 198u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::pallet_balances::types::BalanceLock<u128>>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Any liquidity locks on some account balances."]
            #[doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."]
            #[doc = ""]
            #[doc = " Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`"]
            #[cfg(feature = "ink")]
            pub fn locks(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::pallet_balances::types::BalanceLock<u128>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 33u8, 143u8, 38u8, 199u8, 58u8, 221u8, 99u8, 72u8,
                    151u8, 85u8, 11u8, 64u8, 3u8, 178u8, 107u8, 198u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::pallet_balances::types::BalanceLock<u128>>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Named reserves on some account balances."]
            #[doc = ""]
            #[doc = " Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`"]
            #[cfg(not(feature = "ink"))]
            pub async fn reserves(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::pallet_balances::types::ReserveData<[u8; 8usize], u128>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 96u8, 201u8, 171u8, 115u8, 132u8, 243u8, 111u8, 61u8,
                    231u8, 154u8, 104u8, 95u8, 162u8, 43u8, 68u8, 145u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::pallet_balances::types::ReserveData<[u8; 8usize], u128>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Named reserves on some account balances."]
            #[doc = ""]
            #[doc = " Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`"]
            #[cfg(feature = "ink")]
            pub fn reserves(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::pallet_balances::types::ReserveData<[u8; 8usize], u128>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 96u8, 201u8, 171u8, 115u8, 132u8, 243u8, 111u8, 61u8,
                    231u8, 154u8, 104u8, 95u8, 162u8, 43u8, 68u8, 145u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::pallet_balances::types::ReserveData<[u8; 8usize], u128>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Holds on account balances."]
            #[cfg(not(feature = "ink"))]
            pub async fn holds(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<
                    types::frame_support::traits::tokens::misc::IdAmount<
                        runtime::RuntimeHoldReason,
                        u128,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 129u8, 17u8, 135u8, 237u8, 227u8, 198u8, 31u8, 50u8,
                    105u8, 52u8, 77u8, 22u8, 141u8, 62u8, 99u8, 55u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::frame_support::traits::tokens::misc::IdAmount<
                            runtime::RuntimeHoldReason,
                            u128,
                        >,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Holds on account balances."]
            #[cfg(feature = "ink")]
            pub fn holds(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<
                    types::frame_support::traits::tokens::misc::IdAmount<
                        runtime::RuntimeHoldReason,
                        u128,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 129u8, 17u8, 135u8, 237u8, 227u8, 198u8, 31u8, 50u8,
                    105u8, 52u8, 77u8, 22u8, 141u8, 62u8, 99u8, 55u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::frame_support::traits::tokens::misc::IdAmount<
                            runtime::RuntimeHoldReason,
                            u128,
                        >,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Freeze locks on account balances."]
            #[cfg(not(feature = "ink"))]
            pub async fn freezes(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<
                    types::frame_support::traits::tokens::misc::IdAmount<[u8; 8usize], u128>,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 177u8, 192u8, 235u8, 18u8, 224u8, 56u8, 229u8, 199u8,
                    249u8, 30u8, 18u8, 14u8, 212u8, 183u8, 235u8, 241u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::frame_support::traits::tokens::misc::IdAmount<[u8; 8usize], u128>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Freeze locks on account balances."]
            #[cfg(feature = "ink")]
            pub fn freezes(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<
                    types::frame_support::traits::tokens::misc::IdAmount<[u8; 8usize], u128>,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 177u8, 192u8, 235u8, 18u8, 224u8, 56u8, 229u8, 199u8,
                    249u8, 30u8, 18u8, 14u8, 212u8, 183u8, 235u8, 241u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::frame_support::traits::tokens::misc::IdAmount<[u8; 8usize], u128>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct BalancesPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> BalancesPagedQueryApi<'api> {
            #[doc = " The Balances pallet example of storing the balance of an account."]
            #[doc = ""]
            #[doc = " # Example"]
            #[doc = ""]
            #[doc = " ```nocompile"]
            #[doc = "  impl pallet_balances::Config for Runtime {"]
            #[doc = "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>"]
            #[doc = "  }"]
            #[doc = " ```"]
            #[doc = ""]
            #[doc = " You can also store the balance of an account in the `System` pallet."]
            #[doc = ""]
            #[doc = " # Example"]
            #[doc = ""]
            #[doc = " ```nocompile"]
            #[doc = "  impl pallet_balances::Config for Runtime {"]
            #[doc = "   type AccountStore = System"]
            #[doc = "  }"]
            #[doc = " ```"]
            #[doc = ""]
            #[doc = " But this comes with tradeoffs, storing account balances in the system pallet stores"]
            #[doc = " `frame_system` data alongside the account data contrary to storing account balances in the"]
            #[doc = " `Balances` pallet, which uses a `StorageMap` to store balances data only."]
            #[doc = " NOTE: This is only used in the case that this pallet is used to store balances."]
            pub fn account(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_balances::types::AccountData<u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 185u8, 157u8, 136u8, 14u8, 198u8, 129u8, 121u8,
                    156u8, 12u8, 243u8, 14u8, 136u8, 134u8, 55u8, 29u8, 169u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Any liquidity locks on some account balances."]
            #[doc = " NOTE: Should only be accessed when setting, changing and freeing a lock."]
            #[doc = ""]
            #[doc = " Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`"]
            pub fn locks(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                ::alloc::vec::Vec<types::pallet_balances::types::BalanceLock<u128>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 33u8, 143u8, 38u8, 199u8, 58u8, 221u8, 99u8, 72u8,
                    151u8, 85u8, 11u8, 64u8, 3u8, 178u8, 107u8, 198u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Named reserves on some account balances."]
            #[doc = ""]
            #[doc = " Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`"]
            pub fn reserves(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                ::alloc::vec::Vec<types::pallet_balances::types::ReserveData<[u8; 8usize], u128>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 96u8, 201u8, 171u8, 115u8, 132u8, 243u8, 111u8, 61u8,
                    231u8, 154u8, 104u8, 95u8, 162u8, 43u8, 68u8, 145u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Holds on account balances."]
            pub fn holds(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                ::alloc::vec::Vec<
                    types::frame_support::traits::tokens::misc::IdAmount<
                        runtime::RuntimeHoldReason,
                        u128,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 129u8, 17u8, 135u8, 237u8, 227u8, 198u8, 31u8, 50u8,
                    105u8, 52u8, 77u8, 22u8, 141u8, 62u8, 99u8, 55u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Freeze locks on account balances."]
            pub fn freezes(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                ::alloc::vec::Vec<
                    types::frame_support::traits::tokens::misc::IdAmount<[u8; 8usize], u128>,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    194u8, 38u8, 18u8, 118u8, 204u8, 157u8, 31u8, 133u8, 152u8, 234u8, 75u8, 106u8,
                    116u8, 177u8, 92u8, 47u8, 177u8, 192u8, 235u8, 18u8, 224u8, 56u8, 229u8, 199u8,
                    249u8, 30u8, 18u8, 14u8, 212u8, 183u8, 235u8, 241u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
        }
    }
    pub mod transaction_payment {
        use super::*;
        #[derive(Clone)]
        pub struct TransactionPaymentCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> TransactionPaymentCallApi<'api> {}
        impl<'api> From<&'api super::super::Api> for TransactionPaymentCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct TransactionPaymentQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> TransactionPaymentQueryApi<'api> {
            #[cfg(not(feature = "ink"))]
            pub async fn next_fee_multiplier(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::sp_arithmetic::fixed_point::FixedU128>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8,
                    85u8, 226u8, 8u8, 16u8, 63u8, 46u8, 223u8, 59u8, 223u8, 56u8, 29u8, 235u8,
                    227u8, 49u8, 171u8, 116u8, 70u8, 173u8, 223u8, 220u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 100u8, 167u8, 179u8, 182u8, 224u8, 13u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8,
                    ];
                    <types::sp_arithmetic::fixed_point::FixedU128>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[cfg(feature = "ink")]
            pub fn next_fee_multiplier(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::sp_arithmetic::fixed_point::FixedU128>
            {
                let value = self.api.read_storage(::alloc::vec![
                    63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8,
                    85u8, 226u8, 8u8, 16u8, 63u8, 46u8, 223u8, 59u8, 223u8, 56u8, 29u8, 235u8,
                    227u8, 49u8, 171u8, 116u8, 70u8, 173u8, 223u8, 220u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 100u8, 167u8, 179u8, 182u8, 224u8, 13u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8,
                    ];
                    <types::sp_arithmetic::fixed_point::FixedU128>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_transaction_payment::Releases>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8,
                    85u8, 226u8, 8u8, 16u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_transaction_payment::Releases>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_transaction_payment::Releases>
            {
                let value = self.api.read_storage(::alloc::vec![
                    63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8,
                    85u8, 226u8, 8u8, 16u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_transaction_payment::Releases>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The `OnChargeTransaction` stores the withdrawn tx fee here."]
            #[doc = ""]
            #[doc = " Use `withdraw_txfee` and `remaining_txfee` to access from outside the crate."]
            #[cfg(not(feature = "ink"))]
            pub async fn tx_payment_credit(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<()>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8,
                    85u8, 226u8, 8u8, 16u8, 12u8, 194u8, 135u8, 73u8, 46u8, 245u8, 71u8, 90u8,
                    65u8, 151u8, 183u8, 237u8, 77u8, 54u8, 179u8, 246u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The `OnChargeTransaction` stores the withdrawn tx fee here."]
            #[doc = ""]
            #[doc = " Use `withdraw_txfee` and `remaining_txfee` to access from outside the crate."]
            #[cfg(feature = "ink")]
            pub fn tx_payment_credit(&self) -> ::polymesh_api_ink::error::Result<Option<()>> {
                let value = self.api.read_storage(::alloc::vec![
                    63u8, 20u8, 103u8, 160u8, 150u8, 188u8, 215u8, 26u8, 91u8, 106u8, 12u8, 129u8,
                    85u8, 226u8, 8u8, 16u8, 12u8, 194u8, 135u8, 73u8, 46u8, 245u8, 71u8, 90u8,
                    65u8, 151u8, 183u8, 237u8, 77u8, 54u8, 179u8, 246u8,
                ])?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct TransactionPaymentPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> TransactionPaymentPagedQueryApi<'api> {}
    }
    pub mod identity {
        use super::*;
        #[derive(Clone)]
        pub struct IdentityCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> IdentityCallApi<'api> {
            #[doc = "Register `target_account` with a new Identity."]
            #[doc = ""]
            #[doc = "# Failure"]
            #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
            #[doc = "claims."]
            #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
            #[doc = "one identity."]
            #[doc = "- External secondary keys can be linked to just one identity."]
            #[cfg(not(feature = "ink"))]
            pub fn cdd_register_did(
                &self,
                target_account: ::polymesh_api_client::AccountId,
                secondary_keys: ::alloc::vec::Vec<
                    types::polymesh_primitives::secondary_key::SecondaryKey<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::cdd_register_did {
                        target_account,
                        secondary_keys,
                    },
                ))
            }
            #[doc = "Register `target_account` with a new Identity."]
            #[doc = ""]
            #[doc = "# Failure"]
            #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
            #[doc = "claims."]
            #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
            #[doc = "one identity."]
            #[doc = "- External secondary keys can be linked to just one identity."]
            #[cfg(feature = "ink")]
            pub fn cdd_register_did(
                &self,
                target_account: ::polymesh_api_client::AccountId,
                secondary_keys: ::alloc::vec::Vec<
                    types::polymesh_primitives::secondary_key::SecondaryKey<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 0u8];
                target_account.encode_to(&mut buf);
                secondary_keys.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Invalidates any claim generated by `cdd` from `disable_from` timestamps."]
            #[doc = ""]
            #[doc = "You can also define an expiration time,"]
            #[doc = "which will invalidate all claims generated by that `cdd` and remove it as CDD member group."]
            #[cfg(not(feature = "ink"))]
            pub fn invalidate_cdd_claims(
                &self,
                cdd: ::polymesh_api_client::IdentityId,
                disable_from: u64,
                expiry: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::invalidate_cdd_claims {
                        cdd,
                        disable_from,
                        expiry,
                    },
                ))
            }
            #[doc = "Invalidates any claim generated by `cdd` from `disable_from` timestamps."]
            #[doc = ""]
            #[doc = "You can also define an expiration time,"]
            #[doc = "which will invalidate all claims generated by that `cdd` and remove it as CDD member group."]
            #[cfg(feature = "ink")]
            pub fn invalidate_cdd_claims(
                &self,
                cdd: ::polymesh_api_client::IdentityId,
                disable_from: u64,
                expiry: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 1u8];
                cdd.encode_to(&mut buf);
                disable_from.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
            #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
            #[doc = "this change (or this is not required), primary key of the DID is updated."]
            #[doc = ""]
            #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
            #[doc = "unlinked to any identity."]
            #[doc = ""]
            #[doc = "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key"]
            #[doc = "instead of leaving it as a secondary key."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
            #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
            #[cfg(not(feature = "ink"))]
            pub fn accept_primary_key(
                &self,
                rotation_auth_id: u64,
                optional_cdd_auth_id: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::accept_primary_key {
                        rotation_auth_id,
                        optional_cdd_auth_id,
                    },
                ))
            }
            #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
            #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
            #[doc = "this change (or this is not required), primary key of the DID is updated."]
            #[doc = ""]
            #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
            #[doc = "unlinked to any identity."]
            #[doc = ""]
            #[doc = "Differs from rotate_primary_key_to_secondary in that it will unlink the old primary key"]
            #[doc = "instead of leaving it as a secondary key."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
            #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
            #[cfg(feature = "ink")]
            pub fn accept_primary_key(
                &self,
                rotation_auth_id: u64,
                optional_cdd_auth_id: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 2u8];
                rotation_auth_id.encode_to(&mut buf);
                optional_cdd_auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set if CDD authorization is required for updating primary key of an identity."]
            #[doc = "Callable via root (governance)"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `auth_required` CDD Authorization required or not"]
            #[cfg(not(feature = "ink"))]
            pub fn change_cdd_requirement_for_mk_rotation(
                &self,
                auth_required: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Identity (types :: pallet_identity :: pallet :: IdentityCall :: change_cdd_requirement_for_mk_rotation { auth_required , }))
            }
            #[doc = "Set if CDD authorization is required for updating primary key of an identity."]
            #[doc = "Callable via root (governance)"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `auth_required` CDD Authorization required or not"]
            #[cfg(feature = "ink")]
            pub fn change_cdd_requirement_for_mk_rotation(
                &self,
                auth_required: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 3u8];
                auth_required.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Join an identity as a secondary key."]
            #[cfg(not(feature = "ink"))]
            pub fn join_identity_as_key(
                &self,
                auth_id: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::join_identity_as_key { auth_id },
                ))
            }
            #[doc = "Join an identity as a secondary key."]
            #[cfg(feature = "ink")]
            pub fn join_identity_as_key(&self, auth_id: u64) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 4u8];
                auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Leave the secondary key's identity."]
            #[cfg(not(feature = "ink"))]
            pub fn leave_identity_as_key(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::leave_identity_as_key,
                ))
            }
            #[doc = "Leave the secondary key's identity."]
            #[cfg(feature = "ink")]
            pub fn leave_identity_as_key(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![7u8, 5u8])
            }
            #[doc = "Adds a new claim record or edits an existing one."]
            #[doc = ""]
            #[doc = "Only called by did_issuer's secondary key."]
            #[cfg(not(feature = "ink"))]
            pub fn add_claim(
                &self,
                target: ::polymesh_api_client::IdentityId,
                claim: types::polymesh_primitives::identity_claim::Claim,
                expiry: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::add_claim {
                        target,
                        claim,
                        expiry,
                    },
                ))
            }
            #[doc = "Adds a new claim record or edits an existing one."]
            #[doc = ""]
            #[doc = "Only called by did_issuer's secondary key."]
            #[cfg(feature = "ink")]
            pub fn add_claim(
                &self,
                target: ::polymesh_api_client::IdentityId,
                claim: types::polymesh_primitives::identity_claim::Claim,
                expiry: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 6u8];
                target.encode_to(&mut buf);
                claim.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Marks the specified claim as revoked."]
            #[cfg(not(feature = "ink"))]
            pub fn revoke_claim(
                &self,
                target: ::polymesh_api_client::IdentityId,
                claim: types::polymesh_primitives::identity_claim::Claim,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::revoke_claim { target, claim },
                ))
            }
            #[doc = "Marks the specified claim as revoked."]
            #[cfg(feature = "ink")]
            pub fn revoke_claim(
                &self,
                target: ::polymesh_api_client::IdentityId,
                claim: types::polymesh_primitives::identity_claim::Claim,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 7u8];
                target.encode_to(&mut buf);
                claim.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "It disables all secondary keys at `did` identity."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = ""]
            #[cfg(not(feature = "ink"))]
            pub fn freeze_secondary_keys(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::freeze_secondary_keys,
                ))
            }
            #[doc = "It disables all secondary keys at `did` identity."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = ""]
            #[cfg(feature = "ink")]
            pub fn freeze_secondary_keys(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![7u8, 8u8])
            }
            #[doc = "Re-enables all secondary keys of the caller's identity."]
            #[cfg(not(feature = "ink"))]
            pub fn unfreeze_secondary_keys(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::unfreeze_secondary_keys,
                ))
            }
            #[doc = "Re-enables all secondary keys of the caller's identity."]
            #[cfg(feature = "ink")]
            pub fn unfreeze_secondary_keys(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![7u8, 9u8])
            }
            #[doc = "Adds an authorization."]
            #[cfg(not(feature = "ink"))]
            pub fn add_authorization(
                &self,
                target: types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
                data: types::polymesh_primitives::authorization::AuthorizationData<
                    ::polymesh_api_client::AccountId,
                >,
                expiry: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::add_authorization {
                        target,
                        data,
                        expiry,
                    },
                ))
            }
            #[doc = "Adds an authorization."]
            #[cfg(feature = "ink")]
            pub fn add_authorization(
                &self,
                target: types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
                data: types::polymesh_primitives::authorization::AuthorizationData<
                    ::polymesh_api_client::AccountId,
                >,
                expiry: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 10u8];
                target.encode_to(&mut buf);
                data.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes an authorization."]
            #[doc = "`_auth_issuer_pays` determines whether the issuer of the authorisation pays the transaction fee"]
            #[cfg(not(feature = "ink"))]
            pub fn remove_authorization(
                &self,
                target: types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
                auth_id: u64,
                auth_issuer_pays: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::remove_authorization {
                        target,
                        auth_id,
                        auth_issuer_pays,
                    },
                ))
            }
            #[doc = "Removes an authorization."]
            #[doc = "`_auth_issuer_pays` determines whether the issuer of the authorisation pays the transaction fee"]
            #[cfg(feature = "ink")]
            pub fn remove_authorization(
                &self,
                target: types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
                auth_id: u64,
                auth_issuer_pays: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 11u8];
                target.encode_to(&mut buf);
                auth_id.encode_to(&mut buf);
                auth_issuer_pays.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Assuming this is executed by the GC voting majority, adds a new cdd claim record."]
            #[cfg(not(feature = "ink"))]
            pub fn gc_add_cdd_claim(
                &self,
                target: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::gc_add_cdd_claim { target },
                ))
            }
            #[doc = "Assuming this is executed by the GC voting majority, adds a new cdd claim record."]
            #[cfg(feature = "ink")]
            pub fn gc_add_cdd_claim(
                &self,
                target: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 12u8];
                target.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Assuming this is executed by the GC voting majority, removes an existing cdd claim record."]
            #[cfg(not(feature = "ink"))]
            pub fn gc_revoke_cdd_claim(
                &self,
                target: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::gc_revoke_cdd_claim { target },
                ))
            }
            #[doc = "Assuming this is executed by the GC voting majority, removes an existing cdd claim record."]
            #[cfg(feature = "ink")]
            pub fn gc_revoke_cdd_claim(
                &self,
                target: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 13u8];
                target.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`,"]
            #[doc = "`claim_type`, and `scope`."]
            #[doc = ""]
            #[doc = "Please note that `origin` must be the issuer of the target claim."]
            #[cfg(not(feature = "ink"))]
            pub fn revoke_claim_by_index(
                &self,
                target: ::polymesh_api_client::IdentityId,
                claim_type: types::polymesh_primitives::identity_claim::ClaimType,
                scope: Option<types::polymesh_primitives::identity_claim::Scope>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::revoke_claim_by_index {
                        target,
                        claim_type,
                        scope,
                    },
                ))
            }
            #[doc = "Revokes a specific claim using its [Claim Unique Index](/pallet_identity/index.html#claim-unique-index) composed by `target`,"]
            #[doc = "`claim_type`, and `scope`."]
            #[doc = ""]
            #[doc = "Please note that `origin` must be the issuer of the target claim."]
            #[cfg(feature = "ink")]
            pub fn revoke_claim_by_index(
                &self,
                target: ::polymesh_api_client::IdentityId,
                claim_type: types::polymesh_primitives::identity_claim::ClaimType,
                scope: Option<types::polymesh_primitives::identity_claim::Scope>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 14u8];
                target.encode_to(&mut buf);
                claim_type.encode_to(&mut buf);
                scope.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
            #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
            #[doc = "this change, (or this is not required), primary key of the DID is updated."]
            #[doc = ""]
            #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
            #[doc = "unlinked to any identity."]
            #[doc = ""]
            #[doc = "Differs from accept_primary_key in that it will leave the old primary key as a secondary"]
            #[doc = "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization"]
            #[doc = "instead of unlinking the old primary key."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
            #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
            #[cfg(not(feature = "ink"))]
            pub fn rotate_primary_key_to_secondary(
                &self,
                auth_id: u64,
                optional_cdd_auth_id: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::rotate_primary_key_to_secondary {
                        auth_id,
                        optional_cdd_auth_id,
                    },
                ))
            }
            #[doc = "Call this with the new primary key. By invoking this method, caller accepts authorization"]
            #[doc = "to become the new primary key of the issuing identity. If a CDD service provider approved"]
            #[doc = "this change, (or this is not required), primary key of the DID is updated."]
            #[doc = ""]
            #[doc = "The caller (new primary key) must be either a secondary key of the issuing identity, or"]
            #[doc = "unlinked to any identity."]
            #[doc = ""]
            #[doc = "Differs from accept_primary_key in that it will leave the old primary key as a secondary"]
            #[doc = "key with the permissions specified in the corresponding RotatePrimaryKeyToSecondary authorization"]
            #[doc = "instead of unlinking the old primary key."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `owner_auth_id` Authorization from the owner who initiated the change"]
            #[doc = "* `cdd_auth_id` Authorization from a CDD service provider"]
            #[cfg(feature = "ink")]
            pub fn rotate_primary_key_to_secondary(
                &self,
                auth_id: u64,
                optional_cdd_auth_id: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 15u8];
                auth_id.encode_to(&mut buf);
                optional_cdd_auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds secondary keys to target identity `id`."]
            #[doc = ""]
            #[doc = "Keys are directly added to identity because each of them has an authorization."]
            #[doc = ""]
            #[doc = "# Arguments:"]
            #[doc = "    - `origin` which must be the primary key of the identity `id`."]
            #[doc = "    - `id` to which new secondary keys will be added."]
            #[doc = "    - `additional_keys` which includes secondary keys,"]
            #[doc = "       coupled with authorization data, to add to target identity."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "    - Can only called by primary key owner."]
            #[doc = "    - Keys should be able to linked to any identity."]
            #[cfg(not(feature = "ink"))]
            pub fn add_secondary_keys_with_authorization(
                &self,
                additional_keys: ::alloc::vec::Vec<
                    polymesh_primitives::identity::SecondaryKeyWithAuth<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
                expires_at: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Identity (types :: pallet_identity :: pallet :: IdentityCall :: add_secondary_keys_with_authorization { additional_keys , expires_at , }))
            }
            #[doc = "Adds secondary keys to target identity `id`."]
            #[doc = ""]
            #[doc = "Keys are directly added to identity because each of them has an authorization."]
            #[doc = ""]
            #[doc = "# Arguments:"]
            #[doc = "    - `origin` which must be the primary key of the identity `id`."]
            #[doc = "    - `id` to which new secondary keys will be added."]
            #[doc = "    - `additional_keys` which includes secondary keys,"]
            #[doc = "       coupled with authorization data, to add to target identity."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "    - Can only called by primary key owner."]
            #[doc = "    - Keys should be able to linked to any identity."]
            #[cfg(feature = "ink")]
            pub fn add_secondary_keys_with_authorization(
                &self,
                additional_keys: ::alloc::vec::Vec<
                    polymesh_primitives::identity::SecondaryKeyWithAuth<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
                expires_at: u64,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 16u8];
                additional_keys.encode_to(&mut buf);
                expires_at.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Sets permissions for an specific `target_key` key."]
            #[doc = ""]
            #[doc = "Only the primary key of an identity is able to set secondary key permissions."]
            #[cfg(not(feature = "ink"))]
            pub fn set_secondary_key_permissions(
                &self,
                key: ::polymesh_api_client::AccountId,
                perms: types::polymesh_primitives::secondary_key::Permissions,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::set_secondary_key_permissions {
                        key,
                        perms,
                    },
                ))
            }
            #[doc = "Sets permissions for an specific `target_key` key."]
            #[doc = ""]
            #[doc = "Only the primary key of an identity is able to set secondary key permissions."]
            #[cfg(feature = "ink")]
            pub fn set_secondary_key_permissions(
                &self,
                key: ::polymesh_api_client::AccountId,
                perms: types::polymesh_primitives::secondary_key::Permissions,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 17u8];
                key.encode_to(&mut buf);
                perms.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes specified secondary keys of a DID if present."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = ""]
            #[doc = "The extrinsic can only called by primary key owner."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_secondary_keys(
                &self,
                keys_to_remove: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::remove_secondary_keys {
                        keys_to_remove,
                    },
                ))
            }
            #[doc = "Removes specified secondary keys of a DID if present."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = ""]
            #[doc = "The extrinsic can only called by primary key owner."]
            #[cfg(feature = "ink")]
            pub fn remove_secondary_keys(
                &self,
                keys_to_remove: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 18u8];
                keys_to_remove.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Register custom claim type."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists."]
            #[doc = "* `CounterOverflow` CustomClaimTypeId has overflowed."]
            #[doc = "* `TooLong` The type being registered is too lang."]
            #[cfg(not(feature = "ink"))]
            pub fn register_custom_claim_type(
                &self,
                ty: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::register_custom_claim_type { ty },
                ))
            }
            #[doc = "Register custom claim type."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `CustomClaimTypeAlreadyExists` The type that is being registered already exists."]
            #[doc = "* `CounterOverflow` CustomClaimTypeId has overflowed."]
            #[doc = "* `TooLong` The type being registered is too lang."]
            #[cfg(feature = "ink")]
            pub fn register_custom_claim_type(
                &self,
                ty: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 19u8];
                ty.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Register `target_account` with a new Identity and issue a CDD claim with a blank CddId"]
            #[doc = ""]
            #[doc = "# Failure"]
            #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
            #[doc = "claims."]
            #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
            #[doc = "one identity."]
            #[doc = "- External secondary keys can be linked to just one identity."]
            #[cfg(not(feature = "ink"))]
            pub fn cdd_register_did_with_cdd(
                &self,
                target_account: ::polymesh_api_client::AccountId,
                secondary_keys: ::alloc::vec::Vec<
                    types::polymesh_primitives::secondary_key::SecondaryKey<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
                expiry: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::cdd_register_did_with_cdd {
                        target_account,
                        secondary_keys,
                        expiry,
                    },
                ))
            }
            #[doc = "Register `target_account` with a new Identity and issue a CDD claim with a blank CddId"]
            #[doc = ""]
            #[doc = "# Failure"]
            #[doc = "- `origin` has to be a active CDD provider. Inactive CDD providers cannot add new"]
            #[doc = "claims."]
            #[doc = "- `target_account` (primary key of the new Identity) can be linked to just one and only"]
            #[doc = "one identity."]
            #[doc = "- External secondary keys can be linked to just one identity."]
            #[cfg(feature = "ink")]
            pub fn cdd_register_did_with_cdd(
                &self,
                target_account: ::polymesh_api_client::AccountId,
                secondary_keys: ::alloc::vec::Vec<
                    types::polymesh_primitives::secondary_key::SecondaryKey<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
                expiry: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 20u8];
                target_account.encode_to(&mut buf);
                secondary_keys.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Create a child identity and make the `secondary_key` it's primary key."]
            #[doc = ""]
            #[doc = "Only the primary key can create child identities."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `secondary_key` the secondary key that will become the primary key of the new identity."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
            #[doc = "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity."]
            #[doc = "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity."]
            #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
            #[cfg(not(feature = "ink"))]
            pub fn create_child_identity(
                &self,
                secondary_key: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::create_child_identity {
                        secondary_key,
                    },
                ))
            }
            #[doc = "Create a child identity and make the `secondary_key` it's primary key."]
            #[doc = ""]
            #[doc = "Only the primary key can create child identities."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `secondary_key` the secondary key that will become the primary key of the new identity."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
            #[doc = "- `NotASigner` the `secondary_key` is not a secondary key of the caller's identity."]
            #[doc = "- `AccountKeyIsBeingUsed` the `secondary_key` can't be unlinked from it's current identity."]
            #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
            #[cfg(feature = "ink")]
            pub fn create_child_identity(
                &self,
                secondary_key: ::polymesh_api_client::AccountId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 21u8];
                secondary_key.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Create a child identities."]
            #[doc = ""]
            #[doc = "The new primary key for each child identity will need to sign (off-chain)"]
            #[doc = "an authorization."]
            #[doc = ""]
            #[doc = "Only the primary key can create child identities."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `child_keys` the keys that will become primary keys of their own child identity."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
            #[doc = "- `AlreadyLinked` one of the keys is already linked to an identity."]
            #[doc = "- `DuplicateKey` one of the keys is included multiple times."]
            #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
            #[cfg(not(feature = "ink"))]
            pub fn create_child_identities(
                &self,
                child_keys: ::alloc::vec::Vec<
                    polymesh_primitives::identity::CreateChildIdentityWithAuth<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
                expires_at: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::create_child_identities {
                        child_keys,
                        expires_at,
                    },
                ))
            }
            #[doc = "Create a child identities."]
            #[doc = ""]
            #[doc = "The new primary key for each child identity will need to sign (off-chain)"]
            #[doc = "an authorization."]
            #[doc = ""]
            #[doc = "Only the primary key can create child identities."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `child_keys` the keys that will become primary keys of their own child identity."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `KeyNotAllowed` only the primary key can create a new identity."]
            #[doc = "- `AlreadyLinked` one of the keys is already linked to an identity."]
            #[doc = "- `DuplicateKey` one of the keys is included multiple times."]
            #[doc = "- `IsChildIdentity` the caller's identity is already a child identity and can't create child identities."]
            #[cfg(feature = "ink")]
            pub fn create_child_identities(
                &self,
                child_keys: ::alloc::vec::Vec<
                    polymesh_primitives::identity::CreateChildIdentityWithAuth<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
                expires_at: u64,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 22u8];
                child_keys.encode_to(&mut buf);
                expires_at.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Unlink a child identity from it's parent identity."]
            #[doc = ""]
            #[doc = "Only the primary key of the parent or child identities can unlink the identities."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `child_did` the child identity to unlink from its parent identity."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities."]
            #[doc = "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity."]
            #[doc = "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity."]
            #[cfg(not(feature = "ink"))]
            pub fn unlink_child_identity(
                &self,
                child_did: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Identity(
                    types::pallet_identity::pallet::IdentityCall::unlink_child_identity {
                        child_did,
                    },
                ))
            }
            #[doc = "Unlink a child identity from it's parent identity."]
            #[doc = ""]
            #[doc = "Only the primary key of the parent or child identities can unlink the identities."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `child_did` the child identity to unlink from its parent identity."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `KeyNotAllowed` only the primary key of either the parent or child identity can unlink the identities."]
            #[doc = "- `NoParentIdentity` the identity `child_did` doesn't have a parent identity."]
            #[doc = "- `NotParentOrChildIdentity` the caller's identity isn't the parent or child identity."]
            #[cfg(feature = "ink")]
            pub fn unlink_child_identity(
                &self,
                child_did: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![7u8, 23u8];
                child_did.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for IdentityCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct IdentityQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> IdentityQueryApi<'api> {
            #[doc = " DID -> identity info"]
            #[cfg(not(feature = "ink"))]
            pub async fn did_records(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::polymesh_primitives::identity::DidRecord<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 116u8, 80u8, 50u8, 71u8, 155u8, 166u8, 193u8, 20u8,
                    243u8, 13u8, 15u8, 187u8, 81u8, 210u8, 17u8, 101u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " DID -> identity info"]
            #[cfg(feature = "ink")]
            pub fn did_records(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::polymesh_primitives::identity::DidRecord<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 116u8, 80u8, 50u8, 71u8, 155u8, 166u8, 193u8, 20u8,
                    243u8, 13u8, 15u8, 187u8, 81u8, 210u8, 17u8, 101u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " DID -> bool that indicates if secondary keys are frozen."]
            #[cfg(not(feature = "ink"))]
            pub async fn is_did_frozen(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 88u8, 25u8, 37u8, 70u8, 145u8, 206u8, 174u8, 76u8,
                    55u8, 194u8, 155u8, 126u8, 165u8, 90u8, 158u8, 251u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " DID -> bool that indicates if secondary keys are frozen."]
            #[cfg(feature = "ink")]
            pub fn is_did_frozen(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 88u8, 25u8, 37u8, 70u8, 145u8, 206u8, 174u8, 76u8,
                    55u8, 194u8, 155u8, 126u8, 165u8, 90u8, 158u8, 251u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " It stores the current gas fee payer for the current transaction."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_payer(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 223u8, 12u8, 177u8, 135u8, 158u8, 14u8, 195u8, 122u8,
                    19u8, 92u8, 166u8, 91u8, 51u8, 74u8, 253u8, 115u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " It stores the current gas fee payer for the current transaction."]
            #[cfg(feature = "ink")]
            pub fn current_payer(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 223u8, 12u8, 177u8, 135u8, 158u8, 14u8, 195u8, 122u8,
                    19u8, 92u8, 166u8, 91u8, 51u8, 74u8, 253u8, 115u8,
                ])?;
                Ok(value)
            }
            #[doc = " (Target ID, claim type) (issuer,scope) -> Associated claims"]
            #[cfg(not(feature = "ink"))]
            pub async fn claims(
                &self,
                key_0: types::pallet_identity::types::Claim1stKey,
                key_1: types::pallet_identity::types::Claim2ndKey,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::identity_claim::IdentityClaim>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 156u8, 93u8, 121u8, 93u8, 2u8, 151u8, 190u8, 86u8,
                    2u8, 122u8, 75u8, 36u8, 100u8, 227u8, 51u8, 151u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " (Target ID, claim type) (issuer,scope) -> Associated claims"]
            #[cfg(feature = "ink")]
            pub fn claims(
                &self,
                key_0: types::pallet_identity::types::Claim1stKey,
                key_1: types::pallet_identity::types::Claim2ndKey,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::identity_claim::IdentityClaim>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 156u8, 93u8, 121u8, 93u8, 2u8, 151u8, 190u8, 86u8,
                    2u8, 122u8, 75u8, 36u8, 100u8, 227u8, 51u8, 151u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " CusotmClaimTypeId -> String constant"]
            #[cfg(not(feature = "ink"))]
            pub async fn custom_claims(
                &self,
                key_0: types::polymesh_primitives::identity_claim::CustomClaimTypeId,
            ) -> ::polymesh_api_client::error::Result<Option<::alloc::vec::Vec<u8>>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 191u8, 149u8, 69u8, 57u8, 187u8, 49u8, 56u8, 118u8,
                    117u8, 181u8, 215u8, 96u8, 18u8, 206u8, 94u8, 232u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " CusotmClaimTypeId -> String constant"]
            #[cfg(feature = "ink")]
            pub fn custom_claims(
                &self,
                key_0: types::polymesh_primitives::identity_claim::CustomClaimTypeId,
            ) -> ::polymesh_api_ink::error::Result<Option<::alloc::vec::Vec<u8>>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 191u8, 149u8, 69u8, 57u8, 187u8, 49u8, 56u8, 118u8,
                    117u8, 181u8, 215u8, 96u8, 18u8, 206u8, 94u8, 232u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " String constant -> CustomClaimTypeId"]
            #[cfg(not(feature = "ink"))]
            pub async fn custom_claims_inverse(
                &self,
                key_0: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::identity_claim::CustomClaimTypeId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 238u8, 140u8, 175u8, 222u8, 16u8, 43u8, 89u8, 2u8,
                    60u8, 101u8, 161u8, 89u8, 63u8, 155u8, 89u8, 216u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " String constant -> CustomClaimTypeId"]
            #[cfg(feature = "ink")]
            pub fn custom_claims_inverse(
                &self,
                key_0: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::identity_claim::CustomClaimTypeId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 238u8, 140u8, 175u8, 222u8, 16u8, 43u8, 89u8, 2u8,
                    60u8, 101u8, 161u8, 89u8, 63u8, 155u8, 89u8, 216u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The next `CustomClaimTypeId`."]
            #[cfg(not(feature = "ink"))]
            pub async fn custom_claim_id_sequence(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::identity_claim::CustomClaimTypeId,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 216u8, 67u8, 38u8, 124u8, 109u8, 145u8, 9u8, 206u8,
                    14u8, 87u8, 168u8, 35u8, 237u8, 61u8, 102u8, 0u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::identity_claim::CustomClaimTypeId>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The next `CustomClaimTypeId`."]
            #[cfg(feature = "ink")]
            pub fn custom_claim_id_sequence(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::identity_claim::CustomClaimTypeId,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 216u8, 67u8, 38u8, 124u8, 109u8, 145u8, 9u8, 206u8,
                    14u8, 87u8, 168u8, 35u8, 237u8, 61u8, 102u8, 0u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::identity_claim::CustomClaimTypeId>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Map from AccountId to `KeyRecord` that holds the key's type and identity."]
            #[cfg(not(feature = "ink"))]
            pub async fn key_records(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::polymesh_primitives::secondary_key::KeyRecord<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 140u8, 4u8, 71u8, 134u8, 27u8, 11u8, 130u8, 15u8,
                    11u8, 176u8, 222u8, 164u8, 7u8, 164u8, 75u8, 52u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Map from AccountId to `KeyRecord` that holds the key's type and identity."]
            #[cfg(feature = "ink")]
            pub fn key_records(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::polymesh_primitives::secondary_key::KeyRecord<
                        ::polymesh_api_client::AccountId,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 140u8, 4u8, 71u8, 134u8, 27u8, 11u8, 130u8, 15u8,
                    11u8, 176u8, 222u8, 164u8, 7u8, 164u8, 75u8, 52u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " A secondary key's extrinsic permissions."]
            #[cfg(not(feature = "ink"))]
            pub async fn key_extrinsic_permissions(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::secondary_key::ExtrinsicPermissions>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 66u8, 215u8, 106u8, 150u8, 225u8, 217u8, 210u8, 44u8,
                    255u8, 38u8, 187u8, 4u8, 9u8, 185u8, 157u8, 131u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " A secondary key's extrinsic permissions."]
            #[cfg(feature = "ink")]
            pub fn key_extrinsic_permissions(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::secondary_key::ExtrinsicPermissions>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 66u8, 215u8, 106u8, 150u8, 225u8, 217u8, 210u8, 44u8,
                    255u8, 38u8, 187u8, 4u8, 9u8, 185u8, 157u8, 131u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " A secondary key's asset permissions."]
            #[cfg(not(feature = "ink"))]
            pub async fn key_asset_permissions(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::polymesh_primitives::subset::SubsetRestriction<
                        ::polymesh_api_client::AssetId,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 185u8, 144u8, 42u8, 124u8, 79u8, 75u8, 50u8, 231u8,
                    22u8, 182u8, 5u8, 71u8, 190u8, 2u8, 122u8, 31u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " A secondary key's asset permissions."]
            #[cfg(feature = "ink")]
            pub fn key_asset_permissions(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::polymesh_primitives::subset::SubsetRestriction<
                        ::polymesh_api_client::AssetId,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 185u8, 144u8, 42u8, 124u8, 79u8, 75u8, 50u8, 231u8,
                    22u8, 182u8, 5u8, 71u8, 190u8, 2u8, 122u8, 31u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " A secondary key's portfolio permissions."]
            #[cfg(not(feature = "ink"))]
            pub async fn key_portfolio_permissions(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::polymesh_primitives::subset::SubsetRestriction<
                        types::polymesh_primitives::identity_id::PortfolioId,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 51u8, 17u8, 209u8, 116u8, 254u8, 60u8, 114u8, 180u8,
                    75u8, 236u8, 206u8, 226u8, 14u8, 117u8, 212u8, 41u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " A secondary key's portfolio permissions."]
            #[cfg(feature = "ink")]
            pub fn key_portfolio_permissions(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::polymesh_primitives::subset::SubsetRestriction<
                        types::polymesh_primitives::identity_id::PortfolioId,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 51u8, 17u8, 209u8, 116u8, 254u8, 60u8, 114u8, 180u8,
                    75u8, 236u8, 206u8, 226u8, 14u8, 117u8, 212u8, 41u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " A reverse double map to allow finding all keys for an identity."]
            #[cfg(not(feature = "ink"))]
            pub async fn did_keys(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 48u8, 201u8, 137u8, 112u8, 80u8, 239u8, 164u8, 12u8,
                    73u8, 173u8, 249u8, 240u8, 185u8, 87u8, 20u8, 244u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " A reverse double map to allow finding all keys for an identity."]
            #[cfg(feature = "ink")]
            pub fn did_keys(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 48u8, 201u8, 137u8, 112u8, 80u8, 239u8, 164u8, 12u8,
                    73u8, 173u8, 249u8, 240u8, 185u8, 87u8, 20u8, 244u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Nonce to ensure unique actions. starts from 1."]
            #[cfg(not(feature = "ink"))]
            pub async fn multi_purpose_nonce(&self) -> ::polymesh_api_client::error::Result<u64> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 136u8, 63u8, 194u8, 107u8, 192u8, 198u8, 19u8, 83u8,
                    149u8, 2u8, 100u8, 173u8, 112u8, 208u8, 112u8, 17u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Nonce to ensure unique actions. starts from 1."]
            #[cfg(feature = "ink")]
            pub fn multi_purpose_nonce(&self) -> ::polymesh_api_ink::error::Result<u64> {
                let value = self.api.read_storage(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 136u8, 63u8, 194u8, 107u8, 192u8, 198u8, 19u8, 83u8,
                    149u8, 2u8, 100u8, 173u8, 112u8, 208u8, 112u8, 17u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Authorization nonce per Identity. Initially is 0."]
            #[cfg(not(feature = "ink"))]
            pub async fn off_chain_authorization_nonce(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 180u8, 43u8, 244u8, 108u8, 4u8, 166u8, 74u8, 143u8,
                    8u8, 226u8, 206u8, 196u8, 229u8, 245u8, 62u8, 152u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Authorization nonce per Identity. Initially is 0."]
            #[cfg(feature = "ink")]
            pub fn off_chain_authorization_nonce(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 180u8, 43u8, 244u8, 108u8, 4u8, 166u8, 74u8, 143u8,
                    8u8, 226u8, 206u8, 196u8, 229u8, 245u8, 62u8, 152u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All authorizations that an identity/key has"]
            #[cfg(not(feature = "ink"))]
            pub async fn authorizations(
                &self,
                key_0: types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
                key_1: u64,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::polymesh_primitives::authorization::Authorization<
                        ::polymesh_api_client::AccountId,
                        u64,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 104u8, 58u8, 80u8, 244u8, 170u8, 112u8, 186u8, 34u8,
                    193u8, 127u8, 221u8, 184u8, 141u8, 38u8, 73u8, 43u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " All authorizations that an identity/key has"]
            #[cfg(feature = "ink")]
            pub fn authorizations(
                &self,
                key_0: types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
                key_1: u64,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::polymesh_primitives::authorization::Authorization<
                        ::polymesh_api_client::AccountId,
                        u64,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 104u8, 58u8, 80u8, 244u8, 170u8, 112u8, 186u8, 34u8,
                    193u8, 127u8, 221u8, 184u8, 141u8, 38u8, 73u8, 43u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " All authorizations that an identity has given. (Authorizer, auth_id -> authorized)"]
            #[cfg(not(feature = "ink"))]
            pub async fn authorizations_given(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: u64,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 31u8, 154u8, 92u8, 218u8, 166u8, 154u8, 225u8, 139u8,
                    48u8, 60u8, 199u8, 128u8, 85u8, 224u8, 137u8, 110u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8,
                    ];
                    <types::polymesh_primitives::secondary_key::Signatory<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " All authorizations that an identity has given. (Authorizer, auth_id -> authorized)"]
            #[cfg(feature = "ink")]
            pub fn authorizations_given(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: u64,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 31u8, 154u8, 92u8, 218u8, 166u8, 154u8, 225u8, 139u8,
                    48u8, 60u8, 199u8, 128u8, 85u8, 224u8, 137u8, 110u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8,
                    ];
                    <types::polymesh_primitives::secondary_key::Signatory<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " A config flag that, if set, instructs an authorization from a CDD provider in order to"]
            #[doc = " change the primary key of an identity."]
            #[cfg(not(feature = "ink"))]
            pub async fn cdd_auth_for_primary_key_rotation(
                &self,
            ) -> ::polymesh_api_client::error::Result<bool> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 114u8, 149u8, 136u8, 2u8, 121u8, 4u8, 72u8, 56u8,
                    19u8, 118u8, 139u8, 92u8, 202u8, 32u8, 42u8, 41u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " A config flag that, if set, instructs an authorization from a CDD provider in order to"]
            #[doc = " change the primary key of an identity."]
            #[cfg(feature = "ink")]
            pub fn cdd_auth_for_primary_key_rotation(
                &self,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                let value = self.api.read_storage(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 114u8, 149u8, 136u8, 2u8, 121u8, 4u8, 72u8, 56u8,
                    19u8, 118u8, 139u8, 92u8, 202u8, 32u8, 42u8, 41u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_identity::Version> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_identity::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_identity::Version> {
                let value = self.api.read_storage(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_identity::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " How many \"strong\" references to the account key."]
            #[doc = ""]
            #[doc = " Strong references will block a key from leaving it's identity."]
            #[doc = ""]
            #[doc = " Pallets using \"strong\" references to account keys:"]
            #[doc = " * Relayer: For `user_key` and `paying_key`"]
            #[doc = ""]
            #[cfg(not(feature = "ink"))]
            pub async fn account_key_ref_count(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 231u8, 18u8, 4u8, 202u8, 201u8, 201u8, 123u8, 37u8,
                    198u8, 89u8, 13u8, 191u8, 196u8, 34u8, 200u8, 154u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " How many \"strong\" references to the account key."]
            #[doc = ""]
            #[doc = " Strong references will block a key from leaving it's identity."]
            #[doc = ""]
            #[doc = " Pallets using \"strong\" references to account keys:"]
            #[doc = " * Relayer: For `user_key` and `paying_key`"]
            #[doc = ""]
            #[cfg(feature = "ink")]
            pub fn account_key_ref_count(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 231u8, 18u8, 4u8, 202u8, 201u8, 201u8, 123u8, 37u8,
                    198u8, 89u8, 13u8, 191u8, 196u8, 34u8, 200u8, 154u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Parent identity if the DID is a child Identity."]
            #[cfg(not(feature = "ink"))]
            pub async fn parent_did(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 187u8, 179u8, 70u8, 131u8, 158u8, 200u8, 210u8, 30u8,
                    255u8, 150u8, 252u8, 84u8, 192u8, 67u8, 126u8, 27u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Parent identity if the DID is a child Identity."]
            #[cfg(feature = "ink")]
            pub fn parent_did(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 187u8, 179u8, 70u8, 131u8, 158u8, 200u8, 210u8, 30u8,
                    255u8, 150u8, 252u8, 84u8, 192u8, 67u8, 126u8, 27u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " All child identities of a parent (i.e ParentDID, ChildDID, true)"]
            #[cfg(not(feature = "ink"))]
            pub async fn child_did(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 220u8, 79u8, 118u8, 156u8, 85u8, 150u8, 146u8, 163u8,
                    144u8, 61u8, 210u8, 112u8, 12u8, 48u8, 194u8, 208u8,
                ]);
                buf.extend(key_0.encode());
                buf.extend(key_1.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All child identities of a parent (i.e ParentDID, ChildDID, true)"]
            #[cfg(feature = "ink")]
            pub fn child_did(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 220u8, 79u8, 118u8, 156u8, 85u8, 150u8, 146u8, 163u8,
                    144u8, 61u8, 210u8, 112u8, 12u8, 48u8, 194u8, 208u8,
                ]);
                buf.extend(key_0.encode());
                buf.extend(key_1.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Track the number of authorizations given by each identity."]
            #[cfg(not(feature = "ink"))]
            pub async fn number_of_given_auths(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 101u8, 202u8, 103u8, 188u8, 53u8, 68u8, 42u8, 200u8,
                    90u8, 253u8, 255u8, 123u8, 93u8, 99u8, 239u8, 174u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Track the number of authorizations given by each identity."]
            #[cfg(feature = "ink")]
            pub fn number_of_given_auths(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 101u8, 202u8, 103u8, 188u8, 53u8, 68u8, 42u8, 200u8,
                    90u8, 253u8, 255u8, 123u8, 93u8, 99u8, 239u8, 174u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Tracks all authorizations that must be deleted"]
            #[cfg(not(feature = "ink"))]
            pub async fn outdated_authorizations(
                &self,
                key_0: types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
            ) -> ::polymesh_api_client::error::Result<Option<u64>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 254u8, 249u8, 229u8, 86u8, 138u8, 153u8, 19u8, 161u8,
                    120u8, 28u8, 28u8, 44u8, 9u8, 135u8, 124u8, 227u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Tracks all authorizations that must be deleted"]
            #[cfg(feature = "ink")]
            pub fn outdated_authorizations(
                &self,
                key_0: types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
            ) -> ::polymesh_api_ink::error::Result<Option<u64>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 254u8, 249u8, 229u8, 86u8, 138u8, 153u8, 19u8, 161u8,
                    120u8, 28u8, 28u8, 44u8, 9u8, 135u8, 124u8, 227u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Controls the authorization id."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_auth_id(&self) -> ::polymesh_api_client::error::Result<u64> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 44u8, 229u8, 229u8, 139u8, 191u8, 99u8, 68u8, 254u8,
                    197u8, 173u8, 240u8, 151u8, 160u8, 101u8, 208u8, 238u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Controls the authorization id."]
            #[cfg(feature = "ink")]
            pub fn current_auth_id(&self) -> ::polymesh_api_ink::error::Result<u64> {
                let value = self.api.read_storage(::alloc::vec![
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 44u8, 229u8, 229u8, 139u8, 191u8, 99u8, 68u8, 254u8,
                    197u8, 173u8, 240u8, 151u8, 160u8, 101u8, 208u8, 238u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct IdentityPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> IdentityPagedQueryApi<'api> {
            #[doc = " DID -> identity info"]
            pub fn did_records(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::IdentityId,
                types::polymesh_primitives::identity::DidRecord<::polymesh_api_client::AccountId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 116u8, 80u8, 50u8, 71u8, 155u8, 166u8, 193u8, 20u8,
                    243u8, 13u8, 15u8, 187u8, 81u8, 210u8, 17u8, 101u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " DID -> bool that indicates if secondary keys are frozen."]
            pub fn is_did_frozen(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 88u8, 25u8, 37u8, 70u8, 145u8, 206u8, 174u8, 76u8,
                    55u8, 194u8, 155u8, 126u8, 165u8, 90u8, 158u8, 251u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " (Target ID, claim type) (issuer,scope) -> Associated claims"]
            pub fn claims(
                &self,
                key_0: types::pallet_identity::types::Claim1stKey,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_identity::types::Claim2ndKey,
                types::polymesh_primitives::identity_claim::IdentityClaim,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 156u8, 93u8, 121u8, 93u8, 2u8, 151u8, 190u8, 86u8,
                    2u8, 122u8, 75u8, 36u8, 100u8, 227u8, 51u8, 151u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " CusotmClaimTypeId -> String constant"]
            pub fn custom_claims(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::identity_claim::CustomClaimTypeId,
                ::alloc::vec::Vec<u8>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 191u8, 149u8, 69u8, 57u8, 187u8, 49u8, 56u8, 118u8,
                    117u8, 181u8, 215u8, 96u8, 18u8, 206u8, 94u8, 232u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " String constant -> CustomClaimTypeId"]
            pub fn custom_claims_inverse(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::alloc::vec::Vec<u8>,
                types::polymesh_primitives::identity_claim::CustomClaimTypeId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 238u8, 140u8, 175u8, 222u8, 16u8, 43u8, 89u8, 2u8,
                    60u8, 101u8, 161u8, 89u8, 63u8, 155u8, 89u8, 216u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Map from AccountId to `KeyRecord` that holds the key's type and identity."]
            pub fn key_records(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::polymesh_primitives::secondary_key::KeyRecord<
                    ::polymesh_api_client::AccountId,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 140u8, 4u8, 71u8, 134u8, 27u8, 11u8, 130u8, 15u8,
                    11u8, 176u8, 222u8, 164u8, 7u8, 164u8, 75u8, 52u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " A secondary key's extrinsic permissions."]
            pub fn key_extrinsic_permissions(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 66u8, 215u8, 106u8, 150u8, 225u8, 217u8, 210u8, 44u8,
                    255u8, 38u8, 187u8, 4u8, 9u8, 185u8, 157u8, 131u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " A secondary key's asset permissions."]
            pub fn key_asset_permissions(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::polymesh_primitives::subset::SubsetRestriction<
                    ::polymesh_api_client::AssetId,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 185u8, 144u8, 42u8, 124u8, 79u8, 75u8, 50u8, 231u8,
                    22u8, 182u8, 5u8, 71u8, 190u8, 2u8, 122u8, 31u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " A secondary key's portfolio permissions."]
            pub fn key_portfolio_permissions(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::polymesh_primitives::subset::SubsetRestriction<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 51u8, 17u8, 209u8, 116u8, 254u8, 60u8, 114u8, 180u8,
                    75u8, 236u8, 206u8, 226u8, 14u8, 117u8, 212u8, 41u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " A reverse double map to allow finding all keys for an identity."]
            pub fn did_keys(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 48u8, 201u8, 137u8, 112u8, 80u8, 239u8, 164u8, 12u8,
                    73u8, 173u8, 249u8, 240u8, 185u8, 87u8, 20u8, 244u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Authorization nonce per Identity. Initially is 0."]
            pub fn off_chain_authorization_nonce(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, u64>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 180u8, 43u8, 244u8, 108u8, 4u8, 166u8, 74u8, 143u8,
                    8u8, 226u8, 206u8, 196u8, 229u8, 245u8, 62u8, 152u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " All authorizations that an identity/key has"]
            pub fn authorizations(
                &self,
                key_0: types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
            ) -> ::polymesh_api_client::StoragePaged<
                u64,
                types::polymesh_primitives::authorization::Authorization<
                    ::polymesh_api_client::AccountId,
                    u64,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 104u8, 58u8, 80u8, 244u8, 170u8, 112u8, 186u8, 34u8,
                    193u8, 127u8, 221u8, 184u8, 141u8, 38u8, 73u8, 43u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " All authorizations that an identity has given. (Authorizer, auth_id -> authorized)"]
            pub fn authorizations_given(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<
                u64,
                types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 31u8, 154u8, 92u8, 218u8, 166u8, 154u8, 225u8, 139u8,
                    48u8, 60u8, 199u8, 128u8, 85u8, 224u8, 137u8, 110u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " How many \"strong\" references to the account key."]
            #[doc = ""]
            #[doc = " Strong references will block a key from leaving it's identity."]
            #[doc = ""]
            #[doc = " Pallets using \"strong\" references to account keys:"]
            #[doc = " * Relayer: For `user_key` and `paying_key`"]
            #[doc = ""]
            pub fn account_key_ref_count(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 231u8, 18u8, 4u8, 202u8, 201u8, 201u8, 123u8, 37u8,
                    198u8, 89u8, 13u8, 191u8, 196u8, 34u8, 200u8, 154u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Parent identity if the DID is a child Identity."]
            pub fn parent_did(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::IdentityId,
                ::polymesh_api_client::IdentityId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 187u8, 179u8, 70u8, 131u8, 158u8, 200u8, 210u8, 30u8,
                    255u8, 150u8, 252u8, 84u8, 192u8, 67u8, 126u8, 27u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " All child identities of a parent (i.e ParentDID, ChildDID, true)"]
            pub fn child_did(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 220u8, 79u8, 118u8, 156u8, 85u8, 150u8, 146u8, 163u8,
                    144u8, 61u8, 210u8, 112u8, 12u8, 48u8, 194u8, 208u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " Track the number of authorizations given by each identity."]
            pub fn number_of_given_auths(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, u32>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 101u8, 202u8, 103u8, 188u8, 53u8, 68u8, 42u8, 200u8,
                    90u8, 253u8, 255u8, 123u8, 93u8, 99u8, 239u8, 174u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " Tracks all authorizations that must be deleted"]
            pub fn outdated_authorizations(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::secondary_key::Signatory<
                    ::polymesh_api_client::AccountId,
                >,
                u64,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    42u8, 237u8, 220u8, 119u8, 254u8, 88u8, 201u8, 141u8, 80u8, 189u8, 55u8, 241u8,
                    185u8, 8u8, 64u8, 249u8, 254u8, 249u8, 229u8, 86u8, 138u8, 153u8, 19u8, 161u8,
                    120u8, 28u8, 28u8, 44u8, 9u8, 135u8, 124u8, 227u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
        }
    }
    pub mod cdd_service_providers {
        use super::*;
        #[derive(Clone)]
        pub struct CddServiceProvidersCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> CddServiceProvidersCallApi<'api> {
            #[doc = "Change this group's limit for how many concurrent active members they may be."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `limit` - the number of active members there may be concurrently."]
            #[cfg(not(feature = "ink"))]
            pub fn set_active_members_limit(
                &self,
                limit: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CddServiceProviders (types :: pallet_group :: pallet :: UpgradeCommitteeMembershipCall :: set_active_members_limit { limit , }))
            }
            #[doc = "Change this group's limit for how many concurrent active members they may be."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `limit` - the number of active members there may be concurrently."]
            #[cfg(feature = "ink")]
            pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![8u8, 0u8];
                limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Disables a member at specific moment."]
            #[doc = ""]
            #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
            #[doc = "time-stamp will be updated."]
            #[doc = ""]
            #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
            #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
            #[doc = "generated claim issued before `at` would be considered as a valid one."]
            #[doc = ""]
            #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `at` - Revocation time-stamp."]
            #[doc = "* `who` - Target member of the group."]
            #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
            #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
            #[cfg(not(feature = "ink"))]
            pub fn disable_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
                expiry: Option<u64>,
                at: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::CddServiceProviders(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::disable_member {
                        who,
                        expiry,
                        at,
                    },
                ))
            }
            #[doc = "Disables a member at specific moment."]
            #[doc = ""]
            #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
            #[doc = "time-stamp will be updated."]
            #[doc = ""]
            #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
            #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
            #[doc = "generated claim issued before `at` would be considered as a valid one."]
            #[doc = ""]
            #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `at` - Revocation time-stamp."]
            #[doc = "* `who` - Target member of the group."]
            #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
            #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
            #[cfg(feature = "ink")]
            pub fn disable_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
                expiry: Option<u64>,
                at: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![8u8, 1u8];
                who.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                at.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
            #[doc = "* `who` - IdentityId to be added to the group."]
            #[cfg(not(feature = "ink"))]
            pub fn add_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::CddServiceProviders(
                        types::pallet_group::pallet::UpgradeCommitteeMembershipCall::add_member {
                            who,
                        },
                    ))
            }
            #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
            #[doc = "* `who` - IdentityId to be added to the group."]
            #[cfg(feature = "ink")]
            pub fn add_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![8u8, 2u8];
                who.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
            #[doc = ""]
            #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
            #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
            #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
            #[doc = "claims, you have to use `Self::disable_member` function"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
            #[doc = "* `who` - IdentityId to be removed from the group."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::CddServiceProviders(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::remove_member {
                        who,
                    },
                ))
            }
            #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
            #[doc = ""]
            #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
            #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
            #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
            #[doc = "claims, you have to use `Self::disable_member` function"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
            #[doc = "* `who` - IdentityId to be removed from the group."]
            #[cfg(feature = "ink")]
            pub fn remove_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![8u8, 3u8];
                who.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Swaps out one member `remove` for another member `add`."]
            #[doc = ""]
            #[doc = "May only be called from `SwapOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
            #[doc = "* `remove` - IdentityId to be removed from the group."]
            #[doc = "* `add` - IdentityId to be added in place of `remove`."]
            #[cfg(not(feature = "ink"))]
            pub fn swap_member(
                &self,
                remove: ::polymesh_api_client::IdentityId,
                add: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::CddServiceProviders(
                        types::pallet_group::pallet::UpgradeCommitteeMembershipCall::swap_member {
                            remove,
                            add,
                        },
                    ))
            }
            #[doc = "Swaps out one member `remove` for another member `add`."]
            #[doc = ""]
            #[doc = "May only be called from `SwapOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
            #[doc = "* `remove` - IdentityId to be removed from the group."]
            #[doc = "* `add` - IdentityId to be added in place of `remove`."]
            #[cfg(feature = "ink")]
            pub fn swap_member(
                &self,
                remove: ::polymesh_api_client::IdentityId,
                add: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![8u8, 4u8];
                remove.encode_to(&mut buf);
                add.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the membership to a new set, disregarding the existing membership."]
            #[doc = "May only be called from `ResetOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
            #[doc = "* `members` - New set of identities"]
            #[cfg(not(feature = "ink"))]
            pub fn reset_members(
                &self,
                members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::CddServiceProviders(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::reset_members {
                        members,
                    },
                ))
            }
            #[doc = "Changes the membership to a new set, disregarding the existing membership."]
            #[doc = "May only be called from `ResetOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
            #[doc = "* `members` - New set of identities"]
            #[cfg(feature = "ink")]
            pub fn reset_members(
                &self,
                members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![8u8, 5u8];
                members.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
            #[doc = "vote."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Member of committee who wants to quit."]
            #[doc = ""]
            #[doc = "# Error"]
            #[doc = ""]
            #[doc = "* Only primary key can abdicate."]
            #[doc = "* Last member of a group cannot abdicate."]
            #[cfg(not(feature = "ink"))]
            pub fn abdicate_membership(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CddServiceProviders (types :: pallet_group :: pallet :: UpgradeCommitteeMembershipCall :: abdicate_membership))
            }
            #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
            #[doc = "vote."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Member of committee who wants to quit."]
            #[doc = ""]
            #[doc = "# Error"]
            #[doc = ""]
            #[doc = "* Only primary key can abdicate."]
            #[doc = "* Last member of a group cannot abdicate."]
            #[cfg(feature = "ink")]
            pub fn abdicate_membership(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![8u8, 6u8])
            }
        }
        impl<'api> From<&'api super::super::Api> for CddServiceProvidersCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct CddServiceProvidersQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> CddServiceProvidersQueryApi<'api> {
            #[doc = " The current \"active\" membership, stored as an ordered Vec."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    150u8, 235u8, 107u8, 240u8, 236u8, 147u8, 11u8, 34u8, 6u8, 222u8, 142u8, 251u8,
                    247u8, 247u8, 146u8, 87u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8,
                    138u8, 14u8, 159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current \"active\" membership, stored as an ordered Vec."]
            #[cfg(feature = "ink")]
            pub fn active_members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    150u8, 235u8, 107u8, 240u8, 236u8, 147u8, 11u8, 34u8, 6u8, 222u8, 142u8, 251u8,
                    247u8, 247u8, 146u8, 87u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8,
                    138u8, 14u8, 159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
            #[cfg(not(feature = "ink"))]
            pub async fn inactive_members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::traits::group::InactiveMember<u64>>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    150u8, 235u8, 107u8, 240u8, 236u8, 147u8, 11u8, 34u8, 6u8, 222u8, 142u8, 251u8,
                    247u8, 247u8, 146u8, 87u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8,
                    81u8, 34u8, 107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::polymesh_primitives::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
            #[cfg(feature = "ink")]
            pub fn inactive_members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::traits::group::InactiveMember<u64>>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    150u8, 235u8, 107u8, 240u8, 236u8, 147u8, 11u8, 34u8, 6u8, 222u8, 142u8, 251u8,
                    247u8, 247u8, 146u8, 87u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8,
                    81u8, 34u8, 107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::polymesh_primitives::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Limit of how many \"active\" members there can be."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    150u8, 235u8, 107u8, 240u8, 236u8, 147u8, 11u8, 34u8, 6u8, 222u8, 142u8, 251u8,
                    247u8, 247u8, 146u8, 87u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8,
                    97u8, 92u8, 160u8, 7u8, 124u8, 249u8, 110u8, 183u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Limit of how many \"active\" members there can be."]
            #[cfg(feature = "ink")]
            pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    150u8, 235u8, 107u8, 240u8, 236u8, 147u8, 11u8, 34u8, 6u8, 222u8, 142u8, 251u8,
                    247u8, 247u8, 146u8, 87u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8,
                    97u8, 92u8, 160u8, 7u8, 124u8, 249u8, 110u8, 183u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct CddServiceProvidersPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> CddServiceProvidersPagedQueryApi<'api> {}
    }
    pub mod polymesh_committee {
        use super::*;
        #[derive(Clone)]
        pub struct PolymeshCommitteeCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> PolymeshCommitteeCallApi<'api> {
            #[doc = "Change the vote threshold the determines the winning proposal."]
            #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
            #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
            #[cfg(not(feature = "ink"))]
            pub fn set_vote_threshold(
                &self,
                n: u32,
                d: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::set_vote_threshold {
                        n,
                        d,
                    },
                ))
            }
            #[doc = "Change the vote threshold the determines the winning proposal."]
            #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
            #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
            #[cfg(feature = "ink")]
            pub fn set_vote_threshold(&self, n: u32, d: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![9u8, 0u8];
                n.encode_to(&mut buf);
                d.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the release coordinator."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - The DID of the new release coordinator."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
            #[cfg(not(feature = "ink"))]
            pub fn set_release_coordinator(
                &self,
                id: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: PolymeshCommittee (types :: pallet_committee :: pallet :: UpgradeCommitteeCall :: set_release_coordinator { id , }))
            }
            #[doc = "Changes the release coordinator."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - The DID of the new release coordinator."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
            #[cfg(feature = "ink")]
            pub fn set_release_coordinator(
                &self,
                id: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![9u8, 1u8];
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the time after which a proposal expires."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `expiry` - The new expiry time."]
            #[cfg(not(feature = "ink"))]
            pub fn set_expires_after(
                &self,
                expiry: types::polymesh_primitives::MaybeBlock<u32>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::set_expires_after {
                        expiry,
                    },
                ))
            }
            #[doc = "Changes the time after which a proposal expires."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `expiry` - The new expiry time."]
            #[cfg(feature = "ink")]
            pub fn set_expires_after(
                &self,
                expiry: types::polymesh_primitives::MaybeBlock<u32>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![9u8, 2u8];
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Proposes to the committee that `call` should be executed in its name."]
            #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
            #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
            #[doc = ""]
            #[doc = "# Weight"]
            #[doc = ""]
            #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
            #[doc = "for recording the vote itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `approve` - is this an approving vote?"]
            #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
            #[doc = "* `call` - the call to propose for execution."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(not(feature = "ink"))]
            pub fn vote_or_propose(
                &self,
                approve: bool,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::vote_or_propose {
                        approve,
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Proposes to the committee that `call` should be executed in its name."]
            #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
            #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
            #[doc = ""]
            #[doc = "# Weight"]
            #[doc = ""]
            #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
            #[doc = "for recording the vote itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `approve` - is this an approving vote?"]
            #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
            #[doc = "* `call` - the call to propose for execution."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(feature = "ink")]
            pub fn vote_or_propose(
                &self,
                approve: bool,
                call: runtime::RuntimeCall,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![9u8, 3u8];
                approve.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Votes `approve`ingly (or not, if `false`)"]
            #[doc = "on an existing `proposal` given by its hash, `index`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `proposal` - A hash of the proposal to be voted on."]
            #[doc = "* `index` - The proposal index."]
            #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(not(feature = "ink"))]
            pub fn vote(
                &self,
                proposal: types::primitive_types::H256,
                index: u32,
                approve: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::PolymeshCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::vote {
                        proposal,
                        index,
                        approve,
                    },
                ))
            }
            #[doc = "Votes `approve`ingly (or not, if `false`)"]
            #[doc = "on an existing `proposal` given by its hash, `index`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `proposal` - A hash of the proposal to be voted on."]
            #[doc = "* `index` - The proposal index."]
            #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(feature = "ink")]
            pub fn vote(
                &self,
                proposal: types::primitive_types::H256,
                index: u32,
                approve: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![9u8, 4u8];
                proposal.encode_to(&mut buf);
                index.encode_to(&mut buf);
                approve.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for PolymeshCommitteeCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct PolymeshCommitteeQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> PolymeshCommitteeQueryApi<'api> {
            #[doc = " The hashes of the active proposals."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposals(
                &self,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8,
                    29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The hashes of the active proposals."]
            #[cfg(feature = "ink")]
            pub fn proposals(
                &self,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8,
                    29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Actual proposal for a given hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_of(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8,
                    121u8, 147u8, 11u8, 195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Actual proposal for a given hash."]
            #[cfg(feature = "ink")]
            pub fn proposal_of(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8,
                    121u8, 147u8, 11u8, 195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
            #[cfg(not(feature = "ink"))]
            pub async fn voting(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_committee::pallet::PolymeshVotes<u32>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8,
                    251u8, 57u8, 43u8, 121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
            #[cfg(feature = "ink")]
            pub fn voting(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_committee::pallet::PolymeshVotes<u32>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8,
                    251u8, 57u8, 43u8, 121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Proposals so far."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_count(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8,
                    162u8, 166u8, 43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Proposals so far."]
            #[cfg(feature = "ink")]
            pub fn proposal_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8,
                    162u8, 166u8, 43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The current members of the committee."]
            #[cfg(not(feature = "ink"))]
            pub async fn members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8,
                    226u8, 162u8, 198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current members of the committee."]
            #[cfg(feature = "ink")]
            pub fn members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8,
                    226u8, 162u8, 198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Vote threshold for an approval."]
            #[cfg(not(feature = "ink"))]
            pub async fn vote_threshold(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8,
                    113u8, 204u8, 101u8, 23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Vote threshold for an approval."]
            #[cfg(feature = "ink")]
            pub fn vote_threshold(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
                let value = self.api.read_storage(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8,
                    113u8, 204u8, 101u8, 23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Release cooridinator."]
            #[cfg(not(feature = "ink"))]
            pub async fn release_coordinator(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8,
                    153u8, 133u8, 116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Release cooridinator."]
            #[cfg(feature = "ink")]
            pub fn release_coordinator(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8,
                    153u8, 133u8, 116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
                ])?;
                Ok(value)
            }
            #[doc = " Time after which a proposal will expire."]
            #[cfg(not(feature = "ink"))]
            pub async fn expires_after(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::MaybeBlock<u32>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8,
                    113u8, 75u8, 210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8];
                    <types::polymesh_primitives::MaybeBlock<u32>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Time after which a proposal will expire."]
            #[cfg(feature = "ink")]
            pub fn expires_after(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::MaybeBlock<u32>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8,
                    113u8, 75u8, 210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8];
                    <types::polymesh_primitives::MaybeBlock<u32>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct PolymeshCommitteePagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> PolymeshCommitteePagedQueryApi<'api> {
            #[doc = " Actual proposal for a given hash."]
            pub fn proposal_of(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                runtime::RuntimeCall,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8,
                    121u8, 147u8, 11u8, 195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
            pub fn voting(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                types::pallet_committee::pallet::PolymeshVotes<u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    248u8, 98u8, 43u8, 33u8, 229u8, 216u8, 45u8, 59u8, 122u8, 128u8, 45u8, 206u8,
                    102u8, 181u8, 121u8, 26u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8,
                    251u8, 57u8, 43u8, 121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
        }
    }
    pub mod committee_membership {
        use super::*;
        #[derive(Clone)]
        pub struct CommitteeMembershipCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> CommitteeMembershipCallApi<'api> {
            #[doc = "Change this group's limit for how many concurrent active members they may be."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `limit` - the number of active members there may be concurrently."]
            #[cfg(not(feature = "ink"))]
            pub fn set_active_members_limit(
                &self,
                limit: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CommitteeMembership (types :: pallet_group :: pallet :: UpgradeCommitteeMembershipCall :: set_active_members_limit { limit , }))
            }
            #[doc = "Change this group's limit for how many concurrent active members they may be."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `limit` - the number of active members there may be concurrently."]
            #[cfg(feature = "ink")]
            pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![10u8, 0u8];
                limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Disables a member at specific moment."]
            #[doc = ""]
            #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
            #[doc = "time-stamp will be updated."]
            #[doc = ""]
            #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
            #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
            #[doc = "generated claim issued before `at` would be considered as a valid one."]
            #[doc = ""]
            #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `at` - Revocation time-stamp."]
            #[doc = "* `who` - Target member of the group."]
            #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
            #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
            #[cfg(not(feature = "ink"))]
            pub fn disable_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
                expiry: Option<u64>,
                at: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::CommitteeMembership(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::disable_member {
                        who,
                        expiry,
                        at,
                    },
                ))
            }
            #[doc = "Disables a member at specific moment."]
            #[doc = ""]
            #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
            #[doc = "time-stamp will be updated."]
            #[doc = ""]
            #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
            #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
            #[doc = "generated claim issued before `at` would be considered as a valid one."]
            #[doc = ""]
            #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `at` - Revocation time-stamp."]
            #[doc = "* `who` - Target member of the group."]
            #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
            #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
            #[cfg(feature = "ink")]
            pub fn disable_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
                expiry: Option<u64>,
                at: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![10u8, 1u8];
                who.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                at.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
            #[doc = "* `who` - IdentityId to be added to the group."]
            #[cfg(not(feature = "ink"))]
            pub fn add_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::CommitteeMembership(
                        types::pallet_group::pallet::UpgradeCommitteeMembershipCall::add_member {
                            who,
                        },
                    ))
            }
            #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
            #[doc = "* `who` - IdentityId to be added to the group."]
            #[cfg(feature = "ink")]
            pub fn add_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![10u8, 2u8];
                who.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
            #[doc = ""]
            #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
            #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
            #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
            #[doc = "claims, you have to use `Self::disable_member` function"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
            #[doc = "* `who` - IdentityId to be removed from the group."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::CommitteeMembership(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::remove_member {
                        who,
                    },
                ))
            }
            #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
            #[doc = ""]
            #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
            #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
            #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
            #[doc = "claims, you have to use `Self::disable_member` function"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
            #[doc = "* `who` - IdentityId to be removed from the group."]
            #[cfg(feature = "ink")]
            pub fn remove_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![10u8, 3u8];
                who.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Swaps out one member `remove` for another member `add`."]
            #[doc = ""]
            #[doc = "May only be called from `SwapOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
            #[doc = "* `remove` - IdentityId to be removed from the group."]
            #[doc = "* `add` - IdentityId to be added in place of `remove`."]
            #[cfg(not(feature = "ink"))]
            pub fn swap_member(
                &self,
                remove: ::polymesh_api_client::IdentityId,
                add: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::CommitteeMembership(
                        types::pallet_group::pallet::UpgradeCommitteeMembershipCall::swap_member {
                            remove,
                            add,
                        },
                    ))
            }
            #[doc = "Swaps out one member `remove` for another member `add`."]
            #[doc = ""]
            #[doc = "May only be called from `SwapOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
            #[doc = "* `remove` - IdentityId to be removed from the group."]
            #[doc = "* `add` - IdentityId to be added in place of `remove`."]
            #[cfg(feature = "ink")]
            pub fn swap_member(
                &self,
                remove: ::polymesh_api_client::IdentityId,
                add: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![10u8, 4u8];
                remove.encode_to(&mut buf);
                add.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the membership to a new set, disregarding the existing membership."]
            #[doc = "May only be called from `ResetOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
            #[doc = "* `members` - New set of identities"]
            #[cfg(not(feature = "ink"))]
            pub fn reset_members(
                &self,
                members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::CommitteeMembership(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::reset_members {
                        members,
                    },
                ))
            }
            #[doc = "Changes the membership to a new set, disregarding the existing membership."]
            #[doc = "May only be called from `ResetOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
            #[doc = "* `members` - New set of identities"]
            #[cfg(feature = "ink")]
            pub fn reset_members(
                &self,
                members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![10u8, 5u8];
                members.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
            #[doc = "vote."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Member of committee who wants to quit."]
            #[doc = ""]
            #[doc = "# Error"]
            #[doc = ""]
            #[doc = "* Only primary key can abdicate."]
            #[doc = "* Last member of a group cannot abdicate."]
            #[cfg(not(feature = "ink"))]
            pub fn abdicate_membership(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CommitteeMembership (types :: pallet_group :: pallet :: UpgradeCommitteeMembershipCall :: abdicate_membership))
            }
            #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
            #[doc = "vote."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Member of committee who wants to quit."]
            #[doc = ""]
            #[doc = "# Error"]
            #[doc = ""]
            #[doc = "* Only primary key can abdicate."]
            #[doc = "* Last member of a group cannot abdicate."]
            #[cfg(feature = "ink")]
            pub fn abdicate_membership(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![10u8, 6u8])
            }
        }
        impl<'api> From<&'api super::super::Api> for CommitteeMembershipCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct CommitteeMembershipQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> CommitteeMembershipQueryApi<'api> {
            #[doc = " The current \"active\" membership, stored as an ordered Vec."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    46u8, 228u8, 39u8, 143u8, 249u8, 200u8, 200u8, 193u8, 52u8, 172u8, 199u8,
                    114u8, 182u8, 21u8, 143u8, 99u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8,
                    14u8, 138u8, 14u8, 159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current \"active\" membership, stored as an ordered Vec."]
            #[cfg(feature = "ink")]
            pub fn active_members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    46u8, 228u8, 39u8, 143u8, 249u8, 200u8, 200u8, 193u8, 52u8, 172u8, 199u8,
                    114u8, 182u8, 21u8, 143u8, 99u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8,
                    14u8, 138u8, 14u8, 159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
            #[cfg(not(feature = "ink"))]
            pub async fn inactive_members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::traits::group::InactiveMember<u64>>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    46u8, 228u8, 39u8, 143u8, 249u8, 200u8, 200u8, 193u8, 52u8, 172u8, 199u8,
                    114u8, 182u8, 21u8, 143u8, 99u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8,
                    102u8, 81u8, 34u8, 107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::polymesh_primitives::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
            #[cfg(feature = "ink")]
            pub fn inactive_members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::traits::group::InactiveMember<u64>>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    46u8, 228u8, 39u8, 143u8, 249u8, 200u8, 200u8, 193u8, 52u8, 172u8, 199u8,
                    114u8, 182u8, 21u8, 143u8, 99u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8,
                    102u8, 81u8, 34u8, 107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::polymesh_primitives::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Limit of how many \"active\" members there can be."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    46u8, 228u8, 39u8, 143u8, 249u8, 200u8, 200u8, 193u8, 52u8, 172u8, 199u8,
                    114u8, 182u8, 21u8, 143u8, 99u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8,
                    73u8, 97u8, 92u8, 160u8, 7u8, 124u8, 249u8, 110u8, 183u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Limit of how many \"active\" members there can be."]
            #[cfg(feature = "ink")]
            pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    46u8, 228u8, 39u8, 143u8, 249u8, 200u8, 200u8, 193u8, 52u8, 172u8, 199u8,
                    114u8, 182u8, 21u8, 143u8, 99u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8,
                    73u8, 97u8, 92u8, 160u8, 7u8, 124u8, 249u8, 110u8, 183u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct CommitteeMembershipPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> CommitteeMembershipPagedQueryApi<'api> {}
    }
    pub mod technical_committee {
        use super::*;
        #[derive(Clone)]
        pub struct TechnicalCommitteeCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> TechnicalCommitteeCallApi<'api> {
            #[doc = "Change the vote threshold the determines the winning proposal."]
            #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
            #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
            #[cfg(not(feature = "ink"))]
            pub fn set_vote_threshold(
                &self,
                n: u32,
                d: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::set_vote_threshold {
                        n,
                        d,
                    },
                ))
            }
            #[doc = "Change the vote threshold the determines the winning proposal."]
            #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
            #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
            #[cfg(feature = "ink")]
            pub fn set_vote_threshold(&self, n: u32, d: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![11u8, 0u8];
                n.encode_to(&mut buf);
                d.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the release coordinator."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - The DID of the new release coordinator."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
            #[cfg(not(feature = "ink"))]
            pub fn set_release_coordinator(
                &self,
                id: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: TechnicalCommittee (types :: pallet_committee :: pallet :: UpgradeCommitteeCall :: set_release_coordinator { id , }))
            }
            #[doc = "Changes the release coordinator."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - The DID of the new release coordinator."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
            #[cfg(feature = "ink")]
            pub fn set_release_coordinator(
                &self,
                id: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![11u8, 1u8];
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the time after which a proposal expires."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `expiry` - The new expiry time."]
            #[cfg(not(feature = "ink"))]
            pub fn set_expires_after(
                &self,
                expiry: types::polymesh_primitives::MaybeBlock<u32>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::set_expires_after {
                        expiry,
                    },
                ))
            }
            #[doc = "Changes the time after which a proposal expires."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `expiry` - The new expiry time."]
            #[cfg(feature = "ink")]
            pub fn set_expires_after(
                &self,
                expiry: types::polymesh_primitives::MaybeBlock<u32>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![11u8, 2u8];
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Proposes to the committee that `call` should be executed in its name."]
            #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
            #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
            #[doc = ""]
            #[doc = "# Weight"]
            #[doc = ""]
            #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
            #[doc = "for recording the vote itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `approve` - is this an approving vote?"]
            #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
            #[doc = "* `call` - the call to propose for execution."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(not(feature = "ink"))]
            pub fn vote_or_propose(
                &self,
                approve: bool,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::vote_or_propose {
                        approve,
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Proposes to the committee that `call` should be executed in its name."]
            #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
            #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
            #[doc = ""]
            #[doc = "# Weight"]
            #[doc = ""]
            #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
            #[doc = "for recording the vote itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `approve` - is this an approving vote?"]
            #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
            #[doc = "* `call` - the call to propose for execution."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(feature = "ink")]
            pub fn vote_or_propose(
                &self,
                approve: bool,
                call: runtime::RuntimeCall,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![11u8, 3u8];
                approve.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Votes `approve`ingly (or not, if `false`)"]
            #[doc = "on an existing `proposal` given by its hash, `index`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `proposal` - A hash of the proposal to be voted on."]
            #[doc = "* `index` - The proposal index."]
            #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(not(feature = "ink"))]
            pub fn vote(
                &self,
                proposal: types::primitive_types::H256,
                index: u32,
                approve: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::TechnicalCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::vote {
                        proposal,
                        index,
                        approve,
                    },
                ))
            }
            #[doc = "Votes `approve`ingly (or not, if `false`)"]
            #[doc = "on an existing `proposal` given by its hash, `index`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `proposal` - A hash of the proposal to be voted on."]
            #[doc = "* `index` - The proposal index."]
            #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(feature = "ink")]
            pub fn vote(
                &self,
                proposal: types::primitive_types::H256,
                index: u32,
                approve: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![11u8, 4u8];
                proposal.encode_to(&mut buf);
                index.encode_to(&mut buf);
                approve.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for TechnicalCommitteeCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct TechnicalCommitteeQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> TechnicalCommitteeQueryApi<'api> {
            #[doc = " The hashes of the active proposals."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposals(
                &self,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8,
                    29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The hashes of the active proposals."]
            #[cfg(feature = "ink")]
            pub fn proposals(
                &self,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8,
                    29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Actual proposal for a given hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_of(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8,
                    121u8, 147u8, 11u8, 195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Actual proposal for a given hash."]
            #[cfg(feature = "ink")]
            pub fn proposal_of(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8,
                    121u8, 147u8, 11u8, 195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
            #[cfg(not(feature = "ink"))]
            pub async fn voting(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_committee::pallet::PolymeshVotes<u32>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8,
                    251u8, 57u8, 43u8, 121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
            #[cfg(feature = "ink")]
            pub fn voting(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_committee::pallet::PolymeshVotes<u32>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8,
                    251u8, 57u8, 43u8, 121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Proposals so far."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_count(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8,
                    162u8, 166u8, 43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Proposals so far."]
            #[cfg(feature = "ink")]
            pub fn proposal_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8,
                    162u8, 166u8, 43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The current members of the committee."]
            #[cfg(not(feature = "ink"))]
            pub async fn members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8,
                    59u8, 226u8, 162u8, 198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current members of the committee."]
            #[cfg(feature = "ink")]
            pub fn members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8,
                    59u8, 226u8, 162u8, 198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Vote threshold for an approval."]
            #[cfg(not(feature = "ink"))]
            pub async fn vote_threshold(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8,
                    113u8, 204u8, 101u8, 23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Vote threshold for an approval."]
            #[cfg(feature = "ink")]
            pub fn vote_threshold(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8,
                    113u8, 204u8, 101u8, 23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Release cooridinator."]
            #[cfg(not(feature = "ink"))]
            pub async fn release_coordinator(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8,
                    153u8, 133u8, 116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Release cooridinator."]
            #[cfg(feature = "ink")]
            pub fn release_coordinator(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8,
                    153u8, 133u8, 116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
                ])?;
                Ok(value)
            }
            #[doc = " Time after which a proposal will expire."]
            #[cfg(not(feature = "ink"))]
            pub async fn expires_after(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::MaybeBlock<u32>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8,
                    61u8, 113u8, 75u8, 210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8];
                    <types::polymesh_primitives::MaybeBlock<u32>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Time after which a proposal will expire."]
            #[cfg(feature = "ink")]
            pub fn expires_after(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::MaybeBlock<u32>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8,
                    61u8, 113u8, 75u8, 210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8];
                    <types::polymesh_primitives::MaybeBlock<u32>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct TechnicalCommitteePagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> TechnicalCommitteePagedQueryApi<'api> {
            #[doc = " Actual proposal for a given hash."]
            pub fn proposal_of(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                runtime::RuntimeCall,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8,
                    121u8, 147u8, 11u8, 195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
            pub fn voting(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                types::pallet_committee::pallet::PolymeshVotes<u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    237u8, 37u8, 246u8, 57u8, 66u8, 222u8, 37u8, 172u8, 82u8, 83u8, 186u8, 100u8,
                    181u8, 235u8, 100u8, 209u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8,
                    251u8, 57u8, 43u8, 121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
        }
    }
    pub mod technical_committee_membership {
        use super::*;
        #[derive(Clone)]
        pub struct TechnicalCommitteeMembershipCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> TechnicalCommitteeMembershipCallApi<'api> {
            #[doc = "Change this group's limit for how many concurrent active members they may be."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `limit` - the number of active members there may be concurrently."]
            #[cfg(not(feature = "ink"))]
            pub fn set_active_members_limit(
                &self,
                limit: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: TechnicalCommitteeMembership (types :: pallet_group :: pallet :: UpgradeCommitteeMembershipCall :: set_active_members_limit { limit , }))
            }
            #[doc = "Change this group's limit for how many concurrent active members they may be."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `limit` - the number of active members there may be concurrently."]
            #[cfg(feature = "ink")]
            pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![12u8, 0u8];
                limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Disables a member at specific moment."]
            #[doc = ""]
            #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
            #[doc = "time-stamp will be updated."]
            #[doc = ""]
            #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
            #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
            #[doc = "generated claim issued before `at` would be considered as a valid one."]
            #[doc = ""]
            #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `at` - Revocation time-stamp."]
            #[doc = "* `who` - Target member of the group."]
            #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
            #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
            #[cfg(not(feature = "ink"))]
            pub fn disable_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
                expiry: Option<u64>,
                at: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::disable_member {
                        who,
                        expiry,
                        at,
                    },
                ))
            }
            #[doc = "Disables a member at specific moment."]
            #[doc = ""]
            #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
            #[doc = "time-stamp will be updated."]
            #[doc = ""]
            #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
            #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
            #[doc = "generated claim issued before `at` would be considered as a valid one."]
            #[doc = ""]
            #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `at` - Revocation time-stamp."]
            #[doc = "* `who` - Target member of the group."]
            #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
            #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
            #[cfg(feature = "ink")]
            pub fn disable_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
                expiry: Option<u64>,
                at: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![12u8, 1u8];
                who.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                at.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
            #[doc = "* `who` - IdentityId to be added to the group."]
            #[cfg(not(feature = "ink"))]
            pub fn add_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
                        types::pallet_group::pallet::UpgradeCommitteeMembershipCall::add_member {
                            who,
                        },
                    ))
            }
            #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
            #[doc = "* `who` - IdentityId to be added to the group."]
            #[cfg(feature = "ink")]
            pub fn add_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![12u8, 2u8];
                who.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
            #[doc = ""]
            #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
            #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
            #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
            #[doc = "claims, you have to use `Self::disable_member` function"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
            #[doc = "* `who` - IdentityId to be removed from the group."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::remove_member {
                        who,
                    },
                ))
            }
            #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
            #[doc = ""]
            #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
            #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
            #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
            #[doc = "claims, you have to use `Self::disable_member` function"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
            #[doc = "* `who` - IdentityId to be removed from the group."]
            #[cfg(feature = "ink")]
            pub fn remove_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![12u8, 3u8];
                who.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Swaps out one member `remove` for another member `add`."]
            #[doc = ""]
            #[doc = "May only be called from `SwapOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
            #[doc = "* `remove` - IdentityId to be removed from the group."]
            #[doc = "* `add` - IdentityId to be added in place of `remove`."]
            #[cfg(not(feature = "ink"))]
            pub fn swap_member(
                &self,
                remove: ::polymesh_api_client::IdentityId,
                add: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
                        types::pallet_group::pallet::UpgradeCommitteeMembershipCall::swap_member {
                            remove,
                            add,
                        },
                    ))
            }
            #[doc = "Swaps out one member `remove` for another member `add`."]
            #[doc = ""]
            #[doc = "May only be called from `SwapOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
            #[doc = "* `remove` - IdentityId to be removed from the group."]
            #[doc = "* `add` - IdentityId to be added in place of `remove`."]
            #[cfg(feature = "ink")]
            pub fn swap_member(
                &self,
                remove: ::polymesh_api_client::IdentityId,
                add: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![12u8, 4u8];
                remove.encode_to(&mut buf);
                add.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the membership to a new set, disregarding the existing membership."]
            #[doc = "May only be called from `ResetOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
            #[doc = "* `members` - New set of identities"]
            #[cfg(not(feature = "ink"))]
            pub fn reset_members(
                &self,
                members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::TechnicalCommitteeMembership(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::reset_members {
                        members,
                    },
                ))
            }
            #[doc = "Changes the membership to a new set, disregarding the existing membership."]
            #[doc = "May only be called from `ResetOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
            #[doc = "* `members` - New set of identities"]
            #[cfg(feature = "ink")]
            pub fn reset_members(
                &self,
                members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![12u8, 5u8];
                members.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
            #[doc = "vote."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Member of committee who wants to quit."]
            #[doc = ""]
            #[doc = "# Error"]
            #[doc = ""]
            #[doc = "* Only primary key can abdicate."]
            #[doc = "* Last member of a group cannot abdicate."]
            #[cfg(not(feature = "ink"))]
            pub fn abdicate_membership(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: TechnicalCommitteeMembership (types :: pallet_group :: pallet :: UpgradeCommitteeMembershipCall :: abdicate_membership))
            }
            #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
            #[doc = "vote."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Member of committee who wants to quit."]
            #[doc = ""]
            #[doc = "# Error"]
            #[doc = ""]
            #[doc = "* Only primary key can abdicate."]
            #[doc = "* Last member of a group cannot abdicate."]
            #[cfg(feature = "ink")]
            pub fn abdicate_membership(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![12u8, 6u8])
            }
        }
        impl<'api> From<&'api super::super::Api> for TechnicalCommitteeMembershipCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct TechnicalCommitteeMembershipQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> TechnicalCommitteeMembershipQueryApi<'api> {
            #[doc = " The current \"active\" membership, stored as an ordered Vec."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    92u8, 4u8, 9u8, 209u8, 189u8, 43u8, 77u8, 170u8, 47u8, 109u8, 102u8, 6u8, 59u8,
                    8u8, 155u8, 83u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8,
                    14u8, 159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current \"active\" membership, stored as an ordered Vec."]
            #[cfg(feature = "ink")]
            pub fn active_members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    92u8, 4u8, 9u8, 209u8, 189u8, 43u8, 77u8, 170u8, 47u8, 109u8, 102u8, 6u8, 59u8,
                    8u8, 155u8, 83u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8, 138u8,
                    14u8, 159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
            #[cfg(not(feature = "ink"))]
            pub async fn inactive_members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::traits::group::InactiveMember<u64>>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    92u8, 4u8, 9u8, 209u8, 189u8, 43u8, 77u8, 170u8, 47u8, 109u8, 102u8, 6u8, 59u8,
                    8u8, 155u8, 83u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8,
                    34u8, 107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::polymesh_primitives::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
            #[cfg(feature = "ink")]
            pub fn inactive_members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::traits::group::InactiveMember<u64>>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    92u8, 4u8, 9u8, 209u8, 189u8, 43u8, 77u8, 170u8, 47u8, 109u8, 102u8, 6u8, 59u8,
                    8u8, 155u8, 83u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8, 81u8,
                    34u8, 107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::polymesh_primitives::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Limit of how many \"active\" members there can be."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    92u8, 4u8, 9u8, 209u8, 189u8, 43u8, 77u8, 170u8, 47u8, 109u8, 102u8, 6u8, 59u8,
                    8u8, 155u8, 83u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8,
                    92u8, 160u8, 7u8, 124u8, 249u8, 110u8, 183u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Limit of how many \"active\" members there can be."]
            #[cfg(feature = "ink")]
            pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    92u8, 4u8, 9u8, 209u8, 189u8, 43u8, 77u8, 170u8, 47u8, 109u8, 102u8, 6u8, 59u8,
                    8u8, 155u8, 83u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8, 97u8,
                    92u8, 160u8, 7u8, 124u8, 249u8, 110u8, 183u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct TechnicalCommitteeMembershipPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> TechnicalCommitteeMembershipPagedQueryApi<'api> {}
    }
    pub mod upgrade_committee {
        use super::*;
        #[derive(Clone)]
        pub struct UpgradeCommitteeCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> UpgradeCommitteeCallApi<'api> {
            #[doc = "Change the vote threshold the determines the winning proposal."]
            #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
            #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
            #[cfg(not(feature = "ink"))]
            pub fn set_vote_threshold(
                &self,
                n: u32,
                d: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::set_vote_threshold {
                        n,
                        d,
                    },
                ))
            }
            #[doc = "Change the vote threshold the determines the winning proposal."]
            #[doc = "For e.g., for a simple majority use (1, 2) which represents the in-equation \">= 1/2\"."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `n` - Numerator of the fraction representing vote threshold."]
            #[doc = "* `d` - Denominator of the fraction representing vote threshold."]
            #[cfg(feature = "ink")]
            pub fn set_vote_threshold(&self, n: u32, d: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![13u8, 0u8];
                n.encode_to(&mut buf);
                d.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the release coordinator."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - The DID of the new release coordinator."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
            #[cfg(not(feature = "ink"))]
            pub fn set_release_coordinator(
                &self,
                id: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: UpgradeCommittee (types :: pallet_committee :: pallet :: UpgradeCommitteeCall :: set_release_coordinator { id , }))
            }
            #[doc = "Changes the release coordinator."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - The DID of the new release coordinator."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, If the new coordinator `id` is not part of the committee."]
            #[cfg(feature = "ink")]
            pub fn set_release_coordinator(
                &self,
                id: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![13u8, 1u8];
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the time after which a proposal expires."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `expiry` - The new expiry time."]
            #[cfg(not(feature = "ink"))]
            pub fn set_expires_after(
                &self,
                expiry: types::polymesh_primitives::MaybeBlock<u32>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::set_expires_after {
                        expiry,
                    },
                ))
            }
            #[doc = "Changes the time after which a proposal expires."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `expiry` - The new expiry time."]
            #[cfg(feature = "ink")]
            pub fn set_expires_after(
                &self,
                expiry: types::polymesh_primitives::MaybeBlock<u32>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![13u8, 2u8];
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Proposes to the committee that `call` should be executed in its name."]
            #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
            #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
            #[doc = ""]
            #[doc = "# Weight"]
            #[doc = ""]
            #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
            #[doc = "for recording the vote itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `approve` - is this an approving vote?"]
            #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
            #[doc = "* `call` - the call to propose for execution."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(not(feature = "ink"))]
            pub fn vote_or_propose(
                &self,
                approve: bool,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::vote_or_propose {
                        approve,
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Proposes to the committee that `call` should be executed in its name."]
            #[doc = "Alternatively, if the hash of `call` has already been recorded, i.e., already proposed,"]
            #[doc = "then this call counts as a vote, i.e., as if `vote_by_hash` was called."]
            #[doc = ""]
            #[doc = "# Weight"]
            #[doc = ""]
            #[doc = "The weight of this dispatchable is that of `call` as well as the complexity"]
            #[doc = "for recording the vote itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `approve` - is this an approving vote?"]
            #[doc = "  If the proposal doesn't exist, passing `false` will result in error `FirstVoteReject`."]
            #[doc = "* `call` - the call to propose for execution."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FirstVoteReject`, if `call` hasn't been proposed and `approve == false`."]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(feature = "ink")]
            pub fn vote_or_propose(
                &self,
                approve: bool,
                call: runtime::RuntimeCall,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![13u8, 3u8];
                approve.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Votes `approve`ingly (or not, if `false`)"]
            #[doc = "on an existing `proposal` given by its hash, `index`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `proposal` - A hash of the proposal to be voted on."]
            #[doc = "* `index` - The proposal index."]
            #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(not(feature = "ink"))]
            pub fn vote(
                &self,
                proposal: types::primitive_types::H256,
                index: u32,
                approve: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::UpgradeCommittee(
                    types::pallet_committee::pallet::UpgradeCommitteeCall::vote {
                        proposal,
                        index,
                        approve,
                    },
                ))
            }
            #[doc = "Votes `approve`ingly (or not, if `false`)"]
            #[doc = "on an existing `proposal` given by its hash, `index`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `proposal` - A hash of the proposal to be voted on."]
            #[doc = "* `index` - The proposal index."]
            #[doc = "* `approve` - If `true` than this is a `for` vote, and `against` otherwise."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotAMember`, if the `origin` is not a member of this committee."]
            #[cfg(feature = "ink")]
            pub fn vote(
                &self,
                proposal: types::primitive_types::H256,
                index: u32,
                approve: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![13u8, 4u8];
                proposal.encode_to(&mut buf);
                index.encode_to(&mut buf);
                approve.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for UpgradeCommitteeCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct UpgradeCommitteeQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> UpgradeCommitteeQueryApi<'api> {
            #[doc = " The hashes of the active proposals."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposals(
                &self,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8,
                    29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The hashes of the active proposals."]
            #[cfg(feature = "ink")]
            pub fn proposals(
                &self,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8, 221u8,
                    29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Actual proposal for a given hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_of(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8,
                    121u8, 147u8, 11u8, 195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Actual proposal for a given hash."]
            #[cfg(feature = "ink")]
            pub fn proposal_of(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8,
                    121u8, 147u8, 11u8, 195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
            #[cfg(not(feature = "ink"))]
            pub async fn voting(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_committee::pallet::PolymeshVotes<u32>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8,
                    251u8, 57u8, 43u8, 121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
            #[cfg(feature = "ink")]
            pub fn voting(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_committee::pallet::PolymeshVotes<u32>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8,
                    251u8, 57u8, 43u8, 121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Proposals so far."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_count(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8,
                    162u8, 166u8, 43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Proposals so far."]
            #[cfg(feature = "ink")]
            pub fn proposal_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 98u8, 84u8, 233u8, 213u8, 85u8, 136u8, 120u8, 79u8,
                    162u8, 166u8, 43u8, 114u8, 102u8, 150u8, 226u8, 177u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The current members of the committee."]
            #[cfg(not(feature = "ink"))]
            pub async fn members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8,
                    226u8, 162u8, 198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current members of the committee."]
            #[cfg(feature = "ink")]
            pub fn members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 186u8, 127u8, 184u8, 116u8, 87u8, 53u8, 220u8, 59u8,
                    226u8, 162u8, 198u8, 26u8, 114u8, 195u8, 158u8, 120u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Vote threshold for an approval."]
            #[cfg(not(feature = "ink"))]
            pub async fn vote_threshold(&self) -> ::polymesh_api_client::error::Result<(u32, u32)> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8,
                    113u8, 204u8, 101u8, 23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Vote threshold for an approval."]
            #[cfg(feature = "ink")]
            pub fn vote_threshold(&self) -> ::polymesh_api_ink::error::Result<(u32, u32)> {
                let value = self.api.read_storage(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 156u8, 139u8, 199u8, 108u8, 52u8, 115u8, 136u8,
                    113u8, 204u8, 101u8, 23u8, 132u8, 125u8, 93u8, 3u8, 193u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <(u32, u32)>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Release cooridinator."]
            #[cfg(not(feature = "ink"))]
            pub async fn release_coordinator(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8,
                    153u8, 133u8, 116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Release cooridinator."]
            #[cfg(feature = "ink")]
            pub fn release_coordinator(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 165u8, 39u8, 240u8, 96u8, 78u8, 203u8, 185u8, 53u8,
                    153u8, 133u8, 116u8, 59u8, 46u8, 180u8, 116u8, 144u8,
                ])?;
                Ok(value)
            }
            #[doc = " Time after which a proposal will expire."]
            #[cfg(not(feature = "ink"))]
            pub async fn expires_after(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::MaybeBlock<u32>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8,
                    113u8, 75u8, 210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8];
                    <types::polymesh_primitives::MaybeBlock<u32>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Time after which a proposal will expire."]
            #[cfg(feature = "ink")]
            pub fn expires_after(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::MaybeBlock<u32>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 133u8, 201u8, 79u8, 204u8, 159u8, 70u8, 222u8, 61u8,
                    113u8, 75u8, 210u8, 244u8, 47u8, 119u8, 123u8, 176u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8];
                    <types::polymesh_primitives::MaybeBlock<u32>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct UpgradeCommitteePagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> UpgradeCommitteePagedQueryApi<'api> {
            #[doc = " Actual proposal for a given hash."]
            pub fn proposal_of(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                runtime::RuntimeCall,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 233u8, 214u8, 219u8, 136u8, 104u8, 163u8, 125u8,
                    121u8, 147u8, 11u8, 195u8, 247u8, 243u8, 57u8, 80u8, 209u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " PolymeshVotes on a given proposal, if it is ongoing."]
            pub fn voting(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                types::pallet_committee::pallet::PolymeshVotes<u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    46u8, 97u8, 8u8, 175u8, 80u8, 143u8, 105u8, 172u8, 110u8, 58u8, 4u8, 227u8,
                    221u8, 192u8, 28u8, 229u8, 113u8, 205u8, 48u8, 104u8, 230u8, 17u8, 139u8,
                    251u8, 57u8, 43u8, 121u8, 131u8, 23u8, 246u8, 58u8, 137u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
        }
    }
    pub mod upgrade_committee_membership {
        use super::*;
        #[derive(Clone)]
        pub struct UpgradeCommitteeMembershipCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> UpgradeCommitteeMembershipCallApi<'api> {
            #[doc = "Change this group's limit for how many concurrent active members they may be."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `limit` - the number of active members there may be concurrently."]
            #[cfg(not(feature = "ink"))]
            pub fn set_active_members_limit(
                &self,
                limit: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: UpgradeCommitteeMembership (types :: pallet_group :: pallet :: UpgradeCommitteeMembershipCall :: set_active_members_limit { limit , }))
            }
            #[doc = "Change this group's limit for how many concurrent active members they may be."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `limit` - the number of active members there may be concurrently."]
            #[cfg(feature = "ink")]
            pub fn set_active_members_limit(&self, limit: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![14u8, 0u8];
                limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Disables a member at specific moment."]
            #[doc = ""]
            #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
            #[doc = "time-stamp will be updated."]
            #[doc = ""]
            #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
            #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
            #[doc = "generated claim issued before `at` would be considered as a valid one."]
            #[doc = ""]
            #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `at` - Revocation time-stamp."]
            #[doc = "* `who` - Target member of the group."]
            #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
            #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
            #[cfg(not(feature = "ink"))]
            pub fn disable_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
                expiry: Option<u64>,
                at: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::disable_member {
                        who,
                        expiry,
                        at,
                    },
                ))
            }
            #[doc = "Disables a member at specific moment."]
            #[doc = ""]
            #[doc = "Please note that if member is already revoked (a \"valid member\"), its revocation"]
            #[doc = "time-stamp will be updated."]
            #[doc = ""]
            #[doc = "Any disabled member should NOT allow to act like an active member of the group. For"]
            #[doc = "instance, a disabled CDD member should NOT be able to generate a CDD claim. However any"]
            #[doc = "generated claim issued before `at` would be considered as a valid one."]
            #[doc = ""]
            #[doc = "If you want to invalidate any generated claim, you should use `Self::remove_member`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `at` - Revocation time-stamp."]
            #[doc = "* `who` - Target member of the group."]
            #[doc = "* `expiry` - Time-stamp when `who` is removed from CDD. As soon as it is expired, the"]
            #[doc = "generated claims will be \"invalid\" as `who` is not considered a member of the group."]
            #[cfg(feature = "ink")]
            pub fn disable_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
                expiry: Option<u64>,
                at: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![14u8, 1u8];
                who.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                at.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
            #[doc = "* `who` - IdentityId to be added to the group."]
            #[cfg(not(feature = "ink"))]
            pub fn add_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
                        types::pallet_group::pallet::UpgradeCommitteeMembershipCall::add_member {
                            who,
                        },
                    ))
            }
            #[doc = "Adds a member `who` to the group. May only be called from `AddOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `AddOrigin` or root"]
            #[doc = "* `who` - IdentityId to be added to the group."]
            #[cfg(feature = "ink")]
            pub fn add_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![14u8, 2u8];
                who.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
            #[doc = ""]
            #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
            #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
            #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
            #[doc = "claims, you have to use `Self::disable_member` function"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
            #[doc = "* `who` - IdentityId to be removed from the group."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::remove_member {
                        who,
                    },
                ))
            }
            #[doc = "Removes a member `who` from the set. May only be called from `RemoveOrigin` or root."]
            #[doc = ""]
            #[doc = "Any claim previously generated by this member is not valid as a group claim. For"]
            #[doc = "instance, if a CDD member group generated a claim for a target identity and then it is"]
            #[doc = "removed, that claim will be invalid.  In case you want to keep the validity of generated"]
            #[doc = "claims, you have to use `Self::disable_member` function"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `RemoveOrigin` or root"]
            #[doc = "* `who` - IdentityId to be removed from the group."]
            #[cfg(feature = "ink")]
            pub fn remove_member(
                &self,
                who: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![14u8, 3u8];
                who.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Swaps out one member `remove` for another member `add`."]
            #[doc = ""]
            #[doc = "May only be called from `SwapOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
            #[doc = "* `remove` - IdentityId to be removed from the group."]
            #[doc = "* `add` - IdentityId to be added in place of `remove`."]
            #[cfg(not(feature = "ink"))]
            pub fn swap_member(
                &self,
                remove: ::polymesh_api_client::IdentityId,
                add: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
                        types::pallet_group::pallet::UpgradeCommitteeMembershipCall::swap_member {
                            remove,
                            add,
                        },
                    ))
            }
            #[doc = "Swaps out one member `remove` for another member `add`."]
            #[doc = ""]
            #[doc = "May only be called from `SwapOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `SwapOrigin` or root"]
            #[doc = "* `remove` - IdentityId to be removed from the group."]
            #[doc = "* `add` - IdentityId to be added in place of `remove`."]
            #[cfg(feature = "ink")]
            pub fn swap_member(
                &self,
                remove: ::polymesh_api_client::IdentityId,
                add: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![14u8, 4u8];
                remove.encode_to(&mut buf);
                add.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the membership to a new set, disregarding the existing membership."]
            #[doc = "May only be called from `ResetOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
            #[doc = "* `members` - New set of identities"]
            #[cfg(not(feature = "ink"))]
            pub fn reset_members(
                &self,
                members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api
                    .wrap_call(runtime::RuntimeCall::UpgradeCommitteeMembership(
                    types::pallet_group::pallet::UpgradeCommitteeMembershipCall::reset_members {
                        members,
                    },
                ))
            }
            #[doc = "Changes the membership to a new set, disregarding the existing membership."]
            #[doc = "May only be called from `ResetOrigin` or root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Origin representing `ResetOrigin` or root"]
            #[doc = "* `members` - New set of identities"]
            #[cfg(feature = "ink")]
            pub fn reset_members(
                &self,
                members: ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![14u8, 5u8];
                members.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
            #[doc = "vote."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Member of committee who wants to quit."]
            #[doc = ""]
            #[doc = "# Error"]
            #[doc = ""]
            #[doc = "* Only primary key can abdicate."]
            #[doc = "* Last member of a group cannot abdicate."]
            #[cfg(not(feature = "ink"))]
            pub fn abdicate_membership(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: UpgradeCommitteeMembership (types :: pallet_group :: pallet :: UpgradeCommitteeMembershipCall :: abdicate_membership))
            }
            #[doc = "Allows the calling member to *unilaterally quit* without this being subject to a GC"]
            #[doc = "vote."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - Member of committee who wants to quit."]
            #[doc = ""]
            #[doc = "# Error"]
            #[doc = ""]
            #[doc = "* Only primary key can abdicate."]
            #[doc = "* Last member of a group cannot abdicate."]
            #[cfg(feature = "ink")]
            pub fn abdicate_membership(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![14u8, 6u8])
            }
        }
        impl<'api> From<&'api super::super::Api> for UpgradeCommitteeMembershipCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct UpgradeCommitteeMembershipQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> UpgradeCommitteeMembershipQueryApi<'api> {
            #[doc = " The current \"active\" membership, stored as an ordered Vec."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    44u8, 212u8, 9u8, 87u8, 89u8, 165u8, 24u8, 167u8, 12u8, 219u8, 128u8, 86u8,
                    39u8, 214u8, 32u8, 66u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8,
                    138u8, 14u8, 159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current \"active\" membership, stored as an ordered Vec."]
            #[cfg(feature = "ink")]
            pub fn active_members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::IdentityId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    44u8, 212u8, 9u8, 87u8, 89u8, 165u8, 24u8, 167u8, 12u8, 219u8, 128u8, 86u8,
                    39u8, 214u8, 32u8, 66u8, 118u8, 191u8, 62u8, 207u8, 240u8, 38u8, 151u8, 14u8,
                    138u8, 14u8, 159u8, 240u8, 162u8, 26u8, 38u8, 76u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
            #[cfg(not(feature = "ink"))]
            pub async fn inactive_members(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::traits::group::InactiveMember<u64>>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    44u8, 212u8, 9u8, 87u8, 89u8, 165u8, 24u8, 167u8, 12u8, 219u8, 128u8, 86u8,
                    39u8, 214u8, 32u8, 66u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8,
                    81u8, 34u8, 107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::polymesh_primitives::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " The current \"inactive\" membership, stored as an ordered Vec."]
            #[cfg(feature = "ink")]
            pub fn inactive_members(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::traits::group::InactiveMember<u64>>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    44u8, 212u8, 9u8, 87u8, 89u8, 165u8, 24u8, 167u8, 12u8, 219u8, 128u8, 86u8,
                    39u8, 214u8, 32u8, 66u8, 192u8, 158u8, 95u8, 137u8, 89u8, 57u8, 167u8, 102u8,
                    81u8, 34u8, 107u8, 3u8, 94u8, 145u8, 7u8, 20u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::polymesh_primitives::traits::group::InactiveMember<u64>,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Limit of how many \"active\" members there can be."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_members_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    44u8, 212u8, 9u8, 87u8, 89u8, 165u8, 24u8, 167u8, 12u8, 219u8, 128u8, 86u8,
                    39u8, 214u8, 32u8, 66u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8,
                    97u8, 92u8, 160u8, 7u8, 124u8, 249u8, 110u8, 183u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Limit of how many \"active\" members there can be."]
            #[cfg(feature = "ink")]
            pub fn active_members_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    44u8, 212u8, 9u8, 87u8, 89u8, 165u8, 24u8, 167u8, 12u8, 219u8, 128u8, 86u8,
                    39u8, 214u8, 32u8, 66u8, 101u8, 218u8, 136u8, 19u8, 44u8, 164u8, 10u8, 73u8,
                    97u8, 92u8, 160u8, 7u8, 124u8, 249u8, 110u8, 183u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct UpgradeCommitteeMembershipPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> UpgradeCommitteeMembershipPagedQueryApi<'api> {}
    }
    pub mod multi_sig {
        use super::*;
        #[derive(Clone)]
        pub struct MultiSigCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> MultiSigCallApi<'api> {
            #[doc = "Creates a multisig"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)."]
            #[doc = "* `sigs_required` - Number of sigs required to process a multi-sig tx."]
            #[doc = "* `permissions` - optional custom permissions.  Only the primary key can provide custom permissions."]
            #[cfg(not(feature = "ink"))]
            pub fn create_multisig(
                &self,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                sigs_required: u64,
                permissions: Option<types::polymesh_primitives::secondary_key::Permissions>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::create_multisig {
                        signers,
                        sigs_required,
                        permissions,
                    },
                ))
            }
            #[doc = "Creates a multisig"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `signers` - Signers of the multisig (They need to accept authorization before they are actually added)."]
            #[doc = "* `sigs_required` - Number of sigs required to process a multi-sig tx."]
            #[doc = "* `permissions` - optional custom permissions.  Only the primary key can provide custom permissions."]
            #[cfg(feature = "ink")]
            pub fn create_multisig(
                &self,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                sigs_required: u64,
                permissions: Option<types::polymesh_primitives::secondary_key::Permissions>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 0u8];
                signers.encode_to(&mut buf);
                sigs_required.encode_to(&mut buf);
                permissions.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Creates a multisig proposal"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - MultiSig address."]
            #[doc = "* `proposal` - Proposal to be voted on."]
            #[doc = "* `expiry` - Optional proposal expiry time."]
            #[doc = ""]
            #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
            #[cfg(not(feature = "ink"))]
            pub fn create_proposal(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                proposal: runtime::RuntimeCall,
                expiry: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::create_proposal {
                        multisig,
                        proposal: ::alloc::boxed::Box::new(proposal),
                        expiry,
                    },
                ))
            }
            #[doc = "Creates a multisig proposal"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - MultiSig address."]
            #[doc = "* `proposal` - Proposal to be voted on."]
            #[doc = "* `expiry` - Optional proposal expiry time."]
            #[doc = ""]
            #[doc = "If this is 1 out of `m` multisig, the proposal will be immediately executed."]
            #[cfg(feature = "ink")]
            pub fn create_proposal(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                proposal: runtime::RuntimeCall,
                expiry: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 1u8];
                multisig.encode_to(&mut buf);
                proposal.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Approves a multisig proposal using the caller's secondary key (`AccountId`)."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - MultiSig address."]
            #[doc = "* `proposal_id` - Proposal id to approve."]
            #[doc = "* `max_weight` - The maximum weight to execute the proposal."]
            #[doc = ""]
            #[doc = "If quorum is reached, the proposal will be immediately executed."]
            #[cfg(not(feature = "ink"))]
            pub fn approve(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                proposal_id: u64,
                max_weight: Option<::polymesh_api_client::sp_weights::Weight>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::approve {
                        multisig,
                        proposal_id,
                        max_weight,
                    },
                ))
            }
            #[doc = "Approves a multisig proposal using the caller's secondary key (`AccountId`)."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - MultiSig address."]
            #[doc = "* `proposal_id` - Proposal id to approve."]
            #[doc = "* `max_weight` - The maximum weight to execute the proposal."]
            #[doc = ""]
            #[doc = "If quorum is reached, the proposal will be immediately executed."]
            #[cfg(feature = "ink")]
            pub fn approve(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                proposal_id: u64,
                max_weight: Option<::polymesh_api_client::sp_weights::Weight>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 2u8];
                multisig.encode_to(&mut buf);
                proposal_id.encode_to(&mut buf);
                max_weight.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Rejects a multisig proposal using the caller's secondary key (`AccountId`)."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - MultiSig address."]
            #[doc = "* `proposal_id` - Proposal id to reject."]
            #[doc = "If quorum is reached, the proposal will be immediately executed."]
            #[cfg(not(feature = "ink"))]
            pub fn reject(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                proposal_id: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::reject {
                        multisig,
                        proposal_id,
                    },
                ))
            }
            #[doc = "Rejects a multisig proposal using the caller's secondary key (`AccountId`)."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - MultiSig address."]
            #[doc = "* `proposal_id` - Proposal id to reject."]
            #[doc = "If quorum is reached, the proposal will be immediately executed."]
            #[cfg(feature = "ink")]
            pub fn reject(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                proposal_id: u64,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 3u8];
                multisig.encode_to(&mut buf);
                proposal_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Accepts a multisig signer authorization given to signer's key (AccountId)."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `auth_id` - Auth id of the authorization."]
            #[cfg(not(feature = "ink"))]
            pub fn accept_multisig_signer(
                &self,
                auth_id: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::accept_multisig_signer {
                        auth_id,
                    },
                ))
            }
            #[doc = "Accepts a multisig signer authorization given to signer's key (AccountId)."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `auth_id` - Auth id of the authorization."]
            #[cfg(feature = "ink")]
            pub fn accept_multisig_signer(&self, auth_id: u64) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 4u8];
                auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds signers to the multisig.  This must be called by the multisig itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `signers` - Signers to add."]
            #[cfg(not(feature = "ink"))]
            pub fn add_multisig_signers(
                &self,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::add_multisig_signers { signers },
                ))
            }
            #[doc = "Adds signers to the multisig.  This must be called by the multisig itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `signers` - Signers to add."]
            #[cfg(feature = "ink")]
            pub fn add_multisig_signers(
                &self,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 5u8];
                signers.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes signers from the multisig.  This must be called by the multisig itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `signers` - Signers to remove."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_multisig_signers(
                &self,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::remove_multisig_signers {
                        signers,
                    },
                ))
            }
            #[doc = "Removes signers from the multisig.  This must be called by the multisig itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `signers` - Signers to remove."]
            #[cfg(feature = "ink")]
            pub fn remove_multisig_signers(
                &self,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 6u8];
                signers.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds a signer to the multisig.  This must be called by the admin identity of the"]
            #[doc = "multisig."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - Address of the multi sig"]
            #[doc = "* `signers` - Signers to add."]
            #[doc = ""]
            #[cfg(not(feature = "ink"))]
            pub fn add_multisig_signers_via_admin(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::add_multisig_signers_via_admin {
                        multisig,
                        signers,
                    },
                ))
            }
            #[doc = "Adds a signer to the multisig.  This must be called by the admin identity of the"]
            #[doc = "multisig."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - Address of the multi sig"]
            #[doc = "* `signers` - Signers to add."]
            #[doc = ""]
            #[cfg(feature = "ink")]
            pub fn add_multisig_signers_via_admin(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 7u8];
                multisig.encode_to(&mut buf);
                signers.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes a signer from the multisig."]
            #[doc = "This must be called by the admin identity of the multisig."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - Address of the multisig."]
            #[doc = "* `signers` - Signers to remove."]
            #[doc = ""]
            #[cfg(not(feature = "ink"))]
            pub fn remove_multisig_signers_via_admin(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: MultiSig (types :: pallet_multisig :: pallet :: MultiSigCall :: remove_multisig_signers_via_admin { multisig , signers , }))
            }
            #[doc = "Removes a signer from the multisig."]
            #[doc = "This must be called by the admin identity of the multisig."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - Address of the multisig."]
            #[doc = "* `signers` - Signers to remove."]
            #[doc = ""]
            #[cfg(feature = "ink")]
            pub fn remove_multisig_signers_via_admin(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 8u8];
                multisig.encode_to(&mut buf);
                signers.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the number of signatures required by a multisig.  This must be called by the"]
            #[doc = "multisig itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `sigs_required` - New number of required signatures."]
            #[cfg(not(feature = "ink"))]
            pub fn change_sigs_required(
                &self,
                sigs_required: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::change_sigs_required {
                        sigs_required,
                    },
                ))
            }
            #[doc = "Changes the number of signatures required by a multisig.  This must be called by the"]
            #[doc = "multisig itself."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `sigs_required` - New number of required signatures."]
            #[cfg(feature = "ink")]
            pub fn change_sigs_required(&self, sigs_required: u64) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 9u8];
                sigs_required.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the number of signatures required by a multisig.  This must be called by the admin of the multisig."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - The account identifier ([`AccountId`]) for the multi signature account."]
            #[doc = "* `signatures_required` - The number of required signatures."]
            #[cfg(not(feature = "ink"))]
            pub fn change_sigs_required_via_admin(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                signatures_required: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::change_sigs_required_via_admin {
                        multisig,
                        signatures_required,
                    },
                ))
            }
            #[doc = "Changes the number of signatures required by a multisig.  This must be called by the admin of the multisig."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - The account identifier ([`AccountId`]) for the multi signature account."]
            #[doc = "* `signatures_required` - The number of required signatures."]
            #[cfg(feature = "ink")]
            pub fn change_sigs_required_via_admin(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                signatures_required: u64,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 10u8];
                multisig.encode_to(&mut buf);
                signatures_required.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Add an admin identity to the multisig.  This must be called by the multisig itself."]
            #[cfg(not(feature = "ink"))]
            pub fn add_admin(
                &self,
                admin_did: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::add_admin { admin_did },
                ))
            }
            #[doc = "Add an admin identity to the multisig.  This must be called by the multisig itself."]
            #[cfg(feature = "ink")]
            pub fn add_admin(
                &self,
                admin_did: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 11u8];
                admin_did.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the admin identity from the `multisig`.  This must be called by the admin of the multisig."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_admin_via_admin(
                &self,
                multisig: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::remove_admin_via_admin {
                        multisig,
                    },
                ))
            }
            #[doc = "Removes the admin identity from the `multisig`.  This must be called by the admin of the multisig."]
            #[cfg(feature = "ink")]
            pub fn remove_admin_via_admin(
                &self,
                multisig: ::polymesh_api_client::AccountId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 12u8];
                multisig.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the paying identity from the `multisig`.  This must be called by the multisig itself."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_payer(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::remove_payer,
                ))
            }
            #[doc = "Removes the paying identity from the `multisig`.  This must be called by the multisig itself."]
            #[cfg(feature = "ink")]
            pub fn remove_payer(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![15u8, 13u8])
            }
            #[doc = "Removes the paying identity from the `multisig`.  This must be called by the paying identity of the multisig."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_payer_via_payer(
                &self,
                multisig: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::remove_payer_via_payer {
                        multisig,
                    },
                ))
            }
            #[doc = "Removes the paying identity from the `multisig`.  This must be called by the paying identity of the multisig."]
            #[cfg(feature = "ink")]
            pub fn remove_payer_via_payer(
                &self,
                multisig: ::polymesh_api_client::AccountId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 14u8];
                multisig.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Approves a multisig join identity proposal."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - MultiSig address."]
            #[doc = "* `auth_id` - The join identity authorization to approve."]
            #[doc = ""]
            #[doc = "If quorum is reached, the join identity proposal will be immediately executed."]
            #[cfg(not(feature = "ink"))]
            pub fn approve_join_identity(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                auth_id: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::approve_join_identity {
                        multisig,
                        auth_id,
                    },
                ))
            }
            #[doc = "Approves a multisig join identity proposal."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `multisig` - MultiSig address."]
            #[doc = "* `auth_id` - The join identity authorization to approve."]
            #[doc = ""]
            #[doc = "If quorum is reached, the join identity proposal will be immediately executed."]
            #[cfg(feature = "ink")]
            pub fn approve_join_identity(
                &self,
                multisig: ::polymesh_api_client::AccountId,
                auth_id: u64,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 15u8];
                multisig.encode_to(&mut buf);
                auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Accept a JoinIdentity authorization for this multisig.  This must be called by the multisig itself."]
            #[cfg(not(feature = "ink"))]
            pub fn join_identity(
                &self,
                auth_id: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::join_identity { auth_id },
                ))
            }
            #[doc = "Accept a JoinIdentity authorization for this multisig.  This must be called by the multisig itself."]
            #[cfg(feature = "ink")]
            pub fn join_identity(&self, auth_id: u64) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![15u8, 16u8];
                auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the admin identity from the `multisig`.  This must be called by the multisig itself."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_admin(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::MultiSig(
                    types::pallet_multisig::pallet::MultiSigCall::remove_admin,
                ))
            }
            #[doc = "Removes the admin identity from the `multisig`.  This must be called by the multisig itself."]
            #[cfg(feature = "ink")]
            pub fn remove_admin(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![15u8, 17u8])
            }
        }
        impl<'api> From<&'api super::super::Api> for MultiSigCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct MultiSigQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> MultiSigQueryApi<'api> {
            #[doc = " Nonce to ensure unique MultiSig addresses are generated; starts from 1."]
            #[cfg(not(feature = "ink"))]
            pub async fn multi_sig_nonce(&self) -> ::polymesh_api_client::error::Result<u64> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 10u8, 14u8, 167u8, 96u8, 87u8, 167u8, 154u8,
                    118u8, 104u8, 172u8, 98u8, 216u8, 200u8, 251u8, 224u8, 34u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Nonce to ensure unique MultiSig addresses are generated; starts from 1."]
            #[cfg(feature = "ink")]
            pub fn multi_sig_nonce(&self) -> ::polymesh_api_ink::error::Result<u64> {
                let value = self.api.read_storage(::alloc::vec![
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 10u8, 14u8, 167u8, 96u8, 87u8, 167u8, 154u8,
                    118u8, 104u8, 172u8, 98u8, 216u8, 200u8, 251u8, 224u8, 34u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Signers of a multisig. (multisig, signer) => bool."]
            #[cfg(not(feature = "ink"))]
            pub async fn multi_sig_signers(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 87u8, 55u8, 48u8, 162u8, 27u8, 187u8, 140u8,
                    140u8, 243u8, 200u8, 51u8, 112u8, 105u8, 135u8, 190u8, 191u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Signers of a multisig. (multisig, signer) => bool."]
            #[cfg(feature = "ink")]
            pub fn multi_sig_signers(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 87u8, 55u8, 48u8, 162u8, 27u8, 187u8, 140u8,
                    140u8, 243u8, 200u8, 51u8, 112u8, 105u8, 135u8, 190u8, 191u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Number of approved/accepted signers of a multisig."]
            #[cfg(not(feature = "ink"))]
            pub async fn number_of_signers(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 71u8, 130u8, 22u8, 60u8, 187u8, 185u8, 53u8,
                    64u8, 248u8, 2u8, 20u8, 216u8, 127u8, 68u8, 253u8, 226u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Number of approved/accepted signers of a multisig."]
            #[cfg(feature = "ink")]
            pub fn number_of_signers(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 71u8, 130u8, 22u8, 60u8, 187u8, 185u8, 53u8,
                    64u8, 248u8, 2u8, 20u8, 216u8, 127u8, 68u8, 253u8, 226u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Confirmations required before processing a multisig tx."]
            #[cfg(not(feature = "ink"))]
            pub async fn multi_sig_signs_required(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 186u8, 252u8, 143u8, 56u8, 160u8, 191u8, 27u8,
                    28u8, 14u8, 157u8, 223u8, 36u8, 138u8, 28u8, 207u8, 150u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Confirmations required before processing a multisig tx."]
            #[cfg(feature = "ink")]
            pub fn multi_sig_signs_required(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 186u8, 252u8, 143u8, 56u8, 160u8, 191u8, 27u8,
                    28u8, 14u8, 157u8, 223u8, 36u8, 138u8, 28u8, 207u8, 150u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Next proposal id for a multisig.  Starts from 0."]
            #[doc = ""]
            #[doc = " multisig => next proposal id"]
            #[cfg(not(feature = "ink"))]
            pub async fn next_proposal_id(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 47u8, 88u8, 243u8, 11u8, 97u8, 166u8, 255u8,
                    46u8, 140u8, 116u8, 75u8, 1u8, 215u8, 36u8, 158u8, 12u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Next proposal id for a multisig.  Starts from 0."]
            #[doc = ""]
            #[doc = " multisig => next proposal id"]
            #[cfg(feature = "ink")]
            pub fn next_proposal_id(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 47u8, 88u8, 243u8, 11u8, 97u8, 166u8, 255u8,
                    46u8, 140u8, 116u8, 75u8, 1u8, 215u8, 36u8, 158u8, 12u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Proposals presented for voting to a multisig."]
            #[doc = ""]
            #[doc = " multisig -> proposal id => Option<Proposal>."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposals(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: u64,
            ) -> ::polymesh_api_client::error::Result<Option<runtime::RuntimeCall>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8,
                    221u8, 29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Proposals presented for voting to a multisig."]
            #[doc = ""]
            #[doc = " multisig -> proposal id => Option<Proposal>."]
            #[cfg(feature = "ink")]
            pub fn proposals(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: u64,
            ) -> ::polymesh_api_ink::error::Result<Option<runtime::RuntimeCall>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8,
                    221u8, 29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Individual multisig signer votes."]
            #[doc = ""]
            #[doc = " (multisig, proposal_id) -> signer => vote."]
            #[cfg(not(feature = "ink"))]
            pub async fn votes(
                &self,
                key_0: (::polymesh_api_client::AccountId, u64),
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8,
                    124u8, 194u8, 230u8, 150u8, 237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Individual multisig signer votes."]
            #[doc = ""]
            #[doc = " (multisig, proposal_id) -> signer => vote."]
            #[cfg(feature = "ink")]
            pub fn votes(
                &self,
                key_0: (::polymesh_api_client::AccountId, u64),
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8,
                    124u8, 194u8, 230u8, 150u8, 237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The multisig's paying identity.  The primary key of this identity"]
            #[doc = " pays the transaction/protocal fees of the multisig proposals."]
            #[doc = ""]
            #[doc = " multisig -> Option<IdentityId>."]
            #[cfg(not(feature = "ink"))]
            pub async fn paying_did(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 37u8, 34u8, 79u8, 180u8, 97u8, 160u8, 185u8,
                    177u8, 98u8, 104u8, 127u8, 6u8, 92u8, 57u8, 212u8, 208u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The multisig's paying identity.  The primary key of this identity"]
            #[doc = " pays the transaction/protocal fees of the multisig proposals."]
            #[doc = ""]
            #[doc = " multisig -> Option<IdentityId>."]
            #[cfg(feature = "ink")]
            pub fn paying_did(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 37u8, 34u8, 79u8, 180u8, 97u8, 160u8, 185u8,
                    177u8, 98u8, 104u8, 127u8, 6u8, 92u8, 57u8, 212u8, 208u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The multisig's admin identity.  The primary key of this identity"]
            #[doc = " has admin control over the multisig."]
            #[doc = ""]
            #[doc = " multisig -> Option<IdentityId>."]
            #[cfg(not(feature = "ink"))]
            pub async fn admin_did(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 58u8, 32u8, 242u8, 176u8, 113u8, 123u8, 137u8,
                    45u8, 241u8, 118u8, 159u8, 124u8, 101u8, 106u8, 164u8, 65u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The multisig's admin identity.  The primary key of this identity"]
            #[doc = " has admin control over the multisig."]
            #[doc = ""]
            #[doc = " multisig -> Option<IdentityId>."]
            #[cfg(feature = "ink")]
            pub fn admin_did(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 58u8, 32u8, 242u8, 176u8, 113u8, 123u8, 137u8,
                    45u8, 241u8, 118u8, 159u8, 124u8, 101u8, 106u8, 164u8, 65u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The count of approvals/rejections of a multisig proposal."]
            #[doc = ""]
            #[doc = " multisig -> proposal id => Option<ProposalVoteCount>."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_vote_counts(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: u64,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::multisig::ProposalVoteCount>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 22u8, 28u8, 219u8, 127u8, 2u8, 196u8, 199u8,
                    111u8, 96u8, 96u8, 228u8, 243u8, 137u8, 34u8, 97u8, 245u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The count of approvals/rejections of a multisig proposal."]
            #[doc = ""]
            #[doc = " multisig -> proposal id => Option<ProposalVoteCount>."]
            #[cfg(feature = "ink")]
            pub fn proposal_vote_counts(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: u64,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::multisig::ProposalVoteCount>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 22u8, 28u8, 219u8, 127u8, 2u8, 196u8, 199u8,
                    111u8, 96u8, 96u8, 228u8, 243u8, 137u8, 34u8, 97u8, 245u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The state of a multisig proposal"]
            #[doc = ""]
            #[doc = " multisig -> proposal id => Option<ProposalState>."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_states(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: u64,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::multisig::ProposalState<u64>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8,
                    102u8, 151u8, 171u8, 71u8, 106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The state of a multisig proposal"]
            #[doc = ""]
            #[doc = " multisig -> proposal id => Option<ProposalState>."]
            #[cfg(feature = "ink")]
            pub fn proposal_states(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: u64,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::multisig::ProposalState<u64>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8,
                    102u8, 151u8, 171u8, 71u8, 106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Proposal execution reentry guard."]
            #[cfg(not(feature = "ink"))]
            pub async fn execution_reentry(&self) -> ::polymesh_api_client::error::Result<bool> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 34u8, 8u8, 200u8, 58u8, 222u8, 75u8, 189u8,
                    75u8, 236u8, 60u8, 63u8, 61u8, 162u8, 33u8, 164u8, 101u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Proposal execution reentry guard."]
            #[cfg(feature = "ink")]
            pub fn execution_reentry(&self) -> ::polymesh_api_ink::error::Result<bool> {
                let value = self.api.read_storage(::alloc::vec![
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 34u8, 8u8, 200u8, 58u8, 222u8, 75u8, 189u8,
                    75u8, 236u8, 60u8, 63u8, 61u8, 162u8, 33u8, 164u8, 101u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Pending join identity authorization proposals."]
            #[doc = ""]
            #[doc = " multisig -> auth id => Option<proposal id>."]
            #[cfg(not(feature = "ink"))]
            pub async fn auth_to_proposal_id(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: u64,
            ) -> ::polymesh_api_client::error::Result<Option<u64>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 35u8, 107u8, 174u8, 151u8, 167u8, 187u8,
                    232u8, 180u8, 151u8, 93u8, 165u8, 155u8, 96u8, 132u8, 198u8, 82u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Pending join identity authorization proposals."]
            #[doc = ""]
            #[doc = " multisig -> auth id => Option<proposal id>."]
            #[cfg(feature = "ink")]
            pub fn auth_to_proposal_id(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: u64,
            ) -> ::polymesh_api_ink::error::Result<Option<u64>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 35u8, 107u8, 174u8, 151u8, 167u8, 187u8,
                    232u8, 180u8, 151u8, 93u8, 165u8, 155u8, 96u8, 132u8, 198u8, 82u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The last transaction version, used for `on_runtime_upgrade`."]
            #[cfg(not(feature = "ink"))]
            pub async fn transaction_version(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 136u8, 215u8, 103u8, 226u8, 158u8, 158u8,
                    152u8, 49u8, 187u8, 71u8, 177u8, 173u8, 103u8, 53u8, 72u8, 253u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The last transaction version, used for `on_runtime_upgrade`."]
            #[cfg(feature = "ink")]
            pub fn transaction_version(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 136u8, 215u8, 103u8, 226u8, 158u8, 158u8,
                    152u8, 49u8, 187u8, 71u8, 177u8, 173u8, 103u8, 53u8, 72u8, 253u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The last proposal id before the multisig changed signers or signatures required."]
            #[doc = ""]
            #[doc = " multisig => Option<proposal id>"]
            #[cfg(not(feature = "ink"))]
            pub async fn last_invalid_proposal(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<Option<u64>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 20u8, 113u8, 107u8, 81u8, 124u8, 171u8, 163u8,
                    17u8, 16u8, 5u8, 74u8, 236u8, 90u8, 228u8, 71u8, 111u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The last proposal id before the multisig changed signers or signatures required."]
            #[doc = ""]
            #[doc = " multisig => Option<proposal id>"]
            #[cfg(feature = "ink")]
            pub fn last_invalid_proposal(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<Option<u64>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 20u8, 113u8, 107u8, 81u8, 124u8, 171u8, 163u8,
                    17u8, 16u8, 5u8, 74u8, 236u8, 90u8, 228u8, 71u8, 111u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_multisig::Version> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_multisig::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_multisig::Version> {
                let value = self.api.read_storage(::alloc::vec![
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_multisig::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct MultiSigPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> MultiSigPagedQueryApi<'api> {
            #[doc = " Signers of a multisig. (multisig, signer) => bool."]
            pub fn multi_sig_signers(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 87u8, 55u8, 48u8, 162u8, 27u8, 187u8, 140u8,
                    140u8, 243u8, 200u8, 51u8, 112u8, 105u8, 135u8, 190u8, 191u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Number of approved/accepted signers of a multisig."]
            pub fn number_of_signers(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 71u8, 130u8, 22u8, 60u8, 187u8, 185u8, 53u8,
                    64u8, 248u8, 2u8, 20u8, 216u8, 127u8, 68u8, 253u8, 226u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " Confirmations required before processing a multisig tx."]
            pub fn multi_sig_signs_required(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 186u8, 252u8, 143u8, 56u8, 160u8, 191u8, 27u8,
                    28u8, 14u8, 157u8, 223u8, 36u8, 138u8, 28u8, 207u8, 150u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " Next proposal id for a multisig.  Starts from 0."]
            #[doc = ""]
            #[doc = " multisig => next proposal id"]
            pub fn next_proposal_id(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 47u8, 88u8, 243u8, 11u8, 97u8, 166u8, 255u8,
                    46u8, 140u8, 116u8, 75u8, 1u8, 215u8, 36u8, 158u8, 12u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " Proposals presented for voting to a multisig."]
            #[doc = ""]
            #[doc = " multisig -> proposal id => Option<Proposal>."]
            pub fn proposals(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::StoragePaged<u64, runtime::RuntimeCall> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8,
                    221u8, 29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Individual multisig signer votes."]
            #[doc = ""]
            #[doc = " (multisig, proposal_id) -> signer => vote."]
            pub fn votes(
                &self,
                key_0: (::polymesh_api_client::AccountId, u64),
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8,
                    124u8, 194u8, 230u8, 150u8, 237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The multisig's paying identity.  The primary key of this identity"]
            #[doc = " pays the transaction/protocal fees of the multisig proposals."]
            #[doc = ""]
            #[doc = " multisig -> Option<IdentityId>."]
            pub fn paying_did(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                ::polymesh_api_client::IdentityId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 37u8, 34u8, 79u8, 180u8, 97u8, 160u8, 185u8,
                    177u8, 98u8, 104u8, 127u8, 6u8, 92u8, 57u8, 212u8, 208u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " The multisig's admin identity.  The primary key of this identity"]
            #[doc = " has admin control over the multisig."]
            #[doc = ""]
            #[doc = " multisig -> Option<IdentityId>."]
            pub fn admin_did(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                ::polymesh_api_client::IdentityId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 58u8, 32u8, 242u8, 176u8, 113u8, 123u8, 137u8,
                    45u8, 241u8, 118u8, 159u8, 124u8, 101u8, 106u8, 164u8, 65u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " The count of approvals/rejections of a multisig proposal."]
            #[doc = ""]
            #[doc = " multisig -> proposal id => Option<ProposalVoteCount>."]
            pub fn proposal_vote_counts(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::StoragePaged<
                u64,
                types::polymesh_primitives::multisig::ProposalVoteCount,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 22u8, 28u8, 219u8, 127u8, 2u8, 196u8, 199u8,
                    111u8, 96u8, 96u8, 228u8, 243u8, 137u8, 34u8, 97u8, 245u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The state of a multisig proposal"]
            #[doc = ""]
            #[doc = " multisig -> proposal id => Option<ProposalState>."]
            pub fn proposal_states(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::StoragePaged<
                u64,
                types::polymesh_primitives::multisig::ProposalState<u64>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8,
                    102u8, 151u8, 171u8, 71u8, 106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Pending join identity authorization proposals."]
            #[doc = ""]
            #[doc = " multisig -> auth id => Option<proposal id>."]
            pub fn auth_to_proposal_id(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::StoragePaged<u64, u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 35u8, 107u8, 174u8, 151u8, 167u8, 187u8,
                    232u8, 180u8, 151u8, 93u8, 165u8, 155u8, 96u8, 132u8, 198u8, 82u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The last proposal id before the multisig changed signers or signatures required."]
            #[doc = ""]
            #[doc = " multisig => Option<proposal id>"]
            pub fn last_invalid_proposal(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    232u8, 14u8, 200u8, 196u8, 228u8, 213u8, 75u8, 150u8, 203u8, 167u8, 42u8,
                    186u8, 133u8, 109u8, 50u8, 47u8, 20u8, 113u8, 107u8, 81u8, 124u8, 171u8, 163u8,
                    17u8, 16u8, 5u8, 74u8, 236u8, 90u8, 228u8, 71u8, 111u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
        }
    }
    pub mod validators {
        use super::*;
        #[derive(Clone)]
        pub struct ValidatorsCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> ValidatorsCallApi<'api> {
            #[doc = "Adds a permissioned identity and sets its preferences."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[cfg(not(feature = "ink"))]
            pub fn add_permissioned_validator(
                &self,
                identity: ::polymesh_api_client::IdentityId,
                intended_count: Option<u32>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Validators(
                    types::pallet_validators::pallet::ValidatorsCall::add_permissioned_validator {
                        identity,
                        intended_count,
                    },
                ))
            }
            #[doc = "Adds a permissioned identity and sets its preferences."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[cfg(feature = "ink")]
            pub fn add_permissioned_validator(
                &self,
                identity: ::polymesh_api_client::IdentityId,
                intended_count: Option<u32>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![16u8, 0u8];
                identity.encode_to(&mut buf);
                intended_count.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin Required origin for removing a potential validator."]
            #[doc = "* identity Validator's IdentityId."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_permissioned_validator(
                &self,
                identity: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Validators (types :: pallet_validators :: pallet :: ValidatorsCall :: remove_permissioned_validator { identity , }))
            }
            #[doc = "Remove an identity from the pool of (wannabe) validator identities. Effects are known in the next session."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin Required origin for removing a potential validator."]
            #[doc = "* identity Validator's IdentityId."]
            #[cfg(feature = "ink")]
            pub fn remove_permissioned_validator(
                &self,
                identity: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![16u8, 1u8];
                identity.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[cfg(not(feature = "ink"))]
            pub fn payout_stakers_by_system(
                &self,
                validator_stash: ::polymesh_api_client::AccountId,
                era: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Validators(
                    types::pallet_validators::pallet::ValidatorsCall::payout_stakers_by_system {
                        validator_stash,
                        era,
                    },
                ))
            }
            #[cfg(feature = "ink")]
            pub fn payout_stakers_by_system(
                &self,
                validator_stash: ::polymesh_api_client::AccountId,
                era: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![16u8, 2u8];
                validator_stash.encode_to(&mut buf);
                era.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Switch slashing status on the basis of given `slashing_switch`. Can only be called by root."]
            #[cfg(not(feature = "ink"))]
            pub fn change_slashing_allowed_for(
                &self,
                slashing_switch: types::pallet_validators::types::SlashingSwitch,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Validators(
                    types::pallet_validators::pallet::ValidatorsCall::change_slashing_allowed_for {
                        slashing_switch,
                    },
                ))
            }
            #[doc = "Switch slashing status on the basis of given `slashing_switch`. Can only be called by root."]
            #[cfg(feature = "ink")]
            pub fn change_slashing_allowed_for(
                &self,
                slashing_switch: types::pallet_validators::types::SlashingSwitch,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![16u8, 3u8];
                slashing_switch.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Sets the intended count to `new_intended_count` for the given `identity`."]
            #[cfg(not(feature = "ink"))]
            pub fn update_permissioned_validator_intended_count(
                &self,
                identity: ::polymesh_api_client::IdentityId,
                new_intended_count: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Validators (types :: pallet_validators :: pallet :: ValidatorsCall :: update_permissioned_validator_intended_count { identity , new_intended_count , }))
            }
            #[doc = "Sets the intended count to `new_intended_count` for the given `identity`."]
            #[cfg(feature = "ink")]
            pub fn update_permissioned_validator_intended_count(
                &self,
                identity: ::polymesh_api_client::IdentityId,
                new_intended_count: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![16u8, 4u8];
                identity.encode_to(&mut buf);
                new_intended_count.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Governance council forcefully chills a validator. Effects will be felt at the beginning of the next era."]
            #[cfg(not(feature = "ink"))]
            pub fn chill_from_governance(
                &self,
                identity: ::polymesh_api_client::IdentityId,
                stash_keys: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Validators(
                    types::pallet_validators::pallet::ValidatorsCall::chill_from_governance {
                        identity,
                        stash_keys,
                    },
                ))
            }
            #[doc = "Governance council forcefully chills a validator. Effects will be felt at the beginning of the next era."]
            #[cfg(feature = "ink")]
            pub fn chill_from_governance(
                &self,
                identity: ::polymesh_api_client::IdentityId,
                stash_keys: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![16u8, 5u8];
                identity.encode_to(&mut buf);
                stash_keys.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes commission rate which applies to all validators. Only Governance"]
            #[doc = "committee is allowed to change this value."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `new_cap` the new commission cap."]
            #[cfg(not(feature = "ink"))]
            pub fn set_commission_cap(
                &self,
                new_cap: ::polymesh_api_client::per_things::Perbill,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Validators(
                    types::pallet_validators::pallet::ValidatorsCall::set_commission_cap {
                        new_cap,
                    },
                ))
            }
            #[doc = "Changes commission rate which applies to all validators. Only Governance"]
            #[doc = "committee is allowed to change this value."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `new_cap` the new commission cap."]
            #[cfg(feature = "ink")]
            pub fn set_commission_cap(
                &self,
                new_cap: ::polymesh_api_client::per_things::Perbill,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![16u8, 6u8];
                new_cap.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for ValidatorsCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct ValidatorsQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> ValidatorsQueryApi<'api> {
            #[doc = " Entities that are allowed to run operator/validator nodes."]
            #[cfg(not(feature = "ink"))]
            pub async fn permissioned_identity(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_validators::types::PermissionedIdentityPrefs>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
                    252u8, 214u8, 225u8, 105u8, 3u8, 43u8, 183u8, 3u8, 134u8, 104u8, 250u8, 251u8,
                    247u8, 56u8, 149u8, 104u8, 159u8, 128u8, 103u8, 131u8, 19u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Entities that are allowed to run operator/validator nodes."]
            #[cfg(feature = "ink")]
            pub fn permissioned_identity(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_validators::types::PermissionedIdentityPrefs>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
                    252u8, 214u8, 225u8, 105u8, 3u8, 43u8, 183u8, 3u8, 134u8, 104u8, 250u8, 251u8,
                    247u8, 56u8, 149u8, 104u8, 159u8, 128u8, 103u8, 131u8, 19u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Slashing switch for validators & Nominators."]
            #[cfg(not(feature = "ink"))]
            pub async fn slashing_allowed_for(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_validators::types::SlashingSwitch>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
                    252u8, 214u8, 225u8, 105u8, 3u8, 231u8, 118u8, 103u8, 194u8, 236u8, 24u8,
                    122u8, 5u8, 185u8, 143u8, 2u8, 137u8, 239u8, 72u8, 161u8, 77u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[2u8];
                    <types::pallet_validators::types::SlashingSwitch>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Slashing switch for validators & Nominators."]
            #[cfg(feature = "ink")]
            pub fn slashing_allowed_for(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_validators::types::SlashingSwitch>
            {
                let value = self.api.read_storage(::alloc::vec![
                    136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
                    252u8, 214u8, 225u8, 105u8, 3u8, 231u8, 118u8, 103u8, 194u8, 236u8, 24u8,
                    122u8, 5u8, 185u8, 143u8, 2u8, 137u8, 239u8, 72u8, 161u8, 77u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[2u8];
                    <types::pallet_validators::types::SlashingSwitch>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Allows flexibility in commission. Every validator has commission that should be in the range [0, Cap]."]
            #[cfg(not(feature = "ink"))]
            pub async fn validator_commission_cap(
                &self,
            ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Perbill>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
                    252u8, 214u8, 225u8, 105u8, 3u8, 153u8, 11u8, 115u8, 89u8, 10u8, 47u8, 61u8,
                    123u8, 111u8, 250u8, 62u8, 6u8, 47u8, 110u8, 11u8, 162u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Allows flexibility in commission. Every validator has commission that should be in the range [0, Cap]."]
            #[cfg(feature = "ink")]
            pub fn validator_commission_cap(
                &self,
            ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Perbill>
            {
                let value = self.api.read_storage(::alloc::vec![
                    136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
                    252u8, 214u8, 225u8, 105u8, 3u8, 153u8, 11u8, 115u8, 89u8, 10u8, 47u8, 61u8,
                    123u8, 111u8, 250u8, 62u8, 6u8, 47u8, 110u8, 11u8, 162u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct ValidatorsPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> ValidatorsPagedQueryApi<'api> {
            #[doc = " Entities that are allowed to run operator/validator nodes."]
            pub fn permissioned_identity(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::IdentityId,
                types::pallet_validators::types::PermissionedIdentityPrefs,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8, 39u8, 238u8, 29u8, 250u8,
                    252u8, 214u8, 225u8, 105u8, 3u8, 43u8, 183u8, 3u8, 134u8, 104u8, 250u8, 251u8,
                    247u8, 56u8, 149u8, 104u8, 159u8, 128u8, 103u8, 131u8, 19u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod staking {
        use super::*;
        #[derive(Clone)]
        pub struct StakingCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> StakingCallApi<'api> {
            #[doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"]
            #[doc = "be the account that controls it."]
            #[doc = ""]
            #[doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the stash account."]
            #[doc = ""]
            #[doc = "Emits `Bonded`."]
            #[doc = "## Complexity"]
            #[doc = "- Independent of the arguments. Moderate complexity."]
            #[doc = "- O(1)."]
            #[doc = "- Three extra DB entries."]
            #[doc = ""]
            #[doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"]
            #[doc = "unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed"]
            #[doc = "as dust."]
            #[cfg(not(feature = "ink"))]
            pub fn bond(
                &self,
                value: u128,
                payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::bond { value, payee },
                ))
            }
            #[doc = "Take the origin account as a stash and lock up `value` of its balance. `controller` will"]
            #[doc = "be the account that controls it."]
            #[doc = ""]
            #[doc = "`value` must be more than the `minimum_balance` specified by `T::Currency`."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the stash account."]
            #[doc = ""]
            #[doc = "Emits `Bonded`."]
            #[doc = "## Complexity"]
            #[doc = "- Independent of the arguments. Moderate complexity."]
            #[doc = "- O(1)."]
            #[doc = "- Three extra DB entries."]
            #[doc = ""]
            #[doc = "NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned"]
            #[doc = "unless the `origin` falls below _existential deposit_ (or equal to 0) and gets removed"]
            #[doc = "as dust."]
            #[cfg(feature = "ink")]
            pub fn bond(
                &self,
                value: u128,
                payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 0u8];
                value.encode_to(&mut buf);
                payee.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"]
            #[doc = "for staking."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
            #[doc = ""]
            #[doc = "Use this if there are additional funds in your stash account that you wish to bond."]
            #[doc = "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose"]
            #[doc = "any limitation on the amount that can be added."]
            #[doc = ""]
            #[doc = "Emits `Bonded`."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- Independent of the arguments. Insignificant complexity."]
            #[doc = "- O(1)."]
            #[cfg(not(feature = "ink"))]
            pub fn bond_extra(
                &self,
                max_additional: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::bond_extra {
                        max_additional,
                    },
                ))
            }
            #[doc = "Add some extra amount that have appeared in the stash `free_balance` into the balance up"]
            #[doc = "for staking."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
            #[doc = ""]
            #[doc = "Use this if there are additional funds in your stash account that you wish to bond."]
            #[doc = "Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose"]
            #[doc = "any limitation on the amount that can be added."]
            #[doc = ""]
            #[doc = "Emits `Bonded`."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- Independent of the arguments. Insignificant complexity."]
            #[doc = "- O(1)."]
            #[cfg(feature = "ink")]
            pub fn bond_extra(&self, max_additional: u128) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 1u8];
                max_additional.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"]
            #[doc = "period ends. If this leaves an amount actively bonded less than"]
            #[doc = "[`asset::existential_deposit`], then it is increased to the full amount."]
            #[doc = ""]
            #[doc = "The stash may be chilled if the ledger total amount falls to 0 after unbonding."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[doc = ""]
            #[doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"]
            #[doc = "the funds out of management ready for transfer."]
            #[doc = ""]
            #[doc = "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)"]
            #[doc = "can co-exists at the same time. If there are no unlocking chunks slots available"]
            #[doc = "[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible)."]
            #[doc = ""]
            #[doc = "If a user encounters the `InsufficientBond` error when calling this extrinsic,"]
            #[doc = "they should call `chill` first in order to free up their bonded funds."]
            #[doc = ""]
            #[doc = "Emits `Unbonded`."]
            #[doc = ""]
            #[doc = "See also [`Call::withdraw_unbonded`]."]
            #[cfg(not(feature = "ink"))]
            pub fn unbond(
                &self,
                value: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::unbond { value },
                ))
            }
            #[doc = "Schedule a portion of the stash to be unlocked ready for transfer out after the bond"]
            #[doc = "period ends. If this leaves an amount actively bonded less than"]
            #[doc = "[`asset::existential_deposit`], then it is increased to the full amount."]
            #[doc = ""]
            #[doc = "The stash may be chilled if the ledger total amount falls to 0 after unbonding."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[doc = ""]
            #[doc = "Once the unlock period is done, you can call `withdraw_unbonded` to actually move"]
            #[doc = "the funds out of management ready for transfer."]
            #[doc = ""]
            #[doc = "No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)"]
            #[doc = "can co-exists at the same time. If there are no unlocking chunks slots available"]
            #[doc = "[`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible)."]
            #[doc = ""]
            #[doc = "If a user encounters the `InsufficientBond` error when calling this extrinsic,"]
            #[doc = "they should call `chill` first in order to free up their bonded funds."]
            #[doc = ""]
            #[doc = "Emits `Unbonded`."]
            #[doc = ""]
            #[doc = "See also [`Call::withdraw_unbonded`]."]
            #[cfg(feature = "ink")]
            pub fn unbond(&self, value: u128) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 2u8];
                value.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Remove any unlocked chunks from the `unlocking` queue from our management."]
            #[doc = ""]
            #[doc = "This essentially frees up that balance to be used by the stash account to do whatever"]
            #[doc = "it wants."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller."]
            #[doc = ""]
            #[doc = "Emits `Withdrawn`."]
            #[doc = ""]
            #[doc = "See also [`Call::unbond`]."]
            #[doc = ""]
            #[doc = "## Parameters"]
            #[doc = ""]
            #[doc = "- `num_slashing_spans` indicates the number of metadata slashing spans to clear when"]
            #[doc = "this call results in a complete removal of all the data related to the stash account."]
            #[doc = "In this case, the `num_slashing_spans` must be larger or equal to the number of"]
            #[doc = "slashing spans associated with the stash account in the [`SlashingSpans`] storage type,"]
            #[doc = "otherwise the call will fail. The call weight is directly proportional to"]
            #[doc = "`num_slashing_spans`."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "O(S) where S is the number of slashing spans to remove"]
            #[doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."]
            #[cfg(not(feature = "ink"))]
            pub fn withdraw_unbonded(
                &self,
                num_slashing_spans: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::withdraw_unbonded {
                        num_slashing_spans,
                    },
                ))
            }
            #[doc = "Remove any unlocked chunks from the `unlocking` queue from our management."]
            #[doc = ""]
            #[doc = "This essentially frees up that balance to be used by the stash account to do whatever"]
            #[doc = "it wants."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller."]
            #[doc = ""]
            #[doc = "Emits `Withdrawn`."]
            #[doc = ""]
            #[doc = "See also [`Call::unbond`]."]
            #[doc = ""]
            #[doc = "## Parameters"]
            #[doc = ""]
            #[doc = "- `num_slashing_spans` indicates the number of metadata slashing spans to clear when"]
            #[doc = "this call results in a complete removal of all the data related to the stash account."]
            #[doc = "In this case, the `num_slashing_spans` must be larger or equal to the number of"]
            #[doc = "slashing spans associated with the stash account in the [`SlashingSpans`] storage type,"]
            #[doc = "otherwise the call will fail. The call weight is directly proportional to"]
            #[doc = "`num_slashing_spans`."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "O(S) where S is the number of slashing spans to remove"]
            #[doc = "NOTE: Weight annotation is the kill scenario, we refund otherwise."]
            #[cfg(feature = "ink")]
            pub fn withdraw_unbonded(&self, num_slashing_spans: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 3u8];
                num_slashing_spans.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Declare the desire to validate for the origin controller."]
            #[doc = ""]
            #[doc = "Effects will be felt at the beginning of the next era."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[cfg(not(feature = "ink"))]
            pub fn validate(
                &self,
                prefs: types::pallet_staking::ValidatorPrefs,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::validate { prefs },
                ))
            }
            #[doc = "Declare the desire to validate for the origin controller."]
            #[doc = ""]
            #[doc = "Effects will be felt at the beginning of the next era."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[cfg(feature = "ink")]
            pub fn validate(
                &self,
                prefs: types::pallet_staking::ValidatorPrefs,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 4u8];
                prefs.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Declare the desire to nominate `targets` for the origin controller."]
            #[doc = ""]
            #[doc = "Effects will be felt at the beginning of the next era."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- The transaction's complexity is proportional to the size of `targets` (N)"]
            #[doc = "which is capped at CompactAssignments::LIMIT (T::MaxNominations)."]
            #[doc = "- Both the reads and writes follow a similar pattern."]
            #[cfg(not(feature = "ink"))]
            pub fn nominate(
                &self,
                targets: ::alloc::vec::Vec<
                    ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::nominate { targets },
                ))
            }
            #[doc = "Declare the desire to nominate `targets` for the origin controller."]
            #[doc = ""]
            #[doc = "Effects will be felt at the beginning of the next era."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- The transaction's complexity is proportional to the size of `targets` (N)"]
            #[doc = "which is capped at CompactAssignments::LIMIT (T::MaxNominations)."]
            #[doc = "- Both the reads and writes follow a similar pattern."]
            #[cfg(feature = "ink")]
            pub fn nominate(
                &self,
                targets: ::alloc::vec::Vec<
                    ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 5u8];
                targets.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Declare no desire to either validate or nominate."]
            #[doc = ""]
            #[doc = "Effects will be felt at the beginning of the next era."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- Independent of the arguments. Insignificant complexity."]
            #[doc = "- Contains one read."]
            #[doc = "- Writes are limited to the `origin` account key."]
            #[cfg(not(feature = "ink"))]
            pub fn chill(&self) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::chill,
                ))
            }
            #[doc = "Declare no desire to either validate or nominate."]
            #[doc = ""]
            #[doc = "Effects will be felt at the beginning of the next era."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- Independent of the arguments. Insignificant complexity."]
            #[doc = "- Contains one read."]
            #[doc = "- Writes are limited to the `origin` account key."]
            #[cfg(feature = "ink")]
            pub fn chill(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![17u8, 6u8])
            }
            #[doc = "(Re-)set the payment target for a controller."]
            #[doc = ""]
            #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- O(1)"]
            #[doc = "- Independent of the arguments. Insignificant complexity."]
            #[doc = "- Contains a limited number of reads."]
            #[doc = "- Writes are limited to the `origin` account key."]
            #[doc = "---------"]
            #[cfg(not(feature = "ink"))]
            pub fn set_payee(
                &self,
                payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::set_payee { payee },
                ))
            }
            #[doc = "(Re-)set the payment target for a controller."]
            #[doc = ""]
            #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- O(1)"]
            #[doc = "- Independent of the arguments. Insignificant complexity."]
            #[doc = "- Contains a limited number of reads."]
            #[doc = "- Writes are limited to the `origin` account key."]
            #[doc = "---------"]
            #[cfg(feature = "ink")]
            pub fn set_payee(
                &self,
                payee: types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 7u8];
                payee.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "(Re-)sets the controller of a stash to the stash itself. This function previously"]
            #[doc = "accepted a `controller` argument to set the controller to an account other than the"]
            #[doc = "stash itself. This functionality has now been removed, now only setting the controller"]
            #[doc = "to the stash, if it is not already."]
            #[doc = ""]
            #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "O(1)"]
            #[doc = "- Independent of the arguments. Insignificant complexity."]
            #[doc = "- Contains a limited number of reads."]
            #[doc = "- Writes are limited to the `origin` account key."]
            #[cfg(not(feature = "ink"))]
            pub fn set_controller(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::set_controller,
                ))
            }
            #[doc = "(Re-)sets the controller of a stash to the stash itself. This function previously"]
            #[doc = "accepted a `controller` argument to set the controller to an account other than the"]
            #[doc = "stash itself. This functionality has now been removed, now only setting the controller"]
            #[doc = "to the stash, if it is not already."]
            #[doc = ""]
            #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the stash, not the controller."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "O(1)"]
            #[doc = "- Independent of the arguments. Insignificant complexity."]
            #[doc = "- Contains a limited number of reads."]
            #[doc = "- Writes are limited to the `origin` account key."]
            #[cfg(feature = "ink")]
            pub fn set_controller(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![17u8, 8u8])
            }
            #[doc = "Sets the ideal number of validators."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "O(1)"]
            #[cfg(not(feature = "ink"))]
            pub fn set_validator_count(
                &self,
                new: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::set_validator_count { new },
                ))
            }
            #[doc = "Sets the ideal number of validators."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "O(1)"]
            #[cfg(feature = "ink")]
            pub fn set_validator_count(&self, new: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 9u8];
                new.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Increments the ideal number of validators up to maximum of"]
            #[doc = "`ElectionProviderBase::MaxWinners`."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "Same as [`Self::set_validator_count`]."]
            #[cfg(not(feature = "ink"))]
            pub fn increase_validator_count(
                &self,
                additional: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::increase_validator_count {
                        additional,
                    },
                ))
            }
            #[doc = "Increments the ideal number of validators up to maximum of"]
            #[doc = "`ElectionProviderBase::MaxWinners`."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "Same as [`Self::set_validator_count`]."]
            #[cfg(feature = "ink")]
            pub fn increase_validator_count(&self, additional: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 10u8];
                additional.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Scale up the ideal number of validators by a factor up to maximum of"]
            #[doc = "`ElectionProviderBase::MaxWinners`."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "Same as [`Self::set_validator_count`]."]
            #[cfg(not(feature = "ink"))]
            pub fn scale_validator_count(
                &self,
                factor: ::polymesh_api_client::per_things::Percent,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::scale_validator_count {
                        factor,
                    },
                ))
            }
            #[doc = "Scale up the ideal number of validators by a factor up to maximum of"]
            #[doc = "`ElectionProviderBase::MaxWinners`."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "Same as [`Self::set_validator_count`]."]
            #[cfg(feature = "ink")]
            pub fn scale_validator_count(
                &self,
                factor: ::polymesh_api_client::per_things::Percent,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 11u8];
                factor.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Force there to be no new eras indefinitely."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "# Warning"]
            #[doc = ""]
            #[doc = "The election process starts multiple blocks before the end of the era."]
            #[doc = "Thus the election process may be ongoing when this is called. In this case the"]
            #[doc = "election will continue until the next era is triggered."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- No arguments."]
            #[doc = "- Weight: O(1)"]
            #[cfg(not(feature = "ink"))]
            pub fn force_no_eras(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::force_no_eras,
                ))
            }
            #[doc = "Force there to be no new eras indefinitely."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "# Warning"]
            #[doc = ""]
            #[doc = "The election process starts multiple blocks before the end of the era."]
            #[doc = "Thus the election process may be ongoing when this is called. In this case the"]
            #[doc = "election will continue until the next era is triggered."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- No arguments."]
            #[doc = "- Weight: O(1)"]
            #[cfg(feature = "ink")]
            pub fn force_no_eras(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![17u8, 12u8])
            }
            #[doc = "Force there to be a new era at the end of the next session. After this, it will be"]
            #[doc = "reset to normal (non-forced) behaviour."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "# Warning"]
            #[doc = ""]
            #[doc = "The election process starts multiple blocks before the end of the era."]
            #[doc = "If this is called just before a new era is triggered, the election process may not"]
            #[doc = "have enough blocks to get a result."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- No arguments."]
            #[doc = "- Weight: O(1)"]
            #[cfg(not(feature = "ink"))]
            pub fn force_new_era(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::force_new_era,
                ))
            }
            #[doc = "Force there to be a new era at the end of the next session. After this, it will be"]
            #[doc = "reset to normal (non-forced) behaviour."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "# Warning"]
            #[doc = ""]
            #[doc = "The election process starts multiple blocks before the end of the era."]
            #[doc = "If this is called just before a new era is triggered, the election process may not"]
            #[doc = "have enough blocks to get a result."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- No arguments."]
            #[doc = "- Weight: O(1)"]
            #[cfg(feature = "ink")]
            pub fn force_new_era(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![17u8, 13u8])
            }
            #[doc = "Set the validators who cannot be slashed (if any)."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[cfg(not(feature = "ink"))]
            pub fn set_invulnerables(
                &self,
                invulnerables: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::set_invulnerables {
                        invulnerables,
                    },
                ))
            }
            #[doc = "Set the validators who cannot be slashed (if any)."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[cfg(feature = "ink")]
            pub fn set_invulnerables(
                &self,
                invulnerables: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 14u8];
                invulnerables.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Force a current staker to become completely unstaked, immediately."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "## Parameters"]
            #[doc = ""]
            #[doc = "- `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more"]
            #[doc = "details."]
            #[cfg(not(feature = "ink"))]
            pub fn force_unstake(
                &self,
                stash: ::polymesh_api_client::AccountId,
                num_slashing_spans: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::force_unstake {
                        stash,
                        num_slashing_spans,
                    },
                ))
            }
            #[doc = "Force a current staker to become completely unstaked, immediately."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "## Parameters"]
            #[doc = ""]
            #[doc = "- `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more"]
            #[doc = "details."]
            #[cfg(feature = "ink")]
            pub fn force_unstake(
                &self,
                stash: ::polymesh_api_client::AccountId,
                num_slashing_spans: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 15u8];
                stash.encode_to(&mut buf);
                num_slashing_spans.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Force there to be a new era at the end of sessions indefinitely."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "# Warning"]
            #[doc = ""]
            #[doc = "The election process starts multiple blocks before the end of the era."]
            #[doc = "If this is called just before a new era is triggered, the election process may not"]
            #[doc = "have enough blocks to get a result."]
            #[cfg(not(feature = "ink"))]
            pub fn force_new_era_always(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::force_new_era_always,
                ))
            }
            #[doc = "Force there to be a new era at the end of sessions indefinitely."]
            #[doc = ""]
            #[doc = "The dispatch origin must be Root."]
            #[doc = ""]
            #[doc = "# Warning"]
            #[doc = ""]
            #[doc = "The election process starts multiple blocks before the end of the era."]
            #[doc = "If this is called just before a new era is triggered, the election process may not"]
            #[doc = "have enough blocks to get a result."]
            #[cfg(feature = "ink")]
            pub fn force_new_era_always(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![17u8, 16u8])
            }
            #[doc = "Cancel enactment of a deferred slash."]
            #[doc = ""]
            #[doc = "Can be called by the `T::AdminOrigin`."]
            #[doc = ""]
            #[doc = "Parameters: era and indices of the slashes for that era to kill."]
            #[doc = "They **must** be sorted in ascending order, *and* unique."]
            #[cfg(not(feature = "ink"))]
            pub fn cancel_deferred_slash(
                &self,
                era: u32,
                slash_indices: ::alloc::vec::Vec<u32>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::cancel_deferred_slash {
                        era,
                        slash_indices,
                    },
                ))
            }
            #[doc = "Cancel enactment of a deferred slash."]
            #[doc = ""]
            #[doc = "Can be called by the `T::AdminOrigin`."]
            #[doc = ""]
            #[doc = "Parameters: era and indices of the slashes for that era to kill."]
            #[doc = "They **must** be sorted in ascending order, *and* unique."]
            #[cfg(feature = "ink")]
            pub fn cancel_deferred_slash(
                &self,
                era: u32,
                slash_indices: ::alloc::vec::Vec<u32>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 17u8];
                era.encode_to(&mut buf);
                slash_indices.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Pay out next page of the stakers behind a validator for the given era."]
            #[doc = ""]
            #[doc = "- `validator_stash` is the stash account of the validator."]
            #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
            #[doc = ""]
            #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
            #[doc = "it is not one of the stakers."]
            #[doc = ""]
            #[doc = "The reward payout could be paged in case there are too many nominators backing the"]
            #[doc = "`validator_stash`. This call will payout unpaid pages in an ascending order. To claim a"]
            #[doc = "specific page, use `payout_stakers_by_page`.`"]
            #[doc = ""]
            #[doc = "If all pages are claimed, it returns an error `InvalidPage`."]
            #[cfg(not(feature = "ink"))]
            pub fn payout_stakers(
                &self,
                validator_stash: ::polymesh_api_client::AccountId,
                era: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::payout_stakers {
                        validator_stash,
                        era,
                    },
                ))
            }
            #[doc = "Pay out next page of the stakers behind a validator for the given era."]
            #[doc = ""]
            #[doc = "- `validator_stash` is the stash account of the validator."]
            #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
            #[doc = ""]
            #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
            #[doc = "it is not one of the stakers."]
            #[doc = ""]
            #[doc = "The reward payout could be paged in case there are too many nominators backing the"]
            #[doc = "`validator_stash`. This call will payout unpaid pages in an ascending order. To claim a"]
            #[doc = "specific page, use `payout_stakers_by_page`.`"]
            #[doc = ""]
            #[doc = "If all pages are claimed, it returns an error `InvalidPage`."]
            #[cfg(feature = "ink")]
            pub fn payout_stakers(
                &self,
                validator_stash: ::polymesh_api_client::AccountId,
                era: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 18u8];
                validator_stash.encode_to(&mut buf);
                era.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Rebond a portion of the stash scheduled to be unlocked."]
            #[doc = ""]
            #[doc = "The dispatch origin must be signed by the controller."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- Time complexity: O(L), where L is unlocking chunks"]
            #[doc = "- Bounded by `MaxUnlockingChunks`."]
            #[cfg(not(feature = "ink"))]
            pub fn rebond(
                &self,
                value: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::rebond { value },
                ))
            }
            #[doc = "Rebond a portion of the stash scheduled to be unlocked."]
            #[doc = ""]
            #[doc = "The dispatch origin must be signed by the controller."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- Time complexity: O(L), where L is unlocking chunks"]
            #[doc = "- Bounded by `MaxUnlockingChunks`."]
            #[cfg(feature = "ink")]
            pub fn rebond(&self, value: u128) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 19u8];
                value.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Remove all data structures concerning a staker/stash once it is at a state where it can"]
            #[doc = "be considered `dust` in the staking system. The requirements are:"]
            #[doc = ""]
            #[doc = "1. the `total_balance` of the stash is below existential deposit."]
            #[doc = "2. or, the `ledger.total` of the stash is below existential deposit."]
            #[doc = "3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero."]
            #[doc = ""]
            #[doc = "The former can happen in cases like a slash; the latter when a fully unbonded account"]
            #[doc = "is still receiving staking rewards in `RewardDestination::Staked`."]
            #[doc = ""]
            #[doc = "It can be called by anyone, as long as `stash` meets the above requirements."]
            #[doc = ""]
            #[doc = "Refunds the transaction fees upon successful execution."]
            #[doc = ""]
            #[doc = "## Parameters"]
            #[doc = ""]
            #[doc = "- `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more"]
            #[doc = "details."]
            #[cfg(not(feature = "ink"))]
            pub fn reap_stash(
                &self,
                stash: ::polymesh_api_client::AccountId,
                num_slashing_spans: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::reap_stash {
                        stash,
                        num_slashing_spans,
                    },
                ))
            }
            #[doc = "Remove all data structures concerning a staker/stash once it is at a state where it can"]
            #[doc = "be considered `dust` in the staking system. The requirements are:"]
            #[doc = ""]
            #[doc = "1. the `total_balance` of the stash is below existential deposit."]
            #[doc = "2. or, the `ledger.total` of the stash is below existential deposit."]
            #[doc = "3. or, existential deposit is zero and either `total_balance` or `ledger.total` is zero."]
            #[doc = ""]
            #[doc = "The former can happen in cases like a slash; the latter when a fully unbonded account"]
            #[doc = "is still receiving staking rewards in `RewardDestination::Staked`."]
            #[doc = ""]
            #[doc = "It can be called by anyone, as long as `stash` meets the above requirements."]
            #[doc = ""]
            #[doc = "Refunds the transaction fees upon successful execution."]
            #[doc = ""]
            #[doc = "## Parameters"]
            #[doc = ""]
            #[doc = "- `num_slashing_spans`: Refer to comments on [`Call::withdraw_unbonded`] for more"]
            #[doc = "details."]
            #[cfg(feature = "ink")]
            pub fn reap_stash(
                &self,
                stash: ::polymesh_api_client::AccountId,
                num_slashing_spans: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 20u8];
                stash.encode_to(&mut buf);
                num_slashing_spans.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Remove the given nominations from the calling validator."]
            #[doc = ""]
            #[doc = "Effects will be felt at the beginning of the next era."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[doc = ""]
            #[doc = "- `who`: A list of nominator stash accounts who are nominating this validator which"]
            #[doc = "  should no longer be nominating this validator."]
            #[doc = ""]
            #[doc = "Note: Making this call only makes sense if you first set the validator preferences to"]
            #[doc = "block any further nominations."]
            #[cfg(not(feature = "ink"))]
            pub fn kick(
                &self,
                who: ::alloc::vec::Vec<
                    ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::kick { who },
                ))
            }
            #[doc = "Remove the given nominations from the calling validator."]
            #[doc = ""]
            #[doc = "Effects will be felt at the beginning of the next era."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_ by the controller, not the stash."]
            #[doc = ""]
            #[doc = "- `who`: A list of nominator stash accounts who are nominating this validator which"]
            #[doc = "  should no longer be nominating this validator."]
            #[doc = ""]
            #[doc = "Note: Making this call only makes sense if you first set the validator preferences to"]
            #[doc = "block any further nominations."]
            #[cfg(feature = "ink")]
            pub fn kick(
                &self,
                who: ::alloc::vec::Vec<
                    ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 21u8];
                who.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Update the various staking configurations ."]
            #[doc = ""]
            #[doc = "* `min_nominator_bond`: The minimum active bond needed to be a nominator."]
            #[doc = "* `min_validator_bond`: The minimum active bond needed to be a validator."]
            #[doc = "* `max_nominator_count`: The max number of users who can be a nominator at once. When"]
            #[doc = "  set to `None`, no limit is enforced."]
            #[doc = "* `max_validator_count`: The max number of users who can be a validator at once. When"]
            #[doc = "  set to `None`, no limit is enforced."]
            #[doc = "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which"]
            #[doc = "  should be filled in order for the `chill_other` transaction to work."]
            #[doc = "* `min_commission`: The minimum amount of commission that each validators must maintain."]
            #[doc = "  This is checked only upon calling `validate`. Existing validators are not affected."]
            #[doc = ""]
            #[doc = "RuntimeOrigin must be Root to call this function."]
            #[doc = ""]
            #[doc = "NOTE: Existing nominators and validators will not be affected by this update."]
            #[doc = "to kick people under the new limits, `chill_other` should be called."]
            #[cfg(not(feature = "ink"))]
            pub fn set_staking_configs(
                &self,
                min_nominator_bond: types::pallet_staking::pallet::pallet::ConfigOp<u128>,
                min_validator_bond: types::pallet_staking::pallet::pallet::ConfigOp<u128>,
                max_nominator_count: types::pallet_staking::pallet::pallet::ConfigOp<u32>,
                max_validator_count: types::pallet_staking::pallet::pallet::ConfigOp<u32>,
                chill_threshold: types::pallet_staking::pallet::pallet::ConfigOp<
                    ::polymesh_api_client::per_things::Percent,
                >,
                min_commission: types::pallet_staking::pallet::pallet::ConfigOp<
                    ::polymesh_api_client::per_things::Perbill,
                >,
                max_staked_rewards: types::pallet_staking::pallet::pallet::ConfigOp<
                    ::polymesh_api_client::per_things::Percent,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::set_staking_configs {
                        min_nominator_bond,
                        min_validator_bond,
                        max_nominator_count,
                        max_validator_count,
                        chill_threshold,
                        min_commission,
                        max_staked_rewards,
                    },
                ))
            }
            #[doc = "Update the various staking configurations ."]
            #[doc = ""]
            #[doc = "* `min_nominator_bond`: The minimum active bond needed to be a nominator."]
            #[doc = "* `min_validator_bond`: The minimum active bond needed to be a validator."]
            #[doc = "* `max_nominator_count`: The max number of users who can be a nominator at once. When"]
            #[doc = "  set to `None`, no limit is enforced."]
            #[doc = "* `max_validator_count`: The max number of users who can be a validator at once. When"]
            #[doc = "  set to `None`, no limit is enforced."]
            #[doc = "* `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which"]
            #[doc = "  should be filled in order for the `chill_other` transaction to work."]
            #[doc = "* `min_commission`: The minimum amount of commission that each validators must maintain."]
            #[doc = "  This is checked only upon calling `validate`. Existing validators are not affected."]
            #[doc = ""]
            #[doc = "RuntimeOrigin must be Root to call this function."]
            #[doc = ""]
            #[doc = "NOTE: Existing nominators and validators will not be affected by this update."]
            #[doc = "to kick people under the new limits, `chill_other` should be called."]
            #[cfg(feature = "ink")]
            pub fn set_staking_configs(
                &self,
                min_nominator_bond: types::pallet_staking::pallet::pallet::ConfigOp<u128>,
                min_validator_bond: types::pallet_staking::pallet::pallet::ConfigOp<u128>,
                max_nominator_count: types::pallet_staking::pallet::pallet::ConfigOp<u32>,
                max_validator_count: types::pallet_staking::pallet::pallet::ConfigOp<u32>,
                chill_threshold: types::pallet_staking::pallet::pallet::ConfigOp<
                    ::polymesh_api_client::per_things::Percent,
                >,
                min_commission: types::pallet_staking::pallet::pallet::ConfigOp<
                    ::polymesh_api_client::per_things::Perbill,
                >,
                max_staked_rewards: types::pallet_staking::pallet::pallet::ConfigOp<
                    ::polymesh_api_client::per_things::Percent,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 22u8];
                min_nominator_bond.encode_to(&mut buf);
                min_validator_bond.encode_to(&mut buf);
                max_nominator_count.encode_to(&mut buf);
                max_validator_count.encode_to(&mut buf);
                chill_threshold.encode_to(&mut buf);
                min_commission.encode_to(&mut buf);
                max_staked_rewards.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Declare a `controller` to stop participating as either a validator or nominator."]
            #[doc = ""]
            #[doc = "Effects will be felt at the beginning of the next era."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_, but can be called by anyone."]
            #[doc = ""]
            #[doc = "If the caller is the same as the controller being targeted, then no further checks are"]
            #[doc = "enforced, and this function behaves just like `chill`."]
            #[doc = ""]
            #[doc = "If the caller is different than the controller being targeted, the following conditions"]
            #[doc = "must be met:"]
            #[doc = ""]
            #[doc = "* `controller` must belong to a nominator who has become non-decodable,"]
            #[doc = ""]
            #[doc = "Or:"]
            #[doc = ""]
            #[doc = "* A `ChillThreshold` must be set and checked which defines how close to the max"]
            #[doc = "  nominators or validators we must reach before users can start chilling one-another."]
            #[doc = "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine"]
            #[doc = "  how close we are to the threshold."]
            #[doc = "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines"]
            #[doc = "  if this is a person that should be chilled because they have not met the threshold"]
            #[doc = "  bond required."]
            #[doc = ""]
            #[doc = "This can be helpful if bond requirements are updated, and we need to remove old users"]
            #[doc = "who do not satisfy these requirements."]
            #[cfg(not(feature = "ink"))]
            pub fn chill_other(
                &self,
                stash: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::chill_other { stash },
                ))
            }
            #[doc = "Declare a `controller` to stop participating as either a validator or nominator."]
            #[doc = ""]
            #[doc = "Effects will be felt at the beginning of the next era."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_, but can be called by anyone."]
            #[doc = ""]
            #[doc = "If the caller is the same as the controller being targeted, then no further checks are"]
            #[doc = "enforced, and this function behaves just like `chill`."]
            #[doc = ""]
            #[doc = "If the caller is different than the controller being targeted, the following conditions"]
            #[doc = "must be met:"]
            #[doc = ""]
            #[doc = "* `controller` must belong to a nominator who has become non-decodable,"]
            #[doc = ""]
            #[doc = "Or:"]
            #[doc = ""]
            #[doc = "* A `ChillThreshold` must be set and checked which defines how close to the max"]
            #[doc = "  nominators or validators we must reach before users can start chilling one-another."]
            #[doc = "* A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine"]
            #[doc = "  how close we are to the threshold."]
            #[doc = "* A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines"]
            #[doc = "  if this is a person that should be chilled because they have not met the threshold"]
            #[doc = "  bond required."]
            #[doc = ""]
            #[doc = "This can be helpful if bond requirements are updated, and we need to remove old users"]
            #[doc = "who do not satisfy these requirements."]
            #[cfg(feature = "ink")]
            pub fn chill_other(
                &self,
                stash: ::polymesh_api_client::AccountId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 23u8];
                stash.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Force a validator to have at least the minimum commission. This will not affect a"]
            #[doc = "validator who already has a commission greater than or equal to the minimum. Any account"]
            #[doc = "can call this."]
            #[cfg(not(feature = "ink"))]
            pub fn force_apply_min_commission(
                &self,
                validator_stash: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Staking (types :: pallet_staking :: pallet :: pallet :: StakingCall :: force_apply_min_commission { validator_stash , }))
            }
            #[doc = "Force a validator to have at least the minimum commission. This will not affect a"]
            #[doc = "validator who already has a commission greater than or equal to the minimum. Any account"]
            #[doc = "can call this."]
            #[cfg(feature = "ink")]
            pub fn force_apply_min_commission(
                &self,
                validator_stash: ::polymesh_api_client::AccountId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 24u8];
                validator_stash.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Sets the minimum amount of commission that each validators must maintain."]
            #[doc = ""]
            #[doc = "This call has lower privilege requirements than `set_staking_config` and can be called"]
            #[doc = "by the `T::AdminOrigin`. Root can always call this."]
            #[cfg(not(feature = "ink"))]
            pub fn set_min_commission(
                &self,
                new: ::polymesh_api_client::per_things::Perbill,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::set_min_commission { new },
                ))
            }
            #[doc = "Sets the minimum amount of commission that each validators must maintain."]
            #[doc = ""]
            #[doc = "This call has lower privilege requirements than `set_staking_config` and can be called"]
            #[doc = "by the `T::AdminOrigin`. Root can always call this."]
            #[cfg(feature = "ink")]
            pub fn set_min_commission(
                &self,
                new: ::polymesh_api_client::per_things::Perbill,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 25u8];
                new.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Pay out a page of the stakers behind a validator for the given era and page."]
            #[doc = ""]
            #[doc = "- `validator_stash` is the stash account of the validator."]
            #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
            #[doc = "- `page` is the page index of nominators to pay out with value between 0 and"]
            #[doc = "  `num_nominators / T::MaxExposurePageSize`."]
            #[doc = ""]
            #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
            #[doc = "it is not one of the stakers."]
            #[doc = ""]
            #[doc = "If a validator has more than [`Config::MaxExposurePageSize`] nominators backing"]
            #[doc = "them, then the list of nominators is paged, with each page being capped at"]
            #[doc = "[`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,"]
            #[doc = "the call needs to be made for each page separately in order for all the nominators"]
            #[doc = "backing a validator to receive the reward. The nominators are not sorted across pages"]
            #[doc = "and so it should not be assumed the highest staker would be on the topmost page and vice"]
            #[doc = "versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost."]
            #[cfg(not(feature = "ink"))]
            pub fn payout_stakers_by_page(
                &self,
                validator_stash: ::polymesh_api_client::AccountId,
                era: u32,
                page: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::payout_stakers_by_page {
                        validator_stash,
                        era,
                        page,
                    },
                ))
            }
            #[doc = "Pay out a page of the stakers behind a validator for the given era and page."]
            #[doc = ""]
            #[doc = "- `validator_stash` is the stash account of the validator."]
            #[doc = "- `era` may be any era between `[current_era - history_depth; current_era]`."]
            #[doc = "- `page` is the page index of nominators to pay out with value between 0 and"]
            #[doc = "  `num_nominators / T::MaxExposurePageSize`."]
            #[doc = ""]
            #[doc = "The origin of this call must be _Signed_. Any account can call this function, even if"]
            #[doc = "it is not one of the stakers."]
            #[doc = ""]
            #[doc = "If a validator has more than [`Config::MaxExposurePageSize`] nominators backing"]
            #[doc = "them, then the list of nominators is paged, with each page being capped at"]
            #[doc = "[`Config::MaxExposurePageSize`.] If a validator has more than one page of nominators,"]
            #[doc = "the call needs to be made for each page separately in order for all the nominators"]
            #[doc = "backing a validator to receive the reward. The nominators are not sorted across pages"]
            #[doc = "and so it should not be assumed the highest staker would be on the topmost page and vice"]
            #[doc = "versa. If rewards are not claimed in [`Config::HistoryDepth`] eras, they are lost."]
            #[cfg(feature = "ink")]
            pub fn payout_stakers_by_page(
                &self,
                validator_stash: ::polymesh_api_client::AccountId,
                era: u32,
                page: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 26u8];
                validator_stash.encode_to(&mut buf);
                era.encode_to(&mut buf);
                page.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Migrates an account's `RewardDestination::Controller` to"]
            #[doc = "`RewardDestination::Account(controller)`."]
            #[doc = ""]
            #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
            #[doc = ""]
            #[doc = "This will waive the transaction fee if the `payee` is successfully migrated."]
            #[cfg(not(feature = "ink"))]
            pub fn update_payee(
                &self,
                controller: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::update_payee { controller },
                ))
            }
            #[doc = "Migrates an account's `RewardDestination::Controller` to"]
            #[doc = "`RewardDestination::Account(controller)`."]
            #[doc = ""]
            #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
            #[doc = ""]
            #[doc = "This will waive the transaction fee if the `payee` is successfully migrated."]
            #[cfg(feature = "ink")]
            pub fn update_payee(
                &self,
                controller: ::polymesh_api_client::AccountId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 27u8];
                controller.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Updates a batch of controller accounts to their corresponding stash account if they are"]
            #[doc = "not the same. Ignores any controller accounts that do not exist, and does not operate if"]
            #[doc = "the stash and controller are already the same."]
            #[doc = ""]
            #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
            #[doc = ""]
            #[doc = "The dispatch origin must be `T::AdminOrigin`."]
            #[cfg(not(feature = "ink"))]
            pub fn deprecate_controller_batch(
                &self,
                controllers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Staking (types :: pallet_staking :: pallet :: pallet :: StakingCall :: deprecate_controller_batch { controllers , }))
            }
            #[doc = "Updates a batch of controller accounts to their corresponding stash account if they are"]
            #[doc = "not the same. Ignores any controller accounts that do not exist, and does not operate if"]
            #[doc = "the stash and controller are already the same."]
            #[doc = ""]
            #[doc = "Effects will be felt instantly (as soon as this function is completed successfully)."]
            #[doc = ""]
            #[doc = "The dispatch origin must be `T::AdminOrigin`."]
            #[cfg(feature = "ink")]
            pub fn deprecate_controller_batch(
                &self,
                controllers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 28u8];
                controllers.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Restores the state of a ledger which is in an inconsistent state."]
            #[doc = ""]
            #[doc = "The requirements to restore a ledger are the following:"]
            #[doc = "* The stash is bonded; or"]
            #[doc = "* The stash is not bonded but it has a staking lock left behind; or"]
            #[doc = "* If the stash has an associated ledger and its state is inconsistent; or"]
            #[doc = "* If the ledger is not corrupted *but* its staking lock is out of sync."]
            #[doc = ""]
            #[doc = "The `maybe_*` input parameters will overwrite the corresponding data and metadata of the"]
            #[doc = "ledger associated with the stash. If the input parameters are not set, the ledger will"]
            #[doc = "be reset values from on-chain state."]
            #[cfg(not(feature = "ink"))]
            pub fn restore_ledger(
                &self,
                stash: ::polymesh_api_client::AccountId,
                maybe_controller: Option<::polymesh_api_client::AccountId>,
                maybe_total: Option<u128>,
                maybe_unlocking: Option<
                    ::alloc::vec::Vec<types::pallet_staking::UnlockChunk<u128>>,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::restore_ledger {
                        stash,
                        maybe_controller,
                        maybe_total,
                        maybe_unlocking,
                    },
                ))
            }
            #[doc = "Restores the state of a ledger which is in an inconsistent state."]
            #[doc = ""]
            #[doc = "The requirements to restore a ledger are the following:"]
            #[doc = "* The stash is bonded; or"]
            #[doc = "* The stash is not bonded but it has a staking lock left behind; or"]
            #[doc = "* If the stash has an associated ledger and its state is inconsistent; or"]
            #[doc = "* If the ledger is not corrupted *but* its staking lock is out of sync."]
            #[doc = ""]
            #[doc = "The `maybe_*` input parameters will overwrite the corresponding data and metadata of the"]
            #[doc = "ledger associated with the stash. If the input parameters are not set, the ledger will"]
            #[doc = "be reset values from on-chain state."]
            #[cfg(feature = "ink")]
            pub fn restore_ledger(
                &self,
                stash: ::polymesh_api_client::AccountId,
                maybe_controller: Option<::polymesh_api_client::AccountId>,
                maybe_total: Option<u128>,
                maybe_unlocking: Option<
                    ::alloc::vec::Vec<types::pallet_staking::UnlockChunk<u128>>,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 29u8];
                stash.encode_to(&mut buf);
                maybe_controller.encode_to(&mut buf);
                maybe_total.encode_to(&mut buf);
                maybe_unlocking.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the legacy Staking locks if they exist."]
            #[doc = ""]
            #[doc = "This removes the legacy lock on the stake with [`Config::OldCurrency`] and creates a"]
            #[doc = "hold on it if needed. If all stake cannot be held, the best effort is made to hold as"]
            #[doc = "much as possible. The remaining stake is forced withdrawn from the ledger."]
            #[doc = ""]
            #[doc = "The fee is waived if the migration is successful."]
            #[cfg(not(feature = "ink"))]
            pub fn migrate_currency(
                &self,
                stash: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::migrate_currency { stash },
                ))
            }
            #[doc = "Removes the legacy Staking locks if they exist."]
            #[doc = ""]
            #[doc = "This removes the legacy lock on the stake with [`Config::OldCurrency`] and creates a"]
            #[doc = "hold on it if needed. If all stake cannot be held, the best effort is made to hold as"]
            #[doc = "much as possible. The remaining stake is forced withdrawn from the ledger."]
            #[doc = ""]
            #[doc = "The fee is waived if the migration is successful."]
            #[cfg(feature = "ink")]
            pub fn migrate_currency(
                &self,
                stash: ::polymesh_api_client::AccountId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 30u8];
                stash.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "This function allows governance to manually slash a validator and is a"]
            #[doc = "**fallback mechanism**."]
            #[doc = ""]
            #[doc = "The dispatch origin must be `T::AdminOrigin`."]
            #[doc = ""]
            #[doc = "## Parameters"]
            #[doc = "- `validator_stash` - The stash account of the validator to slash."]
            #[doc = "- `era` - The era in which the validator was in the active set."]
            #[doc = "- `slash_fraction` - The percentage of the stake to slash, expressed as a Perbill."]
            #[doc = ""]
            #[doc = "## Behavior"]
            #[doc = ""]
            #[doc = "The slash will be applied using the standard slashing mechanics, respecting the"]
            #[doc = "configured `SlashDeferDuration`."]
            #[doc = ""]
            #[doc = "This means:"]
            #[doc = "- If the validator was already slashed by a higher percentage for the same era, this"]
            #[doc = "  slash will have no additional effect."]
            #[doc = "- If the validator was previously slashed by a lower percentage, only the difference"]
            #[doc = "  will be applied."]
            #[doc = "- The slash will be deferred by `SlashDeferDuration` eras before being enacted."]
            #[cfg(not(feature = "ink"))]
            pub fn manual_slash(
                &self,
                validator_stash: ::polymesh_api_client::AccountId,
                era: u32,
                slash_fraction: ::polymesh_api_client::per_things::Perbill,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Staking(
                    types::pallet_staking::pallet::pallet::StakingCall::manual_slash {
                        validator_stash,
                        era,
                        slash_fraction,
                    },
                ))
            }
            #[doc = "This function allows governance to manually slash a validator and is a"]
            #[doc = "**fallback mechanism**."]
            #[doc = ""]
            #[doc = "The dispatch origin must be `T::AdminOrigin`."]
            #[doc = ""]
            #[doc = "## Parameters"]
            #[doc = "- `validator_stash` - The stash account of the validator to slash."]
            #[doc = "- `era` - The era in which the validator was in the active set."]
            #[doc = "- `slash_fraction` - The percentage of the stake to slash, expressed as a Perbill."]
            #[doc = ""]
            #[doc = "## Behavior"]
            #[doc = ""]
            #[doc = "The slash will be applied using the standard slashing mechanics, respecting the"]
            #[doc = "configured `SlashDeferDuration`."]
            #[doc = ""]
            #[doc = "This means:"]
            #[doc = "- If the validator was already slashed by a higher percentage for the same era, this"]
            #[doc = "  slash will have no additional effect."]
            #[doc = "- If the validator was previously slashed by a lower percentage, only the difference"]
            #[doc = "  will be applied."]
            #[doc = "- The slash will be deferred by `SlashDeferDuration` eras before being enacted."]
            #[cfg(feature = "ink")]
            pub fn manual_slash(
                &self,
                validator_stash: ::polymesh_api_client::AccountId,
                era: u32,
                slash_fraction: ::polymesh_api_client::per_things::Perbill,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![17u8, 33u8];
                validator_stash.encode_to(&mut buf);
                era.encode_to(&mut buf);
                slash_fraction.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for StakingCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct StakingQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> StakingQueryApi<'api> {
            #[doc = " The ideal number of active validators."]
            #[cfg(not(feature = "ink"))]
            pub async fn validator_count(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 19u8, 142u8, 113u8, 97u8, 36u8, 145u8, 25u8, 45u8,
                    104u8, 222u8, 171u8, 126u8, 111u8, 86u8, 63u8, 225u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The ideal number of active validators."]
            #[cfg(feature = "ink")]
            pub fn validator_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 19u8, 142u8, 113u8, 97u8, 36u8, 145u8, 25u8, 45u8,
                    104u8, 222u8, 171u8, 126u8, 111u8, 86u8, 63u8, 225u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Minimum number of staking participants before emergency conditions are imposed."]
            #[cfg(not(feature = "ink"))]
            pub async fn minimum_validator_count(
                &self,
            ) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 180u8, 154u8, 39u8, 56u8, 238u8, 179u8, 8u8, 150u8,
                    170u8, 203u8, 139u8, 63u8, 180u8, 100u8, 113u8, 189u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Minimum number of staking participants before emergency conditions are imposed."]
            #[cfg(feature = "ink")]
            pub fn minimum_validator_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 180u8, 154u8, 39u8, 56u8, 238u8, 179u8, 8u8, 150u8,
                    170u8, 203u8, 139u8, 63u8, 180u8, 100u8, 113u8, 189u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're"]
            #[doc = " easy to initialize and the performance hit is minimal (we expect no more than four"]
            #[doc = " invulnerables) and restricted to testnets."]
            #[cfg(not(feature = "ink"))]
            pub async fn invulnerables(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 85u8, 121u8, 41u8, 127u8, 77u8, 251u8, 150u8, 9u8,
                    231u8, 228u8, 194u8, 235u8, 171u8, 156u8, 228u8, 10u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're"]
            #[doc = " easy to initialize and the performance hit is minimal (we expect no more than four"]
            #[doc = " invulnerables) and restricted to testnets."]
            #[cfg(feature = "ink")]
            pub fn invulnerables(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 85u8, 121u8, 41u8, 127u8, 77u8, 251u8, 150u8, 9u8,
                    231u8, 228u8, 194u8, 235u8, 171u8, 156u8, 228u8, 10u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Map from all locked \"stash\" accounts to the controller account."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn bonded(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 62u8, 209u8, 75u8, 69u8, 237u8, 32u8, 208u8, 84u8,
                    240u8, 94u8, 55u8, 226u8, 84u8, 44u8, 254u8, 112u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Map from all locked \"stash\" accounts to the controller account."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            #[cfg(feature = "ink")]
            pub fn bonded(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 62u8, 209u8, 75u8, 69u8, 237u8, 32u8, 208u8, 84u8,
                    240u8, 94u8, 55u8, 226u8, 84u8, 44u8, 254u8, 112u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The minimum active bond to become and maintain the role of a nominator."]
            #[cfg(not(feature = "ink"))]
            pub async fn min_nominator_bond(&self) -> ::polymesh_api_client::error::Result<u128> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 237u8, 68u8, 28u8, 235u8, 129u8, 50u8, 108u8, 86u8,
                    38u8, 62u8, 251u8, 182u8, 12u8, 149u8, 194u8, 228u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The minimum active bond to become and maintain the role of a nominator."]
            #[cfg(feature = "ink")]
            pub fn min_nominator_bond(&self) -> ::polymesh_api_ink::error::Result<u128> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 237u8, 68u8, 28u8, 235u8, 129u8, 50u8, 108u8, 86u8,
                    38u8, 62u8, 251u8, 182u8, 12u8, 149u8, 194u8, 228u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The minimum active bond to become and maintain the role of a validator."]
            #[cfg(not(feature = "ink"))]
            pub async fn min_validator_bond(&self) -> ::polymesh_api_client::error::Result<u128> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 102u8, 111u8, 220u8, 187u8, 71u8, 57u8, 133u8,
                    179u8, 172u8, 147u8, 61u8, 19u8, 244u8, 172u8, 255u8, 141u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The minimum active bond to become and maintain the role of a validator."]
            #[cfg(feature = "ink")]
            pub fn min_validator_bond(&self) -> ::polymesh_api_ink::error::Result<u128> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 102u8, 111u8, 220u8, 187u8, 71u8, 57u8, 133u8,
                    179u8, 172u8, 147u8, 61u8, 19u8, 244u8, 172u8, 255u8, 141u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The minimum active nominator stake of the last successful election."]
            #[cfg(not(feature = "ink"))]
            pub async fn minimum_active_stake(&self) -> ::polymesh_api_client::error::Result<u128> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 250u8, 184u8, 109u8, 38u8, 230u8, 41u8, 227u8,
                    155u8, 73u8, 3u8, 219u8, 148u8, 120u8, 111u8, 172u8, 116u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The minimum active nominator stake of the last successful election."]
            #[cfg(feature = "ink")]
            pub fn minimum_active_stake(&self) -> ::polymesh_api_ink::error::Result<u128> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 250u8, 184u8, 109u8, 38u8, 230u8, 41u8, 227u8,
                    155u8, 73u8, 3u8, 219u8, 148u8, 120u8, 111u8, 172u8, 116u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The minimum amount of commission that validators can set."]
            #[doc = ""]
            #[doc = " If set to `0`, no limit exists."]
            #[cfg(not(feature = "ink"))]
            pub async fn min_commission(
                &self,
            ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Perbill>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 88u8, 176u8, 201u8, 193u8, 250u8, 108u8, 193u8,
                    55u8, 89u8, 234u8, 217u8, 180u8, 45u8, 185u8, 238u8, 190u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The minimum amount of commission that validators can set."]
            #[doc = ""]
            #[doc = " If set to `0`, no limit exists."]
            #[cfg(feature = "ink")]
            pub fn min_commission(
                &self,
            ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Perbill>
            {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 88u8, 176u8, 201u8, 193u8, 250u8, 108u8, 193u8,
                    55u8, 89u8, 234u8, 217u8, 180u8, 45u8, 185u8, 238u8, 190u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."]
            #[doc = ""]
            #[doc = " Note: All the reads and mutations to this storage *MUST* be done through the methods exposed"]
            #[doc = " by [`StakingLedger`] to ensure data and lock consistency."]
            #[cfg(not(feature = "ink"))]
            pub async fn ledger(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<Option<types::pallet_staking::StakingLedger>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 66u8, 42u8, 219u8, 87u8, 159u8, 29u8, 191u8, 79u8,
                    56u8, 134u8, 197u8, 207u8, 163u8, 187u8, 140u8, 196u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."]
            #[doc = ""]
            #[doc = " Note: All the reads and mutations to this storage *MUST* be done through the methods exposed"]
            #[doc = " by [`StakingLedger`] to ensure data and lock consistency."]
            #[cfg(feature = "ink")]
            pub fn ledger(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_staking::StakingLedger>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 66u8, 42u8, 219u8, 87u8, 159u8, 29u8, 191u8, 79u8,
                    56u8, 134u8, 197u8, 207u8, 163u8, 187u8, 140u8, 196u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Where the reward payment should be made. Keyed by stash."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn payee(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 146u8, 32u8, 225u8, 114u8, 190u8, 211u8, 22u8,
                    96u8, 95u8, 115u8, 241u8, 255u8, 123u8, 74u8, 222u8, 152u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Where the reward payment should be made. Keyed by stash."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            #[cfg(feature = "ink")]
            pub fn payee(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 146u8, 32u8, 225u8, 114u8, 190u8, 211u8, 22u8,
                    96u8, 95u8, 115u8, 241u8, 255u8, 123u8, 74u8, 222u8, 152u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The map from (wannabe) validator stash key to the preferences of that validator."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn validators(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<types::pallet_staking::ValidatorPrefs>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8,
                    39u8, 238u8, 29u8, 250u8, 252u8, 214u8, 225u8, 105u8, 3u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8];
                    <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The map from (wannabe) validator stash key to the preferences of that validator."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            #[cfg(feature = "ink")]
            pub fn validators(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::ValidatorPrefs>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8,
                    39u8, 238u8, 29u8, 250u8, 252u8, 214u8, 225u8, 105u8, 3u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8];
                    <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = "Counter for the related counted storage map"]
            #[cfg(not(feature = "ink"))]
            pub async fn counter_for_validators(
                &self,
            ) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 109u8, 220u8, 120u8, 9u8, 198u8, 218u8, 155u8,
                    182u8, 9u8, 62u8, 226u8, 46u8, 15u8, 218u8, 75u8, 168u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = "Counter for the related counted storage map"]
            #[cfg(feature = "ink")]
            pub fn counter_for_validators(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 109u8, 220u8, 120u8, 9u8, 198u8, 218u8, 155u8,
                    182u8, 9u8, 62u8, 226u8, 46u8, 15u8, 218u8, 75u8, 168u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The maximum validator count before we stop allowing new validators to join."]
            #[doc = ""]
            #[doc = " When this value is not set, no limits are enforced."]
            #[cfg(not(feature = "ink"))]
            pub async fn max_validators_count(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<u32>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 152u8, 194u8, 100u8, 12u8, 218u8, 108u8, 13u8,
                    128u8, 17u8, 148u8, 168u8, 166u8, 28u8, 105u8, 146u8, 36u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The maximum validator count before we stop allowing new validators to join."]
            #[doc = ""]
            #[doc = " When this value is not set, no limits are enforced."]
            #[cfg(feature = "ink")]
            pub fn max_validators_count(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 152u8, 194u8, 100u8, 12u8, 218u8, 108u8, 13u8,
                    128u8, 17u8, 148u8, 168u8, 166u8, 28u8, 105u8, 146u8, 36u8,
                ])?;
                Ok(value)
            }
            #[doc = " The map from nominator stash key to their nomination preferences, namely the validators that"]
            #[doc = " they wish to support."]
            #[doc = ""]
            #[doc = " Note that the keys of this storage map might become non-decodable in case the"]
            #[doc = " account's [`NominationsQuota::MaxNominations`] configuration is decreased."]
            #[doc = " In this rare case, these nominators"]
            #[doc = " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`"]
            #[doc = " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable"]
            #[doc = " nominators will effectively not-exist, until they re-submit their preferences such that it"]
            #[doc = " is within the bounds of the newly set `Config::MaxNominations`."]
            #[doc = ""]
            #[doc = " This implies that `::iter_keys().count()` and `::iter().count()` might return different"]
            #[doc = " values for this map. Moreover, the main `::count()` is aligned with the former, namely the"]
            #[doc = " number of keys that exist."]
            #[doc = ""]
            #[doc = " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via"]
            #[doc = " [`Call::chill_other`] dispatchable by anyone."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn nominators(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<Option<types::pallet_staking::Nominations>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 156u8, 106u8, 99u8, 127u8, 98u8, 174u8, 42u8,
                    241u8, 199u8, 227u8, 30u8, 237u8, 126u8, 150u8, 190u8, 4u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The map from nominator stash key to their nomination preferences, namely the validators that"]
            #[doc = " they wish to support."]
            #[doc = ""]
            #[doc = " Note that the keys of this storage map might become non-decodable in case the"]
            #[doc = " account's [`NominationsQuota::MaxNominations`] configuration is decreased."]
            #[doc = " In this rare case, these nominators"]
            #[doc = " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`"]
            #[doc = " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable"]
            #[doc = " nominators will effectively not-exist, until they re-submit their preferences such that it"]
            #[doc = " is within the bounds of the newly set `Config::MaxNominations`."]
            #[doc = ""]
            #[doc = " This implies that `::iter_keys().count()` and `::iter().count()` might return different"]
            #[doc = " values for this map. Moreover, the main `::count()` is aligned with the former, namely the"]
            #[doc = " number of keys that exist."]
            #[doc = ""]
            #[doc = " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via"]
            #[doc = " [`Call::chill_other`] dispatchable by anyone."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            #[cfg(feature = "ink")]
            pub fn nominators(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_staking::Nominations>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 156u8, 106u8, 99u8, 127u8, 98u8, 174u8, 42u8,
                    241u8, 199u8, 227u8, 30u8, 237u8, 126u8, 150u8, 190u8, 4u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = "Counter for the related counted storage map"]
            #[cfg(not(feature = "ink"))]
            pub async fn counter_for_nominators(
                &self,
            ) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 249u8, 155u8, 37u8, 133u8, 45u8, 61u8, 105u8, 65u8,
                    152u8, 130u8, 218u8, 101u8, 19u8, 117u8, 205u8, 179u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = "Counter for the related counted storage map"]
            #[cfg(feature = "ink")]
            pub fn counter_for_nominators(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 249u8, 155u8, 37u8, 133u8, 45u8, 61u8, 105u8, 65u8,
                    152u8, 130u8, 218u8, 101u8, 19u8, 117u8, 205u8, 179u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Stakers whose funds are managed by other pallets."]
            #[doc = ""]
            #[doc = " This pallet does not apply any locks on them, therefore they are only virtually bonded. They"]
            #[doc = " are expected to be keyless accounts and hence should not be allowed to mutate their ledger"]
            #[doc = " directly via this pallet. Instead, these accounts are managed by other pallets and accessed"]
            #[doc = " via low level apis. We keep track of them to do minimal integrity checks."]
            #[cfg(not(feature = "ink"))]
            pub async fn virtual_stakers(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<Option<()>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 191u8, 54u8, 6u8, 185u8, 4u8, 169u8, 143u8, 75u8,
                    233u8, 220u8, 185u8, 96u8, 210u8, 108u8, 147u8, 235u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Stakers whose funds are managed by other pallets."]
            #[doc = ""]
            #[doc = " This pallet does not apply any locks on them, therefore they are only virtually bonded. They"]
            #[doc = " are expected to be keyless accounts and hence should not be allowed to mutate their ledger"]
            #[doc = " directly via this pallet. Instead, these accounts are managed by other pallets and accessed"]
            #[doc = " via low level apis. We keep track of them to do minimal integrity checks."]
            #[cfg(feature = "ink")]
            pub fn virtual_stakers(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<Option<()>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 191u8, 54u8, 6u8, 185u8, 4u8, 169u8, 143u8, 75u8,
                    233u8, 220u8, 185u8, 96u8, 210u8, 108u8, 147u8, 235u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = "Counter for the related counted storage map"]
            #[cfg(not(feature = "ink"))]
            pub async fn counter_for_virtual_stakers(
                &self,
            ) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 155u8, 100u8, 118u8, 183u8, 241u8, 10u8, 74u8,
                    207u8, 154u8, 227u8, 102u8, 25u8, 108u8, 239u8, 190u8, 31u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = "Counter for the related counted storage map"]
            #[cfg(feature = "ink")]
            pub fn counter_for_virtual_stakers(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 155u8, 100u8, 118u8, 183u8, 241u8, 10u8, 74u8,
                    207u8, 154u8, 227u8, 102u8, 25u8, 108u8, 239u8, 190u8, 31u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The maximum nominator count before we stop allowing new validators to join."]
            #[doc = ""]
            #[doc = " When this value is not set, no limits are enforced."]
            #[cfg(not(feature = "ink"))]
            pub async fn max_nominators_count(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<u32>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 214u8, 66u8, 192u8, 10u8, 241u8, 25u8, 173u8,
                    243u8, 13u8, 193u8, 29u8, 50u8, 233u8, 240u8, 136u8, 109u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The maximum nominator count before we stop allowing new validators to join."]
            #[doc = ""]
            #[doc = " When this value is not set, no limits are enforced."]
            #[cfg(feature = "ink")]
            pub fn max_nominators_count(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 214u8, 66u8, 192u8, 10u8, 241u8, 25u8, 173u8,
                    243u8, 13u8, 193u8, 29u8, 50u8, 233u8, 240u8, 136u8, 109u8,
                ])?;
                Ok(value)
            }
            #[doc = " The current era index."]
            #[doc = ""]
            #[doc = " This is the latest planned era, depending on how the Session pallet queues the validator"]
            #[doc = " set, it might be active or not."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_era(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 11u8, 106u8, 69u8, 50u8, 30u8, 250u8, 233u8, 42u8,
                    234u8, 21u8, 224u8, 116u8, 14u8, 199u8, 175u8, 231u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The current era index."]
            #[doc = ""]
            #[doc = " This is the latest planned era, depending on how the Session pallet queues the validator"]
            #[doc = " set, it might be active or not."]
            #[cfg(feature = "ink")]
            pub fn current_era(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 11u8, 106u8, 69u8, 50u8, 30u8, 250u8, 233u8, 42u8,
                    234u8, 21u8, 224u8, 116u8, 14u8, 199u8, 175u8, 231u8,
                ])?;
                Ok(value)
            }
            #[doc = " The active era information, it holds index and start."]
            #[doc = ""]
            #[doc = " The active era is the era being currently rewarded. Validator set of this era must be"]
            #[doc = " equal to [`SessionInterface::validators`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_era(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<types::pallet_staking::ActiveEraInfo>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 72u8, 125u8, 244u8, 100u8, 228u8, 74u8, 83u8, 75u8,
                    166u8, 176u8, 203u8, 179u8, 36u8, 7u8, 181u8, 135u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The active era information, it holds index and start."]
            #[doc = ""]
            #[doc = " The active era is the era being currently rewarded. Validator set of this era must be"]
            #[doc = " equal to [`SessionInterface::validators`]."]
            #[cfg(feature = "ink")]
            pub fn active_era(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_staking::ActiveEraInfo>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 72u8, 125u8, 244u8, 100u8, 228u8, 74u8, 83u8, 75u8,
                    166u8, 176u8, 203u8, 179u8, 36u8, 7u8, 181u8, 135u8,
                ])?;
                Ok(value)
            }
            #[doc = " The session index at which the era start for the last [`Config::HistoryDepth`] eras."]
            #[doc = ""]
            #[doc = " Note: This tracks the starting session (i.e. session index when era start being active)"]
            #[doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."]
            #[cfg(not(feature = "ink"))]
            pub async fn eras_start_session_index(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<Option<u32>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 173u8, 129u8, 28u8, 214u8, 90u8, 71u8, 13u8, 220u8,
                    95u8, 29u8, 98u8, 143u8, 240u8, 85u8, 9u8, 130u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The session index at which the era start for the last [`Config::HistoryDepth`] eras."]
            #[doc = ""]
            #[doc = " Note: This tracks the starting session (i.e. session index when era start being active)"]
            #[doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."]
            #[cfg(feature = "ink")]
            pub fn eras_start_session_index(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 173u8, 129u8, 28u8, 214u8, 90u8, 71u8, 13u8, 220u8,
                    95u8, 29u8, 98u8, 143u8, 240u8, 85u8, 9u8, 130u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Exposure of validator at era."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
            #[doc = ""]
            #[doc = " Is it removed after [`Config::HistoryDepth`] eras."]
            #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
            #[doc = ""]
            #[doc = " Note: Deprecated since v14. Use `EraInfo` instead to work with exposures."]
            #[cfg(not(feature = "ink"))]
            pub async fn eras_stakers(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 139u8, 222u8, 10u8, 14u8, 168u8, 134u8, 70u8, 5u8,
                    227u8, 182u8, 142u8, 217u8, 203u8, 45u8, 160u8, 27u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
                    <types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Exposure of validator at era."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
            #[doc = ""]
            #[doc = " Is it removed after [`Config::HistoryDepth`] eras."]
            #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
            #[doc = ""]
            #[doc = " Note: Deprecated since v14. Use `EraInfo` instead to work with exposures."]
            #[cfg(feature = "ink")]
            pub fn eras_stakers(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 139u8, 222u8, 10u8, 14u8, 168u8, 134u8, 70u8, 5u8,
                    227u8, 182u8, 142u8, 217u8, 203u8, 45u8, 160u8, 27u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
                    <types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Summary of validator exposure at a given era."]
            #[doc = ""]
            #[doc = " This contains the total stake in support of the validator and their own stake. In addition,"]
            #[doc = " it can also be used to get the number of nominators backing this validator and the number of"]
            #[doc = " exposure pages they are divided into. The page count is useful to determine the number of"]
            #[doc = " pages of rewards that needs to be claimed."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
            #[doc = " Should only be accessed through `EraInfo`."]
            #[doc = ""]
            #[doc = " Is it removed after [`Config::HistoryDepth`] eras."]
            #[doc = " If stakers hasn't been set or has been removed then empty overview is returned."]
            #[cfg(not(feature = "ink"))]
            pub async fn eras_stakers_overview(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::sp_staking::PagedExposureMetadata<u128>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 116u8, 147u8, 234u8, 25u8, 13u8, 10u8, 244u8,
                    122u8, 204u8, 112u8, 226u8, 84u8, 40u8, 248u8, 177u8, 163u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Summary of validator exposure at a given era."]
            #[doc = ""]
            #[doc = " This contains the total stake in support of the validator and their own stake. In addition,"]
            #[doc = " it can also be used to get the number of nominators backing this validator and the number of"]
            #[doc = " exposure pages they are divided into. The page count is useful to determine the number of"]
            #[doc = " pages of rewards that needs to be claimed."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
            #[doc = " Should only be accessed through `EraInfo`."]
            #[doc = ""]
            #[doc = " Is it removed after [`Config::HistoryDepth`] eras."]
            #[doc = " If stakers hasn't been set or has been removed then empty overview is returned."]
            #[cfg(feature = "ink")]
            pub fn eras_stakers_overview(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::sp_staking::PagedExposureMetadata<u128>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 116u8, 147u8, 234u8, 25u8, 13u8, 10u8, 244u8,
                    122u8, 204u8, 112u8, 226u8, 84u8, 40u8, 248u8, 177u8, 163u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Clipped Exposure of validator at era."]
            #[doc = ""]
            #[doc = " Note: This is deprecated, should be used as read-only and will be removed in the future."]
            #[doc = " New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead."]
            #[doc = ""]
            #[doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"]
            #[doc = " `T::MaxExposurePageSize` biggest stakers."]
            #[doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."]
            #[doc = " This is used to limit the i/o cost for the nominator payout."]
            #[doc = ""]
            #[doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."]
            #[doc = ""]
            #[doc = " It is removed after [`Config::HistoryDepth`] eras."]
            #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
            #[doc = ""]
            #[doc = " Note: Deprecated since v14. Use `EraInfo` instead to work with exposures."]
            #[cfg(not(feature = "ink"))]
            pub async fn eras_stakers_clipped(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 66u8, 152u8, 43u8, 157u8, 108u8, 122u8, 204u8,
                    153u8, 250u8, 169u8, 9u8, 76u8, 145u8, 35u8, 114u8, 194u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
                    <types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Clipped Exposure of validator at era."]
            #[doc = ""]
            #[doc = " Note: This is deprecated, should be used as read-only and will be removed in the future."]
            #[doc = " New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead."]
            #[doc = ""]
            #[doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"]
            #[doc = " `T::MaxExposurePageSize` biggest stakers."]
            #[doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."]
            #[doc = " This is used to limit the i/o cost for the nominator payout."]
            #[doc = ""]
            #[doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."]
            #[doc = ""]
            #[doc = " It is removed after [`Config::HistoryDepth`] eras."]
            #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
            #[doc = ""]
            #[doc = " Note: Deprecated since v14. Use `EraInfo` instead to work with exposures."]
            #[cfg(feature = "ink")]
            pub fn eras_stakers_clipped(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 66u8, 152u8, 43u8, 157u8, 108u8, 122u8, 204u8,
                    153u8, 250u8, 169u8, 9u8, 76u8, 145u8, 35u8, 114u8, 194u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8];
                    <types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Paginated exposure of a validator at given era."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion, then stash account and finally"]
            #[doc = " the page. Should only be accessed through `EraInfo`."]
            #[doc = ""]
            #[doc = " This is cleared after [`Config::HistoryDepth`] eras."]
            #[cfg(not(feature = "ink"))]
            pub async fn eras_stakers_paged(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
                key_2: u32,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::sp_staking::ExposurePage<::polymesh_api_client::AccountId, u128>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 110u8, 207u8, 64u8, 55u8, 60u8, 114u8, 43u8, 3u8,
                    64u8, 211u8, 214u8, 92u8, 49u8, 26u8, 67u8, 5u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_2.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Paginated exposure of a validator at given era."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion, then stash account and finally"]
            #[doc = " the page. Should only be accessed through `EraInfo`."]
            #[doc = ""]
            #[doc = " This is cleared after [`Config::HistoryDepth`] eras."]
            #[cfg(feature = "ink")]
            pub fn eras_stakers_paged(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
                key_2: u32,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::sp_staking::ExposurePage<::polymesh_api_client::AccountId, u128>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 110u8, 207u8, 64u8, 55u8, 60u8, 114u8, 43u8, 3u8,
                    64u8, 211u8, 214u8, 92u8, 49u8, 26u8, 67u8, 5u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_2.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " History of claimed paged rewards by era and validator."]
            #[doc = ""]
            #[doc = " This is keyed by era and validator stash which maps to the set of page indexes which have"]
            #[doc = " been claimed."]
            #[doc = ""]
            #[doc = " It is removed after [`Config::HistoryDepth`] eras."]
            #[cfg(not(feature = "ink"))]
            pub async fn claimed_rewards(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u32>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 172u8, 102u8, 71u8, 2u8, 164u8, 87u8, 170u8, 161u8,
                    88u8, 229u8, 187u8, 69u8, 138u8, 12u8, 55u8, 108u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<u32>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " History of claimed paged rewards by era and validator."]
            #[doc = ""]
            #[doc = " This is keyed by era and validator stash which maps to the set of page indexes which have"]
            #[doc = " been claimed."]
            #[doc = ""]
            #[doc = " It is removed after [`Config::HistoryDepth`] eras."]
            #[cfg(feature = "ink")]
            pub fn claimed_rewards(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u32>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 172u8, 102u8, 71u8, 2u8, 164u8, 87u8, 170u8, 161u8,
                    88u8, 229u8, 187u8, 69u8, 138u8, 12u8, 55u8, 108u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<u32>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Similar to `ErasStakers`, this holds the preferences of validators."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
            #[doc = ""]
            #[doc = " Is it removed after [`Config::HistoryDepth`] eras."]
            #[cfg(not(feature = "ink"))]
            pub async fn eras_validator_prefs(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<types::pallet_staking::ValidatorPrefs>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 104u8, 45u8, 185u8, 45u8, 222u8, 32u8, 161u8, 13u8,
                    150u8, 208u8, 15u8, 240u8, 233u8, 226u8, 33u8, 192u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8];
                    <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Similar to `ErasStakers`, this holds the preferences of validators."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
            #[doc = ""]
            #[doc = " Is it removed after [`Config::HistoryDepth`] eras."]
            #[cfg(feature = "ink")]
            pub fn eras_validator_prefs(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::ValidatorPrefs>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 104u8, 45u8, 185u8, 45u8, 222u8, 32u8, 161u8, 13u8,
                    150u8, 208u8, 15u8, 240u8, 233u8, 226u8, 33u8, 192u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8];
                    <types::pallet_staking::ValidatorPrefs>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The total validator era payout for the last [`Config::HistoryDepth`] eras."]
            #[doc = ""]
            #[doc = " Eras that haven't finished yet or has been removed doesn't have reward."]
            #[cfg(not(feature = "ink"))]
            pub async fn eras_validator_reward(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<Option<u128>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 126u8, 110u8, 210u8, 238u8, 80u8, 124u8, 123u8,
                    68u8, 65u8, 213u8, 158u8, 77u8, 237u8, 68u8, 184u8, 162u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The total validator era payout for the last [`Config::HistoryDepth`] eras."]
            #[doc = ""]
            #[doc = " Eras that haven't finished yet or has been removed doesn't have reward."]
            #[cfg(feature = "ink")]
            pub fn eras_validator_reward(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<Option<u128>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 126u8, 110u8, 210u8, 238u8, 80u8, 124u8, 123u8,
                    68u8, 65u8, 213u8, 158u8, 77u8, 237u8, 68u8, 184u8, 162u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Rewards for the last [`Config::HistoryDepth`] eras."]
            #[doc = " If reward hasn't been set or has been removed then 0 reward is returned."]
            #[cfg(not(feature = "ink"))]
            pub async fn eras_reward_points(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<
                types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 128u8, 204u8, 101u8, 116u8, 40u8, 22u8, 113u8,
                    178u8, 153u8, 193u8, 114u8, 125u8, 122u8, 198u8, 140u8, 171u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 , 0u8 , 0u8 , 0u8 , 0u8 ,] ; < types :: pallet_staking :: EraRewardPoints < :: polymesh_api_client :: AccountId > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " Rewards for the last [`Config::HistoryDepth`] eras."]
            #[doc = " If reward hasn't been set or has been removed then 0 reward is returned."]
            #[cfg(feature = "ink")]
            pub fn eras_reward_points(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<
                types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 128u8, 204u8, 101u8, 116u8, 40u8, 22u8, 113u8,
                    178u8, 153u8, 193u8, 114u8, 125u8, 122u8, 198u8, 140u8, 171u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 , 0u8 , 0u8 , 0u8 , 0u8 ,] ; < types :: pallet_staking :: EraRewardPoints < :: polymesh_api_client :: AccountId > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " The total amount staked for the last [`Config::HistoryDepth`] eras."]
            #[doc = " If total hasn't been set or has been removed then 0 stake is returned."]
            #[cfg(not(feature = "ink"))]
            pub async fn eras_total_stake(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 161u8, 65u8, 196u8, 254u8, 103u8, 194u8, 209u8,
                    31u8, 74u8, 16u8, 198u8, 172u8, 167u8, 167u8, 154u8, 4u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The total amount staked for the last [`Config::HistoryDepth`] eras."]
            #[doc = " If total hasn't been set or has been removed then 0 stake is returned."]
            #[cfg(feature = "ink")]
            pub fn eras_total_stake(&self, key_0: u32) -> ::polymesh_api_ink::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 161u8, 65u8, 196u8, 254u8, 103u8, 194u8, 209u8,
                    31u8, 74u8, 16u8, 198u8, 172u8, 167u8, 167u8, 154u8, 4u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Mode of era forcing."]
            #[cfg(not(feature = "ink"))]
            pub async fn force_era(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_staking::Forcing> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 247u8, 218u8, 208u8, 49u8, 115u8, 36u8, 174u8,
                    202u8, 232u8, 116u8, 75u8, 135u8, 252u8, 149u8, 242u8, 243u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_staking::Forcing>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Mode of era forcing."]
            #[cfg(feature = "ink")]
            pub fn force_era(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::Forcing> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 247u8, 218u8, 208u8, 49u8, 115u8, 36u8, 174u8,
                    202u8, 232u8, 116u8, 75u8, 135u8, 252u8, 149u8, 242u8, 243u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_staking::Forcing>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Maximum staked rewards, i.e. the percentage of the era inflation that"]
            #[doc = " is used for stake rewards."]
            #[doc = " See [Era payout](./index.html#era-payout)."]
            #[cfg(not(feature = "ink"))]
            pub async fn max_staked_rewards(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<::polymesh_api_client::per_things::Percent>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 196u8, 229u8, 144u8, 67u8, 64u8, 77u8, 254u8, 54u8,
                    208u8, 202u8, 211u8, 114u8, 191u8, 183u8, 134u8, 163u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Maximum staked rewards, i.e. the percentage of the era inflation that"]
            #[doc = " is used for stake rewards."]
            #[doc = " See [Era payout](./index.html#era-payout)."]
            #[cfg(feature = "ink")]
            pub fn max_staked_rewards(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::per_things::Percent>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 196u8, 229u8, 144u8, 67u8, 64u8, 77u8, 254u8, 54u8,
                    208u8, 202u8, 211u8, 114u8, 191u8, 183u8, 134u8, 163u8,
                ])?;
                Ok(value)
            }
            #[doc = " The percentage of the slash that is distributed to reporters."]
            #[doc = ""]
            #[doc = " The rest of the slashed value is handled by the `Slash`."]
            #[cfg(not(feature = "ink"))]
            pub async fn slash_reward_fraction(
                &self,
            ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Perbill>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 194u8, 154u8, 3u8, 16u8, 225u8, 187u8, 69u8, 210u8,
                    12u8, 172u8, 231u8, 124u8, 203u8, 98u8, 201u8, 125u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The percentage of the slash that is distributed to reporters."]
            #[doc = ""]
            #[doc = " The rest of the slashed value is handled by the `Slash`."]
            #[cfg(feature = "ink")]
            pub fn slash_reward_fraction(
                &self,
            ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Perbill>
            {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 194u8, 154u8, 3u8, 16u8, 225u8, 187u8, 69u8, 210u8,
                    12u8, 172u8, 231u8, 124u8, 203u8, 98u8, 201u8, 125u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <::polymesh_api_client::per_things::Perbill>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The amount of currency given to reporters of a slash event which was"]
            #[doc = " canceled by extraordinary circumstances (e.g. governance)."]
            #[cfg(not(feature = "ink"))]
            pub async fn canceled_slash_payout(
                &self,
            ) -> ::polymesh_api_client::error::Result<u128> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 40u8, 220u8, 203u8, 85u8, 155u8, 149u8, 196u8, 1u8,
                    104u8, 161u8, 178u8, 105u8, 101u8, 129u8, 181u8, 167u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The amount of currency given to reporters of a slash event which was"]
            #[doc = " canceled by extraordinary circumstances (e.g. governance)."]
            #[cfg(feature = "ink")]
            pub fn canceled_slash_payout(&self) -> ::polymesh_api_ink::error::Result<u128> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 40u8, 220u8, 203u8, 85u8, 155u8, 149u8, 196u8, 1u8,
                    104u8, 161u8, 178u8, 105u8, 101u8, 129u8, 181u8, 167u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All unapplied slashes that are queued for later."]
            #[cfg(not(feature = "ink"))]
            pub async fn unapplied_slashes(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<
                    types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 4u8, 40u8, 36u8, 23u8, 10u8, 93u8, 180u8, 56u8,
                    31u8, 227u8, 57u8, 80u8, 57u8, 202u8, 189u8, 36u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::pallet_staking::UnappliedSlash<
                            ::polymesh_api_client::AccountId,
                            u128,
                        >,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " All unapplied slashes that are queued for later."]
            #[cfg(feature = "ink")]
            pub fn unapplied_slashes(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<
                    types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 4u8, 40u8, 36u8, 23u8, 10u8, 93u8, 180u8, 56u8,
                    31u8, 227u8, 57u8, 80u8, 57u8, 202u8, 189u8, 36u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        types::pallet_staking::UnappliedSlash<
                            ::polymesh_api_client::AccountId,
                            u128,
                        >,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " A mapping from still-bonded eras to the first session index of that era."]
            #[doc = ""]
            #[doc = " Must contains information for eras for the range:"]
            #[doc = " `[active_era - bounding_duration; active_era]`"]
            #[cfg(not(feature = "ink"))]
            pub async fn bonded_eras(
                &self,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<(u32, u32)>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 234u8, 7u8, 222u8, 43u8, 143u8, 1u8, 5u8, 22u8,
                    220u8, 163u8, 247u8, 239u8, 82u8, 247u8, 172u8, 90u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " A mapping from still-bonded eras to the first session index of that era."]
            #[doc = ""]
            #[doc = " Must contains information for eras for the range:"]
            #[doc = " `[active_era - bounding_duration; active_era]`"]
            #[cfg(feature = "ink")]
            pub fn bonded_eras(
                &self,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<(u32, u32)>> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 234u8, 7u8, 222u8, 43u8, 143u8, 1u8, 5u8, 22u8,
                    220u8, 163u8, 247u8, 239u8, 82u8, 247u8, 172u8, 90u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(u32, u32)>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All slashing events on validators, mapped by era to the highest slash proportion"]
            #[doc = " and slash value of the era."]
            #[cfg(not(feature = "ink"))]
            pub async fn validator_slash_in_era(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<(::polymesh_api_client::per_things::Perbill, u128)>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 173u8, 110u8, 21u8, 238u8, 123u8, 253u8, 93u8,
                    85u8, 235u8, 161u8, 1u8, 36u8, 135u8, 211u8, 175u8, 84u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " All slashing events on validators, mapped by era to the highest slash proportion"]
            #[doc = " and slash value of the era."]
            #[cfg(feature = "ink")]
            pub fn validator_slash_in_era(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<(::polymesh_api_client::per_things::Perbill, u128)>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 173u8, 110u8, 21u8, 238u8, 123u8, 253u8, 93u8,
                    85u8, 235u8, 161u8, 1u8, 36u8, 135u8, 211u8, 175u8, 84u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."]
            #[cfg(not(feature = "ink"))]
            pub async fn nominator_slash_in_era(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<Option<u128>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 129u8, 80u8, 8u8, 232u8, 33u8, 11u8, 109u8, 108u8,
                    247u8, 1u8, 226u8, 46u8, 91u8, 242u8, 113u8, 65u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."]
            #[cfg(feature = "ink")]
            pub fn nominator_slash_in_era(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<Option<u128>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 129u8, 80u8, 8u8, 232u8, 33u8, 11u8, 109u8, 108u8,
                    247u8, 1u8, 226u8, 46u8, 91u8, 242u8, 113u8, 65u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Slashing spans for stash accounts."]
            #[cfg(not(feature = "ink"))]
            pub async fn slashing_spans(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_staking::slashing::SlashingSpans>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 171u8, 106u8, 33u8, 43u8, 192u8, 138u8, 86u8, 3u8,
                    130u8, 143u8, 51u8, 249u8, 14u8, 196u8, 161u8, 57u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Slashing spans for stash accounts."]
            #[cfg(feature = "ink")]
            pub fn slashing_spans(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_staking::slashing::SlashingSpans>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 171u8, 106u8, 33u8, 43u8, 192u8, 138u8, 86u8, 3u8,
                    130u8, 143u8, 51u8, 249u8, 14u8, 196u8, 161u8, 57u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Records information about the maximum slash of a stash within a slashing span,"]
            #[doc = " as well as how much reward has been paid out."]
            #[cfg(not(feature = "ink"))]
            pub async fn span_slash(
                &self,
                key_0: (::polymesh_api_client::AccountId, u32),
            ) -> ::polymesh_api_client::error::Result<
                types::pallet_staking::slashing::SpanRecord<u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 230u8, 47u8, 111u8, 121u8, 126u8, 190u8, 145u8,
                    56u8, 223u8, 206u8, 217u8, 66u8, 151u8, 127u8, 234u8, 80u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <types::pallet_staking::slashing::SpanRecord<u128>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Records information about the maximum slash of a stash within a slashing span,"]
            #[doc = " as well as how much reward has been paid out."]
            #[cfg(feature = "ink")]
            pub fn span_slash(
                &self,
                key_0: (::polymesh_api_client::AccountId, u32),
            ) -> ::polymesh_api_ink::error::Result<types::pallet_staking::slashing::SpanRecord<u128>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 230u8, 47u8, 111u8, 121u8, 126u8, 190u8, 145u8,
                    56u8, 223u8, 206u8, 217u8, 66u8, 151u8, 127u8, 234u8, 80u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <types::pallet_staking::slashing::SpanRecord<u128>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The last planned session scheduled by the session pallet."]
            #[doc = ""]
            #[doc = " This is basically in sync with the call to [`pallet_session::SessionManager::new_session`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_planned_session(
                &self,
            ) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 192u8, 211u8, 159u8, 245u8, 119u8, 175u8, 44u8,
                    198u8, 182u8, 122u8, 195u8, 100u8, 31u8, 169u8, 196u8, 231u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The last planned session scheduled by the session pallet."]
            #[doc = ""]
            #[doc = " This is basically in sync with the call to [`pallet_session::SessionManager::new_session`]."]
            #[cfg(feature = "ink")]
            pub fn current_planned_session(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 192u8, 211u8, 159u8, 245u8, 119u8, 175u8, 44u8,
                    198u8, 182u8, 122u8, 195u8, 100u8, 31u8, 169u8, 196u8, 231u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The threshold for when users can start calling `chill_other` for other validators /"]
            #[doc = " nominators. The threshold is compared to the actual number of validators / nominators"]
            #[doc = " (`CountFor*`) in the system compared to the configured max (`Max*Count`)."]
            #[cfg(not(feature = "ink"))]
            pub async fn chill_threshold(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<::polymesh_api_client::per_things::Percent>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 205u8, 220u8, 73u8, 197u8, 243u8, 8u8, 7u8, 212u8,
                    116u8, 160u8, 157u8, 112u8, 254u8, 216u8, 165u8, 105u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The threshold for when users can start calling `chill_other` for other validators /"]
            #[doc = " nominators. The threshold is compared to the actual number of validators / nominators"]
            #[doc = " (`CountFor*`) in the system compared to the configured max (`Max*Count`)."]
            #[cfg(feature = "ink")]
            pub fn chill_threshold(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::per_things::Percent>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 205u8, 220u8, 73u8, 197u8, 243u8, 8u8, 7u8, 212u8,
                    116u8, 160u8, 157u8, 112u8, 254u8, 216u8, 165u8, 105u8,
                ])?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct StakingPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> StakingPagedQueryApi<'api> {
            #[doc = " Map from all locked \"stash\" accounts to the controller account."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            pub fn bonded(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                ::polymesh_api_client::AccountId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 62u8, 209u8, 75u8, 69u8, 237u8, 32u8, 208u8, 84u8,
                    240u8, 94u8, 55u8, 226u8, 84u8, 44u8, 254u8, 112u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."]
            #[doc = ""]
            #[doc = " Note: All the reads and mutations to this storage *MUST* be done through the methods exposed"]
            #[doc = " by [`StakingLedger`] to ensure data and lock consistency."]
            pub fn ledger(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_staking::StakingLedger,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 66u8, 42u8, 219u8, 87u8, 159u8, 29u8, 191u8, 79u8,
                    56u8, 134u8, 197u8, 207u8, 163u8, 187u8, 140u8, 196u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Where the reward payment should be made. Keyed by stash."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            pub fn payee(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_staking::RewardDestination<::polymesh_api_client::AccountId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 146u8, 32u8, 225u8, 114u8, 190u8, 211u8, 22u8,
                    96u8, 95u8, 115u8, 241u8, 255u8, 123u8, 74u8, 222u8, 152u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The map from (wannabe) validator stash key to the preferences of that validator."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            pub fn validators(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_staking::ValidatorPrefs,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8,
                    39u8, 238u8, 29u8, 250u8, 252u8, 214u8, 225u8, 105u8, 3u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The map from nominator stash key to their nomination preferences, namely the validators that"]
            #[doc = " they wish to support."]
            #[doc = ""]
            #[doc = " Note that the keys of this storage map might become non-decodable in case the"]
            #[doc = " account's [`NominationsQuota::MaxNominations`] configuration is decreased."]
            #[doc = " In this rare case, these nominators"]
            #[doc = " are still existent in storage, their key is correct and retrievable (i.e. `contains_key`"]
            #[doc = " indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable"]
            #[doc = " nominators will effectively not-exist, until they re-submit their preferences such that it"]
            #[doc = " is within the bounds of the newly set `Config::MaxNominations`."]
            #[doc = ""]
            #[doc = " This implies that `::iter_keys().count()` and `::iter().count()` might return different"]
            #[doc = " values for this map. Moreover, the main `::count()` is aligned with the former, namely the"]
            #[doc = " number of keys that exist."]
            #[doc = ""]
            #[doc = " Lastly, if any of the nominators become non-decodable, they can be chilled immediately via"]
            #[doc = " [`Call::chill_other`] dispatchable by anyone."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            pub fn nominators(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_staking::Nominations,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 156u8, 106u8, 99u8, 127u8, 98u8, 174u8, 42u8,
                    241u8, 199u8, 227u8, 30u8, 237u8, 126u8, 150u8, 190u8, 4u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Stakers whose funds are managed by other pallets."]
            #[doc = ""]
            #[doc = " This pallet does not apply any locks on them, therefore they are only virtually bonded. They"]
            #[doc = " are expected to be keyless accounts and hence should not be allowed to mutate their ledger"]
            #[doc = " directly via this pallet. Instead, these accounts are managed by other pallets and accessed"]
            #[doc = " via low level apis. We keep track of them to do minimal integrity checks."]
            pub fn virtual_stakers(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, ()>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 191u8, 54u8, 6u8, 185u8, 4u8, 169u8, 143u8, 75u8,
                    233u8, 220u8, 185u8, 96u8, 210u8, 108u8, 147u8, 235u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The session index at which the era start for the last [`Config::HistoryDepth`] eras."]
            #[doc = ""]
            #[doc = " Note: This tracks the starting session (i.e. session index when era start being active)"]
            #[doc = " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."]
            pub fn eras_start_session_index(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<u32, u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 173u8, 129u8, 28u8, 214u8, 90u8, 71u8, 13u8, 220u8,
                    95u8, 29u8, 98u8, 143u8, 240u8, 85u8, 9u8, 130u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Exposure of validator at era."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
            #[doc = ""]
            #[doc = " Is it removed after [`Config::HistoryDepth`] eras."]
            #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
            #[doc = ""]
            #[doc = " Note: Deprecated since v14. Use `EraInfo` instead to work with exposures."]
            pub fn eras_stakers(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 139u8, 222u8, 10u8, 14u8, 168u8, 134u8, 70u8, 5u8,
                    227u8, 182u8, 142u8, 217u8, 203u8, 45u8, 160u8, 27u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Summary of validator exposure at a given era."]
            #[doc = ""]
            #[doc = " This contains the total stake in support of the validator and their own stake. In addition,"]
            #[doc = " it can also be used to get the number of nominators backing this validator and the number of"]
            #[doc = " exposure pages they are divided into. The page count is useful to determine the number of"]
            #[doc = " pages of rewards that needs to be claimed."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
            #[doc = " Should only be accessed through `EraInfo`."]
            #[doc = ""]
            #[doc = " Is it removed after [`Config::HistoryDepth`] eras."]
            #[doc = " If stakers hasn't been set or has been removed then empty overview is returned."]
            pub fn eras_stakers_overview(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::sp_staking::PagedExposureMetadata<u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 116u8, 147u8, 234u8, 25u8, 13u8, 10u8, 244u8,
                    122u8, 204u8, 112u8, 226u8, 84u8, 40u8, 248u8, 177u8, 163u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Clipped Exposure of validator at era."]
            #[doc = ""]
            #[doc = " Note: This is deprecated, should be used as read-only and will be removed in the future."]
            #[doc = " New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead."]
            #[doc = ""]
            #[doc = " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the"]
            #[doc = " `T::MaxExposurePageSize` biggest stakers."]
            #[doc = " (Note: the field `total` and `own` of the exposure remains unchanged)."]
            #[doc = " This is used to limit the i/o cost for the nominator payout."]
            #[doc = ""]
            #[doc = " This is keyed fist by the era index to allow bulk deletion and then the stash account."]
            #[doc = ""]
            #[doc = " It is removed after [`Config::HistoryDepth`] eras."]
            #[doc = " If stakers hasn't been set or has been removed then empty exposure is returned."]
            #[doc = ""]
            #[doc = " Note: Deprecated since v14. Use `EraInfo` instead to work with exposures."]
            pub fn eras_stakers_clipped(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 66u8, 152u8, 43u8, 157u8, 108u8, 122u8, 204u8,
                    153u8, 250u8, 169u8, 9u8, 76u8, 145u8, 35u8, 114u8, 194u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Paginated exposure of a validator at given era."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion, then stash account and finally"]
            #[doc = " the page. Should only be accessed through `EraInfo`."]
            #[doc = ""]
            #[doc = " This is cleared after [`Config::HistoryDepth`] eras."]
            pub fn eras_stakers_paged(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::StoragePaged<
                u32,
                types::sp_staking::ExposurePage<::polymesh_api_client::AccountId, u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 110u8, 207u8, 64u8, 55u8, 60u8, 114u8, 43u8, 3u8,
                    64u8, 211u8, 214u8, 92u8, 49u8, 26u8, 67u8, 5u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " History of claimed paged rewards by era and validator."]
            #[doc = ""]
            #[doc = " This is keyed by era and validator stash which maps to the set of page indexes which have"]
            #[doc = " been claimed."]
            #[doc = ""]
            #[doc = " It is removed after [`Config::HistoryDepth`] eras."]
            pub fn claimed_rewards(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                ::alloc::vec::Vec<u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 172u8, 102u8, 71u8, 2u8, 164u8, 87u8, 170u8, 161u8,
                    88u8, 229u8, 187u8, 69u8, 138u8, 12u8, 55u8, 108u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Similar to `ErasStakers`, this holds the preferences of validators."]
            #[doc = ""]
            #[doc = " This is keyed first by the era index to allow bulk deletion and then the stash account."]
            #[doc = ""]
            #[doc = " Is it removed after [`Config::HistoryDepth`] eras."]
            pub fn eras_validator_prefs(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_staking::ValidatorPrefs,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 104u8, 45u8, 185u8, 45u8, 222u8, 32u8, 161u8, 13u8,
                    150u8, 208u8, 15u8, 240u8, 233u8, 226u8, 33u8, 192u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The total validator era payout for the last [`Config::HistoryDepth`] eras."]
            #[doc = ""]
            #[doc = " Eras that haven't finished yet or has been removed doesn't have reward."]
            pub fn eras_validator_reward(&self) -> ::polymesh_api_client::StoragePaged<u32, u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 126u8, 110u8, 210u8, 238u8, 80u8, 124u8, 123u8,
                    68u8, 65u8, 213u8, 158u8, 77u8, 237u8, 68u8, 184u8, 162u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Rewards for the last [`Config::HistoryDepth`] eras."]
            #[doc = " If reward hasn't been set or has been removed then 0 reward is returned."]
            pub fn eras_reward_points(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                u32,
                types::pallet_staking::EraRewardPoints<::polymesh_api_client::AccountId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 128u8, 204u8, 101u8, 116u8, 40u8, 22u8, 113u8,
                    178u8, 153u8, 193u8, 114u8, 125u8, 122u8, 198u8, 140u8, 171u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The total amount staked for the last [`Config::HistoryDepth`] eras."]
            #[doc = " If total hasn't been set or has been removed then 0 stake is returned."]
            pub fn eras_total_stake(&self) -> ::polymesh_api_client::StoragePaged<u32, u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 161u8, 65u8, 196u8, 254u8, 103u8, 194u8, 209u8,
                    31u8, 74u8, 16u8, 198u8, 172u8, 167u8, 167u8, 154u8, 4u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " All unapplied slashes that are queued for later."]
            pub fn unapplied_slashes(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                u32,
                ::alloc::vec::Vec<
                    types::pallet_staking::UnappliedSlash<::polymesh_api_client::AccountId, u128>,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 4u8, 40u8, 36u8, 23u8, 10u8, 93u8, 180u8, 56u8,
                    31u8, 227u8, 57u8, 80u8, 57u8, 202u8, 189u8, 36u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " All slashing events on validators, mapped by era to the highest slash proportion"]
            #[doc = " and slash value of the era."]
            pub fn validator_slash_in_era(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                (::polymesh_api_client::per_things::Perbill, u128),
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 173u8, 110u8, 21u8, 238u8, 123u8, 253u8, 93u8,
                    85u8, 235u8, 161u8, 1u8, 36u8, 135u8, 211u8, 175u8, 84u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " All slashing events on nominators, mapped by era to the highest slash value of the era."]
            pub fn nominator_slash_in_era(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u128>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 129u8, 80u8, 8u8, 232u8, 33u8, 11u8, 109u8, 108u8,
                    247u8, 1u8, 226u8, 46u8, 91u8, 242u8, 113u8, 65u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Slashing spans for stash accounts."]
            pub fn slashing_spans(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_staking::slashing::SlashingSpans,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 171u8, 106u8, 33u8, 43u8, 192u8, 138u8, 86u8, 3u8,
                    130u8, 143u8, 51u8, 249u8, 14u8, 196u8, 161u8, 57u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Records information about the maximum slash of a stash within a slashing span,"]
            #[doc = " as well as how much reward has been paid out."]
            pub fn span_slash(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                (::polymesh_api_client::AccountId, u32),
                types::pallet_staking::slashing::SpanRecord<u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 62u8, 73u8, 7u8, 247u8, 22u8, 172u8, 137u8, 182u8, 52u8, 125u8, 21u8,
                    236u8, 236u8, 237u8, 202u8, 230u8, 47u8, 111u8, 121u8, 126u8, 190u8, 145u8,
                    56u8, 223u8, 206u8, 217u8, 66u8, 151u8, 127u8, 234u8, 80u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod offences {
        use super::*;
        #[derive(Clone)]
        pub struct OffencesCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> OffencesCallApi<'api> {}
        impl<'api> From<&'api super::super::Api> for OffencesCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct OffencesQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> OffencesQueryApi<'api> {
            #[doc = " The primary structure that holds all offence records keyed by report identifiers."]
            #[cfg(not(feature = "ink"))]
            pub async fn reports(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::sp_staking::offence::OffenceDetails<
                        ::polymesh_api_client::AccountId,
                        (
                            ::polymesh_api_client::AccountId,
                            types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>,
                        ),
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8,
                    67u8, 36u8, 242u8, 165u8, 178u8, 98u8, 233u8, 35u8, 143u8, 164u8, 2u8, 84u8,
                    12u8, 37u8, 11u8, 195u8, 245u8, 214u8, 24u8, 141u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The primary structure that holds all offence records keyed by report identifiers."]
            #[cfg(feature = "ink")]
            pub fn reports(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::sp_staking::offence::OffenceDetails<
                        ::polymesh_api_client::AccountId,
                        (
                            ::polymesh_api_client::AccountId,
                            types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>,
                        ),
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8,
                    67u8, 36u8, 242u8, 165u8, 178u8, 98u8, 233u8, 35u8, 143u8, 164u8, 2u8, 84u8,
                    12u8, 37u8, 11u8, 195u8, 245u8, 214u8, 24u8, 141u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " A vector of reports of the same kind that happened at the same time slot."]
            #[cfg(not(feature = "ink"))]
            pub async fn concurrent_reports_index(
                &self,
                key_0: [u8; 16usize],
                key_1: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8,
                    67u8, 36u8, 242u8, 165u8, 96u8, 220u8, 142u8, 240u8, 0u8, 205u8, 189u8, 200u8,
                    89u8, 221u8, 53u8, 34u8, 41u8, 206u8, 22u8, 251u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " A vector of reports of the same kind that happened at the same time slot."]
            #[cfg(feature = "ink")]
            pub fn concurrent_reports_index(
                &self,
                key_0: [u8; 16usize],
                key_1: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8,
                    67u8, 36u8, 242u8, 165u8, 96u8, 220u8, 142u8, 240u8, 0u8, 205u8, 189u8, 200u8,
                    89u8, 221u8, 53u8, 34u8, 41u8, 206u8, 22u8, 251u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct OffencesPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> OffencesPagedQueryApi<'api> {
            #[doc = " The primary structure that holds all offence records keyed by report identifiers."]
            pub fn reports(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                types::sp_staking::offence::OffenceDetails<
                    ::polymesh_api_client::AccountId,
                    (
                        ::polymesh_api_client::AccountId,
                        types::sp_staking::Exposure<::polymesh_api_client::AccountId, u128>,
                    ),
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8,
                    67u8, 36u8, 242u8, 165u8, 178u8, 98u8, 233u8, 35u8, 143u8, 164u8, 2u8, 84u8,
                    12u8, 37u8, 11u8, 195u8, 245u8, 214u8, 24u8, 141u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " A vector of reports of the same kind that happened at the same time slot."]
            pub fn concurrent_reports_index(
                &self,
                key_0: [u8; 16usize],
            ) -> ::polymesh_api_client::StoragePaged<
                ::alloc::vec::Vec<u8>,
                ::alloc::vec::Vec<types::primitive_types::H256>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    213u8, 196u8, 27u8, 82u8, 163u8, 113u8, 170u8, 54u8, 201u8, 37u8, 76u8, 227u8,
                    67u8, 36u8, 242u8, 165u8, 96u8, 220u8, 142u8, 240u8, 0u8, 205u8, 189u8, 200u8,
                    89u8, 221u8, 53u8, 34u8, 41u8, 206u8, 22u8, 251u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod session {
        use super::*;
        #[derive(Clone)]
        pub struct SessionCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> SessionCallApi<'api> {
            #[doc = "Sets the session key(s) of the function caller to `keys`."]
            #[doc = "Allows an account to set its session key prior to becoming a validator."]
            #[doc = "This doesn't take effect until the next session."]
            #[doc = ""]
            #[doc = "The dispatch origin of this function must be signed."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"]
            #[doc = "  fixed."]
            #[cfg(not(feature = "ink"))]
            pub fn set_keys(
                &self,
                keys: runtime::SessionKeys,
                proof: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Session(
                    types::pallet_session::pallet::SessionCall::set_keys { keys, proof },
                ))
            }
            #[doc = "Sets the session key(s) of the function caller to `keys`."]
            #[doc = "Allows an account to set its session key prior to becoming a validator."]
            #[doc = "This doesn't take effect until the next session."]
            #[doc = ""]
            #[doc = "The dispatch origin of this function must be signed."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is"]
            #[doc = "  fixed."]
            #[cfg(feature = "ink")]
            pub fn set_keys(
                &self,
                keys: runtime::SessionKeys,
                proof: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![19u8, 0u8];
                keys.encode_to(&mut buf);
                proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes any session key(s) of the function caller."]
            #[doc = ""]
            #[doc = "This doesn't take effect until the next session."]
            #[doc = ""]
            #[doc = "The dispatch origin of this function must be Signed and the account must be either be"]
            #[doc = "convertible to a validator ID using the chain's typical addressing system (this usually"]
            #[doc = "means being a controller account) or directly convertible into a validator ID (which"]
            #[doc = "usually means being a stash account)."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"]
            #[doc = "  `T::Keys::key_ids()` which is fixed."]
            #[cfg(not(feature = "ink"))]
            pub fn purge_keys(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Session(
                    types::pallet_session::pallet::SessionCall::purge_keys,
                ))
            }
            #[doc = "Removes any session key(s) of the function caller."]
            #[doc = ""]
            #[doc = "This doesn't take effect until the next session."]
            #[doc = ""]
            #[doc = "The dispatch origin of this function must be Signed and the account must be either be"]
            #[doc = "convertible to a validator ID using the chain's typical addressing system (this usually"]
            #[doc = "means being a controller account) or directly convertible into a validator ID (which"]
            #[doc = "usually means being a stash account)."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- `O(1)` in number of key types. Actual cost depends on the number of length of"]
            #[doc = "  `T::Keys::key_ids()` which is fixed."]
            #[cfg(feature = "ink")]
            pub fn purge_keys(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![19u8, 1u8])
            }
        }
        impl<'api> From<&'api super::super::Api> for SessionCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct SessionQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> SessionQueryApi<'api> {
            #[doc = " The current set of validators."]
            #[cfg(not(feature = "ink"))]
            pub async fn validators(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8,
                    39u8, 238u8, 29u8, 250u8, 252u8, 214u8, 225u8, 105u8, 3u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The current set of validators."]
            #[cfg(feature = "ink")]
            pub fn validators(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 136u8, 220u8, 222u8, 147u8, 76u8, 101u8, 130u8,
                    39u8, 238u8, 29u8, 250u8, 252u8, 214u8, 225u8, 105u8, 3u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<::polymesh_api_client::AccountId>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Current index of the session."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_index(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 114u8, 118u8, 56u8, 0u8, 163u8, 106u8, 153u8,
                    253u8, 252u8, 124u8, 16u8, 246u8, 65u8, 95u8, 110u8, 230u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Current index of the session."]
            #[cfg(feature = "ink")]
            pub fn current_index(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 114u8, 118u8, 56u8, 0u8, 163u8, 106u8, 153u8,
                    253u8, 252u8, 124u8, 16u8, 246u8, 65u8, 95u8, 110u8, 230u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " True if the underlying economic identities or weighting behind the validators"]
            #[doc = " has changed in the queued validator set."]
            #[cfg(not(feature = "ink"))]
            pub async fn queued_changed(&self) -> ::polymesh_api_client::error::Result<bool> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 148u8, 80u8, 191u8, 164u8, 185u8, 106u8, 63u8,
                    167u8, 163u8, 200u8, 244u8, 13u8, 166u8, 191u8, 50u8, 225u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " True if the underlying economic identities or weighting behind the validators"]
            #[doc = " has changed in the queued validator set."]
            #[cfg(feature = "ink")]
            pub fn queued_changed(&self) -> ::polymesh_api_ink::error::Result<bool> {
                let value = self.api.read_storage(::alloc::vec![
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 148u8, 80u8, 191u8, 164u8, 185u8, 106u8, 63u8,
                    167u8, 163u8, 200u8, 244u8, 13u8, 166u8, 191u8, 50u8, 225u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The queued keys for the next session. When the next session begins, these keys"]
            #[doc = " will be used to determine the validator's session keys."]
            #[cfg(not(feature = "ink"))]
            pub async fn queued_keys(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<(::polymesh_api_client::AccountId, runtime::SessionKeys)>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 224u8, 205u8, 208u8, 98u8, 230u8, 234u8, 242u8,
                    66u8, 149u8, 173u8, 76u8, 207u8, 196u8, 29u8, 70u8, 9u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < :: alloc :: vec :: Vec < (:: polymesh_api_client :: AccountId , runtime :: SessionKeys) > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " The queued keys for the next session. When the next session begins, these keys"]
            #[doc = " will be used to determine the validator's session keys."]
            #[cfg(feature = "ink")]
            pub fn queued_keys(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<(::polymesh_api_client::AccountId, runtime::SessionKeys)>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 224u8, 205u8, 208u8, 98u8, 230u8, 234u8, 242u8,
                    66u8, 149u8, 173u8, 76u8, 207u8, 196u8, 29u8, 70u8, 9u8,
                ])?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < :: alloc :: vec :: Vec < (:: polymesh_api_client :: AccountId , runtime :: SessionKeys) > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " Indices of disabled validators."]
            #[doc = ""]
            #[doc = " The vec is always kept sorted so that we can find whether a given validator is"]
            #[doc = " disabled using binary search. It gets cleared when `on_session_ending` returns"]
            #[doc = " a new set of identities."]
            #[cfg(not(feature = "ink"))]
            pub async fn disabled_validators(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<(u32, types::sp_staking::offence::OffenceSeverity)>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 90u8, 154u8, 116u8, 190u8, 74u8, 90u8, 125u8,
                    246u8, 11u8, 1u8, 166u8, 192u8, 50u8, 108u8, 94u8, 32u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(u32, types::sp_staking::offence::OffenceSeverity)>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Indices of disabled validators."]
            #[doc = ""]
            #[doc = " The vec is always kept sorted so that we can find whether a given validator is"]
            #[doc = " disabled using binary search. It gets cleared when `on_session_ending` returns"]
            #[doc = " a new set of identities."]
            #[cfg(feature = "ink")]
            pub fn disabled_validators(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<(u32, types::sp_staking::offence::OffenceSeverity)>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 90u8, 154u8, 116u8, 190u8, 74u8, 90u8, 125u8,
                    246u8, 11u8, 1u8, 166u8, 192u8, 50u8, 108u8, 94u8, 32u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(u32, types::sp_staking::offence::OffenceSeverity)>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The next session keys for a validator."]
            #[cfg(not(feature = "ink"))]
            pub async fn next_keys(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<Option<runtime::SessionKeys>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 76u8, 1u8, 78u8, 107u8, 248u8, 184u8, 194u8, 192u8,
                    17u8, 231u8, 41u8, 11u8, 133u8, 105u8, 107u8, 179u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The next session keys for a validator."]
            #[cfg(feature = "ink")]
            pub fn next_keys(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<Option<runtime::SessionKeys>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 76u8, 1u8, 78u8, 107u8, 248u8, 184u8, 194u8, 192u8,
                    17u8, 231u8, 41u8, 11u8, 133u8, 105u8, 107u8, 179u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."]
            #[cfg(not(feature = "ink"))]
            pub async fn key_owner(
                &self,
                key_0: (types::sp_core::crypto::KeyTypeId, ::alloc::vec::Vec<u8>),
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 114u8, 99u8, 128u8, 64u8, 70u8, 131u8, 252u8,
                    137u8, 232u8, 35u8, 52u8, 80u8, 200u8, 170u8, 25u8, 80u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."]
            #[cfg(feature = "ink")]
            pub fn key_owner(
                &self,
                key_0: (types::sp_core::crypto::KeyTypeId, ::alloc::vec::Vec<u8>),
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 114u8, 99u8, 128u8, 64u8, 70u8, 131u8, 252u8,
                    137u8, 232u8, 35u8, 52u8, 80u8, 200u8, 170u8, 25u8, 80u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct SessionPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> SessionPagedQueryApi<'api> {
            #[doc = " The next session keys for a validator."]
            pub fn next_keys(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                runtime::SessionKeys,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 76u8, 1u8, 78u8, 107u8, 248u8, 184u8, 194u8, 192u8,
                    17u8, 231u8, 41u8, 11u8, 133u8, 105u8, 107u8, 179u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The owner of a key. The key is the `KeyTypeId` + the encoded key."]
            pub fn key_owner(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                (types::sp_core::crypto::KeyTypeId, ::alloc::vec::Vec<u8>),
                ::polymesh_api_client::AccountId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    206u8, 197u8, 7u8, 13u8, 96u8, 157u8, 211u8, 73u8, 127u8, 114u8, 189u8, 224u8,
                    127u8, 201u8, 107u8, 160u8, 114u8, 99u8, 128u8, 64u8, 70u8, 131u8, 252u8,
                    137u8, 232u8, 35u8, 52u8, 80u8, 200u8, 170u8, 25u8, 80u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod authority_discovery {
        use super::*;
        #[derive(Clone)]
        pub struct AuthorityDiscoveryCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> AuthorityDiscoveryCallApi<'api> {}
        impl<'api> From<&'api super::super::Api> for AuthorityDiscoveryCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct AuthorityDiscoveryQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> AuthorityDiscoveryQueryApi<'api> {
            #[doc = " Keys of the current authority set."]
            #[cfg(not(feature = "ink"))]
            pub async fn keys(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::sp_authority_discovery::app::Public>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    32u8, 153u8, 215u8, 241u8, 9u8, 214u8, 229u8, 53u8, 251u8, 0u8, 11u8, 186u8,
                    98u8, 63u8, 212u8, 64u8, 159u8, 153u8, 162u8, 206u8, 113u8, 31u8, 58u8, 49u8,
                    178u8, 252u8, 5u8, 96u8, 76u8, 147u8, 241u8, 121u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::sp_authority_discovery::app::Public>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Keys of the current authority set."]
            #[cfg(feature = "ink")]
            pub fn keys(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::sp_authority_discovery::app::Public>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    32u8, 153u8, 215u8, 241u8, 9u8, 214u8, 229u8, 53u8, 251u8, 0u8, 11u8, 186u8,
                    98u8, 63u8, 212u8, 64u8, 159u8, 153u8, 162u8, 206u8, 113u8, 31u8, 58u8, 49u8,
                    178u8, 252u8, 5u8, 96u8, 76u8, 147u8, 241u8, 121u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::sp_authority_discovery::app::Public>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Keys of the next authority set."]
            #[cfg(not(feature = "ink"))]
            pub async fn next_keys(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::sp_authority_discovery::app::Public>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    32u8, 153u8, 215u8, 241u8, 9u8, 214u8, 229u8, 53u8, 251u8, 0u8, 11u8, 186u8,
                    98u8, 63u8, 212u8, 64u8, 76u8, 1u8, 78u8, 107u8, 248u8, 184u8, 194u8, 192u8,
                    17u8, 231u8, 41u8, 11u8, 133u8, 105u8, 107u8, 179u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::sp_authority_discovery::app::Public>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Keys of the next authority set."]
            #[cfg(feature = "ink")]
            pub fn next_keys(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::sp_authority_discovery::app::Public>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    32u8, 153u8, 215u8, 241u8, 9u8, 214u8, 229u8, 53u8, 251u8, 0u8, 11u8, 186u8,
                    98u8, 63u8, 212u8, 64u8, 76u8, 1u8, 78u8, 107u8, 248u8, 184u8, 194u8, 192u8,
                    17u8, 231u8, 41u8, 11u8, 133u8, 105u8, 107u8, 179u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::sp_authority_discovery::app::Public>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct AuthorityDiscoveryPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> AuthorityDiscoveryPagedQueryApi<'api> {}
    }
    pub mod grandpa {
        use super::*;
        #[derive(Clone)]
        pub struct GrandpaCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> GrandpaCallApi<'api> {
            #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
            #[doc = "equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence"]
            #[doc = "will be reported."]
            #[cfg(not(feature = "ink"))]
            pub fn report_equivocation(
                &self,
                equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
                    types::primitive_types::H256,
                    u32,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Grandpa(
                    types::pallet_grandpa::pallet::GrandpaCall::report_equivocation {
                        equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
                        key_owner_proof,
                    },
                ))
            }
            #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
            #[doc = "equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence"]
            #[doc = "will be reported."]
            #[cfg(feature = "ink")]
            pub fn report_equivocation(
                &self,
                equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
                    types::primitive_types::H256,
                    u32,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![21u8, 0u8];
                equivocation_proof.encode_to(&mut buf);
                key_owner_proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
            #[doc = "equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence"]
            #[doc = "will be reported."]
            #[doc = ""]
            #[doc = "This extrinsic must be called unsigned and it is expected that only"]
            #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
            #[doc = "if the block author is defined it will be defined as the equivocation"]
            #[doc = "reporter."]
            #[cfg(not(feature = "ink"))]
            pub fn report_equivocation_unsigned(
                &self,
                equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
                    types::primitive_types::H256,
                    u32,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Grandpa(
                    types::pallet_grandpa::pallet::GrandpaCall::report_equivocation_unsigned {
                        equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
                        key_owner_proof,
                    },
                ))
            }
            #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
            #[doc = "equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence"]
            #[doc = "will be reported."]
            #[doc = ""]
            #[doc = "This extrinsic must be called unsigned and it is expected that only"]
            #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
            #[doc = "if the block author is defined it will be defined as the equivocation"]
            #[doc = "reporter."]
            #[cfg(feature = "ink")]
            pub fn report_equivocation_unsigned(
                &self,
                equivocation_proof: types::sp_consensus_grandpa::EquivocationProof<
                    types::primitive_types::H256,
                    u32,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![21u8, 1u8];
                equivocation_proof.encode_to(&mut buf);
                key_owner_proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."]
            #[doc = ""]
            #[doc = "This will trigger a forced authority set change at the beginning of the next session, to"]
            #[doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"]
            #[doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."]
            #[doc = "The block production rate (which may be slowed down because of finality lagging) should"]
            #[doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"]
            #[doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"]
            #[doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"]
            #[doc = "block of all validators of the new authority set."]
            #[doc = ""]
            #[doc = "Only callable by root."]
            #[cfg(not(feature = "ink"))]
            pub fn note_stalled(
                &self,
                delay: u32,
                best_finalized_block_number: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Grandpa(
                    types::pallet_grandpa::pallet::GrandpaCall::note_stalled {
                        delay,
                        best_finalized_block_number,
                    },
                ))
            }
            #[doc = "Note that the current authority set of the GRANDPA finality gadget has stalled."]
            #[doc = ""]
            #[doc = "This will trigger a forced authority set change at the beginning of the next session, to"]
            #[doc = "be enacted `delay` blocks after that. The `delay` should be high enough to safely assume"]
            #[doc = "that the block signalling the forced change will not be re-orged e.g. 1000 blocks."]
            #[doc = "The block production rate (which may be slowed down because of finality lagging) should"]
            #[doc = "be taken into account when choosing the `delay`. The GRANDPA voters based on the new"]
            #[doc = "authority will start voting on top of `best_finalized_block_number` for new finalized"]
            #[doc = "blocks. `best_finalized_block_number` should be the highest of the latest finalized"]
            #[doc = "block of all validators of the new authority set."]
            #[doc = ""]
            #[doc = "Only callable by root."]
            #[cfg(feature = "ink")]
            pub fn note_stalled(
                &self,
                delay: u32,
                best_finalized_block_number: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![21u8, 2u8];
                delay.encode_to(&mut buf);
                best_finalized_block_number.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for GrandpaCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct GrandpaQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> GrandpaQueryApi<'api> {
            #[doc = " State of the current authority set."]
            #[cfg(not(feature = "ink"))]
            pub async fn state(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_grandpa::StoredState<u32>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 243u8, 154u8, 16u8, 127u8, 45u8, 141u8, 56u8, 84u8,
                    201u8, 171u8, 169u8, 176u8, 33u8, 244u8, 61u8, 156u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_grandpa::StoredState<u32>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " State of the current authority set."]
            #[cfg(feature = "ink")]
            pub fn state(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_grandpa::StoredState<u32>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 243u8, 154u8, 16u8, 127u8, 45u8, 141u8, 56u8, 84u8,
                    201u8, 171u8, 169u8, 176u8, 33u8, 244u8, 61u8, 156u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_grandpa::StoredState<u32>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Pending change: (signaled at, scheduled change)."]
            #[cfg(not(feature = "ink"))]
            pub async fn pending_change(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_grandpa::StoredPendingChange<u32>>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 47u8, 246u8, 89u8, 145u8, 177u8, 201u8, 21u8, 221u8,
                    108u8, 200u8, 212u8, 130u8, 94u8, 172u8, 252u8, 180u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Pending change: (signaled at, scheduled change)."]
            #[cfg(feature = "ink")]
            pub fn pending_change(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_grandpa::StoredPendingChange<u32>>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 47u8, 246u8, 89u8, 145u8, 177u8, 201u8, 21u8, 221u8,
                    108u8, 200u8, 212u8, 130u8, 94u8, 172u8, 252u8, 180u8,
                ])?;
                Ok(value)
            }
            #[doc = " next block number where we can force a change."]
            #[cfg(not(feature = "ink"))]
            pub async fn next_forced(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 1u8, 215u8, 129u8, 129u8, 38u8, 189u8, 155u8, 48u8,
                    116u8, 128u8, 62u8, 145u8, 244u8, 201u8, 27u8, 89u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " next block number where we can force a change."]
            #[cfg(feature = "ink")]
            pub fn next_forced(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 1u8, 215u8, 129u8, 129u8, 38u8, 189u8, 155u8, 48u8,
                    116u8, 128u8, 62u8, 145u8, 244u8, 201u8, 27u8, 89u8,
                ])?;
                Ok(value)
            }
            #[doc = " `true` if we are currently stalled."]
            #[cfg(not(feature = "ink"))]
            pub async fn stalled(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<(u32, u32)>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 125u8, 221u8, 1u8, 52u8, 97u8, 183u8, 44u8, 48u8,
                    4u8, 249u8, 192u8, 202u8, 63u8, 175u8, 158u8, 190u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " `true` if we are currently stalled."]
            #[cfg(feature = "ink")]
            pub fn stalled(&self) -> ::polymesh_api_ink::error::Result<Option<(u32, u32)>> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 125u8, 221u8, 1u8, 52u8, 97u8, 183u8, 44u8, 48u8,
                    4u8, 249u8, 192u8, 202u8, 63u8, 175u8, 158u8, 190u8,
                ])?;
                Ok(value)
            }
            #[doc = " The number of changes (both in terms of keys and underlying economic responsibilities)"]
            #[doc = " in the \"set\" of Grandpa validators from genesis."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_set_id(&self) -> ::polymesh_api_client::error::Result<u64> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 138u8, 45u8, 9u8, 70u8, 62u8, 255u8, 204u8, 120u8,
                    162u8, 45u8, 117u8, 185u8, 203u8, 135u8, 223u8, 252u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The number of changes (both in terms of keys and underlying economic responsibilities)"]
            #[doc = " in the \"set\" of Grandpa validators from genesis."]
            #[cfg(feature = "ink")]
            pub fn current_set_id(&self) -> ::polymesh_api_ink::error::Result<u64> {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 138u8, 45u8, 9u8, 70u8, 62u8, 255u8, 204u8, 120u8,
                    162u8, 45u8, 117u8, 185u8, 203u8, 135u8, 223u8, 252u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"]
            #[doc = " members were responsible."]
            #[doc = ""]
            #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
            #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
            #[doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"]
            #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
            #[doc = " during that session."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: `SetId` is not under user control."]
            #[cfg(not(feature = "ink"))]
            pub async fn set_id_session(
                &self,
                key_0: u64,
            ) -> ::polymesh_api_client::error::Result<Option<u32>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8, 67u8,
                    221u8, 251u8, 54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"]
            #[doc = " members were responsible."]
            #[doc = ""]
            #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
            #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
            #[doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"]
            #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
            #[doc = " during that session."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: `SetId` is not under user control."]
            #[cfg(feature = "ink")]
            pub fn set_id_session(
                &self,
                key_0: u64,
            ) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8, 67u8,
                    221u8, 251u8, 54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The current list of authorities."]
            #[cfg(not(feature = "ink"))]
            pub async fn authorities(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<(types::sp_consensus_grandpa::app::Public, u64)>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 94u8, 6u8, 33u8, 196u8, 134u8, 154u8, 166u8, 12u8,
                    2u8, 190u8, 154u8, 220u8, 201u8, 138u8, 13u8, 29u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(types::sp_consensus_grandpa::app::Public, u64)>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current list of authorities."]
            #[cfg(feature = "ink")]
            pub fn authorities(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<(types::sp_consensus_grandpa::app::Public, u64)>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 94u8, 6u8, 33u8, 196u8, 134u8, 154u8, 166u8, 12u8,
                    2u8, 190u8, 154u8, 220u8, 201u8, 138u8, 13u8, 29u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(types::sp_consensus_grandpa::app::Public, u64)>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct GrandpaPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> GrandpaPagedQueryApi<'api> {
            #[doc = " A mapping from grandpa set ID to the index of the *most recent* session for which its"]
            #[doc = " members were responsible."]
            #[doc = ""]
            #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
            #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
            #[doc = " together sessions and GRANDPA set ids, i.e. we need to validate that a validator"]
            #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
            #[doc = " during that session."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: `SetId` is not under user control."]
            pub fn set_id_session(&self) -> ::polymesh_api_client::StoragePaged<u64, u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    95u8, 156u8, 196u8, 91u8, 122u8, 0u8, 197u8, 137u8, 147u8, 97u8, 225u8, 198u8,
                    9u8, 150u8, 120u8, 220u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8, 67u8,
                    221u8, 251u8, 54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod historical {
        use super::*;
        #[derive(Clone)]
        pub struct HistoricalCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> HistoricalCallApi<'api> {}
        impl<'api> From<&'api super::super::Api> for HistoricalCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct HistoricalQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> HistoricalQueryApi<'api> {
            #[doc = " Mapping from historical session indices to session-data root hash and validator count."]
            #[cfg(not(feature = "ink"))]
            pub async fn historical_sessions(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<Option<(types::primitive_types::H256, u32)>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    47u8, 133u8, 241u8, 225u8, 55u8, 140u8, 178u8, 215u8, 184u8, 58u8, 219u8,
                    175u8, 11u8, 88u8, 105u8, 194u8, 152u8, 239u8, 125u8, 192u8, 96u8, 67u8, 110u8,
                    78u8, 216u8, 3u8, 175u8, 7u8, 99u8, 43u8, 137u8, 182u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Mapping from historical session indices to session-data root hash and validator count."]
            #[cfg(feature = "ink")]
            pub fn historical_sessions(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<Option<(types::primitive_types::H256, u32)>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    47u8, 133u8, 241u8, 225u8, 55u8, 140u8, 178u8, 215u8, 184u8, 58u8, 219u8,
                    175u8, 11u8, 88u8, 105u8, 194u8, 152u8, 239u8, 125u8, 192u8, 96u8, 67u8, 110u8,
                    78u8, 216u8, 3u8, 175u8, 7u8, 99u8, 43u8, 137u8, 182u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The range of historical sessions we store. [first, last)"]
            #[cfg(not(feature = "ink"))]
            pub async fn stored_range(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<(u32, u32)>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    47u8, 133u8, 241u8, 225u8, 55u8, 140u8, 178u8, 215u8, 184u8, 58u8, 219u8,
                    175u8, 11u8, 88u8, 105u8, 194u8, 255u8, 58u8, 225u8, 39u8, 112u8, 190u8, 162u8,
                    228u8, 141u8, 155u8, 222u8, 115u8, 133u8, 231u8, 162u8, 95u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The range of historical sessions we store. [first, last)"]
            #[cfg(feature = "ink")]
            pub fn stored_range(&self) -> ::polymesh_api_ink::error::Result<Option<(u32, u32)>> {
                let value = self.api.read_storage(::alloc::vec![
                    47u8, 133u8, 241u8, 225u8, 55u8, 140u8, 178u8, 215u8, 184u8, 58u8, 219u8,
                    175u8, 11u8, 88u8, 105u8, 194u8, 255u8, 58u8, 225u8, 39u8, 112u8, 190u8, 162u8,
                    228u8, 141u8, 155u8, 222u8, 115u8, 133u8, 231u8, 162u8, 95u8,
                ])?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct HistoricalPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> HistoricalPagedQueryApi<'api> {
            #[doc = " Mapping from historical session indices to session-data root hash and validator count."]
            pub fn historical_sessions(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<u32, (types::primitive_types::H256, u32)>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    47u8, 133u8, 241u8, 225u8, 55u8, 140u8, 178u8, 215u8, 184u8, 58u8, 219u8,
                    175u8, 11u8, 88u8, 105u8, 194u8, 152u8, 239u8, 125u8, 192u8, 96u8, 67u8, 110u8,
                    78u8, 216u8, 3u8, 175u8, 7u8, 99u8, 43u8, 137u8, 182u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod im_online {
        use super::*;
        #[derive(Clone)]
        pub struct ImOnlineCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> ImOnlineCallApi<'api> {
            #[doc = "## Complexity:"]
            #[doc = "- `O(K)` where K is length of `Keys` (heartbeat.validators_len)"]
            #[doc = "  - `O(K)`: decoding of length `K`"]
            #[cfg(not(feature = "ink"))]
            pub fn heartbeat(
                &self,
                heartbeat: types::pallet_im_online::Heartbeat<u32>,
                signature: types::pallet_im_online::sr25519::app_sr25519::Signature,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::ImOnline(
                    types::pallet_im_online::pallet::ImOnlineCall::heartbeat {
                        heartbeat,
                        signature,
                    },
                ))
            }
            #[doc = "## Complexity:"]
            #[doc = "- `O(K)` where K is length of `Keys` (heartbeat.validators_len)"]
            #[doc = "  - `O(K)`: decoding of length `K`"]
            #[cfg(feature = "ink")]
            pub fn heartbeat(
                &self,
                heartbeat: types::pallet_im_online::Heartbeat<u32>,
                signature: types::pallet_im_online::sr25519::app_sr25519::Signature,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![23u8, 0u8];
                heartbeat.encode_to(&mut buf);
                signature.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for ImOnlineCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct ImOnlineQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> ImOnlineQueryApi<'api> {
            #[doc = " The block number after which it's ok to send heartbeats in the current"]
            #[doc = " session."]
            #[doc = ""]
            #[doc = " At the beginning of each session we set this to a value that should fall"]
            #[doc = " roughly in the middle of the session duration. The idea is to first wait for"]
            #[doc = " the validators to produce a block in the current session, so that the"]
            #[doc = " heartbeat later on will not be necessary."]
            #[doc = ""]
            #[doc = " This value will only be used as a fallback if we fail to get a proper session"]
            #[doc = " progress estimate from `NextSessionRotation`, as those estimates should be"]
            #[doc = " more accurate then the value we calculate for `HeartbeatAfter`."]
            #[cfg(not(feature = "ink"))]
            pub async fn heartbeat_after(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8,
                    141u8, 221u8, 155u8, 148u8, 138u8, 161u8, 242u8, 201u8, 132u8, 79u8, 17u8, 2u8,
                    76u8, 29u8, 32u8, 78u8, 112u8, 90u8, 98u8, 23u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The block number after which it's ok to send heartbeats in the current"]
            #[doc = " session."]
            #[doc = ""]
            #[doc = " At the beginning of each session we set this to a value that should fall"]
            #[doc = " roughly in the middle of the session duration. The idea is to first wait for"]
            #[doc = " the validators to produce a block in the current session, so that the"]
            #[doc = " heartbeat later on will not be necessary."]
            #[doc = ""]
            #[doc = " This value will only be used as a fallback if we fail to get a proper session"]
            #[doc = " progress estimate from `NextSessionRotation`, as those estimates should be"]
            #[doc = " more accurate then the value we calculate for `HeartbeatAfter`."]
            #[cfg(feature = "ink")]
            pub fn heartbeat_after(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8,
                    141u8, 221u8, 155u8, 148u8, 138u8, 161u8, 242u8, 201u8, 132u8, 79u8, 17u8, 2u8,
                    76u8, 29u8, 32u8, 78u8, 112u8, 90u8, 98u8, 23u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The current set of keys that may issue a heartbeat."]
            #[cfg(not(feature = "ink"))]
            pub async fn keys(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::pallet_im_online::sr25519::app_sr25519::Public>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8,
                    141u8, 221u8, 155u8, 148u8, 159u8, 153u8, 162u8, 206u8, 113u8, 31u8, 58u8,
                    49u8, 178u8, 252u8, 5u8, 96u8, 76u8, 147u8, 241u8, 121u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < :: alloc :: vec :: Vec < types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " The current set of keys that may issue a heartbeat."]
            #[cfg(feature = "ink")]
            pub fn keys(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::pallet_im_online::sr25519::app_sr25519::Public>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8,
                    141u8, 221u8, 155u8, 148u8, 159u8, 153u8, 162u8, 206u8, 113u8, 31u8, 58u8,
                    49u8, 178u8, 252u8, 5u8, 96u8, 76u8, 147u8, 241u8, 121u8,
                ])?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < :: alloc :: vec :: Vec < types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex`."]
            #[cfg(not(feature = "ink"))]
            pub async fn received_heartbeats(
                &self,
                key_0: u32,
                key_1: u32,
            ) -> ::polymesh_api_client::error::Result<Option<bool>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8,
                    141u8, 221u8, 155u8, 148u8, 204u8, 90u8, 26u8, 166u8, 227u8, 113u8, 99u8,
                    114u8, 243u8, 110u8, 241u8, 3u8, 183u8, 227u8, 174u8, 103u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex`."]
            #[cfg(feature = "ink")]
            pub fn received_heartbeats(
                &self,
                key_0: u32,
                key_1: u32,
            ) -> ::polymesh_api_ink::error::Result<Option<bool>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8,
                    141u8, 221u8, 155u8, 148u8, 204u8, 90u8, 26u8, 166u8, 227u8, 113u8, 99u8,
                    114u8, 243u8, 110u8, 241u8, 3u8, 183u8, 227u8, 174u8, 103u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"]
            #[doc = " number of blocks authored by the given authority."]
            #[cfg(not(feature = "ink"))]
            pub async fn authored_blocks(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8,
                    141u8, 221u8, 155u8, 148u8, 177u8, 195u8, 113u8, 222u8, 217u8, 233u8, 197u8,
                    101u8, 232u8, 155u8, 167u8, 131u8, 196u8, 213u8, 245u8, 249u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"]
            #[doc = " number of blocks authored by the given authority."]
            #[cfg(feature = "ink")]
            pub fn authored_blocks(
                &self,
                key_0: u32,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8,
                    141u8, 221u8, 155u8, 148u8, 177u8, 195u8, 113u8, 222u8, 217u8, 233u8, 197u8,
                    101u8, 232u8, 155u8, 167u8, 131u8, 196u8, 213u8, 245u8, 249u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct ImOnlinePagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> ImOnlinePagedQueryApi<'api> {
            #[doc = " For each session index, we keep a mapping of `SessionIndex` and `AuthIndex`."]
            pub fn received_heartbeats(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::StoragePaged<u32, bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8,
                    141u8, 221u8, 155u8, 148u8, 204u8, 90u8, 26u8, 166u8, 227u8, 113u8, 99u8,
                    114u8, 243u8, 110u8, 241u8, 3u8, 183u8, 227u8, 174u8, 103u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " For each session index, we keep a mapping of `ValidatorId<T>` to the"]
            #[doc = " number of blocks authored by the given authority."]
            pub fn authored_blocks(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u32>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    43u8, 6u8, 175u8, 151u8, 25u8, 172u8, 100u8, 215u8, 85u8, 98u8, 60u8, 218u8,
                    141u8, 221u8, 155u8, 148u8, 177u8, 195u8, 113u8, 222u8, 217u8, 233u8, 197u8,
                    101u8, 232u8, 155u8, 167u8, 131u8, 196u8, 213u8, 245u8, 249u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod randomness_collective_flip {
        use super::*;
        #[derive(Clone)]
        pub struct RandomnessCollectiveFlipCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> RandomnessCollectiveFlipCallApi<'api> {}
        impl<'api> From<&'api super::super::Api> for RandomnessCollectiveFlipCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct RandomnessCollectiveFlipQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> RandomnessCollectiveFlipQueryApi<'api> {
            #[doc = " Series of block headers from the last 81 blocks that acts as random seed material. This"]
            #[doc = " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of"]
            #[doc = " the oldest hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn random_material(
                &self,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    189u8, 42u8, 82u8, 147u8, 121u8, 71u8, 80u8, 136u8, 211u8, 226u8, 154u8, 145u8,
                    140u8, 212u8, 120u8, 114u8, 26u8, 57u8, 236u8, 118u8, 123u8, 213u8, 38u8,
                    145u8, 17u8, 230u8, 73u8, 42u8, 22u8, 117u8, 112u8, 42u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Series of block headers from the last 81 blocks that acts as random seed material. This"]
            #[doc = " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of"]
            #[doc = " the oldest hash."]
            #[cfg(feature = "ink")]
            pub fn random_material(
                &self,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<types::primitive_types::H256>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    189u8, 42u8, 82u8, 147u8, 121u8, 71u8, 80u8, 136u8, 211u8, 226u8, 154u8, 145u8,
                    140u8, 212u8, 120u8, 114u8, 26u8, 57u8, 236u8, 118u8, 123u8, 213u8, 38u8,
                    145u8, 17u8, 230u8, 73u8, 42u8, 22u8, 117u8, 112u8, 42u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::primitive_types::H256>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct RandomnessCollectiveFlipPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> RandomnessCollectiveFlipPagedQueryApi<'api> {}
    }
    pub mod sudo {
        use super::*;
        #[derive(Clone)]
        pub struct SudoCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> SudoCallApi<'api> {
            #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
            #[cfg(not(feature = "ink"))]
            pub fn sudo(
                &self,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sudo(
                    types::pallet_sudo::pallet::SudoCall::sudo {
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
            #[cfg(feature = "ink")]
            pub fn sudo(&self, call: runtime::RuntimeCall) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![25u8, 0u8];
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
            #[doc = "This function does not check the weight of the call, and instead allows the"]
            #[doc = "Sudo user to specify the weight of the call."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_."]
            #[cfg(not(feature = "ink"))]
            pub fn sudo_unchecked_weight(
                &self,
                call: runtime::RuntimeCall,
                weight: ::polymesh_api_client::sp_weights::Weight,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sudo(
                    types::pallet_sudo::pallet::SudoCall::sudo_unchecked_weight {
                        call: ::alloc::boxed::Box::new(call),
                        weight,
                    },
                ))
            }
            #[doc = "Authenticates the sudo key and dispatches a function call with `Root` origin."]
            #[doc = "This function does not check the weight of the call, and instead allows the"]
            #[doc = "Sudo user to specify the weight of the call."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_."]
            #[cfg(feature = "ink")]
            pub fn sudo_unchecked_weight(
                &self,
                call: runtime::RuntimeCall,
                weight: ::polymesh_api_client::sp_weights::Weight,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![25u8, 1u8];
                call.encode_to(&mut buf);
                weight.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"]
            #[doc = "key."]
            #[cfg(not(feature = "ink"))]
            pub fn set_key(
                &self,
                new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sudo(
                    types::pallet_sudo::pallet::SudoCall::set_key { new },
                ))
            }
            #[doc = "Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo"]
            #[doc = "key."]
            #[cfg(feature = "ink")]
            pub fn set_key(
                &self,
                new: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![25u8, 2u8];
                new.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"]
            #[doc = "a given account."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_."]
            #[cfg(not(feature = "ink"))]
            pub fn sudo_as(
                &self,
                who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sudo(
                    types::pallet_sudo::pallet::SudoCall::sudo_as {
                        who,
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Authenticates the sudo key and dispatches a function call with `Signed` origin from"]
            #[doc = "a given account."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_."]
            #[cfg(feature = "ink")]
            pub fn sudo_as(
                &self,
                who: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                call: runtime::RuntimeCall,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![25u8, 3u8];
                who.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Permanently removes the sudo key."]
            #[doc = ""]
            #[doc = "**This cannot be un-done.**"]
            #[cfg(not(feature = "ink"))]
            pub fn remove_key(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sudo(
                    types::pallet_sudo::pallet::SudoCall::remove_key,
                ))
            }
            #[doc = "Permanently removes the sudo key."]
            #[doc = ""]
            #[doc = "**This cannot be un-done.**"]
            #[cfg(feature = "ink")]
            pub fn remove_key(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![25u8, 4u8])
            }
        }
        impl<'api> From<&'api super::super::Api> for SudoCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct SudoQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> SudoQueryApi<'api> {
            #[doc = " The `AccountId` of the sudo key."]
            #[cfg(not(feature = "ink"))]
            pub async fn key(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AccountId>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    92u8, 13u8, 17u8, 118u8, 165u8, 104u8, 193u8, 249u8, 41u8, 68u8, 52u8, 13u8,
                    191u8, 237u8, 158u8, 156u8, 83u8, 14u8, 188u8, 167u8, 3u8, 200u8, 89u8, 16u8,
                    231u8, 22u8, 76u8, 183u8, 209u8, 201u8, 228u8, 123u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The `AccountId` of the sudo key."]
            #[cfg(feature = "ink")]
            pub fn key(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AccountId>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    92u8, 13u8, 17u8, 118u8, 165u8, 104u8, 193u8, 249u8, 41u8, 68u8, 52u8, 13u8,
                    191u8, 237u8, 158u8, 156u8, 83u8, 14u8, 188u8, 167u8, 3u8, 200u8, 89u8, 16u8,
                    231u8, 22u8, 76u8, 183u8, 209u8, 201u8, 228u8, 123u8,
                ])?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct SudoPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> SudoPagedQueryApi<'api> {}
    }
    pub mod asset {
        use super::*;
        #[derive(Clone)]
        pub struct AssetCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> AssetCallApi<'api> {
            #[doc = "Registers a unique ticker or extends the validity of an existing ticker."]
            #[doc = ""]
            #[doc = "This function allows the caller to register a new ticker or extend the registration"]
            #[doc = "of an existing ticker. The ticker validity does not carry forward when renewing."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `ticker` - The ticker to register."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `TickerRegistered` - When a ticker is successfully registered."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TickerAlreadyRegistered` - If the ticker is already registered."]
            #[doc = "* `TickerTooLong` - If the ticker length exceeds the maximum allowed length."]
            #[doc = "* `InvalidTickerCharacter` - If the ticker contains invalid characters."]
            #[cfg(not(feature = "ink"))]
            pub fn register_unique_ticker(
                &self,
                ticker: types::polymesh_primitives::ticker::Ticker,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::register_unique_ticker { ticker },
                ))
            }
            #[doc = "Registers a unique ticker or extends the validity of an existing ticker."]
            #[doc = ""]
            #[doc = "This function allows the caller to register a new ticker or extend the registration"]
            #[doc = "of an existing ticker. The ticker validity does not carry forward when renewing."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `ticker` - The ticker to register."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `TickerRegistered` - When a ticker is successfully registered."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TickerAlreadyRegistered` - If the ticker is already registered."]
            #[doc = "* `TickerTooLong` - If the ticker length exceeds the maximum allowed length."]
            #[doc = "* `InvalidTickerCharacter` - If the ticker contains invalid characters."]
            #[cfg(feature = "ink")]
            pub fn register_unique_ticker(
                &self,
                ticker: types::polymesh_primitives::ticker::Ticker,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 0u8];
                ticker.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Accepts a ticker transfer."]
            #[doc = ""]
            #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
            #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `auth_id` - Authorization ID of ticker transfer authorization."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `TickerTransferred` - When a ticker is successfully transferred."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
            #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
            #[cfg(not(feature = "ink"))]
            pub fn accept_ticker_transfer(
                &self,
                auth_id: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::accept_ticker_transfer { auth_id },
                ))
            }
            #[doc = "Accepts a ticker transfer."]
            #[doc = ""]
            #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
            #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `auth_id` - Authorization ID of ticker transfer authorization."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `TickerTransferred` - When a ticker is successfully transferred."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
            #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
            #[cfg(feature = "ink")]
            pub fn accept_ticker_transfer(&self, auth_id: u64) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 1u8];
                auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Accepts an asset ownership transfer."]
            #[doc = ""]
            #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
            #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `auth_id` - Authorization ID of the asset ownership transfer authorization."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetOwnershipTransferred` - When a asset ownership is successfully transferred."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
            #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
            #[cfg(not(feature = "ink"))]
            pub fn accept_asset_ownership_transfer(
                &self,
                auth_id: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::accept_asset_ownership_transfer {
                        auth_id,
                    },
                ))
            }
            #[doc = "Accepts an asset ownership transfer."]
            #[doc = ""]
            #[doc = "Consumes the authorization `auth_id` (see `pallet_identity::consume_auth`)."]
            #[doc = "NB: To reject the transfer, call remove auth function in identity module."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `auth_id` - Authorization ID of the asset ownership transfer authorization."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetOwnershipTransferred` - When a asset ownership is successfully transferred."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
            #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
            #[cfg(feature = "ink")]
            pub fn accept_asset_ownership_transfer(
                &self,
                auth_id: u64,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 2u8];
                auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Creates a new asset."]
            #[doc = ""]
            #[doc = "The total supply will initially be zero. To mint tokens, use [`Pallet::issue`]."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
            #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
            #[doc = "* `asset_type` - The [`AssetType`] of the new asset."]
            #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
            #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetCreated` - When a new asset is successfully created."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
            #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
            #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
            #[cfg(not(feature = "ink"))]
            pub fn create_asset(
                &self,
                asset_name: types::polymesh_primitives::asset::AssetName,
                divisible: bool,
                asset_type: types::polymesh_primitives::asset::AssetType,
                asset_identifiers: ::alloc::vec::Vec<
                    types::polymesh_primitives::asset_identifier::AssetIdentifier,
                >,
                funding_round_name: Option<types::polymesh_primitives::asset::FundingRoundName>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::create_asset {
                        asset_name,
                        divisible,
                        asset_type,
                        asset_identifiers,
                        funding_round_name,
                    },
                ))
            }
            #[doc = "Creates a new asset."]
            #[doc = ""]
            #[doc = "The total supply will initially be zero. To mint tokens, use [`Pallet::issue`]."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
            #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
            #[doc = "* `asset_type` - The [`AssetType`] of the new asset."]
            #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
            #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetCreated` - When a new asset is successfully created."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
            #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
            #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
            #[cfg(feature = "ink")]
            pub fn create_asset(
                &self,
                asset_name: types::polymesh_primitives::asset::AssetName,
                divisible: bool,
                asset_type: types::polymesh_primitives::asset::AssetType,
                asset_identifiers: ::alloc::vec::Vec<
                    types::polymesh_primitives::asset_identifier::AssetIdentifier,
                >,
                funding_round_name: Option<types::polymesh_primitives::asset::FundingRoundName>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 3u8];
                asset_name.encode_to(&mut buf);
                divisible.encode_to(&mut buf);
                asset_type.encode_to(&mut buf);
                asset_identifiers.encode_to(&mut buf);
                funding_round_name.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Freezes transfers of a given asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to freeze transfers of a given asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The asset to freeze."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetFrozen` - When an asset is successfully frozen."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NoSuchAsset` - If the asset does not exist."]
            #[doc = "* `AlreadyFrozen` - If the asset is already frozen."]
            #[cfg(not(feature = "ink"))]
            pub fn freeze(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::freeze { asset_id },
                ))
            }
            #[doc = "Freezes transfers of a given asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to freeze transfers of a given asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The asset to freeze."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetFrozen` - When an asset is successfully frozen."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NoSuchAsset` - If the asset does not exist."]
            #[doc = "* `AlreadyFrozen` - If the asset is already frozen."]
            #[cfg(feature = "ink")]
            pub fn freeze(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 4u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Unfreezes transfers of a given asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to unfreeze transfers of a given asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The asset to unfreeze."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetUnfrozen` - When an asset is successfully unfrozen."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NoSuchAsset` - If the asset does not exist."]
            #[doc = "* `NotFrozen` - If the asset is not frozen."]
            #[cfg(not(feature = "ink"))]
            pub fn unfreeze(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::unfreeze { asset_id },
                ))
            }
            #[doc = "Unfreezes transfers of a given asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to unfreeze transfers of a given asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The asset to unfreeze."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetUnfrozen` - When an asset is successfully unfrozen."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NoSuchAsset` - If the asset does not exist."]
            #[doc = "* `NotFrozen` - If the asset is not frozen."]
            #[cfg(feature = "ink")]
            pub fn unfreeze(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 5u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Updates the [`AssetName`] associated to an asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to update the name of an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `asset_name` - The new [`AssetName`] that will be associated to the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetRenamed` - When an asset is successfully renamed."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
            #[doc = "* `NoSuchAsset` - If the asset does not exist."]
            #[cfg(not(feature = "ink"))]
            pub fn rename_asset(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                asset_name: types::polymesh_primitives::asset::AssetName,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::rename_asset {
                        asset_id,
                        asset_name,
                    },
                ))
            }
            #[doc = "Updates the [`AssetName`] associated to an asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to update the name of an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `asset_name` - The new [`AssetName`] that will be associated to the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetRenamed` - When an asset is successfully renamed."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
            #[doc = "* `NoSuchAsset` - If the asset does not exist."]
            #[cfg(feature = "ink")]
            pub fn rename_asset(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                asset_name: types::polymesh_primitives::asset::AssetName,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 6u8];
                asset_id.encode_to(&mut buf);
                asset_name.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Issue (i.e mint) new tokens to the caller, which must be an authorized external agent."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to mint new tokens for a given asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin`: A signer that has permissions to act as an agent of `ticker`."]
            #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
            #[doc = "* `amount`: The amount of tokens that will be issued."]
            #[doc = "* `portfolio_kind`: The [`PortfolioKind`] of the portfolio that will receive the minted tokens."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
            #[doc = "* `InvalidGranularity` - If the amount to issue does not meet the granularity requirements."]
            #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
            #[cfg(not(feature = "ink"))]
            pub fn issue(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                amount: u128,
                portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::issue {
                        asset_id,
                        amount,
                        portfolio_kind,
                    },
                ))
            }
            #[doc = "Issue (i.e mint) new tokens to the caller, which must be an authorized external agent."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to mint new tokens for a given asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin`: A signer that has permissions to act as an agent of `ticker`."]
            #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
            #[doc = "* `amount`: The amount of tokens that will be issued."]
            #[doc = "* `portfolio_kind`: The [`PortfolioKind`] of the portfolio that will receive the minted tokens."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
            #[doc = "* `InvalidGranularity` - If the amount to issue does not meet the granularity requirements."]
            #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
            #[cfg(feature = "ink")]
            pub fn issue(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                amount: u128,
                portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 7u8];
                asset_id.encode_to(&mut buf);
                amount.encode_to(&mut buf);
                portfolio_kind.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Redeems (i.e burns) existing tokens by reducing the balance of the caller's portfolio and the total supply of the asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to redeem tokens from a given asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin`: is a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
            #[doc = "* `value`: amount of tokens to redeem."]
            #[doc = "* `portfolio_kind`: the [`PortfolioKind`] that will have its balance reduced."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
            #[doc = "* `InvalidGranularity` - If the value to redeem does not meet the granularity requirements."]
            #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
            #[cfg(not(feature = "ink"))]
            pub fn redeem(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                value: u128,
                portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::redeem {
                        asset_id,
                        value,
                        portfolio_kind,
                    },
                ))
            }
            #[doc = "Redeems (i.e burns) existing tokens by reducing the balance of the caller's portfolio and the total supply of the asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to redeem tokens from a given asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin`: is a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "* `asset_id`: the [`AssetId`] associated to the asset."]
            #[doc = "* `value`: amount of tokens to redeem."]
            #[doc = "* `portfolio_kind`: the [`PortfolioKind`] that will have its balance reduced."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetBalanceUpdated` - When the asset balance is successfully updated."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
            #[doc = "* `InvalidGranularity` - If the value to redeem does not meet the granularity requirements."]
            #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
            #[cfg(feature = "ink")]
            pub fn redeem(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                value: u128,
                portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 8u8];
                asset_id.encode_to(&mut buf);
                value.encode_to(&mut buf);
                portfolio_kind.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "If the asset associated to `asset_id` is indivisible, sets [`AssetDetails::divisible`] to true."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to make an indivisible asset divisible."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `DivisibilityChanged` - When the divisibility of an asset is successfully changed."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NoSuchAsset` - If the asset does not exist."]
            #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
            #[doc = "* `AssetAlreadyDivisible` - If the asset is already divisible."]
            #[cfg(not(feature = "ink"))]
            pub fn make_divisible(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::make_divisible { asset_id },
                ))
            }
            #[doc = "If the asset associated to `asset_id` is indivisible, sets [`AssetDetails::divisible`] to true."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to make an indivisible asset divisible."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `DivisibilityChanged` - When the divisibility of an asset is successfully changed."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NoSuchAsset` - If the asset does not exist."]
            #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
            #[doc = "* `AssetAlreadyDivisible` - If the asset is already divisible."]
            #[cfg(feature = "ink")]
            pub fn make_divisible(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 9u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Add documents for a given asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to add documents to an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `docs` - Documents to be attached to the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `DocumentAdded` - When a document is successfully added to an asset."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `CounterOverflow` - If the document ID counter overflows."]
            #[cfg(not(feature = "ink"))]
            pub fn add_documents(
                &self,
                docs: ::alloc::vec::Vec<types::polymesh_primitives::document::Document>,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::add_documents { docs, asset_id },
                ))
            }
            #[doc = "Add documents for a given asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to add documents to an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `docs` - Documents to be attached to the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `DocumentAdded` - When a document is successfully added to an asset."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `CounterOverflow` - If the document ID counter overflows."]
            #[cfg(feature = "ink")]
            pub fn add_documents(
                &self,
                docs: ::alloc::vec::Vec<types::polymesh_primitives::document::Document>,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 10u8];
                docs.encode_to(&mut buf);
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Remove documents for a given asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to remove documents from an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `docs_id` - A vector of all [`DocumentId`] that will be removed from the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `DocumentRemoved` - When a document is successfully removed from an asset."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_documents(
                &self,
                docs_id: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::remove_documents { docs_id, asset_id },
                ))
            }
            #[doc = "Remove documents for a given asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to remove documents from an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `docs_id` - A vector of all [`DocumentId`] that will be removed from the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `DocumentRemoved` - When a document is successfully removed from an asset."]
            #[cfg(feature = "ink")]
            pub fn remove_documents(
                &self,
                docs_id: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 11u8];
                docs_id.encode_to(&mut buf);
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Sets the name of the current funding round."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to set the name of the current funding round for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `funding_round_name` - The [`FundingRoundName`] of the current funding round."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `FundingRoundSet` - When the funding round name is successfully set."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundingRoundNameMaxLengthExceeded` - If the funding round name length exceeds the maximum allowed length."]
            #[cfg(not(feature = "ink"))]
            pub fn set_funding_round(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                funding_round_name: types::polymesh_primitives::asset::FundingRoundName,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::set_funding_round {
                        asset_id,
                        funding_round_name,
                    },
                ))
            }
            #[doc = "Sets the name of the current funding round."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to set the name of the current funding round for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `funding_round_name` - The [`FundingRoundName`] of the current funding round."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `FundingRoundSet` - When the funding round name is successfully set."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundingRoundNameMaxLengthExceeded` - If the funding round name length exceeds the maximum allowed length."]
            #[cfg(feature = "ink")]
            pub fn set_funding_round(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                funding_round_name: types::polymesh_primitives::asset::FundingRoundName,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 12u8];
                asset_id.encode_to(&mut buf);
                funding_round_name.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Updates the asset identifiers associated to the asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to update the asset identifiers for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`] that will be associated to the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `IdentifiersUpdated` - When the asset identifiers are successfully updated."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
            #[cfg(not(feature = "ink"))]
            pub fn update_identifiers(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                asset_identifiers: ::alloc::vec::Vec<
                    types::polymesh_primitives::asset_identifier::AssetIdentifier,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::update_identifiers {
                        asset_id,
                        asset_identifiers,
                    },
                ))
            }
            #[doc = "Updates the asset identifiers associated to the asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to update the asset identifiers for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`] that will be associated to the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `IdentifiersUpdated` - When the asset identifiers are successfully updated."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
            #[cfg(feature = "ink")]
            pub fn update_identifiers(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                asset_identifiers: ::alloc::vec::Vec<
                    types::polymesh_primitives::asset_identifier::AssetIdentifier,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 13u8];
                asset_id.encode_to(&mut buf);
                asset_identifiers.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Forces a transfer of tokens from `from_portfolio` to the caller's default portfolio."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to force a transfer of tokens from one portfolio to another."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `value` - The [`Balance`] of tokens that will be transferred."]
            #[doc = "* `from_portfolio` - The [`PortfolioId`] that will have its balance reduced."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `ControllerTransfer` - When tokens are successfully transferred."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
            #[doc = "* `InvalidGranularity` - If the amount to transfer does not meet the granularity requirements."]
            #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
            #[cfg(not(feature = "ink"))]
            pub fn controller_transfer(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                value: u128,
                from_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::controller_transfer {
                        asset_id,
                        value,
                        from_portfolio,
                    },
                ))
            }
            #[doc = "Forces a transfer of tokens from `from_portfolio` to the caller's default portfolio."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to force a transfer of tokens from one portfolio to another."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `value` - The [`Balance`] of tokens that will be transferred."]
            #[doc = "* `from_portfolio` - The [`PortfolioId`] that will have its balance reduced."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `ControllerTransfer` - When tokens are successfully transferred."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `UnexpectedNonFungibleToken` - If the asset is a non-fungible token."]
            #[doc = "* `InvalidGranularity` - If the amount to transfer does not meet the granularity requirements."]
            #[doc = "* `TotalSupplyOverflow` - If the total supply exceeds the maximum allowed limit."]
            #[cfg(feature = "ink")]
            pub fn controller_transfer(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                value: u128,
                from_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 14u8];
                asset_id.encode_to(&mut buf);
                value.encode_to(&mut buf);
                from_portfolio.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Registers a custom asset type."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `ty` - Contains the string representation of the asset type."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
            #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
            #[cfg(not(feature = "ink"))]
            pub fn register_custom_asset_type(
                &self,
                ty: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::register_custom_asset_type { ty },
                ))
            }
            #[doc = "Registers a custom asset type."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `ty` - Contains the string representation of the asset type."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
            #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
            #[cfg(feature = "ink")]
            pub fn register_custom_asset_type(
                &self,
                ty: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 15u8];
                ty.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Creates a new asset with a new custom asset type."]
            #[doc = ""]
            #[doc = "The total supply will initially be zero. To mint tokens, use [`Pallet::issue`]."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
            #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
            #[doc = "* `custom_asset_type` - The custom asset type of the asset."]
            #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
            #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetCreated` - When a new asset is successfully created."]
            #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
            #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
            #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
            #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
            #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
            #[cfg(not(feature = "ink"))]
            pub fn create_asset_with_custom_type(
                &self,
                asset_name: types::polymesh_primitives::asset::AssetName,
                divisible: bool,
                custom_asset_type: ::alloc::vec::Vec<u8>,
                asset_identifiers: ::alloc::vec::Vec<
                    types::polymesh_primitives::asset_identifier::AssetIdentifier,
                >,
                funding_round_name: Option<types::polymesh_primitives::asset::FundingRoundName>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::create_asset_with_custom_type {
                        asset_name,
                        divisible,
                        custom_asset_type,
                        asset_identifiers,
                        funding_round_name,
                    },
                ))
            }
            #[doc = "Creates a new asset with a new custom asset type."]
            #[doc = ""]
            #[doc = "The total supply will initially be zero. To mint tokens, use [`Pallet::issue`]."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_name` - The [`AssetName`] of the new asset."]
            #[doc = "* `divisible` - Sets [`AssetDetails::divisible`], where `true` means the asset is divisible."]
            #[doc = "* `custom_asset_type` - The custom asset type of the asset."]
            #[doc = "* `asset_identifiers` - A vector of [`AssetIdentifier`]."]
            #[doc = "* `funding_round_name` - The name of the funding round ([`FundingRoundName`])."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetCreated` - When a new asset is successfully created."]
            #[doc = "* `CustomAssetTypeRegistered` - When a new custom asset type is successfully registered."]
            #[doc = "* `CustomAssetTypeAlreadyRegistered` - When the custom asset type is already registered."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `MaxLengthOfAssetNameExceeded` - If the asset name length exceeds the maximum allowed length."]
            #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
            #[doc = "* `InvalidAssetIdentifier` - If any of the asset identifiers are invalid."]
            #[doc = "* `TooLong` - If the custom asset type length exceeds the maximum allowed length."]
            #[cfg(feature = "ink")]
            pub fn create_asset_with_custom_type(
                &self,
                asset_name: types::polymesh_primitives::asset::AssetName,
                divisible: bool,
                custom_asset_type: ::alloc::vec::Vec<u8>,
                asset_identifiers: ::alloc::vec::Vec<
                    types::polymesh_primitives::asset_identifier::AssetIdentifier,
                >,
                funding_round_name: Option<types::polymesh_primitives::asset::FundingRoundName>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 16u8];
                asset_name.encode_to(&mut buf);
                divisible.encode_to(&mut buf);
                custom_asset_type.encode_to(&mut buf);
                asset_identifiers.encode_to(&mut buf);
                funding_round_name.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set asset metadata value."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to set metadata for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
            #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
            #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
            #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
            #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
            #[cfg(not(feature = "ink"))]
            pub fn set_asset_metadata(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
                detail: Option<
                    types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::set_asset_metadata {
                        asset_id,
                        key,
                        value,
                        detail,
                    },
                ))
            }
            #[doc = "Set asset metadata value."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to set metadata for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
            #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
            #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
            #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
            #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
            #[cfg(feature = "ink")]
            pub fn set_asset_metadata(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
                detail: Option<
                    types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 17u8];
                asset_id.encode_to(&mut buf);
                key.encode_to(&mut buf);
                value.encode_to(&mut buf);
                detail.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set asset metadata value details (expire, lock status)."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to set metadata details for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
            #[doc = "* `details` - The [`AssetMetadataValueDetail`] (expire, lock status) that will be associated to the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `SetAssetMetadataValueDetails` - When the asset metadata value details are successfully set."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
            #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
            #[doc = "* `AssetMetadataValueIsEmpty` - If the metadata value is empty."]
            #[cfg(not(feature = "ink"))]
            pub fn set_asset_metadata_details(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                detail: types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::set_asset_metadata_details {
                        asset_id,
                        key,
                        detail,
                    },
                ))
            }
            #[doc = "Set asset metadata value details (expire, lock status)."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to set metadata details for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `key` - The [`AssetMetadataKey`] associated to the asset."]
            #[doc = "* `details` - The [`AssetMetadataValueDetail`] (expire, lock status) that will be associated to the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `SetAssetMetadataValueDetails` - When the asset metadata value details are successfully set."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
            #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
            #[doc = "* `AssetMetadataValueIsEmpty` - If the metadata value is empty."]
            #[cfg(feature = "ink")]
            pub fn set_asset_metadata_details(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                detail: types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 18u8];
                asset_id.encode_to(&mut buf);
                key.encode_to(&mut buf);
                detail.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Registers and set local asset metadata."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to register and set local metadata for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `name` - The [`AssetMetadataName`]."]
            #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
            #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
            #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
            #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
            #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
            #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
            #[cfg(not(feature = "ink"))]
            pub fn register_and_set_local_asset_metadata(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
                spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
                value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
                detail: Option<
                    types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::register_and_set_local_asset_metadata {
                        asset_id,
                        name,
                        spec,
                        value,
                        detail,
                    },
                ))
            }
            #[doc = "Registers and set local asset metadata."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to register and set local metadata for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `name` - The [`AssetMetadataName`]."]
            #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
            #[doc = "* `value` - The [`AssetMetadataValue`] of the given metadata key."]
            #[doc = "* `details` - Optional [`AssetMetadataValueDetail`] (expire, lock status)."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
            #[doc = "* `SetAssetMetadataValue` - When the asset metadata value is successfully set."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
            #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
            #[doc = "* `AssetMetadataValueMaxLengthExceeded` - If the metadata value length exceeds the maximum allowed length."]
            #[cfg(feature = "ink")]
            pub fn register_and_set_local_asset_metadata(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
                spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
                value: types::polymesh_primitives::asset_metadata::AssetMetadataValue,
                detail: Option<
                    types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 19u8];
                asset_id.encode_to(&mut buf);
                name.encode_to(&mut buf);
                spec.encode_to(&mut buf);
                value.encode_to(&mut buf);
                detail.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Registers asset metadata local type."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to register a local metadata type for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `name` - The [`AssetMetadataName`]."]
            #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
            #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
            #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
            #[cfg(not(feature = "ink"))]
            pub fn register_asset_metadata_local_type(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
                spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::register_asset_metadata_local_type {
                        asset_id,
                        name,
                        spec,
                    },
                ))
            }
            #[doc = "Registers asset metadata local type."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to register a local metadata type for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `name` - The [`AssetMetadataName`]."]
            #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `RegisterAssetMetadataLocalType` - When the local asset metadata type is successfully registered."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataLocalKeyAlreadyExists` - If the local metadata key already exists."]
            #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
            #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
            #[cfg(feature = "ink")]
            pub fn register_asset_metadata_local_type(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
                spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 20u8];
                asset_id.encode_to(&mut buf);
                name.encode_to(&mut buf);
                spec.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Registers asset metadata global type."]
            #[doc = ""]
            #[doc = "This function allows the root origin to register a global metadata type."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The root origin."]
            #[doc = "* `name` - The [`AssetMetadataName`]."]
            #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `RegisterAssetMetadataGlobalType` - When the global asset metadata type is successfully registered."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataGlobalKeyAlreadyExists` - If the global metadata key already exists."]
            #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
            #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
            #[cfg(not(feature = "ink"))]
            pub fn register_asset_metadata_global_type(
                &self,
                name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
                spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::register_asset_metadata_global_type {
                        name,
                        spec,
                    },
                ))
            }
            #[doc = "Registers asset metadata global type."]
            #[doc = ""]
            #[doc = "This function allows the root origin to register a global metadata type."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The root origin."]
            #[doc = "* `name` - The [`AssetMetadataName`]."]
            #[doc = "* `spec` - The asset metadata specifications ([`AssetMetadataSpec`])."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `RegisterAssetMetadataGlobalType` - When the global asset metadata type is successfully registered."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataGlobalKeyAlreadyExists` - If the global metadata key already exists."]
            #[doc = "* `AssetMetadataNameMaxLengthExceeded` - If the metadata name length exceeds the maximum allowed length."]
            #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
            #[cfg(feature = "ink")]
            pub fn register_asset_metadata_global_type(
                &self,
                name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
                spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 21u8];
                name.encode_to(&mut buf);
                spec.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Updates the type of an asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to update the type of an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `asset_type` - The new [`AssetType`] of the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetTypeChanged` - When the asset type is successfully changed."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NoSuchAsset` - If the asset does not exist."]
            #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
            #[doc = "* `IncompatibleAssetTypeUpdate` - If the new asset type is incompatible with the existing asset type."]
            #[cfg(not(feature = "ink"))]
            pub fn update_asset_type(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                asset_type: types::polymesh_primitives::asset::AssetType,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::update_asset_type {
                        asset_id,
                        asset_type,
                    },
                ))
            }
            #[doc = "Updates the type of an asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to update the type of an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the asset."]
            #[doc = "* `asset_type` - The new [`AssetType`] of the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetTypeChanged` - When the asset type is successfully changed."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NoSuchAsset` - If the asset does not exist."]
            #[doc = "* `InvalidCustomAssetTypeId` - If the custom asset type ID is invalid."]
            #[doc = "* `IncompatibleAssetTypeUpdate` - If the new asset type is incompatible with the existing asset type."]
            #[cfg(feature = "ink")]
            pub fn update_asset_type(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                asset_type: types::polymesh_primitives::asset::AssetType,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 22u8];
                asset_id.encode_to(&mut buf);
                asset_type.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the asset metadata key and value of a local key."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to remove a local metadata key and its value for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the local metadata key."]
            #[doc = "* `local_key` - The [`AssetMetadataLocalKey`] that will be removed."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `LocalMetadataKeyDeleted` - When the local metadata key is successfully deleted."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataKeyIsMissing` - If the local metadata key is missing."]
            #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
            #[doc = "* `AssetMetadataKeyBelongsToNFTCollection` - If the metadata key belongs to an NFT collection."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_local_metadata_key(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                local_key: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::remove_local_metadata_key {
                        asset_id,
                        local_key,
                    },
                ))
            }
            #[doc = "Removes the asset metadata key and value of a local key."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to remove a local metadata key and its value for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the local metadata key."]
            #[doc = "* `local_key` - The [`AssetMetadataLocalKey`] that will be removed."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `LocalMetadataKeyDeleted` - When the local metadata key is successfully deleted."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataKeyIsMissing` - If the local metadata key is missing."]
            #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
            #[doc = "* `AssetMetadataKeyBelongsToNFTCollection` - If the metadata key belongs to an NFT collection."]
            #[cfg(feature = "ink")]
            pub fn remove_local_metadata_key(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                local_key: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 23u8];
                asset_id.encode_to(&mut buf);
                local_key.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the asset metadata value of a metadata key."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to remove a metadata value for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the metadata key."]
            #[doc = "* `metadata_key` - The [`AssetMetadataKey`] that will have its value deleted."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `MetadataValueDeleted` - When the metadata value is successfully deleted."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
            #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_metadata_value(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                metadata_key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::remove_metadata_value {
                        asset_id,
                        metadata_key,
                    },
                ))
            }
            #[doc = "Removes the asset metadata value of a metadata key."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to remove a metadata value for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] associated to the metadata key."]
            #[doc = "* `metadata_key` - The [`AssetMetadataKey`] that will have its value deleted."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `MetadataValueDeleted` - When the metadata value is successfully deleted."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `AssetMetadataKeyIsMissing` - If the metadata key is missing."]
            #[doc = "* `AssetMetadataValueIsLocked` - If the metadata value is locked."]
            #[cfg(feature = "ink")]
            pub fn remove_metadata_value(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                metadata_key: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 24u8];
                asset_id.encode_to(&mut buf);
                metadata_key.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Pre-approves the receivement of the asset for all identities."]
            #[doc = ""]
            #[doc = "This function allows the root origin to pre-approve the receivement of an asset for all identities."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The root origin."]
            #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetAffirmationExemption` - When the asset is successfully exempted from affirmation."]
            #[cfg(not(feature = "ink"))]
            pub fn exempt_asset_affirmation(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::exempt_asset_affirmation { asset_id },
                ))
            }
            #[doc = "Pre-approves the receivement of the asset for all identities."]
            #[doc = ""]
            #[doc = "This function allows the root origin to pre-approve the receivement of an asset for all identities."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The root origin."]
            #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetAffirmationExemption` - When the asset is successfully exempted from affirmation."]
            #[cfg(feature = "ink")]
            pub fn exempt_asset_affirmation(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 25u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the pre-approval of the asset for all identities."]
            #[doc = ""]
            #[doc = "This function allows the root origin to remove the pre-approval of an asset for all identities."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The root origin."]
            #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `RemoveAssetAffirmationExemption` - When the asset's affirmation exemption is successfully removed."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_asset_affirmation_exemption(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::remove_asset_affirmation_exemption {
                        asset_id,
                    },
                ))
            }
            #[doc = "Removes the pre-approval of the asset for all identities."]
            #[doc = ""]
            #[doc = "This function allows the root origin to remove the pre-approval of an asset for all identities."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The root origin."]
            #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `RemoveAssetAffirmationExemption` - When the asset's affirmation exemption is successfully removed."]
            #[cfg(feature = "ink")]
            pub fn remove_asset_affirmation_exemption(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 26u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Pre-approves the receivement of an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `PreApprovedAsset` - When the asset is successfully pre-approved for receivement."]
            #[cfg(not(feature = "ink"))]
            pub fn pre_approve_asset(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::pre_approve_asset { asset_id },
                ))
            }
            #[doc = "Pre-approves the receivement of an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] that will be exempt from affirmation."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `PreApprovedAsset` - When the asset is successfully pre-approved for receivement."]
            #[cfg(feature = "ink")]
            pub fn pre_approve_asset(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 27u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the pre-approval of an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `RemovePreApprovedAsset` - When the asset's pre-approval is successfully removed."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_asset_pre_approval(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::remove_asset_pre_approval { asset_id },
                ))
            }
            #[doc = "Removes the pre-approval of an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] that will have its exemption removed."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `RemovePreApprovedAsset` - When the asset's pre-approval is successfully removed."]
            #[cfg(feature = "ink")]
            pub fn remove_asset_pre_approval(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 28u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Sets all identities in the `mediators` set as mandatory mediators for any instruction transferring `asset_id`."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to add mandatory mediators for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] of the asset that will require the mediators."]
            #[doc = "* `mediators` - A set of [`IdentityId`] of all the mandatory mediators for the given ticker."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetMediatorsAdded` - When the mandatory mediators are successfully added."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NumberOfAssetMediatorsExceeded` - If the number of mandatory mediators exceeds the maximum allowed limit."]
            #[cfg(not(feature = "ink"))]
            pub fn add_mandatory_mediators(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::add_mandatory_mediators {
                        asset_id,
                        mediators,
                    },
                ))
            }
            #[doc = "Sets all identities in the `mediators` set as mandatory mediators for any instruction transferring `asset_id`."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to add mandatory mediators for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] of the asset that will require the mediators."]
            #[doc = "* `mediators` - A set of [`IdentityId`] of all the mandatory mediators for the given ticker."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetMediatorsAdded` - When the mandatory mediators are successfully added."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NumberOfAssetMediatorsExceeded` - If the number of mandatory mediators exceeds the maximum allowed limit."]
            #[cfg(feature = "ink")]
            pub fn add_mandatory_mediators(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 29u8];
                asset_id.encode_to(&mut buf);
                mediators.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes all identities in the `mediators` set from the mandatory mediators list for the given `asset_id`."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to remove mandatory mediators for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] of the asset that will have mediators removed."]
            #[doc = "* `mediators` - A set of [`IdentityId`] of all the mediators that will be removed from the mandatory mediators list."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetMediatorsRemoved` - When the mandatory mediators are successfully removed."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_mandatory_mediators(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::remove_mandatory_mediators {
                        asset_id,
                        mediators,
                    },
                ))
            }
            #[doc = "Removes all identities in the `mediators` set from the mandatory mediators list for the given `asset_id`."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to remove mandatory mediators for an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_id` - The [`AssetId`] of the asset that will have mediators removed."]
            #[doc = "* `mediators` - A set of [`IdentityId`] of all the mediators that will be removed from the mandatory mediators list."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `AssetMediatorsRemoved` - When the mandatory mediators are successfully removed."]
            #[cfg(feature = "ink")]
            pub fn remove_mandatory_mediators(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 30u8];
                asset_id.encode_to(&mut buf);
                mediators.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Establishes a connection between a ticker and an AssetId."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to link a ticker to an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `ticker` - The [`Ticker`] that will be linked to the given `asset_id`."]
            #[doc = "* `asset_id` - The [`AssetId`] that will be connected to `ticker`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `TickerLinkedToAsset` - When the ticker is successfully linked to the asset."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
            #[doc = "* `TickerRegistrationExpired` - If the ticker registration has expired."]
            #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
            #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
            #[doc = "* `AssetIsAlreadyLinkedToATicker` - If the asset is already linked to a ticker."]
            #[cfg(not(feature = "ink"))]
            pub fn link_ticker_to_asset_id(
                &self,
                ticker: types::polymesh_primitives::ticker::Ticker,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::link_ticker_to_asset_id {
                        ticker,
                        asset_id,
                    },
                ))
            }
            #[doc = "Establishes a connection between a ticker and an AssetId."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to link a ticker to an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `ticker` - The [`Ticker`] that will be linked to the given `asset_id`."]
            #[doc = "* `asset_id` - The [`AssetId`] that will be connected to `ticker`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `TickerLinkedToAsset` - When the ticker is successfully linked to the asset."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
            #[doc = "* `TickerRegistrationExpired` - If the ticker registration has expired."]
            #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
            #[doc = "* `TickerIsAlreadyLinkedToAnAsset` - If the ticker is already linked to an asset."]
            #[doc = "* `AssetIsAlreadyLinkedToATicker` - If the asset is already linked to a ticker."]
            #[cfg(feature = "ink")]
            pub fn link_ticker_to_asset_id(
                &self,
                ticker: types::polymesh_primitives::ticker::Ticker,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 31u8];
                ticker.encode_to(&mut buf);
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the link between a ticker and an asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to unlink a ticker from an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `ticker` - The [`Ticker`] that will be unlinked from the given `asset_id`."]
            #[doc = "* `asset_id` - The [`AssetId`] that will be unlinked from `ticker`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `TickerUnlinkedFromAsset` - When the ticker is successfully unlinked from the asset."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
            #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
            #[doc = "* `TickerIsNotLinkedToTheAsset` - If the ticker is not linked to the asset."]
            #[cfg(not(feature = "ink"))]
            pub fn unlink_ticker_from_asset_id(
                &self,
                ticker: types::polymesh_primitives::ticker::Ticker,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::unlink_ticker_from_asset_id {
                        ticker,
                        asset_id,
                    },
                ))
            }
            #[doc = "Removes the link between a ticker and an asset."]
            #[doc = ""]
            #[doc = "This function allows the asset issuer or an external agent to unlink a ticker from an asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `ticker` - The [`Ticker`] that will be unlinked from the given `asset_id`."]
            #[doc = "* `asset_id` - The [`AssetId`] that will be unlinked from `ticker`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `TickerUnlinkedFromAsset` - When the ticker is successfully unlinked from the asset."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `TickerNotRegisteredToCaller` - If the ticker is not registered to the caller."]
            #[doc = "* `TickerRegistrationNotFound` - If the ticker registration is not found."]
            #[doc = "* `TickerIsNotLinkedToTheAsset` - If the ticker is not linked to the asset."]
            #[cfg(feature = "ink")]
            pub fn unlink_ticker_from_asset_id(
                &self,
                ticker: types::polymesh_primitives::ticker::Ticker,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 32u8];
                ticker.encode_to(&mut buf);
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Updates the global metadata specification."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_metadata_name` - The [`AssetMetadataName`] associated with the global metadata."]
            #[doc = "* `asset_metadata_spec` - The new [`AssetMetadataSpec`] that will be associated with the global metadata."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `GlobalMetadataSpecUpdated` - When the global metadata specification is successfully updated."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the origin is not authorized."]
            #[doc = "* `TooLong` - If the metadata url or description length exceeds the maximum allowed length."]
            #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
            #[cfg(not(feature = "ink"))]
            pub fn update_global_metadata_spec(
                &self,
                asset_metadata_name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
                asset_metadata_spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Asset(
                    types::pallet_asset::pallet::AssetCall::update_global_metadata_spec {
                        asset_metadata_name,
                        asset_metadata_spec,
                    },
                ))
            }
            #[doc = "Updates the global metadata specification."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which can be the primary or secondary key of an identity."]
            #[doc = "* `asset_metadata_name` - The [`AssetMetadataName`] associated with the global metadata."]
            #[doc = "* `asset_metadata_spec` - The new [`AssetMetadataSpec`] that will be associated with the global metadata."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `GlobalMetadataSpecUpdated` - When the global metadata specification is successfully updated."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the origin is not authorized."]
            #[doc = "* `TooLong` - If the metadata url or description length exceeds the maximum allowed length."]
            #[doc = "* `AssetMetadataTypeDefMaxLengthExceeded` - If the metadata type definition length exceeds the maximum allowed length."]
            #[cfg(feature = "ink")]
            pub fn update_global_metadata_spec(
                &self,
                asset_metadata_name: types::polymesh_primitives::asset_metadata::AssetMetadataName,
                asset_metadata_spec: types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![26u8, 33u8];
                asset_metadata_name.encode_to(&mut buf);
                asset_metadata_spec.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for AssetCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct AssetQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> AssetQueryApi<'api> {
            #[doc = " Map each [`Ticker`] to its registration details ([`TickerRegistration`])."]
            #[cfg(not(feature = "ink"))]
            pub async fn unique_ticker_registration(
                &self,
                key_0: types::polymesh_primitives::ticker::Ticker,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_asset::types::TickerRegistration<u64>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 121u8, 181u8, 109u8, 199u8, 4u8, 80u8, 93u8,
                    65u8, 21u8, 24u8, 9u8, 66u8, 56u8, 123u8, 250u8, 186u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Map each [`Ticker`] to its registration details ([`TickerRegistration`])."]
            #[cfg(feature = "ink")]
            pub fn unique_ticker_registration(
                &self,
                key_0: types::polymesh_primitives::ticker::Ticker,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_asset::types::TickerRegistration<u64>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 121u8, 181u8, 109u8, 199u8, 4u8, 80u8, 93u8,
                    65u8, 21u8, 24u8, 9u8, 66u8, 56u8, 123u8, 250u8, 186u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Returns [`TickerRegistrationConfig`] for assessing if a ticker is valid."]
            #[cfg(not(feature = "ink"))]
            pub async fn ticker_config(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::pallet_asset::types::TickerRegistrationConfig<u64>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 185u8, 113u8, 30u8, 121u8, 127u8, 46u8, 243u8,
                    186u8, 159u8, 108u8, 75u8, 247u8, 236u8, 154u8, 169u8, 176u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8];
                    <types::pallet_asset::types::TickerRegistrationConfig<u64>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Returns [`TickerRegistrationConfig`] for assessing if a ticker is valid."]
            #[cfg(feature = "ink")]
            pub fn ticker_config(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                types::pallet_asset::types::TickerRegistrationConfig<u64>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 185u8, 113u8, 30u8, 121u8, 127u8, 46u8, 243u8,
                    186u8, 159u8, 108u8, 75u8, 247u8, 236u8, 154u8, 169u8, 176u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8];
                    <types::pallet_asset::types::TickerRegistrationConfig<u64>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Maps each [`AssetId`] to its underling [`AssetDetails`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn assets(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_asset::types::AssetDetails>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 104u8, 42u8, 89u8, 213u8, 26u8, 185u8, 228u8,
                    138u8, 140u8, 140u8, 196u8, 24u8, 255u8, 151u8, 8u8, 210u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Maps each [`AssetId`] to its underling [`AssetDetails`]."]
            #[cfg(feature = "ink")]
            pub fn assets(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_asset::types::AssetDetails>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 104u8, 42u8, 89u8, 213u8, 26u8, 185u8, 228u8,
                    138u8, 140u8, 140u8, 196u8, 24u8, 255u8, 151u8, 8u8, 210u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Maps each [`AssetId`] to its underling [`AssetName`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_names(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset::AssetName>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 123u8, 195u8, 250u8, 203u8, 235u8, 133u8, 90u8,
                    23u8, 143u8, 10u8, 8u8, 53u8, 96u8, 109u8, 5u8, 206u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Maps each [`AssetId`] to its underling [`AssetName`]."]
            #[cfg(feature = "ink")]
            pub fn asset_names(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset::AssetName>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 123u8, 195u8, 250u8, 203u8, 235u8, 133u8, 90u8,
                    23u8, 143u8, 10u8, 8u8, 53u8, 96u8, 109u8, 5u8, 206u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Tracks the total [`Balance`] for each [`AssetId`] per [`IdentityId`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn balance_of(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 106u8, 75u8, 187u8, 251u8, 206u8, 1u8, 124u8,
                    102u8, 14u8, 227u8, 176u8, 68u8, 23u8, 115u8, 19u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                buf.extend(key_1.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Tracks the total [`Balance`] for each [`AssetId`] per [`IdentityId`]."]
            #[cfg(feature = "ink")]
            pub fn balance_of(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 106u8, 75u8, 187u8, 251u8, 206u8, 1u8, 124u8,
                    102u8, 14u8, 227u8, 176u8, 68u8, 23u8, 115u8, 19u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                buf.extend(key_1.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Maps each [`AssetId`] to its asset identifiers ([`AssetIdentifier`])."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_identifiers(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::asset_identifier::AssetIdentifier>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 178u8, 193u8, 1u8, 161u8, 14u8, 189u8, 176u8,
                    94u8, 104u8, 54u8, 170u8, 144u8, 16u8, 162u8, 98u8, 190u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(
                    value.unwrap_or_else(|| {
                        use ::codec::Decode;
                        const DEFAULT: &'static [u8] = &[0u8];
                        <::alloc::vec::Vec<
                            types::polymesh_primitives::asset_identifier::AssetIdentifier,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
                    }),
                )
            }
            #[doc = " Maps each [`AssetId`] to its asset identifiers ([`AssetIdentifier`])."]
            #[cfg(feature = "ink")]
            pub fn asset_identifiers(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::asset_identifier::AssetIdentifier>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 178u8, 193u8, 1u8, 161u8, 14u8, 189u8, 176u8,
                    94u8, 104u8, 54u8, 170u8, 144u8, 16u8, 162u8, 98u8, 190u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(
                    value.unwrap_or_else(|| {
                        use ::codec::Decode;
                        const DEFAULT: &'static [u8] = &[0u8];
                        <::alloc::vec::Vec<
                            types::polymesh_primitives::asset_identifier::AssetIdentifier,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
                    }),
                )
            }
            #[doc = " The next `AssetType::Custom` ID in the sequence."]
            #[doc = ""]
            #[doc = " Numbers in the sequence start from 1 rather than 0."]
            #[cfg(not(feature = "ink"))]
            pub async fn custom_type_id_sequence(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::asset::CustomAssetTypeId,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 16u8, 121u8, 19u8, 48u8, 14u8, 106u8, 39u8,
                    83u8, 29u8, 145u8, 209u8, 187u8, 190u8, 66u8, 165u8, 176u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::asset::CustomAssetTypeId>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The next `AssetType::Custom` ID in the sequence."]
            #[doc = ""]
            #[doc = " Numbers in the sequence start from 1 rather than 0."]
            #[cfg(feature = "ink")]
            pub fn custom_type_id_sequence(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::asset::CustomAssetTypeId,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 16u8, 121u8, 19u8, 48u8, 14u8, 106u8, 39u8,
                    83u8, 29u8, 145u8, 209u8, 187u8, 190u8, 66u8, 165u8, 176u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::asset::CustomAssetTypeId>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Maps custom asset type ids to the registered string contents."]
            #[cfg(not(feature = "ink"))]
            pub async fn custom_types(
                &self,
                key_0: types::polymesh_primitives::asset::CustomAssetTypeId,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u8>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 214u8, 35u8, 90u8, 254u8, 57u8, 243u8, 210u8,
                    34u8, 193u8, 0u8, 96u8, 131u8, 116u8, 109u8, 49u8, 166u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Maps custom asset type ids to the registered string contents."]
            #[cfg(feature = "ink")]
            pub fn custom_types(
                &self,
                key_0: types::polymesh_primitives::asset::CustomAssetTypeId,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u8>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 214u8, 35u8, 90u8, 254u8, 57u8, 243u8, 210u8,
                    34u8, 193u8, 0u8, 96u8, 131u8, 116u8, 109u8, 49u8, 166u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<u8>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Inverse map of `CustomTypes`, from registered string contents to custom asset type ids."]
            #[cfg(not(feature = "ink"))]
            pub async fn custom_types_inverse(
                &self,
                key_0: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset::CustomAssetTypeId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 2u8, 147u8, 168u8, 237u8, 90u8, 35u8, 218u8,
                    237u8, 169u8, 231u8, 223u8, 32u8, 46u8, 15u8, 228u8, 85u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Inverse map of `CustomTypes`, from registered string contents to custom asset type ids."]
            #[cfg(feature = "ink")]
            pub fn custom_types_inverse(
                &self,
                key_0: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset::CustomAssetTypeId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 2u8, 147u8, 168u8, 237u8, 90u8, 35u8, 218u8,
                    237u8, 169u8, 231u8, 223u8, 32u8, 46u8, 15u8, 228u8, 85u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Maps each [`AssetId`] to the name of its founding round ([`FundingRoundName`])."]
            #[cfg(not(feature = "ink"))]
            pub async fn funding_round(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::asset::FundingRoundName,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 93u8, 34u8, 9u8, 253u8, 168u8, 224u8, 203u8,
                    196u8, 69u8, 133u8, 25u8, 204u8, 124u8, 207u8, 104u8, 5u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::asset::FundingRoundName>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Maps each [`AssetId`] to the name of its founding round ([`FundingRoundName`])."]
            #[cfg(feature = "ink")]
            pub fn funding_round(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::asset::FundingRoundName,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 93u8, 34u8, 9u8, 253u8, 168u8, 224u8, 203u8,
                    196u8, 69u8, 133u8, 25u8, 204u8, 124u8, 207u8, 104u8, 5u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::asset::FundingRoundName>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The total [`Balance`] of tokens issued in all recorded funding rounds ([`FundingRoundName`])."]
            #[cfg(not(feature = "ink"))]
            pub async fn issued_in_funding_round(
                &self,
                key_0: (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::asset::FundingRoundName,
                ),
            ) -> ::polymesh_api_client::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 215u8, 137u8, 60u8, 134u8, 127u8, 54u8, 56u8,
                    208u8, 215u8, 148u8, 185u8, 185u8, 12u8, 48u8, 135u8, 44u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The total [`Balance`] of tokens issued in all recorded funding rounds ([`FundingRoundName`])."]
            #[cfg(feature = "ink")]
            pub fn issued_in_funding_round(
                &self,
                key_0: (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::asset::FundingRoundName,
                ),
            ) -> ::polymesh_api_ink::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 215u8, 137u8, 60u8, 134u8, 127u8, 54u8, 56u8,
                    208u8, 215u8, 148u8, 185u8, 185u8, 12u8, 48u8, 135u8, 44u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Returns `true` if transfers for the asset are frozen. Otherwise, returns `false`."]
            #[cfg(not(feature = "ink"))]
            pub async fn frozen(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8,
                    93u8, 238u8, 240u8, 115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Returns `true` if transfers for the asset are frozen. Otherwise, returns `false`."]
            #[cfg(feature = "ink")]
            pub fn frozen(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8,
                    93u8, 238u8, 240u8, 115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All [`Document`] attached to an asset."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_documents(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::document::DocumentId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::document::Document>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 166u8, 167u8, 74u8, 143u8, 116u8, 237u8, 66u8,
                    137u8, 149u8, 40u8, 102u8, 20u8, 236u8, 96u8, 52u8, 9u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " All [`Document`] attached to an asset."]
            #[cfg(feature = "ink")]
            pub fn asset_documents(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::document::DocumentId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::document::Document>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 166u8, 167u8, 74u8, 143u8, 116u8, 237u8, 66u8,
                    137u8, 149u8, 40u8, 102u8, 20u8, 236u8, 96u8, 52u8, 9u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " [`DocumentId`] counter per [`AssetId`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_documents_id_sequence(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::document::DocumentId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 201u8, 198u8, 40u8, 95u8, 195u8, 158u8, 100u8,
                    69u8, 247u8, 3u8, 87u8, 5u8, 57u8, 71u8, 8u8, 63u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::document::DocumentId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " [`DocumentId`] counter per [`AssetId`]."]
            #[cfg(feature = "ink")]
            pub fn asset_documents_id_sequence(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::document::DocumentId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 201u8, 198u8, 40u8, 95u8, 195u8, 158u8, 100u8,
                    69u8, 247u8, 3u8, 87u8, 5u8, 57u8, 71u8, 8u8, 63u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::document::DocumentId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Metatdata values for an asset."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_metadata_values(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataValue>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 12u8, 236u8, 10u8, 112u8, 182u8, 190u8, 51u8,
                    243u8, 171u8, 240u8, 46u8, 214u8, 255u8, 55u8, 188u8, 48u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Metatdata values for an asset."]
            #[cfg(feature = "ink")]
            pub fn asset_metadata_values(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataValue>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 12u8, 236u8, 10u8, 112u8, 182u8, 190u8, 51u8,
                    243u8, 171u8, 240u8, 46u8, 214u8, 255u8, 55u8, 188u8, 48u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Details for an asset's Metadata values."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_metadata_value_details(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 177u8, 107u8, 241u8, 225u8, 188u8, 86u8, 141u8,
                    84u8, 219u8, 116u8, 115u8, 57u8, 230u8, 243u8, 42u8, 93u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Details for an asset's Metadata values."]
            #[cfg(feature = "ink")]
            pub fn asset_metadata_value_details(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 177u8, 107u8, 241u8, 225u8, 188u8, 86u8, 141u8,
                    84u8, 219u8, 116u8, 115u8, 57u8, 230u8, 243u8, 42u8, 93u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Asset Metadata Local Name -> Key."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_metadata_local_name_to_key(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataName,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 132u8, 79u8, 149u8, 0u8, 75u8, 89u8, 31u8,
                    241u8, 75u8, 208u8, 41u8, 159u8, 32u8, 36u8, 73u8, 8u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Asset Metadata Local Name -> Key."]
            #[cfg(feature = "ink")]
            pub fn asset_metadata_local_name_to_key(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataName,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 132u8, 79u8, 149u8, 0u8, 75u8, 89u8, 31u8,
                    241u8, 75u8, 208u8, 41u8, 159u8, 32u8, 36u8, 73u8, 8u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Asset Metadata Global Name -> Key."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_metadata_global_name_to_key(
                &self,
                key_0: types::polymesh_primitives::asset_metadata::AssetMetadataName,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 27u8, 55u8, 255u8, 139u8, 76u8, 15u8, 234u8,
                    246u8, 25u8, 194u8, 110u8, 238u8, 121u8, 209u8, 31u8, 28u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Asset Metadata Global Name -> Key."]
            #[cfg(feature = "ink")]
            pub fn asset_metadata_global_name_to_key(
                &self,
                key_0: types::polymesh_primitives::asset_metadata::AssetMetadataName,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 27u8, 55u8, 255u8, 139u8, 76u8, 15u8, 234u8,
                    246u8, 25u8, 194u8, 110u8, 238u8, 121u8, 209u8, 31u8, 28u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Asset Metadata Local Key -> Name."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_metadata_local_key_to_name(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 15u8, 104u8, 156u8, 10u8, 116u8, 95u8, 149u8,
                    200u8, 0u8, 202u8, 149u8, 7u8, 13u8, 176u8, 112u8, 120u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Asset Metadata Local Key -> Name."]
            #[cfg(feature = "ink")]
            pub fn asset_metadata_local_key_to_name(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 15u8, 104u8, 156u8, 10u8, 116u8, 95u8, 149u8,
                    200u8, 0u8, 202u8, 149u8, 7u8, 13u8, 176u8, 112u8, 120u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Asset Metadata Global Key -> Name."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_metadata_global_key_to_name(
                &self,
                key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 34u8, 54u8, 201u8, 61u8, 167u8, 233u8, 191u8,
                    146u8, 116u8, 241u8, 41u8, 22u8, 57u8, 221u8, 39u8, 238u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Asset Metadata Global Key -> Name."]
            #[cfg(feature = "ink")]
            pub fn asset_metadata_global_key_to_name(
                &self,
                key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataName>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 34u8, 54u8, 201u8, 61u8, 167u8, 233u8, 191u8,
                    146u8, 116u8, 241u8, 41u8, 22u8, 57u8, 221u8, 39u8, 238u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Asset Metadata Local Key specs."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_metadata_local_specs(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 142u8, 233u8, 192u8, 135u8, 176u8, 130u8,
                    140u8, 179u8, 147u8, 154u8, 225u8, 87u8, 146u8, 146u8, 58u8, 218u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Asset Metadata Local Key specs."]
            #[cfg(feature = "ink")]
            pub fn asset_metadata_local_specs(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 142u8, 233u8, 192u8, 135u8, 176u8, 130u8,
                    140u8, 179u8, 147u8, 154u8, 225u8, 87u8, 146u8, 146u8, 58u8, 218u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Asset Metadata Global Key specs."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_metadata_global_specs(
                &self,
                key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 68u8, 154u8, 137u8, 212u8, 2u8, 194u8, 202u8,
                    170u8, 149u8, 44u8, 16u8, 103u8, 57u8, 78u8, 188u8, 125u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Asset Metadata Global Key specs."]
            #[cfg(feature = "ink")]
            pub fn asset_metadata_global_specs(
                &self,
                key_0: types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataSpec>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 68u8, 154u8, 137u8, 212u8, 2u8, 194u8, 202u8,
                    170u8, 149u8, 44u8, 16u8, 103u8, 57u8, 78u8, 188u8, 125u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " A list of assets that exempt all users from affirming its receivement."]
            #[cfg(not(feature = "ink"))]
            pub async fn assets_exempt_from_affirmation(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 129u8, 27u8, 14u8, 202u8, 198u8, 201u8, 246u8,
                    155u8, 120u8, 161u8, 116u8, 181u8, 202u8, 14u8, 1u8, 151u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " A list of assets that exempt all users from affirming its receivement."]
            #[cfg(feature = "ink")]
            pub fn assets_exempt_from_affirmation(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 129u8, 27u8, 14u8, 202u8, 198u8, 201u8, 246u8,
                    155u8, 120u8, 161u8, 116u8, 181u8, 202u8, 14u8, 1u8, 151u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All assets that don't need an affirmation to be received by an identity."]
            #[cfg(not(feature = "ink"))]
            pub async fn pre_approved_asset(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 237u8, 164u8, 217u8, 22u8, 24u8, 141u8, 131u8,
                    204u8, 239u8, 78u8, 76u8, 53u8, 134u8, 236u8, 32u8, 160u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All assets that don't need an affirmation to be received by an identity."]
            #[cfg(feature = "ink")]
            pub fn pre_approved_asset(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 237u8, 164u8, 217u8, 22u8, 24u8, 141u8, 131u8,
                    204u8, 239u8, 78u8, 76u8, 53u8, 134u8, 236u8, 32u8, 160u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The list of mandatory mediators for every ticker."]
            #[cfg(not(feature = "ink"))]
            pub async fn mandatory_mediators(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 24u8, 32u8, 69u8, 175u8, 150u8, 69u8, 91u8,
                    164u8, 42u8, 209u8, 203u8, 52u8, 223u8, 58u8, 185u8, 222u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The list of mandatory mediators for every ticker."]
            #[cfg(feature = "ink")]
            pub fn mandatory_mediators(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 24u8, 32u8, 69u8, 175u8, 150u8, 69u8, 91u8,
                    164u8, 42u8, 209u8, 203u8, 52u8, 223u8, 58u8, 185u8, 222u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The last [`AssetMetadataLocalKey`] used for [`AssetId`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_asset_metadata_local_key(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 172u8, 170u8, 216u8, 160u8, 251u8, 117u8, 82u8,
                    193u8, 254u8, 194u8, 88u8, 218u8, 2u8, 198u8, 198u8, 134u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The last [`AssetMetadataLocalKey`] used for [`AssetId`]."]
            #[cfg(feature = "ink")]
            pub fn current_asset_metadata_local_key(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 172u8, 170u8, 216u8, 160u8, 251u8, 117u8, 82u8,
                    193u8, 254u8, 194u8, 88u8, 218u8, 2u8, 198u8, 198u8, 134u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The last [`AssetMetadataGlobalKey`] used for a global key."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_asset_metadata_global_key(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 238u8, 45u8, 135u8, 59u8, 233u8, 209u8, 66u8,
                    45u8, 163u8, 101u8, 125u8, 201u8, 185u8, 172u8, 154u8, 43u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The last [`AssetMetadataGlobalKey`] used for a global key."]
            #[cfg(feature = "ink")]
            pub fn current_asset_metadata_global_key(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 238u8, 45u8, 135u8, 59u8, 233u8, 209u8, 66u8,
                    45u8, 163u8, 101u8, 125u8, 201u8, 185u8, 172u8, 154u8, 43u8,
                ])?;
                Ok(value)
            }
            #[doc = " All tickers owned by a user."]
            #[cfg(not(feature = "ink"))]
            pub async fn tickers_owned_by_user(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: types::polymesh_primitives::ticker::Ticker,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 99u8, 17u8, 132u8, 70u8, 52u8, 22u8, 240u8,
                    117u8, 69u8, 175u8, 36u8, 91u8, 192u8, 206u8, 64u8, 180u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All tickers owned by a user."]
            #[cfg(feature = "ink")]
            pub fn tickers_owned_by_user(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: types::polymesh_primitives::ticker::Ticker,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 99u8, 17u8, 132u8, 70u8, 52u8, 22u8, 240u8,
                    117u8, 69u8, 175u8, 36u8, 91u8, 192u8, 206u8, 64u8, 180u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All assets owned by a user."]
            #[cfg(not(feature = "ink"))]
            pub async fn security_tokens_owned_by_user(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 151u8, 255u8, 204u8, 37u8, 249u8, 197u8, 202u8,
                    172u8, 255u8, 183u8, 167u8, 221u8, 109u8, 3u8, 85u8, 163u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All assets owned by a user."]
            #[cfg(feature = "ink")]
            pub fn security_tokens_owned_by_user(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 151u8, 255u8, 204u8, 37u8, 249u8, 197u8, 202u8,
                    172u8, 255u8, 183u8, 167u8, 221u8, 109u8, 3u8, 85u8, 163u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Maps all [`AssetId`] that are mapped to a [`Ticker`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_id_ticker(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::ticker::Ticker>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 113u8, 36u8, 180u8, 254u8, 209u8, 33u8, 154u8,
                    66u8, 19u8, 18u8, 173u8, 27u8, 149u8, 213u8, 68u8, 49u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Maps all [`AssetId`] that are mapped to a [`Ticker`]."]
            #[cfg(feature = "ink")]
            pub fn asset_id_ticker(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::ticker::Ticker>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 113u8, 36u8, 180u8, 254u8, 209u8, 33u8, 154u8,
                    66u8, 19u8, 18u8, 173u8, 27u8, 149u8, 213u8, 68u8, 49u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Maps all [`Ticker`] that are linked to an [`AssetId`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn ticker_asset_id(
                &self,
                key_0: types::polymesh_primitives::ticker::Ticker,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::AssetId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 171u8, 113u8, 226u8, 122u8, 108u8, 135u8,
                    182u8, 231u8, 40u8, 21u8, 178u8, 73u8, 152u8, 31u8, 27u8, 107u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Maps all [`Ticker`] that are linked to an [`AssetId`]."]
            #[cfg(feature = "ink")]
            pub fn ticker_asset_id(
                &self,
                key_0: types::polymesh_primitives::ticker::Ticker,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::AssetId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 171u8, 113u8, 226u8, 122u8, 108u8, 135u8,
                    182u8, 231u8, 40u8, 21u8, 178u8, 73u8, 152u8, 31u8, 27u8, 107u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " A per account nonce that is used for generating an [`AssetId`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_nonce(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 4u8, 19u8, 69u8, 160u8, 99u8, 153u8, 130u8,
                    144u8, 101u8, 251u8, 168u8, 63u8, 80u8, 219u8, 22u8, 96u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " A per account nonce that is used for generating an [`AssetId`]."]
            #[cfg(feature = "ink")]
            pub fn asset_nonce(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 4u8, 19u8, 69u8, 160u8, 99u8, 153u8, 130u8,
                    144u8, 101u8, 251u8, 168u8, 63u8, 80u8, 219u8, 22u8, 96u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_asset::Version> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_asset::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_asset::Version> {
                let value = self.api.read_storage(::alloc::vec![
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_asset::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct AssetPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> AssetPagedQueryApi<'api> {
            #[doc = " Map each [`Ticker`] to its registration details ([`TickerRegistration`])."]
            pub fn unique_ticker_registration(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::ticker::Ticker,
                types::pallet_asset::types::TickerRegistration<u64>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 121u8, 181u8, 109u8, 199u8, 4u8, 80u8, 93u8,
                    65u8, 21u8, 24u8, 9u8, 66u8, 56u8, 123u8, 250u8, 186u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Maps each [`AssetId`] to its underling [`AssetDetails`]."]
            pub fn assets(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::pallet_asset::types::AssetDetails,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 104u8, 42u8, 89u8, 213u8, 26u8, 185u8, 228u8,
                    138u8, 140u8, 140u8, 196u8, 24u8, 255u8, 151u8, 8u8, 210u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Maps each [`AssetId`] to its underling [`AssetName`]."]
            pub fn asset_names(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::asset::AssetName,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 123u8, 195u8, 250u8, 203u8, 235u8, 133u8, 90u8,
                    23u8, 143u8, 10u8, 8u8, 53u8, 96u8, 109u8, 5u8, 206u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Tracks the total [`Balance`] for each [`AssetId`] per [`IdentityId`]."]
            pub fn balance_of(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, u128>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 106u8, 75u8, 187u8, 251u8, 206u8, 1u8, 124u8,
                    102u8, 14u8, 227u8, 176u8, 68u8, 23u8, 115u8, 19u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " Maps each [`AssetId`] to its asset identifiers ([`AssetIdentifier`])."]
            pub fn asset_identifiers(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                ::alloc::vec::Vec<types::polymesh_primitives::asset_identifier::AssetIdentifier>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 178u8, 193u8, 1u8, 161u8, 14u8, 189u8, 176u8,
                    94u8, 104u8, 54u8, 170u8, 144u8, 16u8, 162u8, 98u8, 190u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Maps custom asset type ids to the registered string contents."]
            pub fn custom_types(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset::CustomAssetTypeId,
                ::alloc::vec::Vec<u8>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 214u8, 35u8, 90u8, 254u8, 57u8, 243u8, 210u8,
                    34u8, 193u8, 0u8, 96u8, 131u8, 116u8, 109u8, 49u8, 166u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Inverse map of `CustomTypes`, from registered string contents to custom asset type ids."]
            pub fn custom_types_inverse(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::alloc::vec::Vec<u8>,
                types::polymesh_primitives::asset::CustomAssetTypeId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 2u8, 147u8, 168u8, 237u8, 90u8, 35u8, 218u8,
                    237u8, 169u8, 231u8, 223u8, 32u8, 46u8, 15u8, 228u8, 85u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Maps each [`AssetId`] to the name of its founding round ([`FundingRoundName`])."]
            pub fn funding_round(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::asset::FundingRoundName,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 93u8, 34u8, 9u8, 253u8, 168u8, 224u8, 203u8,
                    196u8, 69u8, 133u8, 25u8, 204u8, 124u8, 207u8, 104u8, 5u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The total [`Balance`] of tokens issued in all recorded funding rounds ([`FundingRoundName`])."]
            pub fn issued_in_funding_round(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::asset::FundingRoundName,
                ),
                u128,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 215u8, 137u8, 60u8, 134u8, 127u8, 54u8, 56u8,
                    208u8, 215u8, 148u8, 185u8, 185u8, 12u8, 48u8, 135u8, 44u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Returns `true` if transfers for the asset are frozen. Otherwise, returns `false`."]
            pub fn frozen(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 113u8, 75u8, 228u8, 71u8, 135u8, 205u8, 51u8,
                    93u8, 238u8, 240u8, 115u8, 32u8, 236u8, 125u8, 7u8, 114u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " All [`Document`] attached to an asset."]
            pub fn asset_documents(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::document::DocumentId,
                types::polymesh_primitives::document::Document,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 166u8, 167u8, 74u8, 143u8, 116u8, 237u8, 66u8,
                    137u8, 149u8, 40u8, 102u8, 20u8, 236u8, 96u8, 52u8, 9u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " [`DocumentId`] counter per [`AssetId`]."]
            pub fn asset_documents_id_sequence(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::document::DocumentId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 201u8, 198u8, 40u8, 95u8, 195u8, 158u8, 100u8,
                    69u8, 247u8, 3u8, 87u8, 5u8, 57u8, 71u8, 8u8, 63u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Metatdata values for an asset."]
            pub fn asset_metadata_values(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                types::polymesh_primitives::asset_metadata::AssetMetadataValue,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 12u8, 236u8, 10u8, 112u8, 182u8, 190u8, 51u8,
                    243u8, 171u8, 240u8, 46u8, 214u8, 255u8, 55u8, 188u8, 48u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Details for an asset's Metadata values."]
            pub fn asset_metadata_value_details(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                types::polymesh_primitives::asset_metadata::AssetMetadataValueDetail<u64>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 177u8, 107u8, 241u8, 225u8, 188u8, 86u8, 141u8,
                    84u8, 219u8, 116u8, 115u8, 57u8, 230u8, 243u8, 42u8, 93u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Asset Metadata Local Name -> Key."]
            pub fn asset_metadata_local_name_to_key(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset_metadata::AssetMetadataName,
                types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 132u8, 79u8, 149u8, 0u8, 75u8, 89u8, 31u8,
                    241u8, 75u8, 208u8, 41u8, 159u8, 32u8, 36u8, 73u8, 8u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Asset Metadata Global Name -> Key."]
            pub fn asset_metadata_global_name_to_key(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset_metadata::AssetMetadataName,
                types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 27u8, 55u8, 255u8, 139u8, 76u8, 15u8, 234u8,
                    246u8, 25u8, 194u8, 110u8, 238u8, 121u8, 209u8, 31u8, 28u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Asset Metadata Local Key -> Name."]
            pub fn asset_metadata_local_key_to_name(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
                types::polymesh_primitives::asset_metadata::AssetMetadataName,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 15u8, 104u8, 156u8, 10u8, 116u8, 95u8, 149u8,
                    200u8, 0u8, 202u8, 149u8, 7u8, 13u8, 176u8, 112u8, 120u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Asset Metadata Global Key -> Name."]
            pub fn asset_metadata_global_key_to_name(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
                types::polymesh_primitives::asset_metadata::AssetMetadataName,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 34u8, 54u8, 201u8, 61u8, 167u8, 233u8, 191u8,
                    146u8, 116u8, 241u8, 41u8, 22u8, 57u8, 221u8, 39u8, 238u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Asset Metadata Local Key specs."]
            pub fn asset_metadata_local_specs(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
                types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 142u8, 233u8, 192u8, 135u8, 176u8, 130u8,
                    140u8, 179u8, 147u8, 154u8, 225u8, 87u8, 146u8, 146u8, 58u8, 218u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Asset Metadata Global Key specs."]
            pub fn asset_metadata_global_specs(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset_metadata::AssetMetadataGlobalKey,
                types::polymesh_primitives::asset_metadata::AssetMetadataSpec,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 68u8, 154u8, 137u8, 212u8, 2u8, 194u8, 202u8,
                    170u8, 149u8, 44u8, 16u8, 103u8, 57u8, 78u8, 188u8, 125u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " A list of assets that exempt all users from affirming its receivement."]
            pub fn assets_exempt_from_affirmation(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 129u8, 27u8, 14u8, 202u8, 198u8, 201u8, 246u8,
                    155u8, 120u8, 161u8, 116u8, 181u8, 202u8, 14u8, 1u8, 151u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " All assets that don't need an affirmation to be received by an identity."]
            pub fn pre_approved_asset(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 237u8, 164u8, 217u8, 22u8, 24u8, 141u8, 131u8,
                    204u8, 239u8, 78u8, 76u8, 53u8, 134u8, 236u8, 32u8, 160u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The list of mandatory mediators for every ticker."]
            pub fn mandatory_mediators(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 24u8, 32u8, 69u8, 175u8, 150u8, 69u8, 91u8,
                    164u8, 42u8, 209u8, 203u8, 52u8, 223u8, 58u8, 185u8, 222u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The last [`AssetMetadataLocalKey`] used for [`AssetId`]."]
            pub fn current_asset_metadata_local_key(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::asset_metadata::AssetMetadataLocalKey,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 172u8, 170u8, 216u8, 160u8, 251u8, 117u8, 82u8,
                    193u8, 254u8, 194u8, 88u8, 218u8, 2u8, 198u8, 198u8, 134u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " All tickers owned by a user."]
            pub fn tickers_owned_by_user(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<types::polymesh_primitives::ticker::Ticker, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 99u8, 17u8, 132u8, 70u8, 52u8, 22u8, 240u8,
                    117u8, 69u8, 175u8, 36u8, 91u8, 192u8, 206u8, 64u8, 180u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " All assets owned by a user."]
            pub fn security_tokens_owned_by_user(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 151u8, 255u8, 204u8, 37u8, 249u8, 197u8, 202u8,
                    172u8, 255u8, 183u8, 167u8, 221u8, 109u8, 3u8, 85u8, 163u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Maps all [`AssetId`] that are mapped to a [`Ticker`]."]
            pub fn asset_id_ticker(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::ticker::Ticker,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 113u8, 36u8, 180u8, 254u8, 209u8, 33u8, 154u8,
                    66u8, 19u8, 18u8, 173u8, 27u8, 149u8, 213u8, 68u8, 49u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Maps all [`Ticker`] that are linked to an [`AssetId`]."]
            pub fn ticker_asset_id(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::ticker::Ticker,
                ::polymesh_api_client::AssetId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 171u8, 113u8, 226u8, 122u8, 108u8, 135u8,
                    182u8, 231u8, 40u8, 21u8, 178u8, 73u8, 152u8, 31u8, 27u8, 107u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " A per account nonce that is used for generating an [`AssetId`]."]
            pub fn asset_nonce(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    211u8, 67u8, 113u8, 161u8, 147u8, 167u8, 81u8, 238u8, 165u8, 136u8, 62u8,
                    149u8, 83u8, 69u8, 123u8, 46u8, 4u8, 19u8, 69u8, 160u8, 99u8, 153u8, 130u8,
                    144u8, 101u8, 251u8, 168u8, 63u8, 80u8, 219u8, 22u8, 96u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
        }
    }
    pub mod capital_distribution {
        use super::*;
        #[derive(Clone)]
        pub struct CapitalDistributionCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> CapitalDistributionCallApi<'api> {
            #[doc = "Start and attach a capital distribution, to the CA identified by `ca_id`,"]
            #[doc = "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID."]
            #[doc = ""]
            #[doc = "The distribution will commence at `payment_at` and expire at `expires_at`,"]
            #[doc = "if provided, or if `None`, then there's no expiry."]
            #[doc = ""]
            #[doc = "The funds will be locked in `portfolio` from when `distribute` is called."]
            #[doc = "When there's no expiry, some funds may be locked indefinitely in `portfolio`,"]
            #[doc = "due to claimants not withdrawing or no benefits being pushed to them."]
            #[doc = "For indivisible currencies, unlocked amounts, of less than one whole unit,"]
            #[doc = "will not be transferable from `portfolio`."]
            #[doc = "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units,"]
            #[doc = "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`,"]
            #[doc = "which is now transferrable."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
            #[doc = "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from."]
            #[doc = "- `currency` to withdraw and distribute from the `portfolio`."]
            #[doc = "- `per_share` amount of `currency` to withdraw and distribute."]
            #[doc = "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token."]
            #[doc = "- `amount` of `currency` to withdraw and distribute at most."]
            #[doc = "- `payment_at` specifies when benefits may first be pushed or claimed."]
            #[doc = "- `expires_at` specifies, if provided, when remaining benefits are forfeit"]
            #[doc = "   and may be reclaimed by `origin`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`."]
            #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
            #[doc = "- `NoRecordDate` if CA has no record date."]
            #[doc = "- `RecordDateAfterStart` if CA's record date > payment_at."]
            #[doc = "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`."]
            #[doc = "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`."]
            #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
            #[doc = "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit"]
            #[doc = "- `DistributionAmountIsZero` if the `amount` is zero."]
            #[doc = "- `DistributionPerShareIsZero` if the `per_share` is zero."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn distribute(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
                currency: ::polymesh_api_client::AssetId,
                per_share: u128,
                amount: u128,
                payment_at: u64,
                expires_at: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CapitalDistribution (types :: pallet_corporate_actions :: distribution :: pallet :: CapitalDistributionCall :: distribute { ca_id , portfolio , currency , per_share , amount , payment_at , expires_at , }))
            }
            #[doc = "Start and attach a capital distribution, to the CA identified by `ca_id`,"]
            #[doc = "with `amount` funds in `currency` withdrawn from `portfolio` belonging to `origin`'s DID."]
            #[doc = ""]
            #[doc = "The distribution will commence at `payment_at` and expire at `expires_at`,"]
            #[doc = "if provided, or if `None`, then there's no expiry."]
            #[doc = ""]
            #[doc = "The funds will be locked in `portfolio` from when `distribute` is called."]
            #[doc = "When there's no expiry, some funds may be locked indefinitely in `portfolio`,"]
            #[doc = "due to claimants not withdrawing or no benefits being pushed to them."]
            #[doc = "For indivisible currencies, unlocked amounts, of less than one whole unit,"]
            #[doc = "will not be transferable from `portfolio`."]
            #[doc = "However, if we imagine that users `Alice` and `Bob` both are entitled to 1.5 units,"]
            #[doc = "and only receive `1` units each, then `0.5 + 0.5 = 1` units are left in `portfolio`,"]
            #[doc = "which is now transferrable."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
            #[doc = "- `portfolio` specifies the portfolio number of the agent to distribute `amount` from."]
            #[doc = "- `currency` to withdraw and distribute from the `portfolio`."]
            #[doc = "- `per_share` amount of `currency` to withdraw and distribute."]
            #[doc = "   Specified as a per-million, i.e. `1 / 10^6`th of one `currency` token."]
            #[doc = "- `amount` of `currency` to withdraw and distribute at most."]
            #[doc = "- `payment_at` specifies when benefits may first be pushed or claimed."]
            #[doc = "- `expires_at` specifies, if provided, when remaining benefits are forfeit"]
            #[doc = "   and may be reclaimed by `origin`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `ExpiryBeforePayment` if `expires_at.unwrap() <= payment_at`."]
            #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
            #[doc = "- `NoRecordDate` if CA has no record date."]
            #[doc = "- `RecordDateAfterStart` if CA's record date > payment_at."]
            #[doc = "- `UnauthorizedCustodian` if the caller is not the custodian of `portfolio`."]
            #[doc = "- `InsufficientPortfolioBalance` if `portfolio` has less than `amount` of `currency`."]
            #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
            #[doc = "- `CANotBenefit` if the CA is not of kind PredictableBenefit/UnpredictableBenefit"]
            #[doc = "- `DistributionAmountIsZero` if the `amount` is zero."]
            #[doc = "- `DistributionPerShareIsZero` if the `per_share` is zero."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn distribute(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
                currency: ::polymesh_api_client::AssetId,
                per_share: u128,
                amount: u128,
                payment_at: u64,
                expires_at: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![27u8, 0u8];
                ca_id.encode_to(&mut buf);
                portfolio.encode_to(&mut buf);
                currency.encode_to(&mut buf);
                per_share.encode_to(&mut buf);
                amount.encode_to(&mut buf);
                payment_at.encode_to(&mut buf);
                expires_at.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Claim a benefit of the capital distribution attached to `ca_id`."]
            #[doc = ""]
            #[doc = "Taxes are withheld as specified by the CA."]
            #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
            #[doc = ""]
            #[doc = "All benefits are rounded by truncation, down to first integer below."]
            #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
            #[doc = "they are rounded down to a whole unit."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be a holder of the asset and eligible for the distribution."]
            #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit."]
            #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
            #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
            #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
            #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
            #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
            #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
            #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
            #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
            #[cfg(not(feature = "ink"))]
            pub fn claim(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CapitalDistribution (types :: pallet_corporate_actions :: distribution :: pallet :: CapitalDistributionCall :: claim { ca_id , }))
            }
            #[doc = "Claim a benefit of the capital distribution attached to `ca_id`."]
            #[doc = ""]
            #[doc = "Taxes are withheld as specified by the CA."]
            #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
            #[doc = ""]
            #[doc = "All benefits are rounded by truncation, down to first integer below."]
            #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
            #[doc = "they are rounded down to a whole unit."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be a holder of the asset and eligible for the distribution."]
            #[doc = "- `ca_id` identifies the CA to start a capital distribution for."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `HolderAlreadyPaid` if `origin`'s DID has already received its benefit."]
            #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
            #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
            #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
            #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
            #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
            #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
            #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
            #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
            #[cfg(feature = "ink")]
            pub fn claim(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![27u8, 1u8];
                ca_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Push benefit of an ongoing distribution to the given `holder`."]
            #[doc = ""]
            #[doc = "Taxes are withheld as specified by the CA."]
            #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
            #[doc = ""]
            #[doc = "All benefits are rounded by truncation, down to first integer below."]
            #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
            #[doc = "they are rounded down to a whole unit."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the CA with a capital distributions to push benefits for."]
            #[doc = "- `holder` to push benefits to."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
            #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
            #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
            #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
            #[doc = "- `NotTargetedByCA` if the CA does not target `holder`."]
            #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
            #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
            #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
            #[cfg(not(feature = "ink"))]
            pub fn push_benefit(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                holder: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CapitalDistribution (types :: pallet_corporate_actions :: distribution :: pallet :: CapitalDistributionCall :: push_benefit { ca_id , holder , }))
            }
            #[doc = "Push benefit of an ongoing distribution to the given `holder`."]
            #[doc = ""]
            #[doc = "Taxes are withheld as specified by the CA."]
            #[doc = "Post-tax earnings are then transferred to the default portfolio of the `origin`'s DID."]
            #[doc = ""]
            #[doc = "All benefits are rounded by truncation, down to first integer below."]
            #[doc = "Moreover, before post-tax earnings, in indivisible currencies are transferred,"]
            #[doc = "they are rounded down to a whole unit."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the CA with a capital distributions to push benefits for."]
            #[doc = "- `holder` to push benefits to."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
            #[doc = "- `CannotClaimBeforeStart` if `now < payment_at`."]
            #[doc = "- `CannotClaimAfterExpiry` if `now > expiry_at.unwrap()`."]
            #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
            #[doc = "- `NotTargetedByCA` if the CA does not target `holder`."]
            #[doc = "- `BalanceAmountProductOverflowed` if `ba = balance * amount` would overflow."]
            #[doc = "- `BalanceAmountProductSupplyDivisionFailed` if `ba * supply` would overflow."]
            #[doc = "- Other errors can occur if the compliance manager rejects the transfer."]
            #[cfg(feature = "ink")]
            pub fn push_benefit(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                holder: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![27u8, 2u8];
                ca_id.encode_to(&mut buf);
                holder.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Assuming a distribution has expired,"]
            #[doc = "unlock the remaining amount in the distributor portfolio."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be the creator of the capital distribution tied to `ca_id`."]
            #[doc = "- `ca_id` identifies the CA with a capital distribution to reclaim for."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
            #[doc = "- `AlreadyReclaimed` if this function has already been called successfully."]
            #[doc = "- `NotExpired` if `now < expiry`."]
            #[cfg(not(feature = "ink"))]
            pub fn reclaim(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CapitalDistribution (types :: pallet_corporate_actions :: distribution :: pallet :: CapitalDistributionCall :: reclaim { ca_id , }))
            }
            #[doc = "Assuming a distribution has expired,"]
            #[doc = "unlock the remaining amount in the distributor portfolio."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be the creator of the capital distribution tied to `ca_id`."]
            #[doc = "- `ca_id` identifies the CA with a capital distribution to reclaim for."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
            #[doc = "- `AlreadyReclaimed` if this function has already been called successfully."]
            #[doc = "- `NotExpired` if `now < expiry`."]
            #[cfg(feature = "ink")]
            pub fn reclaim(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![27u8, 3u8];
                ca_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes a distribution that hasn't started yet,"]
            #[doc = "unlocking the full amount in the distributor portfolio."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
            #[doc = "- `DistributionStarted` if `payment_at <= now`."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_distribution(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CapitalDistribution (types :: pallet_corporate_actions :: distribution :: pallet :: CapitalDistributionCall :: remove_distribution { ca_id , }))
            }
            #[doc = "Removes a distribution that hasn't started yet,"]
            #[doc = "unlocking the full amount in the distributor portfolio."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the CA with a not-yet-started capital distribution to remove."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchDistribution` if there's no capital distribution for `ca_id`."]
            #[doc = "- `DistributionStarted` if `payment_at <= now`."]
            #[cfg(feature = "ink")]
            pub fn remove_distribution(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![27u8, 4u8];
                ca_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for CapitalDistributionCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct CapitalDistributionQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> CapitalDistributionQueryApi<'api> {
            #[doc = " All capital distributions, tied to their respective corporate actions (CAs)."]
            #[doc = ""]
            #[doc = " (CAId) => Distribution"]
            #[cfg(not(feature = "ink"))]
            pub async fn distributions(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_corporate_actions::distribution::Distribution>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8,
                    52u8, 39u8, 59u8, 17u8, 106u8, 209u8, 103u8, 105u8, 114u8, 107u8, 158u8, 5u8,
                    125u8, 150u8, 235u8, 86u8, 125u8, 11u8, 175u8, 145u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " All capital distributions, tied to their respective corporate actions (CAs)."]
            #[doc = ""]
            #[doc = " (CAId) => Distribution"]
            #[cfg(feature = "ink")]
            pub fn distributions(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_corporate_actions::distribution::Distribution>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8,
                    52u8, 39u8, 59u8, 17u8, 106u8, 209u8, 103u8, 105u8, 114u8, 107u8, 158u8, 5u8,
                    125u8, 150u8, 235u8, 86u8, 125u8, 11u8, 175u8, 145u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Has an asset holder been paid yet?"]
            #[doc = ""]
            #[doc = " (CAId, DID) -> Was DID paid in the CAId?"]
            #[cfg(not(feature = "ink"))]
            pub async fn holder_paid(
                &self,
                key_0: (
                    types::pallet_corporate_actions::CAId,
                    ::polymesh_api_client::IdentityId,
                ),
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8,
                    52u8, 39u8, 59u8, 17u8, 55u8, 215u8, 43u8, 172u8, 158u8, 205u8, 29u8, 130u8,
                    146u8, 125u8, 52u8, 215u8, 183u8, 138u8, 60u8, 26u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Has an asset holder been paid yet?"]
            #[doc = ""]
            #[doc = " (CAId, DID) -> Was DID paid in the CAId?"]
            #[cfg(feature = "ink")]
            pub fn holder_paid(
                &self,
                key_0: (
                    types::pallet_corporate_actions::CAId,
                    ::polymesh_api_client::IdentityId,
                ),
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8,
                    52u8, 39u8, 59u8, 17u8, 55u8, 215u8, 43u8, 172u8, 158u8, 205u8, 29u8, 130u8,
                    146u8, 125u8, 52u8, 215u8, 183u8, 138u8, 60u8, 26u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::pallet_corporate_actions::distribution::Version,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8,
                    52u8, 39u8, 59u8, 17u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_corporate_actions::distribution::Version>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                types::pallet_corporate_actions::distribution::Version,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8,
                    52u8, 39u8, 59u8, 17u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_corporate_actions::distribution::Version>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct CapitalDistributionPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> CapitalDistributionPagedQueryApi<'api> {
            #[doc = " All capital distributions, tied to their respective corporate actions (CAs)."]
            #[doc = ""]
            #[doc = " (CAId) => Distribution"]
            pub fn distributions(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_corporate_actions::CAId,
                types::pallet_corporate_actions::distribution::Distribution,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8,
                    52u8, 39u8, 59u8, 17u8, 106u8, 209u8, 103u8, 105u8, 114u8, 107u8, 158u8, 5u8,
                    125u8, 150u8, 235u8, 86u8, 125u8, 11u8, 175u8, 145u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Has an asset holder been paid yet?"]
            #[doc = ""]
            #[doc = " (CAId, DID) -> Was DID paid in the CAId?"]
            pub fn holder_paid(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                (
                    types::pallet_corporate_actions::CAId,
                    ::polymesh_api_client::IdentityId,
                ),
                bool,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    81u8, 154u8, 187u8, 138u8, 109u8, 32u8, 81u8, 139u8, 168u8, 202u8, 75u8, 130u8,
                    52u8, 39u8, 59u8, 17u8, 55u8, 215u8, 43u8, 172u8, 158u8, 205u8, 29u8, 130u8,
                    146u8, 125u8, 52u8, 215u8, 183u8, 138u8, 60u8, 26u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
        }
    }
    pub mod checkpoint {
        use super::*;
        #[derive(Clone)]
        pub struct CheckpointCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> CheckpointCallApi<'api> {
            #[doc = "Creates a single checkpoint at the current time."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "- `asset_id` to create the checkpoint for."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
            #[doc = "- `CounterOverflow` if the total checkpoint counter would overflow."]
            #[cfg(not(feature = "ink"))]
            pub fn create_checkpoint(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
                    types::pallet_asset::checkpoint::pallet::CheckpointCall::create_checkpoint {
                        asset_id,
                    },
                ))
            }
            #[doc = "Creates a single checkpoint at the current time."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "- `asset_id` to create the checkpoint for."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
            #[doc = "- `CounterOverflow` if the total checkpoint counter would overflow."]
            #[cfg(feature = "ink")]
            pub fn create_checkpoint(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![28u8, 0u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Sets the max complexity of a schedule set for an arbitrary asset_id to `max_complexity`."]
            #[doc = "The new maximum is not enforced retroactively,"]
            #[doc = "and only applies once new schedules are made."]
            #[doc = ""]
            #[doc = "Must be called as a PIP (requires \"root\")."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` is the root origin."]
            #[doc = "- `max_complexity` allowed for an arbitrary asset's schedule set."]
            #[cfg(not(feature = "ink"))]
            pub fn set_schedules_max_complexity(
                &self,
                max_complexity: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Checkpoint (types :: pallet_asset :: checkpoint :: pallet :: CheckpointCall :: set_schedules_max_complexity { max_complexity , }))
            }
            #[doc = "Sets the max complexity of a schedule set for an arbitrary asset_id to `max_complexity`."]
            #[doc = "The new maximum is not enforced retroactively,"]
            #[doc = "and only applies once new schedules are made."]
            #[doc = ""]
            #[doc = "Must be called as a PIP (requires \"root\")."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` is the root origin."]
            #[doc = "- `max_complexity` allowed for an arbitrary asset's schedule set."]
            #[cfg(feature = "ink")]
            pub fn set_schedules_max_complexity(
                &self,
                max_complexity: u64,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![28u8, 1u8];
                max_complexity.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Creates a schedule generating checkpoints"]
            #[doc = "in the future at either a fixed time or at intervals."]
            #[doc = ""]
            #[doc = "The schedule starts out with `strong_ref_count(schedule_id) <- 0`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
            #[doc = "- `asset_id` to create the schedule for."]
            #[doc = "- `schedule` that will generate checkpoints."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
            #[doc = "- `InsufficientAccountBalance` if the protocol fee could not be charged."]
            #[doc = "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn create_schedule(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                schedule: polymesh_primitives::checkpoint::ScheduleCheckpoints,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
                    types::pallet_asset::checkpoint::pallet::CheckpointCall::create_schedule {
                        asset_id,
                        schedule,
                    },
                ))
            }
            #[doc = "Creates a schedule generating checkpoints"]
            #[doc = "in the future at either a fixed time or at intervals."]
            #[doc = ""]
            #[doc = "The schedule starts out with `strong_ref_count(schedule_id) <- 0`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
            #[doc = "- `asset_id` to create the schedule for."]
            #[doc = "- `schedule` that will generate checkpoints."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
            #[doc = "- `InsufficientAccountBalance` if the protocol fee could not be charged."]
            #[doc = "- `CounterOverflow` if the schedule ID or total checkpoint counters would overflow."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn create_schedule(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                schedule: polymesh_primitives::checkpoint::ScheduleCheckpoints,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![28u8, 2u8];
                asset_id.encode_to(&mut buf);
                schedule.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the checkpoint schedule of an asset identified by `id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
            #[doc = "- `asset_id` to remove the schedule from."]
            #[doc = "- `id` of the schedule, when it was created by `created_schedule`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
            #[doc = "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `asset_id`."]
            #[doc = "- `ScheduleNotRemovable` if `id` exists but is not removable."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn remove_schedule(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                id: polymesh_primitives::checkpoint::ScheduleId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Checkpoint(
                    types::pallet_asset::checkpoint::pallet::CheckpointCall::remove_schedule {
                        asset_id,
                        id,
                    },
                ))
            }
            #[doc = "Removes the checkpoint schedule of an asset identified by `id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as owner of `asset_id`."]
            #[doc = "- `asset_id` to remove the schedule from."]
            #[doc = "- `id` of the schedule, when it was created by `created_schedule`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if the DID of `origin` isn't a permissioned agent for `asset_id`."]
            #[doc = "- `NoCheckpointSchedule` if `id` does not identify a schedule for this `asset_id`."]
            #[doc = "- `ScheduleNotRemovable` if `id` exists but is not removable."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn remove_schedule(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                id: polymesh_primitives::checkpoint::ScheduleId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![28u8, 3u8];
                asset_id.encode_to(&mut buf);
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for CheckpointCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct CheckpointQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> CheckpointQueryApi<'api> {
            #[doc = " Total supply of the token at the checkpoint."]
            #[doc = ""]
            #[doc = " ([`AssetId`], checkpointId) -> total supply at given checkpoint"]
            #[cfg(not(feature = "ink"))]
            pub async fn total_supply(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset::CheckpointId,
            ) -> ::polymesh_api_client::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 89u8, 148u8, 207u8, 218u8, 20u8, 205u8,
                    103u8, 225u8, 88u8, 102u8, 71u8, 212u8, 0u8, 8u8, 171u8, 170u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Total supply of the token at the checkpoint."]
            #[doc = ""]
            #[doc = " ([`AssetId`], checkpointId) -> total supply at given checkpoint"]
            #[cfg(feature = "ink")]
            pub fn total_supply(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset::CheckpointId,
            ) -> ::polymesh_api_ink::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 89u8, 148u8, 207u8, 218u8, 20u8, 205u8,
                    103u8, 225u8, 88u8, 102u8, 71u8, 212u8, 0u8, 8u8, 171u8, 170u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Balance of a DID at a checkpoint."]
            #[doc = ""]
            #[doc = " ([`AssetId`], did, checkpoint ID) -> Balance of a DID at a checkpoint"]
            #[cfg(not(feature = "ink"))]
            pub async fn balance(
                &self,
                key_0: (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::asset::CheckpointId,
                ),
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 78u8, 168u8, 234u8, 12u8, 1u8, 250u8, 164u8,
                    43u8, 110u8, 179u8, 68u8, 168u8, 92u8, 71u8, 179u8, 135u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Balance of a DID at a checkpoint."]
            #[doc = ""]
            #[doc = " ([`AssetId`], did, checkpoint ID) -> Balance of a DID at a checkpoint"]
            #[cfg(feature = "ink")]
            pub fn balance(
                &self,
                key_0: (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::asset::CheckpointId,
                ),
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 78u8, 168u8, 234u8, 12u8, 1u8, 250u8, 164u8,
                    43u8, 110u8, 179u8, 68u8, 168u8, 92u8, 71u8, 179u8, 135u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Checkpoints ID generator sequence."]
            #[doc = " ID of first checkpoint is 1 instead of 0."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> no. of checkpoints"]
            #[cfg(not(feature = "ink"))]
            pub async fn checkpoint_id_sequence(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::asset::CheckpointId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 125u8, 12u8, 59u8, 36u8, 10u8, 236u8, 235u8,
                    137u8, 107u8, 225u8, 196u8, 253u8, 46u8, 38u8, 239u8, 219u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::asset::CheckpointId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Checkpoints ID generator sequence."]
            #[doc = " ID of first checkpoint is 1 instead of 0."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> no. of checkpoints"]
            #[cfg(feature = "ink")]
            pub fn checkpoint_id_sequence(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::asset::CheckpointId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 125u8, 12u8, 59u8, 36u8, 10u8, 236u8, 235u8,
                    137u8, 107u8, 225u8, 196u8, 253u8, 46u8, 38u8, 239u8, 219u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::asset::CheckpointId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Checkpoints where a DID's balance was updated."]
            #[doc = " ([`AssetId`], did) -> [checkpoint ID where user balance changed]"]
            #[cfg(not(feature = "ink"))]
            pub async fn balance_updates(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 143u8, 217u8, 170u8, 216u8, 91u8, 210u8,
                    121u8, 231u8, 28u8, 142u8, 98u8, 99u8, 214u8, 201u8, 229u8, 250u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Checkpoints where a DID's balance was updated."]
            #[doc = " ([`AssetId`], did) -> [checkpoint ID where user balance changed]"]
            #[cfg(feature = "ink")]
            pub fn balance_updates(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 143u8, 217u8, 170u8, 216u8, 91u8, 210u8,
                    121u8, 231u8, 28u8, 142u8, 98u8, 99u8, 214u8, 201u8, 229u8, 250u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Checkpoint timestamps."]
            #[doc = ""]
            #[doc = " Every schedule-originated checkpoint maps its ID to its due time."]
            #[doc = " Every checkpoint manually created maps its ID to the time of recording."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> (checkpoint ID) -> checkpoint timestamp"]
            #[cfg(not(feature = "ink"))]
            pub async fn timestamps(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset::CheckpointId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 212u8, 135u8, 3u8, 189u8, 214u8, 233u8,
                    162u8, 207u8, 215u8, 14u8, 169u8, 158u8, 121u8, 254u8, 114u8, 232u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Checkpoint timestamps."]
            #[doc = ""]
            #[doc = " Every schedule-originated checkpoint maps its ID to its due time."]
            #[doc = " Every checkpoint manually created maps its ID to the time of recording."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> (checkpoint ID) -> checkpoint timestamp"]
            #[cfg(feature = "ink")]
            pub fn timestamps(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::asset::CheckpointId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 212u8, 135u8, 3u8, 189u8, 214u8, 233u8,
                    162u8, 207u8, 215u8, 14u8, 169u8, 158u8, 121u8, 254u8, 114u8, 232u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The maximum complexity allowed for an asset's schedules."]
            #[cfg(not(feature = "ink"))]
            pub async fn schedules_max_complexity(
                &self,
            ) -> ::polymesh_api_client::error::Result<u64> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 157u8, 164u8, 151u8, 8u8, 64u8, 141u8, 200u8,
                    122u8, 167u8, 39u8, 230u8, 249u8, 114u8, 60u8, 67u8, 180u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The maximum complexity allowed for an asset's schedules."]
            #[cfg(feature = "ink")]
            pub fn schedules_max_complexity(&self) -> ::polymesh_api_ink::error::Result<u64> {
                let value = self.api.read_storage(::alloc::vec![
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 157u8, 164u8, 151u8, 8u8, 64u8, 141u8, 200u8,
                    122u8, 167u8, 39u8, 230u8, 249u8, 114u8, 60u8, 67u8, 180u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Checkpoint schedule ID sequence for assets."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> schedule ID"]
            #[cfg(not(feature = "ink"))]
            pub async fn schedule_id_sequence(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<polymesh_primitives::checkpoint::ScheduleId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 105u8, 127u8, 108u8, 151u8, 163u8, 248u8,
                    224u8, 135u8, 154u8, 147u8, 248u8, 192u8, 179u8, 162u8, 41u8, 13u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <polymesh_primitives::checkpoint::ScheduleId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Checkpoint schedule ID sequence for assets."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> schedule ID"]
            #[cfg(feature = "ink")]
            pub fn schedule_id_sequence(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<polymesh_primitives::checkpoint::ScheduleId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 105u8, 127u8, 108u8, 151u8, 163u8, 248u8,
                    224u8, 135u8, 154u8, 147u8, 248u8, 192u8, 179u8, 162u8, 41u8, 13u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <polymesh_primitives::checkpoint::ScheduleId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Cached next checkpoint for each schedule."]
            #[doc = ""]
            #[doc = " This is used to quickly find the next checkpoint from a asset's schedules."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> next checkpoints"]
            #[cfg(not(feature = "ink"))]
            pub async fn cached_next_checkpoints(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                Option<polymesh_primitives::checkpoint::NextCheckpoints>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 80u8, 107u8, 22u8, 3u8, 194u8, 86u8, 107u8,
                    33u8, 70u8, 40u8, 22u8, 166u8, 84u8, 108u8, 245u8, 73u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Cached next checkpoint for each schedule."]
            #[doc = ""]
            #[doc = " This is used to quickly find the next checkpoint from a asset's schedules."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> next checkpoints"]
            #[cfg(feature = "ink")]
            pub fn cached_next_checkpoints(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<polymesh_primitives::checkpoint::NextCheckpoints>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 80u8, 107u8, 22u8, 3u8, 194u8, 86u8, 107u8,
                    33u8, 70u8, 40u8, 22u8, 166u8, 84u8, 108u8, 245u8, 73u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Scheduled checkpoints."]
            #[doc = ""]
            #[doc = " ([`AssetId`], schedule ID) -> schedule checkpoints"]
            #[cfg(not(feature = "ink"))]
            pub async fn scheduled_checkpoints(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: polymesh_primitives::checkpoint::ScheduleId,
            ) -> ::polymesh_api_client::error::Result<
                Option<polymesh_primitives::checkpoint::ScheduleCheckpoints>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 73u8, 231u8, 184u8, 207u8, 197u8, 218u8,
                    76u8, 26u8, 125u8, 44u8, 6u8, 132u8, 44u8, 4u8, 76u8, 237u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Scheduled checkpoints."]
            #[doc = ""]
            #[doc = " ([`AssetId`], schedule ID) -> schedule checkpoints"]
            #[cfg(feature = "ink")]
            pub fn scheduled_checkpoints(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: polymesh_primitives::checkpoint::ScheduleId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<polymesh_primitives::checkpoint::ScheduleCheckpoints>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 73u8, 231u8, 184u8, 207u8, 197u8, 218u8,
                    76u8, 26u8, 125u8, 44u8, 6u8, 132u8, 44u8, 4u8, 76u8, 237u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " How many \"strong\" references are there to a given `ScheduleId`?"]
            #[doc = ""]
            #[doc = " The presence of a \"strong\" reference, in the sense of `Rc<T>`,"]
            #[doc = " entails that the referenced schedule cannot be removed."]
            #[doc = " Thus, as long as `strong_ref_count(schedule_id) > 0`,"]
            #[doc = " `remove_schedule(schedule_id)` will error."]
            #[doc = ""]
            #[doc = " ([`AssetId`], schedule ID) -> strong ref count"]
            #[cfg(not(feature = "ink"))]
            pub async fn schedule_ref_count(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: polymesh_primitives::checkpoint::ScheduleId,
            ) -> ::polymesh_api_client::error::Result<u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 237u8, 119u8, 84u8, 159u8, 230u8, 166u8,
                    65u8, 61u8, 186u8, 244u8, 172u8, 93u8, 185u8, 128u8, 39u8, 122u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " How many \"strong\" references are there to a given `ScheduleId`?"]
            #[doc = ""]
            #[doc = " The presence of a \"strong\" reference, in the sense of `Rc<T>`,"]
            #[doc = " entails that the referenced schedule cannot be removed."]
            #[doc = " Thus, as long as `strong_ref_count(schedule_id) > 0`,"]
            #[doc = " `remove_schedule(schedule_id)` will error."]
            #[doc = ""]
            #[doc = " ([`AssetId`], schedule ID) -> strong ref count"]
            #[cfg(feature = "ink")]
            pub fn schedule_ref_count(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: polymesh_primitives::checkpoint::ScheduleId,
            ) -> ::polymesh_api_ink::error::Result<u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 237u8, 119u8, 84u8, 159u8, 230u8, 166u8,
                    65u8, 61u8, 186u8, 244u8, 172u8, 93u8, 185u8, 128u8, 39u8, 122u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All the checkpoints a given schedule originated."]
            #[doc = ""]
            #[doc = " ([`AssetId`], schedule ID) -> [checkpoint ID]"]
            #[cfg(not(feature = "ink"))]
            pub async fn schedule_points(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: polymesh_primitives::checkpoint::ScheduleId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 169u8, 253u8, 229u8, 218u8, 162u8, 17u8,
                    213u8, 206u8, 52u8, 53u8, 24u8, 44u8, 3u8, 149u8, 70u8, 134u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " All the checkpoints a given schedule originated."]
            #[doc = ""]
            #[doc = " ([`AssetId`], schedule ID) -> [checkpoint ID]"]
            #[cfg(feature = "ink")]
            pub fn schedule_points(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: polymesh_primitives::checkpoint::ScheduleId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 169u8, 253u8, 229u8, 218u8, 162u8, 17u8,
                    213u8, 206u8, 52u8, 53u8, 24u8, 44u8, 3u8, 149u8, 70u8, 134u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_asset::checkpoint::Version>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_asset::checkpoint::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_asset::checkpoint::Version>
            {
                let value = self.api.read_storage(::alloc::vec![
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_asset::checkpoint::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct CheckpointPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> CheckpointPagedQueryApi<'api> {
            #[doc = " Total supply of the token at the checkpoint."]
            #[doc = ""]
            #[doc = " ([`AssetId`], checkpointId) -> total supply at given checkpoint"]
            pub fn total_supply(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset::CheckpointId,
                u128,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 89u8, 148u8, 207u8, 218u8, 20u8, 205u8,
                    103u8, 225u8, 88u8, 102u8, 71u8, 212u8, 0u8, 8u8, 171u8, 170u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Balance of a DID at a checkpoint."]
            #[doc = ""]
            #[doc = " ([`AssetId`], did, checkpoint ID) -> Balance of a DID at a checkpoint"]
            pub fn balance(
                &self,
                key_0: (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::asset::CheckpointId,
                ),
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, u128>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 78u8, 168u8, 234u8, 12u8, 1u8, 250u8, 164u8,
                    43u8, 110u8, 179u8, 68u8, 168u8, 92u8, 71u8, 179u8, 135u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Checkpoints ID generator sequence."]
            #[doc = " ID of first checkpoint is 1 instead of 0."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> no. of checkpoints"]
            pub fn checkpoint_id_sequence(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::asset::CheckpointId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 125u8, 12u8, 59u8, 36u8, 10u8, 236u8, 235u8,
                    137u8, 107u8, 225u8, 196u8, 253u8, 46u8, 38u8, 239u8, 219u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Checkpoints where a DID's balance was updated."]
            #[doc = " ([`AssetId`], did) -> [checkpoint ID where user balance changed]"]
            pub fn balance_updates(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::IdentityId,
                ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 143u8, 217u8, 170u8, 216u8, 91u8, 210u8,
                    121u8, 231u8, 28u8, 142u8, 98u8, 99u8, 214u8, 201u8, 229u8, 250u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Checkpoint timestamps."]
            #[doc = ""]
            #[doc = " Every schedule-originated checkpoint maps its ID to its due time."]
            #[doc = " Every checkpoint manually created maps its ID to the time of recording."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> (checkpoint ID) -> checkpoint timestamp"]
            pub fn timestamps(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset::CheckpointId,
                u64,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 212u8, 135u8, 3u8, 189u8, 214u8, 233u8,
                    162u8, 207u8, 215u8, 14u8, 169u8, 158u8, 121u8, 254u8, 114u8, 232u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Checkpoint schedule ID sequence for assets."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> schedule ID"]
            pub fn schedule_id_sequence(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                polymesh_primitives::checkpoint::ScheduleId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 105u8, 127u8, 108u8, 151u8, 163u8, 248u8,
                    224u8, 135u8, 154u8, 147u8, 248u8, 192u8, 179u8, 162u8, 41u8, 13u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Cached next checkpoint for each schedule."]
            #[doc = ""]
            #[doc = " This is used to quickly find the next checkpoint from a asset's schedules."]
            #[doc = ""]
            #[doc = " ([`AssetId`]) -> next checkpoints"]
            pub fn cached_next_checkpoints(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                polymesh_primitives::checkpoint::NextCheckpoints,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 80u8, 107u8, 22u8, 3u8, 194u8, 86u8, 107u8,
                    33u8, 70u8, 40u8, 22u8, 166u8, 84u8, 108u8, 245u8, 73u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Scheduled checkpoints."]
            #[doc = ""]
            #[doc = " ([`AssetId`], schedule ID) -> schedule checkpoints"]
            pub fn scheduled_checkpoints(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                polymesh_primitives::checkpoint::ScheduleId,
                polymesh_primitives::checkpoint::ScheduleCheckpoints,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 73u8, 231u8, 184u8, 207u8, 197u8, 218u8,
                    76u8, 26u8, 125u8, 44u8, 6u8, 132u8, 44u8, 4u8, 76u8, 237u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " How many \"strong\" references are there to a given `ScheduleId`?"]
            #[doc = ""]
            #[doc = " The presence of a \"strong\" reference, in the sense of `Rc<T>`,"]
            #[doc = " entails that the referenced schedule cannot be removed."]
            #[doc = " Thus, as long as `strong_ref_count(schedule_id) > 0`,"]
            #[doc = " `remove_schedule(schedule_id)` will error."]
            #[doc = ""]
            #[doc = " ([`AssetId`], schedule ID) -> strong ref count"]
            pub fn schedule_ref_count(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<polymesh_primitives::checkpoint::ScheduleId, u32>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 237u8, 119u8, 84u8, 159u8, 230u8, 166u8,
                    65u8, 61u8, 186u8, 244u8, 172u8, 93u8, 185u8, 128u8, 39u8, 122u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " All the checkpoints a given schedule originated."]
            #[doc = ""]
            #[doc = " ([`AssetId`], schedule ID) -> [checkpoint ID]"]
            pub fn schedule_points(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                polymesh_primitives::checkpoint::ScheduleId,
                ::alloc::vec::Vec<types::polymesh_primitives::asset::CheckpointId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    195u8, 146u8, 155u8, 32u8, 184u8, 204u8, 94u8, 128u8, 197u8, 29u8, 170u8,
                    187u8, 151u8, 103u8, 187u8, 14u8, 169u8, 253u8, 229u8, 218u8, 162u8, 17u8,
                    213u8, 206u8, 52u8, 53u8, 24u8, 44u8, 3u8, 149u8, 70u8, 134u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod compliance_manager {
        use super::*;
        #[derive(Clone)]
        pub struct ComplianceManagerCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> ComplianceManagerCallApi<'api> {
            #[doc = "Adds a compliance requirement to an asset given by `asset_id`."]
            #[doc = "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
            #[doc = "* asset_id - Symbol of the asset"]
            #[doc = "* sender_conditions - Sender transfer conditions."]
            #[doc = "* receiver_conditions - Receiver transfer conditions."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn add_compliance_requirement(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                sender_conditions: ::alloc::vec::Vec<
                    types::polymesh_primitives::condition::Condition,
                >,
                receiver_conditions: ::alloc::vec::Vec<
                    types::polymesh_primitives::condition::Condition,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: pallet :: ComplianceManagerCall :: add_compliance_requirement { asset_id , sender_conditions , receiver_conditions , }))
            }
            #[doc = "Adds a compliance requirement to an asset given by `asset_id`."]
            #[doc = "If there are duplicate ClaimTypes for a particular trusted issuer, duplicates are removed."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
            #[doc = "* asset_id - Symbol of the asset"]
            #[doc = "* sender_conditions - Sender transfer conditions."]
            #[doc = "* receiver_conditions - Receiver transfer conditions."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn add_compliance_requirement(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                sender_conditions: ::alloc::vec::Vec<
                    types::polymesh_primitives::condition::Condition,
                >,
                receiver_conditions: ::alloc::vec::Vec<
                    types::polymesh_primitives::condition::Condition,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![29u8, 0u8];
                asset_id.encode_to(&mut buf);
                sender_conditions.encode_to(&mut buf);
                receiver_conditions.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes a compliance requirement from an asset's compliance."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
            #[doc = "* asset_id - Symbol of the asset"]
            #[doc = "* id - Compliance requirement id which is need to be removed"]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn remove_compliance_requirement(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                id: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: pallet :: ComplianceManagerCall :: remove_compliance_requirement { asset_id , id , }))
            }
            #[doc = "Removes a compliance requirement from an asset's compliance."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
            #[doc = "* asset_id - Symbol of the asset"]
            #[doc = "* id - Compliance requirement id which is need to be removed"]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn remove_compliance_requirement(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                id: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![29u8, 1u8];
                asset_id.encode_to(&mut buf);
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Replaces an asset's compliance with a new compliance."]
            #[doc = ""]
            #[doc = "Compliance requirements will be sorted (ascending by id) before"]
            #[doc = "replacing the current requirements."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `asset_id` - the asset asset_id,"]
            #[doc = "* `asset_compliance - the new asset compliance."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `Unauthorized` if `origin` is not the owner of the asset_id."]
            #[doc = "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn replace_asset_compliance(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                asset_compliance: ::alloc::vec::Vec<
                    types::polymesh_primitives::compliance_manager::ComplianceRequirement,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: pallet :: ComplianceManagerCall :: replace_asset_compliance { asset_id , asset_compliance , }))
            }
            #[doc = "Replaces an asset's compliance with a new compliance."]
            #[doc = ""]
            #[doc = "Compliance requirements will be sorted (ascending by id) before"]
            #[doc = "replacing the current requirements."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `asset_id` - the asset asset_id,"]
            #[doc = "* `asset_compliance - the new asset compliance."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `Unauthorized` if `origin` is not the owner of the asset_id."]
            #[doc = "* `DuplicateAssetCompliance` if `asset_compliance` contains multiple entries with the same `requirement_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn replace_asset_compliance(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                asset_compliance: ::alloc::vec::Vec<
                    types::polymesh_primitives::compliance_manager::ComplianceRequirement,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![29u8, 2u8];
                asset_id.encode_to(&mut buf);
                asset_compliance.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes an asset's compliance"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
            #[doc = "* asset_id - Symbol of the asset"]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn reset_asset_compliance(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: pallet :: ComplianceManagerCall :: reset_asset_compliance { asset_id , }))
            }
            #[doc = "Removes an asset's compliance"]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
            #[doc = "* asset_id - Symbol of the asset"]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn reset_asset_compliance(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![29u8, 3u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Pauses the verification of conditions for `asset_id` during transfers."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
            #[doc = "* asset_id - Symbol of the asset"]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn pause_asset_compliance(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: pallet :: ComplianceManagerCall :: pause_asset_compliance { asset_id , }))
            }
            #[doc = "Pauses the verification of conditions for `asset_id` during transfers."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
            #[doc = "* asset_id - Symbol of the asset"]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn pause_asset_compliance(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![29u8, 4u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Resumes the verification of conditions for `asset_id` during transfers."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
            #[doc = "* asset_id - Symbol of the asset"]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn resume_asset_compliance(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: pallet :: ComplianceManagerCall :: resume_asset_compliance { asset_id , }))
            }
            #[doc = "Resumes the verification of conditions for `asset_id` during transfers."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset"]
            #[doc = "* asset_id - Symbol of the asset"]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn resume_asset_compliance(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![29u8, 5u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds another default trusted claim issuer at the asset level."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
            #[doc = "* asset_id - Symbol of the asset."]
            #[doc = "* issuer - IdentityId of the trusted claim issuer."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn add_default_trusted_claim_issuer(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                issuer: types::polymesh_primitives::condition::TrustedIssuer,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: pallet :: ComplianceManagerCall :: add_default_trusted_claim_issuer { asset_id , issuer , }))
            }
            #[doc = "Adds another default trusted claim issuer at the asset level."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
            #[doc = "* asset_id - Symbol of the asset."]
            #[doc = "* issuer - IdentityId of the trusted claim issuer."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn add_default_trusted_claim_issuer(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                issuer: types::polymesh_primitives::condition::TrustedIssuer,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![29u8, 6u8];
                asset_id.encode_to(&mut buf);
                issuer.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the given `issuer` from the set of default trusted claim issuers at the asset level."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
            #[doc = "* asset_id - Symbol of the asset."]
            #[doc = "* issuer - IdentityId of the trusted claim issuer."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn remove_default_trusted_claim_issuer(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                issuer: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: pallet :: ComplianceManagerCall :: remove_default_trusted_claim_issuer { asset_id , issuer , }))
            }
            #[doc = "Removes the given `issuer` from the set of default trusted claim issuers at the asset level."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
            #[doc = "* asset_id - Symbol of the asset."]
            #[doc = "* issuer - IdentityId of the trusted claim issuer."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn remove_default_trusted_claim_issuer(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                issuer: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![29u8, 7u8];
                asset_id.encode_to(&mut buf);
                issuer.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Modify an existing compliance requirement of a given asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
            #[doc = "* asset_id - Symbol of the asset."]
            #[doc = "* new_req - Compliance requirement."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn change_compliance_requirement(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                new_req: types::polymesh_primitives::compliance_manager::ComplianceRequirement,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ComplianceManager (types :: pallet_compliance_manager :: pallet :: ComplianceManagerCall :: change_compliance_requirement { asset_id , new_req , }))
            }
            #[doc = "Modify an existing compliance requirement of a given asset."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* origin - Signer of the dispatchable. It should be the owner of the asset."]
            #[doc = "* asset_id - Symbol of the asset."]
            #[doc = "* new_req - Compliance requirement."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn change_compliance_requirement(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                new_req: types::polymesh_primitives::compliance_manager::ComplianceRequirement,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![29u8, 8u8];
                asset_id.encode_to(&mut buf);
                new_req.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for ComplianceManagerCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct ComplianceManagerQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> ComplianceManagerQueryApi<'api> {
            #[doc = " Compliance for an asset ([`AssetId`] -> [`AssetCompliance`])"]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_compliances(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::compliance_manager::AssetCompliance,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8,
                    53u8, 193u8, 10u8, 8u8, 220u8, 174u8, 4u8, 188u8, 209u8, 112u8, 119u8, 72u8,
                    235u8, 75u8, 159u8, 89u8, 9u8, 248u8, 244u8, 242u8, 195u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8];
                    <types::polymesh_primitives::compliance_manager::AssetCompliance>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Compliance for an asset ([`AssetId`] -> [`AssetCompliance`])"]
            #[cfg(feature = "ink")]
            pub fn asset_compliances(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::compliance_manager::AssetCompliance,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8,
                    53u8, 193u8, 10u8, 8u8, 220u8, 174u8, 4u8, 188u8, 209u8, 112u8, 119u8, 72u8,
                    235u8, 75u8, 159u8, 89u8, 9u8, 248u8, 244u8, 242u8, 195u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8];
                    <types::polymesh_primitives::compliance_manager::AssetCompliance>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " List of trusted claim issuer [`AssetId`] -> Issuer Identity"]
            #[cfg(not(feature = "ink"))]
            pub async fn trusted_claim_issuer(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8,
                    53u8, 193u8, 10u8, 8u8, 220u8, 7u8, 112u8, 219u8, 149u8, 59u8, 221u8, 90u8,
                    127u8, 146u8, 167u8, 42u8, 117u8, 122u8, 15u8, 129u8, 253u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < :: alloc :: vec :: Vec < types :: polymesh_primitives :: condition :: TrustedIssuer > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " List of trusted claim issuer [`AssetId`] -> Issuer Identity"]
            #[cfg(feature = "ink")]
            pub fn trusted_claim_issuer(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8,
                    53u8, 193u8, 10u8, 8u8, 220u8, 7u8, 112u8, 219u8, 149u8, 59u8, 221u8, 90u8,
                    127u8, 146u8, 167u8, 42u8, 117u8, 122u8, 15u8, 129u8, 253u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < :: alloc :: vec :: Vec < types :: polymesh_primitives :: condition :: TrustedIssuer > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_compliance_manager::Version>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8,
                    53u8, 193u8, 10u8, 8u8, 220u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_compliance_manager::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_compliance_manager::Version>
            {
                let value = self.api.read_storage(::alloc::vec![
                    255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8,
                    53u8, 193u8, 10u8, 8u8, 220u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_compliance_manager::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct ComplianceManagerPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> ComplianceManagerPagedQueryApi<'api> {
            #[doc = " Compliance for an asset ([`AssetId`] -> [`AssetCompliance`])"]
            pub fn asset_compliances(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::compliance_manager::AssetCompliance,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8,
                    53u8, 193u8, 10u8, 8u8, 220u8, 174u8, 4u8, 188u8, 209u8, 112u8, 119u8, 72u8,
                    235u8, 75u8, 159u8, 89u8, 9u8, 248u8, 244u8, 242u8, 195u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " List of trusted claim issuer [`AssetId`] -> Issuer Identity"]
            pub fn trusted_claim_issuer(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                ::alloc::vec::Vec<types::polymesh_primitives::condition::TrustedIssuer>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    255u8, 219u8, 199u8, 116u8, 193u8, 144u8, 129u8, 130u8, 221u8, 228u8, 247u8,
                    53u8, 193u8, 10u8, 8u8, 220u8, 7u8, 112u8, 219u8, 149u8, 59u8, 221u8, 90u8,
                    127u8, 146u8, 167u8, 42u8, 117u8, 122u8, 15u8, 129u8, 253u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
        }
    }
    pub mod corporate_action {
        use super::*;
        #[derive(Clone)]
        pub struct CorporateActionCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> CorporateActionCallApi<'api> {
            #[doc = "Set the max `length` of `details` in terms of bytes."]
            #[doc = "May only be called via a PIP."]
            #[cfg(not(feature = "ink"))]
            pub fn set_max_details_length(
                &self,
                length: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateAction (types :: pallet_corporate_actions :: pallet :: CorporateActionCall :: set_max_details_length { length , }))
            }
            #[doc = "Set the max `length` of `details` in terms of bytes."]
            #[doc = "May only be called via a PIP."]
            #[cfg(feature = "ink")]
            pub fn set_max_details_length(&self, length: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![30u8, 0u8];
                length.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set the default CA `TargetIdentities` to `targets`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
            #[doc = "- `asset_id` for which the default identities are changing."]
            #[doc = "- `targets` the default target identities for a CA."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn set_default_targets(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                targets: types::pallet_corporate_actions::TargetIdentities,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateAction (types :: pallet_corporate_actions :: pallet :: CorporateActionCall :: set_default_targets { asset_id , targets , }))
            }
            #[doc = "Set the default CA `TargetIdentities` to `targets`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
            #[doc = "- `asset_id` for which the default identities are changing."]
            #[doc = "- `targets` the default target identities for a CA."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `TooManyTargetIds` if `targets.identities.len() > T::MaxTargetIds::get()`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn set_default_targets(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                targets: types::pallet_corporate_actions::TargetIdentities,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![30u8, 1u8];
                asset_id.encode_to(&mut buf);
                targets.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set the default withholding tax for all DIDs and CAs relevant to this `asset_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
            #[doc = "- `asset_id` that the withholding tax will apply to."]
            #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn set_default_withholding_tax(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                tax: ::polymesh_api_client::per_things::Permill,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateAction (types :: pallet_corporate_actions :: pallet :: CorporateActionCall :: set_default_withholding_tax { asset_id , tax , }))
            }
            #[doc = "Set the default withholding tax for all DIDs and CAs relevant to this `asset_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
            #[doc = "- `asset_id` that the withholding tax will apply to."]
            #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn set_default_withholding_tax(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                tax: ::polymesh_api_client::per_things::Permill,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![30u8, 2u8];
                asset_id.encode_to(&mut buf);
                tax.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set the withholding tax of `asset_id` for `taxed_did` to `tax`."]
            #[doc = "If `Some(tax)`, this overrides the default withholding tax of `asset_id` to `tax` for `taxed_did`."]
            #[doc = "Otherwise, if `None`, the default withholding tax will be used."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
            #[doc = "- `asset_id` that the withholding tax will apply to."]
            #[doc = "- `taxed_did` that will have its withholding tax updated."]
            #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn set_did_withholding_tax(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                taxed_did: ::polymesh_api_client::IdentityId,
                tax: Option<::polymesh_api_client::per_things::Permill>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateAction (types :: pallet_corporate_actions :: pallet :: CorporateActionCall :: set_did_withholding_tax { asset_id , taxed_did , tax , }))
            }
            #[doc = "Set the withholding tax of `asset_id` for `taxed_did` to `tax`."]
            #[doc = "If `Some(tax)`, this overrides the default withholding tax of `asset_id` to `tax` for `taxed_did`."]
            #[doc = "Otherwise, if `None`, the default withholding tax will be used."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
            #[doc = "- `asset_id` that the withholding tax will apply to."]
            #[doc = "- `taxed_did` that will have its withholding tax updated."]
            #[doc = "- `tax` that should be withheld when distributing dividends, etc."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `TooManyDidTaxes` if `Some(tax)` and adding the override would go over the limit `MaxDidWhts`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn set_did_withholding_tax(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                taxed_did: ::polymesh_api_client::IdentityId,
                tax: Option<::polymesh_api_client::per_things::Permill>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![30u8, 3u8];
                asset_id.encode_to(&mut buf);
                taxed_did.encode_to(&mut buf);
                tax.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Initiates a CA for `asset_id` of `kind` with `details` and other provided arguments."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
            #[doc = "- `asset_id` that the CA is made for."]
            #[doc = "- `kind` of CA being initiated."]
            #[doc = "- `decl_date` of CA bring initialized."]
            #[doc = "- `record_date`, if any, to calculate the impact of this CA."]
            #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
            #[doc = "- `details` of the CA in free-text form, up to a certain number of bytes in length."]
            #[doc = "- `targets`, if any, which this CA is relevant/irrelevant to."]
            #[doc = "   Overrides, if provided, the default at the asset level (`set_default_targets`)."]
            #[doc = "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA."]
            #[doc = "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)."]
            #[doc = "- `withholding_tax`, if any, provides per-DID withholding tax overrides."]
            #[doc = "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`."]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `CounterOverflow` in the unlikely event that so many CAs were created for this `asset_id`,"]
            #[doc = "  that integer overflow would have occured if instead allowed."]
            #[doc = "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`."]
            #[doc = "- `DuplicateDidTax` if a DID is included more than once in `wt`."]
            #[doc = "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`."]
            #[doc = "- `DeclDateInFuture` if the declaration date is not in the past."]
            #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn initiate_corporate_action(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                kind: types::pallet_corporate_actions::CAKind,
                decl_date: u64,
                record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
                details: types::pallet_corporate_actions::CADetails,
                targets: Option<types::pallet_corporate_actions::TargetIdentities>,
                default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
                withholding_tax: Option<
                    ::alloc::vec::Vec<(
                        ::polymesh_api_client::IdentityId,
                        ::polymesh_api_client::per_things::Permill,
                    )>,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateAction (types :: pallet_corporate_actions :: pallet :: CorporateActionCall :: initiate_corporate_action { asset_id , kind , decl_date , record_date , details , targets , default_withholding_tax , withholding_tax , }))
            }
            #[doc = "Initiates a CA for `asset_id` of `kind` with `details` and other provided arguments."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `asset_id` with relevant permissions."]
            #[doc = "- `asset_id` that the CA is made for."]
            #[doc = "- `kind` of CA being initiated."]
            #[doc = "- `decl_date` of CA bring initialized."]
            #[doc = "- `record_date`, if any, to calculate the impact of this CA."]
            #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
            #[doc = "- `details` of the CA in free-text form, up to a certain number of bytes in length."]
            #[doc = "- `targets`, if any, which this CA is relevant/irrelevant to."]
            #[doc = "   Overrides, if provided, the default at the asset level (`set_default_targets`)."]
            #[doc = "- `default_withholding_tax`, if any, is the default withholding tax to use for this CA."]
            #[doc = "   Overrides, if provided, the default at the asset level (`set_default_withholding_tax`)."]
            #[doc = "- `withholding_tax`, if any, provides per-DID withholding tax overrides."]
            #[doc = "   Overrides, if provided, the default at the asset level (`set_did_withholding_tax`)."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `DetailsTooLong` if `details.len()` goes beyond `max_details_length`."]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `CounterOverflow` in the unlikely event that so many CAs were created for this `asset_id`,"]
            #[doc = "  that integer overflow would have occured if instead allowed."]
            #[doc = "- `TooManyDidTaxes` if `withholding_tax.unwrap().len()` would go over the limit `MaxDidWhts`."]
            #[doc = "- `DuplicateDidTax` if a DID is included more than once in `wt`."]
            #[doc = "- `TooManyTargetIds` if `targets.unwrap().identities.len() > T::MaxTargetIds::get()`."]
            #[doc = "- `DeclDateInFuture` if the declaration date is not in the past."]
            #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn initiate_corporate_action(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                kind: types::pallet_corporate_actions::CAKind,
                decl_date: u64,
                record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
                details: types::pallet_corporate_actions::CADetails,
                targets: Option<types::pallet_corporate_actions::TargetIdentities>,
                default_withholding_tax: Option<::polymesh_api_client::per_things::Permill>,
                withholding_tax: Option<
                    ::alloc::vec::Vec<(
                        ::polymesh_api_client::IdentityId,
                        ::polymesh_api_client::per_things::Permill,
                    )>,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![30u8, 4u8];
                asset_id.encode_to(&mut buf);
                kind.encode_to(&mut buf);
                decl_date.encode_to(&mut buf);
                record_date.encode_to(&mut buf);
                details.encode_to(&mut buf);
                targets.encode_to(&mut buf);
                default_withholding_tax.encode_to(&mut buf);
                withholding_tax.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Link the given CA `id` to the given `docs`."]
            #[doc = "Any previous links for the CA are removed in favor of `docs`."]
            #[doc = ""]
            #[doc = "The workflow here is to add the documents and initiating the CA in any order desired."]
            #[doc = "Once both exist, they can now be linked together."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `id.asset_id` with relevant permissions."]
            #[doc = "- `id` of the CA to associate with `docs`."]
            #[doc = "- `docs` to associate with the CA with `id`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
            #[doc = "- `NoSuchDoc` if any of `docs` does not identify an existing document."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn link_ca_doc(
                &self,
                id: types::pallet_corporate_actions::CAId,
                docs: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
                    types::pallet_corporate_actions::pallet::CorporateActionCall::link_ca_doc {
                        id,
                        docs,
                    },
                ))
            }
            #[doc = "Link the given CA `id` to the given `docs`."]
            #[doc = "Any previous links for the CA are removed in favor of `docs`."]
            #[doc = ""]
            #[doc = "The workflow here is to add the documents and initiating the CA in any order desired."]
            #[doc = "Once both exist, they can now be linked together."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `id.asset_id` with relevant permissions."]
            #[doc = "- `id` of the CA to associate with `docs`."]
            #[doc = "- `docs` to associate with the CA with `id`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
            #[doc = "- `NoSuchDoc` if any of `docs` does not identify an existing document."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn link_ca_doc(
                &self,
                id: types::pallet_corporate_actions::CAId,
                docs: ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![30u8, 5u8];
                id.encode_to(&mut buf);
                docs.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "Associated data, such as document links, ballots,"]
            #[doc = "and capital distributions are also removed."]
            #[doc = ""]
            #[doc = "Any schedule associated with the record date will see"]
            #[doc = "`strong_ref_count(schedule_id)` decremented."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
            #[doc = "- `ca_id` of the CA to remove."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn remove_ca(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::CorporateAction(
                    types::pallet_corporate_actions::pallet::CorporateActionCall::remove_ca {
                        ca_id,
                    },
                ))
            }
            #[doc = "Removes the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "Associated data, such as document links, ballots,"]
            #[doc = "and capital distributions are also removed."]
            #[doc = ""]
            #[doc = "Any schedule associated with the record date will see"]
            #[doc = "`strong_ref_count(schedule_id)` decremented."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
            #[doc = "- `ca_id` of the CA to remove."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn remove_ca(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![30u8, 6u8];
                ca_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the record date of the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
            #[doc = "- `ca_id` of the CA to alter."]
            #[doc = "- `record_date`, if any, to calculate the impact of the CA."]
            #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
            #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn change_record_date(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateAction (types :: pallet_corporate_actions :: pallet :: CorporateActionCall :: change_record_date { ca_id , record_date , }))
            }
            #[doc = "Changes the record date of the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be an external agent of `ca_id.asset_id` with relevant permissions."]
            #[doc = "- `ca_id` of the CA to alter."]
            #[doc = "- `record_date`, if any, to calculate the impact of the CA."]
            #[doc = "   If provided, this results in a scheduled balance snapshot (\"checkpoint\") at the date."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchCA` if `id` does not identify an existing CA."]
            #[doc = "- When `record_date.is_some()`, other errors due to checkpoint scheduling may occur."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn change_record_date(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                record_date: Option<types::pallet_corporate_actions::RecordDateSpec>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![30u8, 7u8];
                ca_id.encode_to(&mut buf);
                record_date.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Utility extrinsic to batch `initiate_corporate_action` and `distribute`"]
            #[cfg(not(feature = "ink"))]
            pub fn initiate_corporate_action_and_distribute(
                &self,
                ca_args: types::pallet_corporate_actions::InitiateCorporateActionArgs,
                portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
                currency: ::polymesh_api_client::AssetId,
                per_share: u128,
                amount: u128,
                payment_at: u64,
                expires_at: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateAction (types :: pallet_corporate_actions :: pallet :: CorporateActionCall :: initiate_corporate_action_and_distribute { ca_args , portfolio , currency , per_share , amount , payment_at , expires_at , }))
            }
            #[doc = "Utility extrinsic to batch `initiate_corporate_action` and `distribute`"]
            #[cfg(feature = "ink")]
            pub fn initiate_corporate_action_and_distribute(
                &self,
                ca_args: types::pallet_corporate_actions::InitiateCorporateActionArgs,
                portfolio: Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
                currency: ::polymesh_api_client::AssetId,
                per_share: u128,
                amount: u128,
                payment_at: u64,
                expires_at: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![30u8, 8u8];
                ca_args.encode_to(&mut buf);
                portfolio.encode_to(&mut buf);
                currency.encode_to(&mut buf);
                per_share.encode_to(&mut buf);
                amount.encode_to(&mut buf);
                payment_at.encode_to(&mut buf);
                expires_at.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[cfg(not(feature = "ink"))]
            pub fn initiate_corporate_action_and_ballot(
                &self,
                ca_args: types::pallet_corporate_actions::InitiateCorporateActionArgs,
                ballot_time_range: types::pallet_corporate_actions::ballot::BallotTimeRange,
                ballot_meta: types::pallet_corporate_actions::ballot::BallotMeta,
                rcv: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateAction (types :: pallet_corporate_actions :: pallet :: CorporateActionCall :: initiate_corporate_action_and_ballot { ca_args , ballot_time_range , ballot_meta , rcv , }))
            }
            #[cfg(feature = "ink")]
            pub fn initiate_corporate_action_and_ballot(
                &self,
                ca_args: types::pallet_corporate_actions::InitiateCorporateActionArgs,
                ballot_time_range: types::pallet_corporate_actions::ballot::BallotTimeRange,
                ballot_meta: types::pallet_corporate_actions::ballot::BallotMeta,
                rcv: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![30u8, 9u8];
                ca_args.encode_to(&mut buf);
                ballot_time_range.encode_to(&mut buf);
                ballot_meta.encode_to(&mut buf);
                rcv.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for CorporateActionCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct CorporateActionQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> CorporateActionQueryApi<'api> {
            #[doc = " Determines the maximum number of bytes that the free-form `details` of a CA can store."]
            #[doc = ""]
            #[doc = " Note that this is not the number of `char`s or the number of [graphemes]."]
            #[doc = " While this may be unnatural in terms of human understanding of a text's length,"]
            #[doc = " it more closely reflects actual storage costs (`'a'` is cheaper to store than an emoji)."]
            #[doc = ""]
            #[doc = " [graphemes]: https://en.wikipedia.org/wiki/Grapheme"]
            #[cfg(not(feature = "ink"))]
            pub async fn max_details_length(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 35u8, 28u8, 123u8, 214u8, 108u8, 218u8, 59u8, 20u8,
                    118u8, 8u8, 139u8, 67u8, 69u8, 136u8, 180u8, 5u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Determines the maximum number of bytes that the free-form `details` of a CA can store."]
            #[doc = ""]
            #[doc = " Note that this is not the number of `char`s or the number of [graphemes]."]
            #[doc = " While this may be unnatural in terms of human understanding of a text's length,"]
            #[doc = " it more closely reflects actual storage costs (`'a'` is cheaper to store than an emoji)."]
            #[doc = ""]
            #[doc = " [graphemes]: https://en.wikipedia.org/wiki/Grapheme"]
            #[cfg(feature = "ink")]
            pub fn max_details_length(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 35u8, 28u8, 123u8, 214u8, 108u8, 218u8, 59u8, 20u8,
                    118u8, 8u8, 139u8, 67u8, 69u8, 136u8, 180u8, 5u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The identities targeted by default for CAs for this asset,"]
            #[doc = " either to be excluded or included."]
            #[doc = ""]
            #[doc = " (AssetId => target identities)"]
            #[cfg(not(feature = "ink"))]
            pub async fn default_target_identities(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                types::pallet_corporate_actions::TargetIdentities,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 77u8, 99u8, 45u8, 196u8, 84u8, 74u8, 106u8, 171u8,
                    172u8, 166u8, 213u8, 51u8, 51u8, 209u8, 34u8, 188u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 1u8];
                    <types::pallet_corporate_actions::TargetIdentities>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The identities targeted by default for CAs for this asset,"]
            #[doc = " either to be excluded or included."]
            #[doc = ""]
            #[doc = " (AssetId => target identities)"]
            #[cfg(feature = "ink")]
            pub fn default_target_identities(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::TargetIdentities>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 77u8, 99u8, 45u8, 196u8, 84u8, 74u8, 106u8, 171u8,
                    172u8, 166u8, 213u8, 51u8, 51u8, 209u8, 34u8, 188u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 1u8];
                    <types::pallet_corporate_actions::TargetIdentities>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The default amount of tax to withhold (\"withholding tax\", WT) for this asset when distributing dividends."]
            #[doc = ""]
            #[doc = " To understand withholding tax, e.g., let's assume that you hold ACME shares."]
            #[doc = " ACME now decides to distribute 100 SEK to Alice."]
            #[doc = " Alice lives in Sweden, so Skatteverket (the Swedish tax authority) wants 30% of that."]
            #[doc = " Then those 100 * 30% are withheld from Alice, and ACME will send them to Skatteverket."]
            #[doc = ""]
            #[doc = " (AssetId => % to withhold)"]
            #[cfg(not(feature = "ink"))]
            pub async fn default_withholding_tax(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<::polymesh_api_client::per_things::Permill>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 170u8, 50u8, 103u8, 81u8, 229u8, 40u8, 244u8, 16u8,
                    164u8, 129u8, 103u8, 210u8, 52u8, 41u8, 13u8, 197u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <::polymesh_api_client::per_things::Permill>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The default amount of tax to withhold (\"withholding tax\", WT) for this asset when distributing dividends."]
            #[doc = ""]
            #[doc = " To understand withholding tax, e.g., let's assume that you hold ACME shares."]
            #[doc = " ACME now decides to distribute 100 SEK to Alice."]
            #[doc = " Alice lives in Sweden, so Skatteverket (the Swedish tax authority) wants 30% of that."]
            #[doc = " Then those 100 * 30% are withheld from Alice, and ACME will send them to Skatteverket."]
            #[doc = ""]
            #[doc = " (AssetId => % to withhold)"]
            #[cfg(feature = "ink")]
            pub fn default_withholding_tax(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<::polymesh_api_client::per_things::Permill>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 170u8, 50u8, 103u8, 81u8, 229u8, 40u8, 244u8, 16u8,
                    164u8, 129u8, 103u8, 210u8, 52u8, 41u8, 13u8, 197u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <::polymesh_api_client::per_things::Permill>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The amount of tax to withhold (\"withholding tax\", WT) for a certain AssetId x DID."]
            #[doc = " If an entry exists for a certain DID, it overrides the default in `DefaultWithholdingTax`."]
            #[doc = ""]
            #[doc = " (AssetId => [(did, % to withhold)]"]
            #[cfg(not(feature = "ink"))]
            pub async fn did_withholding_tax(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::per_things::Permill,
                )>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 224u8, 222u8, 223u8, 202u8, 239u8, 39u8, 125u8, 98u8,
                    152u8, 237u8, 195u8, 114u8, 134u8, 40u8, 221u8, 13u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(
                        ::polymesh_api_client::IdentityId,
                        ::polymesh_api_client::per_things::Permill,
                    )>>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " The amount of tax to withhold (\"withholding tax\", WT) for a certain AssetId x DID."]
            #[doc = " If an entry exists for a certain DID, it overrides the default in `DefaultWithholdingTax`."]
            #[doc = ""]
            #[doc = " (AssetId => [(did, % to withhold)]"]
            #[cfg(feature = "ink")]
            pub fn did_withholding_tax(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::per_things::Permill,
                )>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 224u8, 222u8, 223u8, 202u8, 239u8, 39u8, 125u8, 98u8,
                    152u8, 237u8, 195u8, 114u8, 134u8, 40u8, 221u8, 13u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<(
                        ::polymesh_api_client::IdentityId,
                        ::polymesh_api_client::per_things::Permill,
                    )>>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " The next per-`AssetId` CA ID in the sequence."]
            #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence."]
            #[cfg(not(feature = "ink"))]
            pub async fn ca_id_sequence(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::LocalCAId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 82u8, 91u8, 86u8, 204u8, 80u8, 123u8, 119u8, 166u8,
                    116u8, 44u8, 136u8, 13u8, 78u8, 115u8, 129u8, 34u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::pallet_corporate_actions::LocalCAId>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The next per-`AssetId` CA ID in the sequence."]
            #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence."]
            #[cfg(feature = "ink")]
            pub fn ca_id_sequence(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::LocalCAId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 82u8, 91u8, 86u8, 204u8, 80u8, 123u8, 119u8, 166u8,
                    116u8, 44u8, 136u8, 13u8, 78u8, 115u8, 129u8, 34u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::pallet_corporate_actions::LocalCAId>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All recorded CAs thus far."]
            #[doc = " Only generic information is stored here."]
            #[doc = " Specific `CAKind`s, e.g., benefits and corporate ballots, may use additional on-chain storage."]
            #[doc = ""]
            #[doc = " (AssetId => local ID => the corporate action)"]
            #[cfg(not(feature = "ink"))]
            pub async fn corporate_actions(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::pallet_corporate_actions::LocalCAId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_corporate_actions::CorporateAction>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 14u8, 36u8, 40u8, 25u8, 103u8, 79u8, 185u8, 193u8,
                    131u8, 31u8, 153u8, 37u8, 135u8, 74u8, 8u8, 159u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " All recorded CAs thus far."]
            #[doc = " Only generic information is stored here."]
            #[doc = " Specific `CAKind`s, e.g., benefits and corporate ballots, may use additional on-chain storage."]
            #[doc = ""]
            #[doc = " (AssetId => local ID => the corporate action)"]
            #[cfg(feature = "ink")]
            pub fn corporate_actions(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::pallet_corporate_actions::LocalCAId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_corporate_actions::CorporateAction>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 14u8, 36u8, 40u8, 25u8, 103u8, 79u8, 185u8, 193u8,
                    131u8, 31u8, 153u8, 37u8, 135u8, 74u8, 8u8, 159u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Associations from CAs to `Document`s via their IDs."]
            #[doc = " (CAId => [DocumentId])"]
            #[doc = ""]
            #[doc = " The `CorporateActions` map stores `AssetId => LocalId => The CA`,"]
            #[doc = " so we can infer `AssetId => CAId`. Therefore, we don't need a double map."]
            #[cfg(not(feature = "ink"))]
            pub async fn ca_doc_link(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 120u8, 114u8, 125u8, 160u8, 162u8, 78u8, 111u8,
                    100u8, 74u8, 192u8, 8u8, 173u8, 45u8, 35u8, 163u8, 153u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Associations from CAs to `Document`s via their IDs."]
            #[doc = " (CAId => [DocumentId])"]
            #[doc = ""]
            #[doc = " The `CorporateActions` map stores `AssetId => LocalId => The CA`,"]
            #[doc = " so we can infer `AssetId => CAId`. Therefore, we don't need a double map."]
            #[cfg(feature = "ink")]
            pub fn ca_doc_link(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 120u8, 114u8, 125u8, 160u8, 162u8, 78u8, 111u8,
                    100u8, 74u8, 192u8, 8u8, 173u8, 45u8, 35u8, 163u8, 153u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Associates details in free-form text with a CA by its ID."]
            #[doc = " (CAId => CADetails)"]
            #[cfg(not(feature = "ink"))]
            pub async fn details(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::CADetails>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8,
                    198u8, 220u8, 28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_corporate_actions::CADetails>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Associates details in free-form text with a CA by its ID."]
            #[doc = " (CAId => CADetails)"]
            #[cfg(feature = "ink")]
            pub fn details(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::CADetails>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8,
                    198u8, 220u8, 28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_corporate_actions::CADetails>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_corporate_actions::Version>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_corporate_actions::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::Version>
            {
                let value = self.api.read_storage(::alloc::vec![
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_corporate_actions::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct CorporateActionPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> CorporateActionPagedQueryApi<'api> {
            #[doc = " The identities targeted by default for CAs for this asset,"]
            #[doc = " either to be excluded or included."]
            #[doc = ""]
            #[doc = " (AssetId => target identities)"]
            pub fn default_target_identities(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::pallet_corporate_actions::TargetIdentities,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 77u8, 99u8, 45u8, 196u8, 84u8, 74u8, 106u8, 171u8,
                    172u8, 166u8, 213u8, 51u8, 51u8, 209u8, 34u8, 188u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The default amount of tax to withhold (\"withholding tax\", WT) for this asset when distributing dividends."]
            #[doc = ""]
            #[doc = " To understand withholding tax, e.g., let's assume that you hold ACME shares."]
            #[doc = " ACME now decides to distribute 100 SEK to Alice."]
            #[doc = " Alice lives in Sweden, so Skatteverket (the Swedish tax authority) wants 30% of that."]
            #[doc = " Then those 100 * 30% are withheld from Alice, and ACME will send them to Skatteverket."]
            #[doc = ""]
            #[doc = " (AssetId => % to withhold)"]
            pub fn default_withholding_tax(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                ::polymesh_api_client::per_things::Permill,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 170u8, 50u8, 103u8, 81u8, 229u8, 40u8, 244u8, 16u8,
                    164u8, 129u8, 103u8, 210u8, 52u8, 41u8, 13u8, 197u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The amount of tax to withhold (\"withholding tax\", WT) for a certain AssetId x DID."]
            #[doc = " If an entry exists for a certain DID, it overrides the default in `DefaultWithholdingTax`."]
            #[doc = ""]
            #[doc = " (AssetId => [(did, % to withhold)]"]
            pub fn did_withholding_tax(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                ::alloc::vec::Vec<(
                    ::polymesh_api_client::IdentityId,
                    ::polymesh_api_client::per_things::Permill,
                )>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 224u8, 222u8, 223u8, 202u8, 239u8, 39u8, 125u8, 98u8,
                    152u8, 237u8, 195u8, 114u8, 134u8, 40u8, 221u8, 13u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The next per-`AssetId` CA ID in the sequence."]
            #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence."]
            pub fn ca_id_sequence(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::pallet_corporate_actions::LocalCAId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 82u8, 91u8, 86u8, 204u8, 80u8, 123u8, 119u8, 166u8,
                    116u8, 44u8, 136u8, 13u8, 78u8, 115u8, 129u8, 34u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " All recorded CAs thus far."]
            #[doc = " Only generic information is stored here."]
            #[doc = " Specific `CAKind`s, e.g., benefits and corporate ballots, may use additional on-chain storage."]
            #[doc = ""]
            #[doc = " (AssetId => local ID => the corporate action)"]
            pub fn corporate_actions(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_corporate_actions::LocalCAId,
                types::pallet_corporate_actions::CorporateAction,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 14u8, 36u8, 40u8, 25u8, 103u8, 79u8, 185u8, 193u8,
                    131u8, 31u8, 153u8, 37u8, 135u8, 74u8, 8u8, 159u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Associations from CAs to `Document`s via their IDs."]
            #[doc = " (CAId => [DocumentId])"]
            #[doc = ""]
            #[doc = " The `CorporateActions` map stores `AssetId => LocalId => The CA`,"]
            #[doc = " so we can infer `AssetId => CAId`. Therefore, we don't need a double map."]
            pub fn ca_doc_link(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_corporate_actions::CAId,
                ::alloc::vec::Vec<types::polymesh_primitives::document::DocumentId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 120u8, 114u8, 125u8, 160u8, 162u8, 78u8, 111u8,
                    100u8, 74u8, 192u8, 8u8, 173u8, 45u8, 35u8, 163u8, 153u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Associates details in free-form text with a CA by its ID."]
            #[doc = " (CAId => CADetails)"]
            pub fn details(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_corporate_actions::CAId,
                types::pallet_corporate_actions::CADetails,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    220u8, 91u8, 74u8, 49u8, 243u8, 242u8, 170u8, 172u8, 182u8, 184u8, 60u8, 136u8,
                    217u8, 32u8, 99u8, 238u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8, 226u8,
                    198u8, 220u8, 28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
        }
    }
    pub mod corporate_ballot {
        use super::*;
        #[derive(Clone)]
        pub struct CorporateBallotCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> CorporateBallotCallApi<'api> {
            #[doc = "Attach a corporate ballot to the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "The ballot will admit votes within `range`."]
            #[doc = "The ballot's metadata is provided by `meta`,"]
            #[doc = "which includes the ballot title, the motions, their choices, etc."]
            #[doc = "See the `BallotMeta` for more."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the CA to attach the ballot to."]
            #[doc = "- `range` specifies when voting starts and ends."]
            #[doc = "- `meta` specifies the ballot's metadata as aforementioned."]
            #[doc = "- `rcv` specifies whether RCV is enabled for this ballot."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
            #[doc = "- `CANotNotice` if the CA is not of the `IssuerNotice` kind."]
            #[doc = "- `StartAfterEnd` if `range.start > range.end`."]
            #[doc = "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp."]
            #[doc = "- `NoRecordDate` if CA has no record date."]
            #[doc = "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date."]
            #[doc = "- `AlreadyExists` if there's a ballot already."]
            #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
            #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
            #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
            #[cfg(not(feature = "ink"))]
            pub fn attach_ballot(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                range: types::pallet_corporate_actions::ballot::BallotTimeRange,
                meta: types::pallet_corporate_actions::ballot::BallotMeta,
                rcv: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateBallot (types :: pallet_corporate_actions :: ballot :: pallet :: CorporateBallotCall :: attach_ballot { ca_id , range , meta , rcv , }))
            }
            #[doc = "Attach a corporate ballot to the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "The ballot will admit votes within `range`."]
            #[doc = "The ballot's metadata is provided by `meta`,"]
            #[doc = "which includes the ballot title, the motions, their choices, etc."]
            #[doc = "See the `BallotMeta` for more."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the CA to attach the ballot to."]
            #[doc = "- `range` specifies when voting starts and ends."]
            #[doc = "- `meta` specifies the ballot's metadata as aforementioned."]
            #[doc = "- `rcv` specifies whether RCV is enabled for this ballot."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
            #[doc = "- `CANotNotice` if the CA is not of the `IssuerNotice` kind."]
            #[doc = "- `StartAfterEnd` if `range.start > range.end`."]
            #[doc = "- `NowAfterEnd` if `now > range.end` where `now` is the current timestamp."]
            #[doc = "- `NoRecordDate` if CA has no record date."]
            #[doc = "- `RecordDateAfterStart` if `date > range.start` where `date` is the CA's record date."]
            #[doc = "- `AlreadyExists` if there's a ballot already."]
            #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
            #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
            #[doc = "- `InsufficientBalance` if the protocol fee couldn't be charged."]
            #[cfg(feature = "ink")]
            pub fn attach_ballot(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                range: types::pallet_corporate_actions::ballot::BallotTimeRange,
                meta: types::pallet_corporate_actions::ballot::BallotMeta,
                rcv: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![31u8, 0u8];
                ca_id.encode_to(&mut buf);
                range.encode_to(&mut buf);
                meta.encode_to(&mut buf);
                rcv.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Cast `votes` in the ballot attached to the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be a permissioned signer targeted by the CA."]
            #[doc = "- `ca_id` identifies the attached ballot's CA."]
            #[doc = "- `votes` specifies the balances to assign to each choice in the ballot."]
            #[doc = "   The full voting power of `origin`'s DID may be used for each motion in the ballot."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
            #[doc = "- `VotingNotStarted` if the voting period hasn't commenced yet."]
            #[doc = "- `VotingAlreadyEnded` if the voting period has ended."]
            #[doc = "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`."]
            #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
            #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
            #[doc = "- `InsufficientVotes` if the voting power used for any motion in `votes`"]
            #[doc = "   exceeds `origin`'s DID's voting power."]
            #[cfg(not(feature = "ink"))]
            pub fn vote(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                votes: ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::CorporateBallot(
                    types::pallet_corporate_actions::ballot::pallet::CorporateBallotCall::vote {
                        ca_id,
                        votes,
                    },
                ))
            }
            #[doc = "Cast `votes` in the ballot attached to the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` which must be a permissioned signer targeted by the CA."]
            #[doc = "- `ca_id` identifies the attached ballot's CA."]
            #[doc = "- `votes` specifies the balances to assign to each choice in the ballot."]
            #[doc = "   The full voting power of `origin`'s DID may be used for each motion in the ballot."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
            #[doc = "- `VotingNotStarted` if the voting period hasn't commenced yet."]
            #[doc = "- `VotingAlreadyEnded` if the voting period has ended."]
            #[doc = "- `WrongVoteCount` if the number of choices in the ballot does not match `votes.len()`."]
            #[doc = "- `NoSuchCA` if `ca_id` does not identify an existing CA."]
            #[doc = "- `NotTargetedByCA` if the CA does not target `origin`'s DID."]
            #[doc = "- `InsufficientVotes` if the voting power used for any motion in `votes`"]
            #[doc = "   exceeds `origin`'s DID's voting power."]
            #[cfg(feature = "ink")]
            pub fn vote(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                votes: ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![31u8, 1u8];
                ca_id.encode_to(&mut buf);
                votes.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Amend the end date of the ballot of the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the attached ballot's CA."]
            #[doc = "- `end` specifies the new end date of the ballot."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
            #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
            #[doc = "- `StartAfterEnd` if `start > end`."]
            #[cfg(not(feature = "ink"))]
            pub fn change_end(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                end: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateBallot (types :: pallet_corporate_actions :: ballot :: pallet :: CorporateBallotCall :: change_end { ca_id , end , }))
            }
            #[doc = "Amend the end date of the ballot of the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the attached ballot's CA."]
            #[doc = "- `end` specifies the new end date of the ballot."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
            #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
            #[doc = "- `StartAfterEnd` if `start > end`."]
            #[cfg(feature = "ink")]
            pub fn change_end(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                end: u64,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![31u8, 2u8];
                ca_id.encode_to(&mut buf);
                end.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the attached ballot's CA."]
            #[doc = "- `meta` specifies the new metadata."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
            #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
            #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
            #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
            #[cfg(not(feature = "ink"))]
            pub fn change_meta(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                meta: types::pallet_corporate_actions::ballot::BallotMeta,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateBallot (types :: pallet_corporate_actions :: ballot :: pallet :: CorporateBallotCall :: change_meta { ca_id , meta , }))
            }
            #[doc = "Amend the metadata (title, motions, etc.) of the ballot of the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the attached ballot's CA."]
            #[doc = "- `meta` specifies the new metadata."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
            #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
            #[doc = "- `NumberOfChoicesOverflow` if the total choice in `meta` overflows `usize`."]
            #[doc = "- `TooLong` if any of the embedded strings in `meta` are too long."]
            #[cfg(feature = "ink")]
            pub fn change_meta(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                meta: types::pallet_corporate_actions::ballot::BallotMeta,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![31u8, 3u8];
                ca_id.encode_to(&mut buf);
                meta.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Amend RCV support for the ballot of the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the attached ballot's CA."]
            #[doc = "- `rcv` specifies if RCV is to be supported or not."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
            #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
            #[cfg(not(feature = "ink"))]
            pub fn change_rcv(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                rcv: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateBallot (types :: pallet_corporate_actions :: ballot :: pallet :: CorporateBallotCall :: change_rcv { ca_id , rcv , }))
            }
            #[doc = "Amend RCV support for the ballot of the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the attached ballot's CA."]
            #[doc = "- `rcv` specifies if RCV is to be supported or not."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
            #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
            #[cfg(feature = "ink")]
            pub fn change_rcv(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
                rcv: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![31u8, 4u8];
                ca_id.encode_to(&mut buf);
                rcv.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Remove the ballot of the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the attached ballot's CA."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
            #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_ballot(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: CorporateBallot (types :: pallet_corporate_actions :: ballot :: pallet :: CorporateBallotCall :: remove_ballot { ca_id , }))
            }
            #[doc = "Remove the ballot of the CA identified by `ca_id`."]
            #[doc = ""]
            #[doc = "## Arguments"]
            #[doc = "- `origin` is a signer that has permissions to act as an agent of `ca_id.asset_id`."]
            #[doc = "- `ca_id` identifies the attached ballot's CA."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = "- `NoSuchBallot` if `ca_id` does not identify a ballot."]
            #[doc = "- `VotingAlreadyStarted` if `start >= now`, where `now` is the current time."]
            #[cfg(feature = "ink")]
            pub fn remove_ballot(
                &self,
                ca_id: types::pallet_corporate_actions::CAId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![31u8, 5u8];
                ca_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for CorporateBallotCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct CorporateBallotQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> CorporateBallotQueryApi<'api> {
            #[doc = " Metadata of a corporate ballot."]
            #[doc = ""]
            #[doc = " (CAId) => BallotMeta"]
            #[cfg(not(feature = "ink"))]
            pub async fn metas(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_corporate_actions::ballot::BallotMeta>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 156u8, 233u8, 150u8, 83u8, 80u8, 111u8, 149u8, 210u8,
                    238u8, 76u8, 158u8, 22u8, 106u8, 202u8, 6u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Metadata of a corporate ballot."]
            #[doc = ""]
            #[doc = " (CAId) => BallotMeta"]
            #[cfg(feature = "ink")]
            pub fn metas(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_corporate_actions::ballot::BallotMeta>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 156u8, 233u8, 150u8, 83u8, 80u8, 111u8, 149u8, 210u8,
                    238u8, 76u8, 158u8, 22u8, 106u8, 202u8, 6u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Time details of a corporate ballot associated with a CA."]
            #[doc = " The timestamps denote when voting starts and stops."]
            #[doc = ""]
            #[doc = " (CAId) => BallotTimeRange"]
            #[cfg(not(feature = "ink"))]
            pub async fn time_ranges(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_corporate_actions::ballot::BallotTimeRange>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 224u8, 44u8, 93u8, 167u8, 153u8, 243u8, 193u8, 143u8,
                    81u8, 133u8, 254u8, 177u8, 13u8, 204u8, 115u8, 80u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Time details of a corporate ballot associated with a CA."]
            #[doc = " The timestamps denote when voting starts and stops."]
            #[doc = ""]
            #[doc = " (CAId) => BallotTimeRange"]
            #[cfg(feature = "ink")]
            pub fn time_ranges(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_corporate_actions::ballot::BallotTimeRange>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 224u8, 44u8, 93u8, 167u8, 153u8, 243u8, 193u8, 143u8,
                    81u8, 133u8, 254u8, 177u8, 13u8, 204u8, 115u8, 80u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Stores how many choices there are in each motion."]
            #[doc = ""]
            #[doc = " At all times, the invariant holds that `motion_choices[idx]` is equal to"]
            #[doc = " `metas.unwrap().motions[idx].choices.len()`. That is, this is just a cache,"]
            #[doc = " used to avoid fetching all the motions with their associated texts."]
            #[doc = ""]
            #[doc = " `u16` choices should be more than enough to fit real use cases."]
            #[doc = ""]
            #[doc = " (CAId) => Number of choices in each motion."]
            #[cfg(not(feature = "ink"))]
            pub async fn motion_num_choices(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u16>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 128u8, 121u8, 46u8, 246u8, 146u8, 237u8, 189u8, 150u8,
                    253u8, 219u8, 95u8, 102u8, 195u8, 212u8, 151u8, 27u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<u16>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Stores how many choices there are in each motion."]
            #[doc = ""]
            #[doc = " At all times, the invariant holds that `motion_choices[idx]` is equal to"]
            #[doc = " `metas.unwrap().motions[idx].choices.len()`. That is, this is just a cache,"]
            #[doc = " used to avoid fetching all the motions with their associated texts."]
            #[doc = ""]
            #[doc = " `u16` choices should be more than enough to fit real use cases."]
            #[doc = ""]
            #[doc = " (CAId) => Number of choices in each motion."]
            #[cfg(feature = "ink")]
            pub fn motion_num_choices(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u16>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 128u8, 121u8, 46u8, 246u8, 146u8, 237u8, 189u8, 150u8,
                    253u8, 219u8, 95u8, 102u8, 195u8, 212u8, 151u8, 27u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<u16>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Is ranked choice voting (RCV) enabled for this ballot?"]
            #[doc = " For an understanding of how RCV is handled, see note on `BallotVote`'s `fallback` field."]
            #[doc = ""]
            #[doc = " (CAId) => bool"]
            #[cfg(not(feature = "ink"))]
            pub async fn rcv(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 255u8, 206u8, 156u8, 27u8, 141u8, 170u8, 167u8, 14u8,
                    136u8, 113u8, 191u8, 30u8, 171u8, 45u8, 90u8, 96u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Is ranked choice voting (RCV) enabled for this ballot?"]
            #[doc = " For an understanding of how RCV is handled, see note on `BallotVote`'s `fallback` field."]
            #[doc = ""]
            #[doc = " (CAId) => bool"]
            #[cfg(feature = "ink")]
            pub fn rcv(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 255u8, 206u8, 156u8, 27u8, 141u8, 170u8, 167u8, 14u8,
                    136u8, 113u8, 191u8, 30u8, 171u8, 45u8, 90u8, 96u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Stores the total vote tally on each choice."]
            #[doc = ""]
            #[doc = " RCV is not accounted for,"]
            #[doc = " as there are too many wants to interpret the graph,"]
            #[doc = " and because it would not be efficient."]
            #[doc = ""]
            #[doc = " (CAId) => [current vote weights]"]
            #[cfg(not(feature = "ink"))]
            pub async fn results(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::error::Result<::alloc::vec::Vec<u128>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 2u8, 53u8, 15u8, 184u8, 68u8, 197u8, 167u8, 101u8,
                    105u8, 101u8, 134u8, 40u8, 189u8, 68u8, 197u8, 62u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<u128>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Stores the total vote tally on each choice."]
            #[doc = ""]
            #[doc = " RCV is not accounted for,"]
            #[doc = " as there are too many wants to interpret the graph,"]
            #[doc = " and because it would not be efficient."]
            #[doc = ""]
            #[doc = " (CAId) => [current vote weights]"]
            #[cfg(feature = "ink")]
            pub fn results(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_ink::error::Result<::alloc::vec::Vec<u128>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 2u8, 53u8, 15u8, 184u8, 68u8, 197u8, 167u8, 101u8,
                    105u8, 101u8, 134u8, 40u8, 189u8, 68u8, 197u8, 62u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<u128>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Stores each DID's votes in a given ballot."]
            #[doc = " See the documentation of `BallotVote` for notes on semantics."]
            #[doc = ""]
            #[doc = " (CAId) => (DID) => [vote weight]"]
            #[doc = ""]
            #[doc = " User must enter 0 vote weight if they don't want to vote for a choice."]
            #[cfg(not(feature = "ink"))]
            pub async fn votes(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8,
                    230u8, 150u8, 237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                buf.extend(key_1.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < :: alloc :: vec :: Vec < types :: pallet_corporate_actions :: ballot :: BallotVote > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " Stores each DID's votes in a given ballot."]
            #[doc = " See the documentation of `BallotVote` for notes on semantics."]
            #[doc = ""]
            #[doc = " (CAId) => (DID) => [vote weight]"]
            #[doc = ""]
            #[doc = " User must enter 0 vote weight if they don't want to vote for a choice."]
            #[cfg(feature = "ink")]
            pub fn votes(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8,
                    230u8, 150u8, 237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                buf.extend(key_1.encode());
                let value = self.api.read_storage(buf)?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < :: alloc :: vec :: Vec < types :: pallet_corporate_actions :: ballot :: BallotVote > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::pallet_corporate_actions::ballot::Version,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_corporate_actions::ballot::Version>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_corporate_actions::ballot::Version>
            {
                let value = self.api.read_storage(::alloc::vec![
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_corporate_actions::ballot::Version>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct CorporateBallotPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> CorporateBallotPagedQueryApi<'api> {
            #[doc = " Metadata of a corporate ballot."]
            #[doc = ""]
            #[doc = " (CAId) => BallotMeta"]
            pub fn metas(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_corporate_actions::CAId,
                types::pallet_corporate_actions::ballot::BallotMeta,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 156u8, 233u8, 150u8, 83u8, 80u8, 111u8, 149u8, 210u8,
                    238u8, 76u8, 158u8, 22u8, 106u8, 202u8, 6u8, 64u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Time details of a corporate ballot associated with a CA."]
            #[doc = " The timestamps denote when voting starts and stops."]
            #[doc = ""]
            #[doc = " (CAId) => BallotTimeRange"]
            pub fn time_ranges(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_corporate_actions::CAId,
                types::pallet_corporate_actions::ballot::BallotTimeRange,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 224u8, 44u8, 93u8, 167u8, 153u8, 243u8, 193u8, 143u8,
                    81u8, 133u8, 254u8, 177u8, 13u8, 204u8, 115u8, 80u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Stores how many choices there are in each motion."]
            #[doc = ""]
            #[doc = " At all times, the invariant holds that `motion_choices[idx]` is equal to"]
            #[doc = " `metas.unwrap().motions[idx].choices.len()`. That is, this is just a cache,"]
            #[doc = " used to avoid fetching all the motions with their associated texts."]
            #[doc = ""]
            #[doc = " `u16` choices should be more than enough to fit real use cases."]
            #[doc = ""]
            #[doc = " (CAId) => Number of choices in each motion."]
            pub fn motion_num_choices(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_corporate_actions::CAId,
                ::alloc::vec::Vec<u16>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 128u8, 121u8, 46u8, 246u8, 146u8, 237u8, 189u8, 150u8,
                    253u8, 219u8, 95u8, 102u8, 195u8, 212u8, 151u8, 27u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Is ranked choice voting (RCV) enabled for this ballot?"]
            #[doc = " For an understanding of how RCV is handled, see note on `BallotVote`'s `fallback` field."]
            #[doc = ""]
            #[doc = " (CAId) => bool"]
            pub fn rcv(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<types::pallet_corporate_actions::CAId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 255u8, 206u8, 156u8, 27u8, 141u8, 170u8, 167u8, 14u8,
                    136u8, 113u8, 191u8, 30u8, 171u8, 45u8, 90u8, 96u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Stores the total vote tally on each choice."]
            #[doc = ""]
            #[doc = " RCV is not accounted for,"]
            #[doc = " as there are too many wants to interpret the graph,"]
            #[doc = " and because it would not be efficient."]
            #[doc = ""]
            #[doc = " (CAId) => [current vote weights]"]
            pub fn results(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_corporate_actions::CAId,
                ::alloc::vec::Vec<u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 2u8, 53u8, 15u8, 184u8, 68u8, 197u8, 167u8, 101u8,
                    105u8, 101u8, 134u8, 40u8, 189u8, 68u8, 197u8, 62u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Stores each DID's votes in a given ballot."]
            #[doc = " See the documentation of `BallotVote` for notes on semantics."]
            #[doc = ""]
            #[doc = " (CAId) => (DID) => [vote weight]"]
            #[doc = ""]
            #[doc = " User must enter 0 vote weight if they don't want to vote for a choice."]
            pub fn votes(
                &self,
                key_0: types::pallet_corporate_actions::CAId,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::IdentityId,
                ::alloc::vec::Vec<types::pallet_corporate_actions::ballot::BallotVote>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    231u8, 254u8, 118u8, 5u8, 155u8, 236u8, 50u8, 215u8, 156u8, 69u8, 147u8, 235u8,
                    7u8, 48u8, 134u8, 127u8, 180u8, 173u8, 198u8, 161u8, 206u8, 79u8, 124u8, 194u8,
                    230u8, 150u8, 237u8, 15u8, 208u8, 107u8, 208u8, 28u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
        }
    }
    pub mod permissions {
        use super::*;
        #[derive(Clone)]
        pub struct PermissionsCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> PermissionsCallApi<'api> {}
        impl<'api> From<&'api super::super::Api> for PermissionsCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct PermissionsQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> PermissionsQueryApi<'api> {
            #[doc = " The name of the current pallet (aka module name)."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_pallet_name(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::PalletName>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    194u8, 182u8, 172u8, 73u8, 238u8, 19u8, 27u8, 228u8, 222u8, 85u8, 39u8, 162u8,
                    204u8, 171u8, 74u8, 103u8, 27u8, 153u8, 117u8, 110u8, 137u8, 126u8, 179u8,
                    78u8, 63u8, 191u8, 84u8, 144u8, 213u8, 155u8, 104u8, 39u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::PalletName>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The name of the current pallet (aka module name)."]
            #[cfg(feature = "ink")]
            pub fn current_pallet_name(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::PalletName>
            {
                let value = self.api.read_storage(::alloc::vec![
                    194u8, 182u8, 172u8, 73u8, 238u8, 19u8, 27u8, 228u8, 222u8, 85u8, 39u8, 162u8,
                    204u8, 171u8, 74u8, 103u8, 27u8, 153u8, 117u8, 110u8, 137u8, 126u8, 179u8,
                    78u8, 63u8, 191u8, 84u8, 144u8, 213u8, 155u8, 104u8, 39u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::PalletName>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The name of the current function (aka extrinsic)."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_dispatchable_name(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::ExtrinsicName>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    194u8, 182u8, 172u8, 73u8, 238u8, 19u8, 27u8, 228u8, 222u8, 85u8, 39u8, 162u8,
                    204u8, 171u8, 74u8, 103u8, 86u8, 93u8, 19u8, 238u8, 55u8, 201u8, 117u8, 107u8,
                    83u8, 238u8, 82u8, 232u8, 250u8, 137u8, 106u8, 86u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::ExtrinsicName>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The name of the current function (aka extrinsic)."]
            #[cfg(feature = "ink")]
            pub fn current_dispatchable_name(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::ExtrinsicName>
            {
                let value = self.api.read_storage(::alloc::vec![
                    194u8, 182u8, 172u8, 73u8, 238u8, 19u8, 27u8, 228u8, 222u8, 85u8, 39u8, 162u8,
                    204u8, 171u8, 74u8, 103u8, 86u8, 93u8, 19u8, 238u8, 55u8, 201u8, 117u8, 107u8,
                    83u8, 238u8, 82u8, 232u8, 250u8, 137u8, 106u8, 86u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::ExtrinsicName>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct PermissionsPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> PermissionsPagedQueryApi<'api> {}
    }
    pub mod pips {
        use super::*;
        #[derive(Clone)]
        pub struct PipsCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> PipsCallApi<'api> {
            #[doc = "Sets the pruning setting for historical PIPs. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `prune` - A boolean flag indicating whether completed PIPs should be pruned (`true`) or retained (`false`)."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `HistoricalPipsPruned` - Emitted when the pruning setting is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(not(feature = "ink"))]
            pub fn set_prune_historical_pips(
                &self,
                prune: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::set_prune_historical_pips { prune },
                ))
            }
            #[doc = "Sets the pruning setting for historical PIPs. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `prune` - A boolean flag indicating whether completed PIPs should be pruned (`true`) or retained (`false`)."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `HistoricalPipsPruned` - Emitted when the pruning setting is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(feature = "ink")]
            pub fn set_prune_historical_pips(&self, prune: bool) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 0u8];
                prune.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the minimum proposal deposit amount required to start a proposal. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `deposit` - The new minimum deposit required to start a proposal."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `MinimumProposalDepositChanged` - Emitted when the minimum proposal deposit is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(not(feature = "ink"))]
            pub fn set_min_proposal_deposit(
                &self,
                deposit: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::set_min_proposal_deposit { deposit },
                ))
            }
            #[doc = "Changes the minimum proposal deposit amount required to start a proposal. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `deposit` - The new minimum deposit required to start a proposal."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `MinimumProposalDepositChanged` - Emitted when the minimum proposal deposit is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(feature = "ink")]
            pub fn set_min_proposal_deposit(&self, deposit: u128) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 1u8];
                deposit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the default enactment period. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `period` - The new default enactment period."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `DefaultEnactmentPeriodChanged` - Emitted when the default enactment period is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(not(feature = "ink"))]
            pub fn set_default_enactment_period(
                &self,
                duration: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::set_default_enactment_period { duration },
                ))
            }
            #[doc = "Changes the default enactment period. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `period` - The new default enactment period."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `DefaultEnactmentPeriodChanged` - Emitted when the default enactment period is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(feature = "ink")]
            pub fn set_default_enactment_period(&self, duration: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 2u8];
                duration.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Sets the expiry duration (in blocks) for pending PIPs. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `expiry` - The new expiry duration for pending PIPs. If `None`, PIPs never expire."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `PendingPipExpiryChanged` - Emitted when the pending PIP expiry duration is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(not(feature = "ink"))]
            pub fn set_pending_pip_expiry(
                &self,
                expiry: types::polymesh_primitives::MaybeBlock<u32>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::set_pending_pip_expiry { expiry },
                ))
            }
            #[doc = "Sets the expiry duration (in blocks) for pending PIPs. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `expiry` - The new expiry duration for pending PIPs. If `None`, PIPs never expire."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `PendingPipExpiryChanged` - Emitted when the pending PIP expiry duration is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(feature = "ink")]
            pub fn set_pending_pip_expiry(
                &self,
                expiry: types::polymesh_primitives::MaybeBlock<u32>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 3u8];
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Sets the maximum number of times a PIP can be skipped. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `max` - The new maximum skip count for PIPs."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `MaxPipSkipCountChanged` - Emitted when the maximum PIP skip count is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(not(feature = "ink"))]
            pub fn set_max_pip_skip_count(
                &self,
                max: u8,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::set_max_pip_skip_count { max },
                ))
            }
            #[doc = "Sets the maximum number of times a PIP can be skipped. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `max` - The new maximum skip count for PIPs."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `MaxPipSkipCountChanged` - Emitted when the maximum PIP skip count is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(feature = "ink")]
            pub fn set_max_pip_skip_count(&self, max: u8) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 4u8];
                max.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Sets the limit on the number of active PIPs. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `limit` - The new limit on the number of active PIPs."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `ActivePipLimitChanged` - Emitted when the active PIP limit is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(not(feature = "ink"))]
            pub fn set_active_pip_limit(
                &self,
                limit: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::set_active_pip_limit { limit },
                ))
            }
            #[doc = "Sets the limit on the number of active PIPs. This function can only be called by the root origin."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `limit` - The new limit on the number of active PIPs."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `ActivePipLimitChanged` - Emitted when the active PIP limit is changed, containing the old and new values."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[cfg(feature = "ink")]
            pub fn set_active_pip_limit(&self, limit: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 5u8];
                limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Proposes a new PIP by submitting a dispatchable which changes the network."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call."]
            #[doc = "* `proposal` - The dispatchable call."]
            #[doc = "* `deposit` - The deposit amount for the proposal."]
            #[doc = "* `url` - A link to a website for proposal discussion."]
            #[doc = "* `description` - A short description of the proposal."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `ProposalCreated`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `IncorrectDeposit` - If the deposit amount is less than the required minimum."]
            #[doc = "* `TooManyActivePips` - If the number of active PIPs exceeds the maximum."]
            #[cfg(not(feature = "ink"))]
            pub fn propose(
                &self,
                proposal: runtime::RuntimeCall,
                deposit: u128,
                url: Option<types::polymesh_primitives::Url>,
                description: Option<types::pallet_pips::types::PipDescription>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::propose {
                        proposal: ::alloc::boxed::Box::new(proposal),
                        deposit,
                        url,
                        description,
                    },
                ))
            }
            #[doc = "Proposes a new PIP by submitting a dispatchable which changes the network."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call."]
            #[doc = "* `proposal` - The dispatchable call."]
            #[doc = "* `deposit` - The deposit amount for the proposal."]
            #[doc = "* `url` - A link to a website for proposal discussion."]
            #[doc = "* `description` - A short description of the proposal."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `ProposalCreated`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `IncorrectDeposit` - If the deposit amount is less than the required minimum."]
            #[doc = "* `TooManyActivePips` - If the number of active PIPs exceeds the maximum."]
            #[cfg(feature = "ink")]
            pub fn propose(
                &self,
                proposal: runtime::RuntimeCall,
                deposit: u128,
                url: Option<types::polymesh_primitives::Url>,
                description: Option<types::pallet_pips::types::PipDescription>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 6u8];
                proposal.encode_to(&mut buf);
                deposit.encode_to(&mut buf);
                url.encode_to(&mut buf);
                description.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Casts a vote either in favor or against a PIP with `id`."]
            #[doc = "The \"conviction\" or strength of the vote is given by `deposit`, which is reserved."]
            #[doc = ""]
            #[doc = "Note that `vote` is *not* additive."]
            #[doc = "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`"]
            #[doc = "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit."]
            #[doc = "To add atop of existing votes, you'll need `existing_deposit + addition`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call."]
            #[doc = "* `id` - The proposal ID to vote on."]
            #[doc = "* `aye_or_nay` - A boolean representing a vote in favor (`true`) or against (`false`)."]
            #[doc = "* `deposit` - The \"conviction\" or strength of the vote, represented by the amount of deposit."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `Voted` - Emitted when a vote is successfully cast."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NoSuchProposal` - If the `id` does not reference a valid PIP."]
            #[doc = "* `NotFromCommunity` - If the proposal was made by a committee."]
            #[doc = "* `IncorrectProposalState` - If the PIP is not in a pending state."]
            #[doc = "* `InsufficientDeposit` - If the `origin` cannot reserve the required deposit."]
            #[doc = "* `IncorrectDeposit` - If the deposit amount is less than the required minimum."]
            #[cfg(not(feature = "ink"))]
            pub fn vote(
                &self,
                id: types::pallet_pips::types::PipId,
                aye_or_nay: bool,
                deposit: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::vote {
                        id,
                        aye_or_nay,
                        deposit,
                    },
                ))
            }
            #[doc = "Casts a vote either in favor or against a PIP with `id`."]
            #[doc = "The \"conviction\" or strength of the vote is given by `deposit`, which is reserved."]
            #[doc = ""]
            #[doc = "Note that `vote` is *not* additive."]
            #[doc = "That is, `vote(id, true, 50)` followed by `vote(id, true, 40)`"]
            #[doc = "will first reserve `50` and then refund `50 - 10`, ending up with `40` in deposit."]
            #[doc = "To add atop of existing votes, you'll need `existing_deposit + addition`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call."]
            #[doc = "* `id` - The proposal ID to vote on."]
            #[doc = "* `aye_or_nay` - A boolean representing a vote in favor (`true`) or against (`false`)."]
            #[doc = "* `deposit` - The \"conviction\" or strength of the vote, represented by the amount of deposit."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `Voted` - Emitted when a vote is successfully cast."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NoSuchProposal` - If the `id` does not reference a valid PIP."]
            #[doc = "* `NotFromCommunity` - If the proposal was made by a committee."]
            #[doc = "* `IncorrectProposalState` - If the PIP is not in a pending state."]
            #[doc = "* `InsufficientDeposit` - If the `origin` cannot reserve the required deposit."]
            #[doc = "* `IncorrectDeposit` - If the deposit amount is less than the required minimum."]
            #[cfg(feature = "ink")]
            pub fn vote(
                &self,
                id: types::pallet_pips::types::PipId,
                aye_or_nay: bool,
                deposit: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 7u8];
                id.encode_to(&mut buf);
                aye_or_nay.encode_to(&mut buf);
                deposit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Approves the pending committee PIP given by the `id`."]
            #[doc = ""]
            #[doc = "This function can only be called by a Governance Committee (GC) voting majority."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
            #[doc = "* `id` - The proposal ID of the PIP to be approved."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
            #[doc = "* `NoSuchProposal` - If the PIP with the given `id` does not exist."]
            #[doc = "* `IncorrectProposalState` - If the proposal is not in a pending state."]
            #[doc = "* `NotByCommittee` - If the proposal was not made by a committee."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function schedules the PIP for execution if all checks pass."]
            #[cfg(not(feature = "ink"))]
            pub fn approve_committee_proposal(
                &self,
                id: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::approve_committee_proposal { id },
                ))
            }
            #[doc = "Approves the pending committee PIP given by the `id`."]
            #[doc = ""]
            #[doc = "This function can only be called by a Governance Committee (GC) voting majority."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
            #[doc = "* `id` - The proposal ID of the PIP to be approved."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
            #[doc = "* `NoSuchProposal` - If the PIP with the given `id` does not exist."]
            #[doc = "* `IncorrectProposalState` - If the proposal is not in a pending state."]
            #[doc = "* `NotByCommittee` - If the proposal was not made by a committee."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function schedules the PIP for execution if all checks pass."]
            #[cfg(feature = "ink")]
            pub fn approve_committee_proposal(
                &self,
                id: types::pallet_pips::types::PipId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 8u8];
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Rejects the PIP given by the `id`. Bonded funds will be refunded, assuming it hasn't"]
            #[doc = "been cancelled or executed."]
            #[doc = ""]
            #[doc = "This function can only be called by a Governance Committee (GC) voting majority."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
            #[doc = "* `id` - The proposal ID of the PIP to be rejected."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
            #[doc = "* `NoSuchProposal` - If the PIP with the given `id` does not exist."]
            #[doc = "* `IncorrectProposalState` - If the proposal was cancelled or executed."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function will unschedule the PIP if it was scheduled for execution and will"]
            #[doc = "unsnapshot the PIP if it was part of a snapshot. It will also handle the rejection"]
            #[doc = "of the proposal and refund any bonded funds."]
            #[cfg(not(feature = "ink"))]
            pub fn reject_proposal(
                &self,
                id: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::reject_proposal { id },
                ))
            }
            #[doc = "Rejects the PIP given by the `id`. Bonded funds will be refunded, assuming it hasn't"]
            #[doc = "been cancelled or executed."]
            #[doc = ""]
            #[doc = "This function can only be called by a Governance Committee (GC) voting majority."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
            #[doc = "* `id` - The proposal ID of the PIP to be rejected."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
            #[doc = "* `NoSuchProposal` - If the PIP with the given `id` does not exist."]
            #[doc = "* `IncorrectProposalState` - If the proposal was cancelled or executed."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function will unschedule the PIP if it was scheduled for execution and will"]
            #[doc = "unsnapshot the PIP if it was part of a snapshot. It will also handle the rejection"]
            #[doc = "of the proposal and refund any bonded funds."]
            #[cfg(feature = "ink")]
            pub fn reject_proposal(
                &self,
                id: types::pallet_pips::types::PipId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 9u8];
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Prunes the PIP given by the `id`. The PIP must not be active."]
            #[doc = ""]
            #[doc = "This function is intended for storage garbage collection purposes and can only be called by a Governance Committee (GC) voting majority."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
            #[doc = "* `id` - The proposal ID of the PIP to be pruned."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
            #[doc = "* `NoSuchProposal` - If the PIP with the given `id` does not exist."]
            #[doc = "* `IncorrectProposalState` - If the proposal is active."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function will remove the PIP from storage and refund any remaining bonded funds."]
            #[cfg(not(feature = "ink"))]
            pub fn prune_proposal(
                &self,
                id: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::prune_proposal { id },
                ))
            }
            #[doc = "Prunes the PIP given by the `id`. The PIP must not be active."]
            #[doc = ""]
            #[doc = "This function is intended for storage garbage collection purposes and can only be called by a Governance Committee (GC) voting majority."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
            #[doc = "* `id` - The proposal ID of the PIP to be pruned."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
            #[doc = "* `NoSuchProposal` - If the PIP with the given `id` does not exist."]
            #[doc = "* `IncorrectProposalState` - If the proposal is active."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function will remove the PIP from storage and refund any remaining bonded funds."]
            #[cfg(feature = "ink")]
            pub fn prune_proposal(
                &self,
                id: types::pallet_pips::types::PipId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 10u8];
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Updates the execution schedule of the PIP given by `id`."]
            #[doc = "This function can only be called by the release coordinator."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the release coordinator."]
            #[doc = "* `id` - The proposal ID of the PIP to be rescheduled."]
            #[doc = "* `until` - An optional future block number where the enactment period will finish."]
            #[doc = "   If `None`, the enactment period will finish in the next block."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `RescheduleNotByReleaseCoordinator` - If the call is not made by the release coordinator."]
            #[doc = "* `IncorrectProposalState` - If the proposal is not in a scheduled state."]
            #[doc = "* `InvalidFutureBlockNumber` - If the provided block number is not a valid future block number."]
            #[cfg(not(feature = "ink"))]
            pub fn reschedule_execution(
                &self,
                id: types::pallet_pips::types::PipId,
                until: Option<u32>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::reschedule_execution { id, until },
                ))
            }
            #[doc = "Updates the execution schedule of the PIP given by `id`."]
            #[doc = "This function can only be called by the release coordinator."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the release coordinator."]
            #[doc = "* `id` - The proposal ID of the PIP to be rescheduled."]
            #[doc = "* `until` - An optional future block number where the enactment period will finish."]
            #[doc = "   If `None`, the enactment period will finish in the next block."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `RescheduleNotByReleaseCoordinator` - If the call is not made by the release coordinator."]
            #[doc = "* `IncorrectProposalState` - If the proposal is not in a scheduled state."]
            #[doc = "* `InvalidFutureBlockNumber` - If the provided block number is not a valid future block number."]
            #[cfg(feature = "ink")]
            pub fn reschedule_execution(
                &self,
                id: types::pallet_pips::types::PipId,
                until: Option<u32>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 11u8];
                id.encode_to(&mut buf);
                until.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Clears the snapshot and emits the event `SnapshotCleared`."]
            #[doc = ""]
            #[doc = "This function can only be called by a Governance Committee (GC) member."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC member."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `SnapshotCleared` - Emitted when the snapshot is successfully cleared, containing the ID of the cleared snapshot."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotACommitteeMember` - If the call is not made by a GC member."]
            #[cfg(not(feature = "ink"))]
            pub fn clear_snapshot(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::clear_snapshot,
                ))
            }
            #[doc = "Clears the snapshot and emits the event `SnapshotCleared`."]
            #[doc = ""]
            #[doc = "This function can only be called by a Governance Committee (GC) member."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC member."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `SnapshotCleared` - Emitted when the snapshot is successfully cleared, containing the ID of the cleared snapshot."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotACommitteeMember` - If the call is not made by a GC member."]
            #[cfg(feature = "ink")]
            pub fn clear_snapshot(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![33u8, 12u8])
            }
            #[doc = "Takes a new snapshot of the current list of active and pending PIPs."]
            #[doc = "The PIPs are then sorted into a priority queue based on each PIP's weight."]
            #[doc = ""]
            #[doc = "This function can only be called by a Governance Committee (GC) member."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC member."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `SnapshotTaken` - Emitted when a snapshot is successfully taken, containing the ID of the snapshot and the queue of PIPs."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotACommitteeMember` - If the call is not made by a GC member."]
            #[cfg(not(feature = "ink"))]
            pub fn snapshot(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::snapshot,
                ))
            }
            #[doc = "Takes a new snapshot of the current list of active and pending PIPs."]
            #[doc = "The PIPs are then sorted into a priority queue based on each PIP's weight."]
            #[doc = ""]
            #[doc = "This function can only be called by a Governance Committee (GC) member."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC member."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `SnapshotTaken` - Emitted when a snapshot is successfully taken, containing the ID of the snapshot and the queue of PIPs."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `NotACommitteeMember` - If the call is not made by a GC member."]
            #[cfg(feature = "ink")]
            pub fn snapshot(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![33u8, 13u8])
            }
            #[doc = "Enacts the results for the PIPs in the snapshot queue."]
            #[doc = ""]
            #[doc = "The snapshot will be available for further enactments until it is cleared."]
            #[doc = ""]
            #[doc = "The `results` parameter is a list of `(id, result)` tuples where `result` is applied to the PIP with the given `id`."]
            #[doc = "Note that the snapshot priority queue is encoded with the *lowest priority first*."]
            #[doc = "For example, `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
            #[doc = "* `results` - A vector of tuples where each tuple contains a PIP ID and a `SnapshotResult` (either `Approve`, `Reject`, or `Skip`)."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `SnapshotResultsEnacted` - Emitted when the snapshot results are successfully enacted, containing the ID of the snapshot and the actions taken."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
            #[doc = "* `CannotSkipPip` - If a given PIP has already been skipped too many times."]
            #[doc = "* `SnapshotResultTooLarge` - If the length of `results` is greater than the length of the snapshot queue."]
            #[doc = "* `SnapshotIdMismatch` - If there is a mismatch between the PIP IDs in `results` and the snapshot queue."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function will:"]
            #[doc = "- Update the skip counts for PIPs that are skipped."]
            #[doc = "- Reject PIPs that are marked for rejection and refund any bonded funds."]
            #[doc = "- Approve PIPs that are marked for approval and schedule them for execution."]
            #[cfg(not(feature = "ink"))]
            pub fn enact_snapshot_results(
                &self,
                results: ::alloc::vec::Vec<(
                    types::pallet_pips::types::PipId,
                    types::pallet_pips::types::SnapshotResult,
                )>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::enact_snapshot_results { results },
                ))
            }
            #[doc = "Enacts the results for the PIPs in the snapshot queue."]
            #[doc = ""]
            #[doc = "The snapshot will be available for further enactments until it is cleared."]
            #[doc = ""]
            #[doc = "The `results` parameter is a list of `(id, result)` tuples where `result` is applied to the PIP with the given `id`."]
            #[doc = "Note that the snapshot priority queue is encoded with the *lowest priority first*."]
            #[doc = "For example, `results = [(id, Approve)]` will approve `SnapshotQueue[SnapshotQueue.len() - 1]`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be a GC voting majority."]
            #[doc = "* `results` - A vector of tuples where each tuple contains a PIP ID and a `SnapshotResult` (either `Approve`, `Reject`, or `Skip`)."]
            #[doc = ""]
            #[doc = "# Events"]
            #[doc = "* `SnapshotResultsEnacted` - Emitted when the snapshot results are successfully enacted, containing the ID of the snapshot and the actions taken."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by a GC voting majority."]
            #[doc = "* `CannotSkipPip` - If a given PIP has already been skipped too many times."]
            #[doc = "* `SnapshotResultTooLarge` - If the length of `results` is greater than the length of the snapshot queue."]
            #[doc = "* `SnapshotIdMismatch` - If there is a mismatch between the PIP IDs in `results` and the snapshot queue."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function will:"]
            #[doc = "- Update the skip counts for PIPs that are skipped."]
            #[doc = "- Reject PIPs that are marked for rejection and refund any bonded funds."]
            #[doc = "- Approve PIPs that are marked for approval and schedule them for execution."]
            #[cfg(feature = "ink")]
            pub fn enact_snapshot_results(
                &self,
                results: ::alloc::vec::Vec<(
                    types::pallet_pips::types::PipId,
                    types::pallet_pips::types::SnapshotResult,
                )>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 14u8];
                results.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Executes a scheduled PIP (Polymesh Improvement Proposal)."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `id` - The unique identifier of the PIP to be executed."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function will:"]
            #[doc = "- Remove the PIP from the scheduling queue."]
            #[doc = "- Execute the proposal associated with the PIP."]
            #[cfg(not(feature = "ink"))]
            pub fn execute_scheduled_pip(
                &self,
                id: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::execute_scheduled_pip { id },
                ))
            }
            #[doc = "Executes a scheduled PIP (Polymesh Improvement Proposal)."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `id` - The unique identifier of the PIP to be executed."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function will:"]
            #[doc = "- Remove the PIP from the scheduling queue."]
            #[doc = "- Execute the proposal associated with the PIP."]
            #[cfg(feature = "ink")]
            pub fn execute_scheduled_pip(
                &self,
                id: types::pallet_pips::types::PipId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 15u8];
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Expires a scheduled PIP (Polymesh Improvement Proposal)."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `did` - The identity ID of the entity initiating the expiration."]
            #[doc = "* `id` - The unique identifier of the PIP to be expired."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function will:"]
            #[doc = "- Check if the PIP is in a pending state."]
            #[doc = "- Unsnapshot the PIP if it was part of a snapshot."]
            #[doc = "- Prune the PIP data if it is in an expired state."]
            #[cfg(not(feature = "ink"))]
            pub fn expire_scheduled_pip(
                &self,
                did: ::polymesh_api_client::IdentityId,
                id: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Pips(
                    types::pallet_pips::pallet::PipsCall::expire_scheduled_pip { did, id },
                ))
            }
            #[doc = "Expires a scheduled PIP (Polymesh Improvement Proposal)."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, which must be the root."]
            #[doc = "* `did` - The identity ID of the entity initiating the expiration."]
            #[doc = "* `id` - The unique identifier of the PIP to be expired."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - If the call is not made by the root origin."]
            #[doc = ""]
            #[doc = "# Notes"]
            #[doc = "This function will:"]
            #[doc = "- Check if the PIP is in a pending state."]
            #[doc = "- Unsnapshot the PIP if it was part of a snapshot."]
            #[doc = "- Prune the PIP data if it is in an expired state."]
            #[cfg(feature = "ink")]
            pub fn expire_scheduled_pip(
                &self,
                did: ::polymesh_api_client::IdentityId,
                id: types::pallet_pips::types::PipId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![33u8, 16u8];
                did.encode_to(&mut buf);
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for PipsCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct PipsQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> PipsQueryApi<'api> {
            #[doc = " Set to `true` if historical PIPs data must be removed."]
            #[cfg(not(feature = "ink"))]
            pub async fn prune_historical_pips(
                &self,
            ) -> ::polymesh_api_client::error::Result<bool> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 189u8, 16u8, 192u8, 60u8, 149u8, 36u8, 81u8,
                    199u8, 53u8, 30u8, 52u8, 222u8, 47u8, 68u8, 166u8, 44u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Set to `true` if historical PIPs data must be removed."]
            #[cfg(feature = "ink")]
            pub fn prune_historical_pips(&self) -> ::polymesh_api_ink::error::Result<bool> {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 189u8, 16u8, 192u8, 60u8, 149u8, 36u8, 81u8,
                    199u8, 53u8, 30u8, 52u8, 222u8, 47u8, 68u8, 166u8, 44u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The minimum amount to be used as a deposit for community PIP creation."]
            #[cfg(not(feature = "ink"))]
            pub async fn minimum_proposal_deposit(
                &self,
            ) -> ::polymesh_api_client::error::Result<u128> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 142u8, 186u8, 24u8, 71u8, 175u8, 165u8,
                    243u8, 64u8, 139u8, 26u8, 206u8, 10u8, 193u8, 132u8, 103u8, 2u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The minimum amount to be used as a deposit for community PIP creation."]
            #[cfg(feature = "ink")]
            pub fn minimum_proposal_deposit(&self) -> ::polymesh_api_ink::error::Result<u128> {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 142u8, 186u8, 24u8, 71u8, 175u8, 165u8,
                    243u8, 64u8, 139u8, 26u8, 206u8, 10u8, 193u8, 132u8, 103u8, 2u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Default enactment period that will be use after a proposal is accepted by GC."]
            #[cfg(not(feature = "ink"))]
            pub async fn default_enactment_period(
                &self,
            ) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 51u8, 170u8, 252u8, 74u8, 212u8, 72u8, 38u8,
                    0u8, 53u8, 50u8, 101u8, 120u8, 239u8, 111u8, 130u8, 18u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Default enactment period that will be use after a proposal is accepted by GC."]
            #[cfg(feature = "ink")]
            pub fn default_enactment_period(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 51u8, 170u8, 252u8, 74u8, 212u8, 72u8, 38u8,
                    0u8, 53u8, 50u8, 101u8, 120u8, 239u8, 111u8, 130u8, 18u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Number of blocks it will take, after a `Pending` PIP expires, assuming it has not transitioned to another `ProposalState`."]
            #[cfg(not(feature = "ink"))]
            pub async fn pending_pip_expiry(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::MaybeBlock<u32>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 58u8, 147u8, 255u8, 239u8, 101u8, 133u8, 6u8,
                    145u8, 79u8, 53u8, 65u8, 205u8, 53u8, 56u8, 227u8, 209u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8];
                    <types::polymesh_primitives::MaybeBlock<u32>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Number of blocks it will take, after a `Pending` PIP expires, assuming it has not transitioned to another `ProposalState`."]
            #[cfg(feature = "ink")]
            pub fn pending_pip_expiry(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::MaybeBlock<u32>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 58u8, 147u8, 255u8, 239u8, 101u8, 133u8, 6u8,
                    145u8, 79u8, 53u8, 65u8, 205u8, 53u8, 56u8, 227u8, 209u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8];
                    <types::polymesh_primitives::MaybeBlock<u32>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Maximum times a PIP can be skipped before triggering `CannotSkipPip` in `enact_snapshot_results`."]
            #[cfg(not(feature = "ink"))]
            pub async fn max_pip_skip_count(&self) -> ::polymesh_api_client::error::Result<u8> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 220u8, 153u8, 145u8, 58u8, 218u8, 242u8,
                    187u8, 63u8, 0u8, 101u8, 235u8, 95u8, 125u8, 163u8, 103u8, 164u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <u8>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Maximum times a PIP can be skipped before triggering `CannotSkipPip` in `enact_snapshot_results`."]
            #[cfg(feature = "ink")]
            pub fn max_pip_skip_count(&self) -> ::polymesh_api_ink::error::Result<u8> {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 220u8, 153u8, 145u8, 58u8, 218u8, 242u8,
                    187u8, 63u8, 0u8, 101u8, 235u8, 95u8, 125u8, 163u8, 103u8, 164u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <u8>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The maximum allowed number for active PIPs. Once reached, new PIPs cannot be proposed by community members."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_pip_limit(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 142u8, 176u8, 200u8, 221u8, 213u8, 71u8,
                    139u8, 145u8, 46u8, 82u8, 219u8, 155u8, 155u8, 174u8, 243u8, 103u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The maximum allowed number for active PIPs. Once reached, new PIPs cannot be proposed by community members."]
            #[cfg(feature = "ink")]
            pub fn active_pip_limit(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 142u8, 176u8, 200u8, 221u8, 213u8, 71u8,
                    139u8, 145u8, 46u8, 82u8, 219u8, 155u8, 155u8, 174u8, 243u8, 103u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Proposal's identifier."]
            #[cfg(not(feature = "ink"))]
            pub async fn pip_id_sequence(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_pips::types::PipId>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 89u8, 187u8, 247u8, 248u8, 106u8, 18u8, 26u8,
                    188u8, 148u8, 170u8, 211u8, 21u8, 5u8, 34u8, 135u8, 100u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::pallet_pips::types::PipId>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Proposal's identifier."]
            #[cfg(feature = "ink")]
            pub fn pip_id_sequence(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::types::PipId> {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 89u8, 187u8, 247u8, 248u8, 106u8, 18u8, 26u8,
                    188u8, 148u8, 170u8, 211u8, 21u8, 5u8, 34u8, 135u8, 100u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::pallet_pips::types::PipId>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Snaphot's identifier."]
            #[cfg(not(feature = "ink"))]
            pub async fn snapshot_id_sequence(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_pips::types::SnapshotId>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 6u8, 175u8, 149u8, 151u8, 152u8, 112u8,
                    164u8, 18u8, 129u8, 2u8, 178u8, 5u8, 64u8, 255u8, 210u8, 228u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::pallet_pips::types::SnapshotId>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Snaphot's identifier."]
            #[cfg(feature = "ink")]
            pub fn snapshot_id_sequence(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::types::SnapshotId>
            {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 6u8, 175u8, 149u8, 151u8, 152u8, 112u8,
                    164u8, 18u8, 129u8, 2u8, 178u8, 5u8, 64u8, 255u8, 210u8, 228u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::pallet_pips::types::SnapshotId>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Total count of pending or scheduled PIPs."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_pip_count(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 160u8, 15u8, 19u8, 210u8, 89u8, 80u8, 103u8,
                    48u8, 205u8, 26u8, 95u8, 188u8, 201u8, 27u8, 117u8, 206u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Total count of pending or scheduled PIPs."]
            #[cfg(feature = "ink")]
            pub fn active_pip_count(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 160u8, 15u8, 19u8, 210u8, 89u8, 80u8, 103u8,
                    48u8, 205u8, 26u8, 95u8, 188u8, 201u8, 27u8, 117u8, 206u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The [`PipsMetadata`] for each proposal ([`PipId`])."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_metadata(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_pips::types::PipsMetadata<u32>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 84u8, 36u8, 238u8, 140u8, 56u8, 250u8, 92u8,
                    7u8, 255u8, 42u8, 121u8, 197u8, 145u8, 184u8, 96u8, 30u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The [`PipsMetadata`] for each proposal ([`PipId`])."]
            #[cfg(feature = "ink")]
            pub fn proposal_metadata(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_pips::types::PipsMetadata<u32>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 84u8, 36u8, 238u8, 140u8, 56u8, 250u8, 92u8,
                    7u8, 255u8, 42u8, 121u8, 197u8, 145u8, 184u8, 96u8, 30u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " All locked [`DepositInfo`] per [`PipId`] for each account."]
            #[cfg(not(feature = "ink"))]
            pub async fn deposits(
                &self,
                key_0: types::pallet_pips::types::PipId,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_pips::types::DepositInfo<::polymesh_api_client::AccountId>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 116u8, 166u8, 20u8, 219u8, 128u8, 33u8,
                    198u8, 189u8, 10u8, 2u8, 138u8, 175u8, 223u8, 41u8, 221u8, 8u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " All locked [`DepositInfo`] per [`PipId`] for each account."]
            #[cfg(feature = "ink")]
            pub fn deposits(
                &self,
                key_0: types::pallet_pips::types::PipId,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_pips::types::DepositInfo<::polymesh_api_client::AccountId>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 116u8, 166u8, 20u8, 219u8, 128u8, 33u8,
                    198u8, 189u8, 10u8, 2u8, 138u8, 175u8, 223u8, 41u8, 221u8, 8u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The [`Pip`] for each proposal ([`PipId`])."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposals(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::pallet_pips::types::Pip<
                        runtime::RuntimeCall,
                        ::polymesh_api_client::AccountId,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8,
                    221u8, 29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The [`Pip`] for each proposal ([`PipId`])."]
            #[cfg(feature = "ink")]
            pub fn proposals(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::pallet_pips::types::Pip<
                        runtime::RuntimeCall,
                        ::polymesh_api_client::AccountId,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8,
                    221u8, 29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The [`VotingResult`] for each proposal ([`PipId`])."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_result(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<types::pallet_pips::types::VotingResult>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 239u8, 64u8, 138u8, 67u8, 171u8, 101u8,
                    203u8, 26u8, 180u8, 173u8, 95u8, 36u8, 142u8, 58u8, 33u8, 239u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                    ];
                    <types::pallet_pips::types::VotingResult>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The [`VotingResult`] for each proposal ([`PipId`])."]
            #[cfg(feature = "ink")]
            pub fn proposal_result(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::types::VotingResult>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 239u8, 64u8, 138u8, 67u8, 171u8, 101u8,
                    203u8, 26u8, 180u8, 173u8, 95u8, 36u8, 142u8, 58u8, 33u8, 239u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                    ];
                    <types::pallet_pips::types::VotingResult>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The Votes ([`Vote`]) for each proposal ([`PipId`]) per account."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_votes(
                &self,
                key_0: types::pallet_pips::types::PipId,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<Option<types::pallet_pips::types::Vote>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 38u8, 65u8, 14u8, 13u8, 124u8, 179u8, 198u8,
                    250u8, 215u8, 127u8, 63u8, 42u8, 53u8, 72u8, 177u8, 49u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The Votes ([`Vote`]) for each proposal ([`PipId`]) per account."]
            #[cfg(feature = "ink")]
            pub fn proposal_votes(
                &self,
                key_0: types::pallet_pips::types::PipId,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_pips::types::Vote>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 38u8, 65u8, 14u8, 13u8, 124u8, 179u8, 198u8,
                    250u8, 215u8, 127u8, 63u8, 42u8, 53u8, 72u8, 177u8, 49u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Maps PIPs to the block at which they will be executed."]
            #[cfg(not(feature = "ink"))]
            pub async fn pip_to_schedule(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<Option<u32>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 235u8, 79u8, 164u8, 184u8, 26u8, 18u8, 180u8,
                    116u8, 221u8, 96u8, 50u8, 249u8, 124u8, 39u8, 211u8, 186u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Maps PIPs to the block at which they will be executed."]
            #[cfg(feature = "ink")]
            pub fn pip_to_schedule(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 235u8, 79u8, 164u8, 184u8, 26u8, 18u8, 180u8,
                    116u8, 221u8, 96u8, 50u8, 249u8, 124u8, 39u8, 211u8, 186u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " A live priority queue (lowest priority at index 0)"]
            #[doc = " of pending PIPs up to the active limit."]
            #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
            #[doc = ""]
            #[doc = " Unlike `SnapshotQueue`, this queue is live, getting updated with each vote cast."]
            #[doc = " The snapshot is therefore essentially a point-in-time clone of this queue."]
            #[cfg(not(feature = "ink"))]
            pub async fn live_queue(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::pallet_pips::types::SnapshottedPip>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 199u8, 191u8, 241u8, 183u8, 34u8, 25u8, 14u8,
                    165u8, 58u8, 69u8, 114u8, 15u8, 85u8, 83u8, 223u8, 90u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::pallet_pips::types::SnapshottedPip>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " A live priority queue (lowest priority at index 0)"]
            #[doc = " of pending PIPs up to the active limit."]
            #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
            #[doc = ""]
            #[doc = " Unlike `SnapshotQueue`, this queue is live, getting updated with each vote cast."]
            #[doc = " The snapshot is therefore essentially a point-in-time clone of this queue."]
            #[cfg(feature = "ink")]
            pub fn live_queue(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::pallet_pips::types::SnapshottedPip>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 199u8, 191u8, 241u8, 183u8, 34u8, 25u8, 14u8,
                    165u8, 58u8, 69u8, 114u8, 15u8, 85u8, 83u8, 223u8, 90u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::pallet_pips::types::SnapshottedPip>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The priority queue (lowest priority at index 0) of PIPs at the point of snapshotting."]
            #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
            #[doc = ""]
            #[doc = " A queued PIP can be skipped. Doing so bumps the `pip_skip_count`."]
            #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
            #[cfg(not(feature = "ink"))]
            pub async fn snapshot_queue(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::pallet_pips::types::SnapshottedPip>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 71u8, 8u8, 47u8, 250u8, 214u8, 91u8, 162u8,
                    233u8, 118u8, 69u8, 120u8, 55u8, 47u8, 38u8, 190u8, 247u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::pallet_pips::types::SnapshottedPip>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The priority queue (lowest priority at index 0) of PIPs at the point of snapshotting."]
            #[doc = " Priority is defined by the `weight` in the `SnapshottedPip`."]
            #[doc = ""]
            #[doc = " A queued PIP can be skipped. Doing so bumps the `pip_skip_count`."]
            #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
            #[cfg(feature = "ink")]
            pub fn snapshot_queue(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::pallet_pips::types::SnapshottedPip>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 71u8, 8u8, 47u8, 250u8, 214u8, 91u8, 162u8,
                    233u8, 118u8, 69u8, 120u8, 55u8, 47u8, 38u8, 190u8, 247u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::pallet_pips::types::SnapshottedPip>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The [`SnapshotMetadata`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn snapshot_meta(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::pallet_pips::types::SnapshotMetadata<
                        u32,
                        ::polymesh_api_client::AccountId,
                    >,
                >,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 90u8, 74u8, 35u8, 0u8, 255u8, 31u8, 130u8,
                    141u8, 244u8, 34u8, 103u8, 253u8, 93u8, 30u8, 199u8, 83u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The [`SnapshotMetadata`]."]
            #[cfg(feature = "ink")]
            pub fn snapshot_meta(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::pallet_pips::types::SnapshotMetadata<
                        u32,
                        ::polymesh_api_client::AccountId,
                    >,
                >,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 90u8, 74u8, 35u8, 0u8, 255u8, 31u8, 130u8,
                    141u8, 244u8, 34u8, 103u8, 253u8, 93u8, 30u8, 199u8, 83u8,
                ])?;
                Ok(value)
            }
            #[doc = " The number of times a certain PIP has been skipped."]
            #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
            #[cfg(not(feature = "ink"))]
            pub async fn pip_skip_count(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<u8> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 225u8, 98u8, 238u8, 82u8, 4u8, 74u8, 74u8,
                    120u8, 78u8, 232u8, 200u8, 123u8, 191u8, 156u8, 108u8, 85u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <u8>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The number of times a certain PIP has been skipped."]
            #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
            #[cfg(feature = "ink")]
            pub fn pip_skip_count(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_ink::error::Result<u8> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 225u8, 98u8, 238u8, 82u8, 4u8, 74u8, 74u8,
                    120u8, 78u8, 232u8, 200u8, 123u8, 191u8, 156u8, 108u8, 85u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <u8>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All existing PIPs where the proposer is a committee."]
            #[doc = " This list is a cache of all ids in `Proposals` with `Proposer::Committee(_)`."]
            #[cfg(not(feature = "ink"))]
            pub async fn committee_pips(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::pallet_pips::types::PipId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 189u8, 121u8, 13u8, 219u8, 47u8, 171u8,
                    170u8, 240u8, 102u8, 140u8, 146u8, 163u8, 22u8, 76u8, 210u8, 186u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::pallet_pips::types::PipId>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " All existing PIPs where the proposer is a committee."]
            #[doc = " This list is a cache of all ids in `Proposals` with `Proposer::Committee(_)`."]
            #[cfg(feature = "ink")]
            pub fn committee_pips(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::pallet_pips::types::PipId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 189u8, 121u8, 13u8, 219u8, 47u8, 171u8,
                    170u8, 240u8, 102u8, 140u8, 146u8, 163u8, 22u8, 76u8, 210u8, 186u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::pallet_pips::types::PipId>>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The ([`ProposalState`]) of a given PIP ([`PipId`])."]
            #[cfg(not(feature = "ink"))]
            pub async fn proposal_states(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_pips::types::ProposalState>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8,
                    102u8, 151u8, 171u8, 71u8, 106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The ([`ProposalState`]) of a given PIP ([`PipId`])."]
            #[cfg(feature = "ink")]
            pub fn proposal_states(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_pips::types::ProposalState>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8,
                    102u8, 151u8, 171u8, 71u8, 106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " All PIPs that still require refunds."]
            #[cfg(not(feature = "ink"))]
            pub async fn pending_refunds(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<Option<bool>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 205u8, 134u8, 199u8, 132u8, 245u8, 50u8,
                    201u8, 105u8, 137u8, 28u8, 166u8, 151u8, 145u8, 10u8, 209u8, 36u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " All PIPs that still require refunds."]
            #[cfg(feature = "ink")]
            pub fn pending_refunds(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_ink::error::Result<Option<bool>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 205u8, 134u8, 199u8, 132u8, 245u8, 50u8,
                    201u8, 105u8, 137u8, 28u8, 166u8, 151u8, 145u8, 10u8, 209u8, 36u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " All PIPs that still require votes to be pruned."]
            #[cfg(not(feature = "ink"))]
            pub async fn votes_to_be_pruned(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::error::Result<Option<bool>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 225u8, 189u8, 204u8, 73u8, 178u8, 99u8,
                    133u8, 4u8, 9u8, 135u8, 123u8, 242u8, 219u8, 200u8, 5u8, 9u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " All PIPs that still require votes to be pruned."]
            #[cfg(feature = "ink")]
            pub fn votes_to_be_pruned(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_ink::error::Result<Option<bool>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 225u8, 189u8, 204u8, 73u8, 178u8, 99u8,
                    133u8, 4u8, 9u8, 135u8, 123u8, 242u8, 219u8, 200u8, 5u8, 9u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_pips::Version> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_pips::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_pips::Version> {
                let value = self.api.read_storage(::alloc::vec![
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_pips::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct PipsPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> PipsPagedQueryApi<'api> {
            #[doc = " The [`PipsMetadata`] for each proposal ([`PipId`])."]
            pub fn proposal_metadata(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_pips::types::PipId,
                types::pallet_pips::types::PipsMetadata<u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 84u8, 36u8, 238u8, 140u8, 56u8, 250u8, 92u8,
                    7u8, 255u8, 42u8, 121u8, 197u8, 145u8, 184u8, 96u8, 30u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " All locked [`DepositInfo`] per [`PipId`] for each account."]
            pub fn deposits(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_pips::types::DepositInfo<::polymesh_api_client::AccountId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 116u8, 166u8, 20u8, 219u8, 128u8, 33u8,
                    198u8, 189u8, 10u8, 2u8, 138u8, 175u8, 223u8, 41u8, 221u8, 8u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The [`Pip`] for each proposal ([`PipId`])."]
            pub fn proposals(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_pips::types::PipId,
                types::pallet_pips::types::Pip<
                    runtime::RuntimeCall,
                    ::polymesh_api_client::AccountId,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 136u8, 194u8, 247u8, 24u8, 140u8, 111u8,
                    221u8, 29u8, 255u8, 174u8, 47u8, 160u8, 209u8, 113u8, 244u8, 64u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The [`VotingResult`] for each proposal ([`PipId`])."]
            pub fn proposal_result(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_pips::types::PipId,
                types::pallet_pips::types::VotingResult,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 239u8, 64u8, 138u8, 67u8, 171u8, 101u8,
                    203u8, 26u8, 180u8, 173u8, 95u8, 36u8, 142u8, 58u8, 33u8, 239u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The Votes ([`Vote`]) for each proposal ([`PipId`]) per account."]
            pub fn proposal_votes(
                &self,
                key_0: types::pallet_pips::types::PipId,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_pips::types::Vote,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 38u8, 65u8, 14u8, 13u8, 124u8, 179u8, 198u8,
                    250u8, 215u8, 127u8, 63u8, 42u8, 53u8, 72u8, 177u8, 49u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Maps PIPs to the block at which they will be executed."]
            pub fn pip_to_schedule(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<types::pallet_pips::types::PipId, u32>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 235u8, 79u8, 164u8, 184u8, 26u8, 18u8, 180u8,
                    116u8, 221u8, 96u8, 50u8, 249u8, 124u8, 39u8, 211u8, 186u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The number of times a certain PIP has been skipped."]
            #[doc = " Once a (configurable) threshhold is exceeded, a PIP cannot be skipped again."]
            pub fn pip_skip_count(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<types::pallet_pips::types::PipId, u8>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 225u8, 98u8, 238u8, 82u8, 4u8, 74u8, 74u8,
                    120u8, 78u8, 232u8, 200u8, 123u8, 191u8, 156u8, 108u8, 85u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The ([`ProposalState`]) of a given PIP ([`PipId`])."]
            pub fn proposal_states(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::pallet_pips::types::PipId,
                types::pallet_pips::types::ProposalState,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 222u8, 188u8, 158u8, 114u8, 68u8, 224u8,
                    102u8, 151u8, 171u8, 71u8, 106u8, 65u8, 161u8, 205u8, 227u8, 138u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " All PIPs that still require refunds."]
            pub fn pending_refunds(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<types::pallet_pips::types::PipId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 205u8, 134u8, 199u8, 132u8, 245u8, 50u8,
                    201u8, 105u8, 137u8, 28u8, 166u8, 151u8, 145u8, 10u8, 209u8, 36u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " All PIPs that still require votes to be pruned."]
            pub fn votes_to_be_pruned(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<types::pallet_pips::types::PipId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    55u8, 181u8, 173u8, 154u8, 186u8, 156u8, 122u8, 135u8, 120u8, 164u8, 215u8,
                    115u8, 13u8, 254u8, 103u8, 198u8, 225u8, 189u8, 204u8, 73u8, 178u8, 99u8,
                    133u8, 4u8, 9u8, 135u8, 123u8, 242u8, 219u8, 200u8, 5u8, 9u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod portfolio {
        use super::*;
        #[derive(Clone)]
        pub struct PortfolioCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> PortfolioCallApi<'api> {
            #[doc = "Creates a portfolio with the given `name`."]
            #[cfg(not(feature = "ink"))]
            pub fn create_portfolio(
                &self,
                name: types::polymesh_primitives::identity_id::PortfolioName,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Portfolio(
                    types::pallet_portfolio::pallet::PortfolioCall::create_portfolio { name },
                ))
            }
            #[doc = "Creates a portfolio with the given `name`."]
            #[cfg(feature = "ink")]
            pub fn create_portfolio(
                &self,
                name: types::polymesh_primitives::identity_id::PortfolioName,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 0u8];
                name.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Deletes a user portfolio. A portfolio can be deleted only if it has no funds."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
            #[doc = "* `PortfolioNotEmpty` if the portfolio still holds any asset"]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn delete_portfolio(
                &self,
                num: types::polymesh_primitives::identity_id::PortfolioNumber,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Portfolio(
                    types::pallet_portfolio::pallet::PortfolioCall::delete_portfolio { num },
                ))
            }
            #[doc = "Deletes a user portfolio. A portfolio can be deleted only if it has no funds."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
            #[doc = "* `PortfolioNotEmpty` if the portfolio still holds any asset"]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn delete_portfolio(
                &self,
                num: types::polymesh_primitives::identity_id::PortfolioNumber,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 1u8];
                num.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Renames a non-default portfolio."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn rename_portfolio(
                &self,
                num: types::polymesh_primitives::identity_id::PortfolioNumber,
                to_name: types::polymesh_primitives::identity_id::PortfolioName,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Portfolio(
                    types::pallet_portfolio::pallet::PortfolioCall::rename_portfolio {
                        num,
                        to_name,
                    },
                ))
            }
            #[doc = "Renames a non-default portfolio."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `PortfolioDoesNotExist` if `num` doesn't reference a valid portfolio."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn rename_portfolio(
                &self,
                num: types::polymesh_primitives::identity_id::PortfolioNumber,
                to_name: types::polymesh_primitives::identity_id::PortfolioName,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 2u8];
                num.encode_to(&mut buf);
                to_name.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "When called by the custodian of `portfolio_id`,"]
            #[doc = "allows returning the custody of the portfolio to the portfolio owner unilaterally."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn quit_portfolio_custody(
                &self,
                pid: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Portfolio(
                    types::pallet_portfolio::pallet::PortfolioCall::quit_portfolio_custody { pid },
                ))
            }
            #[doc = "When called by the custodian of `portfolio_id`,"]
            #[doc = "allows returning the custody of the portfolio to the portfolio owner unilaterally."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `UnauthorizedCustodian` if the caller is not the current custodian of `portfolio_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn quit_portfolio_custody(
                &self,
                pid: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 3u8];
                pid.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[cfg(not(feature = "ink"))]
            pub fn accept_portfolio_custody(
                &self,
                auth_id: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Portfolio(
                    types::pallet_portfolio::pallet::PortfolioCall::accept_portfolio_custody {
                        auth_id,
                    },
                ))
            }
            #[cfg(feature = "ink")]
            pub fn accept_portfolio_custody(&self, auth_id: u64) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 4u8];
                auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same"]
            #[doc = "identity. Must be called by the custodian of the sender."]
            #[doc = "Funds from deleted portfolios can also be recovered via this method."]
            #[doc = ""]
            #[doc = "A short memo can be added to to each token amount moved."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio."]
            #[doc = "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same"]
            #[doc = "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities"]
            #[doc = "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio"]
            #[doc = "* `InsufficientPortfolioBalance` if the sender does not have enough free balance"]
            #[doc = "* `NoDuplicateAssetsAllowed` the same asset can't be repeated in the items vector."]
            #[doc = "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own."]
            #[doc = "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn move_portfolio_funds(
                &self,
                from: types::polymesh_primitives::identity_id::PortfolioId,
                to: types::polymesh_primitives::identity_id::PortfolioId,
                funds: ::alloc::vec::Vec<types::polymesh_primitives::portfolio::Fund>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Portfolio(
                    types::pallet_portfolio::pallet::PortfolioCall::move_portfolio_funds {
                        from,
                        to,
                        funds,
                    },
                ))
            }
            #[doc = "Moves fungigle an non-fungible tokens from one portfolio of an identity to another portfolio of the same"]
            #[doc = "identity. Must be called by the custodian of the sender."]
            #[doc = "Funds from deleted portfolios can also be recovered via this method."]
            #[doc = ""]
            #[doc = "A short memo can be added to to each token amount moved."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `PortfolioDoesNotExist` if one or both of the portfolios reference an invalid portfolio."]
            #[doc = "* `destination_is_same_portfolio` if both sender and receiver portfolio are the same"]
            #[doc = "* `DifferentIdentityPortfolios` if the sender and receiver portfolios belong to different identities"]
            #[doc = "* `UnauthorizedCustodian` if the caller is not the custodian of the from portfolio"]
            #[doc = "* `InsufficientPortfolioBalance` if the sender does not have enough free balance"]
            #[doc = "* `NoDuplicateAssetsAllowed` the same asset can't be repeated in the items vector."]
            #[doc = "* `InvalidTransferNFTNotOwned` if the caller is trying to move an NFT he doesn't own."]
            #[doc = "* `InvalidTransferNFTIsLocked` if the caller is trying to move a locked NFT."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn move_portfolio_funds(
                &self,
                from: types::polymesh_primitives::identity_id::PortfolioId,
                to: types::polymesh_primitives::identity_id::PortfolioId,
                funds: ::alloc::vec::Vec<types::polymesh_primitives::portfolio::Fund>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 5u8];
                from.encode_to(&mut buf);
                to.encode_to(&mut buf);
                funds.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Pre-approves the receivement of an asset to a portfolio."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - the secondary key of the sender."]
            #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
            #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn pre_approve_portfolio(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Portfolio(
                    types::pallet_portfolio::pallet::PortfolioCall::pre_approve_portfolio {
                        asset_id,
                        portfolio_id,
                    },
                ))
            }
            #[doc = "Pre-approves the receivement of an asset to a portfolio."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - the secondary key of the sender."]
            #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
            #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn pre_approve_portfolio(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 6u8];
                asset_id.encode_to(&mut buf);
                portfolio_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the pre approval of an asset to a portfolio."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - the secondary key of the sender."]
            #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
            #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn remove_portfolio_pre_approval(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Portfolio(
                    types::pallet_portfolio::pallet::PortfolioCall::remove_portfolio_pre_approval {
                        asset_id,
                        portfolio_id,
                    },
                ))
            }
            #[doc = "Removes the pre approval of an asset to a portfolio."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - the secondary key of the sender."]
            #[doc = "* `asset_id` - the [`AssetId`] that will be exempt from affirmation."]
            #[doc = "* `portfolio_id` - the [`PortfolioId`] that can receive `asset_id` without affirmation."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn remove_portfolio_pre_approval(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                portfolio_id: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 7u8];
                asset_id.encode_to(&mut buf);
                portfolio_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds an identity that will be allowed to create and take custody of a portfolio under the caller's identity."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `trusted_identity` - the [`IdentityId`] that will be allowed to call `create_custody_portfolio`."]
            #[doc = ""]
            #[cfg(not(feature = "ink"))]
            pub fn allow_identity_to_create_portfolios(
                &self,
                trusted_identity: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Portfolio (types :: pallet_portfolio :: pallet :: PortfolioCall :: allow_identity_to_create_portfolios { trusted_identity , }))
            }
            #[doc = "Adds an identity that will be allowed to create and take custody of a portfolio under the caller's identity."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `trusted_identity` - the [`IdentityId`] that will be allowed to call `create_custody_portfolio`."]
            #[doc = ""]
            #[cfg(feature = "ink")]
            pub fn allow_identity_to_create_portfolios(
                &self,
                trusted_identity: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 8u8];
                trusted_identity.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes permission of an identity to create and take custody of a portfolio under the caller's identity."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `identity` - the [`IdentityId`] that will have the permissions to call `create_custody_portfolio` revoked."]
            #[doc = ""]
            #[cfg(not(feature = "ink"))]
            pub fn revoke_create_portfolios_permission(
                &self,
                identity: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Portfolio (types :: pallet_portfolio :: pallet :: PortfolioCall :: revoke_create_portfolios_permission { identity , }))
            }
            #[doc = "Removes permission of an identity to create and take custody of a portfolio under the caller's identity."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `identity` - the [`IdentityId`] that will have the permissions to call `create_custody_portfolio` revoked."]
            #[doc = ""]
            #[cfg(feature = "ink")]
            pub fn revoke_create_portfolios_permission(
                &self,
                identity: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 9u8];
                identity.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Creates a portfolio under the `portfolio_owner_id` identity and transfers its custody to the caller's identity."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `portfolio_owner_id` - the [`IdentityId`] that will own the new portfolio."]
            #[doc = "* `portfolio_name` - the [`PortfolioName`] of the new portfolio."]
            #[doc = ""]
            #[cfg(not(feature = "ink"))]
            pub fn create_custody_portfolio(
                &self,
                portfolio_owner_id: ::polymesh_api_client::IdentityId,
                portfolio_name: types::polymesh_primitives::identity_id::PortfolioName,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Portfolio(
                    types::pallet_portfolio::pallet::PortfolioCall::create_custody_portfolio {
                        portfolio_owner_id,
                        portfolio_name,
                    },
                ))
            }
            #[doc = "Creates a portfolio under the `portfolio_owner_id` identity and transfers its custody to the caller's identity."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `portfolio_owner_id` - the [`IdentityId`] that will own the new portfolio."]
            #[doc = "* `portfolio_name` - the [`PortfolioName`] of the new portfolio."]
            #[doc = ""]
            #[cfg(feature = "ink")]
            pub fn create_custody_portfolio(
                &self,
                portfolio_owner_id: ::polymesh_api_client::IdentityId,
                portfolio_name: types::polymesh_primitives::identity_id::PortfolioName,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![34u8, 10u8];
                portfolio_owner_id.encode_to(&mut buf);
                portfolio_name.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for PortfolioCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct PortfolioQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> PortfolioQueryApi<'api> {
            #[doc = " The next portfolio sequence number of an identity."]
            #[cfg(not(feature = "ink"))]
            pub async fn next_portfolio_number(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::identity_id::PortfolioNumber,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 172u8, 83u8, 250u8, 216u8, 150u8, 217u8, 192u8,
                    44u8, 226u8, 108u8, 214u8, 101u8, 230u8, 169u8, 16u8, 146u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::identity_id::PortfolioNumber>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The next portfolio sequence number of an identity."]
            #[cfg(feature = "ink")]
            pub fn next_portfolio_number(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::identity_id::PortfolioNumber,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 172u8, 83u8, 250u8, 216u8, 150u8, 217u8, 192u8,
                    44u8, 226u8, 108u8, 214u8, 101u8, 230u8, 169u8, 16u8, 146u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::identity_id::PortfolioNumber>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The set of existing portfolios with their names. If a certain pair of a DID and"]
            #[doc = " portfolio number maps to `None` then such a portfolio doesn't exist. Conversely, if a"]
            #[doc = " pair maps to `Some(name)` then such a portfolio exists and is called `name`."]
            #[cfg(not(feature = "ink"))]
            pub async fn portfolios(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: types::polymesh_primitives::identity_id::PortfolioNumber,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::identity_id::PortfolioName>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 216u8, 45u8, 233u8, 131u8, 28u8, 44u8, 102u8,
                    233u8, 160u8, 8u8, 50u8, 33u8, 79u8, 22u8, 134u8, 96u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The set of existing portfolios with their names. If a certain pair of a DID and"]
            #[doc = " portfolio number maps to `None` then such a portfolio doesn't exist. Conversely, if a"]
            #[doc = " pair maps to `Some(name)` then such a portfolio exists and is called `name`."]
            #[cfg(feature = "ink")]
            pub fn portfolios(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: types::polymesh_primitives::identity_id::PortfolioNumber,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::identity_id::PortfolioName>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 216u8, 45u8, 233u8, 131u8, 28u8, 44u8, 102u8,
                    233u8, 160u8, 8u8, 50u8, 33u8, 79u8, 22u8, 134u8, 96u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Inverse map of `Portfolios` used to ensure bijectivitiy,"]
            #[doc = " and uniqueness of names in `Portfolios`."]
            #[cfg(not(feature = "ink"))]
            pub async fn name_to_number(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: types::polymesh_primitives::identity_id::PortfolioName,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 201u8, 73u8, 93u8, 142u8, 176u8, 225u8, 64u8,
                    248u8, 75u8, 153u8, 21u8, 11u8, 147u8, 73u8, 1u8, 128u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Inverse map of `Portfolios` used to ensure bijectivitiy,"]
            #[doc = " and uniqueness of names in `Portfolios`."]
            #[cfg(feature = "ink")]
            pub fn name_to_number(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: types::polymesh_primitives::identity_id::PortfolioName,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::identity_id::PortfolioNumber>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 201u8, 73u8, 93u8, 142u8, 176u8, 225u8, 64u8,
                    248u8, 75u8, 153u8, 21u8, 11u8, 147u8, 73u8, 1u8, 128u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " How many assets with non-zero balance this portfolio contains."]
            #[cfg(not(feature = "ink"))]
            pub async fn portfolio_asset_count(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 134u8, 1u8, 141u8, 242u8, 36u8, 217u8, 225u8,
                    140u8, 57u8, 102u8, 61u8, 167u8, 241u8, 14u8, 193u8, 102u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " How many assets with non-zero balance this portfolio contains."]
            #[cfg(feature = "ink")]
            pub fn portfolio_asset_count(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 134u8, 1u8, 141u8, 242u8, 36u8, 217u8, 225u8,
                    140u8, 57u8, 102u8, 61u8, 167u8, 241u8, 14u8, 193u8, 102u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The asset balances of portfolios."]
            #[cfg(not(feature = "ink"))]
            pub async fn portfolio_asset_balances(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 187u8, 126u8, 217u8, 17u8, 104u8, 223u8, 249u8,
                    141u8, 179u8, 194u8, 128u8, 143u8, 216u8, 237u8, 226u8, 9u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The asset balances of portfolios."]
            #[cfg(feature = "ink")]
            pub fn portfolio_asset_balances(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 187u8, 126u8, 217u8, 17u8, 104u8, 223u8, 249u8,
                    141u8, 179u8, 194u8, 128u8, 143u8, 216u8, 237u8, 226u8, 9u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Amount of assets locked in a portfolio."]
            #[doc = " These assets show up in portfolio balance but can not be transferred away."]
            #[cfg(not(feature = "ink"))]
            pub async fn portfolio_locked_assets(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 116u8, 19u8, 199u8, 203u8, 198u8, 5u8, 145u8,
                    166u8, 100u8, 250u8, 216u8, 43u8, 219u8, 255u8, 196u8, 204u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Amount of assets locked in a portfolio."]
            #[doc = " These assets show up in portfolio balance but can not be transferred away."]
            #[cfg(feature = "ink")]
            pub fn portfolio_locked_assets(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 116u8, 19u8, 199u8, 203u8, 198u8, 5u8, 145u8,
                    166u8, 100u8, 250u8, 216u8, 43u8, 219u8, 255u8, 196u8, 204u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The custodian of a particular portfolio. None implies that the identity owner is the custodian."]
            #[cfg(not(feature = "ink"))]
            pub async fn portfolio_custodian(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 10u8, 6u8, 59u8, 83u8, 137u8, 54u8, 238u8, 218u8,
                    141u8, 253u8, 27u8, 117u8, 25u8, 62u8, 192u8, 180u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The custodian of a particular portfolio. None implies that the identity owner is the custodian."]
            #[cfg(feature = "ink")]
            pub fn portfolio_custodian(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_ink::error::Result<Option<::polymesh_api_client::IdentityId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 10u8, 6u8, 59u8, 83u8, 137u8, 54u8, 238u8, 218u8,
                    141u8, 253u8, 27u8, 117u8, 25u8, 62u8, 192u8, 180u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Tracks all the portfolios in custody of a particular identity. Only used by the UIs."]
            #[doc = " When `true` is stored as the value for a given `(did, pid)`, it means that `pid` is in custody of `did`."]
            #[doc = " `false` values are never explicitly stored in the map, and are instead inferred by the absence of a key."]
            #[cfg(not(feature = "ink"))]
            pub async fn portfolios_in_custody(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 151u8, 1u8, 246u8, 111u8, 5u8, 25u8, 23u8, 126u8,
                    54u8, 90u8, 86u8, 176u8, 77u8, 30u8, 44u8, 29u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Tracks all the portfolios in custody of a particular identity. Only used by the UIs."]
            #[doc = " When `true` is stored as the value for a given `(did, pid)`, it means that `pid` is in custody of `did`."]
            #[doc = " `false` values are never explicitly stored in the map, and are instead inferred by the absence of a key."]
            #[cfg(feature = "ink")]
            pub fn portfolios_in_custody(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 151u8, 1u8, 246u8, 111u8, 5u8, 25u8, 23u8, 126u8,
                    54u8, 90u8, 86u8, 176u8, 77u8, 30u8, 44u8, 29u8,
                ]);
                buf.extend(key_0.encode());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The nft associated to the portfolio."]
            #[cfg(not(feature = "ink"))]
            pub async fn portfolio_nft(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::nft::NFTId,
                ),
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 173u8, 97u8, 37u8, 11u8, 3u8, 3u8, 23u8, 150u8,
                    237u8, 156u8, 213u8, 12u8, 232u8, 116u8, 250u8, 5u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The nft associated to the portfolio."]
            #[cfg(feature = "ink")]
            pub fn portfolio_nft(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::nft::NFTId,
                ),
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 173u8, 97u8, 37u8, 11u8, 3u8, 3u8, 23u8, 150u8,
                    237u8, 156u8, 213u8, 12u8, 232u8, 116u8, 250u8, 5u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All locked nft for a given portfolio."]
            #[cfg(not(feature = "ink"))]
            pub async fn portfolio_locked_nft(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::nft::NFTId,
                ),
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 184u8, 241u8, 132u8, 127u8, 220u8, 26u8, 219u8,
                    97u8, 120u8, 220u8, 63u8, 134u8, 171u8, 252u8, 234u8, 18u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All locked nft for a given portfolio."]
            #[cfg(feature = "ink")]
            pub fn portfolio_locked_nft(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::nft::NFTId,
                ),
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 184u8, 241u8, 132u8, 127u8, 220u8, 26u8, 219u8,
                    97u8, 120u8, 220u8, 63u8, 134u8, 171u8, 252u8, 234u8, 18u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All portfolios that don't need to affirm the receivement of a given [`AssetId`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn pre_approved_portfolios(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 237u8, 212u8, 229u8, 184u8, 97u8, 233u8, 51u8,
                    24u8, 206u8, 114u8, 208u8, 215u8, 112u8, 111u8, 171u8, 170u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " All portfolios that don't need to affirm the receivement of a given [`AssetId`]."]
            #[cfg(feature = "ink")]
            pub fn pre_approved_portfolios(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 237u8, 212u8, 229u8, 184u8, 97u8, 233u8, 51u8,
                    24u8, 206u8, 114u8, 208u8, 215u8, 112u8, 111u8, 171u8, 170u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Custodians allowed to create and take custody of portfolios on an id's behalf."]
            #[cfg(not(feature = "ink"))]
            pub async fn allowed_custodians(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 8u8, 235u8, 240u8, 0u8, 20u8, 57u8, 146u8, 221u8,
                    92u8, 156u8, 54u8, 141u8, 201u8, 221u8, 88u8, 89u8,
                ]);
                buf.extend(key_0.encode());
                buf.extend(key_1.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Custodians allowed to create and take custody of portfolios on an id's behalf."]
            #[cfg(feature = "ink")]
            pub fn allowed_custodians(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 8u8, 235u8, 240u8, 0u8, 20u8, 57u8, 146u8, 221u8,
                    92u8, 156u8, 54u8, 141u8, 201u8, 221u8, 88u8, 89u8,
                ]);
                buf.extend(key_0.encode());
                buf.extend(key_1.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_portfolio::pallet::Version>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_portfolio::pallet::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_portfolio::pallet::Version>
            {
                let value = self.api.read_storage(::alloc::vec![
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_portfolio::pallet::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct PortfolioPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> PortfolioPagedQueryApi<'api> {
            #[doc = " The next portfolio sequence number of an identity."]
            pub fn next_portfolio_number(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::IdentityId,
                types::polymesh_primitives::identity_id::PortfolioNumber,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 172u8, 83u8, 250u8, 216u8, 150u8, 217u8, 192u8,
                    44u8, 226u8, 108u8, 214u8, 101u8, 230u8, 169u8, 16u8, 146u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " The set of existing portfolios with their names. If a certain pair of a DID and"]
            #[doc = " portfolio number maps to `None` then such a portfolio doesn't exist. Conversely, if a"]
            #[doc = " pair maps to `Some(name)` then such a portfolio exists and is called `name`."]
            pub fn portfolios(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::identity_id::PortfolioNumber,
                types::polymesh_primitives::identity_id::PortfolioName,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 216u8, 45u8, 233u8, 131u8, 28u8, 44u8, 102u8,
                    233u8, 160u8, 8u8, 50u8, 33u8, 79u8, 22u8, 134u8, 96u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Inverse map of `Portfolios` used to ensure bijectivitiy,"]
            #[doc = " and uniqueness of names in `Portfolios`."]
            pub fn name_to_number(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::identity_id::PortfolioName,
                types::polymesh_primitives::identity_id::PortfolioNumber,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 201u8, 73u8, 93u8, 142u8, 176u8, 225u8, 64u8,
                    248u8, 75u8, 153u8, 21u8, 11u8, 147u8, 73u8, 1u8, 128u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " How many assets with non-zero balance this portfolio contains."]
            pub fn portfolio_asset_count(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::identity_id::PortfolioId,
                u64,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 134u8, 1u8, 141u8, 242u8, 36u8, 217u8, 225u8,
                    140u8, 57u8, 102u8, 61u8, 167u8, 241u8, 14u8, 193u8, 102u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The asset balances of portfolios."]
            pub fn portfolio_asset_balances(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, u128>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 187u8, 126u8, 217u8, 17u8, 104u8, 223u8, 249u8,
                    141u8, 179u8, 194u8, 128u8, 143u8, 216u8, 237u8, 226u8, 9u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Amount of assets locked in a portfolio."]
            #[doc = " These assets show up in portfolio balance but can not be transferred away."]
            pub fn portfolio_locked_assets(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, u128>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 116u8, 19u8, 199u8, 203u8, 198u8, 5u8, 145u8,
                    166u8, 100u8, 250u8, 216u8, 43u8, 219u8, 255u8, 196u8, 204u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The custodian of a particular portfolio. None implies that the identity owner is the custodian."]
            pub fn portfolio_custodian(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::identity_id::PortfolioId,
                ::polymesh_api_client::IdentityId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 10u8, 6u8, 59u8, 83u8, 137u8, 54u8, 238u8, 218u8,
                    141u8, 253u8, 27u8, 117u8, 25u8, 62u8, 192u8, 180u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Tracks all the portfolios in custody of a particular identity. Only used by the UIs."]
            #[doc = " When `true` is stored as the value for a given `(did, pid)`, it means that `pid` is in custody of `did`."]
            #[doc = " `false` values are never explicitly stored in the map, and are instead inferred by the absence of a key."]
            pub fn portfolios_in_custody(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::identity_id::PortfolioId,
                bool,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 151u8, 1u8, 246u8, 111u8, 5u8, 25u8, 23u8, 126u8,
                    54u8, 90u8, 86u8, 176u8, 77u8, 30u8, 44u8, 29u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The nft associated to the portfolio."]
            pub fn portfolio_nft(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::StoragePaged<
                (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::nft::NFTId,
                ),
                bool,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 173u8, 97u8, 37u8, 11u8, 3u8, 3u8, 23u8, 150u8,
                    237u8, 156u8, 213u8, 12u8, 232u8, 116u8, 250u8, 5u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " All locked nft for a given portfolio."]
            pub fn portfolio_locked_nft(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::StoragePaged<
                (
                    ::polymesh_api_client::AssetId,
                    types::polymesh_primitives::nft::NFTId,
                ),
                bool,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 184u8, 241u8, 132u8, 127u8, 220u8, 26u8, 219u8,
                    97u8, 120u8, 220u8, 63u8, 134u8, 171u8, 252u8, 234u8, 18u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " All portfolios that don't need to affirm the receivement of a given [`AssetId`]."]
            pub fn pre_approved_portfolios(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 237u8, 212u8, 229u8, 184u8, 97u8, 233u8, 51u8,
                    24u8, 206u8, 114u8, 208u8, 215u8, 112u8, 111u8, 171u8, 170u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Custodians allowed to create and take custody of portfolios on an id's behalf."]
            pub fn allowed_custodians(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    36u8, 2u8, 13u8, 65u8, 5u8, 65u8, 106u8, 176u8, 166u8, 221u8, 157u8, 115u8,
                    101u8, 254u8, 169u8, 230u8, 8u8, 235u8, 240u8, 0u8, 20u8, 57u8, 146u8, 221u8,
                    92u8, 156u8, 54u8, 141u8, 201u8, 221u8, 88u8, 89u8,
                ]);
                buf.extend(key_0.encode());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
        }
    }
    pub mod protocol_fee {
        use super::*;
        #[derive(Clone)]
        pub struct ProtocolFeeCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> ProtocolFeeCallApi<'api> {
            #[doc = "Changes the fee coefficient for the root origin."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - Only root allowed."]
            #[cfg(not(feature = "ink"))]
            pub fn change_coefficient(
                &self,
                coefficient: types::polymesh_primitives::PosRatio,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::ProtocolFee(
                    types::pallet_protocol_fee::pallet::ProtocolFeeCall::change_coefficient {
                        coefficient,
                    },
                ))
            }
            #[doc = "Changes the fee coefficient for the root origin."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - Only root allowed."]
            #[cfg(feature = "ink")]
            pub fn change_coefficient(
                &self,
                coefficient: types::polymesh_primitives::PosRatio,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![35u8, 0u8];
                coefficient.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Changes the a base fee for the root origin."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - Only root allowed."]
            #[cfg(not(feature = "ink"))]
            pub fn change_base_fee(
                &self,
                op: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
                base_fee: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::ProtocolFee(
                    types::pallet_protocol_fee::pallet::ProtocolFeeCall::change_base_fee {
                        op,
                        base_fee,
                    },
                ))
            }
            #[doc = "Changes the a base fee for the root origin."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `BadOrigin` - Only root allowed."]
            #[cfg(feature = "ink")]
            pub fn change_base_fee(
                &self,
                op: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
                base_fee: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![35u8, 1u8];
                op.encode_to(&mut buf);
                base_fee.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for ProtocolFeeCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct ProtocolFeeQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> ProtocolFeeQueryApi<'api> {
            #[doc = " The mapping of operation names to the base fees of those operations."]
            #[cfg(not(feature = "ink"))]
            pub async fn base_fees(
                &self,
                key_0: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
            ) -> ::polymesh_api_client::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8,
                    3u8, 169u8, 228u8, 161u8, 54u8, 217u8, 243u8, 154u8, 193u8, 14u8, 44u8, 253u8,
                    114u8, 99u8, 70u8, 43u8, 154u8, 102u8, 138u8, 8u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The mapping of operation names to the base fees of those operations."]
            #[cfg(feature = "ink")]
            pub fn base_fees(
                &self,
                key_0: types::polymesh_common_utilities::protocol_fee::ProtocolOp,
            ) -> ::polymesh_api_ink::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8,
                    3u8, 169u8, 228u8, 161u8, 54u8, 217u8, 243u8, 154u8, 193u8, 14u8, 44u8, 253u8,
                    114u8, 99u8, 70u8, 43u8, 154u8, 102u8, 138u8, 8u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The fee coefficient as a positive rational (numerator, denominator)."]
            #[cfg(not(feature = "ink"))]
            pub async fn coefficient(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::PosRatio>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8,
                    3u8, 169u8, 228u8, 161u8, 155u8, 182u8, 208u8, 38u8, 251u8, 72u8, 4u8, 189u8,
                    110u8, 17u8, 231u8, 0u8, 23u8, 52u8, 26u8, 97u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::PosRatio>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The fee coefficient as a positive rational (numerator, denominator)."]
            #[cfg(feature = "ink")]
            pub fn coefficient(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::PosRatio>
            {
                let value = self.api.read_storage(::alloc::vec![
                    184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8,
                    3u8, 169u8, 228u8, 161u8, 155u8, 182u8, 208u8, 38u8, 251u8, 72u8, 4u8, 189u8,
                    110u8, 17u8, 231u8, 0u8, 23u8, 52u8, 26u8, 97u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8, 1u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::PosRatio>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct ProtocolFeePagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> ProtocolFeePagedQueryApi<'api> {
            #[doc = " The mapping of operation names to the base fees of those operations."]
            pub fn base_fees(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_common_utilities::protocol_fee::ProtocolOp,
                u128,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    184u8, 15u8, 129u8, 169u8, 9u8, 174u8, 84u8, 41u8, 252u8, 227u8, 28u8, 64u8,
                    3u8, 169u8, 228u8, 161u8, 54u8, 217u8, 243u8, 154u8, 193u8, 14u8, 44u8, 253u8,
                    114u8, 99u8, 70u8, 43u8, 154u8, 102u8, 138u8, 8u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod scheduler {
        use super::*;
        #[derive(Clone)]
        pub struct SchedulerCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> SchedulerCallApi<'api> {
            #[doc = "Anonymously schedule a task."]
            #[cfg(not(feature = "ink"))]
            pub fn schedule(
                &self,
                when: u32,
                maybe_periodic: Option<(u32, u32)>,
                priority: u8,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Scheduler(
                    types::pallet_scheduler::pallet::SchedulerCall::schedule {
                        when,
                        maybe_periodic,
                        priority,
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Anonymously schedule a task."]
            #[cfg(feature = "ink")]
            pub fn schedule(
                &self,
                when: u32,
                maybe_periodic: Option<(u32, u32)>,
                priority: u8,
                call: runtime::RuntimeCall,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![36u8, 0u8];
                when.encode_to(&mut buf);
                maybe_periodic.encode_to(&mut buf);
                priority.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Cancel an anonymously scheduled task."]
            #[cfg(not(feature = "ink"))]
            pub fn cancel(
                &self,
                when: u32,
                index: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Scheduler(
                    types::pallet_scheduler::pallet::SchedulerCall::cancel { when, index },
                ))
            }
            #[doc = "Cancel an anonymously scheduled task."]
            #[cfg(feature = "ink")]
            pub fn cancel(&self, when: u32, index: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![36u8, 1u8];
                when.encode_to(&mut buf);
                index.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Schedule a named task."]
            #[cfg(not(feature = "ink"))]
            pub fn schedule_named(
                &self,
                id: [u8; 32usize],
                when: u32,
                maybe_periodic: Option<(u32, u32)>,
                priority: u8,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Scheduler(
                    types::pallet_scheduler::pallet::SchedulerCall::schedule_named {
                        id,
                        when,
                        maybe_periodic,
                        priority,
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Schedule a named task."]
            #[cfg(feature = "ink")]
            pub fn schedule_named(
                &self,
                id: [u8; 32usize],
                when: u32,
                maybe_periodic: Option<(u32, u32)>,
                priority: u8,
                call: runtime::RuntimeCall,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![36u8, 2u8];
                id.encode_to(&mut buf);
                when.encode_to(&mut buf);
                maybe_periodic.encode_to(&mut buf);
                priority.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Cancel a named scheduled task."]
            #[cfg(not(feature = "ink"))]
            pub fn cancel_named(
                &self,
                id: [u8; 32usize],
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Scheduler(
                    types::pallet_scheduler::pallet::SchedulerCall::cancel_named { id },
                ))
            }
            #[doc = "Cancel a named scheduled task."]
            #[cfg(feature = "ink")]
            pub fn cancel_named(&self, id: [u8; 32usize]) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![36u8, 3u8];
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Anonymously schedule a task after a delay."]
            #[cfg(not(feature = "ink"))]
            pub fn schedule_after(
                &self,
                after: u32,
                maybe_periodic: Option<(u32, u32)>,
                priority: u8,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Scheduler(
                    types::pallet_scheduler::pallet::SchedulerCall::schedule_after {
                        after,
                        maybe_periodic,
                        priority,
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Anonymously schedule a task after a delay."]
            #[cfg(feature = "ink")]
            pub fn schedule_after(
                &self,
                after: u32,
                maybe_periodic: Option<(u32, u32)>,
                priority: u8,
                call: runtime::RuntimeCall,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![36u8, 4u8];
                after.encode_to(&mut buf);
                maybe_periodic.encode_to(&mut buf);
                priority.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Schedule a named task after a delay."]
            #[cfg(not(feature = "ink"))]
            pub fn schedule_named_after(
                &self,
                id: [u8; 32usize],
                after: u32,
                maybe_periodic: Option<(u32, u32)>,
                priority: u8,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Scheduler(
                    types::pallet_scheduler::pallet::SchedulerCall::schedule_named_after {
                        id,
                        after,
                        maybe_periodic,
                        priority,
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Schedule a named task after a delay."]
            #[cfg(feature = "ink")]
            pub fn schedule_named_after(
                &self,
                id: [u8; 32usize],
                after: u32,
                maybe_periodic: Option<(u32, u32)>,
                priority: u8,
                call: runtime::RuntimeCall,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![36u8, 5u8];
                id.encode_to(&mut buf);
                after.encode_to(&mut buf);
                maybe_periodic.encode_to(&mut buf);
                priority.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set a retry configuration for a task so that, in case its scheduled run fails, it will"]
            #[doc = "be retried after `period` blocks, for a total amount of `retries` retries or until it"]
            #[doc = "succeeds."]
            #[doc = ""]
            #[doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"]
            #[doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"]
            #[doc = "normally while the task is retrying."]
            #[doc = ""]
            #[doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"]
            #[doc = "clones of the original task. Their retry configuration will be derived from the"]
            #[doc = "original task's configuration, but will have a lower value for `remaining` than the"]
            #[doc = "original `total_retries`."]
            #[cfg(not(feature = "ink"))]
            pub fn set_retry(
                &self,
                task: (u32, u32),
                retries: u8,
                period: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Scheduler(
                    types::pallet_scheduler::pallet::SchedulerCall::set_retry {
                        task,
                        retries,
                        period,
                    },
                ))
            }
            #[doc = "Set a retry configuration for a task so that, in case its scheduled run fails, it will"]
            #[doc = "be retried after `period` blocks, for a total amount of `retries` retries or until it"]
            #[doc = "succeeds."]
            #[doc = ""]
            #[doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"]
            #[doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"]
            #[doc = "normally while the task is retrying."]
            #[doc = ""]
            #[doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"]
            #[doc = "clones of the original task. Their retry configuration will be derived from the"]
            #[doc = "original task's configuration, but will have a lower value for `remaining` than the"]
            #[doc = "original `total_retries`."]
            #[cfg(feature = "ink")]
            pub fn set_retry(
                &self,
                task: (u32, u32),
                retries: u8,
                period: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![36u8, 6u8];
                task.encode_to(&mut buf);
                retries.encode_to(&mut buf);
                period.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set a retry configuration for a named task so that, in case its scheduled run fails, it"]
            #[doc = "will be retried after `period` blocks, for a total amount of `retries` retries or until"]
            #[doc = "it succeeds."]
            #[doc = ""]
            #[doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"]
            #[doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"]
            #[doc = "normally while the task is retrying."]
            #[doc = ""]
            #[doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"]
            #[doc = "clones of the original task. Their retry configuration will be derived from the"]
            #[doc = "original task's configuration, but will have a lower value for `remaining` than the"]
            #[doc = "original `total_retries`."]
            #[cfg(not(feature = "ink"))]
            pub fn set_retry_named(
                &self,
                id: [u8; 32usize],
                retries: u8,
                period: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Scheduler(
                    types::pallet_scheduler::pallet::SchedulerCall::set_retry_named {
                        id,
                        retries,
                        period,
                    },
                ))
            }
            #[doc = "Set a retry configuration for a named task so that, in case its scheduled run fails, it"]
            #[doc = "will be retried after `period` blocks, for a total amount of `retries` retries or until"]
            #[doc = "it succeeds."]
            #[doc = ""]
            #[doc = "Tasks which need to be scheduled for a retry are still subject to weight metering and"]
            #[doc = "agenda space, same as a regular task. If a periodic task fails, it will be scheduled"]
            #[doc = "normally while the task is retrying."]
            #[doc = ""]
            #[doc = "Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic"]
            #[doc = "clones of the original task. Their retry configuration will be derived from the"]
            #[doc = "original task's configuration, but will have a lower value for `remaining` than the"]
            #[doc = "original `total_retries`."]
            #[cfg(feature = "ink")]
            pub fn set_retry_named(
                &self,
                id: [u8; 32usize],
                retries: u8,
                period: u32,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![36u8, 7u8];
                id.encode_to(&mut buf);
                retries.encode_to(&mut buf);
                period.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the retry configuration of a task."]
            #[cfg(not(feature = "ink"))]
            pub fn cancel_retry(
                &self,
                task: (u32, u32),
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Scheduler(
                    types::pallet_scheduler::pallet::SchedulerCall::cancel_retry { task },
                ))
            }
            #[doc = "Removes the retry configuration of a task."]
            #[cfg(feature = "ink")]
            pub fn cancel_retry(&self, task: (u32, u32)) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![36u8, 8u8];
                task.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Cancel the retry configuration of a named task."]
            #[cfg(not(feature = "ink"))]
            pub fn cancel_retry_named(
                &self,
                id: [u8; 32usize],
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Scheduler(
                    types::pallet_scheduler::pallet::SchedulerCall::cancel_retry_named { id },
                ))
            }
            #[doc = "Cancel the retry configuration of a named task."]
            #[cfg(feature = "ink")]
            pub fn cancel_retry_named(&self, id: [u8; 32usize]) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![36u8, 9u8];
                id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for SchedulerCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct SchedulerQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> SchedulerQueryApi<'api> {
            #[doc = " Block number at which the agenda began incomplete execution."]
            #[cfg(not(feature = "ink"))]
            pub async fn incomplete_since(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<u32>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 247u8, 190u8, 155u8, 11u8, 241u8, 111u8,
                    132u8, 229u8, 89u8, 165u8, 129u8, 1u8, 200u8, 145u8, 213u8, 35u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Block number at which the agenda began incomplete execution."]
            #[cfg(feature = "ink")]
            pub fn incomplete_since(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                let value = self.api.read_storage(::alloc::vec![
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 247u8, 190u8, 155u8, 11u8, 241u8, 111u8,
                    132u8, 229u8, 89u8, 165u8, 129u8, 1u8, 200u8, 145u8, 213u8, 35u8,
                ])?;
                Ok(value)
            }
            #[doc = " Items to be executed, indexed by the block number that they should be executed on."]
            #[cfg(not(feature = "ink"))]
            pub async fn agenda(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<
                    Option<
                        types::pallet_scheduler::Scheduled<
                            [u8; 32usize],
                            types::frame_support::traits::preimages::Bounded<
                                runtime::RuntimeCall,
                                types::sp_runtime::traits::BlakeTwo256,
                            >,
                            u32,
                            runtime::OriginCaller,
                            ::polymesh_api_client::AccountId,
                        >,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 22u8, 67u8, 245u8, 65u8, 151u8, 24u8, 33u8,
                    156u8, 149u8, 103u8, 157u8, 221u8, 45u8, 130u8, 85u8, 116u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        Option<
                            types::pallet_scheduler::Scheduled<
                                [u8; 32usize],
                                types::frame_support::traits::preimages::Bounded<
                                    runtime::RuntimeCall,
                                    types::sp_runtime::traits::BlakeTwo256,
                                >,
                                u32,
                                runtime::OriginCaller,
                                ::polymesh_api_client::AccountId,
                            >,
                        >,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Items to be executed, indexed by the block number that they should be executed on."]
            #[cfg(feature = "ink")]
            pub fn agenda(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<
                    Option<
                        types::pallet_scheduler::Scheduled<
                            [u8; 32usize],
                            types::frame_support::traits::preimages::Bounded<
                                runtime::RuntimeCall,
                                types::sp_runtime::traits::BlakeTwo256,
                            >,
                            u32,
                            runtime::OriginCaller,
                            ::polymesh_api_client::AccountId,
                        >,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 22u8, 67u8, 245u8, 65u8, 151u8, 24u8, 33u8,
                    156u8, 149u8, 103u8, 157u8, 221u8, 45u8, 130u8, 85u8, 116u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<
                        Option<
                            types::pallet_scheduler::Scheduled<
                                [u8; 32usize],
                                types::frame_support::traits::preimages::Bounded<
                                    runtime::RuntimeCall,
                                    types::sp_runtime::traits::BlakeTwo256,
                                >,
                                u32,
                                runtime::OriginCaller,
                                ::polymesh_api_client::AccountId,
                            >,
                        >,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Retry configurations for items to be executed, indexed by task address."]
            #[cfg(not(feature = "ink"))]
            pub async fn retries(
                &self,
                key_0: (u32, u32),
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_scheduler::RetryConfig<u32>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 71u8, 127u8, 133u8, 185u8, 84u8, 220u8,
                    120u8, 96u8, 9u8, 110u8, 108u8, 164u8, 88u8, 214u8, 14u8, 101u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Retry configurations for items to be executed, indexed by task address."]
            #[cfg(feature = "ink")]
            pub fn retries(
                &self,
                key_0: (u32, u32),
            ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_scheduler::RetryConfig<u32>>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 71u8, 127u8, 133u8, 185u8, 84u8, 220u8,
                    120u8, 96u8, 9u8, 110u8, 108u8, 164u8, 88u8, 214u8, 14u8, 101u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Lookup from a name to the block number and index of the task."]
            #[doc = ""]
            #[doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"]
            #[doc = " identities."]
            #[cfg(not(feature = "ink"))]
            pub async fn lookup(
                &self,
                key_0: [u8; 32usize],
            ) -> ::polymesh_api_client::error::Result<Option<(u32, u32)>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 137u8, 26u8, 212u8, 87u8, 191u8, 77u8, 165u8,
                    73u8, 144u8, 250u8, 132u8, 162u8, 172u8, 177u8, 72u8, 162u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Lookup from a name to the block number and index of the task."]
            #[doc = ""]
            #[doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"]
            #[doc = " identities."]
            #[cfg(feature = "ink")]
            pub fn lookup(
                &self,
                key_0: [u8; 32usize],
            ) -> ::polymesh_api_ink::error::Result<Option<(u32, u32)>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 137u8, 26u8, 212u8, 87u8, 191u8, 77u8, 165u8,
                    73u8, 144u8, 250u8, 132u8, 162u8, 172u8, 177u8, 72u8, 162u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct SchedulerPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> SchedulerPagedQueryApi<'api> {
            #[doc = " Items to be executed, indexed by the block number that they should be executed on."]
            pub fn agenda(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                u32,
                ::alloc::vec::Vec<
                    Option<
                        types::pallet_scheduler::Scheduled<
                            [u8; 32usize],
                            types::frame_support::traits::preimages::Bounded<
                                runtime::RuntimeCall,
                                types::sp_runtime::traits::BlakeTwo256,
                            >,
                            u32,
                            runtime::OriginCaller,
                            ::polymesh_api_client::AccountId,
                        >,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 22u8, 67u8, 245u8, 65u8, 151u8, 24u8, 33u8,
                    156u8, 149u8, 103u8, 157u8, 221u8, 45u8, 130u8, 85u8, 116u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Retry configurations for items to be executed, indexed by task address."]
            pub fn retries(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                (u32, u32),
                types::pallet_scheduler::RetryConfig<u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 71u8, 127u8, 133u8, 185u8, 84u8, 220u8,
                    120u8, 96u8, 9u8, 110u8, 108u8, 164u8, 88u8, 214u8, 14u8, 101u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Lookup from a name to the block number and index of the task."]
            #[doc = ""]
            #[doc = " For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4"]
            #[doc = " identities."]
            pub fn lookup(&self) -> ::polymesh_api_client::StoragePaged<[u8; 32usize], (u32, u32)> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    61u8, 183u8, 162u8, 76u8, 253u8, 201u8, 222u8, 120u8, 89u8, 116u8, 116u8,
                    108u8, 20u8, 169u8, 157u8, 249u8, 137u8, 26u8, 212u8, 87u8, 191u8, 77u8, 165u8,
                    73u8, 144u8, 250u8, 132u8, 162u8, 172u8, 177u8, 72u8, 162u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod settlement {
        use super::*;
        #[derive(Clone)]
        pub struct SettlementCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> SettlementCallApi<'api> {
            #[doc = "Registers a new venue."]
            #[doc = ""]
            #[doc = "* `details` - Extra details about a venue"]
            #[doc = "* `signers` - Array of signers that are allowed to sign receipts for this venue"]
            #[doc = "* `typ` - Type of venue being created"]
            #[cfg(not(feature = "ink"))]
            pub fn create_venue(
                &self,
                details: types::polymesh_primitives::settlement::VenueDetails,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                typ: types::polymesh_primitives::settlement::VenueType,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::create_venue {
                        details,
                        signers,
                        typ,
                    },
                ))
            }
            #[doc = "Registers a new venue."]
            #[doc = ""]
            #[doc = "* `details` - Extra details about a venue"]
            #[doc = "* `signers` - Array of signers that are allowed to sign receipts for this venue"]
            #[doc = "* `typ` - Type of venue being created"]
            #[cfg(feature = "ink")]
            pub fn create_venue(
                &self,
                details: types::polymesh_primitives::settlement::VenueDetails,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                typ: types::polymesh_primitives::settlement::VenueType,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 0u8];
                details.encode_to(&mut buf);
                signers.encode_to(&mut buf);
                typ.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Edit a venue's details."]
            #[doc = ""]
            #[doc = "* `id` specifies the ID of the venue to edit."]
            #[doc = "* `details` specifies the updated venue details."]
            #[cfg(not(feature = "ink"))]
            pub fn update_venue_details(
                &self,
                id: types::polymesh_primitives::settlement::VenueId,
                details: types::polymesh_primitives::settlement::VenueDetails,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::update_venue_details {
                        id,
                        details,
                    },
                ))
            }
            #[doc = "Edit a venue's details."]
            #[doc = ""]
            #[doc = "* `id` specifies the ID of the venue to edit."]
            #[doc = "* `details` specifies the updated venue details."]
            #[cfg(feature = "ink")]
            pub fn update_venue_details(
                &self,
                id: types::polymesh_primitives::settlement::VenueId,
                details: types::polymesh_primitives::settlement::VenueDetails,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 1u8];
                id.encode_to(&mut buf);
                details.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Edit a venue's type."]
            #[doc = ""]
            #[doc = "* `id` specifies the ID of the venue to edit."]
            #[doc = "* `type` specifies the new type of the venue."]
            #[cfg(not(feature = "ink"))]
            pub fn update_venue_type(
                &self,
                id: types::polymesh_primitives::settlement::VenueId,
                typ: types::polymesh_primitives::settlement::VenueType,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::update_venue_type { id, typ },
                ))
            }
            #[doc = "Edit a venue's type."]
            #[doc = ""]
            #[doc = "* `id` specifies the ID of the venue to edit."]
            #[doc = "* `type` specifies the new type of the venue."]
            #[cfg(feature = "ink")]
            pub fn update_venue_type(
                &self,
                id: types::polymesh_primitives::settlement::VenueId,
                typ: types::polymesh_primitives::settlement::VenueType,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 2u8];
                id.encode_to(&mut buf);
                typ.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Affirms an instruction using receipts for offchain transfers."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
            #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn affirm_with_receipts(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                receipt_details: ::alloc::vec::Vec<
                    types::polymesh_primitives::settlement::ReceiptDetails<
                        ::polymesh_api_client::AccountId,
                        ::polymesh_api_client::MultiSignature,
                    >,
                >,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::affirm_with_receipts {
                        id,
                        receipt_details,
                        portfolios,
                    },
                ))
            }
            #[doc = "Affirms an instruction using receipts for offchain transfers."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
            #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn affirm_with_receipts(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                receipt_details: ::alloc::vec::Vec<
                    types::polymesh_primitives::settlement::ReceiptDetails<
                        ::polymesh_api_client::AccountId,
                        ::polymesh_api_client::MultiSignature,
                    >,
                >,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 3u8];
                id.encode_to(&mut buf);
                receipt_details.encode_to(&mut buf);
                portfolios.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Enables or disabled venue filtering for a token."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `asset_id` - AssetId of the token in question."]
            #[doc = "* `enabled` - Boolean that decides if the filtering should be enabled."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn set_venue_filtering(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                enabled: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::set_venue_filtering {
                        asset_id,
                        enabled,
                    },
                ))
            }
            #[doc = "Enables or disabled venue filtering for a token."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `asset_id` - AssetId of the token in question."]
            #[doc = "* `enabled` - Boolean that decides if the filtering should be enabled."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn set_venue_filtering(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                enabled: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 4u8];
                asset_id.encode_to(&mut buf);
                enabled.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Allows additional venues to create instructions involving an asset."]
            #[doc = ""]
            #[doc = "* `asset_id` - AssetId of the token in question."]
            #[doc = "* `venues` - Array of venues that are allowed to create instructions for the token in question."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn allow_venues(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::allow_venues {
                        asset_id,
                        venues,
                    },
                ))
            }
            #[doc = "Allows additional venues to create instructions involving an asset."]
            #[doc = ""]
            #[doc = "* `asset_id` - AssetId of the token in question."]
            #[doc = "* `venues` - Array of venues that are allowed to create instructions for the token in question."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn allow_venues(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 5u8];
                asset_id.encode_to(&mut buf);
                venues.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Revokes permission given to venues for creating instructions involving a particular asset."]
            #[doc = ""]
            #[doc = "* `asset_id` - AssetId of the token in question."]
            #[doc = "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn disallow_venues(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::disallow_venues {
                        asset_id,
                        venues,
                    },
                ))
            }
            #[doc = "Revokes permission given to venues for creating instructions involving a particular asset."]
            #[doc = ""]
            #[doc = "* `asset_id` - AssetId of the token in question."]
            #[doc = "* `venues` - Array of venues that are no longer allowed to create instructions for the token in question."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn disallow_venues(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                venues: ::alloc::vec::Vec<types::polymesh_primitives::settlement::VenueId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 6u8];
                asset_id.encode_to(&mut buf);
                venues.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Edit a venue's signers."]
            #[doc = "* `id` specifies the ID of the venue to edit."]
            #[doc = "* `signers` specifies the signers to add/remove."]
            #[doc = "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false."]
            #[cfg(not(feature = "ink"))]
            pub fn update_venue_signers(
                &self,
                id: types::polymesh_primitives::settlement::VenueId,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                add_signers: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::update_venue_signers {
                        id,
                        signers,
                        add_signers,
                    },
                ))
            }
            #[doc = "Edit a venue's signers."]
            #[doc = "* `id` specifies the ID of the venue to edit."]
            #[doc = "* `signers` specifies the signers to add/remove."]
            #[doc = "* `add_signers` specifies the update type add/remove of venue where add is true and remove is false."]
            #[cfg(feature = "ink")]
            pub fn update_venue_signers(
                &self,
                id: types::polymesh_primitives::settlement::VenueId,
                signers: ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                add_signers: bool,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 7u8];
                id.encode_to(&mut buf);
                signers.encode_to(&mut buf);
                add_signers.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Manually executes an instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id`: The [`InstructionId`] of the instruction to be executed."]
            #[doc = "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction."]
            #[doc = "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]."]
            #[doc = "* `fungible_transfers`: The number of fungible legs in the instruction."]
            #[doc = "* `nfts_transfers`: The number of nfts being transferred in the instruction."]
            #[doc = "* `offchain_transfers`: The number of offchain legs in the instruction."]
            #[doc = "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction."]
            #[doc = "If the `weight_limit` is less than the required amount, the instruction will fail execution."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters."]
            #[cfg(not(feature = "ink"))]
            pub fn execute_manual_instruction(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolio: Option<types::polymesh_primitives::identity_id::PortfolioId>,
                fungible_transfers: u32,
                nfts_transfers: u32,
                offchain_transfers: u32,
                weight_limit: Option<::polymesh_api_client::sp_weights::Weight>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::execute_manual_instruction {
                        id,
                        portfolio,
                        fungible_transfers,
                        nfts_transfers,
                        offchain_transfers,
                        weight_limit,
                    },
                ))
            }
            #[doc = "Manually executes an instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id`: The [`InstructionId`] of the instruction to be executed."]
            #[doc = "* `portfolio`:  One of the caller's [`PortfolioId`] which is also a counter patry in the instruction."]
            #[doc = "If None, the caller must be the venue creator or a counter party in a [`Leg::OffChain`]."]
            #[doc = "* `fungible_transfers`: The number of fungible legs in the instruction."]
            #[doc = "* `nfts_transfers`: The number of nfts being transferred in the instruction."]
            #[doc = "* `offchain_transfers`: The number of offchain legs in the instruction."]
            #[doc = "* `weight_limit`: An optional maximum [`Weight`] value to be charged for executing the instruction."]
            #[doc = "If the `weight_limit` is less than the required amount, the instruction will fail execution."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contains the count parameters."]
            #[cfg(feature = "ink")]
            pub fn execute_manual_instruction(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolio: Option<types::polymesh_primitives::identity_id::PortfolioId>,
                fungible_transfers: u32,
                nfts_transfers: u32,
                offchain_transfers: u32,
                weight_limit: Option<::polymesh_api_client::sp_weights::Weight>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 8u8];
                id.encode_to(&mut buf);
                portfolio.encode_to(&mut buf);
                fungible_transfers.encode_to(&mut buf);
                nfts_transfers.encode_to(&mut buf);
                offchain_transfers.encode_to(&mut buf);
                weight_limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds a new instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `venue_id`: The optional [`VenueId`] of the venue this instruction belongs to."]
            #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
            #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
            #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
            #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
            #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
            #[cfg(not(feature = "ink"))]
            pub fn add_instruction(
                &self,
                venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
                settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
                trade_date: Option<u64>,
                value_date: Option<u64>,
                legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
                instruction_memo: Option<types::polymesh_primitives::Memo>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::add_instruction {
                        venue_id,
                        settlement_type,
                        trade_date,
                        value_date,
                        legs,
                        instruction_memo,
                    },
                ))
            }
            #[doc = "Adds a new instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `venue_id`: The optional [`VenueId`] of the venue this instruction belongs to."]
            #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
            #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
            #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
            #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
            #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
            #[cfg(feature = "ink")]
            pub fn add_instruction(
                &self,
                venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
                settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
                trade_date: Option<u64>,
                value_date: Option<u64>,
                legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
                instruction_memo: Option<types::polymesh_primitives::Memo>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 9u8];
                venue_id.encode_to(&mut buf);
                settlement_type.encode_to(&mut buf);
                trade_date.encode_to(&mut buf);
                value_date.encode_to(&mut buf);
                legs.encode_to(&mut buf);
                instruction_memo.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds and affirms a new instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
            #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
            #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
            #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
            #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
            #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn add_and_affirm_instruction(
                &self,
                venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
                settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
                trade_date: Option<u64>,
                value_date: Option<u64>,
                legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
                instruction_memo: Option<types::polymesh_primitives::Memo>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::add_and_affirm_instruction {
                        venue_id,
                        settlement_type,
                        trade_date,
                        value_date,
                        legs,
                        portfolios,
                        instruction_memo,
                    },
                ))
            }
            #[doc = "Adds and affirms a new instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
            #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
            #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
            #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
            #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
            #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = "* `memo`: An optional [`Memo`] field for this instruction."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn add_and_affirm_instruction(
                &self,
                venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
                settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
                trade_date: Option<u64>,
                value_date: Option<u64>,
                legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
                instruction_memo: Option<types::polymesh_primitives::Memo>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 10u8];
                venue_id.encode_to(&mut buf);
                settlement_type.encode_to(&mut buf);
                trade_date.encode_to(&mut buf);
                value_date.encode_to(&mut buf);
                legs.encode_to(&mut buf);
                portfolios.encode_to(&mut buf);
                instruction_memo.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Provide affirmation to an existing instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn affirm_instruction(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::affirm_instruction {
                        id,
                        portfolios,
                    },
                ))
            }
            #[doc = "Provide affirmation to an existing instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn affirm_instruction(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 11u8];
                id.encode_to(&mut buf);
                portfolios.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Withdraw an affirmation for a given instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn withdraw_affirmation(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::withdraw_affirmation {
                        id,
                        portfolios,
                    },
                ))
            }
            #[doc = "Withdraw an affirmation for a given instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn withdraw_affirmation(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 12u8];
                id.encode_to(&mut buf);
                portfolios.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Rejects an existing instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
            #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn reject_instruction(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolio: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::reject_instruction {
                        id,
                        portfolio,
                    },
                ))
            }
            #[doc = "Rejects an existing instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
            #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn reject_instruction(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolio: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 13u8];
                id.encode_to(&mut buf);
                portfolio.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction."]
            #[cfg(not(feature = "ink"))]
            pub fn execute_scheduled_instruction(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                weight_limit: ::polymesh_api_client::sp_weights::Weight,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Settlement (types :: pallet_settlement :: pallet :: SettlementCall :: execute_scheduled_instruction { id , weight_limit , }))
            }
            #[doc = "Root callable extrinsic, used as an internal call to execute a scheduled settlement instruction."]
            #[cfg(feature = "ink")]
            pub fn execute_scheduled_instruction(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                weight_limit: ::polymesh_api_client::sp_weights::Weight,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 14u8];
                id.encode_to(&mut buf);
                weight_limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Affirms an instruction using receipts for offchain transfers."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
            #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn affirm_with_receipts_with_count(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                receipt_details: ::alloc::vec::Vec<
                    types::polymesh_primitives::settlement::ReceiptDetails<
                        ::polymesh_api_client::AccountId,
                        ::polymesh_api_client::MultiSignature,
                    >,
                >,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
                number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Settlement (types :: pallet_settlement :: pallet :: SettlementCall :: affirm_with_receipts_with_count { id , receipt_details , portfolios , number_of_assets , }))
            }
            #[doc = "Affirms an instruction using receipts for offchain transfers."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
            #[doc = "* `receipt_details` - a vector of [`ReceiptDetails`], which contain the details about the offchain transfer."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn affirm_with_receipts_with_count(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                receipt_details: ::alloc::vec::Vec<
                    types::polymesh_primitives::settlement::ReceiptDetails<
                        ::polymesh_api_client::AccountId,
                        ::polymesh_api_client::MultiSignature,
                    >,
                >,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
                number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 15u8];
                id.encode_to(&mut buf);
                receipt_details.encode_to(&mut buf);
                portfolios.encode_to(&mut buf);
                number_of_assets.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Provide affirmation to an existing instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn affirm_instruction_with_count(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
                number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Settlement (types :: pallet_settlement :: pallet :: SettlementCall :: affirm_instruction_with_count { id , portfolios , number_of_assets , }))
            }
            #[doc = "Provide affirmation to an existing instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being affirmed."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn affirm_instruction_with_count(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
                number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 16u8];
                id.encode_to(&mut buf);
                portfolios.encode_to(&mut buf);
                number_of_assets.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Rejects an existing instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
            #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
            #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn reject_instruction_with_count(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolio: types::polymesh_primitives::identity_id::PortfolioId,
                number_of_assets: Option<types::polymesh_primitives::settlement::AssetCount>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Settlement (types :: pallet_settlement :: pallet :: SettlementCall :: reject_instruction_with_count { id , portfolio , number_of_assets , }))
            }
            #[doc = "Rejects an existing instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction being rejected."]
            #[doc = "* `portfolio` - the [`PortfolioId`] that belongs to the instruction and is rejecting it."]
            #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn reject_instruction_with_count(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolio: types::polymesh_primitives::identity_id::PortfolioId,
                number_of_assets: Option<types::polymesh_primitives::settlement::AssetCount>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 17u8];
                id.encode_to(&mut buf);
                portfolio.encode_to(&mut buf);
                number_of_assets.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Withdraw an affirmation for a given instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
            #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn withdraw_affirmation_with_count(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
                number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Settlement (types :: pallet_settlement :: pallet :: SettlementCall :: withdraw_affirmation_with_count { id , portfolios , number_of_assets , }))
            }
            #[doc = "Withdraw an affirmation for a given instruction."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `id` - the [`InstructionId`] of the instruction getting an affirmation withdrawn."]
            #[doc = "* `portfolios` - a vector of [`PortfolioId`] under the caller's control and intended for affirmation withdrawal."]
            #[doc = "* `number_of_assets` - an optional [`AffirmationCount`] that will be used for a precise fee estimation before executing the extrinsic."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_affirmation_count` returns an instance of [`AffirmationCount`]."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn withdraw_affirmation_with_count(
                &self,
                id: types::polymesh_primitives::settlement::InstructionId,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
                number_of_assets: Option<types::polymesh_primitives::settlement::AffirmationCount>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 18u8];
                id.encode_to(&mut buf);
                portfolios.encode_to(&mut buf);
                number_of_assets.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds a new instruction with mediators."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
            #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
            #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
            #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
            #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
            #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
            #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
            #[cfg(not(feature = "ink"))]
            pub fn add_instruction_with_mediators(
                &self,
                venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
                settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
                trade_date: Option<u64>,
                value_date: Option<u64>,
                legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
                instruction_memo: Option<types::polymesh_primitives::Memo>,
                mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Settlement (types :: pallet_settlement :: pallet :: SettlementCall :: add_instruction_with_mediators { venue_id , settlement_type , trade_date , value_date , legs , instruction_memo , mediators , }))
            }
            #[doc = "Adds a new instruction with mediators."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
            #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
            #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
            #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
            #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
            #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
            #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
            #[cfg(feature = "ink")]
            pub fn add_instruction_with_mediators(
                &self,
                venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
                settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
                trade_date: Option<u64>,
                value_date: Option<u64>,
                legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
                instruction_memo: Option<types::polymesh_primitives::Memo>,
                mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 19u8];
                venue_id.encode_to(&mut buf);
                settlement_type.encode_to(&mut buf);
                trade_date.encode_to(&mut buf);
                value_date.encode_to(&mut buf);
                legs.encode_to(&mut buf);
                instruction_memo.encode_to(&mut buf);
                mediators.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Adds and affirms a new instruction with mediators."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
            #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
            #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
            #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
            #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
            #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
            #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn add_and_affirm_with_mediators(
                &self,
                venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
                settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
                trade_date: Option<u64>,
                value_date: Option<u64>,
                legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
                instruction_memo: Option<types::polymesh_primitives::Memo>,
                mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Settlement (types :: pallet_settlement :: pallet :: SettlementCall :: add_and_affirm_with_mediators { venue_id , settlement_type , trade_date , value_date , legs , portfolios , instruction_memo , mediators , }))
            }
            #[doc = "Adds and affirms a new instruction with mediators."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `venue_id`: The [`VenueId`] of the venue this instruction belongs to."]
            #[doc = "* `settlement_type`: The [`SettlementType`] specifying when the instruction should be settled."]
            #[doc = "* `trade_date`: Optional date from which people can interact with this instruction."]
            #[doc = "* `value_date`: Optional date after which the instruction should be settled (not enforced)."]
            #[doc = "* `legs`: A vector of all [`Leg`] included in this instruction."]
            #[doc = "* `portfolios`: A vector of [`PortfolioId`] under the caller's control and intended for affirmation."]
            #[doc = "* `instruction_memo`: An optional [`Memo`] field for this instruction."]
            #[doc = "* `mediators`: A set of [`IdentityId`] of all the mandatory mediators for the instruction."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn add_and_affirm_with_mediators(
                &self,
                venue_id: Option<types::polymesh_primitives::settlement::VenueId>,
                settlement_type: types::polymesh_primitives::settlement::SettlementType<u32>,
                trade_date: Option<u64>,
                value_date: Option<u64>,
                legs: ::alloc::vec::Vec<types::polymesh_primitives::settlement::Leg>,
                portfolios: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::identity_id::PortfolioId,
                >,
                instruction_memo: Option<types::polymesh_primitives::Memo>,
                mediators: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 20u8];
                venue_id.encode_to(&mut buf);
                settlement_type.encode_to(&mut buf);
                trade_date.encode_to(&mut buf);
                value_date.encode_to(&mut buf);
                legs.encode_to(&mut buf);
                portfolios.encode_to(&mut buf);
                instruction_memo.encode_to(&mut buf);
                mediators.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Affirms the instruction as a mediator - should only be called by mediators, otherwise it will fail."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin`: The secondary key of the sender."]
            #[doc = "* `instruction_id`: The [`InstructionId`] that will be affirmed by the mediator."]
            #[doc = "* `expiry`: An Optional value for defining when the affirmation will expire (None means it will always be valid)."]
            #[cfg(not(feature = "ink"))]
            pub fn affirm_instruction_as_mediator(
                &self,
                instruction_id: types::polymesh_primitives::settlement::InstructionId,
                expiry: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Settlement (types :: pallet_settlement :: pallet :: SettlementCall :: affirm_instruction_as_mediator { instruction_id , expiry , }))
            }
            #[doc = "Affirms the instruction as a mediator - should only be called by mediators, otherwise it will fail."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin`: The secondary key of the sender."]
            #[doc = "* `instruction_id`: The [`InstructionId`] that will be affirmed by the mediator."]
            #[doc = "* `expiry`: An Optional value for defining when the affirmation will expire (None means it will always be valid)."]
            #[cfg(feature = "ink")]
            pub fn affirm_instruction_as_mediator(
                &self,
                instruction_id: types::polymesh_primitives::settlement::InstructionId,
                expiry: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 21u8];
                instruction_id.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the mediator's affirmation for the instruction - should only be called by mediators, otherwise it will fail."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin`: The secondary key of the sender."]
            #[doc = "* `instruction_id`: The [`InstructionId`] that will have the affirmation removed."]
            #[cfg(not(feature = "ink"))]
            pub fn withdraw_affirmation_as_mediator(
                &self,
                instruction_id: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Settlement (types :: pallet_settlement :: pallet :: SettlementCall :: withdraw_affirmation_as_mediator { instruction_id , }))
            }
            #[doc = "Removes the mediator's affirmation for the instruction - should only be called by mediators, otherwise it will fail."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin`: The secondary key of the sender."]
            #[doc = "* `instruction_id`: The [`InstructionId`] that will have the affirmation removed."]
            #[cfg(feature = "ink")]
            pub fn withdraw_affirmation_as_mediator(
                &self,
                instruction_id: types::polymesh_primitives::settlement::InstructionId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 22u8];
                instruction_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Rejects an existing instruction - should only be called by mediators, otherwise it will fail."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `instruction_id` - the [`InstructionId`] of the instruction being rejected."]
            #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
            #[cfg(not(feature = "ink"))]
            pub fn reject_instruction_as_mediator(
                &self,
                instruction_id: types::polymesh_primitives::settlement::InstructionId,
                number_of_assets: Option<types::polymesh_primitives::settlement::AssetCount>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Settlement (types :: pallet_settlement :: pallet :: SettlementCall :: reject_instruction_as_mediator { instruction_id , number_of_assets , }))
            }
            #[doc = "Rejects an existing instruction - should only be called by mediators, otherwise it will fail."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `instruction_id` - the [`InstructionId`] of the instruction being rejected."]
            #[doc = "* `number_of_assets` - an optional [`AssetCount`] that will be used for a precise fee estimation before executing the extrinsic."]
            #[doc = ""]
            #[doc = "Note: calling the rpc method `get_execute_instruction_info` returns an instance of [`ExecuteInstructionInfo`], which contain the asset count."]
            #[cfg(feature = "ink")]
            pub fn reject_instruction_as_mediator(
                &self,
                instruction_id: types::polymesh_primitives::settlement::InstructionId,
                number_of_assets: Option<types::polymesh_primitives::settlement::AssetCount>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 23u8];
                instruction_id.encode_to(&mut buf);
                number_of_assets.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Moves the instruction status to `LockedForExecution`. This function must be called by a"]
            #[doc = "mediator of the instruction and will only suceed if the following conditions are met:"]
            #[doc = "- All affirmations have been received."]
            #[doc = "- Instruction is pending or has failed at least one time."]
            #[doc = "- All mediator's affirmations are still valid."]
            #[doc = "- All assets are in the allowed venue list."]
            #[doc = "- All senders have the right amount of assets being transferred."]
            #[doc = "- All senders and receivers are compliant and have valid CDD claims."]
            #[doc = "- All assets' statistics are still valid."]
            #[doc = "- There are no frozen assets."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, specifying the caller."]
            #[doc = "* `inst_id` - The [`InstructionId`] of the instruction to be locked."]
            #[doc = "* `weight_limit` - A maximum [`Weight`] value to be charged for locking the instruction."]
            #[cfg(not(feature = "ink"))]
            pub fn lock_instruction(
                &self,
                inst_id: types::polymesh_primitives::settlement::InstructionId,
                weight_limit: ::polymesh_api_client::sp_weights::Weight,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Settlement(
                    types::pallet_settlement::pallet::SettlementCall::lock_instruction {
                        inst_id,
                        weight_limit,
                    },
                ))
            }
            #[doc = "Moves the instruction status to `LockedForExecution`. This function must be called by a"]
            #[doc = "mediator of the instruction and will only suceed if the following conditions are met:"]
            #[doc = "- All affirmations have been received."]
            #[doc = "- Instruction is pending or has failed at least one time."]
            #[doc = "- All mediator's affirmations are still valid."]
            #[doc = "- All assets are in the allowed venue list."]
            #[doc = "- All senders have the right amount of assets being transferred."]
            #[doc = "- All senders and receivers are compliant and have valid CDD claims."]
            #[doc = "- All assets' statistics are still valid."]
            #[doc = "- There are no frozen assets."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - The origin of the call, specifying the caller."]
            #[doc = "* `inst_id` - The [`InstructionId`] of the instruction to be locked."]
            #[doc = "* `weight_limit` - A maximum [`Weight`] value to be charged for locking the instruction."]
            #[cfg(feature = "ink")]
            pub fn lock_instruction(
                &self,
                inst_id: types::polymesh_primitives::settlement::InstructionId,
                weight_limit: ::polymesh_api_client::sp_weights::Weight,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![37u8, 24u8];
                inst_id.encode_to(&mut buf);
                weight_limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for SettlementCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct SettlementQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> SettlementQueryApi<'api> {
            #[doc = " Info about a venue. venue_id -> venue"]
            #[cfg(not(feature = "ink"))]
            pub async fn venue_info(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::settlement::Venue>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 37u8, 149u8, 35u8, 221u8, 234u8, 221u8, 43u8,
                    130u8, 235u8, 131u8, 158u8, 182u8, 118u8, 158u8, 16u8, 163u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Info about a venue. venue_id -> venue"]
            #[cfg(feature = "ink")]
            pub fn venue_info(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::settlement::Venue>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 37u8, 149u8, 35u8, 221u8, 234u8, 221u8, 43u8,
                    130u8, 235u8, 131u8, 158u8, 182u8, 118u8, 158u8, 16u8, 163u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Free-form text about a venue. venue_id -> `VenueDetails`"]
            #[doc = " Only needed for the UI."]
            #[cfg(not(feature = "ink"))]
            pub async fn details(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::settlement::VenueDetails,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8,
                    226u8, 198u8, 220u8, 28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::VenueDetails>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Free-form text about a venue. venue_id -> `VenueDetails`"]
            #[doc = " Only needed for the UI."]
            #[cfg(feature = "ink")]
            pub fn details(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::settlement::VenueDetails,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8,
                    226u8, 198u8, 220u8, 28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::VenueDetails>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Instructions under a venue."]
            #[doc = " Only needed for the UI."]
            #[doc = ""]
            #[doc = " venue_id -> instruction_id -> ()"]
            #[cfg(not(feature = "ink"))]
            pub async fn venue_instructions(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
                key_1: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::error::Result<()> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 194u8, 12u8, 53u8, 241u8, 21u8, 245u8, 35u8,
                    172u8, 170u8, 85u8, 47u8, 113u8, 49u8, 126u8, 98u8, 7u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[];
                    <()>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Instructions under a venue."]
            #[doc = " Only needed for the UI."]
            #[doc = ""]
            #[doc = " venue_id -> instruction_id -> ()"]
            #[cfg(feature = "ink")]
            pub fn venue_instructions(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
                key_1: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_ink::error::Result<()> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 194u8, 12u8, 53u8, 241u8, 21u8, 245u8, 35u8,
                    172u8, 170u8, 85u8, 47u8, 113u8, 49u8, 126u8, 98u8, 7u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[];
                    <()>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Signers allowed by the venue. (venue_id, signer) -> bool"]
            #[cfg(not(feature = "ink"))]
            pub async fn venue_signers(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 182u8, 5u8, 81u8, 237u8, 11u8, 31u8, 45u8,
                    224u8, 46u8, 226u8, 44u8, 156u8, 78u8, 11u8, 160u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Signers allowed by the venue. (venue_id, signer) -> bool"]
            #[cfg(feature = "ink")]
            pub fn venue_signers(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
                key_1: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 182u8, 5u8, 81u8, 237u8, 11u8, 31u8, 45u8,
                    224u8, 46u8, 226u8, 44u8, 156u8, 78u8, 11u8, 160u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Venues create by an identity."]
            #[doc = " Only needed for the UI."]
            #[doc = ""]
            #[doc = " identity -> venue_id -> ()"]
            #[cfg(not(feature = "ink"))]
            pub async fn user_venues(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_client::error::Result<()> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 210u8, 109u8, 136u8, 8u8, 7u8, 235u8, 230u8,
                    119u8, 137u8, 87u8, 141u8, 192u8, 40u8, 218u8, 115u8, 74u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[];
                    <()>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Venues create by an identity."]
            #[doc = " Only needed for the UI."]
            #[doc = ""]
            #[doc = " identity -> venue_id -> ()"]
            #[cfg(feature = "ink")]
            pub fn user_venues(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_ink::error::Result<()> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 210u8, 109u8, 136u8, 8u8, 7u8, 235u8, 230u8,
                    119u8, 137u8, 87u8, 141u8, 192u8, 40u8, 218u8, 115u8, 74u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[];
                    <()>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Details about an instruction. instruction_id -> instruction_details"]
            #[cfg(not(feature = "ink"))]
            pub async fn instruction_details(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::settlement::Instruction<u64, u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 139u8, 174u8, 75u8, 191u8, 82u8, 90u8, 68u8,
                    48u8, 145u8, 19u8, 222u8, 238u8, 96u8, 255u8, 129u8, 178u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                    ];
                    <types::polymesh_primitives::settlement::Instruction<u64, u32>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Details about an instruction. instruction_id -> instruction_details"]
            #[cfg(feature = "ink")]
            pub fn instruction_details(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::settlement::Instruction<u64, u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 139u8, 174u8, 75u8, 191u8, 82u8, 90u8, 68u8,
                    48u8, 145u8, 19u8, 222u8, 238u8, 96u8, 255u8, 129u8, 178u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                    ];
                    <types::polymesh_primitives::settlement::Instruction<u64, u32>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Status of a leg under an instruction. (instruction_id, leg_id) -> LegStatus"]
            #[cfg(not(feature = "ink"))]
            pub async fn instruction_leg_status(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
                key_1: types::polymesh_primitives::settlement::LegId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::settlement::LegStatus<::polymesh_api_client::AccountId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 241u8, 210u8, 62u8, 209u8, 210u8, 216u8, 97u8,
                    163u8, 74u8, 117u8, 189u8, 72u8, 12u8, 109u8, 191u8, 35u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::LegStatus<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Status of a leg under an instruction. (instruction_id, leg_id) -> LegStatus"]
            #[cfg(feature = "ink")]
            pub fn instruction_leg_status(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
                key_1: types::polymesh_primitives::settlement::LegId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::settlement::LegStatus<::polymesh_api_client::AccountId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 241u8, 210u8, 62u8, 209u8, 210u8, 216u8, 97u8,
                    163u8, 74u8, 117u8, 189u8, 72u8, 12u8, 109u8, 191u8, 35u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::LegStatus<
                        ::polymesh_api_client::AccountId,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " Number of affirmations pending before instruction is executed. instruction_id -> affirm_pending"]
            #[cfg(not(feature = "ink"))]
            pub async fn instruction_affirms_pending(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 84u8, 168u8, 38u8, 237u8, 42u8, 215u8, 233u8,
                    246u8, 173u8, 70u8, 3u8, 122u8, 135u8, 90u8, 149u8, 95u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Number of affirmations pending before instruction is executed. instruction_id -> affirm_pending"]
            #[cfg(feature = "ink")]
            pub fn instruction_affirms_pending(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 84u8, 168u8, 38u8, 237u8, 42u8, 215u8, 233u8,
                    246u8, 173u8, 70u8, 3u8, 122u8, 135u8, 90u8, 149u8, 95u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Tracks affirmations received for an instruction. (instruction_id, counter_party) -> AffirmationStatus"]
            #[cfg(not(feature = "ink"))]
            pub async fn affirms_received(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
                key_1: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::settlement::AffirmationStatus,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 196u8, 164u8, 249u8, 77u8, 192u8, 14u8, 231u8,
                    77u8, 10u8, 20u8, 57u8, 61u8, 241u8, 216u8, 34u8, 202u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::AffirmationStatus>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Tracks affirmations received for an instruction. (instruction_id, counter_party) -> AffirmationStatus"]
            #[cfg(feature = "ink")]
            pub fn affirms_received(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
                key_1: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::settlement::AffirmationStatus,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 196u8, 164u8, 249u8, 77u8, 192u8, 14u8, 231u8,
                    77u8, 10u8, 20u8, 57u8, 61u8, 241u8, 216u8, 34u8, 202u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::AffirmationStatus>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Helps a user track their pending instructions and affirmations (only needed for UI)."]
            #[doc = " (counter_party, instruction_id) -> AffirmationStatus"]
            #[cfg(not(feature = "ink"))]
            pub async fn user_affirmations(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::settlement::AffirmationStatus,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 34u8, 4u8, 158u8, 52u8, 236u8, 109u8, 105u8,
                    33u8, 29u8, 40u8, 146u8, 57u8, 70u8, 48u8, 102u8, 159u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::AffirmationStatus>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Helps a user track their pending instructions and affirmations (only needed for UI)."]
            #[doc = " (counter_party, instruction_id) -> AffirmationStatus"]
            #[cfg(feature = "ink")]
            pub fn user_affirmations(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
                key_1: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::settlement::AffirmationStatus,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 34u8, 4u8, 158u8, 52u8, 236u8, 109u8, 105u8,
                    33u8, 29u8, 40u8, 146u8, 57u8, 70u8, 48u8, 102u8, 159u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::AffirmationStatus>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Tracks redemption of receipts. (signer, receipt_uid) -> receipt_used"]
            #[cfg(not(feature = "ink"))]
            pub async fn receipts_used(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: u64,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 127u8, 126u8, 234u8, 226u8, 61u8, 64u8, 167u8,
                    253u8, 218u8, 94u8, 162u8, 111u8, 120u8, 56u8, 116u8, 157u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Tracks redemption of receipts. (signer, receipt_uid) -> receipt_used"]
            #[cfg(feature = "ink")]
            pub fn receipts_used(
                &self,
                key_0: ::polymesh_api_client::AccountId,
                key_1: u64,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 127u8, 126u8, 234u8, 226u8, 61u8, 64u8, 167u8,
                    253u8, 218u8, 94u8, 162u8, 111u8, 120u8, 56u8, 116u8, 157u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Tracks if a token has enabled filtering venues that can create instructions involving their token. AssetId -> filtering_enabled"]
            #[cfg(not(feature = "ink"))]
            pub async fn venue_filtering(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 242u8, 42u8, 22u8, 99u8, 179u8, 59u8, 93u8,
                    97u8, 223u8, 90u8, 186u8, 160u8, 76u8, 19u8, 198u8, 73u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Tracks if a token has enabled filtering venues that can create instructions involving their token. AssetId -> filtering_enabled"]
            #[cfg(feature = "ink")]
            pub fn venue_filtering(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 242u8, 42u8, 22u8, 99u8, 179u8, 59u8, 93u8,
                    97u8, 223u8, 90u8, 186u8, 160u8, 76u8, 19u8, 198u8, 73u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Venues that are allowed to create instructions involving a particular asset. Only used if filtering is enabled."]
            #[doc = " ([`AssetId`], venue_id) -> allowed"]
            #[cfg(not(feature = "ink"))]
            pub async fn venue_allow_list(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 113u8, 120u8, 81u8, 211u8, 168u8, 229u8, 128u8,
                    215u8, 96u8, 177u8, 241u8, 151u8, 120u8, 224u8, 185u8, 22u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Venues that are allowed to create instructions involving a particular asset. Only used if filtering is enabled."]
            #[doc = " ([`AssetId`], venue_id) -> allowed"]
            #[cfg(feature = "ink")]
            pub fn venue_allow_list(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 113u8, 120u8, 81u8, 211u8, 168u8, 229u8, 128u8,
                    215u8, 96u8, 177u8, 241u8, 151u8, 120u8, 224u8, 185u8, 22u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Number of venues in the system (It's one more than the actual number)"]
            #[cfg(not(feature = "ink"))]
            pub async fn venue_counter(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::settlement::VenueId>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 117u8, 30u8, 157u8, 0u8, 240u8, 121u8, 103u8,
                    207u8, 127u8, 87u8, 212u8, 100u8, 178u8, 100u8, 6u8, 108u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::settlement::VenueId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Number of venues in the system (It's one more than the actual number)"]
            #[cfg(feature = "ink")]
            pub fn venue_counter(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::settlement::VenueId>
            {
                let value = self.api.read_storage(::alloc::vec![
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 117u8, 30u8, 157u8, 0u8, 240u8, 121u8, 103u8,
                    207u8, 127u8, 87u8, 212u8, 100u8, 178u8, 100u8, 6u8, 108u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::settlement::VenueId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Number of instructions in the system (It's one more than the actual number)"]
            #[cfg(not(feature = "ink"))]
            pub async fn instruction_counter(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::settlement::InstructionId,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 186u8, 56u8, 151u8, 67u8, 78u8, 201u8, 90u8,
                    108u8, 36u8, 245u8, 147u8, 242u8, 23u8, 13u8, 233u8, 58u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::settlement::InstructionId>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Number of instructions in the system (It's one more than the actual number)"]
            #[cfg(feature = "ink")]
            pub fn instruction_counter(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::settlement::InstructionId,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 186u8, 56u8, 151u8, 67u8, 78u8, 201u8, 90u8,
                    108u8, 36u8, 245u8, 147u8, 242u8, 23u8, 13u8, 233u8, 58u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::settlement::InstructionId>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Instruction memo"]
            #[cfg(not(feature = "ink"))]
            pub async fn instruction_memos(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::Memo>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 91u8, 46u8, 219u8, 158u8, 9u8, 52u8, 231u8,
                    25u8, 76u8, 164u8, 67u8, 166u8, 153u8, 53u8, 138u8, 48u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Instruction memo"]
            #[cfg(feature = "ink")]
            pub fn instruction_memos(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::Memo>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 91u8, 46u8, 219u8, 158u8, 9u8, 52u8, 231u8,
                    25u8, 76u8, 164u8, 67u8, 166u8, 153u8, 53u8, 138u8, 48u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Instruction statuses. instruction_id -> InstructionStatus"]
            #[cfg(not(feature = "ink"))]
            pub async fn instruction_statuses(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::settlement::InstructionStatus<u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 129u8, 220u8, 107u8, 190u8, 175u8, 117u8, 37u8,
                    159u8, 155u8, 144u8, 126u8, 158u8, 40u8, 0u8, 88u8, 54u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::InstructionStatus<u32>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Instruction statuses. instruction_id -> InstructionStatus"]
            #[cfg(feature = "ink")]
            pub fn instruction_statuses(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::settlement::InstructionStatus<u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 129u8, 220u8, 107u8, 190u8, 175u8, 117u8, 37u8,
                    159u8, 155u8, 144u8, 126u8, 158u8, 40u8, 0u8, 88u8, 54u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::InstructionStatus<u32>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Legs under an instruction. (instruction_id, leg_id) -> Leg"]
            #[cfg(not(feature = "ink"))]
            pub async fn instruction_legs(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
                key_1: types::polymesh_primitives::settlement::LegId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::settlement::Leg>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 17u8, 1u8, 179u8, 157u8, 113u8, 141u8, 101u8,
                    250u8, 213u8, 115u8, 20u8, 61u8, 204u8, 53u8, 74u8, 4u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Legs under an instruction. (instruction_id, leg_id) -> Leg"]
            #[cfg(feature = "ink")]
            pub fn instruction_legs(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
                key_1: types::polymesh_primitives::settlement::LegId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::settlement::Leg>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 17u8, 1u8, 179u8, 157u8, 113u8, 141u8, 101u8,
                    250u8, 213u8, 115u8, 20u8, 61u8, 204u8, 53u8, 74u8, 4u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Tracks the affirmation status for offchain legs in a instruction. [`(InstructionId, LegId)`] -> [`AffirmationStatus`]"]
            #[cfg(not(feature = "ink"))]
            pub async fn off_chain_affirmations(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
                key_1: types::polymesh_primitives::settlement::LegId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::settlement::AffirmationStatus,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 83u8, 128u8, 215u8, 35u8, 66u8, 131u8, 241u8,
                    146u8, 213u8, 20u8, 216u8, 29u8, 178u8, 153u8, 36u8, 132u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::AffirmationStatus>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Tracks the affirmation status for offchain legs in a instruction. [`(InstructionId, LegId)`] -> [`AffirmationStatus`]"]
            #[cfg(feature = "ink")]
            pub fn off_chain_affirmations(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
                key_1: types::polymesh_primitives::settlement::LegId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::settlement::AffirmationStatus,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 83u8, 128u8, 215u8, 35u8, 66u8, 131u8, 241u8,
                    146u8, 213u8, 20u8, 216u8, 29u8, 178u8, 153u8, 36u8, 132u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::settlement::AffirmationStatus>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Tracks the number of signers each venue has."]
            #[cfg(not(feature = "ink"))]
            pub async fn number_of_venue_signers(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_client::error::Result<u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 65u8, 49u8, 135u8, 25u8, 96u8, 14u8, 112u8,
                    10u8, 188u8, 29u8, 148u8, 244u8, 217u8, 121u8, 111u8, 6u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Tracks the number of signers each venue has."]
            #[cfg(feature = "ink")]
            pub fn number_of_venue_signers(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_ink::error::Result<u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 65u8, 49u8, 135u8, 25u8, 96u8, 14u8, 112u8,
                    10u8, 188u8, 29u8, 148u8, 244u8, 217u8, 121u8, 111u8, 6u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The status for the mediators affirmation."]
            #[cfg(not(feature = "ink"))]
            pub async fn instruction_mediators_affirmations(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::settlement::MediatorAffirmationStatus<u64>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 195u8, 167u8, 176u8, 135u8, 61u8, 124u8, 1u8,
                    184u8, 154u8, 97u8, 6u8, 91u8, 221u8, 125u8, 202u8, 39u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                buf.extend(key_1.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < types :: polymesh_primitives :: settlement :: MediatorAffirmationStatus < u64 > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " The status for the mediators affirmation."]
            #[cfg(feature = "ink")]
            pub fn instruction_mediators_affirmations(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::settlement::MediatorAffirmationStatus<u64>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 195u8, 167u8, 176u8, 135u8, 61u8, 124u8, 1u8,
                    184u8, 154u8, 97u8, 6u8, 91u8, 221u8, 125u8, 202u8, 39u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                buf.extend(key_1.encode());
                let value = self.api.read_storage(buf)?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < types :: polymesh_primitives :: settlement :: MediatorAffirmationStatus < u64 > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " The moment the instruction was moved to the `LockedForExecution` status."]
            #[cfg(not(feature = "ink"))]
            pub async fn locked_timestamp(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::error::Result<Option<u64>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 162u8, 178u8, 103u8, 231u8, 33u8, 51u8, 97u8,
                    178u8, 214u8, 32u8, 225u8, 175u8, 31u8, 4u8, 59u8, 230u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The moment the instruction was moved to the `LockedForExecution` status."]
            #[cfg(feature = "ink")]
            pub fn locked_timestamp(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_ink::error::Result<Option<u64>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 162u8, 178u8, 103u8, 231u8, 33u8, 51u8, 97u8,
                    178u8, 214u8, 32u8, 225u8, 175u8, 31u8, 4u8, 59u8, 230u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_settlement::pallet::Version>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_settlement::pallet::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_settlement::pallet::Version>
            {
                let value = self.api.read_storage(::alloc::vec![
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8,
                    90u8, 130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_settlement::pallet::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct SettlementPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> SettlementPagedQueryApi<'api> {
            #[doc = " Info about a venue. venue_id -> venue"]
            pub fn venue_info(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::VenueId,
                types::polymesh_primitives::settlement::Venue,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 37u8, 149u8, 35u8, 221u8, 234u8, 221u8, 43u8,
                    130u8, 235u8, 131u8, 158u8, 182u8, 118u8, 158u8, 16u8, 163u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Free-form text about a venue. venue_id -> `VenueDetails`"]
            #[doc = " Only needed for the UI."]
            pub fn details(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::VenueId,
                types::polymesh_primitives::settlement::VenueDetails,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 38u8, 140u8, 214u8, 5u8, 85u8, 135u8, 135u8,
                    226u8, 198u8, 220u8, 28u8, 194u8, 130u8, 139u8, 228u8, 24u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Instructions under a venue."]
            #[doc = " Only needed for the UI."]
            #[doc = ""]
            #[doc = " venue_id -> instruction_id -> ()"]
            pub fn venue_instructions(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::InstructionId,
                (),
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 194u8, 12u8, 53u8, 241u8, 21u8, 245u8, 35u8,
                    172u8, 170u8, 85u8, 47u8, 113u8, 49u8, 126u8, 98u8, 7u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Signers allowed by the venue. (venue_id, signer) -> bool"]
            pub fn venue_signers(
                &self,
                key_0: types::polymesh_primitives::settlement::VenueId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 182u8, 5u8, 81u8, 237u8, 11u8, 31u8, 45u8,
                    224u8, 46u8, 226u8, 44u8, 156u8, 78u8, 11u8, 160u8, 64u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Venues create by an identity."]
            #[doc = " Only needed for the UI."]
            #[doc = ""]
            #[doc = " identity -> venue_id -> ()"]
            pub fn user_venues(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::VenueId,
                (),
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 210u8, 109u8, 136u8, 8u8, 7u8, 235u8, 230u8,
                    119u8, 137u8, 87u8, 141u8, 192u8, 40u8, 218u8, 115u8, 74u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Details about an instruction. instruction_id -> instruction_details"]
            pub fn instruction_details(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::InstructionId,
                types::polymesh_primitives::settlement::Instruction<u64, u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 139u8, 174u8, 75u8, 191u8, 82u8, 90u8, 68u8,
                    48u8, 145u8, 19u8, 222u8, 238u8, 96u8, 255u8, 129u8, 178u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Status of a leg under an instruction. (instruction_id, leg_id) -> LegStatus"]
            pub fn instruction_leg_status(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::LegId,
                types::polymesh_primitives::settlement::LegStatus<::polymesh_api_client::AccountId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 241u8, 210u8, 62u8, 209u8, 210u8, 216u8, 97u8,
                    163u8, 74u8, 117u8, 189u8, 72u8, 12u8, 109u8, 191u8, 35u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Number of affirmations pending before instruction is executed. instruction_id -> affirm_pending"]
            pub fn instruction_affirms_pending(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::InstructionId,
                u64,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 84u8, 168u8, 38u8, 237u8, 42u8, 215u8, 233u8,
                    246u8, 173u8, 70u8, 3u8, 122u8, 135u8, 90u8, 149u8, 95u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Tracks affirmations received for an instruction. (instruction_id, counter_party) -> AffirmationStatus"]
            pub fn affirms_received(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::identity_id::PortfolioId,
                types::polymesh_primitives::settlement::AffirmationStatus,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 196u8, 164u8, 249u8, 77u8, 192u8, 14u8, 231u8,
                    77u8, 10u8, 20u8, 57u8, 61u8, 241u8, 216u8, 34u8, 202u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Helps a user track their pending instructions and affirmations (only needed for UI)."]
            #[doc = " (counter_party, instruction_id) -> AffirmationStatus"]
            pub fn user_affirmations(
                &self,
                key_0: types::polymesh_primitives::identity_id::PortfolioId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::InstructionId,
                types::polymesh_primitives::settlement::AffirmationStatus,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 34u8, 4u8, 158u8, 52u8, 236u8, 109u8, 105u8,
                    33u8, 29u8, 40u8, 146u8, 57u8, 70u8, 48u8, 102u8, 159u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Tracks redemption of receipts. (signer, receipt_uid) -> receipt_used"]
            pub fn receipts_used(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::StoragePaged<u64, bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 127u8, 126u8, 234u8, 226u8, 61u8, 64u8, 167u8,
                    253u8, 218u8, 94u8, 162u8, 111u8, 120u8, 56u8, 116u8, 157u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Tracks if a token has enabled filtering venues that can create instructions involving their token. AssetId -> filtering_enabled"]
            pub fn venue_filtering(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 242u8, 42u8, 22u8, 99u8, 179u8, 59u8, 93u8,
                    97u8, 223u8, 90u8, 186u8, 160u8, 76u8, 19u8, 198u8, 73u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Venues that are allowed to create instructions involving a particular asset. Only used if filtering is enabled."]
            #[doc = " ([`AssetId`], venue_id) -> allowed"]
            pub fn venue_allow_list(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::VenueId,
                bool,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 113u8, 120u8, 81u8, 211u8, 168u8, 229u8, 128u8,
                    215u8, 96u8, 177u8, 241u8, 151u8, 120u8, 224u8, 185u8, 22u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Instruction memo"]
            pub fn instruction_memos(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::InstructionId,
                types::polymesh_primitives::Memo,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 91u8, 46u8, 219u8, 158u8, 9u8, 52u8, 231u8,
                    25u8, 76u8, 164u8, 67u8, 166u8, 153u8, 53u8, 138u8, 48u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Instruction statuses. instruction_id -> InstructionStatus"]
            pub fn instruction_statuses(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::InstructionId,
                types::polymesh_primitives::settlement::InstructionStatus<u32>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 129u8, 220u8, 107u8, 190u8, 175u8, 117u8, 37u8,
                    159u8, 155u8, 144u8, 126u8, 158u8, 40u8, 0u8, 88u8, 54u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Legs under an instruction. (instruction_id, leg_id) -> Leg"]
            pub fn instruction_legs(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::LegId,
                types::polymesh_primitives::settlement::Leg,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 17u8, 1u8, 179u8, 157u8, 113u8, 141u8, 101u8,
                    250u8, 213u8, 115u8, 20u8, 61u8, 204u8, 53u8, 74u8, 4u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Tracks the affirmation status for offchain legs in a instruction. [`(InstructionId, LegId)`] -> [`AffirmationStatus`]"]
            pub fn off_chain_affirmations(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::LegId,
                types::polymesh_primitives::settlement::AffirmationStatus,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 83u8, 128u8, 215u8, 35u8, 66u8, 131u8, 241u8,
                    146u8, 213u8, 20u8, 216u8, 29u8, 178u8, 153u8, 36u8, 132u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Tracks the number of signers each venue has."]
            pub fn number_of_venue_signers(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::VenueId,
                u32,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 65u8, 49u8, 135u8, 25u8, 96u8, 14u8, 112u8,
                    10u8, 188u8, 29u8, 148u8, 244u8, 217u8, 121u8, 111u8, 6u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " The status for the mediators affirmation."]
            pub fn instruction_mediators_affirmations(
                &self,
                key_0: types::polymesh_primitives::settlement::InstructionId,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::IdentityId,
                types::polymesh_primitives::settlement::MediatorAffirmationStatus<u64>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 195u8, 167u8, 176u8, 135u8, 61u8, 124u8, 1u8,
                    184u8, 154u8, 97u8, 6u8, 91u8, 221u8, 125u8, 202u8, 39u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " The moment the instruction was moved to the `LockedForExecution` status."]
            pub fn locked_timestamp(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::settlement::InstructionId,
                u64,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    165u8, 111u8, 232u8, 82u8, 109u8, 208u8, 251u8, 206u8, 254u8, 94u8, 76u8,
                    244u8, 45u8, 74u8, 131u8, 57u8, 162u8, 178u8, 103u8, 231u8, 33u8, 51u8, 97u8,
                    178u8, 214u8, 32u8, 225u8, 175u8, 31u8, 4u8, 59u8, 230u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod statistics {
        use super::*;
        #[derive(Clone)]
        pub struct StatisticsCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> StatisticsCallApi<'api> {
            #[doc = "Set the active asset stat_types."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
            #[doc = "- `stat_types` - the new stat types to replace any existing types."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `StatTypeLimitReached` - too many stat types enabled for the `asset_id`."]
            #[doc = "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions."]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "- Agent"]
            #[doc = "- Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn set_active_asset_stats(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                stat_types: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::statistics::StatType,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Statistics(
                    types::pallet_statistics::pallet::StatisticsCall::set_active_asset_stats {
                        asset_id,
                        stat_types,
                    },
                ))
            }
            #[doc = "Set the active asset stat_types."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
            #[doc = "- `stat_types` - the new stat types to replace any existing types."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `StatTypeLimitReached` - too many stat types enabled for the `asset_id`."]
            #[doc = "- `CannotRemoveStatTypeInUse` - can not remove a stat type that is in use by transfer conditions."]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "- Agent"]
            #[doc = "- Asset"]
            #[cfg(feature = "ink")]
            pub fn set_active_asset_stats(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                stat_types: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::statistics::StatType,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![38u8, 0u8];
                asset_id.encode_to(&mut buf);
                stat_types.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Allow a trusted issuer to init/resync asset/company stats."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
            #[doc = "- `stat_type` - stat type to update."]
            #[doc = "- `values` - Updated values for `stat_type`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `StatTypeMissing` - `stat_type` is not enabled for the `asset_id`."]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "- Agent"]
            #[doc = "- Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn batch_update_asset_stats(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                stat_type: types::polymesh_primitives::statistics::StatType,
                values: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::statistics::StatUpdate,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Statistics(
                    types::pallet_statistics::pallet::StatisticsCall::batch_update_asset_stats {
                        asset_id,
                        stat_type,
                        values,
                    },
                ))
            }
            #[doc = "Allow a trusted issuer to init/resync asset/company stats."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
            #[doc = "- `stat_type` - stat type to update."]
            #[doc = "- `values` - Updated values for `stat_type`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `StatTypeMissing` - `stat_type` is not enabled for the `asset_id`."]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "- Agent"]
            #[doc = "- Asset"]
            #[cfg(feature = "ink")]
            pub fn batch_update_asset_stats(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                stat_type: types::polymesh_primitives::statistics::StatType,
                values: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::statistics::StatUpdate,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![38u8, 1u8];
                asset_id.encode_to(&mut buf);
                stat_type.encode_to(&mut buf);
                values.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set asset transfer compliance rules."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
            #[doc = "- `transfer_conditions` - the new transfer condition to replace any existing conditions."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset_id`."]
            #[doc = "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset_id`."]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "- Agent"]
            #[doc = "- Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn set_asset_transfer_compliance(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                transfer_conditions: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::transfer_compliance::TransferCondition,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Statistics (types :: pallet_statistics :: pallet :: StatisticsCall :: set_asset_transfer_compliance { asset_id , transfer_conditions , }))
            }
            #[doc = "Set asset transfer compliance rules."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` - a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "- `asset_id` - the [`AssetId`] to change the active stats on."]
            #[doc = "- `transfer_conditions` - the new transfer condition to replace any existing conditions."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `TransferConditionLimitReached` - too many transfer condititon enabled for `asset_id`."]
            #[doc = "- `StatTypeMissing` - a transfer condition requires a stat type that is not enabled for the `asset_id`."]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset_id`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "- Agent"]
            #[doc = "- Asset"]
            #[cfg(feature = "ink")]
            pub fn set_asset_transfer_compliance(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                transfer_conditions: ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::transfer_compliance::TransferCondition,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![38u8, 2u8];
                asset_id.encode_to(&mut buf);
                transfer_conditions.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set/unset entities exempt from an asset's transfer compliance rules."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`."]
            #[doc = "- `is_exempt` - enable/disable exemption for `entities`."]
            #[doc = "- `exempt_key` - the asset and stat type to exempt the `entities` from."]
            #[doc = "- `entities` - the entities to set/unset the exemption for."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "- Agent"]
            #[doc = "- Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn set_entities_exempt(
                &self,
                is_exempt: bool,
                exempt_key : types :: polymesh_primitives :: transfer_compliance :: TransferConditionExemptKey,
                entities: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Statistics(
                    types::pallet_statistics::pallet::StatisticsCall::set_entities_exempt {
                        is_exempt,
                        exempt_key,
                        entities,
                    },
                ))
            }
            #[doc = "Set/unset entities exempt from an asset's transfer compliance rules."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `origin` - a signer that has permissions to act as an agent of `exempt_key.asset`."]
            #[doc = "- `is_exempt` - enable/disable exemption for `entities`."]
            #[doc = "- `exempt_key` - the asset and stat type to exempt the `entities` from."]
            #[doc = "- `entities` - the entities to set/unset the exemption for."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` is not agent-permissioned for `asset`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "- Agent"]
            #[doc = "- Asset"]
            #[cfg(feature = "ink")]
            pub fn set_entities_exempt(
                &self,
                is_exempt: bool,
                exempt_key : types :: polymesh_primitives :: transfer_compliance :: TransferConditionExemptKey,
                entities: ::alloc::collections::BTreeSet<::polymesh_api_client::IdentityId>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![38u8, 3u8];
                is_exempt.encode_to(&mut buf);
                exempt_key.encode_to(&mut buf);
                entities.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for StatisticsCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct StatisticsQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> StatisticsQueryApi<'api> {
            #[doc = " Maps a set of [`StatType`] for each [`AssetId`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn active_asset_stats(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::collections::BTreeSet<types::polymesh_primitives::statistics::StatType>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 239u8, 22u8, 59u8, 174u8, 32u8, 48u8, 119u8, 218u8,
                    227u8, 43u8, 193u8, 151u8, 65u8, 213u8, 147u8, 30u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(
                    value.unwrap_or_else(|| {
                        use ::codec::Decode;
                        const DEFAULT: &'static [u8] = &[0u8];
                        <::alloc::collections::BTreeSet<
                            types::polymesh_primitives::statistics::StatType,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
                    }),
                )
            }
            #[doc = " Maps a set of [`StatType`] for each [`AssetId`]."]
            #[cfg(feature = "ink")]
            pub fn active_asset_stats(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::collections::BTreeSet<types::polymesh_primitives::statistics::StatType>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 239u8, 22u8, 59u8, 174u8, 32u8, 48u8, 119u8, 218u8,
                    227u8, 43u8, 193u8, 151u8, 65u8, 213u8, 147u8, 30u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(
                    value.unwrap_or_else(|| {
                        use ::codec::Decode;
                        const DEFAULT: &'static [u8] = &[0u8];
                        <::alloc::collections::BTreeSet<
                            types::polymesh_primitives::statistics::StatType,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
                    }),
                )
            }
            #[doc = " Asset stats."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_stats(
                &self,
                key_0: types::polymesh_primitives::statistics::Stat1stKey,
                key_1: types::polymesh_primitives::statistics::Stat2ndKey,
            ) -> ::polymesh_api_client::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 13u8, 224u8, 187u8, 176u8, 120u8, 186u8, 103u8, 210u8,
                    250u8, 246u8, 251u8, 70u8, 123u8, 141u8, 62u8, 51u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Asset stats."]
            #[cfg(feature = "ink")]
            pub fn asset_stats(
                &self,
                key_0: types::polymesh_primitives::statistics::Stat1stKey,
                key_1: types::polymesh_primitives::statistics::Stat2ndKey,
            ) -> ::polymesh_api_ink::error::Result<u128> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 13u8, 224u8, 187u8, 176u8, 120u8, 186u8, 103u8, 210u8,
                    250u8, 246u8, 251u8, 70u8, 123u8, 141u8, 62u8, 51u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8,
                    ];
                    <u128>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The [`AssetTransferCompliance`] for each [`AssetId`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn asset_transfer_compliances(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::transfer_compliance::AssetTransferCompliance,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 86u8, 51u8, 252u8, 244u8, 127u8, 54u8, 208u8, 97u8,
                    49u8, 83u8, 224u8, 203u8, 24u8, 190u8, 105u8, 124u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 , 0u8 ,] ; < types :: polymesh_primitives :: transfer_compliance :: AssetTransferCompliance > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " The [`AssetTransferCompliance`] for each [`AssetId`]."]
            #[cfg(feature = "ink")]
            pub fn asset_transfer_compliances(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::transfer_compliance::AssetTransferCompliance,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 86u8, 51u8, 252u8, 244u8, 127u8, 54u8, 208u8, 97u8,
                    49u8, 83u8, 224u8, 203u8, 24u8, 190u8, 105u8, 124u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 , 0u8 ,] ; < types :: polymesh_primitives :: transfer_compliance :: AssetTransferCompliance > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " Entities exempt from a Transfer Compliance rule."]
            #[cfg(not(feature = "ink"))]
            pub async fn transfer_condition_exempt_entities(
                &self,
                key_0: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 26u8, 48u8, 88u8, 202u8, 218u8, 234u8, 155u8, 104u8,
                    25u8, 241u8, 119u8, 22u8, 42u8, 149u8, 27u8, 223u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Entities exempt from a Transfer Compliance rule."]
            #[cfg(feature = "ink")]
            pub fn transfer_condition_exempt_entities(
                &self,
                key_0: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 26u8, 48u8, 88u8, 202u8, 218u8, 234u8, 155u8, 104u8,
                    25u8, 241u8, 119u8, 22u8, 42u8, 149u8, 27u8, 223u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage migration version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_statistics::Version>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_statistics::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage migration version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_statistics::Version> {
                let value = self.api.read_storage(::alloc::vec![
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_statistics::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct StatisticsPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> StatisticsPagedQueryApi<'api> {
            #[doc = " Maps a set of [`StatType`] for each [`AssetId`]."]
            pub fn active_asset_stats(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                ::alloc::collections::BTreeSet<types::polymesh_primitives::statistics::StatType>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 239u8, 22u8, 59u8, 174u8, 32u8, 48u8, 119u8, 218u8,
                    227u8, 43u8, 193u8, 151u8, 65u8, 213u8, 147u8, 30u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Asset stats."]
            pub fn asset_stats(
                &self,
                key_0: types::polymesh_primitives::statistics::Stat1stKey,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::statistics::Stat2ndKey,
                u128,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 13u8, 224u8, 187u8, 176u8, 120u8, 186u8, 103u8, 210u8,
                    250u8, 246u8, 251u8, 70u8, 123u8, 141u8, 62u8, 51u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The [`AssetTransferCompliance`] for each [`AssetId`]."]
            pub fn asset_transfer_compliances(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::transfer_compliance::AssetTransferCompliance,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 86u8, 51u8, 252u8, 244u8, 127u8, 54u8, 208u8, 97u8,
                    49u8, 83u8, 224u8, 203u8, 24u8, 190u8, 105u8, 124u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Entities exempt from a Transfer Compliance rule."]
            pub fn transfer_condition_exempt_entities(
                &self,
                key_0: types::polymesh_primitives::transfer_compliance::TransferConditionExemptKey,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, bool>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    122u8, 118u8, 79u8, 87u8, 64u8, 136u8, 128u8, 152u8, 133u8, 248u8, 66u8, 104u8,
                    92u8, 191u8, 151u8, 8u8, 26u8, 48u8, 88u8, 202u8, 218u8, 234u8, 155u8, 104u8,
                    25u8, 241u8, 119u8, 22u8, 42u8, 149u8, 27u8, 223u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
        }
    }
    pub mod sto {
        use super::*;
        #[derive(Clone)]
        pub struct StoCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> StoCallApi<'api> {
            #[doc = "Create a new fundraiser for a security token offering."]
            #[doc = ""]
            #[doc = "This function creates a tiered pricing fundraiser where investors can purchase"]
            #[doc = "tokens at different price points. The fundraiser uses Polymesh's settlement"]
            #[doc = "infrastructure to ensure compliant and secure token transfers."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_portfolio` - Portfolio containing the tokens being offered for sale"]
            #[doc = "* `offering_asset` - Asset ID of the security token being sold"]
            #[doc = "* `raising_portfolio` - Portfolio that will receive the raised funds"]
            #[doc = "* `raising_asset` - Asset ID of the payment token (e.g., POLYX, stablecoin)"]
            #[doc = "* `tiers` - Vector of price tiers (1-10 tiers), each with total amount and price per unit"]
            #[doc = "* `venue_id` - STO venue ID for handling settlements (must be owned by caller)"]
            #[doc = "* `start` - Optional start time; if `None`, fundraiser begins immediately"]
            #[doc = "* `end` - Optional end time; if `None`, fundraiser runs indefinitely"]
            #[doc = "* `minimum_investment` - Minimum amount of `raising_asset` required per investment"]
            #[doc = "* `fundraiser_name` - Human-readable name for UI display (length limited)"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = "* **Portfolio Custody**: Caller must have custody of both `offering_portfolio` and `raising_portfolio`"]
            #[doc = "* **Venue Ownership**: The specified `venue_id` must be an STO venue owned by the caller"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `InvalidVenue` - Venue doesn't exist, wrong type, or not owned by caller"]
            #[doc = "* `InvalidPriceTiers` - Invalid tier configuration (0 tiers, >10 tiers, zero amounts)"]
            #[doc = "* `InvalidOfferingWindow` - Start time is after end time"]
            #[doc = "* `Overflow` - Total offering amount calculation overflowed"]
            #[cfg(not(feature = "ink"))]
            pub fn create_fundraiser(
                &self,
                offering_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
                offering_asset: ::polymesh_api_client::AssetId,
                raising_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
                raising_asset: ::polymesh_api_client::AssetId,
                tiers: ::alloc::vec::Vec<types::pallet_sto::PriceTier>,
                venue_id: types::polymesh_primitives::settlement::VenueId,
                start: Option<u64>,
                end: Option<u64>,
                minimum_investment: u128,
                fundraiser_name: types::pallet_sto::FundraiserName,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sto(
                    types::pallet_sto::pallet::StoCall::create_fundraiser {
                        offering_portfolio,
                        offering_asset,
                        raising_portfolio,
                        raising_asset,
                        tiers,
                        venue_id,
                        start,
                        end,
                        minimum_investment,
                        fundraiser_name,
                    },
                ))
            }
            #[doc = "Create a new fundraiser for a security token offering."]
            #[doc = ""]
            #[doc = "This function creates a tiered pricing fundraiser where investors can purchase"]
            #[doc = "tokens at different price points. The fundraiser uses Polymesh's settlement"]
            #[doc = "infrastructure to ensure compliant and secure token transfers."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_portfolio` - Portfolio containing the tokens being offered for sale"]
            #[doc = "* `offering_asset` - Asset ID of the security token being sold"]
            #[doc = "* `raising_portfolio` - Portfolio that will receive the raised funds"]
            #[doc = "* `raising_asset` - Asset ID of the payment token (e.g., POLYX, stablecoin)"]
            #[doc = "* `tiers` - Vector of price tiers (1-10 tiers), each with total amount and price per unit"]
            #[doc = "* `venue_id` - STO venue ID for handling settlements (must be owned by caller)"]
            #[doc = "* `start` - Optional start time; if `None`, fundraiser begins immediately"]
            #[doc = "* `end` - Optional end time; if `None`, fundraiser runs indefinitely"]
            #[doc = "* `minimum_investment` - Minimum amount of `raising_asset` required per investment"]
            #[doc = "* `fundraiser_name` - Human-readable name for UI display (length limited)"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = "* **Portfolio Custody**: Caller must have custody of both `offering_portfolio` and `raising_portfolio`"]
            #[doc = "* **Venue Ownership**: The specified `venue_id` must be an STO venue owned by the caller"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `InvalidVenue` - Venue doesn't exist, wrong type, or not owned by caller"]
            #[doc = "* `InvalidPriceTiers` - Invalid tier configuration (0 tiers, >10 tiers, zero amounts)"]
            #[doc = "* `InvalidOfferingWindow` - Start time is after end time"]
            #[doc = "* `Overflow` - Total offering amount calculation overflowed"]
            #[cfg(feature = "ink")]
            pub fn create_fundraiser(
                &self,
                offering_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
                offering_asset: ::polymesh_api_client::AssetId,
                raising_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
                raising_asset: ::polymesh_api_client::AssetId,
                tiers: ::alloc::vec::Vec<types::pallet_sto::PriceTier>,
                venue_id: types::polymesh_primitives::settlement::VenueId,
                start: Option<u64>,
                end: Option<u64>,
                minimum_investment: u128,
                fundraiser_name: types::pallet_sto::FundraiserName,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![39u8, 0u8];
                offering_portfolio.encode_to(&mut buf);
                offering_asset.encode_to(&mut buf);
                raising_portfolio.encode_to(&mut buf);
                raising_asset.encode_to(&mut buf);
                tiers.encode_to(&mut buf);
                venue_id.encode_to(&mut buf);
                start.encode_to(&mut buf);
                end.encode_to(&mut buf);
                minimum_investment.encode_to(&mut buf);
                fundraiser_name.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Invest in a fundraiser using on-chain or off-chain funding."]
            #[doc = ""]
            #[doc = "This function allows investors to purchase tokens from an active fundraiser."]
            #[doc = "The investment is processed through multiple price tiers in order, starting"]
            #[doc = "with the lowest-priced tier. The purchase creates a settlement instruction"]
            #[doc = "that transfers tokens and payment between the appropriate portfolios."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID of the security token being purchased"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to invest in"]
            #[doc = "* `investment_portfolio` - Portfolio where purchased tokens will be deposited"]
            #[doc = "* `funding` - Payment method: either `OnChain(portfolio_id)` for on-chain assets"]
            #[doc = "  or `OffChain(receipt_details)` for off-chain receipts with signature verification"]
            #[doc = "* `purchase_amount` - Number of `offering_asset` tokens to purchase"]
            #[doc = "* `max_price` - Optional maximum price per token; if specified, investment fails"]
            #[doc = "  if the blended price across tiers exceeds this limit"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Portfolio Custody**: Caller must have custody of `investment_portfolio`"]
            #[doc = "* **Funding Portfolio**: If using on-chain funding, caller must have custody"]
            #[doc = "  of the funding portfolio specified in the `FundingMethod`"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserNotLive` - Fundraiser is frozen or closed"]
            #[doc = "* `FundraiserExpired` - Current time is outside fundraiser's active window"]
            #[doc = "* `InsufficientTokensRemaining` - Not enough tokens available across all tiers"]
            #[doc = "* `InvestmentAmountTooLow` - Total cost is below minimum investment threshold"]
            #[doc = "* `MaxPriceExceeded` - Blended price exceeds investor's maximum price limit"]
            #[doc = "* `OffchainFundingNotAllowed` - Off-chain funding not enabled for this fundraiser"]
            #[doc = "* `InvalidSignature` - Off-chain receipt signature verification failed"]
            #[cfg(not(feature = "ink"))]
            pub fn invest(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
                investment_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
                funding: types::pallet_sto::FundingMethod<
                    ::polymesh_api_client::AccountId,
                    ::polymesh_api_client::MultiSignature,
                >,
                purchase_amount: u128,
                max_price: Option<u128>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sto(
                    types::pallet_sto::pallet::StoCall::invest {
                        offering_asset,
                        fundraiser_id,
                        investment_portfolio,
                        funding,
                        purchase_amount,
                        max_price,
                    },
                ))
            }
            #[doc = "Invest in a fundraiser using on-chain or off-chain funding."]
            #[doc = ""]
            #[doc = "This function allows investors to purchase tokens from an active fundraiser."]
            #[doc = "The investment is processed through multiple price tiers in order, starting"]
            #[doc = "with the lowest-priced tier. The purchase creates a settlement instruction"]
            #[doc = "that transfers tokens and payment between the appropriate portfolios."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID of the security token being purchased"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to invest in"]
            #[doc = "* `investment_portfolio` - Portfolio where purchased tokens will be deposited"]
            #[doc = "* `funding` - Payment method: either `OnChain(portfolio_id)` for on-chain assets"]
            #[doc = "  or `OffChain(receipt_details)` for off-chain receipts with signature verification"]
            #[doc = "* `purchase_amount` - Number of `offering_asset` tokens to purchase"]
            #[doc = "* `max_price` - Optional maximum price per token; if specified, investment fails"]
            #[doc = "  if the blended price across tiers exceeds this limit"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Portfolio Custody**: Caller must have custody of `investment_portfolio`"]
            #[doc = "* **Funding Portfolio**: If using on-chain funding, caller must have custody"]
            #[doc = "  of the funding portfolio specified in the `FundingMethod`"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserNotLive` - Fundraiser is frozen or closed"]
            #[doc = "* `FundraiserExpired` - Current time is outside fundraiser's active window"]
            #[doc = "* `InsufficientTokensRemaining` - Not enough tokens available across all tiers"]
            #[doc = "* `InvestmentAmountTooLow` - Total cost is below minimum investment threshold"]
            #[doc = "* `MaxPriceExceeded` - Blended price exceeds investor's maximum price limit"]
            #[doc = "* `OffchainFundingNotAllowed` - Off-chain funding not enabled for this fundraiser"]
            #[doc = "* `InvalidSignature` - Off-chain receipt signature verification failed"]
            #[cfg(feature = "ink")]
            pub fn invest(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
                investment_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
                funding: types::pallet_sto::FundingMethod<
                    ::polymesh_api_client::AccountId,
                    ::polymesh_api_client::MultiSignature,
                >,
                purchase_amount: u128,
                max_price: Option<u128>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![39u8, 1u8];
                offering_asset.encode_to(&mut buf);
                fundraiser_id.encode_to(&mut buf);
                investment_portfolio.encode_to(&mut buf);
                funding.encode_to(&mut buf);
                purchase_amount.encode_to(&mut buf);
                max_price.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Temporarily freeze a fundraiser to prevent new investments."]
            #[doc = ""]
            #[doc = "When a fundraiser is frozen, it cannot accept new investments but remains"]
            #[doc = "otherwise intact. This is useful for pausing activity while resolving"]
            #[doc = "issues or during maintenance periods. The fundraiser can be unfrozen"]
            #[doc = "later to resume normal operations."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to freeze"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to freeze"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserClosed` - Fundraiser has already been permanently closed"]
            #[doc = "* `Unauthorized` - Caller lacks required asset agent permissions"]
            #[cfg(not(feature = "ink"))]
            pub fn freeze_fundraiser(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sto(
                    types::pallet_sto::pallet::StoCall::freeze_fundraiser {
                        offering_asset,
                        fundraiser_id,
                    },
                ))
            }
            #[doc = "Temporarily freeze a fundraiser to prevent new investments."]
            #[doc = ""]
            #[doc = "When a fundraiser is frozen, it cannot accept new investments but remains"]
            #[doc = "otherwise intact. This is useful for pausing activity while resolving"]
            #[doc = "issues or during maintenance periods. The fundraiser can be unfrozen"]
            #[doc = "later to resume normal operations."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to freeze"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to freeze"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserClosed` - Fundraiser has already been permanently closed"]
            #[doc = "* `Unauthorized` - Caller lacks required asset agent permissions"]
            #[cfg(feature = "ink")]
            pub fn freeze_fundraiser(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![39u8, 2u8];
                offering_asset.encode_to(&mut buf);
                fundraiser_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Resume a frozen fundraiser to allow new investments."]
            #[doc = ""]
            #[doc = "This function unfreezes a previously frozen fundraiser, returning it to"]
            #[doc = "the Live status where it can accept new investments. The fundraiser"]
            #[doc = "must not be permanently closed for this operation to succeed."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to unfreeze"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to unfreeze"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserClosed` - Fundraiser has been permanently closed and cannot be unfrozen"]
            #[doc = "* `Unauthorized` - Caller lacks required asset agent permissions"]
            #[cfg(not(feature = "ink"))]
            pub fn unfreeze_fundraiser(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sto(
                    types::pallet_sto::pallet::StoCall::unfreeze_fundraiser {
                        offering_asset,
                        fundraiser_id,
                    },
                ))
            }
            #[doc = "Resume a frozen fundraiser to allow new investments."]
            #[doc = ""]
            #[doc = "This function unfreezes a previously frozen fundraiser, returning it to"]
            #[doc = "the Live status where it can accept new investments. The fundraiser"]
            #[doc = "must not be permanently closed for this operation to succeed."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to unfreeze"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to unfreeze"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserClosed` - Fundraiser has been permanently closed and cannot be unfrozen"]
            #[doc = "* `Unauthorized` - Caller lacks required asset agent permissions"]
            #[cfg(feature = "ink")]
            pub fn unfreeze_fundraiser(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![39u8, 3u8];
                offering_asset.encode_to(&mut buf);
                fundraiser_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Modify the time window when a fundraiser is active for investments."]
            #[doc = ""]
            #[doc = "This function allows authorized agents to update the start and end times"]
            #[doc = "of an active fundraiser. This can be useful for extending fundraising"]
            #[doc = "periods, adjusting launch timing, or responding to market conditions."]
            #[doc = "The fundraiser must not be permanently closed to modify its window."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to modify"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to modify"]
            #[doc = "* `start` - New start time for the fundraiser (can be in the past or future)"]
            #[doc = "* `end` - New optional end time; if `None`, the fundraiser runs indefinitely"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserClosed` - Fundraiser has been permanently closed"]
            #[doc = "* `FundraiserExpired` - Fundraiser has already expired (past its original end time)"]
            #[doc = "* `InvalidOfferingWindow` - New start time is after new end time"]
            #[doc = "* `Unauthorized` - Caller lacks required asset agent permissions"]
            #[cfg(not(feature = "ink"))]
            pub fn modify_fundraiser_window(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
                start: u64,
                end: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sto(
                    types::pallet_sto::pallet::StoCall::modify_fundraiser_window {
                        offering_asset,
                        fundraiser_id,
                        start,
                        end,
                    },
                ))
            }
            #[doc = "Modify the time window when a fundraiser is active for investments."]
            #[doc = ""]
            #[doc = "This function allows authorized agents to update the start and end times"]
            #[doc = "of an active fundraiser. This can be useful for extending fundraising"]
            #[doc = "periods, adjusting launch timing, or responding to market conditions."]
            #[doc = "The fundraiser must not be permanently closed to modify its window."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to modify"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to modify"]
            #[doc = "* `start` - New start time for the fundraiser (can be in the past or future)"]
            #[doc = "* `end` - New optional end time; if `None`, the fundraiser runs indefinitely"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserClosed` - Fundraiser has been permanently closed"]
            #[doc = "* `FundraiserExpired` - Fundraiser has already expired (past its original end time)"]
            #[doc = "* `InvalidOfferingWindow` - New start time is after new end time"]
            #[doc = "* `Unauthorized` - Caller lacks required asset agent permissions"]
            #[cfg(feature = "ink")]
            pub fn modify_fundraiser_window(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
                start: u64,
                end: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![39u8, 4u8];
                offering_asset.encode_to(&mut buf);
                fundraiser_id.encode_to(&mut buf);
                start.encode_to(&mut buf);
                end.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Permanently stop a fundraiser and unlock remaining tokens."]
            #[doc = ""]
            #[doc = "This function permanently closes a fundraiser, preventing any further"]
            #[doc = "investments. Any remaining tokens that haven't been sold are unlocked"]
            #[doc = "and returned to the offering portfolio. Once stopped, a fundraiser"]
            #[doc = "cannot be restarted."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to stop"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to stop"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = "  OR be the original creator of the fundraiser"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserClosed` - Fundraiser has already been permanently closed"]
            #[doc = "* `Unauthorized` - Caller lacks required permissions"]
            #[cfg(not(feature = "ink"))]
            pub fn stop(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sto(
                    types::pallet_sto::pallet::StoCall::stop {
                        offering_asset,
                        fundraiser_id,
                    },
                ))
            }
            #[doc = "Permanently stop a fundraiser and unlock remaining tokens."]
            #[doc = ""]
            #[doc = "This function permanently closes a fundraiser, preventing any further"]
            #[doc = "investments. Any remaining tokens that haven't been sold are unlocked"]
            #[doc = "and returned to the offering portfolio. Once stopped, a fundraiser"]
            #[doc = "cannot be restarted."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID associated with the fundraiser to stop"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to stop"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = "  OR be the original creator of the fundraiser"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserClosed` - Fundraiser has already been permanently closed"]
            #[doc = "* `Unauthorized` - Caller lacks required permissions"]
            #[cfg(feature = "ink")]
            pub fn stop(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![39u8, 5u8];
                offering_asset.encode_to(&mut buf);
                fundraiser_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Enable off-chain funding support for a fundraiser."]
            #[doc = ""]
            #[doc = "This function allows a fundraiser to accept off-chain payments through"]
            #[doc = "cryptographically signed receipts. Once enabled, investors can use the"]
            #[doc = "`invest` function with `FundingMethod::OffChain` to provide payment"]
            #[doc = "receipts instead of on-chain portfolio transfers."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID associated with the fundraiser"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to enable off-chain funding for"]
            #[doc = "* `ticker` - Ticker symbol of the off-chain asset that will be accepted as payment"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = "  OR be the original creator of the fundraiser"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserClosed` - Fundraiser has been permanently closed"]
            #[doc = "* `Unauthorized` - Caller lacks required permissions"]
            #[cfg(not(feature = "ink"))]
            pub fn enable_offchain_funding(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
                ticker: types::polymesh_primitives::ticker::Ticker,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Sto(
                    types::pallet_sto::pallet::StoCall::enable_offchain_funding {
                        offering_asset,
                        fundraiser_id,
                        ticker,
                    },
                ))
            }
            #[doc = "Enable off-chain funding support for a fundraiser."]
            #[doc = ""]
            #[doc = "This function allows a fundraiser to accept off-chain payments through"]
            #[doc = "cryptographically signed receipts. Once enabled, investors can use the"]
            #[doc = "`invest` function with `FundingMethod::OffChain` to provide payment"]
            #[doc = "receipts instead of on-chain portfolio transfers."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "* `offering_asset` - Asset ID associated with the fundraiser"]
            #[doc = "* `fundraiser_id` - Unique identifier of the fundraiser to enable off-chain funding for"]
            #[doc = "* `ticker` - Ticker symbol of the off-chain asset that will be accepted as payment"]
            #[doc = ""]
            #[doc = "# Permissions Required"]
            #[doc = "* **Asset Agent**: Caller must be an authorized external agent for `offering_asset`"]
            #[doc = "  OR be the original creator of the fundraiser"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "* `FundraiserNotFound` - Specified fundraiser doesn't exist"]
            #[doc = "* `FundraiserClosed` - Fundraiser has been permanently closed"]
            #[doc = "* `Unauthorized` - Caller lacks required permissions"]
            #[cfg(feature = "ink")]
            pub fn enable_offchain_funding(
                &self,
                offering_asset: ::polymesh_api_client::AssetId,
                fundraiser_id: types::polymesh_primitives::sto::FundraiserId,
                ticker: types::polymesh_primitives::ticker::Ticker,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![39u8, 6u8];
                offering_asset.encode_to(&mut buf);
                fundraiser_id.encode_to(&mut buf);
                ticker.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for StoCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct StoQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> StoQueryApi<'api> {
            #[doc = " All fundraisers that are currently running."]
            #[doc = " (AssetId, fundraiser_id) -> Fundraiser"]
            #[cfg(not(feature = "ink"))]
            pub async fn fundraisers(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::sto::FundraiserId,
            ) -> ::polymesh_api_client::error::Result<Option<types::pallet_sto::Fundraiser<u64>>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 200u8, 242u8, 149u8, 77u8, 218u8, 243u8, 200u8,
                    19u8, 142u8, 65u8, 23u8, 184u8, 97u8, 230u8, 68u8, 109u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " All fundraisers that are currently running."]
            #[doc = " (AssetId, fundraiser_id) -> Fundraiser"]
            #[cfg(feature = "ink")]
            pub fn fundraisers(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::sto::FundraiserId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_sto::Fundraiser<u64>>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 200u8, 242u8, 149u8, 77u8, 218u8, 243u8, 200u8,
                    19u8, 142u8, 65u8, 23u8, 184u8, 97u8, 230u8, 68u8, 109u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Total fundraisers created for a token."]
            #[cfg(not(feature = "ink"))]
            pub async fn fundraiser_count(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::sto::FundraiserId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 220u8, 57u8, 49u8, 4u8, 64u8, 150u8, 65u8, 208u8,
                    189u8, 149u8, 72u8, 244u8, 76u8, 90u8, 115u8, 235u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::sto::FundraiserId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Total fundraisers created for a token."]
            #[cfg(feature = "ink")]
            pub fn fundraiser_count(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::sto::FundraiserId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 220u8, 57u8, 49u8, 4u8, 64u8, 150u8, 65u8, 208u8,
                    189u8, 149u8, 72u8, 244u8, 76u8, 90u8, 115u8, 235u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::sto::FundraiserId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Name for the Fundraiser. Only used offchain."]
            #[doc = " (AssetId, fundraiser_id) -> Fundraiser name"]
            #[cfg(not(feature = "ink"))]
            pub async fn fundraiser_names(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::sto::FundraiserId,
            ) -> ::polymesh_api_client::error::Result<Option<types::pallet_sto::FundraiserName>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 70u8, 206u8, 185u8, 249u8, 61u8, 181u8, 239u8, 65u8,
                    114u8, 228u8, 101u8, 54u8, 80u8, 98u8, 238u8, 252u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Name for the Fundraiser. Only used offchain."]
            #[doc = " (AssetId, fundraiser_id) -> Fundraiser name"]
            #[cfg(feature = "ink")]
            pub fn fundraiser_names(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::sto::FundraiserId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_sto::FundraiserName>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 70u8, 206u8, 185u8, 249u8, 61u8, 181u8, 239u8, 65u8,
                    114u8, 228u8, 101u8, 54u8, 80u8, 98u8, 238u8, 252u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " If the fundraiser supports off-chain funding payments using receipts."]
            #[cfg(not(feature = "ink"))]
            pub async fn fundraiser_offchain_asset(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::sto::FundraiserId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::ticker::Ticker>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 55u8, 150u8, 78u8, 139u8, 101u8, 132u8, 118u8,
                    249u8, 112u8, 62u8, 159u8, 42u8, 242u8, 137u8, 84u8, 61u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " If the fundraiser supports off-chain funding payments using receipts."]
            #[cfg(feature = "ink")]
            pub fn fundraiser_offchain_asset(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::sto::FundraiserId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::ticker::Ticker>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 55u8, 150u8, 78u8, 139u8, 101u8, 132u8, 118u8,
                    249u8, 112u8, 62u8, 159u8, 42u8, 242u8, 137u8, 84u8, 61u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Storage migration version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_sto::Version> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_sto::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage migration version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_sto::Version> {
                let value = self.api.read_storage(::alloc::vec![
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_sto::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct StoPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> StoPagedQueryApi<'api> {
            #[doc = " All fundraisers that are currently running."]
            #[doc = " (AssetId, fundraiser_id) -> Fundraiser"]
            pub fn fundraisers(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::sto::FundraiserId,
                types::pallet_sto::Fundraiser<u64>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 200u8, 242u8, 149u8, 77u8, 218u8, 243u8, 200u8,
                    19u8, 142u8, 65u8, 23u8, 184u8, 97u8, 230u8, 68u8, 109u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Total fundraisers created for a token."]
            pub fn fundraiser_count(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::sto::FundraiserId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 220u8, 57u8, 49u8, 4u8, 64u8, 150u8, 65u8, 208u8,
                    189u8, 149u8, 72u8, 244u8, 76u8, 90u8, 115u8, 235u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Name for the Fundraiser. Only used offchain."]
            #[doc = " (AssetId, fundraiser_id) -> Fundraiser name"]
            pub fn fundraiser_names(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::sto::FundraiserId,
                types::pallet_sto::FundraiserName,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 70u8, 206u8, 185u8, 249u8, 61u8, 181u8, 239u8, 65u8,
                    114u8, 228u8, 101u8, 54u8, 80u8, 98u8, 238u8, 252u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " If the fundraiser supports off-chain funding payments using receipts."]
            pub fn fundraiser_offchain_asset(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::sto::FundraiserId,
                types::polymesh_primitives::ticker::Ticker,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    74u8, 66u8, 125u8, 144u8, 93u8, 182u8, 66u8, 62u8, 238u8, 230u8, 185u8, 54u8,
                    235u8, 242u8, 167u8, 54u8, 55u8, 150u8, 78u8, 139u8, 101u8, 132u8, 118u8,
                    249u8, 112u8, 62u8, 159u8, 42u8, 242u8, 137u8, 84u8, 61u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod treasury {
        use super::*;
        #[derive(Clone)]
        pub struct TreasuryCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> TreasuryCallApi<'api> {
            #[doc = "It transfers balances from treasury to each of beneficiaries and the specific amount"]
            #[doc = "for each of them."]
            #[doc = ""]
            #[doc = "# Error"]
            #[doc = "* `BadOrigin`: Only root can execute transaction."]
            #[doc = "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries."]
            #[doc = "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity."]
            #[cfg(not(feature = "ink"))]
            pub fn disbursement(
                &self,
                beneficiaries: ::alloc::vec::Vec<types::polymesh_primitives::Beneficiary<u128>>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Treasury(
                    types::pallet_treasury::pallet::TreasuryCall::disbursement { beneficiaries },
                ))
            }
            #[doc = "It transfers balances from treasury to each of beneficiaries and the specific amount"]
            #[doc = "for each of them."]
            #[doc = ""]
            #[doc = "# Error"]
            #[doc = "* `BadOrigin`: Only root can execute transaction."]
            #[doc = "* `InsufficientBalance`: If treasury balances is not enough to cover all beneficiaries."]
            #[doc = "* `InvalidIdentity`: If one of the beneficiaries has an invalid identity."]
            #[cfg(feature = "ink")]
            pub fn disbursement(
                &self,
                beneficiaries: ::alloc::vec::Vec<types::polymesh_primitives::Beneficiary<u128>>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![40u8, 0u8];
                beneficiaries.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "It transfers the specific `amount` from `origin` account into treasury."]
            #[doc = ""]
            #[doc = "Only accounts which are associated to an identity can make a donation to treasury."]
            #[cfg(not(feature = "ink"))]
            pub fn reimbursement(
                &self,
                amount: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Treasury(
                    types::pallet_treasury::pallet::TreasuryCall::reimbursement { amount },
                ))
            }
            #[doc = "It transfers the specific `amount` from `origin` account into treasury."]
            #[doc = ""]
            #[doc = "Only accounts which are associated to an identity can make a donation to treasury."]
            #[cfg(feature = "ink")]
            pub fn reimbursement(&self, amount: u128) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![40u8, 1u8];
                amount.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for TreasuryCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct TreasuryQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> TreasuryQueryApi<'api> {}
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct TreasuryPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> TreasuryPagedQueryApi<'api> {}
    }
    pub mod utility {
        use super::*;
        #[derive(Clone)]
        pub struct UtilityCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> UtilityCallApi<'api> {
            #[doc = "Send a batch of dispatch calls."]
            #[doc = ""]
            #[doc = "May be called from any origin except `None`."]
            #[doc = ""]
            #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
            #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
            #[doc = ""]
            #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
            #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- O(C) where C is the number of calls to be batched."]
            #[doc = ""]
            #[doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"]
            #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
            #[doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"]
            #[doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"]
            #[doc = "event is deposited."]
            #[cfg(not(feature = "ink"))]
            pub fn batch(
                &self,
                calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Utility(
                    types::pallet_utility::pallet::UtilityCall::batch { calls },
                ))
            }
            #[doc = "Send a batch of dispatch calls."]
            #[doc = ""]
            #[doc = "May be called from any origin except `None`."]
            #[doc = ""]
            #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
            #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
            #[doc = ""]
            #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
            #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- O(C) where C is the number of calls to be batched."]
            #[doc = ""]
            #[doc = "This will return `Ok` in all circumstances. To determine the success of the batch, an"]
            #[doc = "event is deposited. If a call failed and the batch was interrupted, then the"]
            #[doc = "`BatchInterrupted` event is deposited, along with the number of successful calls made"]
            #[doc = "and the error of the failed call. If all were successful, then the `BatchCompleted`"]
            #[doc = "event is deposited."]
            #[cfg(feature = "ink")]
            pub fn batch(
                &self,
                calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![41u8, 0u8];
                calls.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Relay a call for a target from an origin"]
            #[doc = ""]
            #[doc = "Relaying in this context refers to the ability of origin to make a call on behalf of"]
            #[doc = "target."]
            #[doc = ""]
            #[doc = "Fees are charged to origin"]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "- `target`: Account to be relayed"]
            #[doc = "- `signature`: Signature from target authorizing the relay"]
            #[doc = "- `call`: Call to be relayed on behalf of target"]
            #[doc = ""]
            #[doc = "POLYMESH: added."]
            #[cfg(not(feature = "ink"))]
            pub fn relay_tx(
                &self,
                target: ::polymesh_api_client::AccountId,
                signature: ::polymesh_api_client::MultiSignature,
                call: types::pallet_utility::UniqueCall<runtime::RuntimeCall>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Utility(
                    types::pallet_utility::pallet::UtilityCall::relay_tx {
                        target,
                        signature,
                        call,
                    },
                ))
            }
            #[doc = "Relay a call for a target from an origin"]
            #[doc = ""]
            #[doc = "Relaying in this context refers to the ability of origin to make a call on behalf of"]
            #[doc = "target."]
            #[doc = ""]
            #[doc = "Fees are charged to origin"]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = "- `target`: Account to be relayed"]
            #[doc = "- `signature`: Signature from target authorizing the relay"]
            #[doc = "- `call`: Call to be relayed on behalf of target"]
            #[doc = ""]
            #[doc = "POLYMESH: added."]
            #[cfg(feature = "ink")]
            pub fn relay_tx(
                &self,
                target: ::polymesh_api_client::AccountId,
                signature: ::polymesh_api_client::MultiSignature,
                call: types::pallet_utility::UniqueCall<runtime::RuntimeCall>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![41u8, 1u8];
                target.encode_to(&mut buf);
                signature.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Send a batch of dispatch calls and atomically execute them."]
            #[doc = "The whole transaction will rollback and fail if any of the calls failed."]
            #[doc = ""]
            #[doc = "May be called from any origin except `None`."]
            #[doc = ""]
            #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
            #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
            #[doc = ""]
            #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
            #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- O(C) where C is the number of calls to be batched."]
            #[cfg(not(feature = "ink"))]
            pub fn batch_all(
                &self,
                calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Utility(
                    types::pallet_utility::pallet::UtilityCall::batch_all { calls },
                ))
            }
            #[doc = "Send a batch of dispatch calls and atomically execute them."]
            #[doc = "The whole transaction will rollback and fail if any of the calls failed."]
            #[doc = ""]
            #[doc = "May be called from any origin except `None`."]
            #[doc = ""]
            #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
            #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
            #[doc = ""]
            #[doc = "If origin is root then the calls are dispatched without checking origin filter. (This"]
            #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- O(C) where C is the number of calls to be batched."]
            #[cfg(feature = "ink")]
            pub fn batch_all(
                &self,
                calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![41u8, 2u8];
                calls.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Dispatches a function call with a provided origin."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Root_."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- O(1)."]
            #[cfg(not(feature = "ink"))]
            pub fn dispatch_as(
                &self,
                as_origin: runtime::OriginCaller,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Utility(
                    types::pallet_utility::pallet::UtilityCall::dispatch_as {
                        as_origin: ::alloc::boxed::Box::new(as_origin),
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Dispatches a function call with a provided origin."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Root_."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- O(1)."]
            #[cfg(feature = "ink")]
            pub fn dispatch_as(
                &self,
                as_origin: runtime::OriginCaller,
                call: runtime::RuntimeCall,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![41u8, 3u8];
                as_origin.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Send a batch of dispatch calls."]
            #[doc = "Unlike `batch`, it allows errors and won't interrupt."]
            #[doc = ""]
            #[doc = "May be called from any origin except `None`."]
            #[doc = ""]
            #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
            #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
            #[doc = ""]
            #[doc = "If origin is root then the calls are dispatch without checking origin filter. (This"]
            #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- O(C) where C is the number of calls to be batched."]
            #[cfg(not(feature = "ink"))]
            pub fn force_batch(
                &self,
                calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Utility(
                    types::pallet_utility::pallet::UtilityCall::force_batch { calls },
                ))
            }
            #[doc = "Send a batch of dispatch calls."]
            #[doc = "Unlike `batch`, it allows errors and won't interrupt."]
            #[doc = ""]
            #[doc = "May be called from any origin except `None`."]
            #[doc = ""]
            #[doc = "- `calls`: The calls to be dispatched from the same origin. The number of call must not"]
            #[doc = "  exceed the constant: `batched_calls_limit` (available in constant metadata)."]
            #[doc = ""]
            #[doc = "If origin is root then the calls are dispatch without checking origin filter. (This"]
            #[doc = "includes bypassing `frame_system::Config::BaseCallFilter`)."]
            #[doc = ""]
            #[doc = "## Complexity"]
            #[doc = "- O(C) where C is the number of calls to be batched."]
            #[cfg(feature = "ink")]
            pub fn force_batch(
                &self,
                calls: ::alloc::vec::Vec<runtime::RuntimeCall>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![41u8, 4u8];
                calls.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Dispatch a function call with a specified weight."]
            #[doc = ""]
            #[doc = "This function does not check the weight of the call, and instead allows the"]
            #[doc = "Root origin to specify the weight of the call."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Root_."]
            #[cfg(not(feature = "ink"))]
            pub fn with_weight(
                &self,
                call: runtime::RuntimeCall,
                weight: ::polymesh_api_client::sp_weights::Weight,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Utility(
                    types::pallet_utility::pallet::UtilityCall::with_weight {
                        call: ::alloc::boxed::Box::new(call),
                        weight,
                    },
                ))
            }
            #[doc = "Dispatch a function call with a specified weight."]
            #[doc = ""]
            #[doc = "This function does not check the weight of the call, and instead allows the"]
            #[doc = "Root origin to specify the weight of the call."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Root_."]
            #[cfg(feature = "ink")]
            pub fn with_weight(
                &self,
                call: runtime::RuntimeCall,
                weight: ::polymesh_api_client::sp_weights::Weight,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![41u8, 5u8];
                call.encode_to(&mut buf);
                weight.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Send a call through an indexed pseudonym of the sender."]
            #[doc = ""]
            #[doc = "Filter from origin are passed along. The call will be dispatched with an origin which"]
            #[doc = "use the same filter as the origin of this call."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_."]
            #[cfg(not(feature = "ink"))]
            pub fn as_derivative(
                &self,
                index: u16,
                call: runtime::RuntimeCall,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Utility(
                    types::pallet_utility::pallet::UtilityCall::as_derivative {
                        index,
                        call: ::alloc::boxed::Box::new(call),
                    },
                ))
            }
            #[doc = "Send a call through an indexed pseudonym of the sender."]
            #[doc = ""]
            #[doc = "Filter from origin are passed along. The call will be dispatched with an origin which"]
            #[doc = "use the same filter as the origin of this call."]
            #[doc = ""]
            #[doc = "The dispatch origin for this call must be _Signed_."]
            #[cfg(feature = "ink")]
            pub fn as_derivative(
                &self,
                index: u16,
                call: runtime::RuntimeCall,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![41u8, 9u8];
                index.encode_to(&mut buf);
                call.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for UtilityCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct UtilityQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> UtilityQueryApi<'api> {
            #[doc = " Nonce for `relay_tx`."]
            #[doc = " POLYMESH: added."]
            #[cfg(not(feature = "ink"))]
            pub async fn nonces(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    213u8, 225u8, 162u8, 250u8, 22u8, 115u8, 44u8, 230u8, 144u8, 97u8, 137u8, 67u8,
                    140u8, 10u8, 130u8, 198u8, 194u8, 10u8, 83u8, 78u8, 161u8, 40u8, 231u8, 69u8,
                    69u8, 109u8, 162u8, 52u8, 205u8, 165u8, 229u8, 109u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Nonce for `relay_tx`."]
            #[doc = " POLYMESH: added."]
            #[cfg(feature = "ink")]
            pub fn nonces(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    213u8, 225u8, 162u8, 250u8, 22u8, 115u8, 44u8, 230u8, 144u8, 97u8, 137u8, 67u8,
                    140u8, 10u8, 130u8, 198u8, 194u8, 10u8, 83u8, 78u8, 161u8, 40u8, 231u8, 69u8,
                    69u8, 109u8, 162u8, 52u8, 205u8, 165u8, 229u8, 109u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct UtilityPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> UtilityPagedQueryApi<'api> {
            #[doc = " Nonce for `relay_tx`."]
            #[doc = " POLYMESH: added."]
            pub fn nonces(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AccountId, u64>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    213u8, 225u8, 162u8, 250u8, 22u8, 115u8, 44u8, 230u8, 144u8, 97u8, 137u8, 67u8,
                    140u8, 10u8, 130u8, 198u8, 194u8, 10u8, 83u8, 78u8, 161u8, 40u8, 231u8, 69u8,
                    69u8, 109u8, 162u8, 52u8, 205u8, 165u8, 229u8, 109u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod base {
        use super::*;
        #[derive(Clone)]
        pub struct BaseCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> BaseCallApi<'api> {}
        impl<'api> From<&'api super::super::Api> for BaseCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct BaseQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> BaseQueryApi<'api> {}
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct BasePagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> BasePagedQueryApi<'api> {}
    }
    pub mod external_agents {
        use super::*;
        #[derive(Clone)]
        pub struct ExternalAgentsCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> ExternalAgentsCallApi<'api> {
            #[doc = "Creates a custom agent group (AG) for the given `asset_id`."]
            #[doc = ""]
            #[doc = "The AG will have the permissions as given by `perms`."]
            #[doc = "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`,"]
            #[doc = "which you can use as `AgentGroup::Custom(id)` when adding agents for `asset_id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `assetID` the [`AssetId] to add the custom group for."]
            #[doc = "- `perms` that the new AG will have."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
            #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
            #[doc = "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(not(feature = "ink"))]
            pub fn create_group(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
                    types::pallet_external_agents::pallet::ExternalAgentsCall::create_group {
                        asset_id,
                        perms,
                    },
                ))
            }
            #[doc = "Creates a custom agent group (AG) for the given `asset_id`."]
            #[doc = ""]
            #[doc = "The AG will have the permissions as given by `perms`."]
            #[doc = "This new AG is then assigned `id = AGIdSequence::get() + 1` as its `AGId`,"]
            #[doc = "which you can use as `AgentGroup::Custom(id)` when adding agents for `asset_id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `assetID` the [`AssetId] to add the custom group for."]
            #[doc = "- `perms` that the new AG will have."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
            #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
            #[doc = "- `CounterOverflow` if `AGIdSequence::get() + 1` would exceed `u32::MAX`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(feature = "ink")]
            pub fn create_group(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![43u8, 0u8];
                asset_id.encode_to(&mut buf);
                perms.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Updates the permissions of the custom AG identified by `id`, for the given `asset_id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `assetID` the [`AssetId] the custom AG belongs to."]
            #[doc = "- `id` for the custom AG within `asset_id`."]
            #[doc = "- `perms` to update the custom AG to."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
            #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
            #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(not(feature = "ink"))]
            pub fn set_group_permissions(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                id: types::polymesh_primitives::agent::AGId,
                perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ExternalAgents (types :: pallet_external_agents :: pallet :: ExternalAgentsCall :: set_group_permissions { asset_id , id , perms , }))
            }
            #[doc = "Updates the permissions of the custom AG identified by `id`, for the given `asset_id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `assetID` the [`AssetId] the custom AG belongs to."]
            #[doc = "- `id` for the custom AG within `asset_id`."]
            #[doc = "- `perms` to update the custom AG to."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
            #[doc = "- `TooLong` if `perms` had some string or list length that was too long."]
            #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(feature = "ink")]
            pub fn set_group_permissions(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                id: types::polymesh_primitives::agent::AGId,
                perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![43u8, 1u8];
                asset_id.encode_to(&mut buf);
                id.encode_to(&mut buf);
                perms.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Remove the given `agent` from `asset_id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `assetID` the [`AssetId] that has the `agent` to remove."]
            #[doc = "- `agent` of `asset_id` to remove."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
            #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
            #[doc = "- `RemovingLastFullAgent` if `agent` is the last full one."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(not(feature = "ink"))]
            pub fn remove_agent(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                agent: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
                    types::pallet_external_agents::pallet::ExternalAgentsCall::remove_agent {
                        asset_id,
                        agent,
                    },
                ))
            }
            #[doc = "Remove the given `agent` from `asset_id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `assetID` the [`AssetId] that has the `agent` to remove."]
            #[doc = "- `agent` of `asset_id` to remove."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
            #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
            #[doc = "- `RemovingLastFullAgent` if `agent` is the last full one."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(feature = "ink")]
            pub fn remove_agent(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                agent: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![43u8, 2u8];
                asset_id.encode_to(&mut buf);
                agent.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Abdicate agentship for `asset_id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `assetID` the [`AssetId] of which the caller is an agent."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NotAnAgent` if the caller is not an agent of `asset_id`."]
            #[doc = "- `RemovingLastFullAgent` if the caller is the last full agent."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn abdicate(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
                    types::pallet_external_agents::pallet::ExternalAgentsCall::abdicate {
                        asset_id,
                    },
                ))
            }
            #[doc = "Abdicate agentship for `asset_id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `assetID` the [`AssetId] of which the caller is an agent."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NotAnAgent` if the caller is not an agent of `asset_id`."]
            #[doc = "- `RemovingLastFullAgent` if the caller is the last full agent."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn abdicate(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![43u8, 3u8];
                asset_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Change the agent group that `agent` belongs to in `asset_id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `assetID` the [`AssetId] that has the `agent`."]
            #[doc = "- `agent` of `asset_id` to change the group for."]
            #[doc = "- `group` that `agent` will belong to in `asset_id`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
            #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
            #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
            #[doc = "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(not(feature = "ink"))]
            pub fn change_group(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                agent: ::polymesh_api_client::IdentityId,
                group: types::polymesh_primitives::agent::AgentGroup,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::ExternalAgents(
                    types::pallet_external_agents::pallet::ExternalAgentsCall::change_group {
                        asset_id,
                        agent,
                        group,
                    },
                ))
            }
            #[doc = "Change the agent group that `agent` belongs to in `asset_id`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `assetID` the [`AssetId] that has the `agent`."]
            #[doc = "- `agent` of `asset_id` to change the group for."]
            #[doc = "- `group` that `agent` will belong to in `asset_id`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedAgent` if `origin` was not authorized as an agent to call this."]
            #[doc = "- `NoSuchAG` if `id` does not identify a custom AG."]
            #[doc = "- `NotAnAgent` if `agent` is not an agent of `asset_id`."]
            #[doc = "- `RemovingLastFullAgent` if `agent` was a `Full` one and is being demoted."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(feature = "ink")]
            pub fn change_group(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                agent: ::polymesh_api_client::IdentityId,
                group: types::polymesh_primitives::agent::AgentGroup,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![43u8, 4u8];
                asset_id.encode_to(&mut buf);
                agent.encode_to(&mut buf);
                group.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Accept an authorization by an agent \"Alice\" who issued `auth_id`"]
            #[doc = "to also become an agent of the asset Alice specified."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `auth_id` identifying the authorization to accept."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `Error::InvalidAuthorization` if `auth_id` does not exist for the given caller."]
            #[doc = "- `Error::AuthorizationExpired` if `auth_id` is for an auth that has expired."]
            #[doc = "- `Error::BadAuthorizationType` if `auth_id` was not for a `BecomeAgent` auth type."]
            #[doc = "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth."]
            #[doc = "- `NoSuchAG` if the group referred to a custom that does not exist."]
            #[doc = "- `AlreadyAnAgent` if the caller is already an agent of the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Agent"]
            #[cfg(not(feature = "ink"))]
            pub fn accept_become_agent(
                &self,
                auth_id: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ExternalAgents (types :: pallet_external_agents :: pallet :: ExternalAgentsCall :: accept_become_agent { auth_id , }))
            }
            #[doc = "Accept an authorization by an agent \"Alice\" who issued `auth_id`"]
            #[doc = "to also become an agent of the asset Alice specified."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `auth_id` identifying the authorization to accept."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `Error::InvalidAuthorization` if `auth_id` does not exist for the given caller."]
            #[doc = "- `Error::AuthorizationExpired` if `auth_id` is for an auth that has expired."]
            #[doc = "- `Error::BadAuthorizationType` if `auth_id` was not for a `BecomeAgent` auth type."]
            #[doc = "- `UnauthorizedAgent` if \"Alice\" is not permissioned to provide the auth."]
            #[doc = "- `NoSuchAG` if the group referred to a custom that does not exist."]
            #[doc = "- `AlreadyAnAgent` if the caller is already an agent of the asset."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Agent"]
            #[cfg(feature = "ink")]
            pub fn accept_become_agent(&self, auth_id: u64) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![43u8, 5u8];
                auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Utility extrinsic to batch `create_group` and  `add_auth`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(not(feature = "ink"))]
            pub fn create_group_and_add_auth(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
                target: ::polymesh_api_client::IdentityId,
                expiry: Option<u64>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ExternalAgents (types :: pallet_external_agents :: pallet :: ExternalAgentsCall :: create_group_and_add_auth { asset_id , perms , target , expiry , }))
            }
            #[doc = "Utility extrinsic to batch `create_group` and  `add_auth`."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(feature = "ink")]
            pub fn create_group_and_add_auth(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
                target: ::polymesh_api_client::IdentityId,
                expiry: Option<u64>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![43u8, 6u8];
                asset_id.encode_to(&mut buf);
                perms.encode_to(&mut buf);
                target.encode_to(&mut buf);
                expiry.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Utility extrinsic to batch `create_group` and  `change_group` for custom groups only."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(not(feature = "ink"))]
            pub fn create_and_change_custom_group(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
                agent: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ExternalAgents (types :: pallet_external_agents :: pallet :: ExternalAgentsCall :: create_and_change_custom_group { asset_id , perms , agent , }))
            }
            #[doc = "Utility extrinsic to batch `create_group` and  `change_group` for custom groups only."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Agent"]
            #[cfg(feature = "ink")]
            pub fn create_and_change_custom_group(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                perms: types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
                agent: ::polymesh_api_client::IdentityId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![43u8, 7u8];
                asset_id.encode_to(&mut buf);
                perms.encode_to(&mut buf);
                agent.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for ExternalAgentsCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct ExternalAgentsQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> ExternalAgentsQueryApi<'api> {
            #[doc = " The next per-asset AG ID in the sequence."]
            #[doc = ""]
            #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence,"]
            #[doc = " which starts from 1, rather than 0."]
            #[cfg(not(feature = "ink"))]
            pub async fn ag_id_sequence(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::agent::AGId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 12u8, 233u8, 200u8, 225u8, 173u8, 92u8, 11u8, 5u8,
                    96u8, 24u8, 174u8, 23u8, 140u8, 103u8, 130u8, 219u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::agent::AGId>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The next per-asset AG ID in the sequence."]
            #[doc = ""]
            #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence,"]
            #[doc = " which starts from 1, rather than 0."]
            #[cfg(feature = "ink")]
            pub fn ag_id_sequence(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::agent::AGId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 12u8, 233u8, 200u8, 225u8, 173u8, 92u8, 11u8, 5u8,
                    96u8, 24u8, 174u8, 23u8, 140u8, 103u8, 130u8, 219u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::agent::AGId>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Maps an agent (`IdentityId`) to all assets they belong to, if any."]
            #[cfg(not(feature = "ink"))]
            pub async fn agent_of(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<()> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 53u8, 162u8, 207u8, 202u8, 92u8, 195u8, 4u8, 152u8,
                    44u8, 119u8, 99u8, 8u8, 91u8, 94u8, 104u8, 181u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[];
                    <()>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Maps an agent (`IdentityId`) to all assets they belong to, if any."]
            #[cfg(feature = "ink")]
            pub fn agent_of(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
                key_1: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<()> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 53u8, 162u8, 207u8, 202u8, 92u8, 195u8, 4u8, 152u8,
                    44u8, 119u8, 99u8, 8u8, 91u8, 94u8, 104u8, 181u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[];
                    <()>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Maps agents (`IdentityId`) for an `AssetId` to what AG they belong to, if any."]
            #[cfg(not(feature = "ink"))]
            pub async fn group_of_agent(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::agent::AgentGroup>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 242u8, 55u8, 209u8, 95u8, 72u8, 97u8, 175u8, 60u8,
                    82u8, 212u8, 93u8, 134u8, 226u8, 228u8, 249u8, 241u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Maps agents (`IdentityId`) for an `AssetId` to what AG they belong to, if any."]
            #[cfg(feature = "ink")]
            pub fn group_of_agent(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::agent::AgentGroup>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 242u8, 55u8, 209u8, 95u8, 72u8, 97u8, 175u8, 60u8,
                    82u8, 212u8, 93u8, 134u8, 226u8, 228u8, 249u8, 241u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Maps an `AssetId` to the number of `Full` agents for it."]
            #[cfg(not(feature = "ink"))]
            pub async fn num_full_agents(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 73u8, 199u8, 126u8, 22u8, 129u8, 58u8, 64u8, 117u8,
                    2u8, 182u8, 198u8, 217u8, 175u8, 14u8, 213u8, 191u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Maps an `AssetId` to the number of `Full` agents for it."]
            #[cfg(feature = "ink")]
            pub fn num_full_agents(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 73u8, 199u8, 126u8, 22u8, 129u8, 58u8, 64u8, 117u8,
                    2u8, 182u8, 198u8, 217u8, 175u8, 14u8, 213u8, 191u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " For custom AGs of an `AssetId`, maps to what permissions an agent in that AG would have."]
            #[cfg(not(feature = "ink"))]
            pub async fn group_permissions(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::agent::AGId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::secondary_key::ExtrinsicPermissions>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 228u8, 175u8, 240u8, 58u8, 197u8, 94u8, 151u8,
                    139u8, 185u8, 101u8, 37u8, 225u8, 222u8, 165u8, 102u8, 172u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " For custom AGs of an `AssetId`, maps to what permissions an agent in that AG would have."]
            #[cfg(feature = "ink")]
            pub fn group_permissions(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::agent::AGId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::secondary_key::ExtrinsicPermissions>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 228u8, 175u8, 240u8, 58u8, 197u8, 94u8, 151u8,
                    139u8, 185u8, 101u8, 37u8, 225u8, 222u8, 165u8, 102u8, 172u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::pallet_external_agents::pallet::Version>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_external_agents::pallet::Version>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::pallet_external_agents::pallet::Version>
            {
                let value = self.api.read_storage(::alloc::vec![
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_external_agents::pallet::Version>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct ExternalAgentsPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> ExternalAgentsPagedQueryApi<'api> {
            #[doc = " The next per-asset AG ID in the sequence."]
            #[doc = ""]
            #[doc = " The full ID is defined as a combination of `AssetId` and a number in this sequence,"]
            #[doc = " which starts from 1, rather than 0."]
            pub fn ag_id_sequence(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::agent::AGId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 12u8, 233u8, 200u8, 225u8, 173u8, 92u8, 11u8, 5u8,
                    96u8, 24u8, 174u8, 23u8, 140u8, 103u8, 130u8, 219u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Maps an agent (`IdentityId`) to all assets they belong to, if any."]
            pub fn agent_of(
                &self,
                key_0: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, ()>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 53u8, 162u8, 207u8, 202u8, 92u8, 195u8, 4u8, 152u8,
                    44u8, 119u8, 99u8, 8u8, 91u8, 94u8, 104u8, 181u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Maps agents (`IdentityId`) for an `AssetId` to what AG they belong to, if any."]
            pub fn group_of_agent(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::IdentityId,
                types::polymesh_primitives::agent::AgentGroup,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 242u8, 55u8, 209u8, 95u8, 72u8, 97u8, 175u8, 60u8,
                    82u8, 212u8, 93u8, 134u8, 226u8, 228u8, 249u8, 241u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Maps an `AssetId` to the number of `Full` agents for it."]
            pub fn num_full_agents(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, u32>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 73u8, 199u8, 126u8, 22u8, 129u8, 58u8, 64u8, 117u8,
                    2u8, 182u8, 198u8, 217u8, 175u8, 14u8, 213u8, 191u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " For custom AGs of an `AssetId`, maps to what permissions an agent in that AG would have."]
            pub fn group_permissions(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::agent::AGId,
                types::polymesh_primitives::secondary_key::ExtrinsicPermissions,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    217u8, 211u8, 240u8, 107u8, 84u8, 165u8, 3u8, 207u8, 6u8, 208u8, 45u8, 154u8,
                    84u8, 235u8, 102u8, 212u8, 228u8, 175u8, 240u8, 58u8, 197u8, 94u8, 151u8,
                    139u8, 185u8, 101u8, 37u8, 225u8, 222u8, 165u8, 102u8, 172u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod relayer {
        use super::*;
        #[derive(Clone)]
        pub struct RelayerCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> RelayerCallApi<'api> {
            #[doc = "Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `user_key` the user key to subsidise."]
            #[doc = "- `polyx_limit` the initial POLYX limit for this subsidy."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[cfg(not(feature = "ink"))]
            pub fn set_paying_key(
                &self,
                user_key: ::polymesh_api_client::AccountId,
                polyx_limit: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Relayer(
                    types::pallet_relayer::pallet::RelayerCall::set_paying_key {
                        user_key,
                        polyx_limit,
                    },
                ))
            }
            #[doc = "Creates an authorization to allow `user_key` to accept the caller (`origin == paying_key`) as their subsidiser."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `user_key` the user key to subsidise."]
            #[doc = "- `polyx_limit` the initial POLYX limit for this subsidy."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[cfg(feature = "ink")]
            pub fn set_paying_key(
                &self,
                user_key: ::polymesh_api_client::AccountId,
                polyx_limit: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![44u8, 0u8];
                user_key.encode_to(&mut buf);
                polyx_limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Accepts a `paying_key` authorization."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `auth_id` the authorization id to accept a `paying_key`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `Error::InvalidAuthorization` if `auth_id` does not exist for the given caller."]
            #[doc = "- `Error::AuthorizationExpired` if `auth_id` the authorization has expired."]
            #[doc = "- `Error::BadAuthorizationType` if `auth_id` was not a `AddRelayerPayingKey` authorization."]
            #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`."]
            #[doc = "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity."]
            #[doc = "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity."]
            #[doc = "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity."]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[cfg(not(feature = "ink"))]
            pub fn accept_paying_key(
                &self,
                auth_id: u64,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Relayer(
                    types::pallet_relayer::pallet::RelayerCall::accept_paying_key { auth_id },
                ))
            }
            #[doc = "Accepts a `paying_key` authorization."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `auth_id` the authorization id to accept a `paying_key`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `Error::InvalidAuthorization` if `auth_id` does not exist for the given caller."]
            #[doc = "- `Error::AuthorizationExpired` if `auth_id` the authorization has expired."]
            #[doc = "- `Error::BadAuthorizationType` if `auth_id` was not a `AddRelayerPayingKey` authorization."]
            #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to accept the authorization for the `user_key`."]
            #[doc = "- `NotAuthorizedForPayingKey` if the authorization was created an identity different from the `paying_key`'s identity."]
            #[doc = "- `UserKeyCddMissing` if the `user_key` is not attached to a CDD'd identity."]
            #[doc = "- `PayingKeyCddMissing` if the `paying_key` is not attached to a CDD'd identity."]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[cfg(feature = "ink")]
            pub fn accept_paying_key(&self, auth_id: u64) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![44u8, 1u8];
                auth_id.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Removes the `paying_key` from a `user_key`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `user_key` the user key to remove the subsidy from."]
            #[doc = "- `paying_key` the paying key that was subsidising the `user_key`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`."]
            #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
            #[doc = "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`."]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_paying_key(
                &self,
                user_key: ::polymesh_api_client::AccountId,
                paying_key: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Relayer(
                    types::pallet_relayer::pallet::RelayerCall::remove_paying_key {
                        user_key,
                        paying_key,
                    },
                ))
            }
            #[doc = "Removes the `paying_key` from a `user_key`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `user_key` the user key to remove the subsidy from."]
            #[doc = "- `paying_key` the paying key that was subsidising the `user_key`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NotAuthorizedForUserKey` if `origin` is not authorized to remove the subsidy for the `user_key`."]
            #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
            #[doc = "- `NotPayingKey` if the `paying_key` doesn't match the current `paying_key`."]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[cfg(feature = "ink")]
            pub fn remove_paying_key(
                &self,
                user_key: ::polymesh_api_client::AccountId,
                paying_key: ::polymesh_api_client::AccountId,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![44u8, 2u8];
                user_key.encode_to(&mut buf);
                paying_key.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Updates the available POLYX for a `user_key`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
            #[doc = "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
            #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[cfg(not(feature = "ink"))]
            pub fn update_polyx_limit(
                &self,
                user_key: ::polymesh_api_client::AccountId,
                polyx_limit: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Relayer(
                    types::pallet_relayer::pallet::RelayerCall::update_polyx_limit {
                        user_key,
                        polyx_limit,
                    },
                ))
            }
            #[doc = "Updates the available POLYX for a `user_key`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
            #[doc = "- `polyx_limit` the amount of POLYX available for subsidising the `user_key`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
            #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[cfg(feature = "ink")]
            pub fn update_polyx_limit(
                &self,
                user_key: ::polymesh_api_client::AccountId,
                polyx_limit: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![44u8, 3u8];
                user_key.encode_to(&mut buf);
                polyx_limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Increase the available POLYX for a `user_key`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
            #[doc = "- `amount` the amount of POLYX to add to the subsidy of `user_key`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
            #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[doc = "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`."]
            #[cfg(not(feature = "ink"))]
            pub fn increase_polyx_limit(
                &self,
                user_key: ::polymesh_api_client::AccountId,
                amount: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Relayer(
                    types::pallet_relayer::pallet::RelayerCall::increase_polyx_limit {
                        user_key,
                        amount,
                    },
                ))
            }
            #[doc = "Increase the available POLYX for a `user_key`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
            #[doc = "- `amount` the amount of POLYX to add to the subsidy of `user_key`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
            #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[doc = "- `Overlow` if the subsidy's remaining POLYX would have overflowed `u128::MAX`."]
            #[cfg(feature = "ink")]
            pub fn increase_polyx_limit(
                &self,
                user_key: ::polymesh_api_client::AccountId,
                amount: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![44u8, 4u8];
                user_key.encode_to(&mut buf);
                amount.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Decrease the available POLYX for a `user_key`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
            #[doc = "- `amount` the amount of POLYX to remove from the subsidy of `user_key`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
            #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[doc = "- `Overlow` if the subsidy has less then `amount` POLYX remaining."]
            #[cfg(not(feature = "ink"))]
            pub fn decrease_polyx_limit(
                &self,
                user_key: ::polymesh_api_client::AccountId,
                amount: u128,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Relayer(
                    types::pallet_relayer::pallet::RelayerCall::decrease_polyx_limit {
                        user_key,
                        amount,
                    },
                ))
            }
            #[doc = "Decrease the available POLYX for a `user_key`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `user_key` the user key of the subsidy to update the available POLYX."]
            #[doc = "- `amount` the amount of POLYX to remove from the subsidy of `user_key`."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- `NoPayingKey` if the `user_key` doesn't have a `paying_key`."]
            #[doc = "- `NotPayingKey` if `origin` doesn't match the current `paying_key`."]
            #[doc = "- `UnauthorizedCaller` if `origin` is not authorized to call this extrinsic."]
            #[doc = "- `Overlow` if the subsidy has less then `amount` POLYX remaining."]
            #[cfg(feature = "ink")]
            pub fn decrease_polyx_limit(
                &self,
                user_key: ::polymesh_api_client::AccountId,
                amount: u128,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![44u8, 5u8];
                user_key.encode_to(&mut buf);
                amount.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for RelayerCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct RelayerQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> RelayerQueryApi<'api> {
            #[doc = " The subsidy for a `user_key` if they are being subsidised,"]
            #[doc = " as a map `user_key` => `Subsidy`."]
            #[doc = ""]
            #[doc = " A key can only have one subsidy at a time.  To change subsidisers"]
            #[doc = " a key needs to call `remove_paying_key` to remove the current subsidy,"]
            #[doc = " before they can accept a new subsidiser."]
            #[cfg(not(feature = "ink"))]
            pub async fn subsidies(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_relayer::pallet::Subsidy<::polymesh_api_client::AccountId>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    5u8, 71u8, 187u8, 31u8, 121u8, 115u8, 160u8, 127u8, 217u8, 78u8, 1u8, 160u8,
                    208u8, 220u8, 209u8, 106u8, 75u8, 74u8, 110u8, 95u8, 140u8, 115u8, 246u8, 81u8,
                    202u8, 177u8, 63u8, 253u8, 143u8, 76u8, 227u8, 53u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The subsidy for a `user_key` if they are being subsidised,"]
            #[doc = " as a map `user_key` => `Subsidy`."]
            #[doc = ""]
            #[doc = " A key can only have one subsidy at a time.  To change subsidisers"]
            #[doc = " a key needs to call `remove_paying_key` to remove the current subsidy,"]
            #[doc = " before they can accept a new subsidiser."]
            #[cfg(feature = "ink")]
            pub fn subsidies(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_relayer::pallet::Subsidy<::polymesh_api_client::AccountId>>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    5u8, 71u8, 187u8, 31u8, 121u8, 115u8, 160u8, 127u8, 217u8, 78u8, 1u8, 160u8,
                    208u8, 220u8, 209u8, 106u8, 75u8, 74u8, 110u8, 95u8, 140u8, 115u8, 246u8, 81u8,
                    202u8, 177u8, 63u8, 253u8, 143u8, 76u8, 227u8, 53u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct RelayerPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> RelayerPagedQueryApi<'api> {
            #[doc = " The subsidy for a `user_key` if they are being subsidised,"]
            #[doc = " as a map `user_key` => `Subsidy`."]
            #[doc = ""]
            #[doc = " A key can only have one subsidy at a time.  To change subsidisers"]
            #[doc = " a key needs to call `remove_paying_key` to remove the current subsidy,"]
            #[doc = " before they can accept a new subsidiser."]
            pub fn subsidies(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_relayer::pallet::Subsidy<::polymesh_api_client::AccountId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    5u8, 71u8, 187u8, 31u8, 121u8, 115u8, 160u8, 127u8, 217u8, 78u8, 1u8, 160u8,
                    208u8, 220u8, 209u8, 106u8, 75u8, 74u8, 110u8, 95u8, 140u8, 115u8, 246u8, 81u8,
                    202u8, 177u8, 63u8, 253u8, 143u8, 76u8, 227u8, 53u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
        }
    }
    pub mod contracts {
        use super::*;
        #[derive(Clone)]
        pub struct ContractsCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> ContractsCallApi<'api> {
            #[doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."]
            #[cfg(not(feature = "ink"))]
            pub fn call_old_weight(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
                gas_limit: u64,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                data: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Contracts(
                    types::pallet_contracts::pallet::ContractsCall::call_old_weight {
                        dest,
                        value,
                        gas_limit,
                        storage_deposit_limit,
                        data,
                    },
                ))
            }
            #[doc = "Deprecated version if [`Self::call`] for use in an in-storage `Call`."]
            #[cfg(feature = "ink")]
            pub fn call_old_weight(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
                gas_limit: u64,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                data: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![46u8, 0u8];
                dest.encode_to(&mut buf);
                value.encode_to(&mut buf);
                gas_limit.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                data.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."]
            #[cfg(not(feature = "ink"))]
            pub fn instantiate_with_code_old_weight(
                &self,
                value: u128,
                gas_limit: u64,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                code: ::alloc::vec::Vec<u8>,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: Contracts (types :: pallet_contracts :: pallet :: ContractsCall :: instantiate_with_code_old_weight { value , gas_limit , storage_deposit_limit , code , data , salt , }))
            }
            #[doc = "Deprecated version if [`Self::instantiate_with_code`] for use in an in-storage `Call`."]
            #[cfg(feature = "ink")]
            pub fn instantiate_with_code_old_weight(
                &self,
                value: u128,
                gas_limit: u64,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                code: ::alloc::vec::Vec<u8>,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![46u8, 1u8];
                value.encode_to(&mut buf);
                gas_limit.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                code.encode_to(&mut buf);
                data.encode_to(&mut buf);
                salt.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."]
            #[cfg(not(feature = "ink"))]
            pub fn instantiate_old_weight(
                &self,
                value: u128,
                gas_limit: u64,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                code_hash: types::primitive_types::H256,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Contracts(
                    types::pallet_contracts::pallet::ContractsCall::instantiate_old_weight {
                        value,
                        gas_limit,
                        storage_deposit_limit,
                        code_hash,
                        data,
                        salt,
                    },
                ))
            }
            #[doc = "Deprecated version if [`Self::instantiate`] for use in an in-storage `Call`."]
            #[cfg(feature = "ink")]
            pub fn instantiate_old_weight(
                &self,
                value: u128,
                gas_limit: u64,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                code_hash: types::primitive_types::H256,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![46u8, 2u8];
                value.encode_to(&mut buf);
                gas_limit.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                code_hash.encode_to(&mut buf);
                data.encode_to(&mut buf);
                salt.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Upload new `code` without instantiating a contract from it."]
            #[doc = ""]
            #[doc = "If the code does not already exist a deposit is reserved from the caller"]
            #[doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"]
            #[doc = "depends on the size of the supplied `code`."]
            #[doc = ""]
            #[doc = "If the code already exists in storage it will still return `Ok` and upgrades"]
            #[doc = "the in storage version to the current"]
            #[doc = "[`InstructionWeights::version`](InstructionWeights)."]
            #[doc = ""]
            #[doc = "- `determinism`: If this is set to any other value but [`Determinism::Enforced`] then"]
            #[doc = "  the only way to use this code is to delegate call into it from an offchain execution."]
            #[doc = "  Set to [`Determinism::Enforced`] if in doubt."]
            #[doc = ""]
            #[doc = "# Note"]
            #[doc = ""]
            #[doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."]
            #[doc = "To avoid this situation a constructor could employ access control so that it can"]
            #[doc = "only be instantiated by permissioned entities. The same is true when uploading"]
            #[doc = "through [`Self::instantiate_with_code`]."]
            #[doc = ""]
            #[doc = "Use [`Determinism::Relaxed`] exclusively for non-deterministic code. If the uploaded"]
            #[doc = "code is deterministic, specifying [`Determinism::Relaxed`] will be disregarded and"]
            #[doc = "result in higher gas costs."]
            #[cfg(not(feature = "ink"))]
            pub fn upload_code(
                &self,
                code: ::alloc::vec::Vec<u8>,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                determinism: types::pallet_contracts::wasm::Determinism,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Contracts(
                    types::pallet_contracts::pallet::ContractsCall::upload_code {
                        code,
                        storage_deposit_limit,
                        determinism,
                    },
                ))
            }
            #[doc = "Upload new `code` without instantiating a contract from it."]
            #[doc = ""]
            #[doc = "If the code does not already exist a deposit is reserved from the caller"]
            #[doc = "and unreserved only when [`Self::remove_code`] is called. The size of the reserve"]
            #[doc = "depends on the size of the supplied `code`."]
            #[doc = ""]
            #[doc = "If the code already exists in storage it will still return `Ok` and upgrades"]
            #[doc = "the in storage version to the current"]
            #[doc = "[`InstructionWeights::version`](InstructionWeights)."]
            #[doc = ""]
            #[doc = "- `determinism`: If this is set to any other value but [`Determinism::Enforced`] then"]
            #[doc = "  the only way to use this code is to delegate call into it from an offchain execution."]
            #[doc = "  Set to [`Determinism::Enforced`] if in doubt."]
            #[doc = ""]
            #[doc = "# Note"]
            #[doc = ""]
            #[doc = "Anyone can instantiate a contract from any uploaded code and thus prevent its removal."]
            #[doc = "To avoid this situation a constructor could employ access control so that it can"]
            #[doc = "only be instantiated by permissioned entities. The same is true when uploading"]
            #[doc = "through [`Self::instantiate_with_code`]."]
            #[doc = ""]
            #[doc = "Use [`Determinism::Relaxed`] exclusively for non-deterministic code. If the uploaded"]
            #[doc = "code is deterministic, specifying [`Determinism::Relaxed`] will be disregarded and"]
            #[doc = "result in higher gas costs."]
            #[cfg(feature = "ink")]
            pub fn upload_code(
                &self,
                code: ::alloc::vec::Vec<u8>,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                determinism: types::pallet_contracts::wasm::Determinism,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![46u8, 3u8];
                code.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                determinism.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."]
            #[doc = ""]
            #[doc = "A code can only be removed by its original uploader (its owner) and only if it is"]
            #[doc = "not used by any contract."]
            #[cfg(not(feature = "ink"))]
            pub fn remove_code(
                &self,
                code_hash: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Contracts(
                    types::pallet_contracts::pallet::ContractsCall::remove_code { code_hash },
                ))
            }
            #[doc = "Remove the code stored under `code_hash` and refund the deposit to its owner."]
            #[doc = ""]
            #[doc = "A code can only be removed by its original uploader (its owner) and only if it is"]
            #[doc = "not used by any contract."]
            #[cfg(feature = "ink")]
            pub fn remove_code(
                &self,
                code_hash: types::primitive_types::H256,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![46u8, 4u8];
                code_hash.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Privileged function that changes the code of an existing contract."]
            #[doc = ""]
            #[doc = "This takes care of updating refcounts and all other necessary operations. Returns"]
            #[doc = "an error if either the `code_hash` or `dest` do not exist."]
            #[doc = ""]
            #[doc = "# Note"]
            #[doc = ""]
            #[doc = "This does **not** change the address of the contract in question. This means"]
            #[doc = "that the contract address is no longer derived from its code hash after calling"]
            #[doc = "this dispatchable."]
            #[cfg(not(feature = "ink"))]
            pub fn set_code(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                code_hash: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Contracts(
                    types::pallet_contracts::pallet::ContractsCall::set_code { dest, code_hash },
                ))
            }
            #[doc = "Privileged function that changes the code of an existing contract."]
            #[doc = ""]
            #[doc = "This takes care of updating refcounts and all other necessary operations. Returns"]
            #[doc = "an error if either the `code_hash` or `dest` do not exist."]
            #[doc = ""]
            #[doc = "# Note"]
            #[doc = ""]
            #[doc = "This does **not** change the address of the contract in question. This means"]
            #[doc = "that the contract address is no longer derived from its code hash after calling"]
            #[doc = "this dispatchable."]
            #[cfg(feature = "ink")]
            pub fn set_code(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                code_hash: types::primitive_types::H256,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![46u8, 5u8];
                dest.encode_to(&mut buf);
                code_hash.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Makes a call to an account, optionally transferring some balance."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = ""]
            #[doc = "* `dest`: Address of the contract to call."]
            #[doc = "* `value`: The balance to transfer from the `origin` to `dest`."]
            #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
            #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"]
            #[doc = "  caller to pay for the storage consumed."]
            #[doc = "* `data`: The input data to pass to the contract."]
            #[doc = ""]
            #[doc = "* If the account is a smart-contract account, the associated code will be"]
            #[doc = "executed and any value will be transferred."]
            #[doc = "* If the account is a regular account, any value will be transferred."]
            #[doc = "* If no account exists and the call value is not less than `existential_deposit`,"]
            #[doc = "a regular account will be created and any value will be transferred."]
            #[cfg(not(feature = "ink"))]
            pub fn call(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                data: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Contracts(
                    types::pallet_contracts::pallet::ContractsCall::call {
                        dest,
                        value,
                        gas_limit,
                        storage_deposit_limit,
                        data,
                    },
                ))
            }
            #[doc = "Makes a call to an account, optionally transferring some balance."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = ""]
            #[doc = "* `dest`: Address of the contract to call."]
            #[doc = "* `value`: The balance to transfer from the `origin` to `dest`."]
            #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
            #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged from the"]
            #[doc = "  caller to pay for the storage consumed."]
            #[doc = "* `data`: The input data to pass to the contract."]
            #[doc = ""]
            #[doc = "* If the account is a smart-contract account, the associated code will be"]
            #[doc = "executed and any value will be transferred."]
            #[doc = "* If the account is a regular account, any value will be transferred."]
            #[doc = "* If no account exists and the call value is not less than `existential_deposit`,"]
            #[doc = "a regular account will be created and any value will be transferred."]
            #[cfg(feature = "ink")]
            pub fn call(
                &self,
                dest: ::polymesh_api_client::MultiAddress<::polymesh_api_client::AccountId, u32>,
                value: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                data: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![46u8, 6u8];
                dest.encode_to(&mut buf);
                value.encode_to(&mut buf);
                gas_limit.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                data.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Instantiates a new contract from the supplied `code` optionally transferring"]
            #[doc = "some balance."]
            #[doc = ""]
            #[doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"]
            #[doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"]
            #[doc = "also check the documentation of [`Self::upload_code`]."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = ""]
            #[doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."]
            #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
            #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"]
            #[doc = "  from the caller to pay for the storage consumed."]
            #[doc = "* `code`: The contract code to deploy in raw bytes."]
            #[doc = "* `data`: The input data to pass to the contract constructor."]
            #[doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."]
            #[doc = ""]
            #[doc = "Instantiation is executed as follows:"]
            #[doc = ""]
            #[doc = "- The supplied `code` is deployed, and a `code_hash` is created for that code."]
            #[doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."]
            #[doc = "- The destination address is computed based on the sender, code_hash and the salt."]
            #[doc = "- The smart-contract account is created at the computed address."]
            #[doc = "- The `value` is transferred to the new account."]
            #[doc = "- The `deploy` function is executed in the context of the newly-created account."]
            #[cfg(not(feature = "ink"))]
            pub fn instantiate_with_code(
                &self,
                value: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                code: ::alloc::vec::Vec<u8>,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Contracts(
                    types::pallet_contracts::pallet::ContractsCall::instantiate_with_code {
                        value,
                        gas_limit,
                        storage_deposit_limit,
                        code,
                        data,
                        salt,
                    },
                ))
            }
            #[doc = "Instantiates a new contract from the supplied `code` optionally transferring"]
            #[doc = "some balance."]
            #[doc = ""]
            #[doc = "This dispatchable has the same effect as calling [`Self::upload_code`] +"]
            #[doc = "[`Self::instantiate`]. Bundling them together provides efficiency gains. Please"]
            #[doc = "also check the documentation of [`Self::upload_code`]."]
            #[doc = ""]
            #[doc = "# Parameters"]
            #[doc = ""]
            #[doc = "* `value`: The balance to transfer from the `origin` to the newly created contract."]
            #[doc = "* `gas_limit`: The gas limit enforced when executing the constructor."]
            #[doc = "* `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved"]
            #[doc = "  from the caller to pay for the storage consumed."]
            #[doc = "* `code`: The contract code to deploy in raw bytes."]
            #[doc = "* `data`: The input data to pass to the contract constructor."]
            #[doc = "* `salt`: Used for the address derivation. See [`Pallet::contract_address`]."]
            #[doc = ""]
            #[doc = "Instantiation is executed as follows:"]
            #[doc = ""]
            #[doc = "- The supplied `code` is deployed, and a `code_hash` is created for that code."]
            #[doc = "- If the `code_hash` already exists on the chain the underlying `code` will be shared."]
            #[doc = "- The destination address is computed based on the sender, code_hash and the salt."]
            #[doc = "- The smart-contract account is created at the computed address."]
            #[doc = "- The `value` is transferred to the new account."]
            #[doc = "- The `deploy` function is executed in the context of the newly-created account."]
            #[cfg(feature = "ink")]
            pub fn instantiate_with_code(
                &self,
                value: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                code: ::alloc::vec::Vec<u8>,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![46u8, 7u8];
                value.encode_to(&mut buf);
                gas_limit.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                code.encode_to(&mut buf);
                data.encode_to(&mut buf);
                salt.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Instantiates a contract from a previously deployed wasm binary."]
            #[doc = ""]
            #[doc = "This function is identical to [`Self::instantiate_with_code`] but without the"]
            #[doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"]
            #[doc = "must be supplied."]
            #[cfg(not(feature = "ink"))]
            pub fn instantiate(
                &self,
                value: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                code_hash: types::primitive_types::H256,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Contracts(
                    types::pallet_contracts::pallet::ContractsCall::instantiate {
                        value,
                        gas_limit,
                        storage_deposit_limit,
                        code_hash,
                        data,
                        salt,
                    },
                ))
            }
            #[doc = "Instantiates a contract from a previously deployed wasm binary."]
            #[doc = ""]
            #[doc = "This function is identical to [`Self::instantiate_with_code`] but without the"]
            #[doc = "code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary"]
            #[doc = "must be supplied."]
            #[cfg(feature = "ink")]
            pub fn instantiate(
                &self,
                value: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<::codec::Compact<u128>>,
                code_hash: types::primitive_types::H256,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![46u8, 8u8];
                value.encode_to(&mut buf);
                gas_limit.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                code_hash.encode_to(&mut buf);
                data.encode_to(&mut buf);
                salt.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "When a migration is in progress, this dispatchable can be used to run migration steps."]
            #[doc = "Calls that contribute to advancing the migration have their fees waived, as it's helpful"]
            #[doc = "for the chain. Note that while the migration is in progress, the pallet will also"]
            #[doc = "leverage the `on_idle` hooks to run migration steps."]
            #[cfg(not(feature = "ink"))]
            pub fn migrate(
                &self,
                weight_limit: ::polymesh_api_client::sp_weights::Weight,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Contracts(
                    types::pallet_contracts::pallet::ContractsCall::migrate { weight_limit },
                ))
            }
            #[doc = "When a migration is in progress, this dispatchable can be used to run migration steps."]
            #[doc = "Calls that contribute to advancing the migration have their fees waived, as it's helpful"]
            #[doc = "for the chain. Note that while the migration is in progress, the pallet will also"]
            #[doc = "leverage the `on_idle` hooks to run migration steps."]
            #[cfg(feature = "ink")]
            pub fn migrate(
                &self,
                weight_limit: ::polymesh_api_client::sp_weights::Weight,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![46u8, 9u8];
                weight_limit.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for ContractsCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct ContractsQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> ContractsQueryApi<'api> {
            #[doc = " A mapping from a contract's code hash to its code."]
            #[cfg(not(feature = "ink"))]
            pub async fn pristine_code(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<Option<::alloc::vec::Vec<u8>>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 77u8, 108u8, 43u8, 3u8, 185u8, 0u8, 40u8, 243u8,
                    191u8, 64u8, 126u8, 180u8, 51u8, 233u8, 99u8, 137u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " A mapping from a contract's code hash to its code."]
            #[cfg(feature = "ink")]
            pub fn pristine_code(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<Option<::alloc::vec::Vec<u8>>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 77u8, 108u8, 43u8, 3u8, 185u8, 0u8, 40u8, 243u8,
                    191u8, 64u8, 126u8, 180u8, 51u8, 233u8, 99u8, 137u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " A mapping from a contract's code hash to its code info."]
            #[cfg(not(feature = "ink"))]
            pub async fn code_info_of(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<Option<types::pallet_contracts::wasm::CodeInfo>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 8u8, 54u8, 41u8, 149u8, 131u8, 65u8, 105u8, 136u8,
                    93u8, 231u8, 244u8, 253u8, 103u8, 25u8, 110u8, 103u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " A mapping from a contract's code hash to its code info."]
            #[cfg(feature = "ink")]
            pub fn code_info_of(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<Option<types::pallet_contracts::wasm::CodeInfo>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 8u8, 54u8, 41u8, 149u8, 131u8, 65u8, 105u8, 136u8,
                    93u8, 231u8, 244u8, 253u8, 103u8, 25u8, 110u8, 103u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " This is a **monotonic** counter incremented on contract instantiation."]
            #[doc = ""]
            #[doc = " This is used in order to generate unique trie ids for contracts."]
            #[doc = " The trie id of a new contract is calculated from hash(account_id, nonce)."]
            #[doc = " The nonce is required because otherwise the following sequence would lead to"]
            #[doc = " a possible collision of storage:"]
            #[doc = ""]
            #[doc = " 1. Create a new contract."]
            #[doc = " 2. Terminate the contract."]
            #[doc = " 3. Immediately recreate the contract with the same account_id."]
            #[doc = ""]
            #[doc = " This is bad because the contents of a trie are deleted lazily and there might be"]
            #[doc = " storage of the old instantiation still in it when the new contract is created. Please"]
            #[doc = " note that we can't replace the counter by the block number because the sequence above"]
            #[doc = " can happen in the same block. We also can't keep the account counter in memory only"]
            #[doc = " because storage is the only way to communicate across different extrinsics in the"]
            #[doc = " same block."]
            #[doc = ""]
            #[doc = " # Note"]
            #[doc = ""]
            #[doc = " Do not use it to determine the number of contracts. It won't be decremented if"]
            #[doc = " a contract is destroyed."]
            #[cfg(not(feature = "ink"))]
            pub async fn nonce(&self) -> ::polymesh_api_client::error::Result<u64> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 113u8, 131u8, 104u8, 160u8, 172u8, 227u8, 110u8,
                    43u8, 27u8, 139u8, 109u8, 189u8, 127u8, 128u8, 147u8, 192u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " This is a **monotonic** counter incremented on contract instantiation."]
            #[doc = ""]
            #[doc = " This is used in order to generate unique trie ids for contracts."]
            #[doc = " The trie id of a new contract is calculated from hash(account_id, nonce)."]
            #[doc = " The nonce is required because otherwise the following sequence would lead to"]
            #[doc = " a possible collision of storage:"]
            #[doc = ""]
            #[doc = " 1. Create a new contract."]
            #[doc = " 2. Terminate the contract."]
            #[doc = " 3. Immediately recreate the contract with the same account_id."]
            #[doc = ""]
            #[doc = " This is bad because the contents of a trie are deleted lazily and there might be"]
            #[doc = " storage of the old instantiation still in it when the new contract is created. Please"]
            #[doc = " note that we can't replace the counter by the block number because the sequence above"]
            #[doc = " can happen in the same block. We also can't keep the account counter in memory only"]
            #[doc = " because storage is the only way to communicate across different extrinsics in the"]
            #[doc = " same block."]
            #[doc = ""]
            #[doc = " # Note"]
            #[doc = ""]
            #[doc = " Do not use it to determine the number of contracts. It won't be decremented if"]
            #[doc = " a contract is destroyed."]
            #[cfg(feature = "ink")]
            pub fn nonce(&self) -> ::polymesh_api_ink::error::Result<u64> {
                let value = self.api.read_storage(::alloc::vec![
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 113u8, 131u8, 104u8, 160u8, 172u8, 227u8, 110u8,
                    43u8, 27u8, 139u8, 109u8, 189u8, 127u8, 128u8, 147u8, 192u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The code associated with a given account."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn contract_info_of(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_contracts::storage::ContractInfo>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 6u8, 14u8, 153u8, 229u8, 55u8, 142u8, 86u8, 37u8,
                    55u8, 207u8, 59u8, 201u8, 131u8, 225u8, 123u8, 145u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The code associated with a given account."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            #[cfg(feature = "ink")]
            pub fn contract_info_of(
                &self,
                key_0: ::polymesh_api_client::AccountId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_contracts::storage::ContractInfo>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 6u8, 14u8, 153u8, 229u8, 55u8, 142u8, 86u8, 37u8,
                    55u8, 207u8, 59u8, 201u8, 131u8, 225u8, 123u8, 145u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Evicted contracts that await child trie deletion."]
            #[doc = ""]
            #[doc = " Child trie deletion is a heavy operation depending on the amount of storage items"]
            #[doc = " stored in said trie. Therefore this operation is performed lazily in `on_idle`."]
            #[cfg(not(feature = "ink"))]
            pub async fn deletion_queue(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<Option<::alloc::vec::Vec<u8>>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 41u8, 22u8, 33u8, 17u8, 173u8, 25u8, 239u8, 20u8,
                    81u8, 85u8, 238u8, 85u8, 42u8, 239u8, 45u8, 17u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Evicted contracts that await child trie deletion."]
            #[doc = ""]
            #[doc = " Child trie deletion is a heavy operation depending on the amount of storage items"]
            #[doc = " stored in said trie. Therefore this operation is performed lazily in `on_idle`."]
            #[cfg(feature = "ink")]
            pub fn deletion_queue(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<Option<::alloc::vec::Vec<u8>>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 41u8, 22u8, 33u8, 17u8, 173u8, 25u8, 239u8, 20u8,
                    81u8, 85u8, 238u8, 85u8, 42u8, 239u8, 45u8, 17u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " A pair of monotonic counters used to track the latest contract marked for deletion"]
            #[doc = " and the latest deleted contract in queue."]
            #[cfg(not(feature = "ink"))]
            pub async fn deletion_queue_counter(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::pallet_contracts::storage::DeletionQueueManager,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 108u8, 255u8, 212u8, 115u8, 184u8, 40u8, 221u8,
                    157u8, 9u8, 18u8, 179u8, 124u8, 178u8, 51u8, 158u8, 121u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::pallet_contracts::storage::DeletionQueueManager>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " A pair of monotonic counters used to track the latest contract marked for deletion"]
            #[doc = " and the latest deleted contract in queue."]
            #[cfg(feature = "ink")]
            pub fn deletion_queue_counter(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                types::pallet_contracts::storage::DeletionQueueManager,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 108u8, 255u8, 212u8, 115u8, 184u8, 40u8, 221u8,
                    157u8, 9u8, 18u8, 179u8, 124u8, 178u8, 51u8, 158u8, 121u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::pallet_contracts::storage::DeletionQueueManager>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " A migration can span across multiple blocks. This storage defines a cursor to track the"]
            #[doc = " progress of the migration, enabling us to resume from the last completed position."]
            #[cfg(not(feature = "ink"))]
            pub async fn migration_in_progress(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<::alloc::vec::Vec<u8>>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 26u8, 207u8, 158u8, 75u8, 24u8, 207u8, 63u8, 7u8,
                    70u8, 114u8, 67u8, 67u8, 145u8, 10u8, 215u8, 36u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " A migration can span across multiple blocks. This storage defines a cursor to track the"]
            #[doc = " progress of the migration, enabling us to resume from the last completed position."]
            #[cfg(feature = "ink")]
            pub fn migration_in_progress(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<::alloc::vec::Vec<u8>>> {
                let value = self.api.read_storage(::alloc::vec![
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 26u8, 207u8, 158u8, 75u8, 24u8, 207u8, 63u8, 7u8,
                    70u8, 114u8, 67u8, 67u8, 145u8, 10u8, 215u8, 36u8,
                ])?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct ContractsPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> ContractsPagedQueryApi<'api> {
            #[doc = " A mapping from a contract's code hash to its code."]
            pub fn pristine_code(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                ::alloc::vec::Vec<u8>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 77u8, 108u8, 43u8, 3u8, 185u8, 0u8, 40u8, 243u8,
                    191u8, 64u8, 126u8, 180u8, 51u8, 233u8, 99u8, 137u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " A mapping from a contract's code hash to its code info."]
            pub fn code_info_of(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                types::pallet_contracts::wasm::CodeInfo,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 8u8, 54u8, 41u8, 149u8, 131u8, 65u8, 105u8, 136u8,
                    93u8, 231u8, 244u8, 253u8, 103u8, 25u8, 110u8, 103u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " The code associated with a given account."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
            pub fn contract_info_of(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AccountId,
                types::pallet_contracts::storage::ContractInfo,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 6u8, 14u8, 153u8, 229u8, 55u8, 142u8, 86u8, 37u8,
                    55u8, 207u8, 59u8, 201u8, 131u8, 225u8, 123u8, 145u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Evicted contracts that await child trie deletion."]
            #[doc = ""]
            #[doc = " Child trie deletion is a heavy operation depending on the amount of storage items"]
            #[doc = " stored in said trie. Therefore this operation is performed lazily in `on_idle`."]
            pub fn deletion_queue(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<u32, ::alloc::vec::Vec<u8>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    67u8, 66u8, 25u8, 62u8, 73u8, 111u8, 171u8, 126u8, 197u8, 157u8, 97u8, 94u8,
                    208u8, 220u8, 85u8, 48u8, 41u8, 22u8, 33u8, 17u8, 173u8, 25u8, 239u8, 20u8,
                    81u8, 85u8, 238u8, 85u8, 42u8, 239u8, 45u8, 17u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod polymesh_contracts {
        use super::*;
        #[derive(Clone)]
        pub struct PolymeshContractsCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> PolymeshContractsCallApi<'api> {
            #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
            #[doc = ""]
            #[doc = "The contract will be attached as a secondary key,"]
            #[doc = "with `perms` as its permissions, to `origin`'s identity."]
            #[doc = ""]
            #[doc = "The contract is transferred `endowment` amount of POLYX."]
            #[doc = "This is distinct from the `gas_limit`,"]
            #[doc = "which controls how much gas the deployment code may at most consume."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
            #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
            #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
            #[doc = "  from the caller to pay for the storage consumed."]
            #[doc = "- `code` with the WASM binary defining the smart contract."]
            #[doc = "- `data` The input data to pass to the contract constructor."]
            #[doc = "- `salt` used for contract address derivation."]
            #[doc = "   By varying this, the same `code` can be used under the same identity."]
            #[doc = "- `perms` that the new secondary key will have."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here."]
            #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
            #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
            #[cfg(not(feature = "ink"))]
            pub fn instantiate_with_code_perms(
                &self,
                endowment: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<u128>,
                code: ::alloc::vec::Vec<u8>,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
                perms: types::polymesh_primitives::secondary_key::Permissions,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: PolymeshContracts (types :: polymesh_contracts :: pallet :: PolymeshContractsCall :: instantiate_with_code_perms { endowment , gas_limit , storage_deposit_limit , code , data , salt , perms , }))
            }
            #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
            #[doc = ""]
            #[doc = "The contract will be attached as a secondary key,"]
            #[doc = "with `perms` as its permissions, to `origin`'s identity."]
            #[doc = ""]
            #[doc = "The contract is transferred `endowment` amount of POLYX."]
            #[doc = "This is distinct from the `gas_limit`,"]
            #[doc = "which controls how much gas the deployment code may at most consume."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
            #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
            #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
            #[doc = "  from the caller to pay for the storage consumed."]
            #[doc = "- `code` with the WASM binary defining the smart contract."]
            #[doc = "- `data` The input data to pass to the contract constructor."]
            #[doc = "- `salt` used for contract address derivation."]
            #[doc = "   By varying this, the same `code` can be used under the same identity."]
            #[doc = "- `perms` that the new secondary key will have."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- All the errors in `pallet_contracts::Call::instantiate_with_code` can also happen here."]
            #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
            #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
            #[cfg(feature = "ink")]
            pub fn instantiate_with_code_perms(
                &self,
                endowment: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<u128>,
                code: ::alloc::vec::Vec<u8>,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
                perms: types::polymesh_primitives::secondary_key::Permissions,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![47u8, 0u8];
                endowment.encode_to(&mut buf);
                gas_limit.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                code.encode_to(&mut buf);
                data.encode_to(&mut buf);
                salt.encode_to(&mut buf);
                perms.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
            #[doc = ""]
            #[doc = "Unlike `instantiate_with_code`,"]
            #[doc = "this assumes that at least one contract with the same WASM code has already been uploaded."]
            #[doc = ""]
            #[doc = "The contract will be attached as a secondary key,"]
            #[doc = "with `perms` as its permissions, to `origin`'s identity."]
            #[doc = ""]
            #[doc = "The contract is transferred `endowment` amount of POLYX."]
            #[doc = "This is distinct from the `gas_limit`,"]
            #[doc = "which controls how much gas the deployment code may at most consume."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
            #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
            #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
            #[doc = "  from the caller to pay for the storage consumed."]
            #[doc = "- `code_hash` of an already uploaded WASM binary."]
            #[doc = "- `data` The input data to pass to the contract constructor."]
            #[doc = "- `salt` used for contract address derivation."]
            #[doc = "   By varying this, the same `code` can be used under the same identity."]
            #[doc = "- `perms` that the new secondary key will have."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- All the errors in `pallet_contracts::Call::instantiate` can also happen here."]
            #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
            #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
            #[cfg(not(feature = "ink"))]
            pub fn instantiate_with_hash_perms(
                &self,
                endowment: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<u128>,
                code_hash: types::primitive_types::H256,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
                perms: types::polymesh_primitives::secondary_key::Permissions,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: PolymeshContracts (types :: polymesh_contracts :: pallet :: PolymeshContractsCall :: instantiate_with_hash_perms { endowment , gas_limit , storage_deposit_limit , code_hash , data , salt , perms , }))
            }
            #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
            #[doc = ""]
            #[doc = "Unlike `instantiate_with_code`,"]
            #[doc = "this assumes that at least one contract with the same WASM code has already been uploaded."]
            #[doc = ""]
            #[doc = "The contract will be attached as a secondary key,"]
            #[doc = "with `perms` as its permissions, to `origin`'s identity."]
            #[doc = ""]
            #[doc = "The contract is transferred `endowment` amount of POLYX."]
            #[doc = "This is distinct from the `gas_limit`,"]
            #[doc = "which controls how much gas the deployment code may at most consume."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `endowment` amount of POLYX to transfer to the contract."]
            #[doc = "- `gas_limit` for how much gas the `deploy` code in the contract may at most consume."]
            #[doc = "- `storage_deposit_limit` The maximum amount of balance that can be charged/reserved"]
            #[doc = "  from the caller to pay for the storage consumed."]
            #[doc = "- `code_hash` of an already uploaded WASM binary."]
            #[doc = "- `data` The input data to pass to the contract constructor."]
            #[doc = "- `salt` used for contract address derivation."]
            #[doc = "   By varying this, the same `code` can be used under the same identity."]
            #[doc = "- `perms` that the new secondary key will have."]
            #[doc = ""]
            #[doc = "# Errors"]
            #[doc = "- All the errors in `pallet_contracts::Call::instantiate` can also happen here."]
            #[doc = "- CDD/Permissions are checked, unlike in `pallet_contracts`."]
            #[doc = "- Errors that arise when adding a new secondary key can also occur here."]
            #[cfg(feature = "ink")]
            pub fn instantiate_with_hash_perms(
                &self,
                endowment: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<u128>,
                code_hash: types::primitive_types::H256,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
                perms: types::polymesh_primitives::secondary_key::Permissions,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![47u8, 1u8];
                endowment.encode_to(&mut buf);
                gas_limit.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                code_hash.encode_to(&mut buf);
                data.encode_to(&mut buf);
                salt.encode_to(&mut buf);
                perms.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Update CallRuntime whitelist."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[cfg(not(feature = "ink"))]
            pub fn update_call_runtime_whitelist(
                &self,
                updates: ::alloc::vec::Vec<(
                    types::polymesh_contracts::chain_extension::ExtrinsicId,
                    bool,
                )>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: PolymeshContracts (types :: polymesh_contracts :: pallet :: PolymeshContractsCall :: update_call_runtime_whitelist { updates , }))
            }
            #[doc = "Update CallRuntime whitelist."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = ""]
            #[doc = "# Errors"]
            #[cfg(feature = "ink")]
            pub fn update_call_runtime_whitelist(
                &self,
                updates: ::alloc::vec::Vec<(
                    types::polymesh_contracts::chain_extension::ExtrinsicId,
                    bool,
                )>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![47u8, 2u8];
                updates.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
            #[doc = ""]
            #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `endowment`: Amount of POLYX to transfer to the contract."]
            #[doc = "- `gas_limit`: For how much gas the `deploy` code in the contract may at most consume."]
            #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
            #[doc = "- `code`: The WASM binary defining the smart contract."]
            #[doc = "- `data`: The input data to pass to the contract constructor."]
            #[doc = "- `salt`: Used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
            #[doc = ""]
            #[cfg(not(feature = "ink"))]
            pub fn instantiate_with_code_as_primary_key(
                &self,
                endowment: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<u128>,
                code: ::alloc::vec::Vec<u8>,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: PolymeshContracts (types :: polymesh_contracts :: pallet :: PolymeshContractsCall :: instantiate_with_code_as_primary_key { endowment , gas_limit , storage_deposit_limit , code , data , salt , }))
            }
            #[doc = "Instantiates a smart contract defining it with the given `code` and `salt`."]
            #[doc = ""]
            #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `endowment`: Amount of POLYX to transfer to the contract."]
            #[doc = "- `gas_limit`: For how much gas the `deploy` code in the contract may at most consume."]
            #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
            #[doc = "- `code`: The WASM binary defining the smart contract."]
            #[doc = "- `data`: The input data to pass to the contract constructor."]
            #[doc = "- `salt`: Used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
            #[doc = ""]
            #[cfg(feature = "ink")]
            pub fn instantiate_with_code_as_primary_key(
                &self,
                endowment: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<u128>,
                code: ::alloc::vec::Vec<u8>,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![47u8, 3u8];
                endowment.encode_to(&mut buf);
                gas_limit.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                code.encode_to(&mut buf);
                data.encode_to(&mut buf);
                salt.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
            #[doc = ""]
            #[doc = "Unlike `instantiate_with_code`, this assumes that at least one contract with the same WASM code has already been uploaded."]
            #[doc = ""]
            #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `endowment`: amount of POLYX to transfer to the contract."]
            #[doc = "- `gas_limit`: for how much gas the `deploy` code in the contract may at most consume."]
            #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
            #[doc = "- `code_hash`: of an already uploaded WASM binary."]
            #[doc = "- `data`: The input data to pass to the contract constructor."]
            #[doc = "- `salt`: used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
            #[doc = ""]
            #[cfg(not(feature = "ink"))]
            pub fn instantiate_with_hash_as_primary_key(
                &self,
                endowment: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<u128>,
                code_hash: types::primitive_types::H256,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: PolymeshContracts (types :: polymesh_contracts :: pallet :: PolymeshContractsCall :: instantiate_with_hash_as_primary_key { endowment , gas_limit , storage_deposit_limit , code_hash , data , salt , }))
            }
            #[doc = "Instantiates a smart contract defining using the given `code_hash` and `salt`."]
            #[doc = ""]
            #[doc = "Unlike `instantiate_with_code`, this assumes that at least one contract with the same WASM code has already been uploaded."]
            #[doc = ""]
            #[doc = "The contract will be attached as a primary key of a newly created child identity of the caller."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "- `endowment`: amount of POLYX to transfer to the contract."]
            #[doc = "- `gas_limit`: for how much gas the `deploy` code in the contract may at most consume."]
            #[doc = "- `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved from the caller to pay for the storage consumed."]
            #[doc = "- `code_hash`: of an already uploaded WASM binary."]
            #[doc = "- `data`: The input data to pass to the contract constructor."]
            #[doc = "- `salt`: used for contract address derivation. By varying this, the same `code` can be used under the same identity."]
            #[doc = ""]
            #[cfg(feature = "ink")]
            pub fn instantiate_with_hash_as_primary_key(
                &self,
                endowment: u128,
                gas_limit: ::polymesh_api_client::sp_weights::Weight,
                storage_deposit_limit: Option<u128>,
                code_hash: types::primitive_types::H256,
                data: ::alloc::vec::Vec<u8>,
                salt: ::alloc::vec::Vec<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![47u8, 4u8];
                endowment.encode_to(&mut buf);
                gas_limit.encode_to(&mut buf);
                storage_deposit_limit.encode_to(&mut buf);
                code_hash.encode_to(&mut buf);
                data.encode_to(&mut buf);
                salt.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[cfg(not(feature = "ink"))]
            pub fn upgrade_api(
                &self,
                api: types::polymesh_contracts::Api,
                next_upgrade: types::polymesh_contracts::NextUpgrade,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::PolymeshContracts(
                    types::polymesh_contracts::pallet::PolymeshContractsCall::upgrade_api {
                        api,
                        next_upgrade,
                    },
                ))
            }
            #[cfg(feature = "ink")]
            pub fn upgrade_api(
                &self,
                api: types::polymesh_contracts::Api,
                next_upgrade: types::polymesh_contracts::NextUpgrade,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![47u8, 5u8];
                api.encode_to(&mut buf);
                next_upgrade.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for PolymeshContractsCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct PolymeshContractsQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> PolymeshContractsQueryApi<'api> {
            #[doc = " Whitelist of extrinsics allowed to be called from contracts."]
            #[cfg(not(feature = "ink"))]
            pub async fn call_runtime_whitelist(
                &self,
                key_0: types::polymesh_contracts::chain_extension::ExtrinsicId,
            ) -> ::polymesh_api_client::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 18u8, 86u8, 78u8, 236u8, 93u8, 99u8, 65u8, 206u8,
                    211u8, 34u8, 76u8, 171u8, 105u8, 214u8, 137u8, 42u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Whitelist of extrinsics allowed to be called from contracts."]
            #[cfg(feature = "ink")]
            pub fn call_runtime_whitelist(
                &self,
                key_0: types::polymesh_contracts::chain_extension::ExtrinsicId,
            ) -> ::polymesh_api_ink::error::Result<bool> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 18u8, 86u8, 78u8, 236u8, 93u8, 99u8, 65u8, 206u8,
                    211u8, 34u8, 76u8, 171u8, 105u8, 214u8, 137u8, 42u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <bool>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(not(feature = "ink"))]
            pub async fn storage_version(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_contracts::pallet::Version>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_contracts::pallet::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Storage version."]
            #[cfg(feature = "ink")]
            pub fn storage_version(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_contracts::pallet::Version>
            {
                let value = self.api.read_storage(::alloc::vec![
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 48u8, 140u8, 233u8, 97u8, 93u8, 224u8, 119u8, 90u8,
                    130u8, 248u8, 169u8, 77u8, 195u8, 210u8, 133u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_contracts::pallet::Version>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Stores the chain version and code hash for the next chain upgrade."]
            #[cfg(not(feature = "ink"))]
            pub async fn api_next_upgrade(
                &self,
                key_0: types::polymesh_contracts::Api,
            ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_contracts::NextUpgrade>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 114u8, 234u8, 160u8, 152u8, 251u8, 78u8, 157u8, 47u8,
                    30u8, 165u8, 58u8, 78u8, 190u8, 160u8, 122u8, 239u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Stores the chain version and code hash for the next chain upgrade."]
            #[cfg(feature = "ink")]
            pub fn api_next_upgrade(
                &self,
                key_0: types::polymesh_contracts::Api,
            ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_contracts::NextUpgrade>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 114u8, 234u8, 160u8, 152u8, 251u8, 78u8, 157u8, 47u8,
                    30u8, 165u8, 58u8, 78u8, 190u8, 160u8, 122u8, 239u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Stores the code hash for the current api."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_api_hash(
                &self,
                key_0: types::polymesh_contracts::Api,
            ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_contracts::ApiCodeHash>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 179u8, 48u8, 43u8, 247u8, 216u8, 48u8, 112u8, 2u8,
                    78u8, 184u8, 137u8, 253u8, 37u8, 61u8, 234u8, 27u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Stores the code hash for the current api."]
            #[cfg(feature = "ink")]
            pub fn current_api_hash(
                &self,
                key_0: types::polymesh_contracts::Api,
            ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_contracts::ApiCodeHash>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 179u8, 48u8, 43u8, 247u8, 216u8, 48u8, 112u8, 2u8,
                    78u8, 184u8, 137u8, 253u8, 37u8, 61u8, 234u8, 27u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct PolymeshContractsPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> PolymeshContractsPagedQueryApi<'api> {
            #[doc = " Whitelist of extrinsics allowed to be called from contracts."]
            pub fn call_runtime_whitelist(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_contracts::chain_extension::ExtrinsicId,
                bool,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 18u8, 86u8, 78u8, 236u8, 93u8, 99u8, 65u8, 206u8,
                    211u8, 34u8, 76u8, 171u8, 105u8, 214u8, 137u8, 42u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " Stores the chain version and code hash for the next chain upgrade."]
            pub fn api_next_upgrade(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_contracts::Api,
                types::polymesh_contracts::NextUpgrade,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 114u8, 234u8, 160u8, 152u8, 251u8, 78u8, 157u8, 47u8,
                    30u8, 165u8, 58u8, 78u8, 190u8, 160u8, 122u8, 239u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
            #[doc = " Stores the code hash for the current api."]
            pub fn current_api_hash(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_contracts::Api,
                types::polymesh_contracts::ApiCodeHash,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    2u8, 198u8, 189u8, 143u8, 229u8, 153u8, 33u8, 126u8, 200u8, 74u8, 193u8, 67u8,
                    214u8, 209u8, 166u8, 2u8, 179u8, 48u8, 43u8, 247u8, 216u8, 48u8, 112u8, 2u8,
                    78u8, 184u8, 137u8, 253u8, 37u8, 61u8, 234u8, 27u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod preimage {
        use super::*;
        #[derive(Clone)]
        pub struct PreimageCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> PreimageCallApi<'api> {
            #[doc = "Register a preimage on-chain."]
            #[doc = ""]
            #[doc = "If the preimage was previously requested, no fees or deposits are taken for providing"]
            #[doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."]
            #[cfg(not(feature = "ink"))]
            pub fn note_preimage(
                &self,
                bytes: ::alloc::vec::Vec<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Preimage(
                    types::pallet_preimage::pallet::PreimageCall::note_preimage { bytes },
                ))
            }
            #[doc = "Register a preimage on-chain."]
            #[doc = ""]
            #[doc = "If the preimage was previously requested, no fees or deposits are taken for providing"]
            #[doc = "the preimage. Otherwise, a deposit is taken proportional to the size of the preimage."]
            #[cfg(feature = "ink")]
            pub fn note_preimage(&self, bytes: ::alloc::vec::Vec<u8>) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![48u8, 0u8];
                bytes.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Clear an unrequested preimage from the runtime storage."]
            #[doc = ""]
            #[doc = "If `len` is provided, then it will be a much cheaper operation."]
            #[doc = ""]
            #[doc = "- `hash`: The hash of the preimage to be removed from the store."]
            #[doc = "- `len`: The length of the preimage of `hash`."]
            #[cfg(not(feature = "ink"))]
            pub fn unnote_preimage(
                &self,
                hash: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Preimage(
                    types::pallet_preimage::pallet::PreimageCall::unnote_preimage { hash },
                ))
            }
            #[doc = "Clear an unrequested preimage from the runtime storage."]
            #[doc = ""]
            #[doc = "If `len` is provided, then it will be a much cheaper operation."]
            #[doc = ""]
            #[doc = "- `hash`: The hash of the preimage to be removed from the store."]
            #[doc = "- `len`: The length of the preimage of `hash`."]
            #[cfg(feature = "ink")]
            pub fn unnote_preimage(
                &self,
                hash: types::primitive_types::H256,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![48u8, 1u8];
                hash.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."]
            #[doc = ""]
            #[doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"]
            #[doc = "a user may have paid, and take the control of the preimage out of their hands."]
            #[cfg(not(feature = "ink"))]
            pub fn request_preimage(
                &self,
                hash: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Preimage(
                    types::pallet_preimage::pallet::PreimageCall::request_preimage { hash },
                ))
            }
            #[doc = "Request a preimage be uploaded to the chain without paying any fees or deposits."]
            #[doc = ""]
            #[doc = "If the preimage requests has already been provided on-chain, we unreserve any deposit"]
            #[doc = "a user may have paid, and take the control of the preimage out of their hands."]
            #[cfg(feature = "ink")]
            pub fn request_preimage(
                &self,
                hash: types::primitive_types::H256,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![48u8, 2u8];
                hash.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Clear a previously made request for a preimage."]
            #[doc = ""]
            #[doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."]
            #[cfg(not(feature = "ink"))]
            pub fn unrequest_preimage(
                &self,
                hash: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Preimage(
                    types::pallet_preimage::pallet::PreimageCall::unrequest_preimage { hash },
                ))
            }
            #[doc = "Clear a previously made request for a preimage."]
            #[doc = ""]
            #[doc = "NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`."]
            #[cfg(feature = "ink")]
            pub fn unrequest_preimage(
                &self,
                hash: types::primitive_types::H256,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![48u8, 3u8];
                hash.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Ensure that the bulk of pre-images is upgraded."]
            #[doc = ""]
            #[doc = "The caller pays no fee if at least 90% of pre-images were successfully updated."]
            #[cfg(not(feature = "ink"))]
            pub fn ensure_updated(
                &self,
                hashes: ::alloc::vec::Vec<types::primitive_types::H256>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Preimage(
                    types::pallet_preimage::pallet::PreimageCall::ensure_updated { hashes },
                ))
            }
            #[doc = "Ensure that the bulk of pre-images is upgraded."]
            #[doc = ""]
            #[doc = "The caller pays no fee if at least 90% of pre-images were successfully updated."]
            #[cfg(feature = "ink")]
            pub fn ensure_updated(
                &self,
                hashes: ::alloc::vec::Vec<types::primitive_types::H256>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![48u8, 4u8];
                hashes.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for PreimageCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct PreimageQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> PreimageQueryApi<'api> {
            #[doc = " The request status of a given hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn status_for(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::pallet_preimage::OldRequestStatus<
                        ::polymesh_api_client::AccountId,
                        u128,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8,
                    70u8, 86u8, 164u8, 72u8, 37u8, 85u8, 177u8, 174u8, 142u8, 206u8, 213u8, 82u8,
                    47u8, 60u8, 64u8, 73u8, 188u8, 132u8, 237u8, 164u8, 168u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The request status of a given hash."]
            #[cfg(feature = "ink")]
            pub fn status_for(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::pallet_preimage::OldRequestStatus<
                        ::polymesh_api_client::AccountId,
                        u128,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8,
                    70u8, 86u8, 164u8, 72u8, 37u8, 85u8, 177u8, 174u8, 142u8, 206u8, 213u8, 82u8,
                    47u8, 60u8, 64u8, 73u8, 188u8, 132u8, 237u8, 164u8, 168u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The request status of a given hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn request_status_for(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::pallet_preimage::RequestStatus<
                        ::polymesh_api_client::AccountId,
                        types::frame_support::traits::tokens::fungible::HoldConsideration,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8,
                    70u8, 86u8, 164u8, 72u8, 37u8, 80u8, 44u8, 38u8, 13u8, 91u8, 187u8, 69u8, 37u8,
                    202u8, 12u8, 237u8, 92u8, 217u8, 67u8, 82u8, 64u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The request status of a given hash."]
            #[cfg(feature = "ink")]
            pub fn request_status_for(
                &self,
                key_0: types::primitive_types::H256,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::pallet_preimage::RequestStatus<
                        ::polymesh_api_client::AccountId,
                        types::frame_support::traits::tokens::fungible::HoldConsideration,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8,
                    70u8, 86u8, 164u8, 72u8, 37u8, 80u8, 44u8, 38u8, 13u8, 91u8, 187u8, 69u8, 37u8,
                    202u8, 12u8, 237u8, 92u8, 217u8, 67u8, 82u8, 64u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[cfg(not(feature = "ink"))]
            pub async fn preimage_for(
                &self,
                key_0: (types::primitive_types::H256, u32),
            ) -> ::polymesh_api_client::error::Result<Option<::alloc::vec::Vec<u8>>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8,
                    70u8, 86u8, 164u8, 72u8, 37u8, 124u8, 125u8, 218u8, 133u8, 201u8, 194u8, 151u8,
                    153u8, 159u8, 208u8, 34u8, 21u8, 232u8, 200u8, 249u8, 222u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[cfg(feature = "ink")]
            pub fn preimage_for(
                &self,
                key_0: (types::primitive_types::H256, u32),
            ) -> ::polymesh_api_ink::error::Result<Option<::alloc::vec::Vec<u8>>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8,
                    70u8, 86u8, 164u8, 72u8, 37u8, 124u8, 125u8, 218u8, 133u8, 201u8, 194u8, 151u8,
                    153u8, 159u8, 208u8, 34u8, 21u8, 232u8, 200u8, 249u8, 222u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct PreimagePagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> PreimagePagedQueryApi<'api> {
            #[doc = " The request status of a given hash."]
            pub fn status_for(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                types::pallet_preimage::OldRequestStatus<::polymesh_api_client::AccountId, u128>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8,
                    70u8, 86u8, 164u8, 72u8, 37u8, 85u8, 177u8, 174u8, 142u8, 206u8, 213u8, 82u8,
                    47u8, 60u8, 64u8, 73u8, 188u8, 132u8, 237u8, 164u8, 168u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " The request status of a given hash."]
            pub fn request_status_for(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::primitive_types::H256,
                types::pallet_preimage::RequestStatus<
                    ::polymesh_api_client::AccountId,
                    types::frame_support::traits::tokens::fungible::HoldConsideration,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8,
                    70u8, 86u8, 164u8, 72u8, 37u8, 80u8, 44u8, 38u8, 13u8, 91u8, 187u8, 69u8, 37u8,
                    202u8, 12u8, 237u8, 92u8, 217u8, 67u8, 82u8, 64u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            pub fn preimage_for(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                (types::primitive_types::H256, u32),
                ::alloc::vec::Vec<u8>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    216u8, 243u8, 20u8, 183u8, 244u8, 230u8, 176u8, 149u8, 240u8, 248u8, 238u8,
                    70u8, 86u8, 164u8, 72u8, 37u8, 124u8, 125u8, 218u8, 133u8, 201u8, 194u8, 151u8,
                    153u8, 159u8, 208u8, 34u8, 21u8, 232u8, 200u8, 249u8, 222u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
        }
    }
    pub mod nft {
        use super::*;
        #[derive(Clone)]
        pub struct NftCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> NftCallApi<'api> {
            #[doc = "Cretes a new `NFTCollection`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
            #[doc = "* `asset_id` - optional [`AssetId`] associated to the new collection. `None` will create a new asset."]
            #[doc = "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type."]
            #[doc = "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `CollectionAlredyRegistered` - if the asset_id is already associated to an NFT collection."]
            #[doc = "- `InvalidAssetType` - if the associated asset is not of type NFT."]
            #[doc = "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed."]
            #[doc = "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered."]
            #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(not(feature = "ink"))]
            pub fn create_nft_collection(
                &self,
                asset_id: Option<::polymesh_api_client::AssetId>,
                nft_type: Option<types::polymesh_primitives::asset::NonFungibleType>,
                collection_keys: types::polymesh_primitives::nft::NFTCollectionKeys,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Nft(
                    types::pallet_nft::pallet::NftCall::create_nft_collection {
                        asset_id,
                        nft_type,
                        collection_keys,
                    },
                ))
            }
            #[doc = "Cretes a new `NFTCollection`."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - contains the secondary key of the caller (i.e. who signed the transaction to execute this function)."]
            #[doc = "* `asset_id` - optional [`AssetId`] associated to the new collection. `None` will create a new asset."]
            #[doc = "* `nft_type` - in case the asset hasn't been created yet, one will be created with the given type."]
            #[doc = "* `collection_keys` - all mandatory metadata keys that the tokens in the collection must have."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `CollectionAlredyRegistered` - if the asset_id is already associated to an NFT collection."]
            #[doc = "- `InvalidAssetType` - if the associated asset is not of type NFT."]
            #[doc = "- `MaxNumberOfKeysExceeded` - if the number of metadata keys for the collection is greater than the maximum allowed."]
            #[doc = "- `UnregisteredMetadataKey` - if any of the metadata keys needed for the collection has not been registered."]
            #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[cfg(feature = "ink")]
            pub fn create_nft_collection(
                &self,
                asset_id: Option<::polymesh_api_client::AssetId>,
                nft_type: Option<types::polymesh_primitives::asset::NonFungibleType>,
                collection_keys: types::polymesh_primitives::nft::NFTCollectionKeys,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![49u8, 0u8];
                asset_id.encode_to(&mut buf);
                nft_type.encode_to(&mut buf);
                collection_keys.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Issues an NFT to the caller."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
            #[doc = "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT."]
            #[doc = "- `portfolio_kind` - the portfolio that will receive the minted nft."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
            #[doc = "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection."]
            #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
            #[doc = ""]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn issue_nft(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                nft_metadata_attributes: ::alloc::vec::Vec<
                    types::polymesh_primitives::nft::NFTMetadataAttribute,
                >,
                portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Nft(
                    types::pallet_nft::pallet::NftCall::issue_nft {
                        asset_id,
                        nft_metadata_attributes,
                        portfolio_kind,
                    },
                ))
            }
            #[doc = "Issues an NFT to the caller."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
            #[doc = "* `nft_metadata_attributes` - all mandatory metadata keys and values for the NFT."]
            #[doc = "- `portfolio_kind` - the portfolio that will receive the minted nft."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
            #[doc = "- `InvalidMetadataAttribute` - if the number of attributes is not equal to the number set in the collection or attempting to set a value for a key not definied in the collection."]
            #[doc = "- `DuplicateMetadataKey` - if a duplicate metadata keys has been passed as input."]
            #[doc = ""]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn issue_nft(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                nft_metadata_attributes: ::alloc::vec::Vec<
                    types::polymesh_primitives::nft::NFTMetadataAttribute,
                >,
                portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![49u8, 1u8];
                asset_id.encode_to(&mut buf);
                nft_metadata_attributes.encode_to(&mut buf);
                portfolio_kind.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Redeems the given NFT from the caller's portfolio."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
            #[doc = "* `nft_id` - the id of the NFT to be burned."]
            #[doc = "* `portfolio_kind` - the portfolio that contains the nft."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
            #[doc = "- `NFTNotFound` - if the given NFT does not exist in the portfolio."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn redeem_nft(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                nft_id: types::polymesh_primitives::nft::NFTId,
                portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
                number_of_keys: Option<u8>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Nft(
                    types::pallet_nft::pallet::NftCall::redeem_nft {
                        asset_id,
                        nft_id,
                        portfolio_kind,
                        number_of_keys,
                    },
                ))
            }
            #[doc = "Redeems the given NFT from the caller's portfolio."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "* `asset_id` - the [`AssetId`] of the NFT collection."]
            #[doc = "* `nft_id` - the id of the NFT to be burned."]
            #[doc = "* `portfolio_kind` - the portfolio that contains the nft."]
            #[doc = ""]
            #[doc = "## Errors"]
            #[doc = "- `CollectionNotFound` - if the collection associated to the given asset_id has not been created."]
            #[doc = "- `NFTNotFound` - if the given NFT does not exist in the portfolio."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn redeem_nft(
                &self,
                asset_id: ::polymesh_api_client::AssetId,
                nft_id: types::polymesh_primitives::nft::NFTId,
                portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
                number_of_keys: Option<u8>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![49u8, 2u8];
                asset_id.encode_to(&mut buf);
                nft_id.encode_to(&mut buf);
                portfolio_kind.encode_to(&mut buf);
                number_of_keys.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Forces the transfer of NFTs from a given portfolio to the caller's portfolio."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "* `nft_id` - the [`NFTId`] of the NFT to be transferred."]
            #[doc = "* `source_portfolio` - the [`PortfolioId`] that currently holds the NFT."]
            #[doc = "* `callers_portfolio_kind` - the [`PortfolioKind`] of the caller's portfolio."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[cfg(not(feature = "ink"))]
            pub fn controller_transfer(
                &self,
                nfts: types::polymesh_primitives::nft::NFTs,
                source_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
                callers_portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Nft(
                    types::pallet_nft::pallet::NftCall::controller_transfer {
                        nfts,
                        source_portfolio,
                        callers_portfolio_kind,
                    },
                ))
            }
            #[doc = "Forces the transfer of NFTs from a given portfolio to the caller's portfolio."]
            #[doc = ""]
            #[doc = "# Arguments"]
            #[doc = "* `origin` - is a signer that has permissions to act as an agent of `asset_id`."]
            #[doc = "* `nft_id` - the [`NFTId`] of the NFT to be transferred."]
            #[doc = "* `source_portfolio` - the [`PortfolioId`] that currently holds the NFT."]
            #[doc = "* `callers_portfolio_kind` - the [`PortfolioKind`] of the caller's portfolio."]
            #[doc = ""]
            #[doc = "# Permissions"]
            #[doc = "* Asset"]
            #[doc = "* Portfolio"]
            #[cfg(feature = "ink")]
            pub fn controller_transfer(
                &self,
                nfts: types::polymesh_primitives::nft::NFTs,
                source_portfolio: types::polymesh_primitives::identity_id::PortfolioId,
                callers_portfolio_kind: types::polymesh_primitives::identity_id::PortfolioKind,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![49u8, 3u8];
                nfts.encode_to(&mut buf);
                source_portfolio.encode_to(&mut buf);
                callers_portfolio_kind.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for NftCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct NftQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> NftQueryApi<'api> {
            #[doc = " The total number of NFTs per identity."]
            #[cfg(not(feature = "ink"))]
            pub async fn number_of_nf_ts(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 170u8, 210u8, 252u8, 218u8, 7u8, 81u8, 234u8, 12u8,
                    131u8, 54u8, 33u8, 16u8, 193u8, 164u8, 16u8, 164u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                buf.extend(key_1.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The total number of NFTs per identity."]
            #[cfg(feature = "ink")]
            pub fn number_of_nf_ts(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: ::polymesh_api_client::IdentityId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 170u8, 210u8, 252u8, 218u8, 7u8, 81u8, 234u8, 12u8,
                    131u8, 54u8, 33u8, 16u8, 193u8, 164u8, 16u8, 164u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                buf.extend(key_1.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The collection id corresponding to each asset."]
            #[cfg(not(feature = "ink"))]
            pub async fn collection_asset(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::nft::NFTCollectionId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 42u8, 68u8, 186u8, 69u8, 7u8, 24u8, 71u8, 138u8,
                    166u8, 31u8, 83u8, 159u8, 177u8, 242u8, 13u8, 1u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::nft::NFTCollectionId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " The collection id corresponding to each asset."]
            #[cfg(feature = "ink")]
            pub fn collection_asset(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::nft::NFTCollectionId>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 42u8, 68u8, 186u8, 69u8, 7u8, 24u8, 71u8, 138u8,
                    166u8, 31u8, 83u8, 159u8, 177u8, 242u8, 13u8, 1u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <types::polymesh_primitives::nft::NFTCollectionId>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " All collection details for a given collection id."]
            #[cfg(not(feature = "ink"))]
            pub async fn collection(
                &self,
                key_0: types::polymesh_primitives::nft::NFTCollectionId,
            ) -> ::polymesh_api_client::error::Result<types::polymesh_primitives::nft::NFTCollection>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 55u8, 92u8, 77u8, 37u8, 190u8, 245u8, 30u8, 47u8,
                    50u8, 254u8, 233u8, 252u8, 85u8, 123u8, 24u8, 32u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                    ];
                    <types::polymesh_primitives::nft::NFTCollection>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " All collection details for a given collection id."]
            #[cfg(feature = "ink")]
            pub fn collection(
                &self,
                key_0: types::polymesh_primitives::nft::NFTCollectionId,
            ) -> ::polymesh_api_ink::error::Result<types::polymesh_primitives::nft::NFTCollection>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 55u8, 92u8, 77u8, 37u8, 190u8, 245u8, 30u8, 47u8,
                    50u8, 254u8, 233u8, 252u8, 85u8, 123u8, 24u8, 32u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                    ];
                    <types::polymesh_primitives::nft::NFTCollection>::decode(&mut &DEFAULT[..])
                        .unwrap()
                }))
            }
            #[doc = " All mandatory metadata keys for a given collection."]
            #[cfg(not(feature = "ink"))]
            pub async fn collection_keys(
                &self,
                key_0: types::polymesh_primitives::nft::NFTCollectionId,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 240u8, 0u8, 218u8, 102u8, 211u8, 19u8, 174u8, 223u8,
                    42u8, 70u8, 29u8, 80u8, 78u8, 220u8, 122u8, 141u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::collections::BTreeSet<
                        types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " All mandatory metadata keys for a given collection."]
            #[cfg(feature = "ink")]
            pub fn collection_keys(
                &self,
                key_0: types::polymesh_primitives::nft::NFTCollectionId,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 240u8, 0u8, 218u8, 102u8, 211u8, 19u8, 174u8, 223u8,
                    42u8, 70u8, 29u8, 80u8, 78u8, 220u8, 122u8, 141u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::collections::BTreeSet<
                        types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                    >>::decode(&mut &DEFAULT[..])
                    .unwrap()
                }))
            }
            #[doc = " The metadata value of an nft given its collection id, token id and metadata key."]
            #[cfg(not(feature = "ink"))]
            pub async fn metadata_value(
                &self,
                key_0: (
                    types::polymesh_primitives::nft::NFTCollectionId,
                    types::polymesh_primitives::nft::NFTId,
                ),
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
            ) -> ::polymesh_api_client::error::Result<
                types::polymesh_primitives::asset_metadata::AssetMetadataValue,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 60u8, 250u8, 177u8, 34u8, 185u8, 246u8, 58u8, 62u8,
                    106u8, 129u8, 169u8, 121u8, 18u8, 218u8, 95u8, 196u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::asset_metadata::AssetMetadataValue>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The metadata value of an nft given its collection id, token id and metadata key."]
            #[cfg(feature = "ink")]
            pub fn metadata_value(
                &self,
                key_0: (
                    types::polymesh_primitives::nft::NFTCollectionId,
                    types::polymesh_primitives::nft::NFTId,
                ),
                key_1: types::polymesh_primitives::asset_metadata::AssetMetadataKey,
            ) -> ::polymesh_api_ink::error::Result<
                types::polymesh_primitives::asset_metadata::AssetMetadataValue,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 60u8, 250u8, 177u8, 34u8, 185u8, 246u8, 58u8, 62u8,
                    106u8, 129u8, 169u8, 121u8, 18u8, 218u8, 95u8, 196u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::polymesh_primitives::asset_metadata::AssetMetadataValue>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The total number of NFTs in a collection."]
            #[cfg(not(feature = "ink"))]
            pub async fn nf_ts_in_collection(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 144u8, 90u8, 125u8, 255u8, 15u8, 215u8, 82u8, 78u8,
                    160u8, 192u8, 231u8, 54u8, 218u8, 113u8, 117u8, 197u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The total number of NFTs in a collection."]
            #[cfg(feature = "ink")]
            pub fn nf_ts_in_collection(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_ink::error::Result<u64> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 144u8, 90u8, 125u8, 255u8, 15u8, 215u8, 82u8, 78u8,
                    160u8, 192u8, 231u8, 54u8, 218u8, 113u8, 117u8, 197u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Tracks the owner of an NFT"]
            #[cfg(not(feature = "ink"))]
            pub async fn nft_owner(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::nft::NFTId,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::identity_id::PortfolioId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 91u8, 94u8, 244u8, 236u8, 188u8, 25u8, 19u8, 255u8,
                    125u8, 167u8, 228u8, 155u8, 11u8, 54u8, 138u8, 234u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Tracks the owner of an NFT"]
            #[cfg(feature = "ink")]
            pub fn nft_owner(
                &self,
                key_0: ::polymesh_api_client::AssetId,
                key_1: types::polymesh_primitives::nft::NFTId,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::identity_id::PortfolioId>,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 91u8, 94u8, 244u8, 236u8, 188u8, 25u8, 19u8, 255u8,
                    125u8, 167u8, 228u8, 155u8, 11u8, 54u8, 138u8, 234u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = key_1.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The last `NFTId` used for an NFT."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_nft_id(
                &self,
                key_0: types::polymesh_primitives::nft::NFTCollectionId,
            ) -> ::polymesh_api_client::error::Result<Option<types::polymesh_primitives::nft::NFTId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 108u8, 101u8, 2u8, 244u8, 210u8, 82u8, 242u8, 26u8,
                    42u8, 247u8, 205u8, 136u8, 217u8, 79u8, 37u8, 195u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The last `NFTId` used for an NFT."]
            #[cfg(feature = "ink")]
            pub fn current_nft_id(
                &self,
                key_0: types::polymesh_primitives::nft::NFTCollectionId,
            ) -> ::polymesh_api_ink::error::Result<Option<types::polymesh_primitives::nft::NFTId>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 108u8, 101u8, 2u8, 244u8, 210u8, 82u8, 242u8, 26u8,
                    42u8, 247u8, 205u8, 136u8, 217u8, 79u8, 37u8, 195u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The last `NFTCollectionId` used for a collection."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_collection_id(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::polymesh_primitives::nft::NFTCollectionId>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 165u8, 141u8, 144u8, 50u8, 190u8, 120u8, 13u8, 0u8,
                    103u8, 139u8, 64u8, 60u8, 240u8, 205u8, 212u8, 75u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The last `NFTCollectionId` used for a collection."]
            #[cfg(feature = "ink")]
            pub fn current_collection_id(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::polymesh_primitives::nft::NFTCollectionId>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 165u8, 141u8, 144u8, 50u8, 190u8, 120u8, 13u8, 0u8,
                    103u8, 139u8, 64u8, 60u8, 240u8, 205u8, 212u8, 75u8,
                ])?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct NftPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> NftPagedQueryApi<'api> {
            #[doc = " The total number of NFTs per identity."]
            pub fn number_of_nf_ts(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::IdentityId, u64>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 170u8, 210u8, 252u8, 218u8, 7u8, 81u8, 234u8, 12u8,
                    131u8, 54u8, 33u8, 16u8, 193u8, 164u8, 16u8, 164u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
            #[doc = " The collection id corresponding to each asset."]
            pub fn collection_asset(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                ::polymesh_api_client::AssetId,
                types::polymesh_primitives::nft::NFTCollectionId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 42u8, 68u8, 186u8, 69u8, 7u8, 24u8, 71u8, 138u8,
                    166u8, 31u8, 83u8, 159u8, 177u8, 242u8, 13u8, 1u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " All collection details for a given collection id."]
            pub fn collection(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::nft::NFTCollectionId,
                types::polymesh_primitives::nft::NFTCollection,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 55u8, 92u8, 77u8, 37u8, 190u8, 245u8, 30u8, 47u8,
                    50u8, 254u8, 233u8, 252u8, 85u8, 123u8, 24u8, 32u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " All mandatory metadata keys for a given collection."]
            pub fn collection_keys(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::nft::NFTCollectionId,
                ::alloc::collections::BTreeSet<
                    types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 240u8, 0u8, 218u8, 102u8, 211u8, 19u8, 174u8, 223u8,
                    42u8, 70u8, 29u8, 80u8, 78u8, 220u8, 122u8, 141u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The metadata value of an nft given its collection id, token id and metadata key."]
            pub fn metadata_value(
                &self,
                key_0: (
                    types::polymesh_primitives::nft::NFTCollectionId,
                    types::polymesh_primitives::nft::NFTId,
                ),
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::asset_metadata::AssetMetadataKey,
                types::polymesh_primitives::asset_metadata::AssetMetadataValue,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 60u8, 250u8, 177u8, 34u8, 185u8, 246u8, 58u8, 62u8,
                    106u8, 129u8, 169u8, 121u8, 18u8, 218u8, 95u8, 196u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The total number of NFTs in a collection."]
            pub fn nf_ts_in_collection(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<::polymesh_api_client::AssetId, u64>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 144u8, 90u8, 125u8, 255u8, 15u8, 215u8, 82u8, 78u8,
                    160u8, 192u8, 231u8, 54u8, 218u8, 113u8, 117u8, 197u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " Tracks the owner of an NFT"]
            pub fn nft_owner(
                &self,
                key_0: ::polymesh_api_client::AssetId,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::nft::NFTId,
                types::polymesh_primitives::identity_id::PortfolioId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 91u8, 94u8, 244u8, 236u8, 188u8, 25u8, 19u8, 255u8,
                    125u8, 167u8, 228u8, 155u8, 11u8, 54u8, 138u8, 234u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::blake2_128(&key));
                buf.extend(key.into_iter());
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
            #[doc = " The last `NFTId` used for an NFT."]
            pub fn current_nft_id(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                types::polymesh_primitives::nft::NFTCollectionId,
                types::polymesh_primitives::nft::NFTId,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    244u8, 63u8, 251u8, 230u8, 30u8, 244u8, 104u8, 116u8, 157u8, 54u8, 23u8, 172u8,
                    26u8, 99u8, 196u8, 183u8, 108u8, 101u8, 2u8, 244u8, 210u8, 82u8, 242u8, 26u8,
                    42u8, 247u8, 205u8, 136u8, 217u8, 79u8, 37u8, 195u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(
                    &self.api.client,
                    prefix,
                    Some(16),
                    self.at,
                )
            }
        }
    }
    pub mod election_provider_multi_phase {
        use super::*;
        #[derive(Clone)]
        pub struct ElectionProviderMultiPhaseCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> ElectionProviderMultiPhaseCallApi<'api> {
            #[doc = "Submit a solution for the unsigned phase."]
            #[doc = ""]
            #[doc = "The dispatch origin fo this call must be __none__."]
            #[doc = ""]
            #[doc = "This submission is checked on the fly. Moreover, this unsigned solution is only"]
            #[doc = "validated when submitted to the pool from the **local** node. Effectively, this means"]
            #[doc = "that only active validators can submit this transaction when authoring a block (similar"]
            #[doc = "to an inherent)."]
            #[doc = ""]
            #[doc = "To prevent any incorrect solution (and thus wasted time/weight), this transaction will"]
            #[doc = "panic if the solution submitted by the validator is invalid in any way, effectively"]
            #[doc = "putting their authoring reward at risk."]
            #[doc = ""]
            #[doc = "No deposit or reward is associated with this submission."]
            #[cfg(not(feature = "ink"))]
            pub fn submit_unsigned(
                &self,
                raw_solution: types::pallet_election_provider_multi_phase::RawSolution<
                    types::polymesh_runtime_common::NposSolution16,
                >,
                witness: types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ElectionProviderMultiPhase (types :: pallet_election_provider_multi_phase :: pallet :: ElectionProviderMultiPhaseCall :: submit_unsigned { raw_solution : :: alloc :: boxed :: Box :: new (raw_solution) , witness , }))
            }
            #[doc = "Submit a solution for the unsigned phase."]
            #[doc = ""]
            #[doc = "The dispatch origin fo this call must be __none__."]
            #[doc = ""]
            #[doc = "This submission is checked on the fly. Moreover, this unsigned solution is only"]
            #[doc = "validated when submitted to the pool from the **local** node. Effectively, this means"]
            #[doc = "that only active validators can submit this transaction when authoring a block (similar"]
            #[doc = "to an inherent)."]
            #[doc = ""]
            #[doc = "To prevent any incorrect solution (and thus wasted time/weight), this transaction will"]
            #[doc = "panic if the solution submitted by the validator is invalid in any way, effectively"]
            #[doc = "putting their authoring reward at risk."]
            #[doc = ""]
            #[doc = "No deposit or reward is associated with this submission."]
            #[cfg(feature = "ink")]
            pub fn submit_unsigned(
                &self,
                raw_solution: types::pallet_election_provider_multi_phase::RawSolution<
                    types::polymesh_runtime_common::NposSolution16,
                >,
                witness: types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![50u8, 0u8];
                raw_solution.encode_to(&mut buf);
                witness.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set a new value for `MinimumUntrustedScore`."]
            #[doc = ""]
            #[doc = "Dispatch origin must be aligned with `T::ForceOrigin`."]
            #[doc = ""]
            #[doc = "This check can be turned off by setting the value to `None`."]
            #[cfg(not(feature = "ink"))]
            pub fn set_minimum_untrusted_score(
                &self,
                maybe_next_score: Option<types::sp_npos_elections::ElectionScore>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ElectionProviderMultiPhase (types :: pallet_election_provider_multi_phase :: pallet :: ElectionProviderMultiPhaseCall :: set_minimum_untrusted_score { maybe_next_score , }))
            }
            #[doc = "Set a new value for `MinimumUntrustedScore`."]
            #[doc = ""]
            #[doc = "Dispatch origin must be aligned with `T::ForceOrigin`."]
            #[doc = ""]
            #[doc = "This check can be turned off by setting the value to `None`."]
            #[cfg(feature = "ink")]
            pub fn set_minimum_untrusted_score(
                &self,
                maybe_next_score: Option<types::sp_npos_elections::ElectionScore>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![50u8, 1u8];
                maybe_next_score.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Set a solution in the queue, to be handed out to the client of this pallet in the next"]
            #[doc = "call to `ElectionProvider::elect`."]
            #[doc = ""]
            #[doc = "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`."]
            #[doc = ""]
            #[doc = "The solution is not checked for any feasibility and is assumed to be trustworthy, as any"]
            #[doc = "feasibility check itself can in principle cause the election process to fail (due to"]
            #[doc = "memory/weight constrains)."]
            #[cfg(not(feature = "ink"))]
            pub fn set_emergency_election_result(
                &self,
                supports: ::alloc::vec::Vec<(
                    ::polymesh_api_client::AccountId,
                    types::sp_npos_elections::Support<::polymesh_api_client::AccountId>,
                )>,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ElectionProviderMultiPhase (types :: pallet_election_provider_multi_phase :: pallet :: ElectionProviderMultiPhaseCall :: set_emergency_election_result { supports , }))
            }
            #[doc = "Set a solution in the queue, to be handed out to the client of this pallet in the next"]
            #[doc = "call to `ElectionProvider::elect`."]
            #[doc = ""]
            #[doc = "This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`."]
            #[doc = ""]
            #[doc = "The solution is not checked for any feasibility and is assumed to be trustworthy, as any"]
            #[doc = "feasibility check itself can in principle cause the election process to fail (due to"]
            #[doc = "memory/weight constrains)."]
            #[cfg(feature = "ink")]
            pub fn set_emergency_election_result(
                &self,
                supports: ::alloc::vec::Vec<(
                    ::polymesh_api_client::AccountId,
                    types::sp_npos_elections::Support<::polymesh_api_client::AccountId>,
                )>,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![50u8, 2u8];
                supports.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Submit a solution for the signed phase."]
            #[doc = ""]
            #[doc = "The dispatch origin fo this call must be __signed__."]
            #[doc = ""]
            #[doc = "The solution is potentially queued, based on the claimed score and processed at the end"]
            #[doc = "of the signed phase."]
            #[doc = ""]
            #[doc = "A deposit is reserved and recorded for the solution. Based on the outcome, the solution"]
            #[doc = "might be rewarded, slashed, or get all or a part of the deposit back."]
            #[cfg(not(feature = "ink"))]
            pub fn submit(
                &self,
                raw_solution: types::pallet_election_provider_multi_phase::RawSolution<
                    types::polymesh_runtime_common::NposSolution16,
                >,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ElectionProviderMultiPhase (types :: pallet_election_provider_multi_phase :: pallet :: ElectionProviderMultiPhaseCall :: submit { raw_solution : :: alloc :: boxed :: Box :: new (raw_solution) , }))
            }
            #[doc = "Submit a solution for the signed phase."]
            #[doc = ""]
            #[doc = "The dispatch origin fo this call must be __signed__."]
            #[doc = ""]
            #[doc = "The solution is potentially queued, based on the claimed score and processed at the end"]
            #[doc = "of the signed phase."]
            #[doc = ""]
            #[doc = "A deposit is reserved and recorded for the solution. Based on the outcome, the solution"]
            #[doc = "might be rewarded, slashed, or get all or a part of the deposit back."]
            #[cfg(feature = "ink")]
            pub fn submit(
                &self,
                raw_solution: types::pallet_election_provider_multi_phase::RawSolution<
                    types::polymesh_runtime_common::NposSolution16,
                >,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![50u8, 3u8];
                raw_solution.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Trigger the governance fallback."]
            #[doc = ""]
            #[doc = "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to"]
            #[doc = "calling [`Call::set_emergency_election_result`]."]
            #[cfg(not(feature = "ink"))]
            pub fn governance_fallback(
                &self,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: ElectionProviderMultiPhase (types :: pallet_election_provider_multi_phase :: pallet :: ElectionProviderMultiPhaseCall :: governance_fallback))
            }
            #[doc = "Trigger the governance fallback."]
            #[doc = ""]
            #[doc = "This can only be called when [`Phase::Emergency`] is enabled, as an alternative to"]
            #[doc = "calling [`Call::set_emergency_election_result`]."]
            #[cfg(feature = "ink")]
            pub fn governance_fallback(&self) -> super::super::WrappedCall {
                self.api.wrap_call(::alloc::vec![50u8, 4u8])
            }
        }
        impl<'api> From<&'api super::super::Api> for ElectionProviderMultiPhaseCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct ElectionProviderMultiPhaseQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> ElectionProviderMultiPhaseQueryApi<'api> {
            #[doc = " Internal counter for the number of rounds."]
            #[doc = ""]
            #[doc = " This is useful for de-duplication of transactions submitted to the pool, and general"]
            #[doc = " diagnostics of the pallet."]
            #[doc = ""]
            #[doc = " This is merely incremented once per every time that an upstream `elect` is called."]
            #[cfg(not(feature = "ink"))]
            pub async fn round(&self) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 19u8, 121u8, 46u8, 120u8, 81u8, 104u8, 247u8,
                    37u8, 182u8, 14u8, 41u8, 105u8, 199u8, 252u8, 37u8, 82u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Internal counter for the number of rounds."]
            #[doc = ""]
            #[doc = " This is useful for de-duplication of transactions submitted to the pool, and general"]
            #[doc = " diagnostics of the pallet."]
            #[doc = ""]
            #[doc = " This is merely incremented once per every time that an upstream `elect` is called."]
            #[cfg(feature = "ink")]
            pub fn round(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 19u8, 121u8, 46u8, 120u8, 81u8, 104u8, 247u8,
                    37u8, 182u8, 14u8, 41u8, 105u8, 199u8, 252u8, 37u8, 82u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[1u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Current phase."]
            #[cfg(not(feature = "ink"))]
            pub async fn current_phase(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::pallet_election_provider_multi_phase::Phase<u32>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 217u8, 118u8, 68u8, 1u8, 148u8, 29u8, 247u8,
                    247u8, 7u8, 164u8, 123u8, 167u8, 219u8, 100u8, 166u8, 234u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_election_provider_multi_phase::Phase<u32>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Current phase."]
            #[cfg(feature = "ink")]
            pub fn current_phase(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                types::pallet_election_provider_multi_phase::Phase<u32>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 217u8, 118u8, 68u8, 1u8, 148u8, 29u8, 247u8,
                    247u8, 7u8, 164u8, 123u8, 167u8, 219u8, 100u8, 166u8, 234u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <types::pallet_election_provider_multi_phase::Phase<u32>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Current best solution, signed or unsigned, queued to be returned upon `elect`."]
            #[doc = ""]
            #[doc = " Always sorted by score."]
            #[cfg(not(feature = "ink"))]
            pub async fn queued_solution(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_election_provider_multi_phase::ReadySolution>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 72u8, 12u8, 161u8, 163u8, 76u8, 172u8, 219u8,
                    18u8, 175u8, 252u8, 103u8, 236u8, 195u8, 160u8, 128u8, 4u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Current best solution, signed or unsigned, queued to be returned upon `elect`."]
            #[doc = ""]
            #[doc = " Always sorted by score."]
            #[cfg(feature = "ink")]
            pub fn queued_solution(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_election_provider_multi_phase::ReadySolution>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 72u8, 12u8, 161u8, 163u8, 76u8, 172u8, 219u8,
                    18u8, 175u8, 252u8, 103u8, 236u8, 195u8, 160u8, 128u8, 4u8,
                ])?;
                Ok(value)
            }
            #[doc = " Snapshot data of the round."]
            #[doc = ""]
            #[doc = " This is created at the beginning of the signed phase and cleared upon calling `elect`."]
            #[doc = " Note: This storage type must only be mutated through [`SnapshotWrapper`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn snapshot(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::pallet_election_provider_multi_phase::RoundSnapshot<
                        ::polymesh_api_client::AccountId,
                        (
                            ::polymesh_api_client::AccountId,
                            u64,
                            ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                        ),
                    >,
                >,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 150u8, 211u8, 143u8, 212u8, 91u8, 192u8,
                    56u8, 250u8, 169u8, 88u8, 111u8, 169u8, 58u8, 160u8, 62u8, 247u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Snapshot data of the round."]
            #[doc = ""]
            #[doc = " This is created at the beginning of the signed phase and cleared upon calling `elect`."]
            #[doc = " Note: This storage type must only be mutated through [`SnapshotWrapper`]."]
            #[cfg(feature = "ink")]
            pub fn snapshot(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::pallet_election_provider_multi_phase::RoundSnapshot<
                        ::polymesh_api_client::AccountId,
                        (
                            ::polymesh_api_client::AccountId,
                            u64,
                            ::alloc::vec::Vec<::polymesh_api_client::AccountId>,
                        ),
                    >,
                >,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 150u8, 211u8, 143u8, 212u8, 91u8, 192u8,
                    56u8, 250u8, 169u8, 88u8, 111u8, 169u8, 58u8, 160u8, 62u8, 247u8,
                ])?;
                Ok(value)
            }
            #[doc = " Desired number of targets to elect for this round."]
            #[doc = ""]
            #[doc = " Only exists when [`Snapshot`] is present."]
            #[doc = " Note: This storage type must only be mutated through [`SnapshotWrapper`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn desired_targets(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<u32>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 114u8, 11u8, 112u8, 253u8, 71u8, 251u8,
                    237u8, 135u8, 90u8, 58u8, 45u8, 173u8, 67u8, 120u8, 236u8, 77u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Desired number of targets to elect for this round."]
            #[doc = ""]
            #[doc = " Only exists when [`Snapshot`] is present."]
            #[doc = " Note: This storage type must only be mutated through [`SnapshotWrapper`]."]
            #[cfg(feature = "ink")]
            pub fn desired_targets(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 114u8, 11u8, 112u8, 253u8, 71u8, 251u8,
                    237u8, 135u8, 90u8, 58u8, 45u8, 173u8, 67u8, 120u8, 236u8, 77u8,
                ])?;
                Ok(value)
            }
            #[doc = " The metadata of the [`RoundSnapshot`]"]
            #[doc = ""]
            #[doc = " Only exists when [`Snapshot`] is present."]
            #[doc = " Note: This storage type must only be mutated through [`SnapshotWrapper`]."]
            #[cfg(not(feature = "ink"))]
            pub async fn snapshot_metadata(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                Option<types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 42u8, 62u8, 95u8, 29u8, 70u8, 27u8, 247u8,
                    99u8, 167u8, 96u8, 19u8, 224u8, 98u8, 180u8, 108u8, 14u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The metadata of the [`RoundSnapshot`]"]
            #[doc = ""]
            #[doc = " Only exists when [`Snapshot`] is present."]
            #[doc = " Note: This storage type must only be mutated through [`SnapshotWrapper`]."]
            #[cfg(feature = "ink")]
            pub fn snapshot_metadata(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                Option<types::pallet_election_provider_multi_phase::SolutionOrSnapshotSize>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 42u8, 62u8, 95u8, 29u8, 70u8, 27u8, 247u8,
                    99u8, 167u8, 96u8, 19u8, 224u8, 98u8, 180u8, 108u8, 14u8,
                ])?;
                Ok(value)
            }
            #[doc = " The next index to be assigned to an incoming signed submission."]
            #[doc = ""]
            #[doc = " Every accepted submission is assigned a unique index; that index is bound to that particular"]
            #[doc = " submission for the duration of the election. On election finalization, the next index is"]
            #[doc = " reset to 0."]
            #[doc = ""]
            #[doc = " We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its"]
            #[doc = " capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,"]
            #[doc = " because iteration is slow. Instead, we store the value here."]
            #[cfg(not(feature = "ink"))]
            pub async fn signed_submission_next_index(
                &self,
            ) -> ::polymesh_api_client::error::Result<u32> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 20u8, 206u8, 58u8, 102u8, 6u8, 50u8, 80u8,
                    247u8, 30u8, 10u8, 17u8, 165u8, 23u8, 234u8, 64u8, 98u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The next index to be assigned to an incoming signed submission."]
            #[doc = ""]
            #[doc = " Every accepted submission is assigned a unique index; that index is bound to that particular"]
            #[doc = " submission for the duration of the election. On election finalization, the next index is"]
            #[doc = " reset to 0."]
            #[doc = ""]
            #[doc = " We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its"]
            #[doc = " capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,"]
            #[doc = " because iteration is slow. Instead, we store the value here."]
            #[cfg(feature = "ink")]
            pub fn signed_submission_next_index(&self) -> ::polymesh_api_ink::error::Result<u32> {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 20u8, 206u8, 58u8, 102u8, 6u8, 50u8, 80u8,
                    247u8, 30u8, 10u8, 17u8, 165u8, 23u8, 234u8, 64u8, 98u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8];
                    <u32>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " A sorted, bounded vector of `(score, block_number, index)`, where each `index` points to a"]
            #[doc = " value in `SignedSubmissions`."]
            #[doc = ""]
            #[doc = " We never need to process more than a single signed submission at a time. Signed submissions"]
            #[doc = " can be quite large, so we're willing to pay the cost of multiple database accesses to access"]
            #[doc = " them one at a time instead of reading and decoding all of them at once."]
            #[cfg(not(feature = "ink"))]
            pub async fn signed_submission_indices(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<(types::sp_npos_elections::ElectionScore, u32, u32)>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 11u8, 177u8, 211u8, 90u8, 139u8, 77u8, 49u8,
                    172u8, 236u8, 47u8, 204u8, 188u8, 240u8, 23u8, 47u8, 196u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < :: alloc :: vec :: Vec < (types :: sp_npos_elections :: ElectionScore , u32 , u32) > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " A sorted, bounded vector of `(score, block_number, index)`, where each `index` points to a"]
            #[doc = " value in `SignedSubmissions`."]
            #[doc = ""]
            #[doc = " We never need to process more than a single signed submission at a time. Signed submissions"]
            #[doc = " can be quite large, so we're willing to pay the cost of multiple database accesses to access"]
            #[doc = " them one at a time instead of reading and decoding all of them at once."]
            #[cfg(feature = "ink")]
            pub fn signed_submission_indices(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<(types::sp_npos_elections::ElectionScore, u32, u32)>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 11u8, 177u8, 211u8, 90u8, 139u8, 77u8, 49u8,
                    172u8, 236u8, 47u8, 204u8, 188u8, 240u8, 23u8, 47u8, 196u8,
                ])?;
                Ok (value . unwrap_or_else (|| { use :: codec :: Decode ; const DEFAULT : & 'static [u8] = & [0u8 ,] ; < :: alloc :: vec :: Vec < (types :: sp_npos_elections :: ElectionScore , u32 , u32) > > :: decode (& mut & DEFAULT [..]) . unwrap () }))
            }
            #[doc = " Unchecked, signed solutions."]
            #[doc = ""]
            #[doc = " Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while"]
            #[doc = " allowing us to keep only a single one in memory at a time."]
            #[doc = ""]
            #[doc = " Twox note: the key of the map is an auto-incrementing index which users cannot inspect or"]
            #[doc = " affect; we shouldn't need a cryptographically secure hasher."]
            #[cfg(not(feature = "ink"))]
            pub async fn signed_submissions_map(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_client::error::Result<
                Option<
                    types::pallet_election_provider_multi_phase::signed::SignedSubmission<
                        ::polymesh_api_client::AccountId,
                        u128,
                        types::polymesh_runtime_common::NposSolution16,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 179u8, 209u8, 198u8, 67u8, 192u8, 212u8,
                    94u8, 43u8, 185u8, 38u8, 154u8, 200u8, 108u8, 29u8, 205u8, 160u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Unchecked, signed solutions."]
            #[doc = ""]
            #[doc = " Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while"]
            #[doc = " allowing us to keep only a single one in memory at a time."]
            #[doc = ""]
            #[doc = " Twox note: the key of the map is an auto-incrementing index which users cannot inspect or"]
            #[doc = " affect; we shouldn't need a cryptographically secure hasher."]
            #[cfg(feature = "ink")]
            pub fn signed_submissions_map(
                &self,
                key_0: u32,
            ) -> ::polymesh_api_ink::error::Result<
                Option<
                    types::pallet_election_provider_multi_phase::signed::SignedSubmission<
                        ::polymesh_api_client::AccountId,
                        u128,
                        types::polymesh_runtime_common::NposSolution16,
                    >,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 179u8, 209u8, 198u8, 67u8, 192u8, 212u8,
                    94u8, 43u8, 185u8, 38u8, 154u8, 200u8, 108u8, 29u8, 205u8, 160u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " The minimum score that each 'untrusted' solution must attain in order to be considered"]
            #[doc = " feasible."]
            #[doc = ""]
            #[doc = " Can be set via `set_minimum_untrusted_score`."]
            #[cfg(not(feature = "ink"))]
            pub async fn minimum_untrusted_score(
                &self,
            ) -> ::polymesh_api_client::error::Result<Option<types::sp_npos_elections::ElectionScore>>
            {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 109u8, 139u8, 189u8, 163u8, 187u8, 186u8,
                    212u8, 108u8, 197u8, 125u8, 67u8, 130u8, 93u8, 208u8, 64u8, 197u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " The minimum score that each 'untrusted' solution must attain in order to be considered"]
            #[doc = " feasible."]
            #[doc = ""]
            #[doc = " Can be set via `set_minimum_untrusted_score`."]
            #[cfg(feature = "ink")]
            pub fn minimum_untrusted_score(
                &self,
            ) -> ::polymesh_api_ink::error::Result<Option<types::sp_npos_elections::ElectionScore>>
            {
                let value = self.api.read_storage(::alloc::vec![
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 109u8, 139u8, 189u8, 163u8, 187u8, 186u8,
                    212u8, 108u8, 197u8, 125u8, 67u8, 130u8, 93u8, 208u8, 64u8, 197u8,
                ])?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct ElectionProviderMultiPhasePagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> ElectionProviderMultiPhasePagedQueryApi<'api> {
            #[doc = " Unchecked, signed solutions."]
            #[doc = ""]
            #[doc = " Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while"]
            #[doc = " allowing us to keep only a single one in memory at a time."]
            #[doc = ""]
            #[doc = " Twox note: the key of the map is an auto-incrementing index which users cannot inspect or"]
            #[doc = " affect; we shouldn't need a cryptographically secure hasher."]
            pub fn signed_submissions_map(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<
                u32,
                types::pallet_election_provider_multi_phase::signed::SignedSubmission<
                    ::polymesh_api_client::AccountId,
                    u128,
                    types::polymesh_runtime_common::NposSolution16,
                >,
            > {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    237u8, 232u8, 228u8, 253u8, 195u8, 200u8, 181u8, 86u8, 240u8, 206u8, 47u8,
                    119u8, 252u8, 37u8, 117u8, 227u8, 179u8, 209u8, 198u8, 67u8, 192u8, 212u8,
                    94u8, 43u8, 185u8, 38u8, 154u8, 200u8, 108u8, 29u8, 205u8, 160u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod polymesh_transaction_payment {
        use super::*;
        #[derive(Clone)]
        pub struct PolymeshTransactionPaymentCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> PolymeshTransactionPaymentCallApi<'api> {
            #[cfg(not(feature = "ink"))]
            pub fn set_disable_fees(
                &self,
                value: bool,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self . api . wrap_call (runtime :: RuntimeCall :: PolymeshTransactionPayment (types :: polymesh_transaction_payment :: pallet :: PolymeshTransactionPaymentCall :: set_disable_fees { value , }))
            }
            #[cfg(feature = "ink")]
            pub fn set_disable_fees(&self, value: bool) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![51u8, 0u8];
                value.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for PolymeshTransactionPaymentCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct PolymeshTransactionPaymentQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> PolymeshTransactionPaymentQueryApi<'api> {}
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct PolymeshTransactionPaymentPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> PolymeshTransactionPaymentPagedQueryApi<'api> {}
    }
    pub mod beefy {
        use super::*;
        #[derive(Clone)]
        pub struct BeefyCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> BeefyCallApi<'api> {
            #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
            #[doc = "equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence"]
            #[doc = "will be reported."]
            #[cfg(not(feature = "ink"))]
            pub fn report_double_voting(
                &self,
                equivocation_proof: types::sp_consensus_beefy::DoubleVotingProof<
                    u32,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                    types::sp_consensus_beefy::ecdsa_crypto::Signature,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Beefy(
                    types::pallet_beefy::pallet::BeefyCall::report_double_voting {
                        equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
                        key_owner_proof,
                    },
                ))
            }
            #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
            #[doc = "equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence"]
            #[doc = "will be reported."]
            #[cfg(feature = "ink")]
            pub fn report_double_voting(
                &self,
                equivocation_proof: types::sp_consensus_beefy::DoubleVotingProof<
                    u32,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                    types::sp_consensus_beefy::ecdsa_crypto::Signature,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![52u8, 0u8];
                equivocation_proof.encode_to(&mut buf);
                key_owner_proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
            #[doc = "equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence"]
            #[doc = "will be reported."]
            #[doc = ""]
            #[doc = "This extrinsic must be called unsigned and it is expected that only"]
            #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
            #[doc = "if the block author is defined it will be defined as the equivocation"]
            #[doc = "reporter."]
            #[cfg(not(feature = "ink"))]
            pub fn report_double_voting_unsigned(
                &self,
                equivocation_proof: types::sp_consensus_beefy::DoubleVotingProof<
                    u32,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                    types::sp_consensus_beefy::ecdsa_crypto::Signature,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Beefy(
                    types::pallet_beefy::pallet::BeefyCall::report_double_voting_unsigned {
                        equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
                        key_owner_proof,
                    },
                ))
            }
            #[doc = "Report voter equivocation/misbehavior. This method will verify the"]
            #[doc = "equivocation proof and validate the given key ownership proof"]
            #[doc = "against the extracted offender. If both are valid, the offence"]
            #[doc = "will be reported."]
            #[doc = ""]
            #[doc = "This extrinsic must be called unsigned and it is expected that only"]
            #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
            #[doc = "if the block author is defined it will be defined as the equivocation"]
            #[doc = "reporter."]
            #[cfg(feature = "ink")]
            pub fn report_double_voting_unsigned(
                &self,
                equivocation_proof: types::sp_consensus_beefy::DoubleVotingProof<
                    u32,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                    types::sp_consensus_beefy::ecdsa_crypto::Signature,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![52u8, 1u8];
                equivocation_proof.encode_to(&mut buf);
                key_owner_proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Reset BEEFY consensus by setting a new BEEFY genesis at `delay_in_blocks` blocks in the"]
            #[doc = "future."]
            #[doc = ""]
            #[doc = "Note: `delay_in_blocks` has to be at least 1."]
            #[cfg(not(feature = "ink"))]
            pub fn set_new_genesis(
                &self,
                delay_in_blocks: u32,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Beefy(
                    types::pallet_beefy::pallet::BeefyCall::set_new_genesis { delay_in_blocks },
                ))
            }
            #[doc = "Reset BEEFY consensus by setting a new BEEFY genesis at `delay_in_blocks` blocks in the"]
            #[doc = "future."]
            #[doc = ""]
            #[doc = "Note: `delay_in_blocks` has to be at least 1."]
            #[cfg(feature = "ink")]
            pub fn set_new_genesis(&self, delay_in_blocks: u32) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![52u8, 2u8];
                delay_in_blocks.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Report fork voting equivocation. This method will verify the equivocation proof"]
            #[doc = "and validate the given key ownership proof against the extracted offender."]
            #[doc = "If both are valid, the offence will be reported."]
            #[cfg(not(feature = "ink"))]
            pub fn report_fork_voting(
                &self,
                equivocation_proof: types::sp_consensus_beefy::ForkVotingProof<
                    types::sp_runtime::generic::header::Header<u32>,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                    types::sp_mmr_primitives::AncestryProof<types::primitive_types::H256>,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Beefy(
                    types::pallet_beefy::pallet::BeefyCall::report_fork_voting {
                        equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
                        key_owner_proof,
                    },
                ))
            }
            #[doc = "Report fork voting equivocation. This method will verify the equivocation proof"]
            #[doc = "and validate the given key ownership proof against the extracted offender."]
            #[doc = "If both are valid, the offence will be reported."]
            #[cfg(feature = "ink")]
            pub fn report_fork_voting(
                &self,
                equivocation_proof: types::sp_consensus_beefy::ForkVotingProof<
                    types::sp_runtime::generic::header::Header<u32>,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                    types::sp_mmr_primitives::AncestryProof<types::primitive_types::H256>,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![52u8, 3u8];
                equivocation_proof.encode_to(&mut buf);
                key_owner_proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Report fork voting equivocation. This method will verify the equivocation proof"]
            #[doc = "and validate the given key ownership proof against the extracted offender."]
            #[doc = "If both are valid, the offence will be reported."]
            #[doc = ""]
            #[doc = "This extrinsic must be called unsigned and it is expected that only"]
            #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
            #[doc = "if the block author is defined it will be defined as the equivocation"]
            #[doc = "reporter."]
            #[cfg(not(feature = "ink"))]
            pub fn report_fork_voting_unsigned(
                &self,
                equivocation_proof: types::sp_consensus_beefy::ForkVotingProof<
                    types::sp_runtime::generic::header::Header<u32>,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                    types::sp_mmr_primitives::AncestryProof<types::primitive_types::H256>,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Beefy(
                    types::pallet_beefy::pallet::BeefyCall::report_fork_voting_unsigned {
                        equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
                        key_owner_proof,
                    },
                ))
            }
            #[doc = "Report fork voting equivocation. This method will verify the equivocation proof"]
            #[doc = "and validate the given key ownership proof against the extracted offender."]
            #[doc = "If both are valid, the offence will be reported."]
            #[doc = ""]
            #[doc = "This extrinsic must be called unsigned and it is expected that only"]
            #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
            #[doc = "if the block author is defined it will be defined as the equivocation"]
            #[doc = "reporter."]
            #[cfg(feature = "ink")]
            pub fn report_fork_voting_unsigned(
                &self,
                equivocation_proof: types::sp_consensus_beefy::ForkVotingProof<
                    types::sp_runtime::generic::header::Header<u32>,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                    types::sp_mmr_primitives::AncestryProof<types::primitive_types::H256>,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![52u8, 4u8];
                equivocation_proof.encode_to(&mut buf);
                key_owner_proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Report future block voting equivocation. This method will verify the equivocation proof"]
            #[doc = "and validate the given key ownership proof against the extracted offender."]
            #[doc = "If both are valid, the offence will be reported."]
            #[cfg(not(feature = "ink"))]
            pub fn report_future_block_voting(
                &self,
                equivocation_proof: types::sp_consensus_beefy::FutureBlockVotingProof<
                    u32,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Beefy(
                    types::pallet_beefy::pallet::BeefyCall::report_future_block_voting {
                        equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
                        key_owner_proof,
                    },
                ))
            }
            #[doc = "Report future block voting equivocation. This method will verify the equivocation proof"]
            #[doc = "and validate the given key ownership proof against the extracted offender."]
            #[doc = "If both are valid, the offence will be reported."]
            #[cfg(feature = "ink")]
            pub fn report_future_block_voting(
                &self,
                equivocation_proof: types::sp_consensus_beefy::FutureBlockVotingProof<
                    u32,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![52u8, 5u8];
                equivocation_proof.encode_to(&mut buf);
                key_owner_proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
            #[doc = "Report future block voting equivocation. This method will verify the equivocation proof"]
            #[doc = "and validate the given key ownership proof against the extracted offender."]
            #[doc = "If both are valid, the offence will be reported."]
            #[doc = ""]
            #[doc = "This extrinsic must be called unsigned and it is expected that only"]
            #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
            #[doc = "if the block author is defined it will be defined as the equivocation"]
            #[doc = "reporter."]
            #[cfg(not(feature = "ink"))]
            pub fn report_future_block_voting_unsigned(
                &self,
                equivocation_proof: types::sp_consensus_beefy::FutureBlockVotingProof<
                    u32,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> ::polymesh_api_client::error::Result<super::super::WrappedCall> {
                self.api.wrap_call(runtime::RuntimeCall::Beefy(
                    types::pallet_beefy::pallet::BeefyCall::report_future_block_voting_unsigned {
                        equivocation_proof: ::alloc::boxed::Box::new(equivocation_proof),
                        key_owner_proof,
                    },
                ))
            }
            #[doc = "Report future block voting equivocation. This method will verify the equivocation proof"]
            #[doc = "and validate the given key ownership proof against the extracted offender."]
            #[doc = "If both are valid, the offence will be reported."]
            #[doc = ""]
            #[doc = "This extrinsic must be called unsigned and it is expected that only"]
            #[doc = "block authors will call it (validated in `ValidateUnsigned`), as such"]
            #[doc = "if the block author is defined it will be defined as the equivocation"]
            #[doc = "reporter."]
            #[cfg(feature = "ink")]
            pub fn report_future_block_voting_unsigned(
                &self,
                equivocation_proof: types::sp_consensus_beefy::FutureBlockVotingProof<
                    u32,
                    types::sp_consensus_beefy::ecdsa_crypto::Public,
                >,
                key_owner_proof: types::sp_session::MembershipProof,
            ) -> super::super::WrappedCall {
                use ::codec::Encode;
                let mut buf = ::alloc::vec![52u8, 6u8];
                equivocation_proof.encode_to(&mut buf);
                key_owner_proof.encode_to(&mut buf);
                self.api.wrap_call(buf)
            }
        }
        impl<'api> From<&'api super::super::Api> for BeefyCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct BeefyQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> BeefyQueryApi<'api> {
            #[doc = " The current authorities set"]
            #[cfg(not(feature = "ink"))]
            pub async fn authorities(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::sp_consensus_beefy::ecdsa_crypto::Public>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 94u8, 6u8, 33u8, 196u8, 134u8, 154u8, 166u8, 12u8,
                    2u8, 190u8, 154u8, 220u8, 201u8, 138u8, 13u8, 29u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::sp_consensus_beefy::ecdsa_crypto::Public>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current authorities set"]
            #[cfg(feature = "ink")]
            pub fn authorities(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::sp_consensus_beefy::ecdsa_crypto::Public>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 94u8, 6u8, 33u8, 196u8, 134u8, 154u8, 166u8, 12u8,
                    2u8, 190u8, 154u8, 220u8, 201u8, 138u8, 13u8, 29u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::sp_consensus_beefy::ecdsa_crypto::Public>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " The current validator set id"]
            #[cfg(not(feature = "ink"))]
            pub async fn validator_set_id(&self) -> ::polymesh_api_client::error::Result<u64> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 143u8, 5u8, 188u8, 204u8, 47u8, 112u8, 236u8,
                    102u8, 163u8, 41u8, 153u8, 197u8, 118u8, 17u8, 86u8, 190u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " The current validator set id"]
            #[cfg(feature = "ink")]
            pub fn validator_set_id(&self) -> ::polymesh_api_ink::error::Result<u64> {
                let value = self.api.read_storage(::alloc::vec![
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 143u8, 5u8, 188u8, 204u8, 47u8, 112u8, 236u8,
                    102u8, 163u8, 41u8, 153u8, 197u8, 118u8, 17u8, 86u8, 190u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Authorities set scheduled to be used with the next session"]
            #[cfg(not(feature = "ink"))]
            pub async fn next_authorities(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                ::alloc::vec::Vec<types::sp_consensus_beefy::ecdsa_crypto::Public>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 170u8, 207u8, 0u8, 185u8, 180u8, 31u8, 218u8,
                    122u8, 146u8, 104u8, 130u8, 28u8, 42u8, 43u8, 62u8, 76u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::sp_consensus_beefy::ecdsa_crypto::Public>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " Authorities set scheduled to be used with the next session"]
            #[cfg(feature = "ink")]
            pub fn next_authorities(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                ::alloc::vec::Vec<types::sp_consensus_beefy::ecdsa_crypto::Public>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 170u8, 207u8, 0u8, 185u8, 180u8, 31u8, 218u8,
                    122u8, 146u8, 104u8, 130u8, 28u8, 42u8, 43u8, 62u8, 76u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <::alloc::vec::Vec<types::sp_consensus_beefy::ecdsa_crypto::Public>>::decode(
                        &mut &DEFAULT[..],
                    )
                    .unwrap()
                }))
            }
            #[doc = " A mapping from BEEFY set ID to the index of the *most recent* session for which its"]
            #[doc = " members were responsible."]
            #[doc = ""]
            #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
            #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
            #[doc = " together sessions and BEEFY set ids, i.e. we need to validate that a validator"]
            #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
            #[doc = " during that session."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: `ValidatorSetId` is not under user control."]
            #[cfg(not(feature = "ink"))]
            pub async fn set_id_session(
                &self,
                key_0: u64,
            ) -> ::polymesh_api_client::error::Result<Option<u32>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8,
                    67u8, 221u8, 251u8, 54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " A mapping from BEEFY set ID to the index of the *most recent* session for which its"]
            #[doc = " members were responsible."]
            #[doc = ""]
            #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
            #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
            #[doc = " together sessions and BEEFY set ids, i.e. we need to validate that a validator"]
            #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
            #[doc = " during that session."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: `ValidatorSetId` is not under user control."]
            #[cfg(feature = "ink")]
            pub fn set_id_session(
                &self,
                key_0: u64,
            ) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8,
                    67u8, 221u8, 251u8, 54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
                ]);
                let key = key_0.encode();
                buf.extend(::polymesh_api_client::hashing::twox_64(&key));
                buf.extend(key.into_iter());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
            #[doc = " Block number where BEEFY consensus is enabled/started."]
            #[doc = " By changing this (through privileged `set_new_genesis()`), BEEFY consensus is effectively"]
            #[doc = " restarted from the newly set block number."]
            #[cfg(not(feature = "ink"))]
            pub async fn genesis_block(&self) -> ::polymesh_api_client::error::Result<Option<u32>> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 199u8, 19u8, 183u8, 248u8, 177u8, 78u8, 40u8, 21u8,
                    210u8, 151u8, 88u8, 93u8, 53u8, 129u8, 231u8, 116u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <Option<u32>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Block number where BEEFY consensus is enabled/started."]
            #[doc = " By changing this (through privileged `set_new_genesis()`), BEEFY consensus is effectively"]
            #[doc = " restarted from the newly set block number."]
            #[cfg(feature = "ink")]
            pub fn genesis_block(&self) -> ::polymesh_api_ink::error::Result<Option<u32>> {
                let value = self.api.read_storage(::alloc::vec![
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 199u8, 19u8, 183u8, 248u8, 177u8, 78u8, 40u8, 21u8,
                    210u8, 151u8, 88u8, 93u8, 53u8, 129u8, 231u8, 116u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8];
                    <Option<u32>>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct BeefyPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> BeefyPagedQueryApi<'api> {
            #[doc = " A mapping from BEEFY set ID to the index of the *most recent* session for which its"]
            #[doc = " members were responsible."]
            #[doc = ""]
            #[doc = " This is only used for validating equivocation proofs. An equivocation proof must"]
            #[doc = " contains a key-ownership proof for a given session, therefore we need a way to tie"]
            #[doc = " together sessions and BEEFY set ids, i.e. we need to validate that a validator"]
            #[doc = " was the owner of a given key on a given session, and what the active set ID was"]
            #[doc = " during that session."]
            #[doc = ""]
            #[doc = " TWOX-NOTE: `ValidatorSetId` is not under user control."]
            pub fn set_id_session(&self) -> ::polymesh_api_client::StoragePaged<u64, u32> {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    8u8, 196u8, 25u8, 116u8, 169u8, 125u8, 191u8, 21u8, 207u8, 190u8, 194u8, 131u8,
                    101u8, 190u8, 162u8, 218u8, 212u8, 124u8, 184u8, 245u8, 50u8, 138u8, 247u8,
                    67u8, 221u8, 251u8, 54u8, 30u8, 113u8, 128u8, 231u8, 252u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(8), self.at)
            }
        }
    }
    pub mod mmr {
        use super::*;
        #[derive(Clone)]
        pub struct MmrCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> MmrCallApi<'api> {}
        impl<'api> From<&'api super::super::Api> for MmrCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct MmrQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> MmrQueryApi<'api> {
            #[doc = " Latest MMR Root hash."]
            #[cfg(not(feature = "ink"))]
            pub async fn root_hash(
                &self,
            ) -> ::polymesh_api_client::error::Result<types::primitive_types::H256> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    168u8, 198u8, 82u8, 9u8, 212u8, 126u8, 232u8, 15u8, 86u8, 176u8, 1u8, 30u8,
                    143u8, 217u8, 31u8, 80u8, 212u8, 47u8, 103u8, 104u8, 7u8, 81u8, 140u8, 103u8,
                    187u8, 66u8, 117u8, 70u8, 186u8, 64u8, 111u8, 161u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Latest MMR Root hash."]
            #[cfg(feature = "ink")]
            pub fn root_hash(
                &self,
            ) -> ::polymesh_api_ink::error::Result<types::primitive_types::H256> {
                let value = self.api.read_storage(::alloc::vec![
                    168u8, 198u8, 82u8, 9u8, 212u8, 126u8, 232u8, 15u8, 86u8, 176u8, 1u8, 30u8,
                    143u8, 217u8, 31u8, 80u8, 212u8, 47u8, 103u8, 104u8, 7u8, 81u8, 140u8, 103u8,
                    187u8, 66u8, 117u8, 70u8, 186u8, 64u8, 111u8, 161u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                        0u8, 0u8,
                    ];
                    <types::primitive_types::H256>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Current size of the MMR (number of leaves)."]
            #[cfg(not(feature = "ink"))]
            pub async fn number_of_leaves(&self) -> ::polymesh_api_client::error::Result<u64> {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    168u8, 198u8, 82u8, 9u8, 212u8, 126u8, 232u8, 15u8, 86u8, 176u8, 1u8, 30u8,
                    143u8, 217u8, 31u8, 80u8, 129u8, 86u8, 32u8, 153u8, 6u8, 36u8, 79u8, 35u8,
                    65u8, 19u8, 124u8, 19u8, 103u8, 116u8, 201u8, 29u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Current size of the MMR (number of leaves)."]
            #[cfg(feature = "ink")]
            pub fn number_of_leaves(&self) -> ::polymesh_api_ink::error::Result<u64> {
                let value = self.api.read_storage(::alloc::vec![
                    168u8, 198u8, 82u8, 9u8, 212u8, 126u8, 232u8, 15u8, 86u8, 176u8, 1u8, 30u8,
                    143u8, 217u8, 31u8, 80u8, 129u8, 86u8, 32u8, 153u8, 6u8, 36u8, 79u8, 35u8,
                    65u8, 19u8, 124u8, 19u8, 103u8, 116u8, 201u8, 29u8,
                ])?;
                Ok(value.unwrap_or_else(|| {
                    use ::codec::Decode;
                    const DEFAULT: &'static [u8] = &[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8];
                    <u64>::decode(&mut &DEFAULT[..]).unwrap()
                }))
            }
            #[doc = " Hashes of the nodes in the MMR."]
            #[doc = ""]
            #[doc = " Note this collection only contains MMR peaks, the inner nodes (and leaves)"]
            #[doc = " are pruned and only stored in the Offchain DB."]
            #[cfg(not(feature = "ink"))]
            pub async fn nodes(
                &self,
                key_0: u64,
            ) -> ::polymesh_api_client::error::Result<Option<types::primitive_types::H256>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    168u8, 198u8, 82u8, 9u8, 212u8, 126u8, 232u8, 15u8, 86u8, 176u8, 1u8, 30u8,
                    143u8, 217u8, 31u8, 80u8, 81u8, 157u8, 252u8, 127u8, 218u8, 210u8, 27u8, 132u8,
                    246u8, 74u8, 83u8, 16u8, 250u8, 23u8, 142u8, 242u8,
                ]);
                buf.extend(key_0.encode());
                let key = ::polymesh_api_client::StorageKey(buf);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(value)
            }
            #[doc = " Hashes of the nodes in the MMR."]
            #[doc = ""]
            #[doc = " Note this collection only contains MMR peaks, the inner nodes (and leaves)"]
            #[doc = " are pruned and only stored in the Offchain DB."]
            #[cfg(feature = "ink")]
            pub fn nodes(
                &self,
                key_0: u64,
            ) -> ::polymesh_api_ink::error::Result<Option<types::primitive_types::H256>>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    168u8, 198u8, 82u8, 9u8, 212u8, 126u8, 232u8, 15u8, 86u8, 176u8, 1u8, 30u8,
                    143u8, 217u8, 31u8, 80u8, 81u8, 157u8, 252u8, 127u8, 218u8, 210u8, 27u8, 132u8,
                    246u8, 74u8, 83u8, 16u8, 250u8, 23u8, 142u8, 242u8,
                ]);
                buf.extend(key_0.encode());
                let value = self.api.read_storage(buf)?;
                Ok(value)
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct MmrPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> MmrPagedQueryApi<'api> {
            #[doc = " Hashes of the nodes in the MMR."]
            #[doc = ""]
            #[doc = " Note this collection only contains MMR peaks, the inner nodes (and leaves)"]
            #[doc = " are pruned and only stored in the Offchain DB."]
            pub fn nodes(
                &self,
            ) -> ::polymesh_api_client::StoragePaged<u64, types::primitive_types::H256>
            {
                use ::codec::Encode;
                let mut buf = ::alloc::vec::Vec::with_capacity(512);
                buf.extend([
                    168u8, 198u8, 82u8, 9u8, 212u8, 126u8, 232u8, 15u8, 86u8, 176u8, 1u8, 30u8,
                    143u8, 217u8, 31u8, 80u8, 81u8, 157u8, 252u8, 127u8, 218u8, 210u8, 27u8, 132u8,
                    246u8, 74u8, 83u8, 16u8, 250u8, 23u8, 142u8, 242u8,
                ]);
                let prefix = ::polymesh_api_client::StorageKey(buf);
                ::polymesh_api_client::StoragePaged::new(&self.api.client, prefix, Some(0), self.at)
            }
        }
    }
    pub mod mmr_leaf {
        use super::*;
        #[derive(Clone)]
        pub struct MmrLeafCallApi<'api> {
            api: &'api super::super::Api,
        }
        impl<'api> MmrLeafCallApi<'api> {}
        impl<'api> From<&'api super::super::Api> for MmrLeafCallApi<'api> {
            fn from(api: &'api super::super::Api) -> Self {
                Self { api }
            }
        }
        #[derive(Clone)]
        pub struct MmrLeafQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            #[cfg(not(feature = "ink"))]
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        impl<'api> MmrLeafQueryApi<'api> {
            #[doc = " Details of current BEEFY authority set."]
            #[cfg(not(feature = "ink"))]
            pub async fn beefy_authorities(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::sp_consensus_beefy::mmr::BeefyAuthoritySet<types::primitive_types::H256>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    218u8, 125u8, 65u8, 133u8, 248u8, 9u8, 62u8, 128u8, 202u8, 206u8, 182u8, 77u8,
                    164u8, 82u8, 25u8, 227u8, 197u8, 42u8, 169u8, 67u8, 191u8, 9u8, 8u8, 134u8,
                    10u8, 62u8, 234u8, 15u8, 173u8, 112u8, 124u8, 220u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(
                    value.unwrap_or_else(|| {
                        use ::codec::Decode;
                        const DEFAULT: &'static [u8] = &[
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8,
                        ];
                        <types::sp_consensus_beefy::mmr::BeefyAuthoritySet<
                            types::primitive_types::H256,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
                    }),
                )
            }
            #[doc = " Details of current BEEFY authority set."]
            #[cfg(feature = "ink")]
            pub fn beefy_authorities(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                types::sp_consensus_beefy::mmr::BeefyAuthoritySet<types::primitive_types::H256>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    218u8, 125u8, 65u8, 133u8, 248u8, 9u8, 62u8, 128u8, 202u8, 206u8, 182u8, 77u8,
                    164u8, 82u8, 25u8, 227u8, 197u8, 42u8, 169u8, 67u8, 191u8, 9u8, 8u8, 134u8,
                    10u8, 62u8, 234u8, 15u8, 173u8, 112u8, 124u8, 220u8,
                ])?;
                Ok(
                    value.unwrap_or_else(|| {
                        use ::codec::Decode;
                        const DEFAULT: &'static [u8] = &[
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8,
                        ];
                        <types::sp_consensus_beefy::mmr::BeefyAuthoritySet<
                            types::primitive_types::H256,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
                    }),
                )
            }
            #[doc = " Details of next BEEFY authority set."]
            #[doc = ""]
            #[doc = " This storage entry is used as cache for calls to `update_beefy_next_authority_set`."]
            #[cfg(not(feature = "ink"))]
            pub async fn beefy_next_authorities(
                &self,
            ) -> ::polymesh_api_client::error::Result<
                types::sp_consensus_beefy::mmr::BeefyAuthoritySet<types::primitive_types::H256>,
            > {
                let key = ::polymesh_api_client::StorageKey(::alloc::vec![
                    218u8, 125u8, 65u8, 133u8, 248u8, 9u8, 62u8, 128u8, 202u8, 206u8, 182u8, 77u8,
                    164u8, 82u8, 25u8, 227u8, 12u8, 152u8, 83u8, 91u8, 130u8, 199u8, 47u8, 175u8,
                    60u8, 100u8, 151u8, 64u8, 148u8, 175u8, 70u8, 67u8,
                ]);
                let value = self.api.client.get_storage_by_key(key, self.at).await?;
                Ok(
                    value.unwrap_or_else(|| {
                        use ::codec::Decode;
                        const DEFAULT: &'static [u8] = &[
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8,
                        ];
                        <types::sp_consensus_beefy::mmr::BeefyAuthoritySet<
                            types::primitive_types::H256,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
                    }),
                )
            }
            #[doc = " Details of next BEEFY authority set."]
            #[doc = ""]
            #[doc = " This storage entry is used as cache for calls to `update_beefy_next_authority_set`."]
            #[cfg(feature = "ink")]
            pub fn beefy_next_authorities(
                &self,
            ) -> ::polymesh_api_ink::error::Result<
                types::sp_consensus_beefy::mmr::BeefyAuthoritySet<types::primitive_types::H256>,
            > {
                let value = self.api.read_storage(::alloc::vec![
                    218u8, 125u8, 65u8, 133u8, 248u8, 9u8, 62u8, 128u8, 202u8, 206u8, 182u8, 77u8,
                    164u8, 82u8, 25u8, 227u8, 12u8, 152u8, 83u8, 91u8, 130u8, 199u8, 47u8, 175u8,
                    60u8, 100u8, 151u8, 64u8, 148u8, 175u8, 70u8, 67u8,
                ])?;
                Ok(
                    value.unwrap_or_else(|| {
                        use ::codec::Decode;
                        const DEFAULT: &'static [u8] = &[
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                            0u8, 0u8,
                        ];
                        <types::sp_consensus_beefy::mmr::BeefyAuthoritySet<
                            types::primitive_types::H256,
                        >>::decode(&mut &DEFAULT[..])
                        .unwrap()
                    }),
                )
            }
        }
        #[derive(Clone)]
        #[cfg(not(feature = "ink"))]
        pub struct MmrLeafPagedQueryApi<'api> {
            pub(crate) api: &'api super::super::Api,
            pub(crate) at: Option<::polymesh_api_client::BlockHash>,
        }
        #[cfg(not(feature = "ink"))]
        impl<'api> MmrLeafPagedQueryApi<'api> {}
    }
}
#[derive(Clone)]
pub struct Api {
    #[cfg(not(feature = "ink"))]
    client: ::polymesh_api_client::Client,
}
impl Api {
    #[cfg(feature = "ink")]
    pub fn new() -> Self {
        Self {}
    }
    #[cfg(feature = "ink")]
    pub fn runtime(&self) -> ::polymesh_api_ink::extension::PolymeshRuntimeInstance {
        ::polymesh_api_ink::extension::new_instance()
    }
    #[cfg(feature = "ink")]
    pub fn read_storage<T: ::codec::Decode>(
        &self,
        key: ::alloc::vec::Vec<u8>,
    ) -> ::polymesh_api_ink::error::Result<Option<T>> {
        let runtime = self.runtime();
        let value = runtime
            .read_storage(key.into())?
            .map(|data| T::decode(&mut data.as_slice()))
            .transpose()?;
        Ok(value)
    }
    #[cfg(not(feature = "ink"))]
    pub async fn new(url: &str) -> ::polymesh_api_client::error::Result<Self> {
        Ok(Self {
            client: ::polymesh_api_client::Client::new(url).await?,
        })
    }
    pub fn call(&self) -> CallApi<'_> {
        CallApi { api: self }
    }
    #[cfg(not(feature = "ink"))]
    pub fn query(&self) -> QueryApi<'_> {
        QueryApi {
            api: self,
            at: None,
        }
    }
    #[cfg(feature = "ink")]
    pub fn query(&self) -> QueryApi<'_> {
        QueryApi { api: self }
    }
    #[cfg(not(feature = "ink"))]
    pub fn query_at(&self, block: ::polymesh_api_client::BlockHash) -> QueryApi<'_> {
        QueryApi {
            api: self,
            at: Some(block),
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn paged_query(&self) -> PagedQueryApi<'_> {
        PagedQueryApi {
            api: self,
            at: None,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn paged_query_at(&self, block: ::polymesh_api_client::BlockHash) -> PagedQueryApi<'_> {
        PagedQueryApi {
            api: self,
            at: Some(block),
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn wrap_call(
        &self,
        call: types::runtime::RuntimeCall,
    ) -> ::polymesh_api_client::Result<WrappedCall> {
        Ok(WrappedCall::new(self, call))
    }
    #[cfg(feature = "ink")]
    pub fn wrap_call(&self, call: ::alloc::vec::Vec<u8>) -> WrappedCall {
        WrappedCall::new(call)
    }
}
#[cfg(not(feature = "ink"))]
use alloc::boxed::Box;
#[async_trait::async_trait]
#[cfg(not(feature = "ink"))]
impl ::polymesh_api_client::ChainApi for Api {
    type RuntimeCall = types::runtime::RuntimeCall;
    type RuntimeEvent = types::runtime::RuntimeEvent;
    type DispatchInfo = types::frame_system::DispatchEventInfo;
    type DispatchError = types::sp_runtime::DispatchError;
    async fn get_nonce(
        &self,
        account: ::polymesh_api_client::AccountId,
    ) -> ::polymesh_api_client::Result<u32> {
        let info = self.query().system().account(account).await?;
        Ok(info.nonce)
    }
    async fn block_events(
        &self,
        block: Option<::polymesh_api_client::BlockHash>,
    ) -> ::polymesh_api_client::Result<
        ::alloc::vec::Vec<::polymesh_api_client::EventRecord<Self::RuntimeEvent>>,
    > {
        let system = match block {
            Some(block) => self.query_at(block).system(),
            None => self.query().system(),
        };
        Ok(system.events().await?)
    }
    fn event_to_extrinsic_result(
        event: &::polymesh_api_client::EventRecord<Self::RuntimeEvent>,
    ) -> Option<::polymesh_api_client::ExtrinsicResult<Self>> {
        match &event.event {
            types::runtime::RuntimeEvent::System(
                types::frame_system::pallet::SystemEvent::ExtrinsicSuccess { dispatch_info },
            ) => Some(::polymesh_api_client::ExtrinsicResult::Success(
                dispatch_info.clone(),
            )),
            types::runtime::RuntimeEvent::System(
                types::frame_system::pallet::SystemEvent::ExtrinsicFailed {
                    dispatch_info,
                    dispatch_error,
                },
            ) => Some(::polymesh_api_client::ExtrinsicResult::Failed(
                dispatch_info.clone(),
                dispatch_error.clone(),
            )),
            _ => None,
        }
    }
    fn client(&self) -> &::polymesh_api_client::Client {
        &self.client
    }
}
#[derive(Clone)]
pub struct CallApi<'api> {
    api: &'api Api,
}
impl<'api> CallApi<'api> {
    pub fn system(&self) -> api::system::SystemCallApi<'api> {
        api::system::SystemCallApi::from(self.api)
    }
    pub fn babe(&self) -> api::babe::BabeCallApi<'api> {
        api::babe::BabeCallApi::from(self.api)
    }
    pub fn timestamp(&self) -> api::timestamp::TimestampCallApi<'api> {
        api::timestamp::TimestampCallApi::from(self.api)
    }
    pub fn indices(&self) -> api::indices::IndicesCallApi<'api> {
        api::indices::IndicesCallApi::from(self.api)
    }
    pub fn authorship(&self) -> api::authorship::AuthorshipCallApi<'api> {
        api::authorship::AuthorshipCallApi::from(self.api)
    }
    pub fn balances(&self) -> api::balances::BalancesCallApi<'api> {
        api::balances::BalancesCallApi::from(self.api)
    }
    pub fn transaction_payment(&self) -> api::transaction_payment::TransactionPaymentCallApi<'api> {
        api::transaction_payment::TransactionPaymentCallApi::from(self.api)
    }
    pub fn identity(&self) -> api::identity::IdentityCallApi<'api> {
        api::identity::IdentityCallApi::from(self.api)
    }
    pub fn cdd_service_providers(
        &self,
    ) -> api::cdd_service_providers::CddServiceProvidersCallApi<'api> {
        api::cdd_service_providers::CddServiceProvidersCallApi::from(self.api)
    }
    pub fn polymesh_committee(&self) -> api::polymesh_committee::PolymeshCommitteeCallApi<'api> {
        api::polymesh_committee::PolymeshCommitteeCallApi::from(self.api)
    }
    pub fn committee_membership(
        &self,
    ) -> api::committee_membership::CommitteeMembershipCallApi<'api> {
        api::committee_membership::CommitteeMembershipCallApi::from(self.api)
    }
    pub fn technical_committee(&self) -> api::technical_committee::TechnicalCommitteeCallApi<'api> {
        api::technical_committee::TechnicalCommitteeCallApi::from(self.api)
    }
    pub fn technical_committee_membership(
        &self,
    ) -> api::technical_committee_membership::TechnicalCommitteeMembershipCallApi<'api> {
        api::technical_committee_membership::TechnicalCommitteeMembershipCallApi::from(self.api)
    }
    pub fn upgrade_committee(&self) -> api::upgrade_committee::UpgradeCommitteeCallApi<'api> {
        api::upgrade_committee::UpgradeCommitteeCallApi::from(self.api)
    }
    pub fn upgrade_committee_membership(
        &self,
    ) -> api::upgrade_committee_membership::UpgradeCommitteeMembershipCallApi<'api> {
        api::upgrade_committee_membership::UpgradeCommitteeMembershipCallApi::from(self.api)
    }
    pub fn multi_sig(&self) -> api::multi_sig::MultiSigCallApi<'api> {
        api::multi_sig::MultiSigCallApi::from(self.api)
    }
    pub fn validators(&self) -> api::validators::ValidatorsCallApi<'api> {
        api::validators::ValidatorsCallApi::from(self.api)
    }
    pub fn staking(&self) -> api::staking::StakingCallApi<'api> {
        api::staking::StakingCallApi::from(self.api)
    }
    pub fn offences(&self) -> api::offences::OffencesCallApi<'api> {
        api::offences::OffencesCallApi::from(self.api)
    }
    pub fn session(&self) -> api::session::SessionCallApi<'api> {
        api::session::SessionCallApi::from(self.api)
    }
    pub fn authority_discovery(&self) -> api::authority_discovery::AuthorityDiscoveryCallApi<'api> {
        api::authority_discovery::AuthorityDiscoveryCallApi::from(self.api)
    }
    pub fn grandpa(&self) -> api::grandpa::GrandpaCallApi<'api> {
        api::grandpa::GrandpaCallApi::from(self.api)
    }
    pub fn historical(&self) -> api::historical::HistoricalCallApi<'api> {
        api::historical::HistoricalCallApi::from(self.api)
    }
    pub fn im_online(&self) -> api::im_online::ImOnlineCallApi<'api> {
        api::im_online::ImOnlineCallApi::from(self.api)
    }
    pub fn randomness_collective_flip(
        &self,
    ) -> api::randomness_collective_flip::RandomnessCollectiveFlipCallApi<'api> {
        api::randomness_collective_flip::RandomnessCollectiveFlipCallApi::from(self.api)
    }
    pub fn sudo(&self) -> api::sudo::SudoCallApi<'api> {
        api::sudo::SudoCallApi::from(self.api)
    }
    pub fn asset(&self) -> api::asset::AssetCallApi<'api> {
        api::asset::AssetCallApi::from(self.api)
    }
    pub fn capital_distribution(
        &self,
    ) -> api::capital_distribution::CapitalDistributionCallApi<'api> {
        api::capital_distribution::CapitalDistributionCallApi::from(self.api)
    }
    pub fn checkpoint(&self) -> api::checkpoint::CheckpointCallApi<'api> {
        api::checkpoint::CheckpointCallApi::from(self.api)
    }
    pub fn compliance_manager(&self) -> api::compliance_manager::ComplianceManagerCallApi<'api> {
        api::compliance_manager::ComplianceManagerCallApi::from(self.api)
    }
    pub fn corporate_action(&self) -> api::corporate_action::CorporateActionCallApi<'api> {
        api::corporate_action::CorporateActionCallApi::from(self.api)
    }
    pub fn corporate_ballot(&self) -> api::corporate_ballot::CorporateBallotCallApi<'api> {
        api::corporate_ballot::CorporateBallotCallApi::from(self.api)
    }
    pub fn permissions(&self) -> api::permissions::PermissionsCallApi<'api> {
        api::permissions::PermissionsCallApi::from(self.api)
    }
    pub fn pips(&self) -> api::pips::PipsCallApi<'api> {
        api::pips::PipsCallApi::from(self.api)
    }
    pub fn portfolio(&self) -> api::portfolio::PortfolioCallApi<'api> {
        api::portfolio::PortfolioCallApi::from(self.api)
    }
    pub fn protocol_fee(&self) -> api::protocol_fee::ProtocolFeeCallApi<'api> {
        api::protocol_fee::ProtocolFeeCallApi::from(self.api)
    }
    pub fn scheduler(&self) -> api::scheduler::SchedulerCallApi<'api> {
        api::scheduler::SchedulerCallApi::from(self.api)
    }
    pub fn settlement(&self) -> api::settlement::SettlementCallApi<'api> {
        api::settlement::SettlementCallApi::from(self.api)
    }
    pub fn statistics(&self) -> api::statistics::StatisticsCallApi<'api> {
        api::statistics::StatisticsCallApi::from(self.api)
    }
    pub fn sto(&self) -> api::sto::StoCallApi<'api> {
        api::sto::StoCallApi::from(self.api)
    }
    pub fn treasury(&self) -> api::treasury::TreasuryCallApi<'api> {
        api::treasury::TreasuryCallApi::from(self.api)
    }
    pub fn utility(&self) -> api::utility::UtilityCallApi<'api> {
        api::utility::UtilityCallApi::from(self.api)
    }
    pub fn base(&self) -> api::base::BaseCallApi<'api> {
        api::base::BaseCallApi::from(self.api)
    }
    pub fn external_agents(&self) -> api::external_agents::ExternalAgentsCallApi<'api> {
        api::external_agents::ExternalAgentsCallApi::from(self.api)
    }
    pub fn relayer(&self) -> api::relayer::RelayerCallApi<'api> {
        api::relayer::RelayerCallApi::from(self.api)
    }
    pub fn contracts(&self) -> api::contracts::ContractsCallApi<'api> {
        api::contracts::ContractsCallApi::from(self.api)
    }
    pub fn polymesh_contracts(&self) -> api::polymesh_contracts::PolymeshContractsCallApi<'api> {
        api::polymesh_contracts::PolymeshContractsCallApi::from(self.api)
    }
    pub fn preimage(&self) -> api::preimage::PreimageCallApi<'api> {
        api::preimage::PreimageCallApi::from(self.api)
    }
    pub fn nft(&self) -> api::nft::NftCallApi<'api> {
        api::nft::NftCallApi::from(self.api)
    }
    pub fn election_provider_multi_phase(
        &self,
    ) -> api::election_provider_multi_phase::ElectionProviderMultiPhaseCallApi<'api> {
        api::election_provider_multi_phase::ElectionProviderMultiPhaseCallApi::from(self.api)
    }
    pub fn polymesh_transaction_payment(
        &self,
    ) -> api::polymesh_transaction_payment::PolymeshTransactionPaymentCallApi<'api> {
        api::polymesh_transaction_payment::PolymeshTransactionPaymentCallApi::from(self.api)
    }
    pub fn beefy(&self) -> api::beefy::BeefyCallApi<'api> {
        api::beefy::BeefyCallApi::from(self.api)
    }
    pub fn mmr(&self) -> api::mmr::MmrCallApi<'api> {
        api::mmr::MmrCallApi::from(self.api)
    }
    pub fn mmr_leaf(&self) -> api::mmr_leaf::MmrLeafCallApi<'api> {
        api::mmr_leaf::MmrLeafCallApi::from(self.api)
    }
}
#[cfg(not(feature = "ink"))]
pub type WrappedCall = ::polymesh_api_client::Call<Api>;
#[cfg(not(feature = "ink"))]
pub type TransactionResults = ::polymesh_api_client::TransactionResults<Api>;
#[cfg(feature = "ink")]
pub type WrappedCall = ::polymesh_api_ink::Call;
#[cfg(not(feature = "ink"))]
impl From<WrappedCall> for types::runtime::RuntimeCall {
    fn from(wrapped: WrappedCall) -> Self {
        wrapped.into_runtime_call()
    }
}
#[cfg(not(feature = "ink"))]
impl From<&WrappedCall> for types::runtime::RuntimeCall {
    fn from(wrapped: &WrappedCall) -> Self {
        wrapped.runtime_call().clone()
    }
}
#[derive(Clone)]
pub struct QueryApi<'api> {
    api: &'api Api,
    #[cfg(not(feature = "ink"))]
    at: Option<::polymesh_api_client::BlockHash>,
}
impl<'api> QueryApi<'api> {
    pub fn system(&self) -> api::system::SystemQueryApi<'api> {
        api::system::SystemQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn babe(&self) -> api::babe::BabeQueryApi<'api> {
        api::babe::BabeQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn timestamp(&self) -> api::timestamp::TimestampQueryApi<'api> {
        api::timestamp::TimestampQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn indices(&self) -> api::indices::IndicesQueryApi<'api> {
        api::indices::IndicesQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn authorship(&self) -> api::authorship::AuthorshipQueryApi<'api> {
        api::authorship::AuthorshipQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn balances(&self) -> api::balances::BalancesQueryApi<'api> {
        api::balances::BalancesQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn transaction_payment(
        &self,
    ) -> api::transaction_payment::TransactionPaymentQueryApi<'api> {
        api::transaction_payment::TransactionPaymentQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn identity(&self) -> api::identity::IdentityQueryApi<'api> {
        api::identity::IdentityQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn cdd_service_providers(
        &self,
    ) -> api::cdd_service_providers::CddServiceProvidersQueryApi<'api> {
        api::cdd_service_providers::CddServiceProvidersQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn polymesh_committee(&self) -> api::polymesh_committee::PolymeshCommitteeQueryApi<'api> {
        api::polymesh_committee::PolymeshCommitteeQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn committee_membership(
        &self,
    ) -> api::committee_membership::CommitteeMembershipQueryApi<'api> {
        api::committee_membership::CommitteeMembershipQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn technical_committee(
        &self,
    ) -> api::technical_committee::TechnicalCommitteeQueryApi<'api> {
        api::technical_committee::TechnicalCommitteeQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn technical_committee_membership(
        &self,
    ) -> api::technical_committee_membership::TechnicalCommitteeMembershipQueryApi<'api> {
        api::technical_committee_membership::TechnicalCommitteeMembershipQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn upgrade_committee(&self) -> api::upgrade_committee::UpgradeCommitteeQueryApi<'api> {
        api::upgrade_committee::UpgradeCommitteeQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn upgrade_committee_membership(
        &self,
    ) -> api::upgrade_committee_membership::UpgradeCommitteeMembershipQueryApi<'api> {
        api::upgrade_committee_membership::UpgradeCommitteeMembershipQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn multi_sig(&self) -> api::multi_sig::MultiSigQueryApi<'api> {
        api::multi_sig::MultiSigQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn validators(&self) -> api::validators::ValidatorsQueryApi<'api> {
        api::validators::ValidatorsQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn staking(&self) -> api::staking::StakingQueryApi<'api> {
        api::staking::StakingQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn offences(&self) -> api::offences::OffencesQueryApi<'api> {
        api::offences::OffencesQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn session(&self) -> api::session::SessionQueryApi<'api> {
        api::session::SessionQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn authority_discovery(
        &self,
    ) -> api::authority_discovery::AuthorityDiscoveryQueryApi<'api> {
        api::authority_discovery::AuthorityDiscoveryQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn grandpa(&self) -> api::grandpa::GrandpaQueryApi<'api> {
        api::grandpa::GrandpaQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn historical(&self) -> api::historical::HistoricalQueryApi<'api> {
        api::historical::HistoricalQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn im_online(&self) -> api::im_online::ImOnlineQueryApi<'api> {
        api::im_online::ImOnlineQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn randomness_collective_flip(
        &self,
    ) -> api::randomness_collective_flip::RandomnessCollectiveFlipQueryApi<'api> {
        api::randomness_collective_flip::RandomnessCollectiveFlipQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn sudo(&self) -> api::sudo::SudoQueryApi<'api> {
        api::sudo::SudoQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn asset(&self) -> api::asset::AssetQueryApi<'api> {
        api::asset::AssetQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn capital_distribution(
        &self,
    ) -> api::capital_distribution::CapitalDistributionQueryApi<'api> {
        api::capital_distribution::CapitalDistributionQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn checkpoint(&self) -> api::checkpoint::CheckpointQueryApi<'api> {
        api::checkpoint::CheckpointQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn compliance_manager(&self) -> api::compliance_manager::ComplianceManagerQueryApi<'api> {
        api::compliance_manager::ComplianceManagerQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn corporate_action(&self) -> api::corporate_action::CorporateActionQueryApi<'api> {
        api::corporate_action::CorporateActionQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn corporate_ballot(&self) -> api::corporate_ballot::CorporateBallotQueryApi<'api> {
        api::corporate_ballot::CorporateBallotQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn permissions(&self) -> api::permissions::PermissionsQueryApi<'api> {
        api::permissions::PermissionsQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn pips(&self) -> api::pips::PipsQueryApi<'api> {
        api::pips::PipsQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn portfolio(&self) -> api::portfolio::PortfolioQueryApi<'api> {
        api::portfolio::PortfolioQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn protocol_fee(&self) -> api::protocol_fee::ProtocolFeeQueryApi<'api> {
        api::protocol_fee::ProtocolFeeQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn scheduler(&self) -> api::scheduler::SchedulerQueryApi<'api> {
        api::scheduler::SchedulerQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn settlement(&self) -> api::settlement::SettlementQueryApi<'api> {
        api::settlement::SettlementQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn statistics(&self) -> api::statistics::StatisticsQueryApi<'api> {
        api::statistics::StatisticsQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn sto(&self) -> api::sto::StoQueryApi<'api> {
        api::sto::StoQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn treasury(&self) -> api::treasury::TreasuryQueryApi<'api> {
        api::treasury::TreasuryQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn utility(&self) -> api::utility::UtilityQueryApi<'api> {
        api::utility::UtilityQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn base(&self) -> api::base::BaseQueryApi<'api> {
        api::base::BaseQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn external_agents(&self) -> api::external_agents::ExternalAgentsQueryApi<'api> {
        api::external_agents::ExternalAgentsQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn relayer(&self) -> api::relayer::RelayerQueryApi<'api> {
        api::relayer::RelayerQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn contracts(&self) -> api::contracts::ContractsQueryApi<'api> {
        api::contracts::ContractsQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn polymesh_contracts(&self) -> api::polymesh_contracts::PolymeshContractsQueryApi<'api> {
        api::polymesh_contracts::PolymeshContractsQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn preimage(&self) -> api::preimage::PreimageQueryApi<'api> {
        api::preimage::PreimageQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn nft(&self) -> api::nft::NftQueryApi<'api> {
        api::nft::NftQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn election_provider_multi_phase(
        &self,
    ) -> api::election_provider_multi_phase::ElectionProviderMultiPhaseQueryApi<'api> {
        api::election_provider_multi_phase::ElectionProviderMultiPhaseQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn polymesh_transaction_payment(
        &self,
    ) -> api::polymesh_transaction_payment::PolymeshTransactionPaymentQueryApi<'api> {
        api::polymesh_transaction_payment::PolymeshTransactionPaymentQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn beefy(&self) -> api::beefy::BeefyQueryApi<'api> {
        api::beefy::BeefyQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn mmr(&self) -> api::mmr::MmrQueryApi<'api> {
        api::mmr::MmrQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
    pub fn mmr_leaf(&self) -> api::mmr_leaf::MmrLeafQueryApi<'api> {
        api::mmr_leaf::MmrLeafQueryApi {
            api: self.api,
            #[cfg(not(feature = "ink"))]
            at: self.at,
        }
    }
}
#[derive(Clone)]
#[cfg(not(feature = "ink"))]
pub struct PagedQueryApi<'api> {
    api: &'api Api,
    at: Option<::polymesh_api_client::BlockHash>,
}
#[cfg(not(feature = "ink"))]
impl<'api> PagedQueryApi<'api> {
    #[cfg(not(feature = "ink"))]
    pub fn system(&self) -> api::system::SystemPagedQueryApi<'api> {
        api::system::SystemPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn babe(&self) -> api::babe::BabePagedQueryApi<'api> {
        api::babe::BabePagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn timestamp(&self) -> api::timestamp::TimestampPagedQueryApi<'api> {
        api::timestamp::TimestampPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn indices(&self) -> api::indices::IndicesPagedQueryApi<'api> {
        api::indices::IndicesPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn authorship(&self) -> api::authorship::AuthorshipPagedQueryApi<'api> {
        api::authorship::AuthorshipPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn balances(&self) -> api::balances::BalancesPagedQueryApi<'api> {
        api::balances::BalancesPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn transaction_payment(
        &self,
    ) -> api::transaction_payment::TransactionPaymentPagedQueryApi<'api> {
        api::transaction_payment::TransactionPaymentPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn identity(&self) -> api::identity::IdentityPagedQueryApi<'api> {
        api::identity::IdentityPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn cdd_service_providers(
        &self,
    ) -> api::cdd_service_providers::CddServiceProvidersPagedQueryApi<'api> {
        api::cdd_service_providers::CddServiceProvidersPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn polymesh_committee(
        &self,
    ) -> api::polymesh_committee::PolymeshCommitteePagedQueryApi<'api> {
        api::polymesh_committee::PolymeshCommitteePagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn committee_membership(
        &self,
    ) -> api::committee_membership::CommitteeMembershipPagedQueryApi<'api> {
        api::committee_membership::CommitteeMembershipPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn technical_committee(
        &self,
    ) -> api::technical_committee::TechnicalCommitteePagedQueryApi<'api> {
        api::technical_committee::TechnicalCommitteePagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn technical_committee_membership(
        &self,
    ) -> api::technical_committee_membership::TechnicalCommitteeMembershipPagedQueryApi<'api> {
        api::technical_committee_membership::TechnicalCommitteeMembershipPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn upgrade_committee(&self) -> api::upgrade_committee::UpgradeCommitteePagedQueryApi<'api> {
        api::upgrade_committee::UpgradeCommitteePagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn upgrade_committee_membership(
        &self,
    ) -> api::upgrade_committee_membership::UpgradeCommitteeMembershipPagedQueryApi<'api> {
        api::upgrade_committee_membership::UpgradeCommitteeMembershipPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn multi_sig(&self) -> api::multi_sig::MultiSigPagedQueryApi<'api> {
        api::multi_sig::MultiSigPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn validators(&self) -> api::validators::ValidatorsPagedQueryApi<'api> {
        api::validators::ValidatorsPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn staking(&self) -> api::staking::StakingPagedQueryApi<'api> {
        api::staking::StakingPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn offences(&self) -> api::offences::OffencesPagedQueryApi<'api> {
        api::offences::OffencesPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn session(&self) -> api::session::SessionPagedQueryApi<'api> {
        api::session::SessionPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn authority_discovery(
        &self,
    ) -> api::authority_discovery::AuthorityDiscoveryPagedQueryApi<'api> {
        api::authority_discovery::AuthorityDiscoveryPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn grandpa(&self) -> api::grandpa::GrandpaPagedQueryApi<'api> {
        api::grandpa::GrandpaPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn historical(&self) -> api::historical::HistoricalPagedQueryApi<'api> {
        api::historical::HistoricalPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn im_online(&self) -> api::im_online::ImOnlinePagedQueryApi<'api> {
        api::im_online::ImOnlinePagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn randomness_collective_flip(
        &self,
    ) -> api::randomness_collective_flip::RandomnessCollectiveFlipPagedQueryApi<'api> {
        api::randomness_collective_flip::RandomnessCollectiveFlipPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn sudo(&self) -> api::sudo::SudoPagedQueryApi<'api> {
        api::sudo::SudoPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn asset(&self) -> api::asset::AssetPagedQueryApi<'api> {
        api::asset::AssetPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn capital_distribution(
        &self,
    ) -> api::capital_distribution::CapitalDistributionPagedQueryApi<'api> {
        api::capital_distribution::CapitalDistributionPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn checkpoint(&self) -> api::checkpoint::CheckpointPagedQueryApi<'api> {
        api::checkpoint::CheckpointPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn compliance_manager(
        &self,
    ) -> api::compliance_manager::ComplianceManagerPagedQueryApi<'api> {
        api::compliance_manager::ComplianceManagerPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn corporate_action(&self) -> api::corporate_action::CorporateActionPagedQueryApi<'api> {
        api::corporate_action::CorporateActionPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn corporate_ballot(&self) -> api::corporate_ballot::CorporateBallotPagedQueryApi<'api> {
        api::corporate_ballot::CorporateBallotPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn permissions(&self) -> api::permissions::PermissionsPagedQueryApi<'api> {
        api::permissions::PermissionsPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn pips(&self) -> api::pips::PipsPagedQueryApi<'api> {
        api::pips::PipsPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn portfolio(&self) -> api::portfolio::PortfolioPagedQueryApi<'api> {
        api::portfolio::PortfolioPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn protocol_fee(&self) -> api::protocol_fee::ProtocolFeePagedQueryApi<'api> {
        api::protocol_fee::ProtocolFeePagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn scheduler(&self) -> api::scheduler::SchedulerPagedQueryApi<'api> {
        api::scheduler::SchedulerPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn settlement(&self) -> api::settlement::SettlementPagedQueryApi<'api> {
        api::settlement::SettlementPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn statistics(&self) -> api::statistics::StatisticsPagedQueryApi<'api> {
        api::statistics::StatisticsPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn sto(&self) -> api::sto::StoPagedQueryApi<'api> {
        api::sto::StoPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn treasury(&self) -> api::treasury::TreasuryPagedQueryApi<'api> {
        api::treasury::TreasuryPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn utility(&self) -> api::utility::UtilityPagedQueryApi<'api> {
        api::utility::UtilityPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn base(&self) -> api::base::BasePagedQueryApi<'api> {
        api::base::BasePagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn external_agents(&self) -> api::external_agents::ExternalAgentsPagedQueryApi<'api> {
        api::external_agents::ExternalAgentsPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn relayer(&self) -> api::relayer::RelayerPagedQueryApi<'api> {
        api::relayer::RelayerPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn contracts(&self) -> api::contracts::ContractsPagedQueryApi<'api> {
        api::contracts::ContractsPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn polymesh_contracts(
        &self,
    ) -> api::polymesh_contracts::PolymeshContractsPagedQueryApi<'api> {
        api::polymesh_contracts::PolymeshContractsPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn preimage(&self) -> api::preimage::PreimagePagedQueryApi<'api> {
        api::preimage::PreimagePagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn nft(&self) -> api::nft::NftPagedQueryApi<'api> {
        api::nft::NftPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn election_provider_multi_phase(
        &self,
    ) -> api::election_provider_multi_phase::ElectionProviderMultiPhasePagedQueryApi<'api> {
        api::election_provider_multi_phase::ElectionProviderMultiPhasePagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn polymesh_transaction_payment(
        &self,
    ) -> api::polymesh_transaction_payment::PolymeshTransactionPaymentPagedQueryApi<'api> {
        api::polymesh_transaction_payment::PolymeshTransactionPaymentPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn beefy(&self) -> api::beefy::BeefyPagedQueryApi<'api> {
        api::beefy::BeefyPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn mmr(&self) -> api::mmr::MmrPagedQueryApi<'api> {
        api::mmr::MmrPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
    #[cfg(not(feature = "ink"))]
    pub fn mmr_leaf(&self) -> api::mmr_leaf::MmrLeafPagedQueryApi<'api> {
        api::mmr_leaf::MmrLeafPagedQueryApi {
            api: self.api,
            at: self.at,
        }
    }
}

